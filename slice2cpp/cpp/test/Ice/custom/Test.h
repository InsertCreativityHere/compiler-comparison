//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.7.10
//
// <auto-generated>
//
// Generated from file `Test.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __Test_h__
#define __Test_h__

#include <IceUtil/PushDisableWarnings.h>
#include <Ice/Ice.h>
#include <IceUtil/UndefSysMacros.h>
#include <deque>
#include <list>
#include <MyByteSeq.h>
#include <CustomMap.h>
#include <CustomBuffer.h>
#include <StringView.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 307
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 >= 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 10
#       error Ice patch level mismatch!
#   endif
#endif

#ifdef ICE_CPP11_MAPPING // C++11 mapping

namespace Test
{

class C;
class D;
class DPrx;
class DictClass;
class TestIntf;
class TestIntfPrx;

}

namespace Test
{

using BoolSeq = ::std::vector<bool>;

using BoolList = std::list<bool>;

using BoolListList = std::list< ::Test::BoolList>;

using BoolListSeq = ::std::vector<BoolList>;

using BoolSeqList = std::list< ::Test::BoolSeq>;

using BoolDequeList = std::list<std::deque<bool> >;

using ByteSeq = ::std::vector<::Ice::Byte>;

using ByteList = std::list< ::Ice::Byte>;

using ByteListList = std::list< ::Test::ByteList>;

using ByteListSeq = ::std::vector<ByteList>;

using ByteSeqList = std::list< ::Test::ByteSeq>;

using StringSeq = ::std::vector<::std::string>;

using StringList = std::list<std::string>;

using StringListList = std::list< ::Test::StringList>;

using StringListSeq = ::std::vector<StringList>;

using StringSeqList = std::list< ::Test::StringSeq>;

struct Fixed
{
    short s;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const short&> ice_tuple() const
    {
        return std::tie(s);
    }
};

using FixedSeq = ::std::vector<Fixed>;

using FixedList = std::list< ::Test::Fixed>;

using FixedListList = std::list< ::Test::FixedList>;

using FixedListSeq = ::std::vector<FixedList>;

using FixedSeqList = std::list< ::Test::FixedSeq>;

struct Variable
{
    ::std::string s;
    ::Test::BoolList bl;
    std::list<std::string> ss;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::Test::BoolList&, const std::list<std::string>&> ice_tuple() const
    {
        return std::tie(s, bl, ss);
    }
};

using VariableSeq = ::std::vector<Variable>;

using VariableList = std::list< ::Test::Variable>;

using VariableListList = std::list< ::Test::VariableList>;

using VariableListSeq = ::std::vector<VariableList>;

using VariableSeqList = std::list< ::Test::VariableSeq>;

using StringStringDict = ::std::map<::std::string, ::std::string>;

using StringStringDictSeq = ::std::vector<StringStringDict>;

using StringStringDictList = std::list< ::Test::StringStringDict>;

using StringStringDictListList = std::list< ::Test::StringStringDictList>;

using StringStringDictListSeq = ::std::vector<StringStringDictList>;

using StringStringDictSeqList = std::list< ::Test::StringStringDictSeq>;

enum class E : unsigned char
{
    E1,
    E2,
    E3
};

using ESeq = ::std::vector<E>;

using EList = std::list< ::Test::E>;

using EListList = std::list< ::Test::EList>;

using EListSeq = ::std::vector<EList>;

using ESeqList = std::list< ::Test::ESeq>;

using CSeq = ::std::vector<::std::shared_ptr<C>>;

using CList = std::list<std::shared_ptr<::Test::C>>;

using CListList = std::list< ::Test::CList>;

using CListSeq = ::std::vector<CList>;

using CSeqList = std::list< ::Test::CSeq>;

using DPrxSeq = ::std::vector<::std::shared_ptr<DPrx>>;

using DPrxList = std::list<std::shared_ptr<DPrx>>;

using DPrxListList = std::list< ::Test::DPrxList>;

using DPrxListSeq = ::std::vector<DPrxList>;

using DPrxSeqList = std::list< ::Test::DPrxSeq>;

using DoubleSeq = ::std::vector<double>;

struct ClassOtherStruct
{
    int x;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const int&> ice_tuple() const
    {
        return std::tie(x);
    }
};

using ClassOtherStructSeq = ::std::vector<ClassOtherStruct>;

struct ClassStruct
{
    ::Test::ClassOtherStructSeq otherSeq;
    ::Test::ClassOtherStruct other;
    int y;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::Test::ClassOtherStructSeq&, const ::Test::ClassOtherStruct&, const int&> ice_tuple() const
    {
        return std::tie(otherSeq, other, y);
    }
};

using ClassStructSeq = ::std::vector<ClassStruct>;

using IntStringDict = Test::CustomMap<Ice::Int, std::string>;

using LongLongDict = ::std::map<long long int, long long int>;

using StringIntDict = ::std::map<::std::string, int>;

using BoolBuffer = Test::CustomBuffer<bool>;

using ShortBuffer = Test::CustomBuffer<Ice::Short>;

using IntBuffer = Test::CustomBuffer<Ice::Int>;

using LongBuffer = Test::CustomBuffer<Ice::Long>;

using FloatBuffer = Test::CustomBuffer<Ice::Float>;

using DoubleBuffer = Test::CustomBuffer<Ice::Double>;

using ByteBuffer = Test::CustomBuffer<Ice::Byte>;

struct BufferStruct
{
    ::Test::ByteBuffer byteBuf;
    ::Test::BoolBuffer boolBuf;
    ::Test::ShortBuffer shortBuf;
    ::Test::IntBuffer intBuf;
    ::Test::LongBuffer longBuf;
    ::Test::FloatBuffer floatBuf;
    ::Test::DoubleBuffer doubleBuf;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::Test::ByteBuffer&, const ::Test::BoolBuffer&, const ::Test::ShortBuffer&, const ::Test::IntBuffer&, const ::Test::LongBuffer&, const ::Test::FloatBuffer&, const ::Test::DoubleBuffer&> ice_tuple() const
    {
        return std::tie(byteBuf, boolBuf, shortBuf, intBuf, longBuf, floatBuf, doubleBuf);
    }
};

using Ice::operator<;
using Ice::operator<=;
using Ice::operator>;
using Ice::operator>=;
using Ice::operator==;
using Ice::operator!=;

}

namespace Test
{

class D : public virtual ::Ice::Object
{
public:

    using ProxyType = DPrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();
};

class TestIntf : public virtual ::Ice::Object
{
public:

    using ProxyType = TestIntfPrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /**
     * Encapsulates the results of a call to opDoubleArray.
     */
    struct OpDoubleArrayResult
    {
        DoubleSeq returnValue;
        DoubleSeq outSeq;
    };

    virtual DoubleSeq opDoubleArray(::std::pair<const double*, const double*> inSeq, DoubleSeq& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opDoubleArray(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opBoolArray.
     */
    struct OpBoolArrayResult
    {
        BoolSeq returnValue;
        BoolSeq outSeq;
    };

    virtual BoolSeq opBoolArray(::std::pair<const bool*, const bool*> inSeq, BoolSeq& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opBoolArray(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opByteArray.
     */
    struct OpByteArrayResult
    {
        ByteList returnValue;
        ByteList outSeq;
    };

    virtual ByteList opByteArray(::std::pair<const ::Ice::Byte*, const ::Ice::Byte*> inSeq, ByteList& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opByteArray(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opVariableArray.
     */
    struct OpVariableArrayResult
    {
        VariableList returnValue;
        VariableList outSeq;
    };

    virtual VariableList opVariableArray(::std::pair<const Variable*, const Variable*> inSeq, VariableList& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opVariableArray(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opBoolRange.
     */
    struct OpBoolRangeResult
    {
        BoolSeq returnValue;
        BoolSeq outSeq;
    };

    virtual BoolSeq opBoolRange(BoolSeq inSeq, BoolSeq& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opBoolRange(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opByteRange.
     */
    struct OpByteRangeResult
    {
        ByteList returnValue;
        ByteList outSeq;
    };

    virtual ByteList opByteRange(ByteList inSeq, ByteList& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opByteRange(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opVariableRange.
     */
    struct OpVariableRangeResult
    {
        VariableList returnValue;
        VariableList outSeq;
    };

    virtual VariableList opVariableRange(VariableList inSeq, VariableList& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opVariableRange(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opByteRangeType.
     */
    struct OpByteRangeTypeResult
    {
        ByteList returnValue;
        ByteList outSeq;
    };

    virtual ByteList opByteRangeType(ByteList inSeq, ByteList& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opByteRangeType(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opVariableRangeType.
     */
    struct OpVariableRangeTypeResult
    {
        VariableList returnValue;
        VariableList outSeq;
    };

    virtual VariableList opVariableRangeType(VariableList inSeq, VariableList& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opVariableRangeType(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opBoolSeq.
     */
    struct OpBoolSeqResult
    {
        std::deque<bool> returnValue;
        std::deque<bool> outSeq;
    };

    virtual std::deque<bool> opBoolSeq(std::deque<bool> inSeq, std::deque<bool>& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opBoolSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opBoolList.
     */
    struct OpBoolListResult
    {
        BoolList returnValue;
        BoolList outSeq;
    };

    virtual BoolList opBoolList(BoolList inSeq, BoolList& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opBoolList(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opBoolDequeList.
     */
    struct OpBoolDequeListResult
    {
        BoolDequeList returnValue;
        BoolDequeList outSeq;
    };

    virtual BoolDequeList opBoolDequeList(BoolDequeList inSeq, BoolDequeList& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opBoolDequeList(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opBoolDequeListArray.
     */
    struct OpBoolDequeListArrayResult
    {
        BoolDequeList returnValue;
        BoolDequeList outSeq;
    };

    virtual BoolDequeList opBoolDequeListArray(::std::pair<const std::deque<bool>*, const std::deque<bool>*> inSeq, BoolDequeList& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opBoolDequeListArray(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opBoolDequeListRange.
     */
    struct OpBoolDequeListRangeResult
    {
        BoolDequeList returnValue;
        BoolDequeList outSeq;
    };

    virtual BoolDequeList opBoolDequeListRange(BoolDequeList inSeq, BoolDequeList& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opBoolDequeListRange(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opByteSeq.
     */
    struct OpByteSeqResult
    {
        std::deque< ::Ice::Byte> returnValue;
        std::deque< ::Ice::Byte> outSeq;
    };

    virtual std::deque< ::Ice::Byte> opByteSeq(std::deque< ::Ice::Byte> inSeq, std::deque< ::Ice::Byte>& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opByteSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opByteList.
     */
    struct OpByteListResult
    {
        ByteList returnValue;
        ByteList outSeq;
    };

    virtual ByteList opByteList(ByteList inSeq, ByteList& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opByteList(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opMyByteSeq.
     */
    struct OpMyByteSeqResult
    {
        MyByteSeq returnValue;
        MyByteSeq outSeq;
    };

    virtual MyByteSeq opMyByteSeq(MyByteSeq inSeq, MyByteSeq& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opMyByteSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opString.
     */
    struct OpStringResult
    {
        ::std::string returnValue;
        ::std::string outString;
    };

    virtual ::std::string opString(Util::string_view inString, ::std::string& outString, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opString(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opStringSeq.
     */
    struct OpStringSeqResult
    {
        std::deque<std::string> returnValue;
        std::deque<std::string> outSeq;
    };

    virtual std::deque<std::string> opStringSeq(std::deque<std::string> inSeq, std::deque<std::string>& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opStringSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opStringList.
     */
    struct OpStringListResult
    {
        StringList returnValue;
        StringList outSeq;
    };

    virtual StringList opStringList(StringList inSeq, StringList& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opStringList(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opFixedSeq.
     */
    struct OpFixedSeqResult
    {
        std::deque< ::Test::Fixed> returnValue;
        std::deque< ::Test::Fixed> outSeq;
    };

    virtual std::deque< ::Test::Fixed> opFixedSeq(std::deque< ::Test::Fixed> inSeq, std::deque< ::Test::Fixed>& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opFixedSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opFixedList.
     */
    struct OpFixedListResult
    {
        FixedList returnValue;
        FixedList outSeq;
    };

    virtual FixedList opFixedList(FixedList inSeq, FixedList& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opFixedList(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opVariableSeq.
     */
    struct OpVariableSeqResult
    {
        std::deque< ::Test::Variable> returnValue;
        std::deque< ::Test::Variable> outSeq;
    };

    virtual std::deque< ::Test::Variable> opVariableSeq(std::deque< ::Test::Variable> inSeq, std::deque< ::Test::Variable>& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opVariableSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opVariableList.
     */
    struct OpVariableListResult
    {
        VariableList returnValue;
        VariableList outSeq;
    };

    virtual VariableList opVariableList(VariableList inSeq, VariableList& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opVariableList(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opStringStringDictSeq.
     */
    struct OpStringStringDictSeqResult
    {
        std::deque< ::Test::StringStringDict> returnValue;
        std::deque< ::Test::StringStringDict> outSeq;
    };

    virtual std::deque< ::Test::StringStringDict> opStringStringDictSeq(std::deque< ::Test::StringStringDict> inSeq, std::deque< ::Test::StringStringDict>& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opStringStringDictSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opStringStringDictList.
     */
    struct OpStringStringDictListResult
    {
        StringStringDictList returnValue;
        StringStringDictList outSeq;
    };

    virtual StringStringDictList opStringStringDictList(StringStringDictList inSeq, StringStringDictList& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opStringStringDictList(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opESeq.
     */
    struct OpESeqResult
    {
        std::deque< ::Test::E> returnValue;
        std::deque< ::Test::E> outSeq;
    };

    virtual std::deque< ::Test::E> opESeq(std::deque< ::Test::E> inSeq, std::deque< ::Test::E>& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opESeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opEList.
     */
    struct OpEListResult
    {
        EList returnValue;
        EList outSeq;
    };

    virtual EList opEList(EList inSeq, EList& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opEList(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opDPrxSeq.
     */
    struct OpDPrxSeqResult
    {
        std::deque<std::shared_ptr<::Test::DPrx>> returnValue;
        std::deque<std::shared_ptr<::Test::DPrx>> outSeq;
    };

    virtual std::deque<std::shared_ptr<::Test::DPrx>> opDPrxSeq(std::deque<std::shared_ptr<::Test::DPrx>> inSeq, std::deque<std::shared_ptr<::Test::DPrx>>& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opDPrxSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opDPrxList.
     */
    struct OpDPrxListResult
    {
        DPrxList returnValue;
        DPrxList outSeq;
    };

    virtual DPrxList opDPrxList(DPrxList inSeq, DPrxList& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opDPrxList(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opCSeq.
     */
    struct OpCSeqResult
    {
        std::deque<std::shared_ptr<Test::C>> returnValue;
        std::deque<std::shared_ptr<Test::C>> outSeq;
    };

    virtual std::deque<std::shared_ptr<Test::C>> opCSeq(std::deque<std::shared_ptr<Test::C>> inSeq, std::deque<std::shared_ptr<Test::C>>& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opCSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opCList.
     */
    struct OpCListResult
    {
        CList returnValue;
        CList outSeq;
    };

    virtual CList opCList(CList inSeq, CList& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opCList(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opClassStruct.
     */
    struct OpClassStructResult
    {
        ClassStruct returnValue;
        ClassStruct outS;
        ClassStructSeq outSeq;
    };

    virtual ClassStruct opClassStruct(ClassStruct inS, ClassStructSeq inSeq, ClassStruct& outS, ClassStructSeq& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opClassStruct(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opOutArrayByteSeq(ByteSeq org, ByteSeq& copy, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opOutArrayByteSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opOutRangeByteSeq(ByteSeq org, ByteSeq& copy, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opOutRangeByteSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opIntStringDict.
     */
    struct OpIntStringDictResult
    {
        IntStringDict returnValue;
        IntStringDict odict;
    };

    virtual IntStringDict opIntStringDict(IntStringDict idict, IntStringDict& odict, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opIntStringDict(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opVarDict.
     */
    struct OpVarDictResult
    {
        ::Test::CustomMap< ::Ice::Long, ::Ice::Long> returnValue;
        ::Test::CustomMap<std::string, ::Ice::Int> odict;
    };

    virtual ::Test::CustomMap< ::Ice::Long, ::Ice::Long> opVarDict(::Test::CustomMap<std::string, ::Ice::Int> idict, ::Test::CustomMap<std::string, ::Ice::Int>& odict, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opVarDict(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opCustomIntStringDict.
     */
    struct OpCustomIntStringDictResult
    {
        ::Test::CustomMap< ::Ice::Int, std::string> returnValue;
        ::Test::CustomMap< ::Ice::Int, std::string> odict;
    };

    virtual ::Test::CustomMap< ::Ice::Int, std::string> opCustomIntStringDict(::std::map< ::Ice::Int, ::Util::string_view> idict, ::Test::CustomMap< ::Ice::Int, std::string>& odict, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opCustomIntStringDict(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opShortBuffer.
     */
    struct OpShortBufferResult
    {
        ShortBuffer returnValue;
        ShortBuffer outS;
    };

    virtual ShortBuffer opShortBuffer(ShortBuffer inS, ShortBuffer& outS, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opShortBuffer(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opBoolBuffer.
     */
    struct OpBoolBufferResult
    {
        ::Test::CustomBuffer<bool> returnValue;
        ::Test::CustomBuffer<bool> outS;
    };

    virtual ::Test::CustomBuffer<bool> opBoolBuffer(::Test::CustomBuffer<bool> inS, ::Test::CustomBuffer<bool>& outS, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opBoolBuffer(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual BufferStruct opBufferStruct(BufferStruct s, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opBufferStruct(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void shutdown(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_shutdown(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

}

namespace Test
{

class C : public ::Ice::ValueHelper<C, ::Ice::Value>
{
public:

    virtual ~C();

    C() = default;

    C(const C&) = default;
    C(C&&) = default;
    C& operator=(const C&) = default;
    C& operator=(C&&) = default;

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<> ice_tuple() const
    {
        return std::tie();
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();
};

/// \cond INTERNAL
static C _iceS_C_init;
/// \endcond

class DictClass : public ::Ice::ValueHelper<DictClass, ::Ice::Value>
{
public:

    virtual ~DictClass();

    DictClass() = default;

    DictClass(const DictClass&) = default;
    DictClass(DictClass&&) = default;
    DictClass& operator=(const DictClass&) = default;
    DictClass& operator=(DictClass&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit DictClass(const ::Test::IntStringDict& isdict) :
        isdict(isdict)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::Test::IntStringDict&> ice_tuple() const
    {
        return std::tie(isdict);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::Test::IntStringDict isdict;
};

}

namespace Test
{

class DPrx : public virtual ::Ice::Proxy<DPrx, ::Ice::ObjectPrx>
{
public:

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    DPrx() = default;
    friend ::std::shared_ptr<DPrx> IceInternal::createProxy<DPrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

class TestIntfPrx : public virtual ::Ice::Proxy<TestIntfPrx, ::Ice::ObjectPrx>
{
public:

    DoubleSeq opDoubleArray(const ::std::pair<const double*, const double*>& inSeq, DoubleSeq& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpDoubleArrayResult>(true, this, &TestIntfPrx::_iceI_opDoubleArray, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opDoubleArrayAsync(const ::std::pair<const double*, const double*>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpDoubleArrayResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpDoubleArrayResult, P>(false, this, &TestIntfPrx::_iceI_opDoubleArray, inSeq, context);
    }

    ::std::function<void()>
    opDoubleArrayAsync(const ::std::pair<const double*, const double*>& inSeq,
                       ::std::function<void(::std::pair<const double*, const double*>, ::std::pair<const double*, const double*>)> response,
                       ::std::function<void(::std::exception_ptr)> ex = nullptr,
                       ::std::function<void(bool)> sent = nullptr,
                       const ::Ice::Context& context = ::Ice::noExplicitContext);

    /// \cond INTERNAL
    void _iceI_opDoubleArray(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpDoubleArrayResult>>&, const ::std::pair<const double*, const double*>&, const ::Ice::Context&);
    /// \endcond

    BoolSeq opBoolArray(const ::std::pair<const bool*, const bool*>& inSeq, BoolSeq& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpBoolArrayResult>(true, this, &TestIntfPrx::_iceI_opBoolArray, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opBoolArrayAsync(const ::std::pair<const bool*, const bool*>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpBoolArrayResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpBoolArrayResult, P>(false, this, &TestIntfPrx::_iceI_opBoolArray, inSeq, context);
    }

    ::std::function<void()>
    opBoolArrayAsync(const ::std::pair<const bool*, const bool*>& inSeq,
                     ::std::function<void(::std::pair<const bool*, const bool*>, ::std::pair<const bool*, const bool*>)> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext);

    /// \cond INTERNAL
    void _iceI_opBoolArray(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpBoolArrayResult>>&, const ::std::pair<const bool*, const bool*>&, const ::Ice::Context&);
    /// \endcond

    ByteList opByteArray(const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>& inSeq, ByteList& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpByteArrayResult>(true, this, &TestIntfPrx::_iceI_opByteArray, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opByteArrayAsync(const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpByteArrayResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpByteArrayResult, P>(false, this, &TestIntfPrx::_iceI_opByteArray, inSeq, context);
    }

    ::std::function<void()>
    opByteArrayAsync(const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>& inSeq,
                     ::std::function<void(::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>, ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>)> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext);

    /// \cond INTERNAL
    void _iceI_opByteArray(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpByteArrayResult>>&, const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>&, const ::Ice::Context&);
    /// \endcond

    VariableList opVariableArray(const ::std::pair<const Variable*, const Variable*>& inSeq, VariableList& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpVariableArrayResult>(true, this, &TestIntfPrx::_iceI_opVariableArray, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opVariableArrayAsync(const ::std::pair<const Variable*, const Variable*>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpVariableArrayResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpVariableArrayResult, P>(false, this, &TestIntfPrx::_iceI_opVariableArray, inSeq, context);
    }

    ::std::function<void()>
    opVariableArrayAsync(const ::std::pair<const Variable*, const Variable*>& inSeq,
                         ::std::function<void(::std::pair<const ::Test::Variable*, const ::Test::Variable*>, ::std::pair<const ::Test::Variable*, const ::Test::Variable*>)> response,
                         ::std::function<void(::std::exception_ptr)> ex = nullptr,
                         ::std::function<void(bool)> sent = nullptr,
                         const ::Ice::Context& context = ::Ice::noExplicitContext);

    /// \cond INTERNAL
    void _iceI_opVariableArray(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpVariableArrayResult>>&, const ::std::pair<const Variable*, const Variable*>&, const ::Ice::Context&);
    /// \endcond

    BoolSeq opBoolRange(const BoolSeq& inSeq, BoolSeq& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpBoolRangeResult>(true, this, &TestIntfPrx::_iceI_opBoolRange, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opBoolRangeAsync(const BoolSeq& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpBoolRangeResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpBoolRangeResult, P>(false, this, &TestIntfPrx::_iceI_opBoolRange, inSeq, context);
    }

    ::std::function<void()>
    opBoolRangeAsync(const BoolSeq& inSeq,
                     ::std::function<void(::Test::BoolSeq, ::Test::BoolSeq)> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpBoolRangeResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpBoolRangeResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opBoolRange, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opBoolRange(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpBoolRangeResult>>&, const BoolSeq&, const ::Ice::Context&);
    /// \endcond

    ByteList opByteRange(const ByteList& inSeq, ByteList& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpByteRangeResult>(true, this, &TestIntfPrx::_iceI_opByteRange, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opByteRangeAsync(const ByteList& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpByteRangeResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpByteRangeResult, P>(false, this, &TestIntfPrx::_iceI_opByteRange, inSeq, context);
    }

    ::std::function<void()>
    opByteRangeAsync(const ByteList& inSeq,
                     ::std::function<void(::Test::ByteList, ::Test::ByteList)> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpByteRangeResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpByteRangeResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opByteRange, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opByteRange(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpByteRangeResult>>&, const ByteList&, const ::Ice::Context&);
    /// \endcond

    VariableList opVariableRange(const VariableList& inSeq, VariableList& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpVariableRangeResult>(true, this, &TestIntfPrx::_iceI_opVariableRange, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opVariableRangeAsync(const VariableList& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpVariableRangeResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpVariableRangeResult, P>(false, this, &TestIntfPrx::_iceI_opVariableRange, inSeq, context);
    }

    ::std::function<void()>
    opVariableRangeAsync(const VariableList& inSeq,
                         ::std::function<void(::Test::VariableList, ::Test::VariableList)> response,
                         ::std::function<void(::std::exception_ptr)> ex = nullptr,
                         ::std::function<void(bool)> sent = nullptr,
                         const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpVariableRangeResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpVariableRangeResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opVariableRange, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opVariableRange(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpVariableRangeResult>>&, const VariableList&, const ::Ice::Context&);
    /// \endcond

    ByteList opByteRangeType(const ByteList& inSeq, ByteList& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpByteRangeTypeResult>(true, this, &TestIntfPrx::_iceI_opByteRangeType, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opByteRangeTypeAsync(const ByteList& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpByteRangeTypeResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpByteRangeTypeResult, P>(false, this, &TestIntfPrx::_iceI_opByteRangeType, inSeq, context);
    }

    ::std::function<void()>
    opByteRangeTypeAsync(const ByteList& inSeq,
                         ::std::function<void(::Test::ByteList, ::Test::ByteList)> response,
                         ::std::function<void(::std::exception_ptr)> ex = nullptr,
                         ::std::function<void(bool)> sent = nullptr,
                         const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpByteRangeTypeResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpByteRangeTypeResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opByteRangeType, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opByteRangeType(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpByteRangeTypeResult>>&, const ByteList&, const ::Ice::Context&);
    /// \endcond

    VariableList opVariableRangeType(const VariableList& inSeq, VariableList& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpVariableRangeTypeResult>(true, this, &TestIntfPrx::_iceI_opVariableRangeType, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opVariableRangeTypeAsync(const VariableList& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpVariableRangeTypeResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpVariableRangeTypeResult, P>(false, this, &TestIntfPrx::_iceI_opVariableRangeType, inSeq, context);
    }

    ::std::function<void()>
    opVariableRangeTypeAsync(const VariableList& inSeq,
                             ::std::function<void(::Test::VariableList, ::Test::VariableList)> response,
                             ::std::function<void(::std::exception_ptr)> ex = nullptr,
                             ::std::function<void(bool)> sent = nullptr,
                             const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpVariableRangeTypeResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpVariableRangeTypeResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opVariableRangeType, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opVariableRangeType(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpVariableRangeTypeResult>>&, const VariableList&, const ::Ice::Context&);
    /// \endcond

    std::deque<bool> opBoolSeq(const std::deque<bool>& inSeq, std::deque<bool>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpBoolSeqResult>(true, this, &TestIntfPrx::_iceI_opBoolSeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opBoolSeqAsync(const std::deque<bool>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpBoolSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpBoolSeqResult, P>(false, this, &TestIntfPrx::_iceI_opBoolSeq, inSeq, context);
    }

    ::std::function<void()>
    opBoolSeqAsync(const std::deque<bool>& inSeq,
                   ::std::function<void(std::deque<bool>, std::deque<bool>)> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpBoolSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpBoolSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opBoolSeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opBoolSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpBoolSeqResult>>&, const std::deque<bool>&, const ::Ice::Context&);
    /// \endcond

    BoolList opBoolList(const BoolList& inSeq, BoolList& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpBoolListResult>(true, this, &TestIntfPrx::_iceI_opBoolList, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opBoolListAsync(const BoolList& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpBoolListResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpBoolListResult, P>(false, this, &TestIntfPrx::_iceI_opBoolList, inSeq, context);
    }

    ::std::function<void()>
    opBoolListAsync(const BoolList& inSeq,
                    ::std::function<void(::Test::BoolList, ::Test::BoolList)> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpBoolListResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpBoolListResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opBoolList, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opBoolList(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpBoolListResult>>&, const BoolList&, const ::Ice::Context&);
    /// \endcond

    BoolDequeList opBoolDequeList(const BoolDequeList& inSeq, BoolDequeList& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpBoolDequeListResult>(true, this, &TestIntfPrx::_iceI_opBoolDequeList, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opBoolDequeListAsync(const BoolDequeList& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpBoolDequeListResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpBoolDequeListResult, P>(false, this, &TestIntfPrx::_iceI_opBoolDequeList, inSeq, context);
    }

    ::std::function<void()>
    opBoolDequeListAsync(const BoolDequeList& inSeq,
                         ::std::function<void(::Test::BoolDequeList, ::Test::BoolDequeList)> response,
                         ::std::function<void(::std::exception_ptr)> ex = nullptr,
                         ::std::function<void(bool)> sent = nullptr,
                         const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpBoolDequeListResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpBoolDequeListResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opBoolDequeList, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opBoolDequeList(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpBoolDequeListResult>>&, const BoolDequeList&, const ::Ice::Context&);
    /// \endcond

    BoolDequeList opBoolDequeListArray(const ::std::pair<const std::deque<bool>*, const std::deque<bool>*>& inSeq, BoolDequeList& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpBoolDequeListArrayResult>(true, this, &TestIntfPrx::_iceI_opBoolDequeListArray, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opBoolDequeListArrayAsync(const ::std::pair<const std::deque<bool>*, const std::deque<bool>*>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpBoolDequeListArrayResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpBoolDequeListArrayResult, P>(false, this, &TestIntfPrx::_iceI_opBoolDequeListArray, inSeq, context);
    }

    ::std::function<void()>
    opBoolDequeListArrayAsync(const ::std::pair<const std::deque<bool>*, const std::deque<bool>*>& inSeq,
                              ::std::function<void(::std::pair<const std::deque<bool>*, const std::deque<bool>*>, ::std::pair<const std::deque<bool>*, const std::deque<bool>*>)> response,
                              ::std::function<void(::std::exception_ptr)> ex = nullptr,
                              ::std::function<void(bool)> sent = nullptr,
                              const ::Ice::Context& context = ::Ice::noExplicitContext);

    /// \cond INTERNAL
    void _iceI_opBoolDequeListArray(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpBoolDequeListArrayResult>>&, const ::std::pair<const std::deque<bool>*, const std::deque<bool>*>&, const ::Ice::Context&);
    /// \endcond

    BoolDequeList opBoolDequeListRange(const BoolDequeList& inSeq, BoolDequeList& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpBoolDequeListRangeResult>(true, this, &TestIntfPrx::_iceI_opBoolDequeListRange, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opBoolDequeListRangeAsync(const BoolDequeList& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpBoolDequeListRangeResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpBoolDequeListRangeResult, P>(false, this, &TestIntfPrx::_iceI_opBoolDequeListRange, inSeq, context);
    }

    ::std::function<void()>
    opBoolDequeListRangeAsync(const BoolDequeList& inSeq,
                              ::std::function<void(::Test::BoolDequeList, ::Test::BoolDequeList)> response,
                              ::std::function<void(::std::exception_ptr)> ex = nullptr,
                              ::std::function<void(bool)> sent = nullptr,
                              const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpBoolDequeListRangeResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpBoolDequeListRangeResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opBoolDequeListRange, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opBoolDequeListRange(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpBoolDequeListRangeResult>>&, const BoolDequeList&, const ::Ice::Context&);
    /// \endcond

    std::deque< ::Ice::Byte> opByteSeq(const std::deque< ::Ice::Byte>& inSeq, std::deque< ::Ice::Byte>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpByteSeqResult>(true, this, &TestIntfPrx::_iceI_opByteSeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opByteSeqAsync(const std::deque< ::Ice::Byte>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpByteSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpByteSeqResult, P>(false, this, &TestIntfPrx::_iceI_opByteSeq, inSeq, context);
    }

    ::std::function<void()>
    opByteSeqAsync(const std::deque< ::Ice::Byte>& inSeq,
                   ::std::function<void(std::deque< ::Ice::Byte>, std::deque< ::Ice::Byte>)> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpByteSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpByteSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opByteSeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opByteSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpByteSeqResult>>&, const std::deque< ::Ice::Byte>&, const ::Ice::Context&);
    /// \endcond

    ByteList opByteList(const ByteList& inSeq, ByteList& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpByteListResult>(true, this, &TestIntfPrx::_iceI_opByteList, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opByteListAsync(const ByteList& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpByteListResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpByteListResult, P>(false, this, &TestIntfPrx::_iceI_opByteList, inSeq, context);
    }

    ::std::function<void()>
    opByteListAsync(const ByteList& inSeq,
                    ::std::function<void(::Test::ByteList, ::Test::ByteList)> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpByteListResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpByteListResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opByteList, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opByteList(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpByteListResult>>&, const ByteList&, const ::Ice::Context&);
    /// \endcond

    MyByteSeq opMyByteSeq(const MyByteSeq& inSeq, MyByteSeq& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpMyByteSeqResult>(true, this, &TestIntfPrx::_iceI_opMyByteSeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opMyByteSeqAsync(const MyByteSeq& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpMyByteSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpMyByteSeqResult, P>(false, this, &TestIntfPrx::_iceI_opMyByteSeq, inSeq, context);
    }

    ::std::function<void()>
    opMyByteSeqAsync(const MyByteSeq& inSeq,
                     ::std::function<void(MyByteSeq, MyByteSeq)> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpMyByteSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpMyByteSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opMyByteSeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opMyByteSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpMyByteSeqResult>>&, const MyByteSeq&, const ::Ice::Context&);
    /// \endcond

    ::std::string opString(const Util::string_view& inString, ::std::string& outString, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpStringResult>(true, this, &TestIntfPrx::_iceI_opString, inString, context).get();
        outString = ::std::move(_result.outString);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opStringAsync(const Util::string_view& inString, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpStringResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpStringResult, P>(false, this, &TestIntfPrx::_iceI_opString, inString, context);
    }

    ::std::function<void()>
    opStringAsync(const Util::string_view& inString,
                  ::std::function<void(Util::string_view, Util::string_view)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext);

    /// \cond INTERNAL
    void _iceI_opString(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpStringResult>>&, const Util::string_view&, const ::Ice::Context&);
    /// \endcond

    std::deque<std::string> opStringSeq(const std::deque<std::string>& inSeq, std::deque<std::string>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpStringSeqResult>(true, this, &TestIntfPrx::_iceI_opStringSeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opStringSeqAsync(const std::deque<std::string>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpStringSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpStringSeqResult, P>(false, this, &TestIntfPrx::_iceI_opStringSeq, inSeq, context);
    }

    ::std::function<void()>
    opStringSeqAsync(const std::deque<std::string>& inSeq,
                     ::std::function<void(std::deque<std::string>, std::deque<std::string>)> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpStringSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpStringSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opStringSeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opStringSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpStringSeqResult>>&, const std::deque<std::string>&, const ::Ice::Context&);
    /// \endcond

    StringList opStringList(const StringList& inSeq, StringList& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpStringListResult>(true, this, &TestIntfPrx::_iceI_opStringList, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opStringListAsync(const StringList& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpStringListResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpStringListResult, P>(false, this, &TestIntfPrx::_iceI_opStringList, inSeq, context);
    }

    ::std::function<void()>
    opStringListAsync(const StringList& inSeq,
                      ::std::function<void(::Test::StringList, ::Test::StringList)> response,
                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                      ::std::function<void(bool)> sent = nullptr,
                      const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpStringListResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpStringListResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opStringList, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opStringList(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpStringListResult>>&, const StringList&, const ::Ice::Context&);
    /// \endcond

    std::deque< ::Test::Fixed> opFixedSeq(const std::deque< ::Test::Fixed>& inSeq, std::deque< ::Test::Fixed>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpFixedSeqResult>(true, this, &TestIntfPrx::_iceI_opFixedSeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opFixedSeqAsync(const std::deque< ::Test::Fixed>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpFixedSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpFixedSeqResult, P>(false, this, &TestIntfPrx::_iceI_opFixedSeq, inSeq, context);
    }

    ::std::function<void()>
    opFixedSeqAsync(const std::deque< ::Test::Fixed>& inSeq,
                    ::std::function<void(std::deque< ::Test::Fixed>, std::deque< ::Test::Fixed>)> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpFixedSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpFixedSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opFixedSeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opFixedSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpFixedSeqResult>>&, const std::deque< ::Test::Fixed>&, const ::Ice::Context&);
    /// \endcond

    FixedList opFixedList(const FixedList& inSeq, FixedList& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpFixedListResult>(true, this, &TestIntfPrx::_iceI_opFixedList, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opFixedListAsync(const FixedList& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpFixedListResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpFixedListResult, P>(false, this, &TestIntfPrx::_iceI_opFixedList, inSeq, context);
    }

    ::std::function<void()>
    opFixedListAsync(const FixedList& inSeq,
                     ::std::function<void(::Test::FixedList, ::Test::FixedList)> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpFixedListResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpFixedListResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opFixedList, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opFixedList(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpFixedListResult>>&, const FixedList&, const ::Ice::Context&);
    /// \endcond

    std::deque< ::Test::Variable> opVariableSeq(const std::deque< ::Test::Variable>& inSeq, std::deque< ::Test::Variable>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpVariableSeqResult>(true, this, &TestIntfPrx::_iceI_opVariableSeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opVariableSeqAsync(const std::deque< ::Test::Variable>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpVariableSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpVariableSeqResult, P>(false, this, &TestIntfPrx::_iceI_opVariableSeq, inSeq, context);
    }

    ::std::function<void()>
    opVariableSeqAsync(const std::deque< ::Test::Variable>& inSeq,
                       ::std::function<void(std::deque< ::Test::Variable>, std::deque< ::Test::Variable>)> response,
                       ::std::function<void(::std::exception_ptr)> ex = nullptr,
                       ::std::function<void(bool)> sent = nullptr,
                       const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpVariableSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpVariableSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opVariableSeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opVariableSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpVariableSeqResult>>&, const std::deque< ::Test::Variable>&, const ::Ice::Context&);
    /// \endcond

    VariableList opVariableList(const VariableList& inSeq, VariableList& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpVariableListResult>(true, this, &TestIntfPrx::_iceI_opVariableList, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opVariableListAsync(const VariableList& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpVariableListResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpVariableListResult, P>(false, this, &TestIntfPrx::_iceI_opVariableList, inSeq, context);
    }

    ::std::function<void()>
    opVariableListAsync(const VariableList& inSeq,
                        ::std::function<void(::Test::VariableList, ::Test::VariableList)> response,
                        ::std::function<void(::std::exception_ptr)> ex = nullptr,
                        ::std::function<void(bool)> sent = nullptr,
                        const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpVariableListResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpVariableListResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opVariableList, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opVariableList(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpVariableListResult>>&, const VariableList&, const ::Ice::Context&);
    /// \endcond

    std::deque< ::Test::StringStringDict> opStringStringDictSeq(const std::deque< ::Test::StringStringDict>& inSeq, std::deque< ::Test::StringStringDict>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpStringStringDictSeqResult>(true, this, &TestIntfPrx::_iceI_opStringStringDictSeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opStringStringDictSeqAsync(const std::deque< ::Test::StringStringDict>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpStringStringDictSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpStringStringDictSeqResult, P>(false, this, &TestIntfPrx::_iceI_opStringStringDictSeq, inSeq, context);
    }

    ::std::function<void()>
    opStringStringDictSeqAsync(const std::deque< ::Test::StringStringDict>& inSeq,
                               ::std::function<void(std::deque< ::Test::StringStringDict>, std::deque< ::Test::StringStringDict>)> response,
                               ::std::function<void(::std::exception_ptr)> ex = nullptr,
                               ::std::function<void(bool)> sent = nullptr,
                               const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpStringStringDictSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpStringStringDictSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opStringStringDictSeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opStringStringDictSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpStringStringDictSeqResult>>&, const std::deque< ::Test::StringStringDict>&, const ::Ice::Context&);
    /// \endcond

    StringStringDictList opStringStringDictList(const StringStringDictList& inSeq, StringStringDictList& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpStringStringDictListResult>(true, this, &TestIntfPrx::_iceI_opStringStringDictList, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opStringStringDictListAsync(const StringStringDictList& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpStringStringDictListResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpStringStringDictListResult, P>(false, this, &TestIntfPrx::_iceI_opStringStringDictList, inSeq, context);
    }

    ::std::function<void()>
    opStringStringDictListAsync(const StringStringDictList& inSeq,
                                ::std::function<void(::Test::StringStringDictList, ::Test::StringStringDictList)> response,
                                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                                ::std::function<void(bool)> sent = nullptr,
                                const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpStringStringDictListResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpStringStringDictListResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opStringStringDictList, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opStringStringDictList(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpStringStringDictListResult>>&, const StringStringDictList&, const ::Ice::Context&);
    /// \endcond

    std::deque< ::Test::E> opESeq(const std::deque< ::Test::E>& inSeq, std::deque< ::Test::E>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpESeqResult>(true, this, &TestIntfPrx::_iceI_opESeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opESeqAsync(const std::deque< ::Test::E>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpESeqResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpESeqResult, P>(false, this, &TestIntfPrx::_iceI_opESeq, inSeq, context);
    }

    ::std::function<void()>
    opESeqAsync(const std::deque< ::Test::E>& inSeq,
                ::std::function<void(std::deque< ::Test::E>, std::deque< ::Test::E>)> response,
                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                ::std::function<void(bool)> sent = nullptr,
                const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpESeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpESeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opESeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opESeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpESeqResult>>&, const std::deque< ::Test::E>&, const ::Ice::Context&);
    /// \endcond

    EList opEList(const EList& inSeq, EList& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpEListResult>(true, this, &TestIntfPrx::_iceI_opEList, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opEListAsync(const EList& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpEListResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpEListResult, P>(false, this, &TestIntfPrx::_iceI_opEList, inSeq, context);
    }

    ::std::function<void()>
    opEListAsync(const EList& inSeq,
                 ::std::function<void(::Test::EList, ::Test::EList)> response,
                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                 ::std::function<void(bool)> sent = nullptr,
                 const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpEListResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpEListResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opEList, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opEList(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpEListResult>>&, const EList&, const ::Ice::Context&);
    /// \endcond

    std::deque<std::shared_ptr<::Test::DPrx>> opDPrxSeq(const std::deque<std::shared_ptr<::Test::DPrx>>& inSeq, std::deque<std::shared_ptr<::Test::DPrx>>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpDPrxSeqResult>(true, this, &TestIntfPrx::_iceI_opDPrxSeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opDPrxSeqAsync(const std::deque<std::shared_ptr<::Test::DPrx>>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpDPrxSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpDPrxSeqResult, P>(false, this, &TestIntfPrx::_iceI_opDPrxSeq, inSeq, context);
    }

    ::std::function<void()>
    opDPrxSeqAsync(const std::deque<std::shared_ptr<::Test::DPrx>>& inSeq,
                   ::std::function<void(std::deque<std::shared_ptr<::Test::DPrx>>, std::deque<std::shared_ptr<::Test::DPrx>>)> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpDPrxSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpDPrxSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opDPrxSeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opDPrxSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpDPrxSeqResult>>&, const std::deque<std::shared_ptr<::Test::DPrx>>&, const ::Ice::Context&);
    /// \endcond

    DPrxList opDPrxList(const DPrxList& inSeq, DPrxList& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpDPrxListResult>(true, this, &TestIntfPrx::_iceI_opDPrxList, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opDPrxListAsync(const DPrxList& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpDPrxListResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpDPrxListResult, P>(false, this, &TestIntfPrx::_iceI_opDPrxList, inSeq, context);
    }

    ::std::function<void()>
    opDPrxListAsync(const DPrxList& inSeq,
                    ::std::function<void(::Test::DPrxList, ::Test::DPrxList)> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpDPrxListResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpDPrxListResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opDPrxList, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opDPrxList(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpDPrxListResult>>&, const DPrxList&, const ::Ice::Context&);
    /// \endcond

    std::deque<std::shared_ptr<Test::C>> opCSeq(const std::deque<std::shared_ptr<Test::C>>& inSeq, std::deque<std::shared_ptr<Test::C>>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpCSeqResult>(true, this, &TestIntfPrx::_iceI_opCSeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opCSeqAsync(const std::deque<std::shared_ptr<Test::C>>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpCSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpCSeqResult, P>(false, this, &TestIntfPrx::_iceI_opCSeq, inSeq, context);
    }

    ::std::function<void()>
    opCSeqAsync(const std::deque<std::shared_ptr<Test::C>>& inSeq,
                ::std::function<void(std::deque<std::shared_ptr<Test::C>>, std::deque<std::shared_ptr<Test::C>>)> response,
                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                ::std::function<void(bool)> sent = nullptr,
                const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpCSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpCSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opCSeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opCSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpCSeqResult>>&, const std::deque<std::shared_ptr<Test::C>>&, const ::Ice::Context&);
    /// \endcond

    CList opCList(const CList& inSeq, CList& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpCListResult>(true, this, &TestIntfPrx::_iceI_opCList, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opCListAsync(const CList& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpCListResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpCListResult, P>(false, this, &TestIntfPrx::_iceI_opCList, inSeq, context);
    }

    ::std::function<void()>
    opCListAsync(const CList& inSeq,
                 ::std::function<void(::Test::CList, ::Test::CList)> response,
                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                 ::std::function<void(bool)> sent = nullptr,
                 const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpCListResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpCListResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opCList, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opCList(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpCListResult>>&, const CList&, const ::Ice::Context&);
    /// \endcond

    ClassStruct opClassStruct(const ClassStruct& inS, const ClassStructSeq& inSeq, ClassStruct& outS, ClassStructSeq& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpClassStructResult>(true, this, &TestIntfPrx::_iceI_opClassStruct, inS, inSeq, context).get();
        outS = ::std::move(_result.outS);
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opClassStructAsync(const ClassStruct& inS, const ClassStructSeq& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpClassStructResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpClassStructResult, P>(false, this, &TestIntfPrx::_iceI_opClassStruct, inS, inSeq, context);
    }

    ::std::function<void()>
    opClassStructAsync(const ClassStruct& inS, const ClassStructSeq& inSeq,
                       ::std::function<void(::Test::ClassStruct, ::Test::ClassStruct, ::Test::ClassStructSeq)> response,
                       ::std::function<void(::std::exception_ptr)> ex = nullptr,
                       ::std::function<void(bool)> sent = nullptr,
                       const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpClassStructResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outS), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpClassStructResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opClassStruct, inS, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opClassStruct(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpClassStructResult>>&, const ClassStruct&, const ClassStructSeq&, const ::Ice::Context&);
    /// \endcond

    void opOutArrayByteSeq(const ByteSeq& org, ByteSeq& copy, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        copy = _makePromiseOutgoing<::Test::ByteSeq>(true, this, &TestIntfPrx::_iceI_opOutArrayByteSeq, org, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto opOutArrayByteSeqAsync(const ByteSeq& org, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::Test::ByteSeq>>().get_future())
    {
        return _makePromiseOutgoing<::Test::ByteSeq, P>(false, this, &TestIntfPrx::_iceI_opOutArrayByteSeq, org, context);
    }

    ::std::function<void()>
    opOutArrayByteSeqAsync(const ByteSeq& org,
                           ::std::function<void(::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>)> response,
                           ::std::function<void(::std::exception_ptr)> ex = nullptr,
                           ::std::function<void(bool)> sent = nullptr,
                           const ::Ice::Context& context = ::Ice::noExplicitContext);

    /// \cond INTERNAL
    void _iceI_opOutArrayByteSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::Test::ByteSeq>>&, const ByteSeq&, const ::Ice::Context&);
    /// \endcond

    void opOutRangeByteSeq(const ByteSeq& org, ByteSeq& copy, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        copy = _makePromiseOutgoing<::Test::ByteSeq>(true, this, &TestIntfPrx::_iceI_opOutRangeByteSeq, org, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto opOutRangeByteSeqAsync(const ByteSeq& org, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::Test::ByteSeq>>().get_future())
    {
        return _makePromiseOutgoing<::Test::ByteSeq, P>(false, this, &TestIntfPrx::_iceI_opOutRangeByteSeq, org, context);
    }

    ::std::function<void()>
    opOutRangeByteSeqAsync(const ByteSeq& org,
                           ::std::function<void(::Test::ByteSeq)> response,
                           ::std::function<void(::std::exception_ptr)> ex = nullptr,
                           ::std::function<void(bool)> sent = nullptr,
                           const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<::Test::ByteSeq>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opOutRangeByteSeq, org, context);
    }

    /// \cond INTERNAL
    void _iceI_opOutRangeByteSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::Test::ByteSeq>>&, const ByteSeq&, const ::Ice::Context&);
    /// \endcond

    IntStringDict opIntStringDict(const IntStringDict& idict, IntStringDict& odict, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpIntStringDictResult>(true, this, &TestIntfPrx::_iceI_opIntStringDict, idict, context).get();
        odict = ::std::move(_result.odict);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opIntStringDictAsync(const IntStringDict& idict, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpIntStringDictResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpIntStringDictResult, P>(false, this, &TestIntfPrx::_iceI_opIntStringDict, idict, context);
    }

    ::std::function<void()>
    opIntStringDictAsync(const IntStringDict& idict,
                         ::std::function<void(::Test::IntStringDict, ::Test::IntStringDict)> response,
                         ::std::function<void(::std::exception_ptr)> ex = nullptr,
                         ::std::function<void(bool)> sent = nullptr,
                         const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpIntStringDictResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.odict));
        };
        return _makeLambdaOutgoing<TestIntf::OpIntStringDictResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opIntStringDict, idict, context);
    }

    /// \cond INTERNAL
    void _iceI_opIntStringDict(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpIntStringDictResult>>&, const IntStringDict&, const ::Ice::Context&);
    /// \endcond

    ::Test::CustomMap< ::Ice::Long, ::Ice::Long> opVarDict(const ::Test::CustomMap<std::string, ::Ice::Int>& idict, ::Test::CustomMap<std::string, ::Ice::Int>& odict, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpVarDictResult>(true, this, &TestIntfPrx::_iceI_opVarDict, idict, context).get();
        odict = ::std::move(_result.odict);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opVarDictAsync(const ::Test::CustomMap<std::string, ::Ice::Int>& idict, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpVarDictResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpVarDictResult, P>(false, this, &TestIntfPrx::_iceI_opVarDict, idict, context);
    }

    ::std::function<void()>
    opVarDictAsync(const ::Test::CustomMap<std::string, ::Ice::Int>& idict,
                   ::std::function<void(::Test::CustomMap< ::Ice::Long, ::Ice::Long>, ::Test::CustomMap<std::string, ::Ice::Int>)> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpVarDictResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.odict));
        };
        return _makeLambdaOutgoing<TestIntf::OpVarDictResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opVarDict, idict, context);
    }

    /// \cond INTERNAL
    void _iceI_opVarDict(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpVarDictResult>>&, const ::Test::CustomMap<std::string, ::Ice::Int>&, const ::Ice::Context&);
    /// \endcond

    ::Test::CustomMap< ::Ice::Int, std::string> opCustomIntStringDict(const ::std::map< ::Ice::Int, ::Util::string_view>& idict, ::Test::CustomMap< ::Ice::Int, std::string>& odict, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpCustomIntStringDictResult>(true, this, &TestIntfPrx::_iceI_opCustomIntStringDict, idict, context).get();
        odict = ::std::move(_result.odict);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opCustomIntStringDictAsync(const ::std::map< ::Ice::Int, ::Util::string_view>& idict, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpCustomIntStringDictResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpCustomIntStringDictResult, P>(false, this, &TestIntfPrx::_iceI_opCustomIntStringDict, idict, context);
    }

    ::std::function<void()>
    opCustomIntStringDictAsync(const ::std::map< ::Ice::Int, ::Util::string_view>& idict,
                               ::std::function<void(::std::map< ::Ice::Int, ::Util::string_view>, ::std::map< ::Ice::Int, ::Util::string_view>)> response,
                               ::std::function<void(::std::exception_ptr)> ex = nullptr,
                               ::std::function<void(bool)> sent = nullptr,
                               const ::Ice::Context& context = ::Ice::noExplicitContext);

    /// \cond INTERNAL
    void _iceI_opCustomIntStringDict(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpCustomIntStringDictResult>>&, const ::std::map< ::Ice::Int, ::Util::string_view>&, const ::Ice::Context&);
    /// \endcond

    ShortBuffer opShortBuffer(const ShortBuffer& inS, ShortBuffer& outS, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpShortBufferResult>(true, this, &TestIntfPrx::_iceI_opShortBuffer, inS, context).get();
        outS = ::std::move(_result.outS);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opShortBufferAsync(const ShortBuffer& inS, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpShortBufferResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpShortBufferResult, P>(false, this, &TestIntfPrx::_iceI_opShortBuffer, inS, context);
    }

    ::std::function<void()>
    opShortBufferAsync(const ShortBuffer& inS,
                       ::std::function<void(::Test::ShortBuffer, ::Test::ShortBuffer)> response,
                       ::std::function<void(::std::exception_ptr)> ex = nullptr,
                       ::std::function<void(bool)> sent = nullptr,
                       const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpShortBufferResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outS));
        };
        return _makeLambdaOutgoing<TestIntf::OpShortBufferResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opShortBuffer, inS, context);
    }

    /// \cond INTERNAL
    void _iceI_opShortBuffer(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpShortBufferResult>>&, const ShortBuffer&, const ::Ice::Context&);
    /// \endcond

    ::Test::CustomBuffer<bool> opBoolBuffer(const ::Test::CustomBuffer<bool>& inS, ::Test::CustomBuffer<bool>& outS, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpBoolBufferResult>(true, this, &TestIntfPrx::_iceI_opBoolBuffer, inS, context).get();
        outS = ::std::move(_result.outS);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opBoolBufferAsync(const ::Test::CustomBuffer<bool>& inS, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpBoolBufferResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpBoolBufferResult, P>(false, this, &TestIntfPrx::_iceI_opBoolBuffer, inS, context);
    }

    ::std::function<void()>
    opBoolBufferAsync(const ::Test::CustomBuffer<bool>& inS,
                      ::std::function<void(::Test::CustomBuffer<bool>, ::Test::CustomBuffer<bool>)> response,
                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                      ::std::function<void(bool)> sent = nullptr,
                      const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpBoolBufferResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outS));
        };
        return _makeLambdaOutgoing<TestIntf::OpBoolBufferResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opBoolBuffer, inS, context);
    }

    /// \cond INTERNAL
    void _iceI_opBoolBuffer(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpBoolBufferResult>>&, const ::Test::CustomBuffer<bool>&, const ::Ice::Context&);
    /// \endcond

    BufferStruct opBufferStruct(const BufferStruct& s, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::Test::BufferStruct>(true, this, &TestIntfPrx::_iceI_opBufferStruct, s, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto opBufferStructAsync(const BufferStruct& s, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::Test::BufferStruct>>().get_future())
    {
        return _makePromiseOutgoing<::Test::BufferStruct, P>(false, this, &TestIntfPrx::_iceI_opBufferStruct, s, context);
    }

    ::std::function<void()>
    opBufferStructAsync(const BufferStruct& s,
                        ::std::function<void(::Test::BufferStruct)> response,
                        ::std::function<void(::std::exception_ptr)> ex = nullptr,
                        ::std::function<void(bool)> sent = nullptr,
                        const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<::Test::BufferStruct>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opBufferStruct, s, context);
    }

    /// \cond INTERNAL
    void _iceI_opBufferStruct(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::Test::BufferStruct>>&, const BufferStruct&, const ::Ice::Context&);
    /// \endcond

    void shutdown(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &TestIntfPrx::_iceI_shutdown, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto shutdownAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &TestIntfPrx::_iceI_shutdown, context);
    }

    ::std::function<void()>
    shutdownAsync(::std::function<void()> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_shutdown, context);
    }

    /// \cond INTERNAL
    void _iceI_shutdown(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    TestIntfPrx() = default;
    friend ::std::shared_ptr<TestIntfPrx> IceInternal::createProxy<TestIntfPrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

}

/// \cond STREAM
namespace Ice
{

template<>
struct StreamableTraits<::Test::Fixed>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 2;
    static const bool fixedLength = true;
};

template<typename S>
struct StreamReader<::Test::Fixed, S>
{
    static void read(S* istr, ::Test::Fixed& v)
    {
        istr->readAll(v.s);
    }
};

template<>
struct StreamableTraits<::Test::Variable>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 3;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::Test::Variable, S>
{
    static void read(S* istr, ::Test::Variable& v)
    {
        istr->readAll(v.s, v.bl, v.ss);
    }
};

template<>
struct StreamableTraits< ::Test::E>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 2;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits<::Test::ClassOtherStruct>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 4;
    static const bool fixedLength = true;
};

template<typename S>
struct StreamReader<::Test::ClassOtherStruct, S>
{
    static void read(S* istr, ::Test::ClassOtherStruct& v)
    {
        istr->readAll(v.x);
    }
};

template<>
struct StreamableTraits<::Test::ClassStruct>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 9;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::Test::ClassStruct, S>
{
    static void read(S* istr, ::Test::ClassStruct& v)
    {
        istr->readAll(v.otherSeq, v.other, v.y);
    }
};

template<typename S>
struct StreamReader<::Test::DictClass, S>
{
    static void read(S* istr, ::Test::DictClass& v)
    {
        istr->readAll(v.isdict);
    }
};

template<>
struct StreamableTraits<::Test::BufferStruct>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 7;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::Test::BufferStruct, S>
{
    static void read(S* istr, ::Test::BufferStruct& v)
    {
        istr->readAll(v.byteBuf, v.boolBuf, v.shortBuf, v.intBuf, v.longBuf, v.floatBuf, v.doubleBuf);
    }
};

}
/// \endcond

/// \cond INTERNAL
namespace Test
{

using CPtr = ::std::shared_ptr<C>;

using DPtr = ::std::shared_ptr<D>;
using DPrxPtr = ::std::shared_ptr<DPrx>;

using DictClassPtr = ::std::shared_ptr<DictClass>;

using TestIntfPtr = ::std::shared_ptr<TestIntf>;
using TestIntfPrxPtr = ::std::shared_ptr<TestIntfPrx>;

}
/// \endcond

#else // C++98 mapping

namespace IceProxy
{

namespace Test
{

class D;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< D>&);
::IceProxy::Ice::Object* upCast(D*);
/// \endcond

class TestIntf;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< TestIntf>&);
::IceProxy::Ice::Object* upCast(TestIntf*);
/// \endcond

}

}

namespace Test
{

class C;
using CPtr = ::Ice::SharedPtr<C>;
/// \cond INTERNAL
void _icePatchValuePtr(CPtr&, const ::Ice::ValuePtr&);
/// \endcond
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::D> DPrx;
typedef DPrx DPrxPtr;

class D;
typedef ::IceInternal::Handle< D> DPtr;

class DictClass;
using DictClassPtr = ::Ice::SharedPtr<DictClass>;
/// \cond INTERNAL
void _icePatchValuePtr(DictClassPtr&, const ::Ice::ValuePtr&);
/// \endcond
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::TestIntf> TestIntfPrx;
typedef TestIntfPrx TestIntfPrxPtr;

class TestIntf;
typedef ::IceInternal::Handle< TestIntf> TestIntfPtr;

}

namespace Test
{

typedef ::std::vector<bool> BoolSeq;

typedef std::list<bool> BoolList;

typedef std::list< ::Test::BoolList> BoolListList;

typedef ::std::vector<BoolList> BoolListSeq;

typedef std::list< ::Test::BoolSeq> BoolSeqList;

typedef std::list<std::deque<bool> > BoolDequeList;

typedef ::std::vector< ::Ice::Byte> ByteSeq;

typedef std::list< ::Ice::Byte> ByteList;

typedef std::list< ::Test::ByteList> ByteListList;

typedef ::std::vector<ByteList> ByteListSeq;

typedef std::list< ::Test::ByteSeq> ByteSeqList;

typedef ::std::vector< ::std::string> StringSeq;

typedef std::list<std::string> StringList;

typedef std::list< ::Test::StringList> StringListList;

typedef ::std::vector<StringList> StringListSeq;

typedef std::list< ::Test::StringSeq> StringSeqList;

struct Fixed
{
    ::Ice::Short s;

    bool operator==(const Fixed& rhs_) const
    {
        if(this == &rhs_)
        {
            return true;
        }
        if(s != rhs_.s)
        {
            return false;
        }
        return true;
    }

    bool operator<(const Fixed& rhs_) const
    {
        if(this == &rhs_)
        {
            return false;
        }
        if(s < rhs_.s)
        {
            return true;
        }
        else if(rhs_.s < s)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const Fixed& rhs_) const
    {
        return !operator==(rhs_);
    }
    bool operator<=(const Fixed& rhs_) const
    {
        return operator<(rhs_) || operator==(rhs_);
    }
    bool operator>(const Fixed& rhs_) const
    {
        return !operator<(rhs_) && !operator==(rhs_);
    }
    bool operator>=(const Fixed& rhs_) const
    {
        return !operator<(rhs_);
    }
};

typedef ::std::vector<Fixed> FixedSeq;

typedef std::list< ::Test::Fixed> FixedList;

typedef std::list< ::Test::FixedList> FixedListList;

typedef ::std::vector<FixedList> FixedListSeq;

typedef std::list< ::Test::FixedSeq> FixedSeqList;

struct Variable
{
    ::std::string s;
    ::Test::BoolList bl;
    std::list<std::string> ss;

    bool operator==(const Variable& rhs_) const
    {
        if(this == &rhs_)
        {
            return true;
        }
        if(s != rhs_.s)
        {
            return false;
        }
        if(bl != rhs_.bl)
        {
            return false;
        }
        if(ss != rhs_.ss)
        {
            return false;
        }
        return true;
    }

    bool operator<(const Variable& rhs_) const
    {
        if(this == &rhs_)
        {
            return false;
        }
        if(s < rhs_.s)
        {
            return true;
        }
        else if(rhs_.s < s)
        {
            return false;
        }
        if(bl < rhs_.bl)
        {
            return true;
        }
        else if(rhs_.bl < bl)
        {
            return false;
        }
        if(ss < rhs_.ss)
        {
            return true;
        }
        else if(rhs_.ss < ss)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const Variable& rhs_) const
    {
        return !operator==(rhs_);
    }
    bool operator<=(const Variable& rhs_) const
    {
        return operator<(rhs_) || operator==(rhs_);
    }
    bool operator>(const Variable& rhs_) const
    {
        return !operator<(rhs_) && !operator==(rhs_);
    }
    bool operator>=(const Variable& rhs_) const
    {
        return !operator<(rhs_);
    }
};

typedef ::std::vector<Variable> VariableSeq;

typedef std::list< ::Test::Variable> VariableList;

typedef std::list< ::Test::VariableList> VariableListList;

typedef ::std::vector<VariableList> VariableListSeq;

typedef std::list< ::Test::VariableSeq> VariableSeqList;

typedef ::std::map< ::std::string, ::std::string> StringStringDict;

typedef ::std::vector<StringStringDict> StringStringDictSeq;

typedef std::list< ::Test::StringStringDict> StringStringDictList;

typedef std::list< ::Test::StringStringDictList> StringStringDictListList;

typedef ::std::vector<StringStringDictList> StringStringDictListSeq;

typedef std::list< ::Test::StringStringDictSeq> StringStringDictSeqList;

enum E
{
    E1,
    E2,
    E3
};

typedef ::std::vector<E> ESeq;

typedef std::list< ::Test::E> EList;

typedef std::list< ::Test::EList> EListList;

typedef ::std::vector<EList> EListSeq;

typedef std::list< ::Test::ESeq> ESeqList;

typedef ::std::vector<CPtr> CSeq;

typedef std::list< ::Test::CPtr> CList;

typedef std::list< ::Test::CList> CListList;

typedef ::std::vector<CList> CListSeq;

typedef std::list< ::Test::CSeq> CSeqList;

typedef ::std::vector<DPrx> DPrxSeq;

typedef std::list< ::Test::DPrx> DPrxList;

typedef std::list< ::Test::DPrxList> DPrxListList;

typedef ::std::vector<DPrxList> DPrxListSeq;

typedef std::list< ::Test::DPrxSeq> DPrxSeqList;

typedef ::std::vector< ::Ice::Double> DoubleSeq;

class ClassOtherStruct : public IceUtil::Shared
{
public:
    
    ClassOtherStruct() {}
    explicit ClassOtherStruct(::Ice::Int x) :
        x(x)
    {
    }
    

    ::Ice::Int x;

    bool operator==(const ClassOtherStruct& rhs_) const
    {
        if(this == &rhs_)
        {
            return true;
        }
        if(x != rhs_.x)
        {
            return false;
        }
        return true;
    }

    bool operator<(const ClassOtherStruct& rhs_) const
    {
        if(this == &rhs_)
        {
            return false;
        }
        if(x < rhs_.x)
        {
            return true;
        }
        else if(rhs_.x < x)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const ClassOtherStruct& rhs_) const
    {
        return !operator==(rhs_);
    }
    bool operator<=(const ClassOtherStruct& rhs_) const
    {
        return operator<(rhs_) || operator==(rhs_);
    }
    bool operator>(const ClassOtherStruct& rhs_) const
    {
        return !operator<(rhs_) && !operator==(rhs_);
    }
    bool operator>=(const ClassOtherStruct& rhs_) const
    {
        return !operator<(rhs_);
    }
};

typedef ::IceUtil::Handle< ::Test::ClassOtherStruct> ClassOtherStructPtr;

typedef ::std::vector<ClassOtherStructPtr> ClassOtherStructSeq;

class ClassStruct : public IceUtil::Shared
{
public:
    
    ClassStruct() {}
    ClassStruct(const ClassOtherStructSeq& otherSeq, const ClassOtherStructPtr& other, ::Ice::Int y) :
        otherSeq(otherSeq),
        other(other),
        y(y)
    {
    }
    

    ::Test::ClassOtherStructSeq otherSeq;
    ::Test::ClassOtherStructPtr other;
    ::Ice::Int y;

    bool operator==(const ClassStruct& rhs_) const
    {
        if(this == &rhs_)
        {
            return true;
        }
        if(otherSeq != rhs_.otherSeq)
        {
            return false;
        }
        if(other != rhs_.other)
        {
            return false;
        }
        if(y != rhs_.y)
        {
            return false;
        }
        return true;
    }

    bool operator<(const ClassStruct& rhs_) const
    {
        if(this == &rhs_)
        {
            return false;
        }
        if(otherSeq < rhs_.otherSeq)
        {
            return true;
        }
        else if(rhs_.otherSeq < otherSeq)
        {
            return false;
        }
        if(other < rhs_.other)
        {
            return true;
        }
        else if(rhs_.other < other)
        {
            return false;
        }
        if(y < rhs_.y)
        {
            return true;
        }
        else if(rhs_.y < y)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const ClassStruct& rhs_) const
    {
        return !operator==(rhs_);
    }
    bool operator<=(const ClassStruct& rhs_) const
    {
        return operator<(rhs_) || operator==(rhs_);
    }
    bool operator>(const ClassStruct& rhs_) const
    {
        return !operator<(rhs_) && !operator==(rhs_);
    }
    bool operator>=(const ClassStruct& rhs_) const
    {
        return !operator<(rhs_);
    }
};

typedef ::IceUtil::Handle< ::Test::ClassStruct> ClassStructPtr;

typedef ::std::vector<ClassStructPtr> ClassStructSeq;

typedef Test::CustomMap<Ice::Int, std::string> IntStringDict;

typedef ::std::map< ::Ice::Long, ::Ice::Long> LongLongDict;

typedef ::std::map< ::std::string, ::Ice::Int> StringIntDict;

typedef Test::CustomBuffer<bool> BoolBuffer;

typedef Test::CustomBuffer<Ice::Short> ShortBuffer;

typedef Test::CustomBuffer<Ice::Int> IntBuffer;

typedef Test::CustomBuffer<Ice::Long> LongBuffer;

typedef Test::CustomBuffer<Ice::Float> FloatBuffer;

typedef Test::CustomBuffer<Ice::Double> DoubleBuffer;

typedef Test::CustomBuffer<Ice::Byte> ByteBuffer;

struct BufferStruct
{
    ::Test::ByteBuffer byteBuf;
    ::Test::BoolBuffer boolBuf;
    ::Test::ShortBuffer shortBuf;
    ::Test::IntBuffer intBuf;
    ::Test::LongBuffer longBuf;
    ::Test::FloatBuffer floatBuf;
    ::Test::DoubleBuffer doubleBuf;

    bool operator==(const BufferStruct& rhs_) const
    {
        if(this == &rhs_)
        {
            return true;
        }
        if(byteBuf != rhs_.byteBuf)
        {
            return false;
        }
        if(boolBuf != rhs_.boolBuf)
        {
            return false;
        }
        if(shortBuf != rhs_.shortBuf)
        {
            return false;
        }
        if(intBuf != rhs_.intBuf)
        {
            return false;
        }
        if(longBuf != rhs_.longBuf)
        {
            return false;
        }
        if(floatBuf != rhs_.floatBuf)
        {
            return false;
        }
        if(doubleBuf != rhs_.doubleBuf)
        {
            return false;
        }
        return true;
    }

    bool operator<(const BufferStruct& rhs_) const
    {
        if(this == &rhs_)
        {
            return false;
        }
        if(byteBuf < rhs_.byteBuf)
        {
            return true;
        }
        else if(rhs_.byteBuf < byteBuf)
        {
            return false;
        }
        if(boolBuf < rhs_.boolBuf)
        {
            return true;
        }
        else if(rhs_.boolBuf < boolBuf)
        {
            return false;
        }
        if(shortBuf < rhs_.shortBuf)
        {
            return true;
        }
        else if(rhs_.shortBuf < shortBuf)
        {
            return false;
        }
        if(intBuf < rhs_.intBuf)
        {
            return true;
        }
        else if(rhs_.intBuf < intBuf)
        {
            return false;
        }
        if(longBuf < rhs_.longBuf)
        {
            return true;
        }
        else if(rhs_.longBuf < longBuf)
        {
            return false;
        }
        if(floatBuf < rhs_.floatBuf)
        {
            return true;
        }
        else if(rhs_.floatBuf < floatBuf)
        {
            return false;
        }
        if(doubleBuf < rhs_.doubleBuf)
        {
            return true;
        }
        else if(rhs_.doubleBuf < doubleBuf)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const BufferStruct& rhs_) const
    {
        return !operator==(rhs_);
    }
    bool operator<=(const BufferStruct& rhs_) const
    {
        return operator<(rhs_) || operator==(rhs_);
    }
    bool operator>(const BufferStruct& rhs_) const
    {
        return !operator<(rhs_) && !operator==(rhs_);
    }
    bool operator>=(const BufferStruct& rhs_) const
    {
        return !operator<(rhs_);
    }
};

}

namespace Test
{

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opDoubleArray.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opDoubleArray.
 */
class Callback_TestIntf_opDoubleArray_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opDoubleArray_Base> Callback_TestIntf_opDoubleArrayPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opBoolArray.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opBoolArray.
 */
class Callback_TestIntf_opBoolArray_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opBoolArray_Base> Callback_TestIntf_opBoolArrayPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opByteArray.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opByteArray.
 */
class Callback_TestIntf_opByteArray_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opByteArray_Base> Callback_TestIntf_opByteArrayPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opVariableArray.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opVariableArray.
 */
class Callback_TestIntf_opVariableArray_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opVariableArray_Base> Callback_TestIntf_opVariableArrayPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opBoolRange.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opBoolRange.
 */
class Callback_TestIntf_opBoolRange_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opBoolRange_Base> Callback_TestIntf_opBoolRangePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opByteRange.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opByteRange.
 */
class Callback_TestIntf_opByteRange_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opByteRange_Base> Callback_TestIntf_opByteRangePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opVariableRange.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opVariableRange.
 */
class Callback_TestIntf_opVariableRange_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opVariableRange_Base> Callback_TestIntf_opVariableRangePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opByteRangeType.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opByteRangeType.
 */
class Callback_TestIntf_opByteRangeType_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opByteRangeType_Base> Callback_TestIntf_opByteRangeTypePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opVariableRangeType.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opVariableRangeType.
 */
class Callback_TestIntf_opVariableRangeType_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opVariableRangeType_Base> Callback_TestIntf_opVariableRangeTypePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opBoolSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opBoolSeq.
 */
class Callback_TestIntf_opBoolSeq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opBoolSeq_Base> Callback_TestIntf_opBoolSeqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opBoolList.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opBoolList.
 */
class Callback_TestIntf_opBoolList_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opBoolList_Base> Callback_TestIntf_opBoolListPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opBoolDequeList.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opBoolDequeList.
 */
class Callback_TestIntf_opBoolDequeList_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opBoolDequeList_Base> Callback_TestIntf_opBoolDequeListPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opBoolDequeListArray.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opBoolDequeListArray.
 */
class Callback_TestIntf_opBoolDequeListArray_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opBoolDequeListArray_Base> Callback_TestIntf_opBoolDequeListArrayPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opBoolDequeListRange.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opBoolDequeListRange.
 */
class Callback_TestIntf_opBoolDequeListRange_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opBoolDequeListRange_Base> Callback_TestIntf_opBoolDequeListRangePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opByteSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opByteSeq.
 */
class Callback_TestIntf_opByteSeq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opByteSeq_Base> Callback_TestIntf_opByteSeqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opByteList.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opByteList.
 */
class Callback_TestIntf_opByteList_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opByteList_Base> Callback_TestIntf_opByteListPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opMyByteSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opMyByteSeq.
 */
class Callback_TestIntf_opMyByteSeq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opMyByteSeq_Base> Callback_TestIntf_opMyByteSeqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opString.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opString.
 */
class Callback_TestIntf_opString_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opString_Base> Callback_TestIntf_opStringPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opStringSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opStringSeq.
 */
class Callback_TestIntf_opStringSeq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opStringSeq_Base> Callback_TestIntf_opStringSeqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opStringList.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opStringList.
 */
class Callback_TestIntf_opStringList_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opStringList_Base> Callback_TestIntf_opStringListPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opFixedSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opFixedSeq.
 */
class Callback_TestIntf_opFixedSeq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opFixedSeq_Base> Callback_TestIntf_opFixedSeqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opFixedList.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opFixedList.
 */
class Callback_TestIntf_opFixedList_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opFixedList_Base> Callback_TestIntf_opFixedListPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opVariableSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opVariableSeq.
 */
class Callback_TestIntf_opVariableSeq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opVariableSeq_Base> Callback_TestIntf_opVariableSeqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opVariableList.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opVariableList.
 */
class Callback_TestIntf_opVariableList_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opVariableList_Base> Callback_TestIntf_opVariableListPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opStringStringDictSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opStringStringDictSeq.
 */
class Callback_TestIntf_opStringStringDictSeq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opStringStringDictSeq_Base> Callback_TestIntf_opStringStringDictSeqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opStringStringDictList.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opStringStringDictList.
 */
class Callback_TestIntf_opStringStringDictList_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opStringStringDictList_Base> Callback_TestIntf_opStringStringDictListPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opESeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opESeq.
 */
class Callback_TestIntf_opESeq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opESeq_Base> Callback_TestIntf_opESeqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opEList.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opEList.
 */
class Callback_TestIntf_opEList_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opEList_Base> Callback_TestIntf_opEListPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opDPrxSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opDPrxSeq.
 */
class Callback_TestIntf_opDPrxSeq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opDPrxSeq_Base> Callback_TestIntf_opDPrxSeqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opDPrxList.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opDPrxList.
 */
class Callback_TestIntf_opDPrxList_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opDPrxList_Base> Callback_TestIntf_opDPrxListPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opCSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opCSeq.
 */
class Callback_TestIntf_opCSeq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opCSeq_Base> Callback_TestIntf_opCSeqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opCList.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opCList.
 */
class Callback_TestIntf_opCList_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opCList_Base> Callback_TestIntf_opCListPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opClassStruct.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opClassStruct.
 */
class Callback_TestIntf_opClassStruct_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opClassStruct_Base> Callback_TestIntf_opClassStructPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opOutArrayByteSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opOutArrayByteSeq.
 */
class Callback_TestIntf_opOutArrayByteSeq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opOutArrayByteSeq_Base> Callback_TestIntf_opOutArrayByteSeqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opOutRangeByteSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opOutRangeByteSeq.
 */
class Callback_TestIntf_opOutRangeByteSeq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opOutRangeByteSeq_Base> Callback_TestIntf_opOutRangeByteSeqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opIntStringDict.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opIntStringDict.
 */
class Callback_TestIntf_opIntStringDict_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opIntStringDict_Base> Callback_TestIntf_opIntStringDictPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opVarDict.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opVarDict.
 */
class Callback_TestIntf_opVarDict_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opVarDict_Base> Callback_TestIntf_opVarDictPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opCustomIntStringDict.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opCustomIntStringDict.
 */
class Callback_TestIntf_opCustomIntStringDict_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opCustomIntStringDict_Base> Callback_TestIntf_opCustomIntStringDictPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opShortBuffer.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opShortBuffer.
 */
class Callback_TestIntf_opShortBuffer_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opShortBuffer_Base> Callback_TestIntf_opShortBufferPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opBoolBuffer.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opBoolBuffer.
 */
class Callback_TestIntf_opBoolBuffer_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opBoolBuffer_Base> Callback_TestIntf_opBoolBufferPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opBufferStruct.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opBufferStruct.
 */
class Callback_TestIntf_opBufferStruct_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opBufferStruct_Base> Callback_TestIntf_opBufferStructPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_shutdown.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_shutdown.
 */
class Callback_TestIntf_shutdown_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_shutdown_Base> Callback_TestIntf_shutdownPtr;

}

namespace IceProxy
{

namespace Test
{

class D : public virtual ::Ice::Proxy<D, ::IceProxy::Ice::Object>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class TestIntf : public virtual ::Ice::Proxy<TestIntf, ::IceProxy::Ice::Object>
{
public:

    ::Test::DoubleSeq opDoubleArray(const ::std::pair<const ::Ice::Double*, const ::Ice::Double*>& inSeq, ::Test::DoubleSeq& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opDoubleArray(outSeq, _iceI_begin_opDoubleArray(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opDoubleArray(const ::std::pair<const ::Ice::Double*, const ::Ice::Double*>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opDoubleArray(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opDoubleArray(const ::std::pair<const ::Ice::Double*, const ::Ice::Double*>& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opDoubleArray(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opDoubleArray(const ::std::pair<const ::Ice::Double*, const ::Ice::Double*>& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opDoubleArray(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opDoubleArray(const ::std::pair<const ::Ice::Double*, const ::Ice::Double*>& inSeq, const ::Test::Callback_TestIntf_opDoubleArrayPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opDoubleArray(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opDoubleArray(const ::std::pair<const ::Ice::Double*, const ::Ice::Double*>& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opDoubleArrayPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opDoubleArray(inSeq, context, cb, cookie);
    }

    ::Test::DoubleSeq end_opDoubleArray(::Test::DoubleSeq& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opDoubleArray(::std::pair< ::IceUtil::ScopedArray< ::Ice::Double>, ::std::pair<const  ::Ice::Double*, const  ::Ice::Double*> >& iceP_outSeq, ::std::pair< ::IceUtil::ScopedArray< ::Ice::Double>, ::std::pair<const  ::Ice::Double*, const  ::Ice::Double*> >& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opDoubleArray(const ::std::pair<const ::Ice::Double*, const ::Ice::Double*>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::BoolSeq opBoolArray(const ::std::pair<const bool*, const bool*>& inSeq, ::Test::BoolSeq& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opBoolArray(outSeq, _iceI_begin_opBoolArray(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opBoolArray(const ::std::pair<const bool*, const bool*>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opBoolArray(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opBoolArray(const ::std::pair<const bool*, const bool*>& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opBoolArray(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opBoolArray(const ::std::pair<const bool*, const bool*>& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opBoolArray(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opBoolArray(const ::std::pair<const bool*, const bool*>& inSeq, const ::Test::Callback_TestIntf_opBoolArrayPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opBoolArray(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opBoolArray(const ::std::pair<const bool*, const bool*>& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opBoolArrayPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opBoolArray(inSeq, context, cb, cookie);
    }

    ::Test::BoolSeq end_opBoolArray(::Test::BoolSeq& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opBoolArray(::std::pair< ::IceUtil::ScopedArray<bool>, ::std::pair<const bool*, const bool*> >& iceP_outSeq, ::std::pair< ::IceUtil::ScopedArray<bool>, ::std::pair<const bool*, const bool*> >& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opBoolArray(const ::std::pair<const bool*, const bool*>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::ByteList opByteArray(const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>& inSeq, ::Test::ByteList& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opByteArray(outSeq, _iceI_begin_opByteArray(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opByteArray(const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opByteArray(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opByteArray(const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByteArray(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opByteArray(const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByteArray(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opByteArray(const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>& inSeq, const ::Test::Callback_TestIntf_opByteArrayPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByteArray(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opByteArray(const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opByteArrayPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByteArray(inSeq, context, cb, cookie);
    }

    ::Test::ByteList end_opByteArray(::Test::ByteList& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opByteArray(::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>& iceP_outSeq, ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opByteArray(const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::VariableList opVariableArray(const ::std::pair<const ::Test::Variable*, const ::Test::Variable*>& inSeq, ::Test::VariableList& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opVariableArray(outSeq, _iceI_begin_opVariableArray(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opVariableArray(const ::std::pair<const ::Test::Variable*, const ::Test::Variable*>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opVariableArray(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opVariableArray(const ::std::pair<const ::Test::Variable*, const ::Test::Variable*>& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opVariableArray(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opVariableArray(const ::std::pair<const ::Test::Variable*, const ::Test::Variable*>& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opVariableArray(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opVariableArray(const ::std::pair<const ::Test::Variable*, const ::Test::Variable*>& inSeq, const ::Test::Callback_TestIntf_opVariableArrayPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opVariableArray(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opVariableArray(const ::std::pair<const ::Test::Variable*, const ::Test::Variable*>& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opVariableArrayPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opVariableArray(inSeq, context, cb, cookie);
    }

    ::Test::VariableList end_opVariableArray(::Test::VariableList& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opVariableArray(::std::vector< ::Test::Variable>& iceP_outSeq, ::std::vector< ::Test::Variable>& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opVariableArray(const ::std::pair<const ::Test::Variable*, const ::Test::Variable*>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::BoolSeq opBoolRange(const ::std::pair< ::Test::BoolSeq::const_iterator,  ::Test::BoolSeq::const_iterator>& inSeq, ::Test::BoolSeq& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opBoolRange(outSeq, _iceI_begin_opBoolRange(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opBoolRange(const ::std::pair< ::Test::BoolSeq::const_iterator,  ::Test::BoolSeq::const_iterator>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opBoolRange(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opBoolRange(const ::std::pair< ::Test::BoolSeq::const_iterator,  ::Test::BoolSeq::const_iterator>& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opBoolRange(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opBoolRange(const ::std::pair< ::Test::BoolSeq::const_iterator,  ::Test::BoolSeq::const_iterator>& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opBoolRange(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opBoolRange(const ::std::pair< ::Test::BoolSeq::const_iterator,  ::Test::BoolSeq::const_iterator>& inSeq, const ::Test::Callback_TestIntf_opBoolRangePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opBoolRange(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opBoolRange(const ::std::pair< ::Test::BoolSeq::const_iterator,  ::Test::BoolSeq::const_iterator>& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opBoolRangePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opBoolRange(inSeq, context, cb, cookie);
    }

    ::Test::BoolSeq end_opBoolRange(::Test::BoolSeq& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opBoolRange(::Test::BoolSeq& iceP_outSeq, ::Test::BoolSeq& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opBoolRange(const ::std::pair< ::Test::BoolSeq::const_iterator,  ::Test::BoolSeq::const_iterator>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::ByteList opByteRange(const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>& inSeq, ::Test::ByteList& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opByteRange(outSeq, _iceI_begin_opByteRange(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opByteRange(const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opByteRange(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opByteRange(const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByteRange(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opByteRange(const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByteRange(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opByteRange(const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>& inSeq, const ::Test::Callback_TestIntf_opByteRangePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByteRange(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opByteRange(const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opByteRangePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByteRange(inSeq, context, cb, cookie);
    }

    ::Test::ByteList end_opByteRange(::Test::ByteList& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opByteRange(::Test::ByteList& iceP_outSeq, ::Test::ByteList& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opByteRange(const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::VariableList opVariableRange(const ::std::pair< ::Test::VariableList::const_iterator,  ::Test::VariableList::const_iterator>& inSeq, ::Test::VariableList& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opVariableRange(outSeq, _iceI_begin_opVariableRange(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opVariableRange(const ::std::pair< ::Test::VariableList::const_iterator,  ::Test::VariableList::const_iterator>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opVariableRange(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opVariableRange(const ::std::pair< ::Test::VariableList::const_iterator,  ::Test::VariableList::const_iterator>& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opVariableRange(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opVariableRange(const ::std::pair< ::Test::VariableList::const_iterator,  ::Test::VariableList::const_iterator>& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opVariableRange(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opVariableRange(const ::std::pair< ::Test::VariableList::const_iterator,  ::Test::VariableList::const_iterator>& inSeq, const ::Test::Callback_TestIntf_opVariableRangePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opVariableRange(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opVariableRange(const ::std::pair< ::Test::VariableList::const_iterator,  ::Test::VariableList::const_iterator>& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opVariableRangePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opVariableRange(inSeq, context, cb, cookie);
    }

    ::Test::VariableList end_opVariableRange(::Test::VariableList& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opVariableRange(::Test::VariableList& iceP_outSeq, ::Test::VariableList& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opVariableRange(const ::std::pair< ::Test::VariableList::const_iterator,  ::Test::VariableList::const_iterator>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::ByteList opByteRangeType(const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>& inSeq, ::Test::ByteList& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opByteRangeType(outSeq, _iceI_begin_opByteRangeType(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opByteRangeType(const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opByteRangeType(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opByteRangeType(const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByteRangeType(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opByteRangeType(const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByteRangeType(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opByteRangeType(const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>& inSeq, const ::Test::Callback_TestIntf_opByteRangeTypePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByteRangeType(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opByteRangeType(const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opByteRangeTypePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByteRangeType(inSeq, context, cb, cookie);
    }

    ::Test::ByteList end_opByteRangeType(::Test::ByteList& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opByteRangeType(::Test::ByteList& iceP_outSeq, ::Test::ByteList& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opByteRangeType(const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::VariableList opVariableRangeType(const ::std::pair<std::deque< ::Test::Variable>::const_iterator, std::deque< ::Test::Variable>::const_iterator>& inSeq, ::Test::VariableList& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opVariableRangeType(outSeq, _iceI_begin_opVariableRangeType(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opVariableRangeType(const ::std::pair<std::deque< ::Test::Variable>::const_iterator, std::deque< ::Test::Variable>::const_iterator>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opVariableRangeType(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opVariableRangeType(const ::std::pair<std::deque< ::Test::Variable>::const_iterator, std::deque< ::Test::Variable>::const_iterator>& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opVariableRangeType(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opVariableRangeType(const ::std::pair<std::deque< ::Test::Variable>::const_iterator, std::deque< ::Test::Variable>::const_iterator>& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opVariableRangeType(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opVariableRangeType(const ::std::pair<std::deque< ::Test::Variable>::const_iterator, std::deque< ::Test::Variable>::const_iterator>& inSeq, const ::Test::Callback_TestIntf_opVariableRangeTypePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opVariableRangeType(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opVariableRangeType(const ::std::pair<std::deque< ::Test::Variable>::const_iterator, std::deque< ::Test::Variable>::const_iterator>& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opVariableRangeTypePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opVariableRangeType(inSeq, context, cb, cookie);
    }

    ::Test::VariableList end_opVariableRangeType(::Test::VariableList& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opVariableRangeType(std::deque< ::Test::Variable>& iceP_outSeq, std::deque< ::Test::Variable>& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opVariableRangeType(const ::std::pair<std::deque< ::Test::Variable>::const_iterator, std::deque< ::Test::Variable>::const_iterator>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    std::deque<bool> opBoolSeq(const std::deque<bool>& inSeq, std::deque<bool>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opBoolSeq(outSeq, _iceI_begin_opBoolSeq(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opBoolSeq(const std::deque<bool>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opBoolSeq(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opBoolSeq(const std::deque<bool>& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opBoolSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opBoolSeq(const std::deque<bool>& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opBoolSeq(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opBoolSeq(const std::deque<bool>& inSeq, const ::Test::Callback_TestIntf_opBoolSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opBoolSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opBoolSeq(const std::deque<bool>& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opBoolSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opBoolSeq(inSeq, context, cb, cookie);
    }

    std::deque<bool> end_opBoolSeq(std::deque<bool>& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opBoolSeq(std::deque<bool>& iceP_outSeq, std::deque<bool>& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opBoolSeq(const std::deque<bool>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::BoolList opBoolList(const ::Test::BoolList& inSeq, ::Test::BoolList& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opBoolList(outSeq, _iceI_begin_opBoolList(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opBoolList(const ::Test::BoolList& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opBoolList(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opBoolList(const ::Test::BoolList& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opBoolList(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opBoolList(const ::Test::BoolList& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opBoolList(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opBoolList(const ::Test::BoolList& inSeq, const ::Test::Callback_TestIntf_opBoolListPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opBoolList(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opBoolList(const ::Test::BoolList& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opBoolListPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opBoolList(inSeq, context, cb, cookie);
    }

    ::Test::BoolList end_opBoolList(::Test::BoolList& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opBoolList(::Test::BoolList& iceP_outSeq, ::Test::BoolList& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opBoolList(const ::Test::BoolList&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::BoolDequeList opBoolDequeList(const ::Test::BoolDequeList& inSeq, ::Test::BoolDequeList& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opBoolDequeList(outSeq, _iceI_begin_opBoolDequeList(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opBoolDequeList(const ::Test::BoolDequeList& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opBoolDequeList(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opBoolDequeList(const ::Test::BoolDequeList& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opBoolDequeList(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opBoolDequeList(const ::Test::BoolDequeList& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opBoolDequeList(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opBoolDequeList(const ::Test::BoolDequeList& inSeq, const ::Test::Callback_TestIntf_opBoolDequeListPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opBoolDequeList(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opBoolDequeList(const ::Test::BoolDequeList& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opBoolDequeListPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opBoolDequeList(inSeq, context, cb, cookie);
    }

    ::Test::BoolDequeList end_opBoolDequeList(::Test::BoolDequeList& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opBoolDequeList(::Test::BoolDequeList& iceP_outSeq, ::Test::BoolDequeList& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opBoolDequeList(const ::Test::BoolDequeList&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::BoolDequeList opBoolDequeListArray(const ::std::pair<const std::deque<bool>*, const std::deque<bool>*>& inSeq, ::Test::BoolDequeList& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opBoolDequeListArray(outSeq, _iceI_begin_opBoolDequeListArray(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opBoolDequeListArray(const ::std::pair<const std::deque<bool>*, const std::deque<bool>*>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opBoolDequeListArray(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opBoolDequeListArray(const ::std::pair<const std::deque<bool>*, const std::deque<bool>*>& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opBoolDequeListArray(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opBoolDequeListArray(const ::std::pair<const std::deque<bool>*, const std::deque<bool>*>& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opBoolDequeListArray(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opBoolDequeListArray(const ::std::pair<const std::deque<bool>*, const std::deque<bool>*>& inSeq, const ::Test::Callback_TestIntf_opBoolDequeListArrayPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opBoolDequeListArray(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opBoolDequeListArray(const ::std::pair<const std::deque<bool>*, const std::deque<bool>*>& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opBoolDequeListArrayPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opBoolDequeListArray(inSeq, context, cb, cookie);
    }

    ::Test::BoolDequeList end_opBoolDequeListArray(::Test::BoolDequeList& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opBoolDequeListArray(::std::vector<std::deque<bool> >& iceP_outSeq, ::std::vector<std::deque<bool> >& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opBoolDequeListArray(const ::std::pair<const std::deque<bool>*, const std::deque<bool>*>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::BoolDequeList opBoolDequeListRange(const ::std::pair< ::Test::BoolDequeList::const_iterator,  ::Test::BoolDequeList::const_iterator>& inSeq, ::Test::BoolDequeList& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opBoolDequeListRange(outSeq, _iceI_begin_opBoolDequeListRange(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opBoolDequeListRange(const ::std::pair< ::Test::BoolDequeList::const_iterator,  ::Test::BoolDequeList::const_iterator>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opBoolDequeListRange(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opBoolDequeListRange(const ::std::pair< ::Test::BoolDequeList::const_iterator,  ::Test::BoolDequeList::const_iterator>& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opBoolDequeListRange(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opBoolDequeListRange(const ::std::pair< ::Test::BoolDequeList::const_iterator,  ::Test::BoolDequeList::const_iterator>& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opBoolDequeListRange(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opBoolDequeListRange(const ::std::pair< ::Test::BoolDequeList::const_iterator,  ::Test::BoolDequeList::const_iterator>& inSeq, const ::Test::Callback_TestIntf_opBoolDequeListRangePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opBoolDequeListRange(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opBoolDequeListRange(const ::std::pair< ::Test::BoolDequeList::const_iterator,  ::Test::BoolDequeList::const_iterator>& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opBoolDequeListRangePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opBoolDequeListRange(inSeq, context, cb, cookie);
    }

    ::Test::BoolDequeList end_opBoolDequeListRange(::Test::BoolDequeList& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opBoolDequeListRange(::Test::BoolDequeList& iceP_outSeq, ::Test::BoolDequeList& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opBoolDequeListRange(const ::std::pair< ::Test::BoolDequeList::const_iterator,  ::Test::BoolDequeList::const_iterator>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    std::deque< ::Ice::Byte> opByteSeq(const std::deque< ::Ice::Byte>& inSeq, std::deque< ::Ice::Byte>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opByteSeq(outSeq, _iceI_begin_opByteSeq(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opByteSeq(const std::deque< ::Ice::Byte>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opByteSeq(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opByteSeq(const std::deque< ::Ice::Byte>& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByteSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opByteSeq(const std::deque< ::Ice::Byte>& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByteSeq(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opByteSeq(const std::deque< ::Ice::Byte>& inSeq, const ::Test::Callback_TestIntf_opByteSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByteSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opByteSeq(const std::deque< ::Ice::Byte>& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opByteSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByteSeq(inSeq, context, cb, cookie);
    }

    std::deque< ::Ice::Byte> end_opByteSeq(std::deque< ::Ice::Byte>& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opByteSeq(std::deque< ::Ice::Byte>& iceP_outSeq, std::deque< ::Ice::Byte>& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opByteSeq(const std::deque< ::Ice::Byte>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::ByteList opByteList(const ::Test::ByteList& inSeq, ::Test::ByteList& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opByteList(outSeq, _iceI_begin_opByteList(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opByteList(const ::Test::ByteList& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opByteList(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opByteList(const ::Test::ByteList& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByteList(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opByteList(const ::Test::ByteList& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByteList(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opByteList(const ::Test::ByteList& inSeq, const ::Test::Callback_TestIntf_opByteListPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByteList(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opByteList(const ::Test::ByteList& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opByteListPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByteList(inSeq, context, cb, cookie);
    }

    ::Test::ByteList end_opByteList(::Test::ByteList& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opByteList(::Test::ByteList& iceP_outSeq, ::Test::ByteList& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opByteList(const ::Test::ByteList&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    MyByteSeq opMyByteSeq(const MyByteSeq& inSeq, MyByteSeq& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opMyByteSeq(outSeq, _iceI_begin_opMyByteSeq(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opMyByteSeq(const MyByteSeq& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opMyByteSeq(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opMyByteSeq(const MyByteSeq& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opMyByteSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opMyByteSeq(const MyByteSeq& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opMyByteSeq(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opMyByteSeq(const MyByteSeq& inSeq, const ::Test::Callback_TestIntf_opMyByteSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opMyByteSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opMyByteSeq(const MyByteSeq& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opMyByteSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opMyByteSeq(inSeq, context, cb, cookie);
    }

    MyByteSeq end_opMyByteSeq(MyByteSeq& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opMyByteSeq(MyByteSeq& iceP_outSeq, MyByteSeq& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opMyByteSeq(const MyByteSeq&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::std::string opString(const Util::string_view& inString, ::std::string& outString, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opString(outString, _iceI_begin_opString(inString, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opString(const Util::string_view& inString, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opString(inString, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opString(const Util::string_view& inString, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opString(inString, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opString(const Util::string_view& inString, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opString(inString, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opString(const Util::string_view& inString, const ::Test::Callback_TestIntf_opStringPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opString(inString, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opString(const Util::string_view& inString, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opStringPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opString(inString, context, cb, cookie);
    }

    ::std::string end_opString(::std::string& outString, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opString(Util::string_view& iceP_outString, Util::string_view& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opString(const Util::string_view&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    std::deque<std::string> opStringSeq(const std::deque<std::string>& inSeq, std::deque<std::string>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opStringSeq(outSeq, _iceI_begin_opStringSeq(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opStringSeq(const std::deque<std::string>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opStringSeq(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opStringSeq(const std::deque<std::string>& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringSeq(const std::deque<std::string>& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringSeq(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringSeq(const std::deque<std::string>& inSeq, const ::Test::Callback_TestIntf_opStringSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringSeq(const std::deque<std::string>& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opStringSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringSeq(inSeq, context, cb, cookie);
    }

    std::deque<std::string> end_opStringSeq(std::deque<std::string>& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opStringSeq(std::deque<std::string>& iceP_outSeq, std::deque<std::string>& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opStringSeq(const std::deque<std::string>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::StringList opStringList(const ::Test::StringList& inSeq, ::Test::StringList& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opStringList(outSeq, _iceI_begin_opStringList(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opStringList(const ::Test::StringList& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opStringList(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opStringList(const ::Test::StringList& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringList(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringList(const ::Test::StringList& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringList(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringList(const ::Test::StringList& inSeq, const ::Test::Callback_TestIntf_opStringListPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringList(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringList(const ::Test::StringList& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opStringListPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringList(inSeq, context, cb, cookie);
    }

    ::Test::StringList end_opStringList(::Test::StringList& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opStringList(::Test::StringList& iceP_outSeq, ::Test::StringList& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opStringList(const ::Test::StringList&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    std::deque< ::Test::Fixed> opFixedSeq(const std::deque< ::Test::Fixed>& inSeq, std::deque< ::Test::Fixed>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opFixedSeq(outSeq, _iceI_begin_opFixedSeq(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opFixedSeq(const std::deque< ::Test::Fixed>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opFixedSeq(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opFixedSeq(const std::deque< ::Test::Fixed>& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opFixedSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opFixedSeq(const std::deque< ::Test::Fixed>& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opFixedSeq(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opFixedSeq(const std::deque< ::Test::Fixed>& inSeq, const ::Test::Callback_TestIntf_opFixedSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opFixedSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opFixedSeq(const std::deque< ::Test::Fixed>& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opFixedSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opFixedSeq(inSeq, context, cb, cookie);
    }

    std::deque< ::Test::Fixed> end_opFixedSeq(std::deque< ::Test::Fixed>& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opFixedSeq(std::deque< ::Test::Fixed>& iceP_outSeq, std::deque< ::Test::Fixed>& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opFixedSeq(const std::deque< ::Test::Fixed>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::FixedList opFixedList(const ::Test::FixedList& inSeq, ::Test::FixedList& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opFixedList(outSeq, _iceI_begin_opFixedList(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opFixedList(const ::Test::FixedList& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opFixedList(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opFixedList(const ::Test::FixedList& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opFixedList(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opFixedList(const ::Test::FixedList& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opFixedList(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opFixedList(const ::Test::FixedList& inSeq, const ::Test::Callback_TestIntf_opFixedListPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opFixedList(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opFixedList(const ::Test::FixedList& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opFixedListPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opFixedList(inSeq, context, cb, cookie);
    }

    ::Test::FixedList end_opFixedList(::Test::FixedList& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opFixedList(::Test::FixedList& iceP_outSeq, ::Test::FixedList& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opFixedList(const ::Test::FixedList&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    std::deque< ::Test::Variable> opVariableSeq(const std::deque< ::Test::Variable>& inSeq, std::deque< ::Test::Variable>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opVariableSeq(outSeq, _iceI_begin_opVariableSeq(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opVariableSeq(const std::deque< ::Test::Variable>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opVariableSeq(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opVariableSeq(const std::deque< ::Test::Variable>& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opVariableSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opVariableSeq(const std::deque< ::Test::Variable>& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opVariableSeq(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opVariableSeq(const std::deque< ::Test::Variable>& inSeq, const ::Test::Callback_TestIntf_opVariableSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opVariableSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opVariableSeq(const std::deque< ::Test::Variable>& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opVariableSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opVariableSeq(inSeq, context, cb, cookie);
    }

    std::deque< ::Test::Variable> end_opVariableSeq(std::deque< ::Test::Variable>& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opVariableSeq(std::deque< ::Test::Variable>& iceP_outSeq, std::deque< ::Test::Variable>& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opVariableSeq(const std::deque< ::Test::Variable>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::VariableList opVariableList(const ::Test::VariableList& inSeq, ::Test::VariableList& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opVariableList(outSeq, _iceI_begin_opVariableList(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opVariableList(const ::Test::VariableList& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opVariableList(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opVariableList(const ::Test::VariableList& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opVariableList(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opVariableList(const ::Test::VariableList& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opVariableList(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opVariableList(const ::Test::VariableList& inSeq, const ::Test::Callback_TestIntf_opVariableListPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opVariableList(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opVariableList(const ::Test::VariableList& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opVariableListPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opVariableList(inSeq, context, cb, cookie);
    }

    ::Test::VariableList end_opVariableList(::Test::VariableList& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opVariableList(::Test::VariableList& iceP_outSeq, ::Test::VariableList& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opVariableList(const ::Test::VariableList&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    std::deque< ::Test::StringStringDict> opStringStringDictSeq(const std::deque< ::Test::StringStringDict>& inSeq, std::deque< ::Test::StringStringDict>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opStringStringDictSeq(outSeq, _iceI_begin_opStringStringDictSeq(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opStringStringDictSeq(const std::deque< ::Test::StringStringDict>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opStringStringDictSeq(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opStringStringDictSeq(const std::deque< ::Test::StringStringDict>& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringStringDictSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringStringDictSeq(const std::deque< ::Test::StringStringDict>& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringStringDictSeq(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringStringDictSeq(const std::deque< ::Test::StringStringDict>& inSeq, const ::Test::Callback_TestIntf_opStringStringDictSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringStringDictSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringStringDictSeq(const std::deque< ::Test::StringStringDict>& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opStringStringDictSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringStringDictSeq(inSeq, context, cb, cookie);
    }

    std::deque< ::Test::StringStringDict> end_opStringStringDictSeq(std::deque< ::Test::StringStringDict>& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opStringStringDictSeq(std::deque< ::Test::StringStringDict>& iceP_outSeq, std::deque< ::Test::StringStringDict>& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opStringStringDictSeq(const std::deque< ::Test::StringStringDict>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::StringStringDictList opStringStringDictList(const ::Test::StringStringDictList& inSeq, ::Test::StringStringDictList& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opStringStringDictList(outSeq, _iceI_begin_opStringStringDictList(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opStringStringDictList(const ::Test::StringStringDictList& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opStringStringDictList(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opStringStringDictList(const ::Test::StringStringDictList& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringStringDictList(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringStringDictList(const ::Test::StringStringDictList& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringStringDictList(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringStringDictList(const ::Test::StringStringDictList& inSeq, const ::Test::Callback_TestIntf_opStringStringDictListPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringStringDictList(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringStringDictList(const ::Test::StringStringDictList& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opStringStringDictListPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringStringDictList(inSeq, context, cb, cookie);
    }

    ::Test::StringStringDictList end_opStringStringDictList(::Test::StringStringDictList& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opStringStringDictList(::Test::StringStringDictList& iceP_outSeq, ::Test::StringStringDictList& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opStringStringDictList(const ::Test::StringStringDictList&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    std::deque< ::Test::E> opESeq(const std::deque< ::Test::E>& inSeq, std::deque< ::Test::E>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opESeq(outSeq, _iceI_begin_opESeq(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opESeq(const std::deque< ::Test::E>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opESeq(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opESeq(const std::deque< ::Test::E>& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opESeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opESeq(const std::deque< ::Test::E>& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opESeq(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opESeq(const std::deque< ::Test::E>& inSeq, const ::Test::Callback_TestIntf_opESeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opESeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opESeq(const std::deque< ::Test::E>& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opESeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opESeq(inSeq, context, cb, cookie);
    }

    std::deque< ::Test::E> end_opESeq(std::deque< ::Test::E>& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opESeq(std::deque< ::Test::E>& iceP_outSeq, std::deque< ::Test::E>& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opESeq(const std::deque< ::Test::E>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::EList opEList(const ::Test::EList& inSeq, ::Test::EList& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opEList(outSeq, _iceI_begin_opEList(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opEList(const ::Test::EList& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opEList(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opEList(const ::Test::EList& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opEList(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opEList(const ::Test::EList& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opEList(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opEList(const ::Test::EList& inSeq, const ::Test::Callback_TestIntf_opEListPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opEList(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opEList(const ::Test::EList& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opEListPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opEList(inSeq, context, cb, cookie);
    }

    ::Test::EList end_opEList(::Test::EList& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opEList(::Test::EList& iceP_outSeq, ::Test::EList& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opEList(const ::Test::EList&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    std::deque< ::Test::DPrx> opDPrxSeq(const std::deque< ::Test::DPrx>& inSeq, std::deque< ::Test::DPrx>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opDPrxSeq(outSeq, _iceI_begin_opDPrxSeq(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opDPrxSeq(const std::deque< ::Test::DPrx>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opDPrxSeq(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opDPrxSeq(const std::deque< ::Test::DPrx>& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opDPrxSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opDPrxSeq(const std::deque< ::Test::DPrx>& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opDPrxSeq(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opDPrxSeq(const std::deque< ::Test::DPrx>& inSeq, const ::Test::Callback_TestIntf_opDPrxSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opDPrxSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opDPrxSeq(const std::deque< ::Test::DPrx>& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opDPrxSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opDPrxSeq(inSeq, context, cb, cookie);
    }

    std::deque< ::Test::DPrx> end_opDPrxSeq(std::deque< ::Test::DPrx>& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opDPrxSeq(std::deque< ::Test::DPrx>& iceP_outSeq, std::deque< ::Test::DPrx>& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opDPrxSeq(const std::deque< ::Test::DPrx>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::DPrxList opDPrxList(const ::Test::DPrxList& inSeq, ::Test::DPrxList& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opDPrxList(outSeq, _iceI_begin_opDPrxList(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opDPrxList(const ::Test::DPrxList& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opDPrxList(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opDPrxList(const ::Test::DPrxList& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opDPrxList(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opDPrxList(const ::Test::DPrxList& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opDPrxList(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opDPrxList(const ::Test::DPrxList& inSeq, const ::Test::Callback_TestIntf_opDPrxListPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opDPrxList(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opDPrxList(const ::Test::DPrxList& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opDPrxListPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opDPrxList(inSeq, context, cb, cookie);
    }

    ::Test::DPrxList end_opDPrxList(::Test::DPrxList& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opDPrxList(::Test::DPrxList& iceP_outSeq, ::Test::DPrxList& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opDPrxList(const ::Test::DPrxList&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    std::deque< ::Test::CPtr> opCSeq(const std::deque< ::Test::CPtr>& inSeq, std::deque< ::Test::CPtr>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opCSeq(outSeq, _iceI_begin_opCSeq(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opCSeq(const std::deque< ::Test::CPtr>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opCSeq(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opCSeq(const std::deque< ::Test::CPtr>& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opCSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opCSeq(const std::deque< ::Test::CPtr>& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opCSeq(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opCSeq(const std::deque< ::Test::CPtr>& inSeq, const ::Test::Callback_TestIntf_opCSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opCSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opCSeq(const std::deque< ::Test::CPtr>& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opCSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opCSeq(inSeq, context, cb, cookie);
    }

    std::deque< ::Test::CPtr> end_opCSeq(std::deque< ::Test::CPtr>& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opCSeq(std::deque< ::Test::CPtr>& iceP_outSeq, std::deque< ::Test::CPtr>& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opCSeq(const std::deque< ::Test::CPtr>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::CList opCList(const ::Test::CList& inSeq, ::Test::CList& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opCList(outSeq, _iceI_begin_opCList(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opCList(const ::Test::CList& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opCList(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opCList(const ::Test::CList& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opCList(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opCList(const ::Test::CList& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opCList(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opCList(const ::Test::CList& inSeq, const ::Test::Callback_TestIntf_opCListPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opCList(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opCList(const ::Test::CList& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opCListPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opCList(inSeq, context, cb, cookie);
    }

    ::Test::CList end_opCList(::Test::CList& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opCList(::Test::CList& iceP_outSeq, ::Test::CList& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opCList(const ::Test::CList&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::ClassStructPtr opClassStruct(const ::Test::ClassStructPtr& inS, const ::Test::ClassStructSeq& inSeq, ::Test::ClassStructPtr& outS, ::Test::ClassStructSeq& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opClassStruct(outS, outSeq, _iceI_begin_opClassStruct(inS, inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opClassStruct(const ::Test::ClassStructPtr& inS, const ::Test::ClassStructSeq& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opClassStruct(inS, inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opClassStruct(const ::Test::ClassStructPtr& inS, const ::Test::ClassStructSeq& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opClassStruct(inS, inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opClassStruct(const ::Test::ClassStructPtr& inS, const ::Test::ClassStructSeq& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opClassStruct(inS, inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opClassStruct(const ::Test::ClassStructPtr& inS, const ::Test::ClassStructSeq& inSeq, const ::Test::Callback_TestIntf_opClassStructPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opClassStruct(inS, inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opClassStruct(const ::Test::ClassStructPtr& inS, const ::Test::ClassStructSeq& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opClassStructPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opClassStruct(inS, inSeq, context, cb, cookie);
    }

    ::Test::ClassStructPtr end_opClassStruct(::Test::ClassStructPtr& outS, ::Test::ClassStructSeq& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opClassStruct(::Test::ClassStructPtr& iceP_outS, ::Test::ClassStructSeq& iceP_outSeq, ::Test::ClassStructPtr& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opClassStruct(const ::Test::ClassStructPtr&, const ::Test::ClassStructSeq&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void opOutArrayByteSeq(const ::Test::ByteSeq& org, ::Test::ByteSeq& copy, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_opOutArrayByteSeq(copy, _iceI_begin_opOutArrayByteSeq(org, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opOutArrayByteSeq(const ::Test::ByteSeq& org, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opOutArrayByteSeq(org, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opOutArrayByteSeq(const ::Test::ByteSeq& org, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOutArrayByteSeq(org, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opOutArrayByteSeq(const ::Test::ByteSeq& org, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOutArrayByteSeq(org, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opOutArrayByteSeq(const ::Test::ByteSeq& org, const ::Test::Callback_TestIntf_opOutArrayByteSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOutArrayByteSeq(org, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opOutArrayByteSeq(const ::Test::ByteSeq& org, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opOutArrayByteSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOutArrayByteSeq(org, context, cb, cookie);
    }

    void end_opOutArrayByteSeq(::Test::ByteSeq& copy, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opOutArrayByteSeq(::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>& iceP_copy, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opOutArrayByteSeq(const ::Test::ByteSeq&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void opOutRangeByteSeq(const ::Test::ByteSeq& org, ::Test::ByteSeq& copy, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_opOutRangeByteSeq(copy, _iceI_begin_opOutRangeByteSeq(org, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opOutRangeByteSeq(const ::Test::ByteSeq& org, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opOutRangeByteSeq(org, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opOutRangeByteSeq(const ::Test::ByteSeq& org, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOutRangeByteSeq(org, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opOutRangeByteSeq(const ::Test::ByteSeq& org, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOutRangeByteSeq(org, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opOutRangeByteSeq(const ::Test::ByteSeq& org, const ::Test::Callback_TestIntf_opOutRangeByteSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOutRangeByteSeq(org, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opOutRangeByteSeq(const ::Test::ByteSeq& org, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opOutRangeByteSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOutRangeByteSeq(org, context, cb, cookie);
    }

    void end_opOutRangeByteSeq(::Test::ByteSeq& copy, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opOutRangeByteSeq(::Test::ByteSeq& iceP_copy, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opOutRangeByteSeq(const ::Test::ByteSeq&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::IntStringDict opIntStringDict(const ::Test::IntStringDict& idict, ::Test::IntStringDict& odict, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opIntStringDict(odict, _iceI_begin_opIntStringDict(idict, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opIntStringDict(const ::Test::IntStringDict& idict, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opIntStringDict(idict, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opIntStringDict(const ::Test::IntStringDict& idict, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opIntStringDict(idict, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opIntStringDict(const ::Test::IntStringDict& idict, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opIntStringDict(idict, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opIntStringDict(const ::Test::IntStringDict& idict, const ::Test::Callback_TestIntf_opIntStringDictPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opIntStringDict(idict, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opIntStringDict(const ::Test::IntStringDict& idict, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opIntStringDictPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opIntStringDict(idict, context, cb, cookie);
    }

    ::Test::IntStringDict end_opIntStringDict(::Test::IntStringDict& odict, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opIntStringDict(::Test::IntStringDict& iceP_odict, ::Test::IntStringDict& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opIntStringDict(const ::Test::IntStringDict&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::CustomMap< ::Ice::Long, ::Ice::Long> opVarDict(const ::Test::CustomMap<std::string, ::Ice::Int>& idict, ::Test::CustomMap<std::string, ::Ice::Int>& odict, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opVarDict(odict, _iceI_begin_opVarDict(idict, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opVarDict(const ::Test::CustomMap<std::string, ::Ice::Int>& idict, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opVarDict(idict, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opVarDict(const ::Test::CustomMap<std::string, ::Ice::Int>& idict, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opVarDict(idict, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opVarDict(const ::Test::CustomMap<std::string, ::Ice::Int>& idict, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opVarDict(idict, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opVarDict(const ::Test::CustomMap<std::string, ::Ice::Int>& idict, const ::Test::Callback_TestIntf_opVarDictPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opVarDict(idict, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opVarDict(const ::Test::CustomMap<std::string, ::Ice::Int>& idict, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opVarDictPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opVarDict(idict, context, cb, cookie);
    }

    ::Test::CustomMap< ::Ice::Long, ::Ice::Long> end_opVarDict(::Test::CustomMap<std::string, ::Ice::Int>& odict, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opVarDict(::Test::CustomMap<std::string, ::Ice::Int>& iceP_odict, ::Test::CustomMap< ::Ice::Long, ::Ice::Long>& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opVarDict(const ::Test::CustomMap<std::string, ::Ice::Int>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::CustomMap< ::Ice::Int, std::string> opCustomIntStringDict(const ::std::map< ::Ice::Int, ::Util::string_view>& idict, ::Test::CustomMap< ::Ice::Int, std::string>& odict, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opCustomIntStringDict(odict, _iceI_begin_opCustomIntStringDict(idict, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opCustomIntStringDict(const ::std::map< ::Ice::Int, ::Util::string_view>& idict, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opCustomIntStringDict(idict, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opCustomIntStringDict(const ::std::map< ::Ice::Int, ::Util::string_view>& idict, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opCustomIntStringDict(idict, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opCustomIntStringDict(const ::std::map< ::Ice::Int, ::Util::string_view>& idict, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opCustomIntStringDict(idict, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opCustomIntStringDict(const ::std::map< ::Ice::Int, ::Util::string_view>& idict, const ::Test::Callback_TestIntf_opCustomIntStringDictPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opCustomIntStringDict(idict, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opCustomIntStringDict(const ::std::map< ::Ice::Int, ::Util::string_view>& idict, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opCustomIntStringDictPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opCustomIntStringDict(idict, context, cb, cookie);
    }

    ::Test::CustomMap< ::Ice::Int, std::string> end_opCustomIntStringDict(::Test::CustomMap< ::Ice::Int, std::string>& odict, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opCustomIntStringDict(::std::map< ::Ice::Int, ::Util::string_view>& iceP_odict, ::std::map< ::Ice::Int, ::Util::string_view>& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opCustomIntStringDict(const ::std::map< ::Ice::Int, ::Util::string_view>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::ShortBuffer opShortBuffer(const ::Test::ShortBuffer& inS, ::Test::ShortBuffer& outS, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opShortBuffer(outS, _iceI_begin_opShortBuffer(inS, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opShortBuffer(const ::Test::ShortBuffer& inS, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opShortBuffer(inS, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opShortBuffer(const ::Test::ShortBuffer& inS, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opShortBuffer(inS, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opShortBuffer(const ::Test::ShortBuffer& inS, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opShortBuffer(inS, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opShortBuffer(const ::Test::ShortBuffer& inS, const ::Test::Callback_TestIntf_opShortBufferPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opShortBuffer(inS, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opShortBuffer(const ::Test::ShortBuffer& inS, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opShortBufferPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opShortBuffer(inS, context, cb, cookie);
    }

    ::Test::ShortBuffer end_opShortBuffer(::Test::ShortBuffer& outS, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opShortBuffer(::Test::ShortBuffer& iceP_outS, ::Test::ShortBuffer& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opShortBuffer(const ::Test::ShortBuffer&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::CustomBuffer<bool> opBoolBuffer(const ::Test::CustomBuffer<bool>& inS, ::Test::CustomBuffer<bool>& outS, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opBoolBuffer(outS, _iceI_begin_opBoolBuffer(inS, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opBoolBuffer(const ::Test::CustomBuffer<bool>& inS, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opBoolBuffer(inS, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opBoolBuffer(const ::Test::CustomBuffer<bool>& inS, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opBoolBuffer(inS, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opBoolBuffer(const ::Test::CustomBuffer<bool>& inS, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opBoolBuffer(inS, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opBoolBuffer(const ::Test::CustomBuffer<bool>& inS, const ::Test::Callback_TestIntf_opBoolBufferPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opBoolBuffer(inS, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opBoolBuffer(const ::Test::CustomBuffer<bool>& inS, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opBoolBufferPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opBoolBuffer(inS, context, cb, cookie);
    }

    ::Test::CustomBuffer<bool> end_opBoolBuffer(::Test::CustomBuffer<bool>& outS, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opBoolBuffer(::Test::CustomBuffer<bool>& iceP_outS, ::Test::CustomBuffer<bool>& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opBoolBuffer(const ::Test::CustomBuffer<bool>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::BufferStruct opBufferStruct(const ::Test::BufferStruct& s, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opBufferStruct(_iceI_begin_opBufferStruct(s, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opBufferStruct(const ::Test::BufferStruct& s, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opBufferStruct(s, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opBufferStruct(const ::Test::BufferStruct& s, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opBufferStruct(s, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opBufferStruct(const ::Test::BufferStruct& s, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opBufferStruct(s, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opBufferStruct(const ::Test::BufferStruct& s, const ::Test::Callback_TestIntf_opBufferStructPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opBufferStruct(s, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opBufferStruct(const ::Test::BufferStruct& s, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opBufferStructPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opBufferStruct(s, context, cb, cookie);
    }

    ::Test::BufferStruct end_opBufferStruct(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_opBufferStruct(const ::Test::BufferStruct&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void shutdown(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_shutdown(_iceI_begin_shutdown(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_shutdown(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_shutdown(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_shutdown(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_shutdown(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_shutdown(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_shutdown(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_shutdown(const ::Test::Callback_TestIntf_shutdownPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_shutdown(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_shutdown(const ::Ice::Context& context, const ::Test::Callback_TestIntf_shutdownPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_shutdown(context, cb, cookie);
    }

    void end_shutdown(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_shutdown(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

}

}

namespace Test
{

class D : public virtual ::Ice::Object
{
public:

    typedef DPrx ProxyType;

    virtual ~D();
    D() = default;
    D(const D&) = default;
    D& operator=(const D&) = default;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();
};

class TestIntf : public virtual ::Ice::Object
{
public:

    typedef TestIntfPrx ProxyType;

    virtual ~TestIntf();
    TestIntf() = default;
    TestIntf(const TestIntf&) = default;
    TestIntf& operator=(const TestIntf&) = default;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual DoubleSeq opDoubleArray(const ::std::pair<const ::Ice::Double*, const ::Ice::Double*>& inSeq, DoubleSeq& outSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opDoubleArray(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual BoolSeq opBoolArray(const ::std::pair<const bool*, const bool*>& inSeq, BoolSeq& outSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opBoolArray(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ByteList opByteArray(const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>& inSeq, ByteList& outSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opByteArray(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual VariableList opVariableArray(const ::std::pair<const Variable*, const Variable*>& inSeq, VariableList& outSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opVariableArray(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual BoolSeq opBoolRange(const ::std::pair<BoolSeq::const_iterator, BoolSeq::const_iterator>& inSeq, BoolSeq& outSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opBoolRange(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ByteList opByteRange(const ::std::pair<ByteList::const_iterator, ByteList::const_iterator>& inSeq, ByteList& outSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opByteRange(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual VariableList opVariableRange(const ::std::pair<VariableList::const_iterator, VariableList::const_iterator>& inSeq, VariableList& outSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opVariableRange(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ByteList opByteRangeType(const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>& inSeq, ByteList& outSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opByteRangeType(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual VariableList opVariableRangeType(const ::std::pair<std::deque< ::Test::Variable>::const_iterator, std::deque< ::Test::Variable>::const_iterator>& inSeq, VariableList& outSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opVariableRangeType(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual std::deque<bool> opBoolSeq(const std::deque<bool>& inSeq, std::deque<bool>& outSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opBoolSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual BoolList opBoolList(const BoolList& inSeq, BoolList& outSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opBoolList(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual BoolDequeList opBoolDequeList(const BoolDequeList& inSeq, BoolDequeList& outSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opBoolDequeList(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual BoolDequeList opBoolDequeListArray(const ::std::pair<const std::deque<bool>*, const std::deque<bool>*>& inSeq, BoolDequeList& outSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opBoolDequeListArray(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual BoolDequeList opBoolDequeListRange(const ::std::pair<BoolDequeList::const_iterator, BoolDequeList::const_iterator>& inSeq, BoolDequeList& outSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opBoolDequeListRange(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual std::deque< ::Ice::Byte> opByteSeq(const std::deque< ::Ice::Byte>& inSeq, std::deque< ::Ice::Byte>& outSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opByteSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ByteList opByteList(const ByteList& inSeq, ByteList& outSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opByteList(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual MyByteSeq opMyByteSeq(const MyByteSeq& inSeq, MyByteSeq& outSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opMyByteSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::std::string opString(const Util::string_view& inString, ::std::string& outString, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opString(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual std::deque<std::string> opStringSeq(const std::deque<std::string>& inSeq, std::deque<std::string>& outSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opStringSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual StringList opStringList(const StringList& inSeq, StringList& outSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opStringList(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual std::deque< ::Test::Fixed> opFixedSeq(const std::deque< ::Test::Fixed>& inSeq, std::deque< ::Test::Fixed>& outSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opFixedSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual FixedList opFixedList(const FixedList& inSeq, FixedList& outSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opFixedList(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual std::deque< ::Test::Variable> opVariableSeq(const std::deque< ::Test::Variable>& inSeq, std::deque< ::Test::Variable>& outSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opVariableSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual VariableList opVariableList(const VariableList& inSeq, VariableList& outSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opVariableList(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual std::deque< ::Test::StringStringDict> opStringStringDictSeq(const std::deque< ::Test::StringStringDict>& inSeq, std::deque< ::Test::StringStringDict>& outSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opStringStringDictSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual StringStringDictList opStringStringDictList(const StringStringDictList& inSeq, StringStringDictList& outSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opStringStringDictList(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual std::deque< ::Test::E> opESeq(const std::deque< ::Test::E>& inSeq, std::deque< ::Test::E>& outSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opESeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual EList opEList(const EList& inSeq, EList& outSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opEList(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual std::deque< ::Test::DPrx> opDPrxSeq(const std::deque< ::Test::DPrx>& inSeq, std::deque< ::Test::DPrx>& outSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opDPrxSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual DPrxList opDPrxList(const DPrxList& inSeq, DPrxList& outSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opDPrxList(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual std::deque< ::Test::CPtr> opCSeq(const std::deque< ::Test::CPtr>& inSeq, std::deque< ::Test::CPtr>& outSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opCSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual CList opCList(const CList& inSeq, CList& outSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opCList(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ClassStructPtr opClassStruct(const ClassStructPtr& inS, const ClassStructSeq& inSeq, ClassStructPtr& outS, ClassStructSeq& outSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opClassStruct(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opOutArrayByteSeq(const ByteSeq& org, ByteSeq& copy, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opOutArrayByteSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opOutRangeByteSeq(const ByteSeq& org, ByteSeq& copy, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opOutRangeByteSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual IntStringDict opIntStringDict(const IntStringDict& idict, IntStringDict& odict, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opIntStringDict(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::Test::CustomMap< ::Ice::Long, ::Ice::Long> opVarDict(const ::Test::CustomMap<std::string, ::Ice::Int>& idict, ::Test::CustomMap<std::string, ::Ice::Int>& odict, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opVarDict(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::Test::CustomMap< ::Ice::Int, std::string> opCustomIntStringDict(const ::std::map< ::Ice::Int, ::Util::string_view>& idict, ::Test::CustomMap< ::Ice::Int, std::string>& odict, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opCustomIntStringDict(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ShortBuffer opShortBuffer(const ShortBuffer& inS, ShortBuffer& outS, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opShortBuffer(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::Test::CustomBuffer<bool> opBoolBuffer(const ::Test::CustomBuffer<bool>& inS, ::Test::CustomBuffer<bool>& outS, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opBoolBuffer(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual BufferStruct opBufferStruct(const BufferStruct& s, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opBufferStruct(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void shutdown(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_shutdown(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond
};

}

namespace Test
{

class C : public ::Ice::Value
{
public:

    typedef CPtr PointerType;

    virtual ~C();

    C()
    {
    }
    C(const C&) = default;
    C& operator=(const C&) = default;

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ValuePtr ice_clone() const;

    /**
     * Obtains the Slice type ID of the most-derived class implemented by this instance.
     * @return The type ID.
     */
    virtual ::std::string ice_id() const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return The type ID.
     */
    static const ::std::string& ice_staticId();

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_C_init = ::Test::C::ice_factory();
/// \endcond

class DictClass : public ::Ice::Value
{
public:

    typedef DictClassPtr PointerType;

    virtual ~DictClass();

    DictClass()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit DictClass(const ::Test::IntStringDict& isdict) :
        isdict(isdict)
    {
    }
    DictClass(const DictClass&) = default;
    DictClass& operator=(const DictClass&) = default;

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ValuePtr ice_clone() const;

    /**
     * Obtains the Slice type ID of the most-derived class implemented by this instance.
     * @return The type ID.
     */
    virtual ::std::string ice_id() const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return The type ID.
     */
    static const ::std::string& ice_staticId();

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    ::Test::IntStringDict isdict;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_DictClass_init = ::Test::DictClass::ice_factory();
/// \endcond

}

/// \cond STREAM
namespace Ice
{

template<>
struct StreamableTraits< ::Test::Fixed>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 2;
    static const bool fixedLength = true;
};

template<typename S>
struct StreamWriter< ::Test::Fixed, S>
{
    static void write(S* ostr, const ::Test::Fixed& v)
    {
        ostr->write(v.s);
    }
};

template<typename S>
struct StreamReader< ::Test::Fixed, S>
{
    static void read(S* istr, ::Test::Fixed& v)
    {
        istr->read(v.s);
    }
};

template<>
struct StreamableTraits< ::Test::Variable>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 3;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::Test::Variable, S>
{
    static void write(S* ostr, const ::Test::Variable& v)
    {
        ostr->write(v.s);
        ostr->write(v.bl);
        ostr->write(v.ss);
    }
};

template<typename S>
struct StreamReader< ::Test::Variable, S>
{
    static void read(S* istr, ::Test::Variable& v)
    {
        istr->read(v.s);
        istr->read(v.bl);
        istr->read(v.ss);
    }
};

template<>
struct StreamableTraits< ::Test::E>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 2;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits< ::Test::ClassOtherStructPtr>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStructClass;
    static const int minWireSize = 4;
    static const bool fixedLength = true;
};

template<typename S>
struct StreamWriter< ::Test::ClassOtherStructPtr, S>
{
    static void write(S* ostr, const ::Test::ClassOtherStructPtr& v)
    {
        ostr->write(v->x);
    }
};

template<typename S>
struct StreamReader< ::Test::ClassOtherStructPtr, S>
{
    static void read(S* istr, ::Test::ClassOtherStructPtr& v)
    {
        istr->read(v->x);
    }
};

template<>
struct StreamableTraits< ::Test::ClassStructPtr>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStructClass;
    static const int minWireSize = 9;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::Test::ClassStructPtr, S>
{
    static void write(S* ostr, const ::Test::ClassStructPtr& v)
    {
        ostr->write(v->otherSeq);
        ostr->write(v->other);
        ostr->write(v->y);
    }
};

template<typename S>
struct StreamReader< ::Test::ClassStructPtr, S>
{
    static void read(S* istr, ::Test::ClassStructPtr& v)
    {
        istr->read(v->otherSeq);
        istr->read(v->other);
        istr->read(v->y);
    }
};

template<typename S>
struct StreamWriter< ::Test::DictClass, S>
{
    static void write(S* ostr, const ::Test::DictClass& v)
    {
        ostr->write(v.isdict);
    }
};

template<typename S>
struct StreamReader< ::Test::DictClass, S>
{
    static void read(S* istr, ::Test::DictClass& v)
    {
        istr->read(v.isdict);
    }
};

template<>
struct StreamableTraits< ::Test::BufferStruct>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 7;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::Test::BufferStruct, S>
{
    static void write(S* ostr, const ::Test::BufferStruct& v)
    {
        ostr->write(v.byteBuf);
        ostr->write(v.boolBuf);
        ostr->write(v.shortBuf);
        ostr->write(v.intBuf);
        ostr->write(v.longBuf);
        ostr->write(v.floatBuf);
        ostr->write(v.doubleBuf);
    }
};

template<typename S>
struct StreamReader< ::Test::BufferStruct, S>
{
    static void read(S* istr, ::Test::BufferStruct& v)
    {
        istr->read(v.byteBuf);
        istr->read(v.boolBuf);
        istr->read(v.shortBuf);
        istr->read(v.intBuf);
        istr->read(v.longBuf);
        istr->read(v.floatBuf);
        istr->read(v.doubleBuf);
    }
};

}
/// \endcond

namespace Test
{

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opDoubleArray.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opDoubleArray.
 */
template<class T>
class CallbackNC_TestIntf_opDoubleArray : public Callback_TestIntf_opDoubleArray_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::pair<const ::Ice::Double*, const ::Ice::Double*>&, const ::std::pair<const ::Ice::Double*, const ::Ice::Double*>&);

    CallbackNC_TestIntf_opDoubleArray(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        ::std::pair<const ::Ice::Double*, const ::Ice::Double*> iceP_outSeq;
        ::std::pair< ::IceUtil::ScopedArray< ::Ice::Double>, ::std::pair<const  ::Ice::Double*, const  ::Ice::Double*> > iceP_outSeq_tmp_;
        ::std::pair<const ::Ice::Double*, const ::Ice::Double*> ret;
        ::std::pair< ::IceUtil::ScopedArray< ::Ice::Double>, ::std::pair<const  ::Ice::Double*, const  ::Ice::Double*> > ret_tmp_;
        try
        {
            proxy->_iceI_end_opDoubleArray(iceP_outSeq_tmp_, ret_tmp_, result);
            iceP_outSeq = iceP_outSeq_tmp_.second;
            ret = ret_tmp_.second;
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opDoubleArray.
 */
template<class T> Callback_TestIntf_opDoubleArrayPtr
newCallback_TestIntf_opDoubleArray(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::pair<const ::Ice::Double*, const ::Ice::Double*>&, const ::std::pair<const ::Ice::Double*, const ::Ice::Double*>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opDoubleArray<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opDoubleArray.
 */
template<class T> Callback_TestIntf_opDoubleArrayPtr
newCallback_TestIntf_opDoubleArray(T* instance, void (T::*cb)(const ::std::pair<const ::Ice::Double*, const ::Ice::Double*>&, const ::std::pair<const ::Ice::Double*, const ::Ice::Double*>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opDoubleArray<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opDoubleArray.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opDoubleArray.
 */
template<class T, typename CT>
class Callback_TestIntf_opDoubleArray : public Callback_TestIntf_opDoubleArray_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::pair<const ::Ice::Double*, const ::Ice::Double*>&, const ::std::pair<const ::Ice::Double*, const ::Ice::Double*>&, const CT&);

    Callback_TestIntf_opDoubleArray(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        ::std::pair<const ::Ice::Double*, const ::Ice::Double*> iceP_outSeq;
        ::std::pair< ::IceUtil::ScopedArray< ::Ice::Double>, ::std::pair<const  ::Ice::Double*, const  ::Ice::Double*> > iceP_outSeq_tmp_;
        ::std::pair<const ::Ice::Double*, const ::Ice::Double*> ret;
        ::std::pair< ::IceUtil::ScopedArray< ::Ice::Double>, ::std::pair<const  ::Ice::Double*, const  ::Ice::Double*> > ret_tmp_;
        try
        {
            proxy->_iceI_end_opDoubleArray(iceP_outSeq_tmp_, ret_tmp_, result);
            iceP_outSeq = iceP_outSeq_tmp_.second;
            ret = ret_tmp_.second;
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opDoubleArray.
 */
template<class T, typename CT> Callback_TestIntf_opDoubleArrayPtr
newCallback_TestIntf_opDoubleArray(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::pair<const ::Ice::Double*, const ::Ice::Double*>&, const ::std::pair<const ::Ice::Double*, const ::Ice::Double*>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opDoubleArray<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opDoubleArray.
 */
template<class T, typename CT> Callback_TestIntf_opDoubleArrayPtr
newCallback_TestIntf_opDoubleArray(T* instance, void (T::*cb)(const ::std::pair<const ::Ice::Double*, const ::Ice::Double*>&, const ::std::pair<const ::Ice::Double*, const ::Ice::Double*>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opDoubleArray<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opBoolArray.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opBoolArray.
 */
template<class T>
class CallbackNC_TestIntf_opBoolArray : public Callback_TestIntf_opBoolArray_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::pair<const bool*, const bool*>&, const ::std::pair<const bool*, const bool*>&);

    CallbackNC_TestIntf_opBoolArray(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        ::std::pair<const bool*, const bool*> iceP_outSeq;
        ::std::pair< ::IceUtil::ScopedArray<bool>, ::std::pair<const bool*, const bool*> > iceP_outSeq_tmp_;
        ::std::pair<const bool*, const bool*> ret;
        ::std::pair< ::IceUtil::ScopedArray<bool>, ::std::pair<const bool*, const bool*> > ret_tmp_;
        try
        {
            proxy->_iceI_end_opBoolArray(iceP_outSeq_tmp_, ret_tmp_, result);
            iceP_outSeq = iceP_outSeq_tmp_.second;
            ret = ret_tmp_.second;
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opBoolArray.
 */
template<class T> Callback_TestIntf_opBoolArrayPtr
newCallback_TestIntf_opBoolArray(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::pair<const bool*, const bool*>&, const ::std::pair<const bool*, const bool*>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opBoolArray<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opBoolArray.
 */
template<class T> Callback_TestIntf_opBoolArrayPtr
newCallback_TestIntf_opBoolArray(T* instance, void (T::*cb)(const ::std::pair<const bool*, const bool*>&, const ::std::pair<const bool*, const bool*>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opBoolArray<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opBoolArray.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opBoolArray.
 */
template<class T, typename CT>
class Callback_TestIntf_opBoolArray : public Callback_TestIntf_opBoolArray_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::pair<const bool*, const bool*>&, const ::std::pair<const bool*, const bool*>&, const CT&);

    Callback_TestIntf_opBoolArray(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        ::std::pair<const bool*, const bool*> iceP_outSeq;
        ::std::pair< ::IceUtil::ScopedArray<bool>, ::std::pair<const bool*, const bool*> > iceP_outSeq_tmp_;
        ::std::pair<const bool*, const bool*> ret;
        ::std::pair< ::IceUtil::ScopedArray<bool>, ::std::pair<const bool*, const bool*> > ret_tmp_;
        try
        {
            proxy->_iceI_end_opBoolArray(iceP_outSeq_tmp_, ret_tmp_, result);
            iceP_outSeq = iceP_outSeq_tmp_.second;
            ret = ret_tmp_.second;
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opBoolArray.
 */
template<class T, typename CT> Callback_TestIntf_opBoolArrayPtr
newCallback_TestIntf_opBoolArray(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::pair<const bool*, const bool*>&, const ::std::pair<const bool*, const bool*>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opBoolArray<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opBoolArray.
 */
template<class T, typename CT> Callback_TestIntf_opBoolArrayPtr
newCallback_TestIntf_opBoolArray(T* instance, void (T::*cb)(const ::std::pair<const bool*, const bool*>&, const ::std::pair<const bool*, const bool*>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opBoolArray<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opByteArray.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opByteArray.
 */
template<class T>
class CallbackNC_TestIntf_opByteArray : public Callback_TestIntf_opByteArray_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>&, const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>&);

    CallbackNC_TestIntf_opByteArray(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*> iceP_outSeq;
        ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*> ret;
        try
        {
            proxy->_iceI_end_opByteArray(iceP_outSeq, ret, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opByteArray.
 */
template<class T> Callback_TestIntf_opByteArrayPtr
newCallback_TestIntf_opByteArray(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>&, const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opByteArray<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opByteArray.
 */
template<class T> Callback_TestIntf_opByteArrayPtr
newCallback_TestIntf_opByteArray(T* instance, void (T::*cb)(const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>&, const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opByteArray<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opByteArray.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opByteArray.
 */
template<class T, typename CT>
class Callback_TestIntf_opByteArray : public Callback_TestIntf_opByteArray_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>&, const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>&, const CT&);

    Callback_TestIntf_opByteArray(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*> iceP_outSeq;
        ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*> ret;
        try
        {
            proxy->_iceI_end_opByteArray(iceP_outSeq, ret, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opByteArray.
 */
template<class T, typename CT> Callback_TestIntf_opByteArrayPtr
newCallback_TestIntf_opByteArray(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>&, const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opByteArray<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opByteArray.
 */
template<class T, typename CT> Callback_TestIntf_opByteArrayPtr
newCallback_TestIntf_opByteArray(T* instance, void (T::*cb)(const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>&, const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opByteArray<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opVariableArray.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opVariableArray.
 */
template<class T>
class CallbackNC_TestIntf_opVariableArray : public Callback_TestIntf_opVariableArray_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::pair<const Variable*, const Variable*>&, const ::std::pair<const Variable*, const Variable*>&);

    CallbackNC_TestIntf_opVariableArray(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        ::std::pair<const Variable*, const Variable*> iceP_outSeq;
        ::std::vector<Variable> iceP_outSeq_tmp_;
        ::std::pair<const Variable*, const Variable*> ret;
        ::std::vector<Variable> ret_tmp_;
        try
        {
            proxy->_iceI_end_opVariableArray(iceP_outSeq_tmp_, ret_tmp_, result);
            if(!iceP_outSeq_tmp_.empty())
            {
                iceP_outSeq.first = &iceP_outSeq_tmp_[0];
                iceP_outSeq.second = iceP_outSeq.first + iceP_outSeq_tmp_.size();
            }
            else
            {
                iceP_outSeq.first = iceP_outSeq.second = 0;
            }
            if(!ret_tmp_.empty())
            {
                ret.first = &ret_tmp_[0];
                ret.second = ret.first + ret_tmp_.size();
            }
            else
            {
                ret.first = ret.second = 0;
            }
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opVariableArray.
 */
template<class T> Callback_TestIntf_opVariableArrayPtr
newCallback_TestIntf_opVariableArray(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::pair<const Variable*, const Variable*>&, const ::std::pair<const Variable*, const Variable*>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opVariableArray<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opVariableArray.
 */
template<class T> Callback_TestIntf_opVariableArrayPtr
newCallback_TestIntf_opVariableArray(T* instance, void (T::*cb)(const ::std::pair<const Variable*, const Variable*>&, const ::std::pair<const Variable*, const Variable*>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opVariableArray<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opVariableArray.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opVariableArray.
 */
template<class T, typename CT>
class Callback_TestIntf_opVariableArray : public Callback_TestIntf_opVariableArray_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::pair<const Variable*, const Variable*>&, const ::std::pair<const Variable*, const Variable*>&, const CT&);

    Callback_TestIntf_opVariableArray(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        ::std::pair<const Variable*, const Variable*> iceP_outSeq;
        ::std::vector<Variable> iceP_outSeq_tmp_;
        ::std::pair<const Variable*, const Variable*> ret;
        ::std::vector<Variable> ret_tmp_;
        try
        {
            proxy->_iceI_end_opVariableArray(iceP_outSeq_tmp_, ret_tmp_, result);
            if(!iceP_outSeq_tmp_.empty())
            {
                iceP_outSeq.first = &iceP_outSeq_tmp_[0];
                iceP_outSeq.second = iceP_outSeq.first + iceP_outSeq_tmp_.size();
            }
            else
            {
                iceP_outSeq.first = iceP_outSeq.second = 0;
            }
            if(!ret_tmp_.empty())
            {
                ret.first = &ret_tmp_[0];
                ret.second = ret.first + ret_tmp_.size();
            }
            else
            {
                ret.first = ret.second = 0;
            }
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opVariableArray.
 */
template<class T, typename CT> Callback_TestIntf_opVariableArrayPtr
newCallback_TestIntf_opVariableArray(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::pair<const Variable*, const Variable*>&, const ::std::pair<const Variable*, const Variable*>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opVariableArray<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opVariableArray.
 */
template<class T, typename CT> Callback_TestIntf_opVariableArrayPtr
newCallback_TestIntf_opVariableArray(T* instance, void (T::*cb)(const ::std::pair<const Variable*, const Variable*>&, const ::std::pair<const Variable*, const Variable*>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opVariableArray<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opBoolRange.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opBoolRange.
 */
template<class T>
class CallbackNC_TestIntf_opBoolRange : public Callback_TestIntf_opBoolRange_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::pair<BoolSeq::const_iterator, BoolSeq::const_iterator>&, const ::std::pair<BoolSeq::const_iterator, BoolSeq::const_iterator>&);

    CallbackNC_TestIntf_opBoolRange(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        ::std::pair<BoolSeq::const_iterator, BoolSeq::const_iterator> iceP_outSeq;
        BoolSeq iceP_outSeq_tmp_;
        ::std::pair<BoolSeq::const_iterator, BoolSeq::const_iterator> ret;
        BoolSeq ret_tmp_;
        try
        {
            ret_tmp_ = proxy->end_opBoolRange(iceP_outSeq_tmp_, result);
            iceP_outSeq.first = iceP_outSeq_tmp_.begin();
            iceP_outSeq.second = iceP_outSeq_tmp_.end();
            ret.first = ret_tmp_.begin();
            ret.second = ret_tmp_.end();
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opBoolRange.
 */
template<class T> Callback_TestIntf_opBoolRangePtr
newCallback_TestIntf_opBoolRange(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::pair<BoolSeq::const_iterator, BoolSeq::const_iterator>&, const ::std::pair<BoolSeq::const_iterator, BoolSeq::const_iterator>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opBoolRange<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opBoolRange.
 */
template<class T> Callback_TestIntf_opBoolRangePtr
newCallback_TestIntf_opBoolRange(T* instance, void (T::*cb)(const ::std::pair<BoolSeq::const_iterator, BoolSeq::const_iterator>&, const ::std::pair<BoolSeq::const_iterator, BoolSeq::const_iterator>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opBoolRange<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opBoolRange.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opBoolRange.
 */
template<class T, typename CT>
class Callback_TestIntf_opBoolRange : public Callback_TestIntf_opBoolRange_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::pair<BoolSeq::const_iterator, BoolSeq::const_iterator>&, const ::std::pair<BoolSeq::const_iterator, BoolSeq::const_iterator>&, const CT&);

    Callback_TestIntf_opBoolRange(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        ::std::pair<BoolSeq::const_iterator, BoolSeq::const_iterator> iceP_outSeq;
        BoolSeq iceP_outSeq_tmp_;
        ::std::pair<BoolSeq::const_iterator, BoolSeq::const_iterator> ret;
        BoolSeq ret_tmp_;
        try
        {
            ret_tmp_ = proxy->end_opBoolRange(iceP_outSeq_tmp_, result);
            iceP_outSeq.first = iceP_outSeq_tmp_.begin();
            iceP_outSeq.second = iceP_outSeq_tmp_.end();
            ret.first = ret_tmp_.begin();
            ret.second = ret_tmp_.end();
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opBoolRange.
 */
template<class T, typename CT> Callback_TestIntf_opBoolRangePtr
newCallback_TestIntf_opBoolRange(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::pair<BoolSeq::const_iterator, BoolSeq::const_iterator>&, const ::std::pair<BoolSeq::const_iterator, BoolSeq::const_iterator>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opBoolRange<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opBoolRange.
 */
template<class T, typename CT> Callback_TestIntf_opBoolRangePtr
newCallback_TestIntf_opBoolRange(T* instance, void (T::*cb)(const ::std::pair<BoolSeq::const_iterator, BoolSeq::const_iterator>&, const ::std::pair<BoolSeq::const_iterator, BoolSeq::const_iterator>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opBoolRange<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opByteRange.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opByteRange.
 */
template<class T>
class CallbackNC_TestIntf_opByteRange : public Callback_TestIntf_opByteRange_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::pair<ByteList::const_iterator, ByteList::const_iterator>&, const ::std::pair<ByteList::const_iterator, ByteList::const_iterator>&);

    CallbackNC_TestIntf_opByteRange(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        ::std::pair<ByteList::const_iterator, ByteList::const_iterator> iceP_outSeq;
        ByteList iceP_outSeq_tmp_;
        ::std::pair<ByteList::const_iterator, ByteList::const_iterator> ret;
        ByteList ret_tmp_;
        try
        {
            ret_tmp_ = proxy->end_opByteRange(iceP_outSeq_tmp_, result);
            iceP_outSeq.first = iceP_outSeq_tmp_.begin();
            iceP_outSeq.second = iceP_outSeq_tmp_.end();
            ret.first = ret_tmp_.begin();
            ret.second = ret_tmp_.end();
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opByteRange.
 */
template<class T> Callback_TestIntf_opByteRangePtr
newCallback_TestIntf_opByteRange(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::pair<ByteList::const_iterator, ByteList::const_iterator>&, const ::std::pair<ByteList::const_iterator, ByteList::const_iterator>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opByteRange<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opByteRange.
 */
template<class T> Callback_TestIntf_opByteRangePtr
newCallback_TestIntf_opByteRange(T* instance, void (T::*cb)(const ::std::pair<ByteList::const_iterator, ByteList::const_iterator>&, const ::std::pair<ByteList::const_iterator, ByteList::const_iterator>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opByteRange<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opByteRange.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opByteRange.
 */
template<class T, typename CT>
class Callback_TestIntf_opByteRange : public Callback_TestIntf_opByteRange_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::pair<ByteList::const_iterator, ByteList::const_iterator>&, const ::std::pair<ByteList::const_iterator, ByteList::const_iterator>&, const CT&);

    Callback_TestIntf_opByteRange(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        ::std::pair<ByteList::const_iterator, ByteList::const_iterator> iceP_outSeq;
        ByteList iceP_outSeq_tmp_;
        ::std::pair<ByteList::const_iterator, ByteList::const_iterator> ret;
        ByteList ret_tmp_;
        try
        {
            ret_tmp_ = proxy->end_opByteRange(iceP_outSeq_tmp_, result);
            iceP_outSeq.first = iceP_outSeq_tmp_.begin();
            iceP_outSeq.second = iceP_outSeq_tmp_.end();
            ret.first = ret_tmp_.begin();
            ret.second = ret_tmp_.end();
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opByteRange.
 */
template<class T, typename CT> Callback_TestIntf_opByteRangePtr
newCallback_TestIntf_opByteRange(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::pair<ByteList::const_iterator, ByteList::const_iterator>&, const ::std::pair<ByteList::const_iterator, ByteList::const_iterator>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opByteRange<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opByteRange.
 */
template<class T, typename CT> Callback_TestIntf_opByteRangePtr
newCallback_TestIntf_opByteRange(T* instance, void (T::*cb)(const ::std::pair<ByteList::const_iterator, ByteList::const_iterator>&, const ::std::pair<ByteList::const_iterator, ByteList::const_iterator>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opByteRange<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opVariableRange.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opVariableRange.
 */
template<class T>
class CallbackNC_TestIntf_opVariableRange : public Callback_TestIntf_opVariableRange_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::pair<VariableList::const_iterator, VariableList::const_iterator>&, const ::std::pair<VariableList::const_iterator, VariableList::const_iterator>&);

    CallbackNC_TestIntf_opVariableRange(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        ::std::pair<VariableList::const_iterator, VariableList::const_iterator> iceP_outSeq;
        VariableList iceP_outSeq_tmp_;
        ::std::pair<VariableList::const_iterator, VariableList::const_iterator> ret;
        VariableList ret_tmp_;
        try
        {
            ret_tmp_ = proxy->end_opVariableRange(iceP_outSeq_tmp_, result);
            iceP_outSeq.first = iceP_outSeq_tmp_.begin();
            iceP_outSeq.second = iceP_outSeq_tmp_.end();
            ret.first = ret_tmp_.begin();
            ret.second = ret_tmp_.end();
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opVariableRange.
 */
template<class T> Callback_TestIntf_opVariableRangePtr
newCallback_TestIntf_opVariableRange(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::pair<VariableList::const_iterator, VariableList::const_iterator>&, const ::std::pair<VariableList::const_iterator, VariableList::const_iterator>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opVariableRange<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opVariableRange.
 */
template<class T> Callback_TestIntf_opVariableRangePtr
newCallback_TestIntf_opVariableRange(T* instance, void (T::*cb)(const ::std::pair<VariableList::const_iterator, VariableList::const_iterator>&, const ::std::pair<VariableList::const_iterator, VariableList::const_iterator>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opVariableRange<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opVariableRange.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opVariableRange.
 */
template<class T, typename CT>
class Callback_TestIntf_opVariableRange : public Callback_TestIntf_opVariableRange_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::pair<VariableList::const_iterator, VariableList::const_iterator>&, const ::std::pair<VariableList::const_iterator, VariableList::const_iterator>&, const CT&);

    Callback_TestIntf_opVariableRange(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        ::std::pair<VariableList::const_iterator, VariableList::const_iterator> iceP_outSeq;
        VariableList iceP_outSeq_tmp_;
        ::std::pair<VariableList::const_iterator, VariableList::const_iterator> ret;
        VariableList ret_tmp_;
        try
        {
            ret_tmp_ = proxy->end_opVariableRange(iceP_outSeq_tmp_, result);
            iceP_outSeq.first = iceP_outSeq_tmp_.begin();
            iceP_outSeq.second = iceP_outSeq_tmp_.end();
            ret.first = ret_tmp_.begin();
            ret.second = ret_tmp_.end();
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opVariableRange.
 */
template<class T, typename CT> Callback_TestIntf_opVariableRangePtr
newCallback_TestIntf_opVariableRange(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::pair<VariableList::const_iterator, VariableList::const_iterator>&, const ::std::pair<VariableList::const_iterator, VariableList::const_iterator>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opVariableRange<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opVariableRange.
 */
template<class T, typename CT> Callback_TestIntf_opVariableRangePtr
newCallback_TestIntf_opVariableRange(T* instance, void (T::*cb)(const ::std::pair<VariableList::const_iterator, VariableList::const_iterator>&, const ::std::pair<VariableList::const_iterator, VariableList::const_iterator>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opVariableRange<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opByteRangeType.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opByteRangeType.
 */
template<class T>
class CallbackNC_TestIntf_opByteRangeType : public Callback_TestIntf_opByteRangeType_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>&, const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>&);

    CallbackNC_TestIntf_opByteRangeType(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator> iceP_outSeq;
        ::Test::ByteList iceP_outSeq_tmp_;
        ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator> ret;
        ::Test::ByteList ret_tmp_;
        try
        {
            ret_tmp_ = proxy->end_opByteRangeType(iceP_outSeq_tmp_, result);
            iceP_outSeq.first = iceP_outSeq_tmp_.begin();
            iceP_outSeq.second = iceP_outSeq_tmp_.end();
            ret.first = ret_tmp_.begin();
            ret.second = ret_tmp_.end();
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opByteRangeType.
 */
template<class T> Callback_TestIntf_opByteRangeTypePtr
newCallback_TestIntf_opByteRangeType(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>&, const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opByteRangeType<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opByteRangeType.
 */
template<class T> Callback_TestIntf_opByteRangeTypePtr
newCallback_TestIntf_opByteRangeType(T* instance, void (T::*cb)(const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>&, const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opByteRangeType<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opByteRangeType.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opByteRangeType.
 */
template<class T, typename CT>
class Callback_TestIntf_opByteRangeType : public Callback_TestIntf_opByteRangeType_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>&, const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>&, const CT&);

    Callback_TestIntf_opByteRangeType(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator> iceP_outSeq;
        ::Test::ByteList iceP_outSeq_tmp_;
        ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator> ret;
        ::Test::ByteList ret_tmp_;
        try
        {
            ret_tmp_ = proxy->end_opByteRangeType(iceP_outSeq_tmp_, result);
            iceP_outSeq.first = iceP_outSeq_tmp_.begin();
            iceP_outSeq.second = iceP_outSeq_tmp_.end();
            ret.first = ret_tmp_.begin();
            ret.second = ret_tmp_.end();
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opByteRangeType.
 */
template<class T, typename CT> Callback_TestIntf_opByteRangeTypePtr
newCallback_TestIntf_opByteRangeType(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>&, const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opByteRangeType<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opByteRangeType.
 */
template<class T, typename CT> Callback_TestIntf_opByteRangeTypePtr
newCallback_TestIntf_opByteRangeType(T* instance, void (T::*cb)(const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>&, const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opByteRangeType<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opVariableRangeType.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opVariableRangeType.
 */
template<class T>
class CallbackNC_TestIntf_opVariableRangeType : public Callback_TestIntf_opVariableRangeType_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::pair<std::deque< ::Test::Variable>::const_iterator, std::deque< ::Test::Variable>::const_iterator>&, const ::std::pair<std::deque< ::Test::Variable>::const_iterator, std::deque< ::Test::Variable>::const_iterator>&);

    CallbackNC_TestIntf_opVariableRangeType(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        ::std::pair<std::deque< ::Test::Variable>::const_iterator, std::deque< ::Test::Variable>::const_iterator> iceP_outSeq;
        std::deque< ::Test::Variable> iceP_outSeq_tmp_;
        ::std::pair<std::deque< ::Test::Variable>::const_iterator, std::deque< ::Test::Variable>::const_iterator> ret;
        std::deque< ::Test::Variable> ret_tmp_;
        try
        {
            proxy->_iceI_end_opVariableRangeType(iceP_outSeq_tmp_, ret_tmp_, result);
            iceP_outSeq.first = iceP_outSeq_tmp_.begin();
            iceP_outSeq.second = iceP_outSeq_tmp_.end();
            ret.first = ret_tmp_.begin();
            ret.second = ret_tmp_.end();
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opVariableRangeType.
 */
template<class T> Callback_TestIntf_opVariableRangeTypePtr
newCallback_TestIntf_opVariableRangeType(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::pair<std::deque< ::Test::Variable>::const_iterator, std::deque< ::Test::Variable>::const_iterator>&, const ::std::pair<std::deque< ::Test::Variable>::const_iterator, std::deque< ::Test::Variable>::const_iterator>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opVariableRangeType<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opVariableRangeType.
 */
template<class T> Callback_TestIntf_opVariableRangeTypePtr
newCallback_TestIntf_opVariableRangeType(T* instance, void (T::*cb)(const ::std::pair<std::deque< ::Test::Variable>::const_iterator, std::deque< ::Test::Variable>::const_iterator>&, const ::std::pair<std::deque< ::Test::Variable>::const_iterator, std::deque< ::Test::Variable>::const_iterator>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opVariableRangeType<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opVariableRangeType.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opVariableRangeType.
 */
template<class T, typename CT>
class Callback_TestIntf_opVariableRangeType : public Callback_TestIntf_opVariableRangeType_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::pair<std::deque< ::Test::Variable>::const_iterator, std::deque< ::Test::Variable>::const_iterator>&, const ::std::pair<std::deque< ::Test::Variable>::const_iterator, std::deque< ::Test::Variable>::const_iterator>&, const CT&);

    Callback_TestIntf_opVariableRangeType(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        ::std::pair<std::deque< ::Test::Variable>::const_iterator, std::deque< ::Test::Variable>::const_iterator> iceP_outSeq;
        std::deque< ::Test::Variable> iceP_outSeq_tmp_;
        ::std::pair<std::deque< ::Test::Variable>::const_iterator, std::deque< ::Test::Variable>::const_iterator> ret;
        std::deque< ::Test::Variable> ret_tmp_;
        try
        {
            proxy->_iceI_end_opVariableRangeType(iceP_outSeq_tmp_, ret_tmp_, result);
            iceP_outSeq.first = iceP_outSeq_tmp_.begin();
            iceP_outSeq.second = iceP_outSeq_tmp_.end();
            ret.first = ret_tmp_.begin();
            ret.second = ret_tmp_.end();
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opVariableRangeType.
 */
template<class T, typename CT> Callback_TestIntf_opVariableRangeTypePtr
newCallback_TestIntf_opVariableRangeType(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::pair<std::deque< ::Test::Variable>::const_iterator, std::deque< ::Test::Variable>::const_iterator>&, const ::std::pair<std::deque< ::Test::Variable>::const_iterator, std::deque< ::Test::Variable>::const_iterator>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opVariableRangeType<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opVariableRangeType.
 */
template<class T, typename CT> Callback_TestIntf_opVariableRangeTypePtr
newCallback_TestIntf_opVariableRangeType(T* instance, void (T::*cb)(const ::std::pair<std::deque< ::Test::Variable>::const_iterator, std::deque< ::Test::Variable>::const_iterator>&, const ::std::pair<std::deque< ::Test::Variable>::const_iterator, std::deque< ::Test::Variable>::const_iterator>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opVariableRangeType<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opBoolSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opBoolSeq.
 */
template<class T>
class CallbackNC_TestIntf_opBoolSeq : public Callback_TestIntf_opBoolSeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const std::deque<bool>&, const std::deque<bool>&);

    CallbackNC_TestIntf_opBoolSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        std::deque<bool> iceP_outSeq;
        std::deque<bool> ret;
        try
        {
            ret = proxy->end_opBoolSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opBoolSeq.
 */
template<class T> Callback_TestIntf_opBoolSeqPtr
newCallback_TestIntf_opBoolSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const std::deque<bool>&, const std::deque<bool>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opBoolSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opBoolSeq.
 */
template<class T> Callback_TestIntf_opBoolSeqPtr
newCallback_TestIntf_opBoolSeq(T* instance, void (T::*cb)(const std::deque<bool>&, const std::deque<bool>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opBoolSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opBoolSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opBoolSeq.
 */
template<class T, typename CT>
class Callback_TestIntf_opBoolSeq : public Callback_TestIntf_opBoolSeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const std::deque<bool>&, const std::deque<bool>&, const CT&);

    Callback_TestIntf_opBoolSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        std::deque<bool> iceP_outSeq;
        std::deque<bool> ret;
        try
        {
            ret = proxy->end_opBoolSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opBoolSeq.
 */
template<class T, typename CT> Callback_TestIntf_opBoolSeqPtr
newCallback_TestIntf_opBoolSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const std::deque<bool>&, const std::deque<bool>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opBoolSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opBoolSeq.
 */
template<class T, typename CT> Callback_TestIntf_opBoolSeqPtr
newCallback_TestIntf_opBoolSeq(T* instance, void (T::*cb)(const std::deque<bool>&, const std::deque<bool>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opBoolSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opBoolList.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opBoolList.
 */
template<class T>
class CallbackNC_TestIntf_opBoolList : public Callback_TestIntf_opBoolList_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const BoolList&, const BoolList&);

    CallbackNC_TestIntf_opBoolList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        BoolList iceP_outSeq;
        BoolList ret;
        try
        {
            ret = proxy->end_opBoolList(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opBoolList.
 */
template<class T> Callback_TestIntf_opBoolListPtr
newCallback_TestIntf_opBoolList(const IceUtil::Handle<T>& instance, void (T::*cb)(const BoolList&, const BoolList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opBoolList<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opBoolList.
 */
template<class T> Callback_TestIntf_opBoolListPtr
newCallback_TestIntf_opBoolList(T* instance, void (T::*cb)(const BoolList&, const BoolList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opBoolList<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opBoolList.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opBoolList.
 */
template<class T, typename CT>
class Callback_TestIntf_opBoolList : public Callback_TestIntf_opBoolList_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const BoolList&, const BoolList&, const CT&);

    Callback_TestIntf_opBoolList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        BoolList iceP_outSeq;
        BoolList ret;
        try
        {
            ret = proxy->end_opBoolList(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opBoolList.
 */
template<class T, typename CT> Callback_TestIntf_opBoolListPtr
newCallback_TestIntf_opBoolList(const IceUtil::Handle<T>& instance, void (T::*cb)(const BoolList&, const BoolList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opBoolList<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opBoolList.
 */
template<class T, typename CT> Callback_TestIntf_opBoolListPtr
newCallback_TestIntf_opBoolList(T* instance, void (T::*cb)(const BoolList&, const BoolList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opBoolList<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opBoolDequeList.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opBoolDequeList.
 */
template<class T>
class CallbackNC_TestIntf_opBoolDequeList : public Callback_TestIntf_opBoolDequeList_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const BoolDequeList&, const BoolDequeList&);

    CallbackNC_TestIntf_opBoolDequeList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        BoolDequeList iceP_outSeq;
        BoolDequeList ret;
        try
        {
            ret = proxy->end_opBoolDequeList(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opBoolDequeList.
 */
template<class T> Callback_TestIntf_opBoolDequeListPtr
newCallback_TestIntf_opBoolDequeList(const IceUtil::Handle<T>& instance, void (T::*cb)(const BoolDequeList&, const BoolDequeList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opBoolDequeList<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opBoolDequeList.
 */
template<class T> Callback_TestIntf_opBoolDequeListPtr
newCallback_TestIntf_opBoolDequeList(T* instance, void (T::*cb)(const BoolDequeList&, const BoolDequeList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opBoolDequeList<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opBoolDequeList.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opBoolDequeList.
 */
template<class T, typename CT>
class Callback_TestIntf_opBoolDequeList : public Callback_TestIntf_opBoolDequeList_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const BoolDequeList&, const BoolDequeList&, const CT&);

    Callback_TestIntf_opBoolDequeList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        BoolDequeList iceP_outSeq;
        BoolDequeList ret;
        try
        {
            ret = proxy->end_opBoolDequeList(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opBoolDequeList.
 */
template<class T, typename CT> Callback_TestIntf_opBoolDequeListPtr
newCallback_TestIntf_opBoolDequeList(const IceUtil::Handle<T>& instance, void (T::*cb)(const BoolDequeList&, const BoolDequeList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opBoolDequeList<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opBoolDequeList.
 */
template<class T, typename CT> Callback_TestIntf_opBoolDequeListPtr
newCallback_TestIntf_opBoolDequeList(T* instance, void (T::*cb)(const BoolDequeList&, const BoolDequeList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opBoolDequeList<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opBoolDequeListArray.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opBoolDequeListArray.
 */
template<class T>
class CallbackNC_TestIntf_opBoolDequeListArray : public Callback_TestIntf_opBoolDequeListArray_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::pair<const std::deque<bool>*, const std::deque<bool>*>&, const ::std::pair<const std::deque<bool>*, const std::deque<bool>*>&);

    CallbackNC_TestIntf_opBoolDequeListArray(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        ::std::pair<const std::deque<bool>*, const std::deque<bool>*> iceP_outSeq;
        ::std::vector<std::deque<bool> > iceP_outSeq_tmp_;
        ::std::pair<const std::deque<bool>*, const std::deque<bool>*> ret;
        ::std::vector<std::deque<bool> > ret_tmp_;
        try
        {
            proxy->_iceI_end_opBoolDequeListArray(iceP_outSeq_tmp_, ret_tmp_, result);
            if(!iceP_outSeq_tmp_.empty())
            {
                iceP_outSeq.first = &iceP_outSeq_tmp_[0];
                iceP_outSeq.second = iceP_outSeq.first + iceP_outSeq_tmp_.size();
            }
            else
            {
                iceP_outSeq.first = iceP_outSeq.second = 0;
            }
            if(!ret_tmp_.empty())
            {
                ret.first = &ret_tmp_[0];
                ret.second = ret.first + ret_tmp_.size();
            }
            else
            {
                ret.first = ret.second = 0;
            }
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opBoolDequeListArray.
 */
template<class T> Callback_TestIntf_opBoolDequeListArrayPtr
newCallback_TestIntf_opBoolDequeListArray(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::pair<const std::deque<bool>*, const std::deque<bool>*>&, const ::std::pair<const std::deque<bool>*, const std::deque<bool>*>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opBoolDequeListArray<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opBoolDequeListArray.
 */
template<class T> Callback_TestIntf_opBoolDequeListArrayPtr
newCallback_TestIntf_opBoolDequeListArray(T* instance, void (T::*cb)(const ::std::pair<const std::deque<bool>*, const std::deque<bool>*>&, const ::std::pair<const std::deque<bool>*, const std::deque<bool>*>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opBoolDequeListArray<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opBoolDequeListArray.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opBoolDequeListArray.
 */
template<class T, typename CT>
class Callback_TestIntf_opBoolDequeListArray : public Callback_TestIntf_opBoolDequeListArray_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::pair<const std::deque<bool>*, const std::deque<bool>*>&, const ::std::pair<const std::deque<bool>*, const std::deque<bool>*>&, const CT&);

    Callback_TestIntf_opBoolDequeListArray(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        ::std::pair<const std::deque<bool>*, const std::deque<bool>*> iceP_outSeq;
        ::std::vector<std::deque<bool> > iceP_outSeq_tmp_;
        ::std::pair<const std::deque<bool>*, const std::deque<bool>*> ret;
        ::std::vector<std::deque<bool> > ret_tmp_;
        try
        {
            proxy->_iceI_end_opBoolDequeListArray(iceP_outSeq_tmp_, ret_tmp_, result);
            if(!iceP_outSeq_tmp_.empty())
            {
                iceP_outSeq.first = &iceP_outSeq_tmp_[0];
                iceP_outSeq.second = iceP_outSeq.first + iceP_outSeq_tmp_.size();
            }
            else
            {
                iceP_outSeq.first = iceP_outSeq.second = 0;
            }
            if(!ret_tmp_.empty())
            {
                ret.first = &ret_tmp_[0];
                ret.second = ret.first + ret_tmp_.size();
            }
            else
            {
                ret.first = ret.second = 0;
            }
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opBoolDequeListArray.
 */
template<class T, typename CT> Callback_TestIntf_opBoolDequeListArrayPtr
newCallback_TestIntf_opBoolDequeListArray(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::pair<const std::deque<bool>*, const std::deque<bool>*>&, const ::std::pair<const std::deque<bool>*, const std::deque<bool>*>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opBoolDequeListArray<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opBoolDequeListArray.
 */
template<class T, typename CT> Callback_TestIntf_opBoolDequeListArrayPtr
newCallback_TestIntf_opBoolDequeListArray(T* instance, void (T::*cb)(const ::std::pair<const std::deque<bool>*, const std::deque<bool>*>&, const ::std::pair<const std::deque<bool>*, const std::deque<bool>*>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opBoolDequeListArray<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opBoolDequeListRange.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opBoolDequeListRange.
 */
template<class T>
class CallbackNC_TestIntf_opBoolDequeListRange : public Callback_TestIntf_opBoolDequeListRange_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::pair<BoolDequeList::const_iterator, BoolDequeList::const_iterator>&, const ::std::pair<BoolDequeList::const_iterator, BoolDequeList::const_iterator>&);

    CallbackNC_TestIntf_opBoolDequeListRange(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        ::std::pair<BoolDequeList::const_iterator, BoolDequeList::const_iterator> iceP_outSeq;
        BoolDequeList iceP_outSeq_tmp_;
        ::std::pair<BoolDequeList::const_iterator, BoolDequeList::const_iterator> ret;
        BoolDequeList ret_tmp_;
        try
        {
            ret_tmp_ = proxy->end_opBoolDequeListRange(iceP_outSeq_tmp_, result);
            iceP_outSeq.first = iceP_outSeq_tmp_.begin();
            iceP_outSeq.second = iceP_outSeq_tmp_.end();
            ret.first = ret_tmp_.begin();
            ret.second = ret_tmp_.end();
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opBoolDequeListRange.
 */
template<class T> Callback_TestIntf_opBoolDequeListRangePtr
newCallback_TestIntf_opBoolDequeListRange(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::pair<BoolDequeList::const_iterator, BoolDequeList::const_iterator>&, const ::std::pair<BoolDequeList::const_iterator, BoolDequeList::const_iterator>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opBoolDequeListRange<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opBoolDequeListRange.
 */
template<class T> Callback_TestIntf_opBoolDequeListRangePtr
newCallback_TestIntf_opBoolDequeListRange(T* instance, void (T::*cb)(const ::std::pair<BoolDequeList::const_iterator, BoolDequeList::const_iterator>&, const ::std::pair<BoolDequeList::const_iterator, BoolDequeList::const_iterator>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opBoolDequeListRange<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opBoolDequeListRange.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opBoolDequeListRange.
 */
template<class T, typename CT>
class Callback_TestIntf_opBoolDequeListRange : public Callback_TestIntf_opBoolDequeListRange_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::pair<BoolDequeList::const_iterator, BoolDequeList::const_iterator>&, const ::std::pair<BoolDequeList::const_iterator, BoolDequeList::const_iterator>&, const CT&);

    Callback_TestIntf_opBoolDequeListRange(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        ::std::pair<BoolDequeList::const_iterator, BoolDequeList::const_iterator> iceP_outSeq;
        BoolDequeList iceP_outSeq_tmp_;
        ::std::pair<BoolDequeList::const_iterator, BoolDequeList::const_iterator> ret;
        BoolDequeList ret_tmp_;
        try
        {
            ret_tmp_ = proxy->end_opBoolDequeListRange(iceP_outSeq_tmp_, result);
            iceP_outSeq.first = iceP_outSeq_tmp_.begin();
            iceP_outSeq.second = iceP_outSeq_tmp_.end();
            ret.first = ret_tmp_.begin();
            ret.second = ret_tmp_.end();
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opBoolDequeListRange.
 */
template<class T, typename CT> Callback_TestIntf_opBoolDequeListRangePtr
newCallback_TestIntf_opBoolDequeListRange(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::pair<BoolDequeList::const_iterator, BoolDequeList::const_iterator>&, const ::std::pair<BoolDequeList::const_iterator, BoolDequeList::const_iterator>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opBoolDequeListRange<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opBoolDequeListRange.
 */
template<class T, typename CT> Callback_TestIntf_opBoolDequeListRangePtr
newCallback_TestIntf_opBoolDequeListRange(T* instance, void (T::*cb)(const ::std::pair<BoolDequeList::const_iterator, BoolDequeList::const_iterator>&, const ::std::pair<BoolDequeList::const_iterator, BoolDequeList::const_iterator>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opBoolDequeListRange<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opByteSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opByteSeq.
 */
template<class T>
class CallbackNC_TestIntf_opByteSeq : public Callback_TestIntf_opByteSeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const std::deque< ::Ice::Byte>&, const std::deque< ::Ice::Byte>&);

    CallbackNC_TestIntf_opByteSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        std::deque< ::Ice::Byte> iceP_outSeq;
        std::deque< ::Ice::Byte> ret;
        try
        {
            ret = proxy->end_opByteSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opByteSeq.
 */
template<class T> Callback_TestIntf_opByteSeqPtr
newCallback_TestIntf_opByteSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const std::deque< ::Ice::Byte>&, const std::deque< ::Ice::Byte>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opByteSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opByteSeq.
 */
template<class T> Callback_TestIntf_opByteSeqPtr
newCallback_TestIntf_opByteSeq(T* instance, void (T::*cb)(const std::deque< ::Ice::Byte>&, const std::deque< ::Ice::Byte>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opByteSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opByteSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opByteSeq.
 */
template<class T, typename CT>
class Callback_TestIntf_opByteSeq : public Callback_TestIntf_opByteSeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const std::deque< ::Ice::Byte>&, const std::deque< ::Ice::Byte>&, const CT&);

    Callback_TestIntf_opByteSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        std::deque< ::Ice::Byte> iceP_outSeq;
        std::deque< ::Ice::Byte> ret;
        try
        {
            ret = proxy->end_opByteSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opByteSeq.
 */
template<class T, typename CT> Callback_TestIntf_opByteSeqPtr
newCallback_TestIntf_opByteSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const std::deque< ::Ice::Byte>&, const std::deque< ::Ice::Byte>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opByteSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opByteSeq.
 */
template<class T, typename CT> Callback_TestIntf_opByteSeqPtr
newCallback_TestIntf_opByteSeq(T* instance, void (T::*cb)(const std::deque< ::Ice::Byte>&, const std::deque< ::Ice::Byte>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opByteSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opByteList.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opByteList.
 */
template<class T>
class CallbackNC_TestIntf_opByteList : public Callback_TestIntf_opByteList_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ByteList&, const ByteList&);

    CallbackNC_TestIntf_opByteList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        ByteList iceP_outSeq;
        ByteList ret;
        try
        {
            ret = proxy->end_opByteList(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opByteList.
 */
template<class T> Callback_TestIntf_opByteListPtr
newCallback_TestIntf_opByteList(const IceUtil::Handle<T>& instance, void (T::*cb)(const ByteList&, const ByteList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opByteList<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opByteList.
 */
template<class T> Callback_TestIntf_opByteListPtr
newCallback_TestIntf_opByteList(T* instance, void (T::*cb)(const ByteList&, const ByteList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opByteList<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opByteList.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opByteList.
 */
template<class T, typename CT>
class Callback_TestIntf_opByteList : public Callback_TestIntf_opByteList_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ByteList&, const ByteList&, const CT&);

    Callback_TestIntf_opByteList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        ByteList iceP_outSeq;
        ByteList ret;
        try
        {
            ret = proxy->end_opByteList(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opByteList.
 */
template<class T, typename CT> Callback_TestIntf_opByteListPtr
newCallback_TestIntf_opByteList(const IceUtil::Handle<T>& instance, void (T::*cb)(const ByteList&, const ByteList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opByteList<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opByteList.
 */
template<class T, typename CT> Callback_TestIntf_opByteListPtr
newCallback_TestIntf_opByteList(T* instance, void (T::*cb)(const ByteList&, const ByteList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opByteList<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opMyByteSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opMyByteSeq.
 */
template<class T>
class CallbackNC_TestIntf_opMyByteSeq : public Callback_TestIntf_opMyByteSeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const MyByteSeq&, const MyByteSeq&);

    CallbackNC_TestIntf_opMyByteSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        MyByteSeq iceP_outSeq;
        MyByteSeq ret;
        try
        {
            ret = proxy->end_opMyByteSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opMyByteSeq.
 */
template<class T> Callback_TestIntf_opMyByteSeqPtr
newCallback_TestIntf_opMyByteSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const MyByteSeq&, const MyByteSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opMyByteSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opMyByteSeq.
 */
template<class T> Callback_TestIntf_opMyByteSeqPtr
newCallback_TestIntf_opMyByteSeq(T* instance, void (T::*cb)(const MyByteSeq&, const MyByteSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opMyByteSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opMyByteSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opMyByteSeq.
 */
template<class T, typename CT>
class Callback_TestIntf_opMyByteSeq : public Callback_TestIntf_opMyByteSeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const MyByteSeq&, const MyByteSeq&, const CT&);

    Callback_TestIntf_opMyByteSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        MyByteSeq iceP_outSeq;
        MyByteSeq ret;
        try
        {
            ret = proxy->end_opMyByteSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opMyByteSeq.
 */
template<class T, typename CT> Callback_TestIntf_opMyByteSeqPtr
newCallback_TestIntf_opMyByteSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const MyByteSeq&, const MyByteSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opMyByteSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opMyByteSeq.
 */
template<class T, typename CT> Callback_TestIntf_opMyByteSeqPtr
newCallback_TestIntf_opMyByteSeq(T* instance, void (T::*cb)(const MyByteSeq&, const MyByteSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opMyByteSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opString.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opString.
 */
template<class T>
class CallbackNC_TestIntf_opString : public Callback_TestIntf_opString_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const Util::string_view&, const Util::string_view&);

    CallbackNC_TestIntf_opString(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        Util::string_view iceP_outString;
        Util::string_view ret;
        try
        {
            proxy->_iceI_end_opString(iceP_outString, ret, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outString);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opString.
 */
template<class T> Callback_TestIntf_opStringPtr
newCallback_TestIntf_opString(const IceUtil::Handle<T>& instance, void (T::*cb)(const Util::string_view&, const Util::string_view&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opString<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opString.
 */
template<class T> Callback_TestIntf_opStringPtr
newCallback_TestIntf_opString(T* instance, void (T::*cb)(const Util::string_view&, const Util::string_view&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opString<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opString.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opString.
 */
template<class T, typename CT>
class Callback_TestIntf_opString : public Callback_TestIntf_opString_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const Util::string_view&, const Util::string_view&, const CT&);

    Callback_TestIntf_opString(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        Util::string_view iceP_outString;
        Util::string_view ret;
        try
        {
            proxy->_iceI_end_opString(iceP_outString, ret, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outString, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opString.
 */
template<class T, typename CT> Callback_TestIntf_opStringPtr
newCallback_TestIntf_opString(const IceUtil::Handle<T>& instance, void (T::*cb)(const Util::string_view&, const Util::string_view&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opString<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opString.
 */
template<class T, typename CT> Callback_TestIntf_opStringPtr
newCallback_TestIntf_opString(T* instance, void (T::*cb)(const Util::string_view&, const Util::string_view&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opString<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opStringSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opStringSeq.
 */
template<class T>
class CallbackNC_TestIntf_opStringSeq : public Callback_TestIntf_opStringSeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const std::deque<std::string>&, const std::deque<std::string>&);

    CallbackNC_TestIntf_opStringSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        std::deque<std::string> iceP_outSeq;
        std::deque<std::string> ret;
        try
        {
            ret = proxy->end_opStringSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opStringSeq.
 */
template<class T> Callback_TestIntf_opStringSeqPtr
newCallback_TestIntf_opStringSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const std::deque<std::string>&, const std::deque<std::string>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opStringSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opStringSeq.
 */
template<class T> Callback_TestIntf_opStringSeqPtr
newCallback_TestIntf_opStringSeq(T* instance, void (T::*cb)(const std::deque<std::string>&, const std::deque<std::string>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opStringSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opStringSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opStringSeq.
 */
template<class T, typename CT>
class Callback_TestIntf_opStringSeq : public Callback_TestIntf_opStringSeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const std::deque<std::string>&, const std::deque<std::string>&, const CT&);

    Callback_TestIntf_opStringSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        std::deque<std::string> iceP_outSeq;
        std::deque<std::string> ret;
        try
        {
            ret = proxy->end_opStringSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opStringSeq.
 */
template<class T, typename CT> Callback_TestIntf_opStringSeqPtr
newCallback_TestIntf_opStringSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const std::deque<std::string>&, const std::deque<std::string>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opStringSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opStringSeq.
 */
template<class T, typename CT> Callback_TestIntf_opStringSeqPtr
newCallback_TestIntf_opStringSeq(T* instance, void (T::*cb)(const std::deque<std::string>&, const std::deque<std::string>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opStringSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opStringList.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opStringList.
 */
template<class T>
class CallbackNC_TestIntf_opStringList : public Callback_TestIntf_opStringList_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const StringList&, const StringList&);

    CallbackNC_TestIntf_opStringList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        StringList iceP_outSeq;
        StringList ret;
        try
        {
            ret = proxy->end_opStringList(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opStringList.
 */
template<class T> Callback_TestIntf_opStringListPtr
newCallback_TestIntf_opStringList(const IceUtil::Handle<T>& instance, void (T::*cb)(const StringList&, const StringList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opStringList<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opStringList.
 */
template<class T> Callback_TestIntf_opStringListPtr
newCallback_TestIntf_opStringList(T* instance, void (T::*cb)(const StringList&, const StringList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opStringList<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opStringList.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opStringList.
 */
template<class T, typename CT>
class Callback_TestIntf_opStringList : public Callback_TestIntf_opStringList_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const StringList&, const StringList&, const CT&);

    Callback_TestIntf_opStringList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        StringList iceP_outSeq;
        StringList ret;
        try
        {
            ret = proxy->end_opStringList(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opStringList.
 */
template<class T, typename CT> Callback_TestIntf_opStringListPtr
newCallback_TestIntf_opStringList(const IceUtil::Handle<T>& instance, void (T::*cb)(const StringList&, const StringList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opStringList<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opStringList.
 */
template<class T, typename CT> Callback_TestIntf_opStringListPtr
newCallback_TestIntf_opStringList(T* instance, void (T::*cb)(const StringList&, const StringList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opStringList<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opFixedSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opFixedSeq.
 */
template<class T>
class CallbackNC_TestIntf_opFixedSeq : public Callback_TestIntf_opFixedSeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const std::deque< ::Test::Fixed>&, const std::deque< ::Test::Fixed>&);

    CallbackNC_TestIntf_opFixedSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        std::deque< ::Test::Fixed> iceP_outSeq;
        std::deque< ::Test::Fixed> ret;
        try
        {
            ret = proxy->end_opFixedSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opFixedSeq.
 */
template<class T> Callback_TestIntf_opFixedSeqPtr
newCallback_TestIntf_opFixedSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const std::deque< ::Test::Fixed>&, const std::deque< ::Test::Fixed>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opFixedSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opFixedSeq.
 */
template<class T> Callback_TestIntf_opFixedSeqPtr
newCallback_TestIntf_opFixedSeq(T* instance, void (T::*cb)(const std::deque< ::Test::Fixed>&, const std::deque< ::Test::Fixed>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opFixedSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opFixedSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opFixedSeq.
 */
template<class T, typename CT>
class Callback_TestIntf_opFixedSeq : public Callback_TestIntf_opFixedSeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const std::deque< ::Test::Fixed>&, const std::deque< ::Test::Fixed>&, const CT&);

    Callback_TestIntf_opFixedSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        std::deque< ::Test::Fixed> iceP_outSeq;
        std::deque< ::Test::Fixed> ret;
        try
        {
            ret = proxy->end_opFixedSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opFixedSeq.
 */
template<class T, typename CT> Callback_TestIntf_opFixedSeqPtr
newCallback_TestIntf_opFixedSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const std::deque< ::Test::Fixed>&, const std::deque< ::Test::Fixed>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opFixedSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opFixedSeq.
 */
template<class T, typename CT> Callback_TestIntf_opFixedSeqPtr
newCallback_TestIntf_opFixedSeq(T* instance, void (T::*cb)(const std::deque< ::Test::Fixed>&, const std::deque< ::Test::Fixed>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opFixedSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opFixedList.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opFixedList.
 */
template<class T>
class CallbackNC_TestIntf_opFixedList : public Callback_TestIntf_opFixedList_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const FixedList&, const FixedList&);

    CallbackNC_TestIntf_opFixedList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        FixedList iceP_outSeq;
        FixedList ret;
        try
        {
            ret = proxy->end_opFixedList(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opFixedList.
 */
template<class T> Callback_TestIntf_opFixedListPtr
newCallback_TestIntf_opFixedList(const IceUtil::Handle<T>& instance, void (T::*cb)(const FixedList&, const FixedList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opFixedList<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opFixedList.
 */
template<class T> Callback_TestIntf_opFixedListPtr
newCallback_TestIntf_opFixedList(T* instance, void (T::*cb)(const FixedList&, const FixedList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opFixedList<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opFixedList.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opFixedList.
 */
template<class T, typename CT>
class Callback_TestIntf_opFixedList : public Callback_TestIntf_opFixedList_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const FixedList&, const FixedList&, const CT&);

    Callback_TestIntf_opFixedList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        FixedList iceP_outSeq;
        FixedList ret;
        try
        {
            ret = proxy->end_opFixedList(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opFixedList.
 */
template<class T, typename CT> Callback_TestIntf_opFixedListPtr
newCallback_TestIntf_opFixedList(const IceUtil::Handle<T>& instance, void (T::*cb)(const FixedList&, const FixedList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opFixedList<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opFixedList.
 */
template<class T, typename CT> Callback_TestIntf_opFixedListPtr
newCallback_TestIntf_opFixedList(T* instance, void (T::*cb)(const FixedList&, const FixedList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opFixedList<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opVariableSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opVariableSeq.
 */
template<class T>
class CallbackNC_TestIntf_opVariableSeq : public Callback_TestIntf_opVariableSeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const std::deque< ::Test::Variable>&, const std::deque< ::Test::Variable>&);

    CallbackNC_TestIntf_opVariableSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        std::deque< ::Test::Variable> iceP_outSeq;
        std::deque< ::Test::Variable> ret;
        try
        {
            ret = proxy->end_opVariableSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opVariableSeq.
 */
template<class T> Callback_TestIntf_opVariableSeqPtr
newCallback_TestIntf_opVariableSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const std::deque< ::Test::Variable>&, const std::deque< ::Test::Variable>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opVariableSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opVariableSeq.
 */
template<class T> Callback_TestIntf_opVariableSeqPtr
newCallback_TestIntf_opVariableSeq(T* instance, void (T::*cb)(const std::deque< ::Test::Variable>&, const std::deque< ::Test::Variable>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opVariableSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opVariableSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opVariableSeq.
 */
template<class T, typename CT>
class Callback_TestIntf_opVariableSeq : public Callback_TestIntf_opVariableSeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const std::deque< ::Test::Variable>&, const std::deque< ::Test::Variable>&, const CT&);

    Callback_TestIntf_opVariableSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        std::deque< ::Test::Variable> iceP_outSeq;
        std::deque< ::Test::Variable> ret;
        try
        {
            ret = proxy->end_opVariableSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opVariableSeq.
 */
template<class T, typename CT> Callback_TestIntf_opVariableSeqPtr
newCallback_TestIntf_opVariableSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const std::deque< ::Test::Variable>&, const std::deque< ::Test::Variable>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opVariableSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opVariableSeq.
 */
template<class T, typename CT> Callback_TestIntf_opVariableSeqPtr
newCallback_TestIntf_opVariableSeq(T* instance, void (T::*cb)(const std::deque< ::Test::Variable>&, const std::deque< ::Test::Variable>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opVariableSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opVariableList.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opVariableList.
 */
template<class T>
class CallbackNC_TestIntf_opVariableList : public Callback_TestIntf_opVariableList_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const VariableList&, const VariableList&);

    CallbackNC_TestIntf_opVariableList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        VariableList iceP_outSeq;
        VariableList ret;
        try
        {
            ret = proxy->end_opVariableList(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opVariableList.
 */
template<class T> Callback_TestIntf_opVariableListPtr
newCallback_TestIntf_opVariableList(const IceUtil::Handle<T>& instance, void (T::*cb)(const VariableList&, const VariableList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opVariableList<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opVariableList.
 */
template<class T> Callback_TestIntf_opVariableListPtr
newCallback_TestIntf_opVariableList(T* instance, void (T::*cb)(const VariableList&, const VariableList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opVariableList<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opVariableList.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opVariableList.
 */
template<class T, typename CT>
class Callback_TestIntf_opVariableList : public Callback_TestIntf_opVariableList_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const VariableList&, const VariableList&, const CT&);

    Callback_TestIntf_opVariableList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        VariableList iceP_outSeq;
        VariableList ret;
        try
        {
            ret = proxy->end_opVariableList(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opVariableList.
 */
template<class T, typename CT> Callback_TestIntf_opVariableListPtr
newCallback_TestIntf_opVariableList(const IceUtil::Handle<T>& instance, void (T::*cb)(const VariableList&, const VariableList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opVariableList<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opVariableList.
 */
template<class T, typename CT> Callback_TestIntf_opVariableListPtr
newCallback_TestIntf_opVariableList(T* instance, void (T::*cb)(const VariableList&, const VariableList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opVariableList<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opStringStringDictSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opStringStringDictSeq.
 */
template<class T>
class CallbackNC_TestIntf_opStringStringDictSeq : public Callback_TestIntf_opStringStringDictSeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const std::deque< ::Test::StringStringDict>&, const std::deque< ::Test::StringStringDict>&);

    CallbackNC_TestIntf_opStringStringDictSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        std::deque< ::Test::StringStringDict> iceP_outSeq;
        std::deque< ::Test::StringStringDict> ret;
        try
        {
            ret = proxy->end_opStringStringDictSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opStringStringDictSeq.
 */
template<class T> Callback_TestIntf_opStringStringDictSeqPtr
newCallback_TestIntf_opStringStringDictSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const std::deque< ::Test::StringStringDict>&, const std::deque< ::Test::StringStringDict>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opStringStringDictSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opStringStringDictSeq.
 */
template<class T> Callback_TestIntf_opStringStringDictSeqPtr
newCallback_TestIntf_opStringStringDictSeq(T* instance, void (T::*cb)(const std::deque< ::Test::StringStringDict>&, const std::deque< ::Test::StringStringDict>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opStringStringDictSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opStringStringDictSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opStringStringDictSeq.
 */
template<class T, typename CT>
class Callback_TestIntf_opStringStringDictSeq : public Callback_TestIntf_opStringStringDictSeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const std::deque< ::Test::StringStringDict>&, const std::deque< ::Test::StringStringDict>&, const CT&);

    Callback_TestIntf_opStringStringDictSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        std::deque< ::Test::StringStringDict> iceP_outSeq;
        std::deque< ::Test::StringStringDict> ret;
        try
        {
            ret = proxy->end_opStringStringDictSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opStringStringDictSeq.
 */
template<class T, typename CT> Callback_TestIntf_opStringStringDictSeqPtr
newCallback_TestIntf_opStringStringDictSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const std::deque< ::Test::StringStringDict>&, const std::deque< ::Test::StringStringDict>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opStringStringDictSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opStringStringDictSeq.
 */
template<class T, typename CT> Callback_TestIntf_opStringStringDictSeqPtr
newCallback_TestIntf_opStringStringDictSeq(T* instance, void (T::*cb)(const std::deque< ::Test::StringStringDict>&, const std::deque< ::Test::StringStringDict>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opStringStringDictSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opStringStringDictList.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opStringStringDictList.
 */
template<class T>
class CallbackNC_TestIntf_opStringStringDictList : public Callback_TestIntf_opStringStringDictList_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const StringStringDictList&, const StringStringDictList&);

    CallbackNC_TestIntf_opStringStringDictList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        StringStringDictList iceP_outSeq;
        StringStringDictList ret;
        try
        {
            ret = proxy->end_opStringStringDictList(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opStringStringDictList.
 */
template<class T> Callback_TestIntf_opStringStringDictListPtr
newCallback_TestIntf_opStringStringDictList(const IceUtil::Handle<T>& instance, void (T::*cb)(const StringStringDictList&, const StringStringDictList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opStringStringDictList<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opStringStringDictList.
 */
template<class T> Callback_TestIntf_opStringStringDictListPtr
newCallback_TestIntf_opStringStringDictList(T* instance, void (T::*cb)(const StringStringDictList&, const StringStringDictList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opStringStringDictList<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opStringStringDictList.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opStringStringDictList.
 */
template<class T, typename CT>
class Callback_TestIntf_opStringStringDictList : public Callback_TestIntf_opStringStringDictList_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const StringStringDictList&, const StringStringDictList&, const CT&);

    Callback_TestIntf_opStringStringDictList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        StringStringDictList iceP_outSeq;
        StringStringDictList ret;
        try
        {
            ret = proxy->end_opStringStringDictList(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opStringStringDictList.
 */
template<class T, typename CT> Callback_TestIntf_opStringStringDictListPtr
newCallback_TestIntf_opStringStringDictList(const IceUtil::Handle<T>& instance, void (T::*cb)(const StringStringDictList&, const StringStringDictList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opStringStringDictList<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opStringStringDictList.
 */
template<class T, typename CT> Callback_TestIntf_opStringStringDictListPtr
newCallback_TestIntf_opStringStringDictList(T* instance, void (T::*cb)(const StringStringDictList&, const StringStringDictList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opStringStringDictList<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opESeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opESeq.
 */
template<class T>
class CallbackNC_TestIntf_opESeq : public Callback_TestIntf_opESeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const std::deque< ::Test::E>&, const std::deque< ::Test::E>&);

    CallbackNC_TestIntf_opESeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        std::deque< ::Test::E> iceP_outSeq;
        std::deque< ::Test::E> ret;
        try
        {
            ret = proxy->end_opESeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opESeq.
 */
template<class T> Callback_TestIntf_opESeqPtr
newCallback_TestIntf_opESeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const std::deque< ::Test::E>&, const std::deque< ::Test::E>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opESeq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opESeq.
 */
template<class T> Callback_TestIntf_opESeqPtr
newCallback_TestIntf_opESeq(T* instance, void (T::*cb)(const std::deque< ::Test::E>&, const std::deque< ::Test::E>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opESeq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opESeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opESeq.
 */
template<class T, typename CT>
class Callback_TestIntf_opESeq : public Callback_TestIntf_opESeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const std::deque< ::Test::E>&, const std::deque< ::Test::E>&, const CT&);

    Callback_TestIntf_opESeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        std::deque< ::Test::E> iceP_outSeq;
        std::deque< ::Test::E> ret;
        try
        {
            ret = proxy->end_opESeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opESeq.
 */
template<class T, typename CT> Callback_TestIntf_opESeqPtr
newCallback_TestIntf_opESeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const std::deque< ::Test::E>&, const std::deque< ::Test::E>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opESeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opESeq.
 */
template<class T, typename CT> Callback_TestIntf_opESeqPtr
newCallback_TestIntf_opESeq(T* instance, void (T::*cb)(const std::deque< ::Test::E>&, const std::deque< ::Test::E>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opESeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opEList.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opEList.
 */
template<class T>
class CallbackNC_TestIntf_opEList : public Callback_TestIntf_opEList_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const EList&, const EList&);

    CallbackNC_TestIntf_opEList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        EList iceP_outSeq;
        EList ret;
        try
        {
            ret = proxy->end_opEList(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opEList.
 */
template<class T> Callback_TestIntf_opEListPtr
newCallback_TestIntf_opEList(const IceUtil::Handle<T>& instance, void (T::*cb)(const EList&, const EList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opEList<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opEList.
 */
template<class T> Callback_TestIntf_opEListPtr
newCallback_TestIntf_opEList(T* instance, void (T::*cb)(const EList&, const EList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opEList<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opEList.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opEList.
 */
template<class T, typename CT>
class Callback_TestIntf_opEList : public Callback_TestIntf_opEList_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const EList&, const EList&, const CT&);

    Callback_TestIntf_opEList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        EList iceP_outSeq;
        EList ret;
        try
        {
            ret = proxy->end_opEList(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opEList.
 */
template<class T, typename CT> Callback_TestIntf_opEListPtr
newCallback_TestIntf_opEList(const IceUtil::Handle<T>& instance, void (T::*cb)(const EList&, const EList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opEList<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opEList.
 */
template<class T, typename CT> Callback_TestIntf_opEListPtr
newCallback_TestIntf_opEList(T* instance, void (T::*cb)(const EList&, const EList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opEList<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opDPrxSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opDPrxSeq.
 */
template<class T>
class CallbackNC_TestIntf_opDPrxSeq : public Callback_TestIntf_opDPrxSeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const std::deque< ::Test::DPrx>&, const std::deque< ::Test::DPrx>&);

    CallbackNC_TestIntf_opDPrxSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        std::deque< ::Test::DPrx> iceP_outSeq;
        std::deque< ::Test::DPrx> ret;
        try
        {
            ret = proxy->end_opDPrxSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opDPrxSeq.
 */
template<class T> Callback_TestIntf_opDPrxSeqPtr
newCallback_TestIntf_opDPrxSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const std::deque< ::Test::DPrx>&, const std::deque< ::Test::DPrx>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opDPrxSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opDPrxSeq.
 */
template<class T> Callback_TestIntf_opDPrxSeqPtr
newCallback_TestIntf_opDPrxSeq(T* instance, void (T::*cb)(const std::deque< ::Test::DPrx>&, const std::deque< ::Test::DPrx>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opDPrxSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opDPrxSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opDPrxSeq.
 */
template<class T, typename CT>
class Callback_TestIntf_opDPrxSeq : public Callback_TestIntf_opDPrxSeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const std::deque< ::Test::DPrx>&, const std::deque< ::Test::DPrx>&, const CT&);

    Callback_TestIntf_opDPrxSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        std::deque< ::Test::DPrx> iceP_outSeq;
        std::deque< ::Test::DPrx> ret;
        try
        {
            ret = proxy->end_opDPrxSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opDPrxSeq.
 */
template<class T, typename CT> Callback_TestIntf_opDPrxSeqPtr
newCallback_TestIntf_opDPrxSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const std::deque< ::Test::DPrx>&, const std::deque< ::Test::DPrx>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opDPrxSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opDPrxSeq.
 */
template<class T, typename CT> Callback_TestIntf_opDPrxSeqPtr
newCallback_TestIntf_opDPrxSeq(T* instance, void (T::*cb)(const std::deque< ::Test::DPrx>&, const std::deque< ::Test::DPrx>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opDPrxSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opDPrxList.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opDPrxList.
 */
template<class T>
class CallbackNC_TestIntf_opDPrxList : public Callback_TestIntf_opDPrxList_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const DPrxList&, const DPrxList&);

    CallbackNC_TestIntf_opDPrxList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        DPrxList iceP_outSeq;
        DPrxList ret;
        try
        {
            ret = proxy->end_opDPrxList(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opDPrxList.
 */
template<class T> Callback_TestIntf_opDPrxListPtr
newCallback_TestIntf_opDPrxList(const IceUtil::Handle<T>& instance, void (T::*cb)(const DPrxList&, const DPrxList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opDPrxList<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opDPrxList.
 */
template<class T> Callback_TestIntf_opDPrxListPtr
newCallback_TestIntf_opDPrxList(T* instance, void (T::*cb)(const DPrxList&, const DPrxList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opDPrxList<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opDPrxList.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opDPrxList.
 */
template<class T, typename CT>
class Callback_TestIntf_opDPrxList : public Callback_TestIntf_opDPrxList_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const DPrxList&, const DPrxList&, const CT&);

    Callback_TestIntf_opDPrxList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        DPrxList iceP_outSeq;
        DPrxList ret;
        try
        {
            ret = proxy->end_opDPrxList(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opDPrxList.
 */
template<class T, typename CT> Callback_TestIntf_opDPrxListPtr
newCallback_TestIntf_opDPrxList(const IceUtil::Handle<T>& instance, void (T::*cb)(const DPrxList&, const DPrxList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opDPrxList<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opDPrxList.
 */
template<class T, typename CT> Callback_TestIntf_opDPrxListPtr
newCallback_TestIntf_opDPrxList(T* instance, void (T::*cb)(const DPrxList&, const DPrxList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opDPrxList<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opCSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opCSeq.
 */
template<class T>
class CallbackNC_TestIntf_opCSeq : public Callback_TestIntf_opCSeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const std::deque< ::Test::CPtr>&, const std::deque< ::Test::CPtr>&);

    CallbackNC_TestIntf_opCSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        std::deque< ::Test::CPtr> iceP_outSeq;
        std::deque< ::Test::CPtr> ret;
        try
        {
            ret = proxy->end_opCSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opCSeq.
 */
template<class T> Callback_TestIntf_opCSeqPtr
newCallback_TestIntf_opCSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const std::deque< ::Test::CPtr>&, const std::deque< ::Test::CPtr>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opCSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opCSeq.
 */
template<class T> Callback_TestIntf_opCSeqPtr
newCallback_TestIntf_opCSeq(T* instance, void (T::*cb)(const std::deque< ::Test::CPtr>&, const std::deque< ::Test::CPtr>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opCSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opCSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opCSeq.
 */
template<class T, typename CT>
class Callback_TestIntf_opCSeq : public Callback_TestIntf_opCSeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const std::deque< ::Test::CPtr>&, const std::deque< ::Test::CPtr>&, const CT&);

    Callback_TestIntf_opCSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        std::deque< ::Test::CPtr> iceP_outSeq;
        std::deque< ::Test::CPtr> ret;
        try
        {
            ret = proxy->end_opCSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opCSeq.
 */
template<class T, typename CT> Callback_TestIntf_opCSeqPtr
newCallback_TestIntf_opCSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const std::deque< ::Test::CPtr>&, const std::deque< ::Test::CPtr>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opCSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opCSeq.
 */
template<class T, typename CT> Callback_TestIntf_opCSeqPtr
newCallback_TestIntf_opCSeq(T* instance, void (T::*cb)(const std::deque< ::Test::CPtr>&, const std::deque< ::Test::CPtr>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opCSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opCList.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opCList.
 */
template<class T>
class CallbackNC_TestIntf_opCList : public Callback_TestIntf_opCList_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const CList&, const CList&);

    CallbackNC_TestIntf_opCList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        CList iceP_outSeq;
        CList ret;
        try
        {
            ret = proxy->end_opCList(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opCList.
 */
template<class T> Callback_TestIntf_opCListPtr
newCallback_TestIntf_opCList(const IceUtil::Handle<T>& instance, void (T::*cb)(const CList&, const CList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opCList<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opCList.
 */
template<class T> Callback_TestIntf_opCListPtr
newCallback_TestIntf_opCList(T* instance, void (T::*cb)(const CList&, const CList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opCList<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opCList.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opCList.
 */
template<class T, typename CT>
class Callback_TestIntf_opCList : public Callback_TestIntf_opCList_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CList&, const CList&, const CT&);

    Callback_TestIntf_opCList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        CList iceP_outSeq;
        CList ret;
        try
        {
            ret = proxy->end_opCList(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opCList.
 */
template<class T, typename CT> Callback_TestIntf_opCListPtr
newCallback_TestIntf_opCList(const IceUtil::Handle<T>& instance, void (T::*cb)(const CList&, const CList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opCList<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opCList.
 */
template<class T, typename CT> Callback_TestIntf_opCListPtr
newCallback_TestIntf_opCList(T* instance, void (T::*cb)(const CList&, const CList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opCList<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opClassStruct.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opClassStruct.
 */
template<class T>
class CallbackNC_TestIntf_opClassStruct : public Callback_TestIntf_opClassStruct_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ClassStructPtr&, const ClassStructPtr&, const ClassStructSeq&);

    CallbackNC_TestIntf_opClassStruct(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        ClassStructPtr iceP_outS;
        ClassStructSeq iceP_outSeq;
        ClassStructPtr ret;
        try
        {
            ret = proxy->end_opClassStruct(iceP_outS, iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outS, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opClassStruct.
 */
template<class T> Callback_TestIntf_opClassStructPtr
newCallback_TestIntf_opClassStruct(const IceUtil::Handle<T>& instance, void (T::*cb)(const ClassStructPtr&, const ClassStructPtr&, const ClassStructSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opClassStruct<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opClassStruct.
 */
template<class T> Callback_TestIntf_opClassStructPtr
newCallback_TestIntf_opClassStruct(T* instance, void (T::*cb)(const ClassStructPtr&, const ClassStructPtr&, const ClassStructSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opClassStruct<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opClassStruct.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opClassStruct.
 */
template<class T, typename CT>
class Callback_TestIntf_opClassStruct : public Callback_TestIntf_opClassStruct_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ClassStructPtr&, const ClassStructPtr&, const ClassStructSeq&, const CT&);

    Callback_TestIntf_opClassStruct(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        ClassStructPtr iceP_outS;
        ClassStructSeq iceP_outSeq;
        ClassStructPtr ret;
        try
        {
            ret = proxy->end_opClassStruct(iceP_outS, iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outS, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opClassStruct.
 */
template<class T, typename CT> Callback_TestIntf_opClassStructPtr
newCallback_TestIntf_opClassStruct(const IceUtil::Handle<T>& instance, void (T::*cb)(const ClassStructPtr&, const ClassStructPtr&, const ClassStructSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opClassStruct<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opClassStruct.
 */
template<class T, typename CT> Callback_TestIntf_opClassStructPtr
newCallback_TestIntf_opClassStruct(T* instance, void (T::*cb)(const ClassStructPtr&, const ClassStructPtr&, const ClassStructSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opClassStruct<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opOutArrayByteSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opOutArrayByteSeq.
 */
template<class T>
class CallbackNC_TestIntf_opOutArrayByteSeq : public Callback_TestIntf_opOutArrayByteSeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>&);

    CallbackNC_TestIntf_opOutArrayByteSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*> iceP_copy;
        try
        {
            proxy->_iceI_end_opOutArrayByteSeq(iceP_copy, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(iceP_copy);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opOutArrayByteSeq.
 */
template<class T> Callback_TestIntf_opOutArrayByteSeqPtr
newCallback_TestIntf_opOutArrayByteSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opOutArrayByteSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opOutArrayByteSeq.
 */
template<class T> Callback_TestIntf_opOutArrayByteSeqPtr
newCallback_TestIntf_opOutArrayByteSeq(T* instance, void (T::*cb)(const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opOutArrayByteSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opOutArrayByteSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opOutArrayByteSeq.
 */
template<class T, typename CT>
class Callback_TestIntf_opOutArrayByteSeq : public Callback_TestIntf_opOutArrayByteSeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>&, const CT&);

    Callback_TestIntf_opOutArrayByteSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*> iceP_copy;
        try
        {
            proxy->_iceI_end_opOutArrayByteSeq(iceP_copy, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(iceP_copy, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opOutArrayByteSeq.
 */
template<class T, typename CT> Callback_TestIntf_opOutArrayByteSeqPtr
newCallback_TestIntf_opOutArrayByteSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opOutArrayByteSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opOutArrayByteSeq.
 */
template<class T, typename CT> Callback_TestIntf_opOutArrayByteSeqPtr
newCallback_TestIntf_opOutArrayByteSeq(T* instance, void (T::*cb)(const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opOutArrayByteSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opOutRangeByteSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opOutRangeByteSeq.
 */
template<class T>
class CallbackNC_TestIntf_opOutRangeByteSeq : public Callback_TestIntf_opOutRangeByteSeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::pair<ByteSeq::const_iterator, ByteSeq::const_iterator>&);

    CallbackNC_TestIntf_opOutRangeByteSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        ::std::pair<ByteSeq::const_iterator, ByteSeq::const_iterator> iceP_copy;
        ByteSeq iceP_copy_tmp_;
        try
        {
            proxy->end_opOutRangeByteSeq(iceP_copy_tmp_, result);
            iceP_copy.first = iceP_copy_tmp_.begin();
            iceP_copy.second = iceP_copy_tmp_.end();
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(iceP_copy);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opOutRangeByteSeq.
 */
template<class T> Callback_TestIntf_opOutRangeByteSeqPtr
newCallback_TestIntf_opOutRangeByteSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::pair<ByteSeq::const_iterator, ByteSeq::const_iterator>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opOutRangeByteSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opOutRangeByteSeq.
 */
template<class T> Callback_TestIntf_opOutRangeByteSeqPtr
newCallback_TestIntf_opOutRangeByteSeq(T* instance, void (T::*cb)(const ::std::pair<ByteSeq::const_iterator, ByteSeq::const_iterator>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opOutRangeByteSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opOutRangeByteSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opOutRangeByteSeq.
 */
template<class T, typename CT>
class Callback_TestIntf_opOutRangeByteSeq : public Callback_TestIntf_opOutRangeByteSeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::pair<ByteSeq::const_iterator, ByteSeq::const_iterator>&, const CT&);

    Callback_TestIntf_opOutRangeByteSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        ::std::pair<ByteSeq::const_iterator, ByteSeq::const_iterator> iceP_copy;
        ByteSeq iceP_copy_tmp_;
        try
        {
            proxy->end_opOutRangeByteSeq(iceP_copy_tmp_, result);
            iceP_copy.first = iceP_copy_tmp_.begin();
            iceP_copy.second = iceP_copy_tmp_.end();
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(iceP_copy, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opOutRangeByteSeq.
 */
template<class T, typename CT> Callback_TestIntf_opOutRangeByteSeqPtr
newCallback_TestIntf_opOutRangeByteSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::pair<ByteSeq::const_iterator, ByteSeq::const_iterator>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opOutRangeByteSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opOutRangeByteSeq.
 */
template<class T, typename CT> Callback_TestIntf_opOutRangeByteSeqPtr
newCallback_TestIntf_opOutRangeByteSeq(T* instance, void (T::*cb)(const ::std::pair<ByteSeq::const_iterator, ByteSeq::const_iterator>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opOutRangeByteSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opIntStringDict.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opIntStringDict.
 */
template<class T>
class CallbackNC_TestIntf_opIntStringDict : public Callback_TestIntf_opIntStringDict_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IntStringDict&, const IntStringDict&);

    CallbackNC_TestIntf_opIntStringDict(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        IntStringDict iceP_odict;
        IntStringDict ret;
        try
        {
            ret = proxy->end_opIntStringDict(iceP_odict, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_odict);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opIntStringDict.
 */
template<class T> Callback_TestIntf_opIntStringDictPtr
newCallback_TestIntf_opIntStringDict(const IceUtil::Handle<T>& instance, void (T::*cb)(const IntStringDict&, const IntStringDict&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opIntStringDict<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opIntStringDict.
 */
template<class T> Callback_TestIntf_opIntStringDictPtr
newCallback_TestIntf_opIntStringDict(T* instance, void (T::*cb)(const IntStringDict&, const IntStringDict&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opIntStringDict<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opIntStringDict.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opIntStringDict.
 */
template<class T, typename CT>
class Callback_TestIntf_opIntStringDict : public Callback_TestIntf_opIntStringDict_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IntStringDict&, const IntStringDict&, const CT&);

    Callback_TestIntf_opIntStringDict(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        IntStringDict iceP_odict;
        IntStringDict ret;
        try
        {
            ret = proxy->end_opIntStringDict(iceP_odict, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_odict, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opIntStringDict.
 */
template<class T, typename CT> Callback_TestIntf_opIntStringDictPtr
newCallback_TestIntf_opIntStringDict(const IceUtil::Handle<T>& instance, void (T::*cb)(const IntStringDict&, const IntStringDict&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opIntStringDict<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opIntStringDict.
 */
template<class T, typename CT> Callback_TestIntf_opIntStringDictPtr
newCallback_TestIntf_opIntStringDict(T* instance, void (T::*cb)(const IntStringDict&, const IntStringDict&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opIntStringDict<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opVarDict.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opVarDict.
 */
template<class T>
class CallbackNC_TestIntf_opVarDict : public Callback_TestIntf_opVarDict_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Test::CustomMap< ::Ice::Long, ::Ice::Long>&, const ::Test::CustomMap<std::string, ::Ice::Int>&);

    CallbackNC_TestIntf_opVarDict(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        ::Test::CustomMap<std::string, ::Ice::Int> iceP_odict;
        ::Test::CustomMap< ::Ice::Long, ::Ice::Long> ret;
        try
        {
            ret = proxy->end_opVarDict(iceP_odict, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_odict);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opVarDict.
 */
template<class T> Callback_TestIntf_opVarDictPtr
newCallback_TestIntf_opVarDict(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::CustomMap< ::Ice::Long, ::Ice::Long>&, const ::Test::CustomMap<std::string, ::Ice::Int>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opVarDict<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opVarDict.
 */
template<class T> Callback_TestIntf_opVarDictPtr
newCallback_TestIntf_opVarDict(T* instance, void (T::*cb)(const ::Test::CustomMap< ::Ice::Long, ::Ice::Long>&, const ::Test::CustomMap<std::string, ::Ice::Int>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opVarDict<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opVarDict.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opVarDict.
 */
template<class T, typename CT>
class Callback_TestIntf_opVarDict : public Callback_TestIntf_opVarDict_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Test::CustomMap< ::Ice::Long, ::Ice::Long>&, const ::Test::CustomMap<std::string, ::Ice::Int>&, const CT&);

    Callback_TestIntf_opVarDict(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        ::Test::CustomMap<std::string, ::Ice::Int> iceP_odict;
        ::Test::CustomMap< ::Ice::Long, ::Ice::Long> ret;
        try
        {
            ret = proxy->end_opVarDict(iceP_odict, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_odict, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opVarDict.
 */
template<class T, typename CT> Callback_TestIntf_opVarDictPtr
newCallback_TestIntf_opVarDict(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::CustomMap< ::Ice::Long, ::Ice::Long>&, const ::Test::CustomMap<std::string, ::Ice::Int>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opVarDict<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opVarDict.
 */
template<class T, typename CT> Callback_TestIntf_opVarDictPtr
newCallback_TestIntf_opVarDict(T* instance, void (T::*cb)(const ::Test::CustomMap< ::Ice::Long, ::Ice::Long>&, const ::Test::CustomMap<std::string, ::Ice::Int>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opVarDict<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opCustomIntStringDict.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opCustomIntStringDict.
 */
template<class T>
class CallbackNC_TestIntf_opCustomIntStringDict : public Callback_TestIntf_opCustomIntStringDict_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::map< ::Ice::Int, ::Util::string_view>&, const ::std::map< ::Ice::Int, ::Util::string_view>&);

    CallbackNC_TestIntf_opCustomIntStringDict(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        ::std::map< ::Ice::Int, ::Util::string_view> iceP_odict;
        ::std::map< ::Ice::Int, ::Util::string_view> ret;
        try
        {
            proxy->_iceI_end_opCustomIntStringDict(iceP_odict, ret, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_odict);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opCustomIntStringDict.
 */
template<class T> Callback_TestIntf_opCustomIntStringDictPtr
newCallback_TestIntf_opCustomIntStringDict(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::map< ::Ice::Int, ::Util::string_view>&, const ::std::map< ::Ice::Int, ::Util::string_view>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opCustomIntStringDict<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opCustomIntStringDict.
 */
template<class T> Callback_TestIntf_opCustomIntStringDictPtr
newCallback_TestIntf_opCustomIntStringDict(T* instance, void (T::*cb)(const ::std::map< ::Ice::Int, ::Util::string_view>&, const ::std::map< ::Ice::Int, ::Util::string_view>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opCustomIntStringDict<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opCustomIntStringDict.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opCustomIntStringDict.
 */
template<class T, typename CT>
class Callback_TestIntf_opCustomIntStringDict : public Callback_TestIntf_opCustomIntStringDict_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::map< ::Ice::Int, ::Util::string_view>&, const ::std::map< ::Ice::Int, ::Util::string_view>&, const CT&);

    Callback_TestIntf_opCustomIntStringDict(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        ::std::map< ::Ice::Int, ::Util::string_view> iceP_odict;
        ::std::map< ::Ice::Int, ::Util::string_view> ret;
        try
        {
            proxy->_iceI_end_opCustomIntStringDict(iceP_odict, ret, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_odict, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opCustomIntStringDict.
 */
template<class T, typename CT> Callback_TestIntf_opCustomIntStringDictPtr
newCallback_TestIntf_opCustomIntStringDict(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::map< ::Ice::Int, ::Util::string_view>&, const ::std::map< ::Ice::Int, ::Util::string_view>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opCustomIntStringDict<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opCustomIntStringDict.
 */
template<class T, typename CT> Callback_TestIntf_opCustomIntStringDictPtr
newCallback_TestIntf_opCustomIntStringDict(T* instance, void (T::*cb)(const ::std::map< ::Ice::Int, ::Util::string_view>&, const ::std::map< ::Ice::Int, ::Util::string_view>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opCustomIntStringDict<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opShortBuffer.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opShortBuffer.
 */
template<class T>
class CallbackNC_TestIntf_opShortBuffer : public Callback_TestIntf_opShortBuffer_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ShortBuffer&, const ShortBuffer&);

    CallbackNC_TestIntf_opShortBuffer(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        ShortBuffer iceP_outS;
        ShortBuffer ret;
        try
        {
            ret = proxy->end_opShortBuffer(iceP_outS, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outS);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opShortBuffer.
 */
template<class T> Callback_TestIntf_opShortBufferPtr
newCallback_TestIntf_opShortBuffer(const IceUtil::Handle<T>& instance, void (T::*cb)(const ShortBuffer&, const ShortBuffer&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opShortBuffer<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opShortBuffer.
 */
template<class T> Callback_TestIntf_opShortBufferPtr
newCallback_TestIntf_opShortBuffer(T* instance, void (T::*cb)(const ShortBuffer&, const ShortBuffer&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opShortBuffer<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opShortBuffer.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opShortBuffer.
 */
template<class T, typename CT>
class Callback_TestIntf_opShortBuffer : public Callback_TestIntf_opShortBuffer_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ShortBuffer&, const ShortBuffer&, const CT&);

    Callback_TestIntf_opShortBuffer(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        ShortBuffer iceP_outS;
        ShortBuffer ret;
        try
        {
            ret = proxy->end_opShortBuffer(iceP_outS, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outS, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opShortBuffer.
 */
template<class T, typename CT> Callback_TestIntf_opShortBufferPtr
newCallback_TestIntf_opShortBuffer(const IceUtil::Handle<T>& instance, void (T::*cb)(const ShortBuffer&, const ShortBuffer&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opShortBuffer<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opShortBuffer.
 */
template<class T, typename CT> Callback_TestIntf_opShortBufferPtr
newCallback_TestIntf_opShortBuffer(T* instance, void (T::*cb)(const ShortBuffer&, const ShortBuffer&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opShortBuffer<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opBoolBuffer.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opBoolBuffer.
 */
template<class T>
class CallbackNC_TestIntf_opBoolBuffer : public Callback_TestIntf_opBoolBuffer_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Test::CustomBuffer<bool>&, const ::Test::CustomBuffer<bool>&);

    CallbackNC_TestIntf_opBoolBuffer(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        ::Test::CustomBuffer<bool> iceP_outS;
        ::Test::CustomBuffer<bool> ret;
        try
        {
            ret = proxy->end_opBoolBuffer(iceP_outS, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outS);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opBoolBuffer.
 */
template<class T> Callback_TestIntf_opBoolBufferPtr
newCallback_TestIntf_opBoolBuffer(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::CustomBuffer<bool>&, const ::Test::CustomBuffer<bool>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opBoolBuffer<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opBoolBuffer.
 */
template<class T> Callback_TestIntf_opBoolBufferPtr
newCallback_TestIntf_opBoolBuffer(T* instance, void (T::*cb)(const ::Test::CustomBuffer<bool>&, const ::Test::CustomBuffer<bool>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opBoolBuffer<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opBoolBuffer.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opBoolBuffer.
 */
template<class T, typename CT>
class Callback_TestIntf_opBoolBuffer : public Callback_TestIntf_opBoolBuffer_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Test::CustomBuffer<bool>&, const ::Test::CustomBuffer<bool>&, const CT&);

    Callback_TestIntf_opBoolBuffer(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        ::Test::CustomBuffer<bool> iceP_outS;
        ::Test::CustomBuffer<bool> ret;
        try
        {
            ret = proxy->end_opBoolBuffer(iceP_outS, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outS, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opBoolBuffer.
 */
template<class T, typename CT> Callback_TestIntf_opBoolBufferPtr
newCallback_TestIntf_opBoolBuffer(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::CustomBuffer<bool>&, const ::Test::CustomBuffer<bool>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opBoolBuffer<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opBoolBuffer.
 */
template<class T, typename CT> Callback_TestIntf_opBoolBufferPtr
newCallback_TestIntf_opBoolBuffer(T* instance, void (T::*cb)(const ::Test::CustomBuffer<bool>&, const ::Test::CustomBuffer<bool>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opBoolBuffer<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opBufferStruct.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opBufferStruct.
 */
template<class T>
class CallbackNC_TestIntf_opBufferStruct : public Callback_TestIntf_opBufferStruct_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const BufferStruct&);

    CallbackNC_TestIntf_opBufferStruct(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        BufferStruct ret;
        try
        {
            ret = proxy->end_opBufferStruct(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opBufferStruct.
 */
template<class T> Callback_TestIntf_opBufferStructPtr
newCallback_TestIntf_opBufferStruct(const IceUtil::Handle<T>& instance, void (T::*cb)(const BufferStruct&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opBufferStruct<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opBufferStruct.
 */
template<class T> Callback_TestIntf_opBufferStructPtr
newCallback_TestIntf_opBufferStruct(T* instance, void (T::*cb)(const BufferStruct&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opBufferStruct<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opBufferStruct.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opBufferStruct.
 */
template<class T, typename CT>
class Callback_TestIntf_opBufferStruct : public Callback_TestIntf_opBufferStruct_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const BufferStruct&, const CT&);

    Callback_TestIntf_opBufferStruct(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        BufferStruct ret;
        try
        {
            ret = proxy->end_opBufferStruct(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opBufferStruct.
 */
template<class T, typename CT> Callback_TestIntf_opBufferStructPtr
newCallback_TestIntf_opBufferStruct(const IceUtil::Handle<T>& instance, void (T::*cb)(const BufferStruct&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opBufferStruct<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opBufferStruct.
 */
template<class T, typename CT> Callback_TestIntf_opBufferStructPtr
newCallback_TestIntf_opBufferStruct(T* instance, void (T::*cb)(const BufferStruct&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opBufferStruct<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_shutdown.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_shutdown.
 */
template<class T>
class CallbackNC_TestIntf_shutdown : public Callback_TestIntf_shutdown_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_TestIntf_shutdown(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_shutdown.
 */
template<class T> Callback_TestIntf_shutdownPtr
newCallback_TestIntf_shutdown(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_shutdown<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_shutdown.
 */
template<class T> Callback_TestIntf_shutdownPtr
newCallback_TestIntf_shutdown(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_shutdown<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_shutdown.
 */
template<class T> Callback_TestIntf_shutdownPtr
newCallback_TestIntf_shutdown(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_shutdown<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_shutdown.
 */
template<class T> Callback_TestIntf_shutdownPtr
newCallback_TestIntf_shutdown(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_shutdown<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_shutdown.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_shutdown.
 */
template<class T, typename CT>
class Callback_TestIntf_shutdown : public Callback_TestIntf_shutdown_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_TestIntf_shutdown(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_shutdown.
 */
template<class T, typename CT> Callback_TestIntf_shutdownPtr
newCallback_TestIntf_shutdown(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_shutdown<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_shutdown.
 */
template<class T, typename CT> Callback_TestIntf_shutdownPtr
newCallback_TestIntf_shutdown(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_shutdown<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_shutdown.
 */
template<class T, typename CT> Callback_TestIntf_shutdownPtr
newCallback_TestIntf_shutdown(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_shutdown<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_shutdown.
 */
template<class T, typename CT> Callback_TestIntf_shutdownPtr
newCallback_TestIntf_shutdown(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_shutdown<T, CT>(instance, 0, excb, sentcb);
}

}

#endif

#include <IceUtil/PopDisableWarnings.h>
#endif
