//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.8.0-alpha.0
//
// <auto-generated>
//
// Generated from file `TestAMD.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __TestAMD_h__
#define __TestAMD_h__

#include <IceUtil/PushDisableWarnings.h>
#include <Ice/Ice.h>
#include <IceUtil/UndefSysMacros.h>
#include <deque>
#include <list>
#include <MyByteSeq.h>
#include <CustomMap.h>
#include <CustomBuffer.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION  != 30850
#       error Ice version mismatch: an exact match is required for beta generated code
#   endif
#endif

namespace Test
{


using BoolSeq = ::std::vector<bool>;

using BoolList = std::list<bool>;

using BoolListList = std::list< ::Test::BoolList>;

using BoolListSeq = ::std::vector<BoolList>;

using BoolSeqList = std::list< ::Test::BoolSeq>;

using ByteSeq = ::std::vector<::std::uint8_t>;

using ByteList = std::list< ::Ice::Byte>;

using ByteListList = std::list< ::Test::ByteList>;

using ByteListSeq = ::std::vector<ByteList>;

using ByteSeqList = std::list< ::Test::ByteSeq>;

using StringSeq = ::std::vector<::std::string>;

using StringList = std::list<std::string>;

using StringListList = std::list< ::Test::StringList>;

using StringListSeq = ::std::vector<StringList>;

using StringSeqList = std::list< ::Test::StringSeq>;
struct Fixed;

using FixedSeq = ::std::vector<Fixed>;

using FixedList = std::list< ::Test::Fixed>;

using FixedListList = std::list< ::Test::FixedList>;

using FixedListSeq = ::std::vector<FixedList>;

using FixedSeqList = std::list< ::Test::FixedSeq>;
struct Variable;

using VariableSeq = ::std::vector<Variable>;

using VariableList = std::list< ::Test::Variable>;

using VariableListList = std::list< ::Test::VariableList>;

using VariableListSeq = ::std::vector<VariableList>;

using VariableSeqList = std::list< ::Test::VariableSeq>;

using StringStringDict = ::std::map<::std::string, ::std::string>;

using StringStringDictSeq = ::std::vector<StringStringDict>;

using StringStringDictList = std::list< ::Test::StringStringDict>;

using StringStringDictListList = std::list< ::Test::StringStringDictList>;

using StringStringDictListSeq = ::std::vector<StringStringDictList>;

using StringStringDictSeqList = std::list< ::Test::StringStringDictSeq>;

enum class E : unsigned char
{
    E1,
    E2,
    E3
};

using ESeq = ::std::vector<E>;

using EList = std::list< ::Test::E>;

using EListList = std::list< ::Test::EList>;

using EListSeq = ::std::vector<EList>;

using ESeqList = std::list< ::Test::ESeq>;
class C;

using CPtr = ::std::shared_ptr<C>;

using CSeq = ::std::vector<::std::shared_ptr<C>>;

using CList = std::list<std::shared_ptr<::Test::C>>;

using CListList = std::list< ::Test::CList>;

using CListSeq = ::std::vector<CList>;

using CSeqList = std::list< ::Test::CSeq>;
class DPrx;

using DPrxPtr = ::std::optional<DPrx>;

using DPrxSeq = ::std::vector<::std::optional<DPrx>>;

using DPrxList = std::list<::Test::DPrxPtr>;

using DPrxListList = std::list< ::Test::DPrxList>;

using DPrxListSeq = ::std::vector<DPrxList>;

using DPrxSeqList = std::list< ::Test::DPrxSeq>;

using DoubleSeq = ::std::vector<double>;
struct ClassOtherStruct;

using ClassOtherStructSeq = ::std::vector<ClassOtherStruct>;
struct ClassStruct;

using ClassStructSeq = ::std::vector<ClassStruct>;

using IntStringDict = Test::CustomMap<std::int32_t, std::string>;

using LongLongDict = ::std::map<::std::int64_t, ::std::int64_t>;

using StringIntDict = ::std::map<::std::string, ::std::int32_t>;
class DictClass;

using DictClassPtr = ::std::shared_ptr<DictClass>;

using BoolBuffer = Test::CustomBuffer<bool>;

using ShortBuffer = Test::CustomBuffer<std::int16_t>;

using IntBuffer = Test::CustomBuffer<std::int32_t>;

using LongBuffer = Test::CustomBuffer<int64_t>;

using FloatBuffer = Test::CustomBuffer<float>;

using DoubleBuffer = Test::CustomBuffer<double>;

using ByteBuffer = Test::CustomBuffer<Ice::Byte>;
struct BufferStruct;
class TestIntfPrx;

using TestIntfPrxPtr = ::std::optional<TestIntfPrx>;

}

namespace Test
{

class DPrx : public ::Ice::Proxy<DPrx, ::Ice::ObjectPrx>
{
public:

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId();

    explicit DPrx(const ::Ice::ObjectPrx& other) : ::Ice::ObjectPrx(other)
    {
    }

    DPrx(const DPrx& other) noexcept : ::Ice::ObjectPrx(other)
    {
    }

    DPrx(DPrx&& other) noexcept : ::Ice::ObjectPrx(::std::move(other))
    {
    }

    DPrx(const ::std::shared_ptr<::Ice::Communicator>& communicator, const ::std::string& proxyString) :
        ::Ice::ObjectPrx(communicator, proxyString)
    {
    }

    DPrx& operator=(const DPrx& rhs) noexcept
    {
        ::Ice::ObjectPrx::operator=(rhs);
        return *this;
    }

    DPrx& operator=(DPrx&& rhs) noexcept
    {
        ::Ice::ObjectPrx::operator=(::std::move(rhs));
        return *this;
    }

    /// \cond INTERNAL
    static DPrx _fromReference(::IceInternal::ReferencePtr ref) { return DPrx(::std::move(ref)); }

protected:

    DPrx() = default;

    explicit DPrx(::IceInternal::ReferencePtr&& ref) : ::Ice::ObjectPrx(::std::move(ref))
    {
    }
    /// \endcond
};

class TestIntfPrx : public ::Ice::Proxy<TestIntfPrx, ::Ice::ObjectPrx>
{
public:

    DoubleSeq opDoubleArray(const ::std::pair<const double*, const double*>& inSeq, DoubleSeq& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<DoubleSeq, DoubleSeq>> opDoubleArrayAsync(const ::std::pair<const double*, const double*>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    opDoubleArrayAsync(const ::std::pair<const double*, const double*>& inSeq,
                       ::std::function<void(::Test::DoubleSeq, ::Test::DoubleSeq)> response,
                       ::std::function<void(::std::exception_ptr)> ex = nullptr,
                       ::std::function<void(bool)> sent = nullptr,
                       const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opDoubleArray(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<DoubleSeq, DoubleSeq>>>&, const ::std::pair<const double*, const double*>&, const ::Ice::Context&) const;
    /// \endcond

    BoolSeq opBoolArray(const ::std::pair<const bool*, const bool*>& inSeq, BoolSeq& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<BoolSeq, BoolSeq>> opBoolArrayAsync(const ::std::pair<const bool*, const bool*>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    opBoolArrayAsync(const ::std::pair<const bool*, const bool*>& inSeq,
                     ::std::function<void(::Test::BoolSeq, ::Test::BoolSeq)> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opBoolArray(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<BoolSeq, BoolSeq>>>&, const ::std::pair<const bool*, const bool*>&, const ::Ice::Context&) const;
    /// \endcond

    ByteList opByteArray(const ::std::pair<const ::std::uint8_t*, const ::std::uint8_t*>& inSeq, ByteList& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<ByteList, ByteList>> opByteArrayAsync(const ::std::pair<const ::std::uint8_t*, const ::std::uint8_t*>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    opByteArrayAsync(const ::std::pair<const ::std::uint8_t*, const ::std::uint8_t*>& inSeq,
                     ::std::function<void(::std::pair<const ::std::uint8_t*, const ::std::uint8_t*>, ::std::pair<const ::std::uint8_t*, const ::std::uint8_t*>)> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opByteArray(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<ByteList, ByteList>>>&, const ::std::pair<const ::std::uint8_t*, const ::std::uint8_t*>&, const ::Ice::Context&) const;
    /// \endcond

    VariableList opVariableArray(const ::std::pair<const Variable*, const Variable*>& inSeq, VariableList& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<VariableList, VariableList>> opVariableArrayAsync(const ::std::pair<const Variable*, const Variable*>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    opVariableArrayAsync(const ::std::pair<const Variable*, const Variable*>& inSeq,
                         ::std::function<void(::Test::VariableList, ::Test::VariableList)> response,
                         ::std::function<void(::std::exception_ptr)> ex = nullptr,
                         ::std::function<void(bool)> sent = nullptr,
                         const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opVariableArray(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<VariableList, VariableList>>>&, const ::std::pair<const Variable*, const Variable*>&, const ::Ice::Context&) const;
    /// \endcond

    BoolSeq opBoolRange(const BoolSeq& inSeq, BoolSeq& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<BoolSeq, BoolSeq>> opBoolRangeAsync(const BoolSeq& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    opBoolRangeAsync(const BoolSeq& inSeq,
                     ::std::function<void(::Test::BoolSeq, ::Test::BoolSeq)> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opBoolRange(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<BoolSeq, BoolSeq>>>&, const BoolSeq&, const ::Ice::Context&) const;
    /// \endcond

    ByteList opByteRange(const ByteList& inSeq, ByteList& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<ByteList, ByteList>> opByteRangeAsync(const ByteList& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    opByteRangeAsync(const ByteList& inSeq,
                     ::std::function<void(::Test::ByteList, ::Test::ByteList)> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opByteRange(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<ByteList, ByteList>>>&, const ByteList&, const ::Ice::Context&) const;
    /// \endcond

    VariableList opVariableRange(const VariableList& inSeq, VariableList& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<VariableList, VariableList>> opVariableRangeAsync(const VariableList& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    opVariableRangeAsync(const VariableList& inSeq,
                         ::std::function<void(::Test::VariableList, ::Test::VariableList)> response,
                         ::std::function<void(::std::exception_ptr)> ex = nullptr,
                         ::std::function<void(bool)> sent = nullptr,
                         const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opVariableRange(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<VariableList, VariableList>>>&, const VariableList&, const ::Ice::Context&) const;
    /// \endcond

    ByteList opByteRangeType(const ByteList& inSeq, ByteList& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<ByteList, ByteList>> opByteRangeTypeAsync(const ByteList& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    opByteRangeTypeAsync(const ByteList& inSeq,
                         ::std::function<void(::Test::ByteList, ::Test::ByteList)> response,
                         ::std::function<void(::std::exception_ptr)> ex = nullptr,
                         ::std::function<void(bool)> sent = nullptr,
                         const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opByteRangeType(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<ByteList, ByteList>>>&, const ByteList&, const ::Ice::Context&) const;
    /// \endcond

    VariableList opVariableRangeType(const VariableList& inSeq, VariableList& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<VariableList, VariableList>> opVariableRangeTypeAsync(const VariableList& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    opVariableRangeTypeAsync(const VariableList& inSeq,
                             ::std::function<void(::Test::VariableList, ::Test::VariableList)> response,
                             ::std::function<void(::std::exception_ptr)> ex = nullptr,
                             ::std::function<void(bool)> sent = nullptr,
                             const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opVariableRangeType(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<VariableList, VariableList>>>&, const VariableList&, const ::Ice::Context&) const;
    /// \endcond

    std::deque<bool> opBoolSeq(const std::deque<bool>& inSeq, std::deque<bool>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<std::deque<bool>, std::deque<bool>>> opBoolSeqAsync(const std::deque<bool>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    opBoolSeqAsync(const std::deque<bool>& inSeq,
                   ::std::function<void(std::deque<bool>, std::deque<bool>)> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opBoolSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<std::deque<bool>, std::deque<bool>>>>&, const std::deque<bool>&, const ::Ice::Context&) const;
    /// \endcond

    BoolList opBoolList(const BoolList& inSeq, BoolList& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<BoolList, BoolList>> opBoolListAsync(const BoolList& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    opBoolListAsync(const BoolList& inSeq,
                    ::std::function<void(::Test::BoolList, ::Test::BoolList)> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opBoolList(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<BoolList, BoolList>>>&, const BoolList&, const ::Ice::Context&) const;
    /// \endcond

    std::deque< ::Ice::Byte> opByteSeq(const std::deque< ::Ice::Byte>& inSeq, std::deque< ::Ice::Byte>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<std::deque< ::Ice::Byte>, std::deque< ::Ice::Byte>>> opByteSeqAsync(const std::deque< ::Ice::Byte>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    opByteSeqAsync(const std::deque< ::Ice::Byte>& inSeq,
                   ::std::function<void(std::deque< ::Ice::Byte>, std::deque< ::Ice::Byte>)> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opByteSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<std::deque< ::Ice::Byte>, std::deque< ::Ice::Byte>>>>&, const std::deque< ::Ice::Byte>&, const ::Ice::Context&) const;
    /// \endcond

    ByteList opByteList(const ByteList& inSeq, ByteList& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<ByteList, ByteList>> opByteListAsync(const ByteList& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    opByteListAsync(const ByteList& inSeq,
                    ::std::function<void(::Test::ByteList, ::Test::ByteList)> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opByteList(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<ByteList, ByteList>>>&, const ByteList&, const ::Ice::Context&) const;
    /// \endcond

    MyByteSeq opMyByteSeq(const MyByteSeq& inSeq, MyByteSeq& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<MyByteSeq, MyByteSeq>> opMyByteSeqAsync(const MyByteSeq& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    opMyByteSeqAsync(const MyByteSeq& inSeq,
                     ::std::function<void(MyByteSeq, MyByteSeq)> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opMyByteSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<MyByteSeq, MyByteSeq>>>&, const MyByteSeq&, const ::Ice::Context&) const;
    /// \endcond

    std::deque<std::string> opStringSeq(const std::deque<std::string>& inSeq, std::deque<std::string>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<std::deque<std::string>, std::deque<std::string>>> opStringSeqAsync(const std::deque<std::string>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    opStringSeqAsync(const std::deque<std::string>& inSeq,
                     ::std::function<void(std::deque<std::string>, std::deque<std::string>)> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opStringSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<std::deque<std::string>, std::deque<std::string>>>>&, const std::deque<std::string>&, const ::Ice::Context&) const;
    /// \endcond

    StringList opStringList(const StringList& inSeq, StringList& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<StringList, StringList>> opStringListAsync(const StringList& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    opStringListAsync(const StringList& inSeq,
                      ::std::function<void(::Test::StringList, ::Test::StringList)> response,
                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                      ::std::function<void(bool)> sent = nullptr,
                      const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opStringList(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<StringList, StringList>>>&, const StringList&, const ::Ice::Context&) const;
    /// \endcond

    std::deque< ::Test::Fixed> opFixedSeq(const std::deque< ::Test::Fixed>& inSeq, std::deque< ::Test::Fixed>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<std::deque< ::Test::Fixed>, std::deque< ::Test::Fixed>>> opFixedSeqAsync(const std::deque< ::Test::Fixed>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    opFixedSeqAsync(const std::deque< ::Test::Fixed>& inSeq,
                    ::std::function<void(std::deque< ::Test::Fixed>, std::deque< ::Test::Fixed>)> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opFixedSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<std::deque< ::Test::Fixed>, std::deque< ::Test::Fixed>>>>&, const std::deque< ::Test::Fixed>&, const ::Ice::Context&) const;
    /// \endcond

    FixedList opFixedList(const FixedList& inSeq, FixedList& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<FixedList, FixedList>> opFixedListAsync(const FixedList& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    opFixedListAsync(const FixedList& inSeq,
                     ::std::function<void(::Test::FixedList, ::Test::FixedList)> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opFixedList(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<FixedList, FixedList>>>&, const FixedList&, const ::Ice::Context&) const;
    /// \endcond

    std::deque< ::Test::Variable> opVariableSeq(const std::deque< ::Test::Variable>& inSeq, std::deque< ::Test::Variable>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<std::deque< ::Test::Variable>, std::deque< ::Test::Variable>>> opVariableSeqAsync(const std::deque< ::Test::Variable>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    opVariableSeqAsync(const std::deque< ::Test::Variable>& inSeq,
                       ::std::function<void(std::deque< ::Test::Variable>, std::deque< ::Test::Variable>)> response,
                       ::std::function<void(::std::exception_ptr)> ex = nullptr,
                       ::std::function<void(bool)> sent = nullptr,
                       const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opVariableSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<std::deque< ::Test::Variable>, std::deque< ::Test::Variable>>>>&, const std::deque< ::Test::Variable>&, const ::Ice::Context&) const;
    /// \endcond

    VariableList opVariableList(const VariableList& inSeq, VariableList& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<VariableList, VariableList>> opVariableListAsync(const VariableList& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    opVariableListAsync(const VariableList& inSeq,
                        ::std::function<void(::Test::VariableList, ::Test::VariableList)> response,
                        ::std::function<void(::std::exception_ptr)> ex = nullptr,
                        ::std::function<void(bool)> sent = nullptr,
                        const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opVariableList(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<VariableList, VariableList>>>&, const VariableList&, const ::Ice::Context&) const;
    /// \endcond

    std::deque< ::Test::StringStringDict> opStringStringDictSeq(const std::deque< ::Test::StringStringDict>& inSeq, std::deque< ::Test::StringStringDict>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<std::deque< ::Test::StringStringDict>, std::deque< ::Test::StringStringDict>>> opStringStringDictSeqAsync(const std::deque< ::Test::StringStringDict>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    opStringStringDictSeqAsync(const std::deque< ::Test::StringStringDict>& inSeq,
                               ::std::function<void(std::deque< ::Test::StringStringDict>, std::deque< ::Test::StringStringDict>)> response,
                               ::std::function<void(::std::exception_ptr)> ex = nullptr,
                               ::std::function<void(bool)> sent = nullptr,
                               const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opStringStringDictSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<std::deque< ::Test::StringStringDict>, std::deque< ::Test::StringStringDict>>>>&, const std::deque< ::Test::StringStringDict>&, const ::Ice::Context&) const;
    /// \endcond

    StringStringDictList opStringStringDictList(const StringStringDictList& inSeq, StringStringDictList& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<StringStringDictList, StringStringDictList>> opStringStringDictListAsync(const StringStringDictList& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    opStringStringDictListAsync(const StringStringDictList& inSeq,
                                ::std::function<void(::Test::StringStringDictList, ::Test::StringStringDictList)> response,
                                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                                ::std::function<void(bool)> sent = nullptr,
                                const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opStringStringDictList(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<StringStringDictList, StringStringDictList>>>&, const StringStringDictList&, const ::Ice::Context&) const;
    /// \endcond

    std::deque< ::Test::E> opESeq(const std::deque< ::Test::E>& inSeq, std::deque< ::Test::E>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<std::deque< ::Test::E>, std::deque< ::Test::E>>> opESeqAsync(const std::deque< ::Test::E>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    opESeqAsync(const std::deque< ::Test::E>& inSeq,
                ::std::function<void(std::deque< ::Test::E>, std::deque< ::Test::E>)> response,
                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                ::std::function<void(bool)> sent = nullptr,
                const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opESeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<std::deque< ::Test::E>, std::deque< ::Test::E>>>>&, const std::deque< ::Test::E>&, const ::Ice::Context&) const;
    /// \endcond

    EList opEList(const EList& inSeq, EList& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<EList, EList>> opEListAsync(const EList& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    opEListAsync(const EList& inSeq,
                 ::std::function<void(::Test::EList, ::Test::EList)> response,
                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                 ::std::function<void(bool)> sent = nullptr,
                 const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opEList(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<EList, EList>>>&, const EList&, const ::Ice::Context&) const;
    /// \endcond

    std::deque<::Test::DPrxPtr> opDPrxSeq(const std::deque<::Test::DPrxPtr>& inSeq, std::deque<::Test::DPrxPtr>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<std::deque<::Test::DPrxPtr>, std::deque<::Test::DPrxPtr>>> opDPrxSeqAsync(const std::deque<::Test::DPrxPtr>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    opDPrxSeqAsync(const std::deque<::Test::DPrxPtr>& inSeq,
                   ::std::function<void(std::deque<::Test::DPrxPtr>, std::deque<::Test::DPrxPtr>)> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opDPrxSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<std::deque<::Test::DPrxPtr>, std::deque<::Test::DPrxPtr>>>>&, const std::deque<::Test::DPrxPtr>&, const ::Ice::Context&) const;
    /// \endcond

    DPrxList opDPrxList(const DPrxList& inSeq, DPrxList& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<DPrxList, DPrxList>> opDPrxListAsync(const DPrxList& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    opDPrxListAsync(const DPrxList& inSeq,
                    ::std::function<void(::Test::DPrxList, ::Test::DPrxList)> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opDPrxList(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<DPrxList, DPrxList>>>&, const DPrxList&, const ::Ice::Context&) const;
    /// \endcond

    std::deque<std::shared_ptr<Test::C>> opCSeq(const std::deque<std::shared_ptr<Test::C>>& inSeq, std::deque<std::shared_ptr<Test::C>>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<std::deque<std::shared_ptr<Test::C>>, std::deque<std::shared_ptr<Test::C>>>> opCSeqAsync(const std::deque<std::shared_ptr<Test::C>>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    opCSeqAsync(const std::deque<std::shared_ptr<Test::C>>& inSeq,
                ::std::function<void(std::deque<std::shared_ptr<Test::C>>, std::deque<std::shared_ptr<Test::C>>)> response,
                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                ::std::function<void(bool)> sent = nullptr,
                const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opCSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<std::deque<std::shared_ptr<Test::C>>, std::deque<std::shared_ptr<Test::C>>>>>&, const std::deque<std::shared_ptr<Test::C>>&, const ::Ice::Context&) const;
    /// \endcond

    CList opCList(const CList& inSeq, CList& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<CList, CList>> opCListAsync(const CList& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    opCListAsync(const CList& inSeq,
                 ::std::function<void(::Test::CList, ::Test::CList)> response,
                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                 ::std::function<void(bool)> sent = nullptr,
                 const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opCList(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<CList, CList>>>&, const CList&, const ::Ice::Context&) const;
    /// \endcond

    ClassStruct opClassStruct(const ClassStruct& inS, const ClassStructSeq& inSeq, ClassStruct& outS, ClassStructSeq& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<ClassStruct, ClassStruct, ClassStructSeq>> opClassStructAsync(const ClassStruct& inS, const ClassStructSeq& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    opClassStructAsync(const ClassStruct& inS, const ClassStructSeq& inSeq,
                       ::std::function<void(::Test::ClassStruct, ::Test::ClassStruct, ::Test::ClassStructSeq)> response,
                       ::std::function<void(::std::exception_ptr)> ex = nullptr,
                       ::std::function<void(bool)> sent = nullptr,
                       const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opClassStruct(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<ClassStruct, ClassStruct, ClassStructSeq>>>&, const ClassStruct&, const ClassStructSeq&, const ::Ice::Context&) const;
    /// \endcond

    void opOutArrayByteSeq(const ByteSeq& org, ByteSeq& copy, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<ByteSeq> opOutArrayByteSeqAsync(const ByteSeq& org, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    opOutArrayByteSeqAsync(const ByteSeq& org,
                           ::std::function<void(::std::pair<const ::std::uint8_t*, const ::std::uint8_t*>)> response,
                           ::std::function<void(::std::exception_ptr)> ex = nullptr,
                           ::std::function<void(bool)> sent = nullptr,
                           const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opOutArrayByteSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ByteSeq>>&, const ByteSeq&, const ::Ice::Context&) const;
    /// \endcond

    void opOutRangeByteSeq(const ByteSeq& org, ByteSeq& copy, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<ByteSeq> opOutRangeByteSeqAsync(const ByteSeq& org, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    opOutRangeByteSeqAsync(const ByteSeq& org,
                           ::std::function<void(::Test::ByteSeq)> response,
                           ::std::function<void(::std::exception_ptr)> ex = nullptr,
                           ::std::function<void(bool)> sent = nullptr,
                           const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opOutRangeByteSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ByteSeq>>&, const ByteSeq&, const ::Ice::Context&) const;
    /// \endcond

    IntStringDict opIntStringDict(const IntStringDict& idict, IntStringDict& odict, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<IntStringDict, IntStringDict>> opIntStringDictAsync(const IntStringDict& idict, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    opIntStringDictAsync(const IntStringDict& idict,
                         ::std::function<void(::Test::IntStringDict, ::Test::IntStringDict)> response,
                         ::std::function<void(::std::exception_ptr)> ex = nullptr,
                         ::std::function<void(bool)> sent = nullptr,
                         const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opIntStringDict(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<IntStringDict, IntStringDict>>>&, const IntStringDict&, const ::Ice::Context&) const;
    /// \endcond

    ::Test::CustomMap< int64_t, int64_t> opVarDict(const ::Test::CustomMap<std::string, std::int32_t>& idict, ::Test::CustomMap<std::string, std::int32_t>& odict, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<::Test::CustomMap< int64_t, int64_t>, ::Test::CustomMap<std::string, std::int32_t>>> opVarDictAsync(const ::Test::CustomMap<std::string, std::int32_t>& idict, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    opVarDictAsync(const ::Test::CustomMap<std::string, std::int32_t>& idict,
                   ::std::function<void(::Test::CustomMap< int64_t, int64_t>, ::Test::CustomMap<std::string, std::int32_t>)> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opVarDict(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::Test::CustomMap< int64_t, int64_t>, ::Test::CustomMap<std::string, std::int32_t>>>>&, const ::Test::CustomMap<std::string, std::int32_t>&, const ::Ice::Context&) const;
    /// \endcond

    ShortBuffer opShortBuffer(const ShortBuffer& inS, ShortBuffer& outS, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<ShortBuffer, ShortBuffer>> opShortBufferAsync(const ShortBuffer& inS, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    opShortBufferAsync(const ShortBuffer& inS,
                       ::std::function<void(::Test::ShortBuffer, ::Test::ShortBuffer)> response,
                       ::std::function<void(::std::exception_ptr)> ex = nullptr,
                       ::std::function<void(bool)> sent = nullptr,
                       const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opShortBuffer(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<ShortBuffer, ShortBuffer>>>&, const ShortBuffer&, const ::Ice::Context&) const;
    /// \endcond

    ::Test::CustomBuffer<bool> opBoolBuffer(const ::Test::CustomBuffer<bool>& inS, ::Test::CustomBuffer<bool>& outS, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<::Test::CustomBuffer<bool>, ::Test::CustomBuffer<bool>>> opBoolBufferAsync(const ::Test::CustomBuffer<bool>& inS, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    opBoolBufferAsync(const ::Test::CustomBuffer<bool>& inS,
                      ::std::function<void(::Test::CustomBuffer<bool>, ::Test::CustomBuffer<bool>)> response,
                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                      ::std::function<void(bool)> sent = nullptr,
                      const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opBoolBuffer(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::Test::CustomBuffer<bool>, ::Test::CustomBuffer<bool>>>>&, const ::Test::CustomBuffer<bool>&, const ::Ice::Context&) const;
    /// \endcond

    BufferStruct opBufferStruct(const BufferStruct& s, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<BufferStruct> opBufferStructAsync(const BufferStruct& s, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    opBufferStructAsync(const BufferStruct& s,
                        ::std::function<void(::Test::BufferStruct)> response,
                        ::std::function<void(::std::exception_ptr)> ex = nullptr,
                        ::std::function<void(bool)> sent = nullptr,
                        const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_opBufferStruct(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<BufferStruct>>&, const BufferStruct&, const ::Ice::Context&) const;
    /// \endcond

    void shutdown(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<void> shutdownAsync(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    shutdownAsync(::std::function<void()> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_shutdown(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&) const;
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId();

    explicit TestIntfPrx(const ::Ice::ObjectPrx& other) : ::Ice::ObjectPrx(other)
    {
    }

    TestIntfPrx(const TestIntfPrx& other) noexcept : ::Ice::ObjectPrx(other)
    {
    }

    TestIntfPrx(TestIntfPrx&& other) noexcept : ::Ice::ObjectPrx(::std::move(other))
    {
    }

    TestIntfPrx(const ::std::shared_ptr<::Ice::Communicator>& communicator, const ::std::string& proxyString) :
        ::Ice::ObjectPrx(communicator, proxyString)
    {
    }

    TestIntfPrx& operator=(const TestIntfPrx& rhs) noexcept
    {
        ::Ice::ObjectPrx::operator=(rhs);
        return *this;
    }

    TestIntfPrx& operator=(TestIntfPrx&& rhs) noexcept
    {
        ::Ice::ObjectPrx::operator=(::std::move(rhs));
        return *this;
    }

    /// \cond INTERNAL
    static TestIntfPrx _fromReference(::IceInternal::ReferencePtr ref) { return TestIntfPrx(::std::move(ref)); }

protected:

    TestIntfPrx() = default;

    explicit TestIntfPrx(::IceInternal::ReferencePtr&& ref) : ::Ice::ObjectPrx(::std::move(ref))
    {
    }
    /// \endcond
};

}

namespace Test
{

struct Fixed
{
    ::std::int16_t s;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::int16_t&> ice_tuple() const
    {
        return std::tie(s);
    }
};

struct Variable
{
    ::std::string s;
    ::Test::BoolList bl;
    std::list<std::string> ss;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::Test::BoolList&, const std::list<std::string>&> ice_tuple() const
    {
        return std::tie(s, bl, ss);
    }
};

class C : public ::Ice::ValueHelper<C, ::Ice::Value>
{
public:

    virtual ~C();

    C() = default;

    C(const C&) = default;
    C(C&&) = default;
    C& operator=(const C&) = default;
    C& operator=(C&&) = default;

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<> ice_tuple() const
    {
        return std::tie();
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId();
};

/// \cond INTERNAL
static C _iceS_C_init;
/// \endcond

struct ClassOtherStruct
{
    ::std::int32_t x;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::int32_t&> ice_tuple() const
    {
        return std::tie(x);
    }
};

struct ClassStruct
{
    ::Test::ClassOtherStructSeq otherSeq;
    ::Test::ClassOtherStruct other;
    ::std::int32_t y;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::Test::ClassOtherStructSeq&, const ::Test::ClassOtherStruct&, const ::std::int32_t&> ice_tuple() const
    {
        return std::tie(otherSeq, other, y);
    }
};

class DictClass : public ::Ice::ValueHelper<DictClass, ::Ice::Value>
{
public:

    virtual ~DictClass();

    DictClass() = default;

    DictClass(const DictClass&) = default;
    DictClass(DictClass&&) = default;
    DictClass& operator=(const DictClass&) = default;
    DictClass& operator=(DictClass&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit DictClass(const ::Test::IntStringDict& isdict) :
        isdict(isdict)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::Test::IntStringDict&> ice_tuple() const
    {
        return std::tie(isdict);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId();

    ::Test::IntStringDict isdict;
};

struct BufferStruct
{
    ::Test::ByteBuffer byteBuf;
    ::Test::BoolBuffer boolBuf;
    ::Test::ShortBuffer shortBuf;
    ::Test::IntBuffer intBuf;
    ::Test::LongBuffer longBuf;
    ::Test::FloatBuffer floatBuf;
    ::Test::DoubleBuffer doubleBuf;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::Test::ByteBuffer&, const ::Test::BoolBuffer&, const ::Test::ShortBuffer&, const ::Test::IntBuffer&, const ::Test::LongBuffer&, const ::Test::FloatBuffer&, const ::Test::DoubleBuffer&> ice_tuple() const
    {
        return std::tie(byteBuf, boolBuf, shortBuf, intBuf, longBuf, floatBuf, doubleBuf);
    }
};

using Ice::operator<;
using Ice::operator<=;
using Ice::operator>;
using Ice::operator>=;
using Ice::operator==;
using Ice::operator!=;

}

namespace Test
{

class D : public virtual ::Ice::Object
{
public:

    using ProxyType = DPrx;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static ::std::string_view ice_staticId();
};

using DPtr = ::std::shared_ptr<D>;

class TestIntf : public virtual ::Ice::Object
{
public:

    using ProxyType = TestIntfPrx;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static ::std::string_view ice_staticId();

    virtual void opDoubleArrayAsync(::std::pair<const double*, const double*> inSeq, ::std::function<void(const DoubleSeq& returnValue, const DoubleSeq& outSeq)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opDoubleArray(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opBoolArrayAsync(::std::pair<const bool*, const bool*> inSeq, ::std::function<void(const BoolSeq& returnValue, const BoolSeq& outSeq)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opBoolArray(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opByteArrayAsync(::std::pair<const ::std::uint8_t*, const ::std::uint8_t*> inSeq, ::std::function<void(const ::std::pair<const ::std::uint8_t*, const ::std::uint8_t*>& returnValue, const ::std::pair<const ::std::uint8_t*, const ::std::uint8_t*>& outSeq)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opByteArray(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opVariableArrayAsync(::std::pair<const Variable*, const Variable*> inSeq, ::std::function<void(const VariableList& returnValue, const VariableList& outSeq)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opVariableArray(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opBoolRangeAsync(BoolSeq inSeq, ::std::function<void(const BoolSeq& returnValue, const BoolSeq& outSeq)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opBoolRange(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opByteRangeAsync(ByteList inSeq, ::std::function<void(const ByteList& returnValue, const ByteList& outSeq)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opByteRange(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opVariableRangeAsync(VariableList inSeq, ::std::function<void(const VariableList& returnValue, const VariableList& outSeq)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opVariableRange(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opByteRangeTypeAsync(ByteList inSeq, ::std::function<void(const ByteList& returnValue, const ByteList& outSeq)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opByteRangeType(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opVariableRangeTypeAsync(VariableList inSeq, ::std::function<void(const VariableList& returnValue, const VariableList& outSeq)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opVariableRangeType(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opBoolSeqAsync(std::deque<bool> inSeq, ::std::function<void(const std::deque<bool>& returnValue, const std::deque<bool>& outSeq)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opBoolSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opBoolListAsync(BoolList inSeq, ::std::function<void(const BoolList& returnValue, const BoolList& outSeq)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opBoolList(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opByteSeqAsync(std::deque< ::Ice::Byte> inSeq, ::std::function<void(const std::deque< ::Ice::Byte>& returnValue, const std::deque< ::Ice::Byte>& outSeq)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opByteSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opByteListAsync(ByteList inSeq, ::std::function<void(const ByteList& returnValue, const ByteList& outSeq)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opByteList(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opMyByteSeqAsync(MyByteSeq inSeq, ::std::function<void(const MyByteSeq& returnValue, const MyByteSeq& outSeq)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opMyByteSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opStringSeqAsync(std::deque<std::string> inSeq, ::std::function<void(const std::deque<std::string>& returnValue, const std::deque<std::string>& outSeq)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opStringSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opStringListAsync(StringList inSeq, ::std::function<void(const StringList& returnValue, const StringList& outSeq)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opStringList(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opFixedSeqAsync(std::deque< ::Test::Fixed> inSeq, ::std::function<void(const std::deque< ::Test::Fixed>& returnValue, const std::deque< ::Test::Fixed>& outSeq)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opFixedSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opFixedListAsync(FixedList inSeq, ::std::function<void(const FixedList& returnValue, const FixedList& outSeq)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opFixedList(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opVariableSeqAsync(std::deque< ::Test::Variable> inSeq, ::std::function<void(const std::deque< ::Test::Variable>& returnValue, const std::deque< ::Test::Variable>& outSeq)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opVariableSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opVariableListAsync(VariableList inSeq, ::std::function<void(const VariableList& returnValue, const VariableList& outSeq)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opVariableList(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opStringStringDictSeqAsync(std::deque< ::Test::StringStringDict> inSeq, ::std::function<void(const std::deque< ::Test::StringStringDict>& returnValue, const std::deque< ::Test::StringStringDict>& outSeq)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opStringStringDictSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opStringStringDictListAsync(StringStringDictList inSeq, ::std::function<void(const StringStringDictList& returnValue, const StringStringDictList& outSeq)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opStringStringDictList(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opESeqAsync(std::deque< ::Test::E> inSeq, ::std::function<void(const std::deque< ::Test::E>& returnValue, const std::deque< ::Test::E>& outSeq)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opESeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opEListAsync(EList inSeq, ::std::function<void(const EList& returnValue, const EList& outSeq)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opEList(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opDPrxSeqAsync(std::deque<::Test::DPrxPtr> inSeq, ::std::function<void(const std::deque<::Test::DPrxPtr>& returnValue, const std::deque<::Test::DPrxPtr>& outSeq)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opDPrxSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opDPrxListAsync(DPrxList inSeq, ::std::function<void(const DPrxList& returnValue, const DPrxList& outSeq)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opDPrxList(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opCSeqAsync(std::deque<std::shared_ptr<Test::C>> inSeq, ::std::function<void(const std::deque<std::shared_ptr<Test::C>>& returnValue, const std::deque<std::shared_ptr<Test::C>>& outSeq)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opCSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opCListAsync(CList inSeq, ::std::function<void(const CList& returnValue, const CList& outSeq)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opCList(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opClassStructAsync(ClassStruct inS, ClassStructSeq inSeq, ::std::function<void(const ClassStruct& returnValue, const ClassStruct& outS, const ClassStructSeq& outSeq)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opClassStruct(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opOutArrayByteSeqAsync(ByteSeq org, ::std::function<void(const ::std::pair<const ::std::uint8_t*, const ::std::uint8_t*>& copy)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opOutArrayByteSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opOutRangeByteSeqAsync(ByteSeq org, ::std::function<void(const ByteSeq& copy)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opOutRangeByteSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opIntStringDictAsync(IntStringDict idict, ::std::function<void(const IntStringDict& returnValue, const IntStringDict& odict)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opIntStringDict(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opVarDictAsync(::Test::CustomMap<std::string, std::int32_t> idict, ::std::function<void(const ::Test::CustomMap< int64_t, int64_t>& returnValue, const ::Test::CustomMap<std::string, std::int32_t>& odict)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opVarDict(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opShortBufferAsync(ShortBuffer inS, ::std::function<void(const ShortBuffer& returnValue, const ShortBuffer& outS)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opShortBuffer(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opBoolBufferAsync(::Test::CustomBuffer<bool> inS, ::std::function<void(const ::Test::CustomBuffer<bool>& returnValue, const ::Test::CustomBuffer<bool>& outS)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opBoolBuffer(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opBufferStructAsync(BufferStruct s, ::std::function<void(const BufferStruct& returnValue)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opBufferStruct(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void shutdownAsync(::std::function<void()> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_shutdown(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

using TestIntfPtr = ::std::shared_ptr<TestIntf>;

}

/// \cond STREAM
namespace Ice
{

template<>
struct StreamableTraits<::Test::Fixed>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 2;
    static const bool fixedLength = true;
};

template<typename S>
struct StreamReader<::Test::Fixed, S>
{
    static void read(S* istr, ::Test::Fixed& v)
    {
        istr->readAll(v.s);
    }
};

template<>
struct StreamableTraits<::Test::Variable>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 3;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::Test::Variable, S>
{
    static void read(S* istr, ::Test::Variable& v)
    {
        istr->readAll(v.s, v.bl, v.ss);
    }
};

template<>
struct StreamableTraits< ::Test::E>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 2;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits<::Test::ClassOtherStruct>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 4;
    static const bool fixedLength = true;
};

template<typename S>
struct StreamReader<::Test::ClassOtherStruct, S>
{
    static void read(S* istr, ::Test::ClassOtherStruct& v)
    {
        istr->readAll(v.x);
    }
};

template<>
struct StreamableTraits<::Test::ClassStruct>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 9;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::Test::ClassStruct, S>
{
    static void read(S* istr, ::Test::ClassStruct& v)
    {
        istr->readAll(v.otherSeq, v.other, v.y);
    }
};

template<typename S>
struct StreamReader<::Test::DictClass, S>
{
    static void read(S* istr, ::Test::DictClass& v)
    {
        istr->readAll(v.isdict);
    }
};

template<>
struct StreamableTraits<::Test::BufferStruct>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 7;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::Test::BufferStruct, S>
{
    static void read(S* istr, ::Test::BufferStruct& v)
    {
        istr->readAll(v.byteBuf, v.boolBuf, v.shortBuf, v.intBuf, v.longBuf, v.floatBuf, v.doubleBuf);
    }
};

}
/// \endcond

#include <IceUtil/PopDisableWarnings.h>
#endif
