//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.8.0-alpha.0
//
// <auto-generated>
//
// Generated from file `TestAMD.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __TestAMD_h__
#define __TestAMD_h__

#include <IceUtil/PushDisableWarnings.h>
#include <Ice/Ice.h>
#include <IceUtil/UndefSysMacros.h>
#include <deque>
#include <list>
#include <MyByteSeq.h>
#include <CustomMap.h>
#include <CustomBuffer.h>
#include <StringView.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION  != 30850
#       error Ice version mismatch: an exact match is required for beta generated code
#   endif
#endif

#ifdef ICE_CPP11_MAPPING // C++11 mapping

namespace Test
{

class C;
class D;
class DPrx;
class DictClass;
class TestIntf;
class TestIntfPrx;

}

namespace Test
{

using BoolSeq = ::std::vector<bool>;

using BoolList = std::list<bool>;

using BoolListList = std::list< ::Test::BoolList>;

using BoolListSeq = ::std::vector<BoolList>;

using BoolSeqList = std::list< ::Test::BoolSeq>;

using ByteSeq = ::std::vector<::Ice::Byte>;

using ByteList = std::list< ::Ice::Byte>;

using ByteListList = std::list< ::Test::ByteList>;

using ByteListSeq = ::std::vector<ByteList>;

using ByteSeqList = std::list< ::Test::ByteSeq>;

using StringSeq = ::std::vector<::std::string>;

using StringList = std::list<std::string>;

using StringListList = std::list< ::Test::StringList>;

using StringListSeq = ::std::vector<StringList>;

using StringSeqList = std::list< ::Test::StringSeq>;

struct Fixed
{
    short s;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const short&> ice_tuple() const
    {
        return std::tie(s);
    }
};

using FixedSeq = ::std::vector<Fixed>;

using FixedList = std::list< ::Test::Fixed>;

using FixedListList = std::list< ::Test::FixedList>;

using FixedListSeq = ::std::vector<FixedList>;

using FixedSeqList = std::list< ::Test::FixedSeq>;

struct Variable
{
    ::std::string s;
    ::Test::BoolList bl;
    std::list<std::string> ss;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::Test::BoolList&, const std::list<std::string>&> ice_tuple() const
    {
        return std::tie(s, bl, ss);
    }
};

using VariableSeq = ::std::vector<Variable>;

using VariableList = std::list< ::Test::Variable>;

using VariableListList = std::list< ::Test::VariableList>;

using VariableListSeq = ::std::vector<VariableList>;

using VariableSeqList = std::list< ::Test::VariableSeq>;

using StringStringDict = ::std::map<::std::string, ::std::string>;

using StringStringDictSeq = ::std::vector<StringStringDict>;

using StringStringDictList = std::list< ::Test::StringStringDict>;

using StringStringDictListList = std::list< ::Test::StringStringDictList>;

using StringStringDictListSeq = ::std::vector<StringStringDictList>;

using StringStringDictSeqList = std::list< ::Test::StringStringDictSeq>;

enum class E : unsigned char
{
    E1,
    E2,
    E3
};

using ESeq = ::std::vector<E>;

using EList = std::list< ::Test::E>;

using EListList = std::list< ::Test::EList>;

using EListSeq = ::std::vector<EList>;

using ESeqList = std::list< ::Test::ESeq>;

using CSeq = ::std::vector<::std::shared_ptr<C>>;

using CList = std::list<std::shared_ptr<::Test::C>>;

using CListList = std::list< ::Test::CList>;

using CListSeq = ::std::vector<CList>;

using CSeqList = std::list< ::Test::CSeq>;

using DPrxSeq = ::std::vector<::std::shared_ptr<DPrx>>;

using DPrxList = std::list<std::shared_ptr<::Test::DPrx>>;

using DPrxListList = std::list< ::Test::DPrxList>;

using DPrxListSeq = ::std::vector<DPrxList>;

using DPrxSeqList = std::list< ::Test::DPrxSeq>;

using DoubleSeq = ::std::vector<double>;

struct ClassOtherStruct
{
    int x;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const int&> ice_tuple() const
    {
        return std::tie(x);
    }
};

using ClassOtherStructSeq = ::std::vector<ClassOtherStruct>;

struct ClassStruct
{
    ::Test::ClassOtherStructSeq otherSeq;
    ::Test::ClassOtherStruct other;
    int y;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::Test::ClassOtherStructSeq&, const ::Test::ClassOtherStruct&, const int&> ice_tuple() const
    {
        return std::tie(otherSeq, other, y);
    }
};

using ClassStructSeq = ::std::vector<ClassStruct>;

using IntStringDict = Test::CustomMap<Ice::Int, std::string>;

using LongLongDict = ::std::map<long long int, long long int>;

using StringIntDict = ::std::map<::std::string, int>;

using BoolBuffer = Test::CustomBuffer<bool>;

using ShortBuffer = Test::CustomBuffer<Ice::Short>;

using IntBuffer = Test::CustomBuffer<Ice::Int>;

using LongBuffer = Test::CustomBuffer<Ice::Long>;

using FloatBuffer = Test::CustomBuffer<Ice::Float>;

using DoubleBuffer = Test::CustomBuffer<Ice::Double>;

using ByteBuffer = Test::CustomBuffer<Ice::Byte>;

struct BufferStruct
{
    ::Test::ByteBuffer byteBuf;
    ::Test::BoolBuffer boolBuf;
    ::Test::ShortBuffer shortBuf;
    ::Test::IntBuffer intBuf;
    ::Test::LongBuffer longBuf;
    ::Test::FloatBuffer floatBuf;
    ::Test::DoubleBuffer doubleBuf;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::Test::ByteBuffer&, const ::Test::BoolBuffer&, const ::Test::ShortBuffer&, const ::Test::IntBuffer&, const ::Test::LongBuffer&, const ::Test::FloatBuffer&, const ::Test::DoubleBuffer&> ice_tuple() const
    {
        return std::tie(byteBuf, boolBuf, shortBuf, intBuf, longBuf, floatBuf, doubleBuf);
    }
};

using Ice::operator<;
using Ice::operator<=;
using Ice::operator>;
using Ice::operator>=;
using Ice::operator==;
using Ice::operator!=;

}

namespace Test
{

class D : public virtual ::Ice::Object
{
public:

    using ProxyType = DPrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();
};

class TestIntf : public virtual ::Ice::Object
{
public:

    using ProxyType = TestIntfPrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /**
     * Encapsulates the results of a call to opDoubleArray.
     */
    struct OpDoubleArrayResult
    {
        DoubleSeq returnValue;
        DoubleSeq outSeq;
    };

    virtual void opDoubleArrayAsync(::std::pair<const double*, const double*> inSeq, ::std::function<void(const DoubleSeq& returnValue, const DoubleSeq& outSeq)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opDoubleArray(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opBoolArray.
     */
    struct OpBoolArrayResult
    {
        BoolSeq returnValue;
        BoolSeq outSeq;
    };

    virtual void opBoolArrayAsync(::std::pair<const bool*, const bool*> inSeq, ::std::function<void(const BoolSeq& returnValue, const BoolSeq& outSeq)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opBoolArray(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opByteArray.
     */
    struct OpByteArrayResult
    {
        ByteList returnValue;
        ByteList outSeq;
    };

    virtual void opByteArrayAsync(::std::pair<const ::Ice::Byte*, const ::Ice::Byte*> inSeq, ::std::function<void(const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>& returnValue, const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>& outSeq)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opByteArray(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opVariableArray.
     */
    struct OpVariableArrayResult
    {
        VariableList returnValue;
        VariableList outSeq;
    };

    virtual void opVariableArrayAsync(::std::pair<const Variable*, const Variable*> inSeq, ::std::function<void(const VariableList& returnValue, const VariableList& outSeq)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opVariableArray(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opBoolRange.
     */
    struct OpBoolRangeResult
    {
        BoolSeq returnValue;
        BoolSeq outSeq;
    };

    virtual void opBoolRangeAsync(BoolSeq inSeq, ::std::function<void(const BoolSeq& returnValue, const BoolSeq& outSeq)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opBoolRange(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opByteRange.
     */
    struct OpByteRangeResult
    {
        ByteList returnValue;
        ByteList outSeq;
    };

    virtual void opByteRangeAsync(ByteList inSeq, ::std::function<void(const ByteList& returnValue, const ByteList& outSeq)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opByteRange(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opVariableRange.
     */
    struct OpVariableRangeResult
    {
        VariableList returnValue;
        VariableList outSeq;
    };

    virtual void opVariableRangeAsync(VariableList inSeq, ::std::function<void(const VariableList& returnValue, const VariableList& outSeq)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opVariableRange(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opByteRangeType.
     */
    struct OpByteRangeTypeResult
    {
        ByteList returnValue;
        ByteList outSeq;
    };

    virtual void opByteRangeTypeAsync(ByteList inSeq, ::std::function<void(const ByteList& returnValue, const ByteList& outSeq)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opByteRangeType(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opVariableRangeType.
     */
    struct OpVariableRangeTypeResult
    {
        VariableList returnValue;
        VariableList outSeq;
    };

    virtual void opVariableRangeTypeAsync(VariableList inSeq, ::std::function<void(const VariableList& returnValue, const VariableList& outSeq)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opVariableRangeType(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opBoolSeq.
     */
    struct OpBoolSeqResult
    {
        std::deque<bool> returnValue;
        std::deque<bool> outSeq;
    };

    virtual void opBoolSeqAsync(std::deque<bool> inSeq, ::std::function<void(const std::deque<bool>& returnValue, const std::deque<bool>& outSeq)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opBoolSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opBoolList.
     */
    struct OpBoolListResult
    {
        BoolList returnValue;
        BoolList outSeq;
    };

    virtual void opBoolListAsync(BoolList inSeq, ::std::function<void(const BoolList& returnValue, const BoolList& outSeq)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opBoolList(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opByteSeq.
     */
    struct OpByteSeqResult
    {
        std::deque< ::Ice::Byte> returnValue;
        std::deque< ::Ice::Byte> outSeq;
    };

    virtual void opByteSeqAsync(std::deque< ::Ice::Byte> inSeq, ::std::function<void(const std::deque< ::Ice::Byte>& returnValue, const std::deque< ::Ice::Byte>& outSeq)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opByteSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opByteList.
     */
    struct OpByteListResult
    {
        ByteList returnValue;
        ByteList outSeq;
    };

    virtual void opByteListAsync(ByteList inSeq, ::std::function<void(const ByteList& returnValue, const ByteList& outSeq)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opByteList(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opMyByteSeq.
     */
    struct OpMyByteSeqResult
    {
        MyByteSeq returnValue;
        MyByteSeq outSeq;
    };

    virtual void opMyByteSeqAsync(MyByteSeq inSeq, ::std::function<void(const MyByteSeq& returnValue, const MyByteSeq& outSeq)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opMyByteSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opString.
     */
    struct OpStringResult
    {
        ::std::string returnValue;
        ::std::string outString;
    };

    virtual void opStringAsync(Util::string_view inString, ::std::function<void(const Util::string_view& returnValue, const Util::string_view& outString)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opString(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opStringSeq.
     */
    struct OpStringSeqResult
    {
        std::deque<std::string> returnValue;
        std::deque<std::string> outSeq;
    };

    virtual void opStringSeqAsync(std::deque<std::string> inSeq, ::std::function<void(const std::deque<std::string>& returnValue, const std::deque<std::string>& outSeq)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opStringSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opStringList.
     */
    struct OpStringListResult
    {
        StringList returnValue;
        StringList outSeq;
    };

    virtual void opStringListAsync(StringList inSeq, ::std::function<void(const StringList& returnValue, const StringList& outSeq)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opStringList(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opFixedSeq.
     */
    struct OpFixedSeqResult
    {
        std::deque< ::Test::Fixed> returnValue;
        std::deque< ::Test::Fixed> outSeq;
    };

    virtual void opFixedSeqAsync(std::deque< ::Test::Fixed> inSeq, ::std::function<void(const std::deque< ::Test::Fixed>& returnValue, const std::deque< ::Test::Fixed>& outSeq)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opFixedSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opFixedList.
     */
    struct OpFixedListResult
    {
        FixedList returnValue;
        FixedList outSeq;
    };

    virtual void opFixedListAsync(FixedList inSeq, ::std::function<void(const FixedList& returnValue, const FixedList& outSeq)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opFixedList(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opVariableSeq.
     */
    struct OpVariableSeqResult
    {
        std::deque< ::Test::Variable> returnValue;
        std::deque< ::Test::Variable> outSeq;
    };

    virtual void opVariableSeqAsync(std::deque< ::Test::Variable> inSeq, ::std::function<void(const std::deque< ::Test::Variable>& returnValue, const std::deque< ::Test::Variable>& outSeq)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opVariableSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opVariableList.
     */
    struct OpVariableListResult
    {
        VariableList returnValue;
        VariableList outSeq;
    };

    virtual void opVariableListAsync(VariableList inSeq, ::std::function<void(const VariableList& returnValue, const VariableList& outSeq)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opVariableList(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opStringStringDictSeq.
     */
    struct OpStringStringDictSeqResult
    {
        std::deque< ::Test::StringStringDict> returnValue;
        std::deque< ::Test::StringStringDict> outSeq;
    };

    virtual void opStringStringDictSeqAsync(std::deque< ::Test::StringStringDict> inSeq, ::std::function<void(const std::deque< ::Test::StringStringDict>& returnValue, const std::deque< ::Test::StringStringDict>& outSeq)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opStringStringDictSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opStringStringDictList.
     */
    struct OpStringStringDictListResult
    {
        StringStringDictList returnValue;
        StringStringDictList outSeq;
    };

    virtual void opStringStringDictListAsync(StringStringDictList inSeq, ::std::function<void(const StringStringDictList& returnValue, const StringStringDictList& outSeq)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opStringStringDictList(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opESeq.
     */
    struct OpESeqResult
    {
        std::deque< ::Test::E> returnValue;
        std::deque< ::Test::E> outSeq;
    };

    virtual void opESeqAsync(std::deque< ::Test::E> inSeq, ::std::function<void(const std::deque< ::Test::E>& returnValue, const std::deque< ::Test::E>& outSeq)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opESeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opEList.
     */
    struct OpEListResult
    {
        EList returnValue;
        EList outSeq;
    };

    virtual void opEListAsync(EList inSeq, ::std::function<void(const EList& returnValue, const EList& outSeq)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opEList(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opDPrxSeq.
     */
    struct OpDPrxSeqResult
    {
        std::deque<std::shared_ptr<::Test::DPrx>> returnValue;
        std::deque<std::shared_ptr<::Test::DPrx>> outSeq;
    };

    virtual void opDPrxSeqAsync(std::deque<std::shared_ptr<::Test::DPrx>> inSeq, ::std::function<void(const std::deque<std::shared_ptr<::Test::DPrx>>& returnValue, const std::deque<std::shared_ptr<::Test::DPrx>>& outSeq)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opDPrxSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opDPrxList.
     */
    struct OpDPrxListResult
    {
        DPrxList returnValue;
        DPrxList outSeq;
    };

    virtual void opDPrxListAsync(DPrxList inSeq, ::std::function<void(const DPrxList& returnValue, const DPrxList& outSeq)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opDPrxList(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opCSeq.
     */
    struct OpCSeqResult
    {
        std::deque<std::shared_ptr<Test::C>> returnValue;
        std::deque<std::shared_ptr<Test::C>> outSeq;
    };

    virtual void opCSeqAsync(std::deque<std::shared_ptr<Test::C>> inSeq, ::std::function<void(const std::deque<std::shared_ptr<Test::C>>& returnValue, const std::deque<std::shared_ptr<Test::C>>& outSeq)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opCSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opCList.
     */
    struct OpCListResult
    {
        CList returnValue;
        CList outSeq;
    };

    virtual void opCListAsync(CList inSeq, ::std::function<void(const CList& returnValue, const CList& outSeq)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opCList(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opClassStruct.
     */
    struct OpClassStructResult
    {
        ClassStruct returnValue;
        ClassStruct outS;
        ClassStructSeq outSeq;
    };

    virtual void opClassStructAsync(ClassStruct inS, ClassStructSeq inSeq, ::std::function<void(const ClassStruct& returnValue, const ClassStruct& outS, const ClassStructSeq& outSeq)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opClassStruct(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opOutArrayByteSeqAsync(ByteSeq org, ::std::function<void(const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>& copy)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opOutArrayByteSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opOutRangeByteSeqAsync(ByteSeq org, ::std::function<void(const ByteSeq& copy)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opOutRangeByteSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opIntStringDict.
     */
    struct OpIntStringDictResult
    {
        IntStringDict returnValue;
        IntStringDict odict;
    };

    virtual void opIntStringDictAsync(IntStringDict idict, ::std::function<void(const IntStringDict& returnValue, const IntStringDict& odict)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opIntStringDict(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opVarDict.
     */
    struct OpVarDictResult
    {
        ::Test::CustomMap< ::Ice::Long, ::Ice::Long> returnValue;
        ::Test::CustomMap<std::string, ::Ice::Int> odict;
    };

    virtual void opVarDictAsync(::Test::CustomMap<std::string, ::Ice::Int> idict, ::std::function<void(const ::Test::CustomMap< ::Ice::Long, ::Ice::Long>& returnValue, const ::Test::CustomMap<std::string, ::Ice::Int>& odict)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opVarDict(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opCustomIntStringDict.
     */
    struct OpCustomIntStringDictResult
    {
        ::Test::CustomMap< ::Ice::Int, std::string> returnValue;
        ::Test::CustomMap< ::Ice::Int, std::string> odict;
    };

    virtual void opCustomIntStringDictAsync(::std::map< ::Ice::Int, ::Util::string_view> idict, ::std::function<void(const ::std::map< ::Ice::Int, ::Util::string_view>& returnValue, const ::std::map< ::Ice::Int, ::Util::string_view>& odict)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opCustomIntStringDict(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opShortBuffer.
     */
    struct OpShortBufferResult
    {
        ShortBuffer returnValue;
        ShortBuffer outS;
    };

    virtual void opShortBufferAsync(ShortBuffer inS, ::std::function<void(const ShortBuffer& returnValue, const ShortBuffer& outS)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opShortBuffer(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opBoolBuffer.
     */
    struct OpBoolBufferResult
    {
        ::Test::CustomBuffer<bool> returnValue;
        ::Test::CustomBuffer<bool> outS;
    };

    virtual void opBoolBufferAsync(::Test::CustomBuffer<bool> inS, ::std::function<void(const ::Test::CustomBuffer<bool>& returnValue, const ::Test::CustomBuffer<bool>& outS)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opBoolBuffer(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opBufferStructAsync(BufferStruct s, ::std::function<void(const BufferStruct& returnValue)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opBufferStruct(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void shutdownAsync(::std::function<void()> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_shutdown(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

}

namespace Test
{

class C : public ::Ice::ValueHelper<C, ::Ice::Value>
{
public:

    virtual ~C();

    C() = default;

    C(const C&) = default;
    C(C&&) = default;
    C& operator=(const C&) = default;
    C& operator=(C&&) = default;

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<> ice_tuple() const
    {
        return std::tie();
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();
};

/// \cond INTERNAL
static C _iceS_C_init;
/// \endcond

class DictClass : public ::Ice::ValueHelper<DictClass, ::Ice::Value>
{
public:

    virtual ~DictClass();

    DictClass() = default;

    DictClass(const DictClass&) = default;
    DictClass(DictClass&&) = default;
    DictClass& operator=(const DictClass&) = default;
    DictClass& operator=(DictClass&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit DictClass(const ::Test::IntStringDict& isdict) :
        isdict(isdict)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::Test::IntStringDict&> ice_tuple() const
    {
        return std::tie(isdict);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::Test::IntStringDict isdict;
};

}

namespace Test
{

class DPrx : public virtual ::Ice::Proxy<DPrx, ::Ice::ObjectPrx>
{
public:

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    DPrx() = default;
    friend ::std::shared_ptr<DPrx> IceInternal::createProxy<DPrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

class TestIntfPrx : public virtual ::Ice::Proxy<TestIntfPrx, ::Ice::ObjectPrx>
{
public:

    DoubleSeq opDoubleArray(const ::std::pair<const double*, const double*>& inSeq, DoubleSeq& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpDoubleArrayResult>(true, this, &TestIntfPrx::_iceI_opDoubleArray, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opDoubleArrayAsync(const ::std::pair<const double*, const double*>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpDoubleArrayResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpDoubleArrayResult, P>(false, this, &TestIntfPrx::_iceI_opDoubleArray, inSeq, context);
    }

    ::std::function<void()>
    opDoubleArrayAsync(const ::std::pair<const double*, const double*>& inSeq,
                       ::std::function<void(::Test::DoubleSeq, ::Test::DoubleSeq)> response,
                       ::std::function<void(::std::exception_ptr)> ex = nullptr,
                       ::std::function<void(bool)> sent = nullptr,
                       const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpDoubleArrayResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpDoubleArrayResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opDoubleArray, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opDoubleArray(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpDoubleArrayResult>>&, const ::std::pair<const double*, const double*>&, const ::Ice::Context&);
    /// \endcond

    BoolSeq opBoolArray(const ::std::pair<const bool*, const bool*>& inSeq, BoolSeq& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpBoolArrayResult>(true, this, &TestIntfPrx::_iceI_opBoolArray, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opBoolArrayAsync(const ::std::pair<const bool*, const bool*>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpBoolArrayResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpBoolArrayResult, P>(false, this, &TestIntfPrx::_iceI_opBoolArray, inSeq, context);
    }

    ::std::function<void()>
    opBoolArrayAsync(const ::std::pair<const bool*, const bool*>& inSeq,
                     ::std::function<void(::Test::BoolSeq, ::Test::BoolSeq)> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpBoolArrayResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpBoolArrayResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opBoolArray, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opBoolArray(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpBoolArrayResult>>&, const ::std::pair<const bool*, const bool*>&, const ::Ice::Context&);
    /// \endcond

    ByteList opByteArray(const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>& inSeq, ByteList& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpByteArrayResult>(true, this, &TestIntfPrx::_iceI_opByteArray, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opByteArrayAsync(const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpByteArrayResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpByteArrayResult, P>(false, this, &TestIntfPrx::_iceI_opByteArray, inSeq, context);
    }

    ::std::function<void()>
    opByteArrayAsync(const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>& inSeq,
                     ::std::function<void(::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>, ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>)> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext);

    /// \cond INTERNAL
    void _iceI_opByteArray(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpByteArrayResult>>&, const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>&, const ::Ice::Context&);
    /// \endcond

    VariableList opVariableArray(const ::std::pair<const Variable*, const Variable*>& inSeq, VariableList& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpVariableArrayResult>(true, this, &TestIntfPrx::_iceI_opVariableArray, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opVariableArrayAsync(const ::std::pair<const Variable*, const Variable*>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpVariableArrayResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpVariableArrayResult, P>(false, this, &TestIntfPrx::_iceI_opVariableArray, inSeq, context);
    }

    ::std::function<void()>
    opVariableArrayAsync(const ::std::pair<const Variable*, const Variable*>& inSeq,
                         ::std::function<void(::Test::VariableList, ::Test::VariableList)> response,
                         ::std::function<void(::std::exception_ptr)> ex = nullptr,
                         ::std::function<void(bool)> sent = nullptr,
                         const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpVariableArrayResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpVariableArrayResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opVariableArray, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opVariableArray(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpVariableArrayResult>>&, const ::std::pair<const Variable*, const Variable*>&, const ::Ice::Context&);
    /// \endcond

    BoolSeq opBoolRange(const BoolSeq& inSeq, BoolSeq& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpBoolRangeResult>(true, this, &TestIntfPrx::_iceI_opBoolRange, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opBoolRangeAsync(const BoolSeq& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpBoolRangeResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpBoolRangeResult, P>(false, this, &TestIntfPrx::_iceI_opBoolRange, inSeq, context);
    }

    ::std::function<void()>
    opBoolRangeAsync(const BoolSeq& inSeq,
                     ::std::function<void(::Test::BoolSeq, ::Test::BoolSeq)> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpBoolRangeResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpBoolRangeResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opBoolRange, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opBoolRange(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpBoolRangeResult>>&, const BoolSeq&, const ::Ice::Context&);
    /// \endcond

    ByteList opByteRange(const ByteList& inSeq, ByteList& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpByteRangeResult>(true, this, &TestIntfPrx::_iceI_opByteRange, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opByteRangeAsync(const ByteList& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpByteRangeResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpByteRangeResult, P>(false, this, &TestIntfPrx::_iceI_opByteRange, inSeq, context);
    }

    ::std::function<void()>
    opByteRangeAsync(const ByteList& inSeq,
                     ::std::function<void(::Test::ByteList, ::Test::ByteList)> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpByteRangeResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpByteRangeResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opByteRange, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opByteRange(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpByteRangeResult>>&, const ByteList&, const ::Ice::Context&);
    /// \endcond

    VariableList opVariableRange(const VariableList& inSeq, VariableList& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpVariableRangeResult>(true, this, &TestIntfPrx::_iceI_opVariableRange, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opVariableRangeAsync(const VariableList& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpVariableRangeResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpVariableRangeResult, P>(false, this, &TestIntfPrx::_iceI_opVariableRange, inSeq, context);
    }

    ::std::function<void()>
    opVariableRangeAsync(const VariableList& inSeq,
                         ::std::function<void(::Test::VariableList, ::Test::VariableList)> response,
                         ::std::function<void(::std::exception_ptr)> ex = nullptr,
                         ::std::function<void(bool)> sent = nullptr,
                         const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpVariableRangeResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpVariableRangeResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opVariableRange, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opVariableRange(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpVariableRangeResult>>&, const VariableList&, const ::Ice::Context&);
    /// \endcond

    ByteList opByteRangeType(const ByteList& inSeq, ByteList& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpByteRangeTypeResult>(true, this, &TestIntfPrx::_iceI_opByteRangeType, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opByteRangeTypeAsync(const ByteList& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpByteRangeTypeResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpByteRangeTypeResult, P>(false, this, &TestIntfPrx::_iceI_opByteRangeType, inSeq, context);
    }

    ::std::function<void()>
    opByteRangeTypeAsync(const ByteList& inSeq,
                         ::std::function<void(::Test::ByteList, ::Test::ByteList)> response,
                         ::std::function<void(::std::exception_ptr)> ex = nullptr,
                         ::std::function<void(bool)> sent = nullptr,
                         const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpByteRangeTypeResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpByteRangeTypeResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opByteRangeType, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opByteRangeType(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpByteRangeTypeResult>>&, const ByteList&, const ::Ice::Context&);
    /// \endcond

    VariableList opVariableRangeType(const VariableList& inSeq, VariableList& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpVariableRangeTypeResult>(true, this, &TestIntfPrx::_iceI_opVariableRangeType, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opVariableRangeTypeAsync(const VariableList& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpVariableRangeTypeResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpVariableRangeTypeResult, P>(false, this, &TestIntfPrx::_iceI_opVariableRangeType, inSeq, context);
    }

    ::std::function<void()>
    opVariableRangeTypeAsync(const VariableList& inSeq,
                             ::std::function<void(::Test::VariableList, ::Test::VariableList)> response,
                             ::std::function<void(::std::exception_ptr)> ex = nullptr,
                             ::std::function<void(bool)> sent = nullptr,
                             const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpVariableRangeTypeResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpVariableRangeTypeResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opVariableRangeType, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opVariableRangeType(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpVariableRangeTypeResult>>&, const VariableList&, const ::Ice::Context&);
    /// \endcond

    std::deque<bool> opBoolSeq(const std::deque<bool>& inSeq, std::deque<bool>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpBoolSeqResult>(true, this, &TestIntfPrx::_iceI_opBoolSeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opBoolSeqAsync(const std::deque<bool>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpBoolSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpBoolSeqResult, P>(false, this, &TestIntfPrx::_iceI_opBoolSeq, inSeq, context);
    }

    ::std::function<void()>
    opBoolSeqAsync(const std::deque<bool>& inSeq,
                   ::std::function<void(std::deque<bool>, std::deque<bool>)> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpBoolSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpBoolSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opBoolSeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opBoolSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpBoolSeqResult>>&, const std::deque<bool>&, const ::Ice::Context&);
    /// \endcond

    BoolList opBoolList(const BoolList& inSeq, BoolList& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpBoolListResult>(true, this, &TestIntfPrx::_iceI_opBoolList, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opBoolListAsync(const BoolList& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpBoolListResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpBoolListResult, P>(false, this, &TestIntfPrx::_iceI_opBoolList, inSeq, context);
    }

    ::std::function<void()>
    opBoolListAsync(const BoolList& inSeq,
                    ::std::function<void(::Test::BoolList, ::Test::BoolList)> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpBoolListResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpBoolListResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opBoolList, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opBoolList(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpBoolListResult>>&, const BoolList&, const ::Ice::Context&);
    /// \endcond

    std::deque< ::Ice::Byte> opByteSeq(const std::deque< ::Ice::Byte>& inSeq, std::deque< ::Ice::Byte>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpByteSeqResult>(true, this, &TestIntfPrx::_iceI_opByteSeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opByteSeqAsync(const std::deque< ::Ice::Byte>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpByteSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpByteSeqResult, P>(false, this, &TestIntfPrx::_iceI_opByteSeq, inSeq, context);
    }

    ::std::function<void()>
    opByteSeqAsync(const std::deque< ::Ice::Byte>& inSeq,
                   ::std::function<void(std::deque< ::Ice::Byte>, std::deque< ::Ice::Byte>)> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpByteSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpByteSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opByteSeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opByteSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpByteSeqResult>>&, const std::deque< ::Ice::Byte>&, const ::Ice::Context&);
    /// \endcond

    ByteList opByteList(const ByteList& inSeq, ByteList& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpByteListResult>(true, this, &TestIntfPrx::_iceI_opByteList, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opByteListAsync(const ByteList& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpByteListResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpByteListResult, P>(false, this, &TestIntfPrx::_iceI_opByteList, inSeq, context);
    }

    ::std::function<void()>
    opByteListAsync(const ByteList& inSeq,
                    ::std::function<void(::Test::ByteList, ::Test::ByteList)> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpByteListResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpByteListResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opByteList, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opByteList(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpByteListResult>>&, const ByteList&, const ::Ice::Context&);
    /// \endcond

    MyByteSeq opMyByteSeq(const MyByteSeq& inSeq, MyByteSeq& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpMyByteSeqResult>(true, this, &TestIntfPrx::_iceI_opMyByteSeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opMyByteSeqAsync(const MyByteSeq& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpMyByteSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpMyByteSeqResult, P>(false, this, &TestIntfPrx::_iceI_opMyByteSeq, inSeq, context);
    }

    ::std::function<void()>
    opMyByteSeqAsync(const MyByteSeq& inSeq,
                     ::std::function<void(MyByteSeq, MyByteSeq)> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpMyByteSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpMyByteSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opMyByteSeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opMyByteSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpMyByteSeqResult>>&, const MyByteSeq&, const ::Ice::Context&);
    /// \endcond

    ::std::string opString(const Util::string_view& inString, ::std::string& outString, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpStringResult>(true, this, &TestIntfPrx::_iceI_opString, inString, context).get();
        outString = ::std::move(_result.outString);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opStringAsync(const Util::string_view& inString, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpStringResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpStringResult, P>(false, this, &TestIntfPrx::_iceI_opString, inString, context);
    }

    ::std::function<void()>
    opStringAsync(const Util::string_view& inString,
                  ::std::function<void(Util::string_view, Util::string_view)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext);

    /// \cond INTERNAL
    void _iceI_opString(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpStringResult>>&, const Util::string_view&, const ::Ice::Context&);
    /// \endcond

    std::deque<std::string> opStringSeq(const std::deque<std::string>& inSeq, std::deque<std::string>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpStringSeqResult>(true, this, &TestIntfPrx::_iceI_opStringSeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opStringSeqAsync(const std::deque<std::string>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpStringSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpStringSeqResult, P>(false, this, &TestIntfPrx::_iceI_opStringSeq, inSeq, context);
    }

    ::std::function<void()>
    opStringSeqAsync(const std::deque<std::string>& inSeq,
                     ::std::function<void(std::deque<std::string>, std::deque<std::string>)> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpStringSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpStringSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opStringSeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opStringSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpStringSeqResult>>&, const std::deque<std::string>&, const ::Ice::Context&);
    /// \endcond

    StringList opStringList(const StringList& inSeq, StringList& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpStringListResult>(true, this, &TestIntfPrx::_iceI_opStringList, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opStringListAsync(const StringList& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpStringListResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpStringListResult, P>(false, this, &TestIntfPrx::_iceI_opStringList, inSeq, context);
    }

    ::std::function<void()>
    opStringListAsync(const StringList& inSeq,
                      ::std::function<void(::Test::StringList, ::Test::StringList)> response,
                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                      ::std::function<void(bool)> sent = nullptr,
                      const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpStringListResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpStringListResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opStringList, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opStringList(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpStringListResult>>&, const StringList&, const ::Ice::Context&);
    /// \endcond

    std::deque< ::Test::Fixed> opFixedSeq(const std::deque< ::Test::Fixed>& inSeq, std::deque< ::Test::Fixed>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpFixedSeqResult>(true, this, &TestIntfPrx::_iceI_opFixedSeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opFixedSeqAsync(const std::deque< ::Test::Fixed>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpFixedSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpFixedSeqResult, P>(false, this, &TestIntfPrx::_iceI_opFixedSeq, inSeq, context);
    }

    ::std::function<void()>
    opFixedSeqAsync(const std::deque< ::Test::Fixed>& inSeq,
                    ::std::function<void(std::deque< ::Test::Fixed>, std::deque< ::Test::Fixed>)> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpFixedSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpFixedSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opFixedSeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opFixedSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpFixedSeqResult>>&, const std::deque< ::Test::Fixed>&, const ::Ice::Context&);
    /// \endcond

    FixedList opFixedList(const FixedList& inSeq, FixedList& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpFixedListResult>(true, this, &TestIntfPrx::_iceI_opFixedList, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opFixedListAsync(const FixedList& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpFixedListResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpFixedListResult, P>(false, this, &TestIntfPrx::_iceI_opFixedList, inSeq, context);
    }

    ::std::function<void()>
    opFixedListAsync(const FixedList& inSeq,
                     ::std::function<void(::Test::FixedList, ::Test::FixedList)> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpFixedListResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpFixedListResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opFixedList, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opFixedList(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpFixedListResult>>&, const FixedList&, const ::Ice::Context&);
    /// \endcond

    std::deque< ::Test::Variable> opVariableSeq(const std::deque< ::Test::Variable>& inSeq, std::deque< ::Test::Variable>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpVariableSeqResult>(true, this, &TestIntfPrx::_iceI_opVariableSeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opVariableSeqAsync(const std::deque< ::Test::Variable>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpVariableSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpVariableSeqResult, P>(false, this, &TestIntfPrx::_iceI_opVariableSeq, inSeq, context);
    }

    ::std::function<void()>
    opVariableSeqAsync(const std::deque< ::Test::Variable>& inSeq,
                       ::std::function<void(std::deque< ::Test::Variable>, std::deque< ::Test::Variable>)> response,
                       ::std::function<void(::std::exception_ptr)> ex = nullptr,
                       ::std::function<void(bool)> sent = nullptr,
                       const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpVariableSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpVariableSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opVariableSeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opVariableSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpVariableSeqResult>>&, const std::deque< ::Test::Variable>&, const ::Ice::Context&);
    /// \endcond

    VariableList opVariableList(const VariableList& inSeq, VariableList& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpVariableListResult>(true, this, &TestIntfPrx::_iceI_opVariableList, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opVariableListAsync(const VariableList& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpVariableListResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpVariableListResult, P>(false, this, &TestIntfPrx::_iceI_opVariableList, inSeq, context);
    }

    ::std::function<void()>
    opVariableListAsync(const VariableList& inSeq,
                        ::std::function<void(::Test::VariableList, ::Test::VariableList)> response,
                        ::std::function<void(::std::exception_ptr)> ex = nullptr,
                        ::std::function<void(bool)> sent = nullptr,
                        const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpVariableListResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpVariableListResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opVariableList, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opVariableList(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpVariableListResult>>&, const VariableList&, const ::Ice::Context&);
    /// \endcond

    std::deque< ::Test::StringStringDict> opStringStringDictSeq(const std::deque< ::Test::StringStringDict>& inSeq, std::deque< ::Test::StringStringDict>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpStringStringDictSeqResult>(true, this, &TestIntfPrx::_iceI_opStringStringDictSeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opStringStringDictSeqAsync(const std::deque< ::Test::StringStringDict>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpStringStringDictSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpStringStringDictSeqResult, P>(false, this, &TestIntfPrx::_iceI_opStringStringDictSeq, inSeq, context);
    }

    ::std::function<void()>
    opStringStringDictSeqAsync(const std::deque< ::Test::StringStringDict>& inSeq,
                               ::std::function<void(std::deque< ::Test::StringStringDict>, std::deque< ::Test::StringStringDict>)> response,
                               ::std::function<void(::std::exception_ptr)> ex = nullptr,
                               ::std::function<void(bool)> sent = nullptr,
                               const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpStringStringDictSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpStringStringDictSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opStringStringDictSeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opStringStringDictSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpStringStringDictSeqResult>>&, const std::deque< ::Test::StringStringDict>&, const ::Ice::Context&);
    /// \endcond

    StringStringDictList opStringStringDictList(const StringStringDictList& inSeq, StringStringDictList& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpStringStringDictListResult>(true, this, &TestIntfPrx::_iceI_opStringStringDictList, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opStringStringDictListAsync(const StringStringDictList& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpStringStringDictListResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpStringStringDictListResult, P>(false, this, &TestIntfPrx::_iceI_opStringStringDictList, inSeq, context);
    }

    ::std::function<void()>
    opStringStringDictListAsync(const StringStringDictList& inSeq,
                                ::std::function<void(::Test::StringStringDictList, ::Test::StringStringDictList)> response,
                                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                                ::std::function<void(bool)> sent = nullptr,
                                const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpStringStringDictListResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpStringStringDictListResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opStringStringDictList, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opStringStringDictList(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpStringStringDictListResult>>&, const StringStringDictList&, const ::Ice::Context&);
    /// \endcond

    std::deque< ::Test::E> opESeq(const std::deque< ::Test::E>& inSeq, std::deque< ::Test::E>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpESeqResult>(true, this, &TestIntfPrx::_iceI_opESeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opESeqAsync(const std::deque< ::Test::E>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpESeqResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpESeqResult, P>(false, this, &TestIntfPrx::_iceI_opESeq, inSeq, context);
    }

    ::std::function<void()>
    opESeqAsync(const std::deque< ::Test::E>& inSeq,
                ::std::function<void(std::deque< ::Test::E>, std::deque< ::Test::E>)> response,
                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                ::std::function<void(bool)> sent = nullptr,
                const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpESeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpESeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opESeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opESeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpESeqResult>>&, const std::deque< ::Test::E>&, const ::Ice::Context&);
    /// \endcond

    EList opEList(const EList& inSeq, EList& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpEListResult>(true, this, &TestIntfPrx::_iceI_opEList, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opEListAsync(const EList& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpEListResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpEListResult, P>(false, this, &TestIntfPrx::_iceI_opEList, inSeq, context);
    }

    ::std::function<void()>
    opEListAsync(const EList& inSeq,
                 ::std::function<void(::Test::EList, ::Test::EList)> response,
                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                 ::std::function<void(bool)> sent = nullptr,
                 const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpEListResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpEListResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opEList, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opEList(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpEListResult>>&, const EList&, const ::Ice::Context&);
    /// \endcond

    std::deque<std::shared_ptr<::Test::DPrx>> opDPrxSeq(const std::deque<std::shared_ptr<::Test::DPrx>>& inSeq, std::deque<std::shared_ptr<::Test::DPrx>>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpDPrxSeqResult>(true, this, &TestIntfPrx::_iceI_opDPrxSeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opDPrxSeqAsync(const std::deque<std::shared_ptr<::Test::DPrx>>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpDPrxSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpDPrxSeqResult, P>(false, this, &TestIntfPrx::_iceI_opDPrxSeq, inSeq, context);
    }

    ::std::function<void()>
    opDPrxSeqAsync(const std::deque<std::shared_ptr<::Test::DPrx>>& inSeq,
                   ::std::function<void(std::deque<std::shared_ptr<::Test::DPrx>>, std::deque<std::shared_ptr<::Test::DPrx>>)> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpDPrxSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpDPrxSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opDPrxSeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opDPrxSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpDPrxSeqResult>>&, const std::deque<std::shared_ptr<::Test::DPrx>>&, const ::Ice::Context&);
    /// \endcond

    DPrxList opDPrxList(const DPrxList& inSeq, DPrxList& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpDPrxListResult>(true, this, &TestIntfPrx::_iceI_opDPrxList, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opDPrxListAsync(const DPrxList& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpDPrxListResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpDPrxListResult, P>(false, this, &TestIntfPrx::_iceI_opDPrxList, inSeq, context);
    }

    ::std::function<void()>
    opDPrxListAsync(const DPrxList& inSeq,
                    ::std::function<void(::Test::DPrxList, ::Test::DPrxList)> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpDPrxListResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpDPrxListResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opDPrxList, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opDPrxList(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpDPrxListResult>>&, const DPrxList&, const ::Ice::Context&);
    /// \endcond

    std::deque<std::shared_ptr<Test::C>> opCSeq(const std::deque<std::shared_ptr<Test::C>>& inSeq, std::deque<std::shared_ptr<Test::C>>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpCSeqResult>(true, this, &TestIntfPrx::_iceI_opCSeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opCSeqAsync(const std::deque<std::shared_ptr<Test::C>>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpCSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpCSeqResult, P>(false, this, &TestIntfPrx::_iceI_opCSeq, inSeq, context);
    }

    ::std::function<void()>
    opCSeqAsync(const std::deque<std::shared_ptr<Test::C>>& inSeq,
                ::std::function<void(std::deque<std::shared_ptr<Test::C>>, std::deque<std::shared_ptr<Test::C>>)> response,
                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                ::std::function<void(bool)> sent = nullptr,
                const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpCSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpCSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opCSeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opCSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpCSeqResult>>&, const std::deque<std::shared_ptr<Test::C>>&, const ::Ice::Context&);
    /// \endcond

    CList opCList(const CList& inSeq, CList& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpCListResult>(true, this, &TestIntfPrx::_iceI_opCList, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opCListAsync(const CList& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpCListResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpCListResult, P>(false, this, &TestIntfPrx::_iceI_opCList, inSeq, context);
    }

    ::std::function<void()>
    opCListAsync(const CList& inSeq,
                 ::std::function<void(::Test::CList, ::Test::CList)> response,
                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                 ::std::function<void(bool)> sent = nullptr,
                 const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpCListResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpCListResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opCList, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opCList(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpCListResult>>&, const CList&, const ::Ice::Context&);
    /// \endcond

    ClassStruct opClassStruct(const ClassStruct& inS, const ClassStructSeq& inSeq, ClassStruct& outS, ClassStructSeq& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpClassStructResult>(true, this, &TestIntfPrx::_iceI_opClassStruct, inS, inSeq, context).get();
        outS = ::std::move(_result.outS);
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opClassStructAsync(const ClassStruct& inS, const ClassStructSeq& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpClassStructResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpClassStructResult, P>(false, this, &TestIntfPrx::_iceI_opClassStruct, inS, inSeq, context);
    }

    ::std::function<void()>
    opClassStructAsync(const ClassStruct& inS, const ClassStructSeq& inSeq,
                       ::std::function<void(::Test::ClassStruct, ::Test::ClassStruct, ::Test::ClassStructSeq)> response,
                       ::std::function<void(::std::exception_ptr)> ex = nullptr,
                       ::std::function<void(bool)> sent = nullptr,
                       const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpClassStructResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outS), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpClassStructResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opClassStruct, inS, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opClassStruct(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpClassStructResult>>&, const ClassStruct&, const ClassStructSeq&, const ::Ice::Context&);
    /// \endcond

    void opOutArrayByteSeq(const ByteSeq& org, ByteSeq& copy, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        copy = _makePromiseOutgoing<::Test::ByteSeq>(true, this, &TestIntfPrx::_iceI_opOutArrayByteSeq, org, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto opOutArrayByteSeqAsync(const ByteSeq& org, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::Test::ByteSeq>>().get_future())
    {
        return _makePromiseOutgoing<::Test::ByteSeq, P>(false, this, &TestIntfPrx::_iceI_opOutArrayByteSeq, org, context);
    }

    ::std::function<void()>
    opOutArrayByteSeqAsync(const ByteSeq& org,
                           ::std::function<void(::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>)> response,
                           ::std::function<void(::std::exception_ptr)> ex = nullptr,
                           ::std::function<void(bool)> sent = nullptr,
                           const ::Ice::Context& context = ::Ice::noExplicitContext);

    /// \cond INTERNAL
    void _iceI_opOutArrayByteSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::Test::ByteSeq>>&, const ByteSeq&, const ::Ice::Context&);
    /// \endcond

    void opOutRangeByteSeq(const ByteSeq& org, ByteSeq& copy, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        copy = _makePromiseOutgoing<::Test::ByteSeq>(true, this, &TestIntfPrx::_iceI_opOutRangeByteSeq, org, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto opOutRangeByteSeqAsync(const ByteSeq& org, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::Test::ByteSeq>>().get_future())
    {
        return _makePromiseOutgoing<::Test::ByteSeq, P>(false, this, &TestIntfPrx::_iceI_opOutRangeByteSeq, org, context);
    }

    ::std::function<void()>
    opOutRangeByteSeqAsync(const ByteSeq& org,
                           ::std::function<void(::Test::ByteSeq)> response,
                           ::std::function<void(::std::exception_ptr)> ex = nullptr,
                           ::std::function<void(bool)> sent = nullptr,
                           const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<::Test::ByteSeq>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opOutRangeByteSeq, org, context);
    }

    /// \cond INTERNAL
    void _iceI_opOutRangeByteSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::Test::ByteSeq>>&, const ByteSeq&, const ::Ice::Context&);
    /// \endcond

    IntStringDict opIntStringDict(const IntStringDict& idict, IntStringDict& odict, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpIntStringDictResult>(true, this, &TestIntfPrx::_iceI_opIntStringDict, idict, context).get();
        odict = ::std::move(_result.odict);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opIntStringDictAsync(const IntStringDict& idict, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpIntStringDictResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpIntStringDictResult, P>(false, this, &TestIntfPrx::_iceI_opIntStringDict, idict, context);
    }

    ::std::function<void()>
    opIntStringDictAsync(const IntStringDict& idict,
                         ::std::function<void(::Test::IntStringDict, ::Test::IntStringDict)> response,
                         ::std::function<void(::std::exception_ptr)> ex = nullptr,
                         ::std::function<void(bool)> sent = nullptr,
                         const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpIntStringDictResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.odict));
        };
        return _makeLambdaOutgoing<TestIntf::OpIntStringDictResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opIntStringDict, idict, context);
    }

    /// \cond INTERNAL
    void _iceI_opIntStringDict(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpIntStringDictResult>>&, const IntStringDict&, const ::Ice::Context&);
    /// \endcond

    ::Test::CustomMap< ::Ice::Long, ::Ice::Long> opVarDict(const ::Test::CustomMap<std::string, ::Ice::Int>& idict, ::Test::CustomMap<std::string, ::Ice::Int>& odict, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpVarDictResult>(true, this, &TestIntfPrx::_iceI_opVarDict, idict, context).get();
        odict = ::std::move(_result.odict);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opVarDictAsync(const ::Test::CustomMap<std::string, ::Ice::Int>& idict, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpVarDictResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpVarDictResult, P>(false, this, &TestIntfPrx::_iceI_opVarDict, idict, context);
    }

    ::std::function<void()>
    opVarDictAsync(const ::Test::CustomMap<std::string, ::Ice::Int>& idict,
                   ::std::function<void(::Test::CustomMap< ::Ice::Long, ::Ice::Long>, ::Test::CustomMap<std::string, ::Ice::Int>)> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpVarDictResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.odict));
        };
        return _makeLambdaOutgoing<TestIntf::OpVarDictResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opVarDict, idict, context);
    }

    /// \cond INTERNAL
    void _iceI_opVarDict(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpVarDictResult>>&, const ::Test::CustomMap<std::string, ::Ice::Int>&, const ::Ice::Context&);
    /// \endcond

    ::Test::CustomMap< ::Ice::Int, std::string> opCustomIntStringDict(const ::std::map< ::Ice::Int, ::Util::string_view>& idict, ::Test::CustomMap< ::Ice::Int, std::string>& odict, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpCustomIntStringDictResult>(true, this, &TestIntfPrx::_iceI_opCustomIntStringDict, idict, context).get();
        odict = ::std::move(_result.odict);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opCustomIntStringDictAsync(const ::std::map< ::Ice::Int, ::Util::string_view>& idict, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpCustomIntStringDictResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpCustomIntStringDictResult, P>(false, this, &TestIntfPrx::_iceI_opCustomIntStringDict, idict, context);
    }

    ::std::function<void()>
    opCustomIntStringDictAsync(const ::std::map< ::Ice::Int, ::Util::string_view>& idict,
                               ::std::function<void(::std::map< ::Ice::Int, ::Util::string_view>, ::std::map< ::Ice::Int, ::Util::string_view>)> response,
                               ::std::function<void(::std::exception_ptr)> ex = nullptr,
                               ::std::function<void(bool)> sent = nullptr,
                               const ::Ice::Context& context = ::Ice::noExplicitContext);

    /// \cond INTERNAL
    void _iceI_opCustomIntStringDict(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpCustomIntStringDictResult>>&, const ::std::map< ::Ice::Int, ::Util::string_view>&, const ::Ice::Context&);
    /// \endcond

    ShortBuffer opShortBuffer(const ShortBuffer& inS, ShortBuffer& outS, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpShortBufferResult>(true, this, &TestIntfPrx::_iceI_opShortBuffer, inS, context).get();
        outS = ::std::move(_result.outS);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opShortBufferAsync(const ShortBuffer& inS, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpShortBufferResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpShortBufferResult, P>(false, this, &TestIntfPrx::_iceI_opShortBuffer, inS, context);
    }

    ::std::function<void()>
    opShortBufferAsync(const ShortBuffer& inS,
                       ::std::function<void(::Test::ShortBuffer, ::Test::ShortBuffer)> response,
                       ::std::function<void(::std::exception_ptr)> ex = nullptr,
                       ::std::function<void(bool)> sent = nullptr,
                       const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpShortBufferResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outS));
        };
        return _makeLambdaOutgoing<TestIntf::OpShortBufferResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opShortBuffer, inS, context);
    }

    /// \cond INTERNAL
    void _iceI_opShortBuffer(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpShortBufferResult>>&, const ShortBuffer&, const ::Ice::Context&);
    /// \endcond

    ::Test::CustomBuffer<bool> opBoolBuffer(const ::Test::CustomBuffer<bool>& inS, ::Test::CustomBuffer<bool>& outS, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpBoolBufferResult>(true, this, &TestIntfPrx::_iceI_opBoolBuffer, inS, context).get();
        outS = ::std::move(_result.outS);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opBoolBufferAsync(const ::Test::CustomBuffer<bool>& inS, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpBoolBufferResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpBoolBufferResult, P>(false, this, &TestIntfPrx::_iceI_opBoolBuffer, inS, context);
    }

    ::std::function<void()>
    opBoolBufferAsync(const ::Test::CustomBuffer<bool>& inS,
                      ::std::function<void(::Test::CustomBuffer<bool>, ::Test::CustomBuffer<bool>)> response,
                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                      ::std::function<void(bool)> sent = nullptr,
                      const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpBoolBufferResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outS));
        };
        return _makeLambdaOutgoing<TestIntf::OpBoolBufferResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opBoolBuffer, inS, context);
    }

    /// \cond INTERNAL
    void _iceI_opBoolBuffer(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpBoolBufferResult>>&, const ::Test::CustomBuffer<bool>&, const ::Ice::Context&);
    /// \endcond

    BufferStruct opBufferStruct(const BufferStruct& s, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::Test::BufferStruct>(true, this, &TestIntfPrx::_iceI_opBufferStruct, s, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto opBufferStructAsync(const BufferStruct& s, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::Test::BufferStruct>>().get_future())
    {
        return _makePromiseOutgoing<::Test::BufferStruct, P>(false, this, &TestIntfPrx::_iceI_opBufferStruct, s, context);
    }

    ::std::function<void()>
    opBufferStructAsync(const BufferStruct& s,
                        ::std::function<void(::Test::BufferStruct)> response,
                        ::std::function<void(::std::exception_ptr)> ex = nullptr,
                        ::std::function<void(bool)> sent = nullptr,
                        const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<::Test::BufferStruct>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opBufferStruct, s, context);
    }

    /// \cond INTERNAL
    void _iceI_opBufferStruct(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::Test::BufferStruct>>&, const BufferStruct&, const ::Ice::Context&);
    /// \endcond

    void shutdown(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &TestIntfPrx::_iceI_shutdown, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto shutdownAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &TestIntfPrx::_iceI_shutdown, context);
    }

    ::std::function<void()>
    shutdownAsync(::std::function<void()> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_shutdown, context);
    }

    /// \cond INTERNAL
    void _iceI_shutdown(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    TestIntfPrx() = default;
    friend ::std::shared_ptr<TestIntfPrx> IceInternal::createProxy<TestIntfPrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

}

/// \cond STREAM
namespace Ice
{

template<>
struct StreamableTraits<::Test::Fixed>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 2;
    static const bool fixedLength = true;
};

template<typename S>
struct StreamReader<::Test::Fixed, S>
{
    static void read(S* istr, ::Test::Fixed& v)
    {
        istr->readAll(v.s);
    }
};

template<>
struct StreamableTraits<::Test::Variable>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 3;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::Test::Variable, S>
{
    static void read(S* istr, ::Test::Variable& v)
    {
        istr->readAll(v.s, v.bl, v.ss);
    }
};

template<>
struct StreamableTraits< ::Test::E>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 2;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits<::Test::ClassOtherStruct>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 4;
    static const bool fixedLength = true;
};

template<typename S>
struct StreamReader<::Test::ClassOtherStruct, S>
{
    static void read(S* istr, ::Test::ClassOtherStruct& v)
    {
        istr->readAll(v.x);
    }
};

template<>
struct StreamableTraits<::Test::ClassStruct>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 9;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::Test::ClassStruct, S>
{
    static void read(S* istr, ::Test::ClassStruct& v)
    {
        istr->readAll(v.otherSeq, v.other, v.y);
    }
};

template<typename S>
struct StreamReader<::Test::DictClass, S>
{
    static void read(S* istr, ::Test::DictClass& v)
    {
        istr->readAll(v.isdict);
    }
};

template<>
struct StreamableTraits<::Test::BufferStruct>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 7;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::Test::BufferStruct, S>
{
    static void read(S* istr, ::Test::BufferStruct& v)
    {
        istr->readAll(v.byteBuf, v.boolBuf, v.shortBuf, v.intBuf, v.longBuf, v.floatBuf, v.doubleBuf);
    }
};

}
/// \endcond

/// \cond INTERNAL
namespace Test
{

using CPtr = ::std::shared_ptr<C>;

using DPtr = ::std::shared_ptr<D>;
using DPrxPtr = ::std::shared_ptr<DPrx>;

using DictClassPtr = ::std::shared_ptr<DictClass>;

using TestIntfPtr = ::std::shared_ptr<TestIntf>;
using TestIntfPrxPtr = ::std::shared_ptr<TestIntfPrx>;

}
/// \endcond

#else // C++98 mapping

namespace IceProxy
{

namespace Test
{

class D;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< D>&);
::IceProxy::Ice::Object* upCast(D*);
/// \endcond

class TestIntf;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< TestIntf>&);
::IceProxy::Ice::Object* upCast(TestIntf*);
/// \endcond

}

}

namespace Test
{

class C;
using CPtr = ::Ice::SharedPtr<C>;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::D> DPrx;
typedef DPrx DPrxPtr;

class D;
using DPtr = ::Ice::SharedPtr< D>;

class DictClass;
using DictClassPtr = ::Ice::SharedPtr<DictClass>;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::TestIntf> TestIntfPrx;
typedef TestIntfPrx TestIntfPrxPtr;

class TestIntf;
using TestIntfPtr = ::Ice::SharedPtr< TestIntf>;

}

namespace Test
{

typedef ::std::vector<bool> BoolSeq;

typedef std::list<bool> BoolList;

typedef std::list< ::Test::BoolList> BoolListList;

typedef ::std::vector<BoolList> BoolListSeq;

typedef std::list< ::Test::BoolSeq> BoolSeqList;

typedef ::std::vector< ::Ice::Byte> ByteSeq;

typedef std::list< ::Ice::Byte> ByteList;

typedef std::list< ::Test::ByteList> ByteListList;

typedef ::std::vector<ByteList> ByteListSeq;

typedef std::list< ::Test::ByteSeq> ByteSeqList;

typedef ::std::vector< ::std::string> StringSeq;

typedef std::list<std::string> StringList;

typedef std::list< ::Test::StringList> StringListList;

typedef ::std::vector<StringList> StringListSeq;

typedef std::list< ::Test::StringSeq> StringSeqList;

struct Fixed
{
    ::Ice::Short s;

    bool operator==(const Fixed& rhs_) const
    {
        if(this == &rhs_)
        {
            return true;
        }
        if(s != rhs_.s)
        {
            return false;
        }
        return true;
    }

    bool operator<(const Fixed& rhs_) const
    {
        if(this == &rhs_)
        {
            return false;
        }
        if(s < rhs_.s)
        {
            return true;
        }
        else if(rhs_.s < s)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const Fixed& rhs_) const
    {
        return !operator==(rhs_);
    }
    bool operator<=(const Fixed& rhs_) const
    {
        return operator<(rhs_) || operator==(rhs_);
    }
    bool operator>(const Fixed& rhs_) const
    {
        return !operator<(rhs_) && !operator==(rhs_);
    }
    bool operator>=(const Fixed& rhs_) const
    {
        return !operator<(rhs_);
    }
};

typedef ::std::vector<Fixed> FixedSeq;

typedef std::list< ::Test::Fixed> FixedList;

typedef std::list< ::Test::FixedList> FixedListList;

typedef ::std::vector<FixedList> FixedListSeq;

typedef std::list< ::Test::FixedSeq> FixedSeqList;

struct Variable
{
    ::std::string s;
    ::Test::BoolList bl;
    std::list<std::string> ss;
};

typedef ::std::vector<Variable> VariableSeq;

typedef std::list< ::Test::Variable> VariableList;

typedef std::list< ::Test::VariableList> VariableListList;

typedef ::std::vector<VariableList> VariableListSeq;

typedef std::list< ::Test::VariableSeq> VariableSeqList;

typedef ::std::map< ::std::string, ::std::string> StringStringDict;

typedef ::std::vector<StringStringDict> StringStringDictSeq;

typedef std::list< ::Test::StringStringDict> StringStringDictList;

typedef std::list< ::Test::StringStringDictList> StringStringDictListList;

typedef ::std::vector<StringStringDictList> StringStringDictListSeq;

typedef std::list< ::Test::StringStringDictSeq> StringStringDictSeqList;

enum E
{
    E1,
    E2,
    E3
};

typedef ::std::vector<E> ESeq;

typedef std::list< ::Test::E> EList;

typedef std::list< ::Test::EList> EListList;

typedef ::std::vector<EList> EListSeq;

typedef std::list< ::Test::ESeq> ESeqList;

typedef ::std::vector<CPtr> CSeq;

typedef std::list< ::Test::CPtr> CList;

typedef std::list< ::Test::CList> CListList;

typedef ::std::vector<CList> CListSeq;

typedef std::list< ::Test::CSeq> CSeqList;

typedef ::std::vector<DPrx> DPrxSeq;

typedef std::list< ::Test::DPrx> DPrxList;

typedef std::list< ::Test::DPrxList> DPrxListList;

typedef ::std::vector<DPrxList> DPrxListSeq;

typedef std::list< ::Test::DPrxSeq> DPrxSeqList;

typedef ::std::vector< ::Ice::Double> DoubleSeq;

class ClassOtherStruct : public IceUtil::Shared
{
public:
    
    ClassOtherStruct() {}
    explicit ClassOtherStruct(::Ice::Int x) :
        x(x)
    {
    }
    

    ::Ice::Int x;

    bool operator==(const ClassOtherStruct& rhs_) const
    {
        if(this == &rhs_)
        {
            return true;
        }
        if(x != rhs_.x)
        {
            return false;
        }
        return true;
    }

    bool operator<(const ClassOtherStruct& rhs_) const
    {
        if(this == &rhs_)
        {
            return false;
        }
        if(x < rhs_.x)
        {
            return true;
        }
        else if(rhs_.x < x)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const ClassOtherStruct& rhs_) const
    {
        return !operator==(rhs_);
    }
    bool operator<=(const ClassOtherStruct& rhs_) const
    {
        return operator<(rhs_) || operator==(rhs_);
    }
    bool operator>(const ClassOtherStruct& rhs_) const
    {
        return !operator<(rhs_) && !operator==(rhs_);
    }
    bool operator>=(const ClassOtherStruct& rhs_) const
    {
        return !operator<(rhs_);
    }
};

typedef ::IceUtil::Handle< ::Test::ClassOtherStruct> ClassOtherStructPtr;

typedef ::std::vector<ClassOtherStructPtr> ClassOtherStructSeq;

class ClassStruct : public IceUtil::Shared
{
public:
    
    ClassStruct() {}
    ClassStruct(const ClassOtherStructSeq& otherSeq, const ClassOtherStructPtr& other, ::Ice::Int y) :
        otherSeq(otherSeq),
        other(other),
        y(y)
    {
    }
    

    ::Test::ClassOtherStructSeq otherSeq;
    ::Test::ClassOtherStructPtr other;
    ::Ice::Int y;
};

typedef ::IceUtil::Handle< ::Test::ClassStruct> ClassStructPtr;

typedef ::std::vector<ClassStructPtr> ClassStructSeq;

typedef Test::CustomMap<Ice::Int, std::string> IntStringDict;

typedef ::std::map< ::Ice::Long, ::Ice::Long> LongLongDict;

typedef ::std::map< ::std::string, ::Ice::Int> StringIntDict;

typedef Test::CustomBuffer<bool> BoolBuffer;

typedef Test::CustomBuffer<Ice::Short> ShortBuffer;

typedef Test::CustomBuffer<Ice::Int> IntBuffer;

typedef Test::CustomBuffer<Ice::Long> LongBuffer;

typedef Test::CustomBuffer<Ice::Float> FloatBuffer;

typedef Test::CustomBuffer<Ice::Double> DoubleBuffer;

typedef Test::CustomBuffer<Ice::Byte> ByteBuffer;

struct BufferStruct
{
    ::Test::ByteBuffer byteBuf;
    ::Test::BoolBuffer boolBuf;
    ::Test::ShortBuffer shortBuf;
    ::Test::IntBuffer intBuf;
    ::Test::LongBuffer longBuf;
    ::Test::FloatBuffer floatBuf;
    ::Test::DoubleBuffer doubleBuf;
};

}

namespace Test
{

/**
 * AMD callback class for Test::TestIntf::opDoubleArray_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_TestIntf_opDoubleArray : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_TestIntf_opDoubleArray();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const DoubleSeq& result, const DoubleSeq& outSeq) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_TestIntf_opDoubleArray> AMD_TestIntf_opDoubleArrayPtr;

/**
 * AMD callback class for Test::TestIntf::opBoolArray_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_TestIntf_opBoolArray : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_TestIntf_opBoolArray();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const BoolSeq& result, const BoolSeq& outSeq) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_TestIntf_opBoolArray> AMD_TestIntf_opBoolArrayPtr;

/**
 * AMD callback class for Test::TestIntf::opByteArray_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_TestIntf_opByteArray : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_TestIntf_opByteArray();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>& result, const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>& outSeq) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_TestIntf_opByteArray> AMD_TestIntf_opByteArrayPtr;

/**
 * AMD callback class for Test::TestIntf::opVariableArray_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_TestIntf_opVariableArray : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_TestIntf_opVariableArray();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const VariableList& result, const VariableList& outSeq) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_TestIntf_opVariableArray> AMD_TestIntf_opVariableArrayPtr;

/**
 * AMD callback class for Test::TestIntf::opBoolRange_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_TestIntf_opBoolRange : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_TestIntf_opBoolRange();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const BoolSeq& result, const BoolSeq& outSeq) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_TestIntf_opBoolRange> AMD_TestIntf_opBoolRangePtr;

/**
 * AMD callback class for Test::TestIntf::opByteRange_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_TestIntf_opByteRange : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_TestIntf_opByteRange();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const ::std::pair<ByteList::const_iterator, ByteList::const_iterator>& result, const ::std::pair<ByteList::const_iterator, ByteList::const_iterator>& outSeq) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_TestIntf_opByteRange> AMD_TestIntf_opByteRangePtr;

/**
 * AMD callback class for Test::TestIntf::opVariableRange_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_TestIntf_opVariableRange : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_TestIntf_opVariableRange();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const VariableList& result, const VariableList& outSeq) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_TestIntf_opVariableRange> AMD_TestIntf_opVariableRangePtr;

/**
 * AMD callback class for Test::TestIntf::opByteRangeType_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_TestIntf_opByteRangeType : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_TestIntf_opByteRangeType();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const ByteList& result, const ByteList& outSeq) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_TestIntf_opByteRangeType> AMD_TestIntf_opByteRangeTypePtr;

/**
 * AMD callback class for Test::TestIntf::opVariableRangeType_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_TestIntf_opVariableRangeType : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_TestIntf_opVariableRangeType();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const VariableList& result, const VariableList& outSeq) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_TestIntf_opVariableRangeType> AMD_TestIntf_opVariableRangeTypePtr;

/**
 * AMD callback class for Test::TestIntf::opBoolSeq_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_TestIntf_opBoolSeq : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_TestIntf_opBoolSeq();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const std::deque<bool>& result, const std::deque<bool>& outSeq) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_TestIntf_opBoolSeq> AMD_TestIntf_opBoolSeqPtr;

/**
 * AMD callback class for Test::TestIntf::opBoolList_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_TestIntf_opBoolList : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_TestIntf_opBoolList();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const BoolList& result, const BoolList& outSeq) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_TestIntf_opBoolList> AMD_TestIntf_opBoolListPtr;

/**
 * AMD callback class for Test::TestIntf::opByteSeq_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_TestIntf_opByteSeq : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_TestIntf_opByteSeq();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const std::deque< ::Ice::Byte>& result, const std::deque< ::Ice::Byte>& outSeq) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_TestIntf_opByteSeq> AMD_TestIntf_opByteSeqPtr;

/**
 * AMD callback class for Test::TestIntf::opByteList_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_TestIntf_opByteList : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_TestIntf_opByteList();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const ByteList& result, const ByteList& outSeq) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_TestIntf_opByteList> AMD_TestIntf_opByteListPtr;

/**
 * AMD callback class for Test::TestIntf::opMyByteSeq_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_TestIntf_opMyByteSeq : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_TestIntf_opMyByteSeq();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const MyByteSeq& result, const MyByteSeq& outSeq) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_TestIntf_opMyByteSeq> AMD_TestIntf_opMyByteSeqPtr;

/**
 * AMD callback class for Test::TestIntf::opString_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_TestIntf_opString : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_TestIntf_opString();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const Util::string_view& result, const Util::string_view& outString) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_TestIntf_opString> AMD_TestIntf_opStringPtr;

/**
 * AMD callback class for Test::TestIntf::opStringSeq_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_TestIntf_opStringSeq : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_TestIntf_opStringSeq();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const std::deque<std::string>& result, const std::deque<std::string>& outSeq) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_TestIntf_opStringSeq> AMD_TestIntf_opStringSeqPtr;

/**
 * AMD callback class for Test::TestIntf::opStringList_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_TestIntf_opStringList : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_TestIntf_opStringList();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const StringList& result, const StringList& outSeq) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_TestIntf_opStringList> AMD_TestIntf_opStringListPtr;

/**
 * AMD callback class for Test::TestIntf::opFixedSeq_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_TestIntf_opFixedSeq : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_TestIntf_opFixedSeq();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const std::deque< ::Test::Fixed>& result, const std::deque< ::Test::Fixed>& outSeq) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_TestIntf_opFixedSeq> AMD_TestIntf_opFixedSeqPtr;

/**
 * AMD callback class for Test::TestIntf::opFixedList_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_TestIntf_opFixedList : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_TestIntf_opFixedList();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const FixedList& result, const FixedList& outSeq) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_TestIntf_opFixedList> AMD_TestIntf_opFixedListPtr;

/**
 * AMD callback class for Test::TestIntf::opVariableSeq_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_TestIntf_opVariableSeq : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_TestIntf_opVariableSeq();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const std::deque< ::Test::Variable>& result, const std::deque< ::Test::Variable>& outSeq) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_TestIntf_opVariableSeq> AMD_TestIntf_opVariableSeqPtr;

/**
 * AMD callback class for Test::TestIntf::opVariableList_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_TestIntf_opVariableList : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_TestIntf_opVariableList();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const VariableList& result, const VariableList& outSeq) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_TestIntf_opVariableList> AMD_TestIntf_opVariableListPtr;

/**
 * AMD callback class for Test::TestIntf::opStringStringDictSeq_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_TestIntf_opStringStringDictSeq : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_TestIntf_opStringStringDictSeq();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const std::deque< ::Test::StringStringDict>& result, const std::deque< ::Test::StringStringDict>& outSeq) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_TestIntf_opStringStringDictSeq> AMD_TestIntf_opStringStringDictSeqPtr;

/**
 * AMD callback class for Test::TestIntf::opStringStringDictList_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_TestIntf_opStringStringDictList : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_TestIntf_opStringStringDictList();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const StringStringDictList& result, const StringStringDictList& outSeq) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_TestIntf_opStringStringDictList> AMD_TestIntf_opStringStringDictListPtr;

/**
 * AMD callback class for Test::TestIntf::opESeq_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_TestIntf_opESeq : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_TestIntf_opESeq();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const std::deque< ::Test::E>& result, const std::deque< ::Test::E>& outSeq) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_TestIntf_opESeq> AMD_TestIntf_opESeqPtr;

/**
 * AMD callback class for Test::TestIntf::opEList_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_TestIntf_opEList : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_TestIntf_opEList();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const EList& result, const EList& outSeq) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_TestIntf_opEList> AMD_TestIntf_opEListPtr;

/**
 * AMD callback class for Test::TestIntf::opDPrxSeq_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_TestIntf_opDPrxSeq : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_TestIntf_opDPrxSeq();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const std::deque< ::Test::DPrx>& result, const std::deque< ::Test::DPrx>& outSeq) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_TestIntf_opDPrxSeq> AMD_TestIntf_opDPrxSeqPtr;

/**
 * AMD callback class for Test::TestIntf::opDPrxList_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_TestIntf_opDPrxList : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_TestIntf_opDPrxList();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const DPrxList& result, const DPrxList& outSeq) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_TestIntf_opDPrxList> AMD_TestIntf_opDPrxListPtr;

/**
 * AMD callback class for Test::TestIntf::opCSeq_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_TestIntf_opCSeq : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_TestIntf_opCSeq();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const std::deque< ::Test::CPtr>& result, const std::deque< ::Test::CPtr>& outSeq) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_TestIntf_opCSeq> AMD_TestIntf_opCSeqPtr;

/**
 * AMD callback class for Test::TestIntf::opCList_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_TestIntf_opCList : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_TestIntf_opCList();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const CList& result, const CList& outSeq) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_TestIntf_opCList> AMD_TestIntf_opCListPtr;

/**
 * AMD callback class for Test::TestIntf::opClassStruct_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_TestIntf_opClassStruct : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_TestIntf_opClassStruct();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const ClassStructPtr& result, const ClassStructPtr& outS, const ClassStructSeq& outSeq) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_TestIntf_opClassStruct> AMD_TestIntf_opClassStructPtr;

/**
 * AMD callback class for Test::TestIntf::opOutArrayByteSeq_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_TestIntf_opOutArrayByteSeq : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_TestIntf_opOutArrayByteSeq();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>& copy) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_TestIntf_opOutArrayByteSeq> AMD_TestIntf_opOutArrayByteSeqPtr;

/**
 * AMD callback class for Test::TestIntf::opOutRangeByteSeq_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_TestIntf_opOutRangeByteSeq : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_TestIntf_opOutRangeByteSeq();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const ::std::pair<ByteSeq::const_iterator, ByteSeq::const_iterator>& copy) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_TestIntf_opOutRangeByteSeq> AMD_TestIntf_opOutRangeByteSeqPtr;

/**
 * AMD callback class for Test::TestIntf::opIntStringDict_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_TestIntf_opIntStringDict : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_TestIntf_opIntStringDict();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const IntStringDict& result, const IntStringDict& odict) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_TestIntf_opIntStringDict> AMD_TestIntf_opIntStringDictPtr;

/**
 * AMD callback class for Test::TestIntf::opVarDict_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_TestIntf_opVarDict : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_TestIntf_opVarDict();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const ::Test::CustomMap< ::Ice::Long, ::Ice::Long>& result, const ::Test::CustomMap<std::string, ::Ice::Int>& odict) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_TestIntf_opVarDict> AMD_TestIntf_opVarDictPtr;

/**
 * AMD callback class for Test::TestIntf::opCustomIntStringDict_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_TestIntf_opCustomIntStringDict : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_TestIntf_opCustomIntStringDict();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const ::std::map< ::Ice::Int, ::Util::string_view>& result, const ::std::map< ::Ice::Int, ::Util::string_view>& odict) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_TestIntf_opCustomIntStringDict> AMD_TestIntf_opCustomIntStringDictPtr;

/**
 * AMD callback class for Test::TestIntf::opShortBuffer_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_TestIntf_opShortBuffer : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_TestIntf_opShortBuffer();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const ShortBuffer& result, const ShortBuffer& outS) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_TestIntf_opShortBuffer> AMD_TestIntf_opShortBufferPtr;

/**
 * AMD callback class for Test::TestIntf::opBoolBuffer_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_TestIntf_opBoolBuffer : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_TestIntf_opBoolBuffer();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const ::Test::CustomBuffer<bool>& result, const ::Test::CustomBuffer<bool>& outS) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_TestIntf_opBoolBuffer> AMD_TestIntf_opBoolBufferPtr;

/**
 * AMD callback class for Test::TestIntf::opBufferStruct_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_TestIntf_opBufferStruct : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_TestIntf_opBufferStruct();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response(const BufferStruct& result) = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_TestIntf_opBufferStruct> AMD_TestIntf_opBufferStructPtr;

/**
 * AMD callback class for Test::TestIntf::shutdown_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_TestIntf_shutdown : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_TestIntf_shutdown();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_TestIntf_shutdown> AMD_TestIntf_shutdownPtr;

}

/// \cond INTERNAL
namespace IceAsync
{

namespace Test
{

#if defined(_MSC_VER)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_TestIntf_opDoubleArray : public ::Test::AMD_TestIntf_opDoubleArray, public ::IceInternal::IncomingAsync
{
public:

    AMD_TestIntf_opDoubleArray(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::DoubleSeq&, const ::Test::DoubleSeq&);
};

#if defined(_MSC_VER)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_TestIntf_opBoolArray : public ::Test::AMD_TestIntf_opBoolArray, public ::IceInternal::IncomingAsync
{
public:

    AMD_TestIntf_opBoolArray(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::BoolSeq&, const ::Test::BoolSeq&);
};

#if defined(_MSC_VER)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_TestIntf_opByteArray : public ::Test::AMD_TestIntf_opByteArray, public ::IceInternal::IncomingAsync
{
public:

    AMD_TestIntf_opByteArray(::IceInternal::Incoming&);

    virtual void ice_response(const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>&, const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>&);
};

#if defined(_MSC_VER)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_TestIntf_opVariableArray : public ::Test::AMD_TestIntf_opVariableArray, public ::IceInternal::IncomingAsync
{
public:

    AMD_TestIntf_opVariableArray(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::VariableList&, const ::Test::VariableList&);
};

#if defined(_MSC_VER)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_TestIntf_opBoolRange : public ::Test::AMD_TestIntf_opBoolRange, public ::IceInternal::IncomingAsync
{
public:

    AMD_TestIntf_opBoolRange(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::BoolSeq&, const ::Test::BoolSeq&);
};

#if defined(_MSC_VER)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_TestIntf_opByteRange : public ::Test::AMD_TestIntf_opByteRange, public ::IceInternal::IncomingAsync
{
public:

    AMD_TestIntf_opByteRange(::IceInternal::Incoming&);

    virtual void ice_response(const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>&, const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>&);
};

#if defined(_MSC_VER)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_TestIntf_opVariableRange : public ::Test::AMD_TestIntf_opVariableRange, public ::IceInternal::IncomingAsync
{
public:

    AMD_TestIntf_opVariableRange(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::VariableList&, const ::Test::VariableList&);
};

#if defined(_MSC_VER)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_TestIntf_opByteRangeType : public ::Test::AMD_TestIntf_opByteRangeType, public ::IceInternal::IncomingAsync
{
public:

    AMD_TestIntf_opByteRangeType(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::ByteList&, const ::Test::ByteList&);
};

#if defined(_MSC_VER)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_TestIntf_opVariableRangeType : public ::Test::AMD_TestIntf_opVariableRangeType, public ::IceInternal::IncomingAsync
{
public:

    AMD_TestIntf_opVariableRangeType(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::VariableList&, const ::Test::VariableList&);
};

#if defined(_MSC_VER)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_TestIntf_opBoolSeq : public ::Test::AMD_TestIntf_opBoolSeq, public ::IceInternal::IncomingAsync
{
public:

    AMD_TestIntf_opBoolSeq(::IceInternal::Incoming&);

    virtual void ice_response(const std::deque<bool>&, const std::deque<bool>&);
};

#if defined(_MSC_VER)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_TestIntf_opBoolList : public ::Test::AMD_TestIntf_opBoolList, public ::IceInternal::IncomingAsync
{
public:

    AMD_TestIntf_opBoolList(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::BoolList&, const ::Test::BoolList&);
};

#if defined(_MSC_VER)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_TestIntf_opByteSeq : public ::Test::AMD_TestIntf_opByteSeq, public ::IceInternal::IncomingAsync
{
public:

    AMD_TestIntf_opByteSeq(::IceInternal::Incoming&);

    virtual void ice_response(const std::deque< ::Ice::Byte>&, const std::deque< ::Ice::Byte>&);
};

#if defined(_MSC_VER)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_TestIntf_opByteList : public ::Test::AMD_TestIntf_opByteList, public ::IceInternal::IncomingAsync
{
public:

    AMD_TestIntf_opByteList(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::ByteList&, const ::Test::ByteList&);
};

#if defined(_MSC_VER)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_TestIntf_opMyByteSeq : public ::Test::AMD_TestIntf_opMyByteSeq, public ::IceInternal::IncomingAsync
{
public:

    AMD_TestIntf_opMyByteSeq(::IceInternal::Incoming&);

    virtual void ice_response(const MyByteSeq&, const MyByteSeq&);
};

#if defined(_MSC_VER)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_TestIntf_opString : public ::Test::AMD_TestIntf_opString, public ::IceInternal::IncomingAsync
{
public:

    AMD_TestIntf_opString(::IceInternal::Incoming&);

    virtual void ice_response(const Util::string_view&, const Util::string_view&);
};

#if defined(_MSC_VER)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_TestIntf_opStringSeq : public ::Test::AMD_TestIntf_opStringSeq, public ::IceInternal::IncomingAsync
{
public:

    AMD_TestIntf_opStringSeq(::IceInternal::Incoming&);

    virtual void ice_response(const std::deque<std::string>&, const std::deque<std::string>&);
};

#if defined(_MSC_VER)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_TestIntf_opStringList : public ::Test::AMD_TestIntf_opStringList, public ::IceInternal::IncomingAsync
{
public:

    AMD_TestIntf_opStringList(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::StringList&, const ::Test::StringList&);
};

#if defined(_MSC_VER)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_TestIntf_opFixedSeq : public ::Test::AMD_TestIntf_opFixedSeq, public ::IceInternal::IncomingAsync
{
public:

    AMD_TestIntf_opFixedSeq(::IceInternal::Incoming&);

    virtual void ice_response(const std::deque< ::Test::Fixed>&, const std::deque< ::Test::Fixed>&);
};

#if defined(_MSC_VER)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_TestIntf_opFixedList : public ::Test::AMD_TestIntf_opFixedList, public ::IceInternal::IncomingAsync
{
public:

    AMD_TestIntf_opFixedList(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::FixedList&, const ::Test::FixedList&);
};

#if defined(_MSC_VER)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_TestIntf_opVariableSeq : public ::Test::AMD_TestIntf_opVariableSeq, public ::IceInternal::IncomingAsync
{
public:

    AMD_TestIntf_opVariableSeq(::IceInternal::Incoming&);

    virtual void ice_response(const std::deque< ::Test::Variable>&, const std::deque< ::Test::Variable>&);
};

#if defined(_MSC_VER)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_TestIntf_opVariableList : public ::Test::AMD_TestIntf_opVariableList, public ::IceInternal::IncomingAsync
{
public:

    AMD_TestIntf_opVariableList(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::VariableList&, const ::Test::VariableList&);
};

#if defined(_MSC_VER)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_TestIntf_opStringStringDictSeq : public ::Test::AMD_TestIntf_opStringStringDictSeq, public ::IceInternal::IncomingAsync
{
public:

    AMD_TestIntf_opStringStringDictSeq(::IceInternal::Incoming&);

    virtual void ice_response(const std::deque< ::Test::StringStringDict>&, const std::deque< ::Test::StringStringDict>&);
};

#if defined(_MSC_VER)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_TestIntf_opStringStringDictList : public ::Test::AMD_TestIntf_opStringStringDictList, public ::IceInternal::IncomingAsync
{
public:

    AMD_TestIntf_opStringStringDictList(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::StringStringDictList&, const ::Test::StringStringDictList&);
};

#if defined(_MSC_VER)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_TestIntf_opESeq : public ::Test::AMD_TestIntf_opESeq, public ::IceInternal::IncomingAsync
{
public:

    AMD_TestIntf_opESeq(::IceInternal::Incoming&);

    virtual void ice_response(const std::deque< ::Test::E>&, const std::deque< ::Test::E>&);
};

#if defined(_MSC_VER)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_TestIntf_opEList : public ::Test::AMD_TestIntf_opEList, public ::IceInternal::IncomingAsync
{
public:

    AMD_TestIntf_opEList(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::EList&, const ::Test::EList&);
};

#if defined(_MSC_VER)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_TestIntf_opDPrxSeq : public ::Test::AMD_TestIntf_opDPrxSeq, public ::IceInternal::IncomingAsync
{
public:

    AMD_TestIntf_opDPrxSeq(::IceInternal::Incoming&);

    virtual void ice_response(const std::deque< ::Test::DPrx>&, const std::deque< ::Test::DPrx>&);
};

#if defined(_MSC_VER)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_TestIntf_opDPrxList : public ::Test::AMD_TestIntf_opDPrxList, public ::IceInternal::IncomingAsync
{
public:

    AMD_TestIntf_opDPrxList(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::DPrxList&, const ::Test::DPrxList&);
};

#if defined(_MSC_VER)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_TestIntf_opCSeq : public ::Test::AMD_TestIntf_opCSeq, public ::IceInternal::IncomingAsync
{
public:

    AMD_TestIntf_opCSeq(::IceInternal::Incoming&);

    virtual void ice_response(const std::deque< ::Test::CPtr>&, const std::deque< ::Test::CPtr>&);
};

#if defined(_MSC_VER)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_TestIntf_opCList : public ::Test::AMD_TestIntf_opCList, public ::IceInternal::IncomingAsync
{
public:

    AMD_TestIntf_opCList(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::CList&, const ::Test::CList&);
};

#if defined(_MSC_VER)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_TestIntf_opClassStruct : public ::Test::AMD_TestIntf_opClassStruct, public ::IceInternal::IncomingAsync
{
public:

    AMD_TestIntf_opClassStruct(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::ClassStructPtr&, const ::Test::ClassStructPtr&, const ::Test::ClassStructSeq&);
};

#if defined(_MSC_VER)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_TestIntf_opOutArrayByteSeq : public ::Test::AMD_TestIntf_opOutArrayByteSeq, public ::IceInternal::IncomingAsync
{
public:

    AMD_TestIntf_opOutArrayByteSeq(::IceInternal::Incoming&);

    virtual void ice_response(const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>&);
};

#if defined(_MSC_VER)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_TestIntf_opOutRangeByteSeq : public ::Test::AMD_TestIntf_opOutRangeByteSeq, public ::IceInternal::IncomingAsync
{
public:

    AMD_TestIntf_opOutRangeByteSeq(::IceInternal::Incoming&);

    virtual void ice_response(const ::std::pair< ::Test::ByteSeq::const_iterator,  ::Test::ByteSeq::const_iterator>&);
};

#if defined(_MSC_VER)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_TestIntf_opIntStringDict : public ::Test::AMD_TestIntf_opIntStringDict, public ::IceInternal::IncomingAsync
{
public:

    AMD_TestIntf_opIntStringDict(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::IntStringDict&, const ::Test::IntStringDict&);
};

#if defined(_MSC_VER)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_TestIntf_opVarDict : public ::Test::AMD_TestIntf_opVarDict, public ::IceInternal::IncomingAsync
{
public:

    AMD_TestIntf_opVarDict(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::CustomMap< ::Ice::Long, ::Ice::Long>&, const ::Test::CustomMap<std::string, ::Ice::Int>&);
};

#if defined(_MSC_VER)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_TestIntf_opCustomIntStringDict : public ::Test::AMD_TestIntf_opCustomIntStringDict, public ::IceInternal::IncomingAsync
{
public:

    AMD_TestIntf_opCustomIntStringDict(::IceInternal::Incoming&);

    virtual void ice_response(const ::std::map< ::Ice::Int, ::Util::string_view>&, const ::std::map< ::Ice::Int, ::Util::string_view>&);
};

#if defined(_MSC_VER)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_TestIntf_opShortBuffer : public ::Test::AMD_TestIntf_opShortBuffer, public ::IceInternal::IncomingAsync
{
public:

    AMD_TestIntf_opShortBuffer(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::ShortBuffer&, const ::Test::ShortBuffer&);
};

#if defined(_MSC_VER)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_TestIntf_opBoolBuffer : public ::Test::AMD_TestIntf_opBoolBuffer, public ::IceInternal::IncomingAsync
{
public:

    AMD_TestIntf_opBoolBuffer(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::CustomBuffer<bool>&, const ::Test::CustomBuffer<bool>&);
};

#if defined(_MSC_VER)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_TestIntf_opBufferStruct : public ::Test::AMD_TestIntf_opBufferStruct, public ::IceInternal::IncomingAsync
{
public:

    AMD_TestIntf_opBufferStruct(::IceInternal::Incoming&);

    virtual void ice_response(const ::Test::BufferStruct&);
};

#if defined(_MSC_VER)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_TestIntf_shutdown : public ::Test::AMD_TestIntf_shutdown, public ::IceInternal::IncomingAsync
{
public:

    AMD_TestIntf_shutdown(::IceInternal::Incoming&);

    virtual void ice_response();
};

#if defined(_MSC_VER)
#   pragma warning(pop)
#endif

}

}
/// \endcond

namespace Test
{

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opDoubleArray.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opDoubleArray.
 */
class Callback_TestIntf_opDoubleArray_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opDoubleArray_Base> Callback_TestIntf_opDoubleArrayPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opBoolArray.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opBoolArray.
 */
class Callback_TestIntf_opBoolArray_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opBoolArray_Base> Callback_TestIntf_opBoolArrayPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opByteArray.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opByteArray.
 */
class Callback_TestIntf_opByteArray_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opByteArray_Base> Callback_TestIntf_opByteArrayPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opVariableArray.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opVariableArray.
 */
class Callback_TestIntf_opVariableArray_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opVariableArray_Base> Callback_TestIntf_opVariableArrayPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opBoolRange.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opBoolRange.
 */
class Callback_TestIntf_opBoolRange_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opBoolRange_Base> Callback_TestIntf_opBoolRangePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opByteRange.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opByteRange.
 */
class Callback_TestIntf_opByteRange_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opByteRange_Base> Callback_TestIntf_opByteRangePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opVariableRange.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opVariableRange.
 */
class Callback_TestIntf_opVariableRange_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opVariableRange_Base> Callback_TestIntf_opVariableRangePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opByteRangeType.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opByteRangeType.
 */
class Callback_TestIntf_opByteRangeType_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opByteRangeType_Base> Callback_TestIntf_opByteRangeTypePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opVariableRangeType.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opVariableRangeType.
 */
class Callback_TestIntf_opVariableRangeType_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opVariableRangeType_Base> Callback_TestIntf_opVariableRangeTypePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opBoolSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opBoolSeq.
 */
class Callback_TestIntf_opBoolSeq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opBoolSeq_Base> Callback_TestIntf_opBoolSeqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opBoolList.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opBoolList.
 */
class Callback_TestIntf_opBoolList_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opBoolList_Base> Callback_TestIntf_opBoolListPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opByteSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opByteSeq.
 */
class Callback_TestIntf_opByteSeq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opByteSeq_Base> Callback_TestIntf_opByteSeqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opByteList.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opByteList.
 */
class Callback_TestIntf_opByteList_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opByteList_Base> Callback_TestIntf_opByteListPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opMyByteSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opMyByteSeq.
 */
class Callback_TestIntf_opMyByteSeq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opMyByteSeq_Base> Callback_TestIntf_opMyByteSeqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opString.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opString.
 */
class Callback_TestIntf_opString_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opString_Base> Callback_TestIntf_opStringPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opStringSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opStringSeq.
 */
class Callback_TestIntf_opStringSeq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opStringSeq_Base> Callback_TestIntf_opStringSeqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opStringList.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opStringList.
 */
class Callback_TestIntf_opStringList_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opStringList_Base> Callback_TestIntf_opStringListPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opFixedSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opFixedSeq.
 */
class Callback_TestIntf_opFixedSeq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opFixedSeq_Base> Callback_TestIntf_opFixedSeqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opFixedList.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opFixedList.
 */
class Callback_TestIntf_opFixedList_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opFixedList_Base> Callback_TestIntf_opFixedListPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opVariableSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opVariableSeq.
 */
class Callback_TestIntf_opVariableSeq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opVariableSeq_Base> Callback_TestIntf_opVariableSeqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opVariableList.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opVariableList.
 */
class Callback_TestIntf_opVariableList_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opVariableList_Base> Callback_TestIntf_opVariableListPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opStringStringDictSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opStringStringDictSeq.
 */
class Callback_TestIntf_opStringStringDictSeq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opStringStringDictSeq_Base> Callback_TestIntf_opStringStringDictSeqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opStringStringDictList.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opStringStringDictList.
 */
class Callback_TestIntf_opStringStringDictList_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opStringStringDictList_Base> Callback_TestIntf_opStringStringDictListPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opESeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opESeq.
 */
class Callback_TestIntf_opESeq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opESeq_Base> Callback_TestIntf_opESeqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opEList.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opEList.
 */
class Callback_TestIntf_opEList_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opEList_Base> Callback_TestIntf_opEListPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opDPrxSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opDPrxSeq.
 */
class Callback_TestIntf_opDPrxSeq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opDPrxSeq_Base> Callback_TestIntf_opDPrxSeqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opDPrxList.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opDPrxList.
 */
class Callback_TestIntf_opDPrxList_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opDPrxList_Base> Callback_TestIntf_opDPrxListPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opCSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opCSeq.
 */
class Callback_TestIntf_opCSeq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opCSeq_Base> Callback_TestIntf_opCSeqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opCList.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opCList.
 */
class Callback_TestIntf_opCList_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opCList_Base> Callback_TestIntf_opCListPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opClassStruct.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opClassStruct.
 */
class Callback_TestIntf_opClassStruct_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opClassStruct_Base> Callback_TestIntf_opClassStructPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opOutArrayByteSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opOutArrayByteSeq.
 */
class Callback_TestIntf_opOutArrayByteSeq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opOutArrayByteSeq_Base> Callback_TestIntf_opOutArrayByteSeqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opOutRangeByteSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opOutRangeByteSeq.
 */
class Callback_TestIntf_opOutRangeByteSeq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opOutRangeByteSeq_Base> Callback_TestIntf_opOutRangeByteSeqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opIntStringDict.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opIntStringDict.
 */
class Callback_TestIntf_opIntStringDict_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opIntStringDict_Base> Callback_TestIntf_opIntStringDictPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opVarDict.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opVarDict.
 */
class Callback_TestIntf_opVarDict_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opVarDict_Base> Callback_TestIntf_opVarDictPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opCustomIntStringDict.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opCustomIntStringDict.
 */
class Callback_TestIntf_opCustomIntStringDict_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opCustomIntStringDict_Base> Callback_TestIntf_opCustomIntStringDictPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opShortBuffer.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opShortBuffer.
 */
class Callback_TestIntf_opShortBuffer_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opShortBuffer_Base> Callback_TestIntf_opShortBufferPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opBoolBuffer.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opBoolBuffer.
 */
class Callback_TestIntf_opBoolBuffer_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opBoolBuffer_Base> Callback_TestIntf_opBoolBufferPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opBufferStruct.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opBufferStruct.
 */
class Callback_TestIntf_opBufferStruct_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opBufferStruct_Base> Callback_TestIntf_opBufferStructPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_shutdown.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_shutdown.
 */
class Callback_TestIntf_shutdown_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_shutdown_Base> Callback_TestIntf_shutdownPtr;

}

namespace IceProxy
{

namespace Test
{

class D : public virtual ::Ice::Proxy<D, ::IceProxy::Ice::Object>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class TestIntf : public virtual ::Ice::Proxy<TestIntf, ::IceProxy::Ice::Object>
{
public:

    ::Test::DoubleSeq opDoubleArray(const ::std::pair<const ::Ice::Double*, const ::Ice::Double*>& inSeq, ::Test::DoubleSeq& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opDoubleArray(outSeq, _iceI_begin_opDoubleArray(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opDoubleArray(const ::std::pair<const ::Ice::Double*, const ::Ice::Double*>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opDoubleArray(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opDoubleArray(const ::std::pair<const ::Ice::Double*, const ::Ice::Double*>& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opDoubleArray(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opDoubleArray(const ::std::pair<const ::Ice::Double*, const ::Ice::Double*>& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opDoubleArray(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opDoubleArray(const ::std::pair<const ::Ice::Double*, const ::Ice::Double*>& inSeq, const ::Test::Callback_TestIntf_opDoubleArrayPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opDoubleArray(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opDoubleArray(const ::std::pair<const ::Ice::Double*, const ::Ice::Double*>& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opDoubleArrayPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opDoubleArray(inSeq, context, cb, cookie);
    }

    ::Test::DoubleSeq end_opDoubleArray(::Test::DoubleSeq& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opDoubleArray(::Test::DoubleSeq& iceP_outSeq, ::Test::DoubleSeq& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opDoubleArray(const ::std::pair<const ::Ice::Double*, const ::Ice::Double*>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::BoolSeq opBoolArray(const ::std::pair<const bool*, const bool*>& inSeq, ::Test::BoolSeq& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opBoolArray(outSeq, _iceI_begin_opBoolArray(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opBoolArray(const ::std::pair<const bool*, const bool*>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opBoolArray(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opBoolArray(const ::std::pair<const bool*, const bool*>& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opBoolArray(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opBoolArray(const ::std::pair<const bool*, const bool*>& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opBoolArray(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opBoolArray(const ::std::pair<const bool*, const bool*>& inSeq, const ::Test::Callback_TestIntf_opBoolArrayPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opBoolArray(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opBoolArray(const ::std::pair<const bool*, const bool*>& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opBoolArrayPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opBoolArray(inSeq, context, cb, cookie);
    }

    ::Test::BoolSeq end_opBoolArray(::Test::BoolSeq& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opBoolArray(::Test::BoolSeq& iceP_outSeq, ::Test::BoolSeq& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opBoolArray(const ::std::pair<const bool*, const bool*>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::ByteList opByteArray(const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>& inSeq, ::Test::ByteList& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opByteArray(outSeq, _iceI_begin_opByteArray(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opByteArray(const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opByteArray(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opByteArray(const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByteArray(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opByteArray(const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByteArray(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opByteArray(const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>& inSeq, const ::Test::Callback_TestIntf_opByteArrayPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByteArray(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opByteArray(const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opByteArrayPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByteArray(inSeq, context, cb, cookie);
    }

    ::Test::ByteList end_opByteArray(::Test::ByteList& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opByteArray(::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>& iceP_outSeq, ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opByteArray(const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::VariableList opVariableArray(const ::std::pair<const ::Test::Variable*, const ::Test::Variable*>& inSeq, ::Test::VariableList& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opVariableArray(outSeq, _iceI_begin_opVariableArray(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opVariableArray(const ::std::pair<const ::Test::Variable*, const ::Test::Variable*>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opVariableArray(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opVariableArray(const ::std::pair<const ::Test::Variable*, const ::Test::Variable*>& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opVariableArray(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opVariableArray(const ::std::pair<const ::Test::Variable*, const ::Test::Variable*>& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opVariableArray(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opVariableArray(const ::std::pair<const ::Test::Variable*, const ::Test::Variable*>& inSeq, const ::Test::Callback_TestIntf_opVariableArrayPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opVariableArray(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opVariableArray(const ::std::pair<const ::Test::Variable*, const ::Test::Variable*>& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opVariableArrayPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opVariableArray(inSeq, context, cb, cookie);
    }

    ::Test::VariableList end_opVariableArray(::Test::VariableList& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opVariableArray(::Test::VariableList& iceP_outSeq, ::Test::VariableList& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opVariableArray(const ::std::pair<const ::Test::Variable*, const ::Test::Variable*>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::BoolSeq opBoolRange(const ::std::pair< ::Test::BoolSeq::const_iterator,  ::Test::BoolSeq::const_iterator>& inSeq, ::Test::BoolSeq& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opBoolRange(outSeq, _iceI_begin_opBoolRange(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opBoolRange(const ::std::pair< ::Test::BoolSeq::const_iterator,  ::Test::BoolSeq::const_iterator>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opBoolRange(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opBoolRange(const ::std::pair< ::Test::BoolSeq::const_iterator,  ::Test::BoolSeq::const_iterator>& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opBoolRange(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opBoolRange(const ::std::pair< ::Test::BoolSeq::const_iterator,  ::Test::BoolSeq::const_iterator>& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opBoolRange(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opBoolRange(const ::std::pair< ::Test::BoolSeq::const_iterator,  ::Test::BoolSeq::const_iterator>& inSeq, const ::Test::Callback_TestIntf_opBoolRangePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opBoolRange(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opBoolRange(const ::std::pair< ::Test::BoolSeq::const_iterator,  ::Test::BoolSeq::const_iterator>& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opBoolRangePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opBoolRange(inSeq, context, cb, cookie);
    }

    ::Test::BoolSeq end_opBoolRange(::Test::BoolSeq& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opBoolRange(::Test::BoolSeq& iceP_outSeq, ::Test::BoolSeq& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opBoolRange(const ::std::pair< ::Test::BoolSeq::const_iterator,  ::Test::BoolSeq::const_iterator>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::ByteList opByteRange(const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>& inSeq, ::Test::ByteList& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opByteRange(outSeq, _iceI_begin_opByteRange(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opByteRange(const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opByteRange(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opByteRange(const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByteRange(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opByteRange(const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByteRange(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opByteRange(const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>& inSeq, const ::Test::Callback_TestIntf_opByteRangePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByteRange(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opByteRange(const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opByteRangePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByteRange(inSeq, context, cb, cookie);
    }

    ::Test::ByteList end_opByteRange(::Test::ByteList& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opByteRange(::Test::ByteList& iceP_outSeq, ::Test::ByteList& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opByteRange(const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::VariableList opVariableRange(const ::std::pair< ::Test::VariableList::const_iterator,  ::Test::VariableList::const_iterator>& inSeq, ::Test::VariableList& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opVariableRange(outSeq, _iceI_begin_opVariableRange(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opVariableRange(const ::std::pair< ::Test::VariableList::const_iterator,  ::Test::VariableList::const_iterator>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opVariableRange(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opVariableRange(const ::std::pair< ::Test::VariableList::const_iterator,  ::Test::VariableList::const_iterator>& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opVariableRange(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opVariableRange(const ::std::pair< ::Test::VariableList::const_iterator,  ::Test::VariableList::const_iterator>& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opVariableRange(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opVariableRange(const ::std::pair< ::Test::VariableList::const_iterator,  ::Test::VariableList::const_iterator>& inSeq, const ::Test::Callback_TestIntf_opVariableRangePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opVariableRange(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opVariableRange(const ::std::pair< ::Test::VariableList::const_iterator,  ::Test::VariableList::const_iterator>& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opVariableRangePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opVariableRange(inSeq, context, cb, cookie);
    }

    ::Test::VariableList end_opVariableRange(::Test::VariableList& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opVariableRange(::Test::VariableList& iceP_outSeq, ::Test::VariableList& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opVariableRange(const ::std::pair< ::Test::VariableList::const_iterator,  ::Test::VariableList::const_iterator>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::ByteList opByteRangeType(const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>& inSeq, ::Test::ByteList& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opByteRangeType(outSeq, _iceI_begin_opByteRangeType(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opByteRangeType(const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opByteRangeType(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opByteRangeType(const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByteRangeType(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opByteRangeType(const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByteRangeType(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opByteRangeType(const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>& inSeq, const ::Test::Callback_TestIntf_opByteRangeTypePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByteRangeType(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opByteRangeType(const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opByteRangeTypePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByteRangeType(inSeq, context, cb, cookie);
    }

    ::Test::ByteList end_opByteRangeType(::Test::ByteList& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opByteRangeType(::Test::ByteList& iceP_outSeq, ::Test::ByteList& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opByteRangeType(const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::VariableList opVariableRangeType(const ::std::pair<std::deque< ::Test::Variable>::const_iterator, std::deque< ::Test::Variable>::const_iterator>& inSeq, ::Test::VariableList& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opVariableRangeType(outSeq, _iceI_begin_opVariableRangeType(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opVariableRangeType(const ::std::pair<std::deque< ::Test::Variable>::const_iterator, std::deque< ::Test::Variable>::const_iterator>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opVariableRangeType(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opVariableRangeType(const ::std::pair<std::deque< ::Test::Variable>::const_iterator, std::deque< ::Test::Variable>::const_iterator>& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opVariableRangeType(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opVariableRangeType(const ::std::pair<std::deque< ::Test::Variable>::const_iterator, std::deque< ::Test::Variable>::const_iterator>& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opVariableRangeType(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opVariableRangeType(const ::std::pair<std::deque< ::Test::Variable>::const_iterator, std::deque< ::Test::Variable>::const_iterator>& inSeq, const ::Test::Callback_TestIntf_opVariableRangeTypePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opVariableRangeType(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opVariableRangeType(const ::std::pair<std::deque< ::Test::Variable>::const_iterator, std::deque< ::Test::Variable>::const_iterator>& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opVariableRangeTypePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opVariableRangeType(inSeq, context, cb, cookie);
    }

    ::Test::VariableList end_opVariableRangeType(::Test::VariableList& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opVariableRangeType(::Test::VariableList& iceP_outSeq, ::Test::VariableList& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opVariableRangeType(const ::std::pair<std::deque< ::Test::Variable>::const_iterator, std::deque< ::Test::Variable>::const_iterator>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    std::deque<bool> opBoolSeq(const std::deque<bool>& inSeq, std::deque<bool>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opBoolSeq(outSeq, _iceI_begin_opBoolSeq(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opBoolSeq(const std::deque<bool>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opBoolSeq(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opBoolSeq(const std::deque<bool>& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opBoolSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opBoolSeq(const std::deque<bool>& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opBoolSeq(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opBoolSeq(const std::deque<bool>& inSeq, const ::Test::Callback_TestIntf_opBoolSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opBoolSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opBoolSeq(const std::deque<bool>& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opBoolSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opBoolSeq(inSeq, context, cb, cookie);
    }

    std::deque<bool> end_opBoolSeq(std::deque<bool>& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opBoolSeq(std::deque<bool>& iceP_outSeq, std::deque<bool>& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opBoolSeq(const std::deque<bool>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::BoolList opBoolList(const ::Test::BoolList& inSeq, ::Test::BoolList& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opBoolList(outSeq, _iceI_begin_opBoolList(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opBoolList(const ::Test::BoolList& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opBoolList(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opBoolList(const ::Test::BoolList& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opBoolList(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opBoolList(const ::Test::BoolList& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opBoolList(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opBoolList(const ::Test::BoolList& inSeq, const ::Test::Callback_TestIntf_opBoolListPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opBoolList(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opBoolList(const ::Test::BoolList& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opBoolListPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opBoolList(inSeq, context, cb, cookie);
    }

    ::Test::BoolList end_opBoolList(::Test::BoolList& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opBoolList(::Test::BoolList& iceP_outSeq, ::Test::BoolList& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opBoolList(const ::Test::BoolList&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    std::deque< ::Ice::Byte> opByteSeq(const std::deque< ::Ice::Byte>& inSeq, std::deque< ::Ice::Byte>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opByteSeq(outSeq, _iceI_begin_opByteSeq(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opByteSeq(const std::deque< ::Ice::Byte>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opByteSeq(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opByteSeq(const std::deque< ::Ice::Byte>& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByteSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opByteSeq(const std::deque< ::Ice::Byte>& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByteSeq(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opByteSeq(const std::deque< ::Ice::Byte>& inSeq, const ::Test::Callback_TestIntf_opByteSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByteSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opByteSeq(const std::deque< ::Ice::Byte>& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opByteSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByteSeq(inSeq, context, cb, cookie);
    }

    std::deque< ::Ice::Byte> end_opByteSeq(std::deque< ::Ice::Byte>& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opByteSeq(std::deque< ::Ice::Byte>& iceP_outSeq, std::deque< ::Ice::Byte>& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opByteSeq(const std::deque< ::Ice::Byte>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::ByteList opByteList(const ::Test::ByteList& inSeq, ::Test::ByteList& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opByteList(outSeq, _iceI_begin_opByteList(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opByteList(const ::Test::ByteList& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opByteList(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opByteList(const ::Test::ByteList& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByteList(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opByteList(const ::Test::ByteList& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByteList(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opByteList(const ::Test::ByteList& inSeq, const ::Test::Callback_TestIntf_opByteListPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByteList(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opByteList(const ::Test::ByteList& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opByteListPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByteList(inSeq, context, cb, cookie);
    }

    ::Test::ByteList end_opByteList(::Test::ByteList& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opByteList(::Test::ByteList& iceP_outSeq, ::Test::ByteList& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opByteList(const ::Test::ByteList&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    MyByteSeq opMyByteSeq(const MyByteSeq& inSeq, MyByteSeq& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opMyByteSeq(outSeq, _iceI_begin_opMyByteSeq(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opMyByteSeq(const MyByteSeq& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opMyByteSeq(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opMyByteSeq(const MyByteSeq& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opMyByteSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opMyByteSeq(const MyByteSeq& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opMyByteSeq(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opMyByteSeq(const MyByteSeq& inSeq, const ::Test::Callback_TestIntf_opMyByteSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opMyByteSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opMyByteSeq(const MyByteSeq& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opMyByteSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opMyByteSeq(inSeq, context, cb, cookie);
    }

    MyByteSeq end_opMyByteSeq(MyByteSeq& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opMyByteSeq(MyByteSeq& iceP_outSeq, MyByteSeq& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opMyByteSeq(const MyByteSeq&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::std::string opString(const Util::string_view& inString, ::std::string& outString, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opString(outString, _iceI_begin_opString(inString, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opString(const Util::string_view& inString, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opString(inString, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opString(const Util::string_view& inString, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opString(inString, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opString(const Util::string_view& inString, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opString(inString, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opString(const Util::string_view& inString, const ::Test::Callback_TestIntf_opStringPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opString(inString, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opString(const Util::string_view& inString, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opStringPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opString(inString, context, cb, cookie);
    }

    ::std::string end_opString(::std::string& outString, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opString(Util::string_view& iceP_outString, Util::string_view& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opString(const Util::string_view&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    std::deque<std::string> opStringSeq(const std::deque<std::string>& inSeq, std::deque<std::string>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opStringSeq(outSeq, _iceI_begin_opStringSeq(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opStringSeq(const std::deque<std::string>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opStringSeq(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opStringSeq(const std::deque<std::string>& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringSeq(const std::deque<std::string>& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringSeq(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringSeq(const std::deque<std::string>& inSeq, const ::Test::Callback_TestIntf_opStringSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringSeq(const std::deque<std::string>& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opStringSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringSeq(inSeq, context, cb, cookie);
    }

    std::deque<std::string> end_opStringSeq(std::deque<std::string>& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opStringSeq(std::deque<std::string>& iceP_outSeq, std::deque<std::string>& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opStringSeq(const std::deque<std::string>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::StringList opStringList(const ::Test::StringList& inSeq, ::Test::StringList& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opStringList(outSeq, _iceI_begin_opStringList(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opStringList(const ::Test::StringList& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opStringList(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opStringList(const ::Test::StringList& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringList(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringList(const ::Test::StringList& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringList(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringList(const ::Test::StringList& inSeq, const ::Test::Callback_TestIntf_opStringListPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringList(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringList(const ::Test::StringList& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opStringListPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringList(inSeq, context, cb, cookie);
    }

    ::Test::StringList end_opStringList(::Test::StringList& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opStringList(::Test::StringList& iceP_outSeq, ::Test::StringList& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opStringList(const ::Test::StringList&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    std::deque< ::Test::Fixed> opFixedSeq(const std::deque< ::Test::Fixed>& inSeq, std::deque< ::Test::Fixed>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opFixedSeq(outSeq, _iceI_begin_opFixedSeq(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opFixedSeq(const std::deque< ::Test::Fixed>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opFixedSeq(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opFixedSeq(const std::deque< ::Test::Fixed>& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opFixedSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opFixedSeq(const std::deque< ::Test::Fixed>& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opFixedSeq(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opFixedSeq(const std::deque< ::Test::Fixed>& inSeq, const ::Test::Callback_TestIntf_opFixedSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opFixedSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opFixedSeq(const std::deque< ::Test::Fixed>& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opFixedSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opFixedSeq(inSeq, context, cb, cookie);
    }

    std::deque< ::Test::Fixed> end_opFixedSeq(std::deque< ::Test::Fixed>& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opFixedSeq(std::deque< ::Test::Fixed>& iceP_outSeq, std::deque< ::Test::Fixed>& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opFixedSeq(const std::deque< ::Test::Fixed>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::FixedList opFixedList(const ::Test::FixedList& inSeq, ::Test::FixedList& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opFixedList(outSeq, _iceI_begin_opFixedList(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opFixedList(const ::Test::FixedList& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opFixedList(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opFixedList(const ::Test::FixedList& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opFixedList(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opFixedList(const ::Test::FixedList& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opFixedList(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opFixedList(const ::Test::FixedList& inSeq, const ::Test::Callback_TestIntf_opFixedListPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opFixedList(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opFixedList(const ::Test::FixedList& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opFixedListPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opFixedList(inSeq, context, cb, cookie);
    }

    ::Test::FixedList end_opFixedList(::Test::FixedList& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opFixedList(::Test::FixedList& iceP_outSeq, ::Test::FixedList& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opFixedList(const ::Test::FixedList&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    std::deque< ::Test::Variable> opVariableSeq(const std::deque< ::Test::Variable>& inSeq, std::deque< ::Test::Variable>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opVariableSeq(outSeq, _iceI_begin_opVariableSeq(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opVariableSeq(const std::deque< ::Test::Variable>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opVariableSeq(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opVariableSeq(const std::deque< ::Test::Variable>& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opVariableSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opVariableSeq(const std::deque< ::Test::Variable>& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opVariableSeq(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opVariableSeq(const std::deque< ::Test::Variable>& inSeq, const ::Test::Callback_TestIntf_opVariableSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opVariableSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opVariableSeq(const std::deque< ::Test::Variable>& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opVariableSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opVariableSeq(inSeq, context, cb, cookie);
    }

    std::deque< ::Test::Variable> end_opVariableSeq(std::deque< ::Test::Variable>& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opVariableSeq(std::deque< ::Test::Variable>& iceP_outSeq, std::deque< ::Test::Variable>& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opVariableSeq(const std::deque< ::Test::Variable>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::VariableList opVariableList(const ::Test::VariableList& inSeq, ::Test::VariableList& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opVariableList(outSeq, _iceI_begin_opVariableList(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opVariableList(const ::Test::VariableList& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opVariableList(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opVariableList(const ::Test::VariableList& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opVariableList(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opVariableList(const ::Test::VariableList& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opVariableList(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opVariableList(const ::Test::VariableList& inSeq, const ::Test::Callback_TestIntf_opVariableListPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opVariableList(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opVariableList(const ::Test::VariableList& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opVariableListPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opVariableList(inSeq, context, cb, cookie);
    }

    ::Test::VariableList end_opVariableList(::Test::VariableList& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opVariableList(::Test::VariableList& iceP_outSeq, ::Test::VariableList& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opVariableList(const ::Test::VariableList&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    std::deque< ::Test::StringStringDict> opStringStringDictSeq(const std::deque< ::Test::StringStringDict>& inSeq, std::deque< ::Test::StringStringDict>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opStringStringDictSeq(outSeq, _iceI_begin_opStringStringDictSeq(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opStringStringDictSeq(const std::deque< ::Test::StringStringDict>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opStringStringDictSeq(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opStringStringDictSeq(const std::deque< ::Test::StringStringDict>& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringStringDictSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringStringDictSeq(const std::deque< ::Test::StringStringDict>& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringStringDictSeq(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringStringDictSeq(const std::deque< ::Test::StringStringDict>& inSeq, const ::Test::Callback_TestIntf_opStringStringDictSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringStringDictSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringStringDictSeq(const std::deque< ::Test::StringStringDict>& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opStringStringDictSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringStringDictSeq(inSeq, context, cb, cookie);
    }

    std::deque< ::Test::StringStringDict> end_opStringStringDictSeq(std::deque< ::Test::StringStringDict>& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opStringStringDictSeq(std::deque< ::Test::StringStringDict>& iceP_outSeq, std::deque< ::Test::StringStringDict>& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opStringStringDictSeq(const std::deque< ::Test::StringStringDict>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::StringStringDictList opStringStringDictList(const ::Test::StringStringDictList& inSeq, ::Test::StringStringDictList& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opStringStringDictList(outSeq, _iceI_begin_opStringStringDictList(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opStringStringDictList(const ::Test::StringStringDictList& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opStringStringDictList(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opStringStringDictList(const ::Test::StringStringDictList& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringStringDictList(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringStringDictList(const ::Test::StringStringDictList& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringStringDictList(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringStringDictList(const ::Test::StringStringDictList& inSeq, const ::Test::Callback_TestIntf_opStringStringDictListPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringStringDictList(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringStringDictList(const ::Test::StringStringDictList& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opStringStringDictListPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringStringDictList(inSeq, context, cb, cookie);
    }

    ::Test::StringStringDictList end_opStringStringDictList(::Test::StringStringDictList& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opStringStringDictList(::Test::StringStringDictList& iceP_outSeq, ::Test::StringStringDictList& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opStringStringDictList(const ::Test::StringStringDictList&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    std::deque< ::Test::E> opESeq(const std::deque< ::Test::E>& inSeq, std::deque< ::Test::E>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opESeq(outSeq, _iceI_begin_opESeq(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opESeq(const std::deque< ::Test::E>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opESeq(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opESeq(const std::deque< ::Test::E>& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opESeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opESeq(const std::deque< ::Test::E>& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opESeq(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opESeq(const std::deque< ::Test::E>& inSeq, const ::Test::Callback_TestIntf_opESeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opESeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opESeq(const std::deque< ::Test::E>& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opESeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opESeq(inSeq, context, cb, cookie);
    }

    std::deque< ::Test::E> end_opESeq(std::deque< ::Test::E>& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opESeq(std::deque< ::Test::E>& iceP_outSeq, std::deque< ::Test::E>& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opESeq(const std::deque< ::Test::E>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::EList opEList(const ::Test::EList& inSeq, ::Test::EList& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opEList(outSeq, _iceI_begin_opEList(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opEList(const ::Test::EList& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opEList(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opEList(const ::Test::EList& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opEList(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opEList(const ::Test::EList& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opEList(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opEList(const ::Test::EList& inSeq, const ::Test::Callback_TestIntf_opEListPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opEList(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opEList(const ::Test::EList& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opEListPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opEList(inSeq, context, cb, cookie);
    }

    ::Test::EList end_opEList(::Test::EList& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opEList(::Test::EList& iceP_outSeq, ::Test::EList& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opEList(const ::Test::EList&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    std::deque< ::Test::DPrx> opDPrxSeq(const std::deque< ::Test::DPrx>& inSeq, std::deque< ::Test::DPrx>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opDPrxSeq(outSeq, _iceI_begin_opDPrxSeq(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opDPrxSeq(const std::deque< ::Test::DPrx>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opDPrxSeq(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opDPrxSeq(const std::deque< ::Test::DPrx>& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opDPrxSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opDPrxSeq(const std::deque< ::Test::DPrx>& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opDPrxSeq(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opDPrxSeq(const std::deque< ::Test::DPrx>& inSeq, const ::Test::Callback_TestIntf_opDPrxSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opDPrxSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opDPrxSeq(const std::deque< ::Test::DPrx>& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opDPrxSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opDPrxSeq(inSeq, context, cb, cookie);
    }

    std::deque< ::Test::DPrx> end_opDPrxSeq(std::deque< ::Test::DPrx>& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opDPrxSeq(std::deque< ::Test::DPrx>& iceP_outSeq, std::deque< ::Test::DPrx>& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opDPrxSeq(const std::deque< ::Test::DPrx>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::DPrxList opDPrxList(const ::Test::DPrxList& inSeq, ::Test::DPrxList& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opDPrxList(outSeq, _iceI_begin_opDPrxList(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opDPrxList(const ::Test::DPrxList& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opDPrxList(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opDPrxList(const ::Test::DPrxList& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opDPrxList(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opDPrxList(const ::Test::DPrxList& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opDPrxList(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opDPrxList(const ::Test::DPrxList& inSeq, const ::Test::Callback_TestIntf_opDPrxListPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opDPrxList(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opDPrxList(const ::Test::DPrxList& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opDPrxListPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opDPrxList(inSeq, context, cb, cookie);
    }

    ::Test::DPrxList end_opDPrxList(::Test::DPrxList& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opDPrxList(::Test::DPrxList& iceP_outSeq, ::Test::DPrxList& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opDPrxList(const ::Test::DPrxList&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    std::deque< ::Test::CPtr> opCSeq(const std::deque< ::Test::CPtr>& inSeq, std::deque< ::Test::CPtr>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opCSeq(outSeq, _iceI_begin_opCSeq(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opCSeq(const std::deque< ::Test::CPtr>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opCSeq(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opCSeq(const std::deque< ::Test::CPtr>& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opCSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opCSeq(const std::deque< ::Test::CPtr>& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opCSeq(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opCSeq(const std::deque< ::Test::CPtr>& inSeq, const ::Test::Callback_TestIntf_opCSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opCSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opCSeq(const std::deque< ::Test::CPtr>& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opCSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opCSeq(inSeq, context, cb, cookie);
    }

    std::deque< ::Test::CPtr> end_opCSeq(std::deque< ::Test::CPtr>& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opCSeq(std::deque< ::Test::CPtr>& iceP_outSeq, std::deque< ::Test::CPtr>& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opCSeq(const std::deque< ::Test::CPtr>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::CList opCList(const ::Test::CList& inSeq, ::Test::CList& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opCList(outSeq, _iceI_begin_opCList(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opCList(const ::Test::CList& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opCList(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opCList(const ::Test::CList& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opCList(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opCList(const ::Test::CList& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opCList(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opCList(const ::Test::CList& inSeq, const ::Test::Callback_TestIntf_opCListPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opCList(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opCList(const ::Test::CList& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opCListPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opCList(inSeq, context, cb, cookie);
    }

    ::Test::CList end_opCList(::Test::CList& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opCList(::Test::CList& iceP_outSeq, ::Test::CList& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opCList(const ::Test::CList&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::ClassStructPtr opClassStruct(const ::Test::ClassStructPtr& inS, const ::Test::ClassStructSeq& inSeq, ::Test::ClassStructPtr& outS, ::Test::ClassStructSeq& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opClassStruct(outS, outSeq, _iceI_begin_opClassStruct(inS, inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opClassStruct(const ::Test::ClassStructPtr& inS, const ::Test::ClassStructSeq& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opClassStruct(inS, inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opClassStruct(const ::Test::ClassStructPtr& inS, const ::Test::ClassStructSeq& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opClassStruct(inS, inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opClassStruct(const ::Test::ClassStructPtr& inS, const ::Test::ClassStructSeq& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opClassStruct(inS, inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opClassStruct(const ::Test::ClassStructPtr& inS, const ::Test::ClassStructSeq& inSeq, const ::Test::Callback_TestIntf_opClassStructPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opClassStruct(inS, inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opClassStruct(const ::Test::ClassStructPtr& inS, const ::Test::ClassStructSeq& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opClassStructPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opClassStruct(inS, inSeq, context, cb, cookie);
    }

    ::Test::ClassStructPtr end_opClassStruct(::Test::ClassStructPtr& outS, ::Test::ClassStructSeq& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opClassStruct(::Test::ClassStructPtr& iceP_outS, ::Test::ClassStructSeq& iceP_outSeq, ::Test::ClassStructPtr& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opClassStruct(const ::Test::ClassStructPtr&, const ::Test::ClassStructSeq&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void opOutArrayByteSeq(const ::Test::ByteSeq& org, ::Test::ByteSeq& copy, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_opOutArrayByteSeq(copy, _iceI_begin_opOutArrayByteSeq(org, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opOutArrayByteSeq(const ::Test::ByteSeq& org, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opOutArrayByteSeq(org, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opOutArrayByteSeq(const ::Test::ByteSeq& org, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOutArrayByteSeq(org, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opOutArrayByteSeq(const ::Test::ByteSeq& org, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOutArrayByteSeq(org, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opOutArrayByteSeq(const ::Test::ByteSeq& org, const ::Test::Callback_TestIntf_opOutArrayByteSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOutArrayByteSeq(org, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opOutArrayByteSeq(const ::Test::ByteSeq& org, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opOutArrayByteSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOutArrayByteSeq(org, context, cb, cookie);
    }

    void end_opOutArrayByteSeq(::Test::ByteSeq& copy, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opOutArrayByteSeq(::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>& iceP_copy, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opOutArrayByteSeq(const ::Test::ByteSeq&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void opOutRangeByteSeq(const ::Test::ByteSeq& org, ::Test::ByteSeq& copy, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_opOutRangeByteSeq(copy, _iceI_begin_opOutRangeByteSeq(org, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opOutRangeByteSeq(const ::Test::ByteSeq& org, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opOutRangeByteSeq(org, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opOutRangeByteSeq(const ::Test::ByteSeq& org, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOutRangeByteSeq(org, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opOutRangeByteSeq(const ::Test::ByteSeq& org, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOutRangeByteSeq(org, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opOutRangeByteSeq(const ::Test::ByteSeq& org, const ::Test::Callback_TestIntf_opOutRangeByteSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOutRangeByteSeq(org, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opOutRangeByteSeq(const ::Test::ByteSeq& org, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opOutRangeByteSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOutRangeByteSeq(org, context, cb, cookie);
    }

    void end_opOutRangeByteSeq(::Test::ByteSeq& copy, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opOutRangeByteSeq(::Test::ByteSeq& iceP_copy, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opOutRangeByteSeq(const ::Test::ByteSeq&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::IntStringDict opIntStringDict(const ::Test::IntStringDict& idict, ::Test::IntStringDict& odict, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opIntStringDict(odict, _iceI_begin_opIntStringDict(idict, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opIntStringDict(const ::Test::IntStringDict& idict, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opIntStringDict(idict, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opIntStringDict(const ::Test::IntStringDict& idict, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opIntStringDict(idict, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opIntStringDict(const ::Test::IntStringDict& idict, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opIntStringDict(idict, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opIntStringDict(const ::Test::IntStringDict& idict, const ::Test::Callback_TestIntf_opIntStringDictPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opIntStringDict(idict, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opIntStringDict(const ::Test::IntStringDict& idict, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opIntStringDictPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opIntStringDict(idict, context, cb, cookie);
    }

    ::Test::IntStringDict end_opIntStringDict(::Test::IntStringDict& odict, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opIntStringDict(::Test::IntStringDict& iceP_odict, ::Test::IntStringDict& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opIntStringDict(const ::Test::IntStringDict&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::CustomMap< ::Ice::Long, ::Ice::Long> opVarDict(const ::Test::CustomMap<std::string, ::Ice::Int>& idict, ::Test::CustomMap<std::string, ::Ice::Int>& odict, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opVarDict(odict, _iceI_begin_opVarDict(idict, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opVarDict(const ::Test::CustomMap<std::string, ::Ice::Int>& idict, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opVarDict(idict, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opVarDict(const ::Test::CustomMap<std::string, ::Ice::Int>& idict, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opVarDict(idict, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opVarDict(const ::Test::CustomMap<std::string, ::Ice::Int>& idict, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opVarDict(idict, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opVarDict(const ::Test::CustomMap<std::string, ::Ice::Int>& idict, const ::Test::Callback_TestIntf_opVarDictPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opVarDict(idict, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opVarDict(const ::Test::CustomMap<std::string, ::Ice::Int>& idict, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opVarDictPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opVarDict(idict, context, cb, cookie);
    }

    ::Test::CustomMap< ::Ice::Long, ::Ice::Long> end_opVarDict(::Test::CustomMap<std::string, ::Ice::Int>& odict, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opVarDict(::Test::CustomMap<std::string, ::Ice::Int>& iceP_odict, ::Test::CustomMap< ::Ice::Long, ::Ice::Long>& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opVarDict(const ::Test::CustomMap<std::string, ::Ice::Int>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::CustomMap< ::Ice::Int, std::string> opCustomIntStringDict(const ::std::map< ::Ice::Int, ::Util::string_view>& idict, ::Test::CustomMap< ::Ice::Int, std::string>& odict, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opCustomIntStringDict(odict, _iceI_begin_opCustomIntStringDict(idict, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opCustomIntStringDict(const ::std::map< ::Ice::Int, ::Util::string_view>& idict, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opCustomIntStringDict(idict, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opCustomIntStringDict(const ::std::map< ::Ice::Int, ::Util::string_view>& idict, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opCustomIntStringDict(idict, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opCustomIntStringDict(const ::std::map< ::Ice::Int, ::Util::string_view>& idict, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opCustomIntStringDict(idict, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opCustomIntStringDict(const ::std::map< ::Ice::Int, ::Util::string_view>& idict, const ::Test::Callback_TestIntf_opCustomIntStringDictPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opCustomIntStringDict(idict, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opCustomIntStringDict(const ::std::map< ::Ice::Int, ::Util::string_view>& idict, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opCustomIntStringDictPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opCustomIntStringDict(idict, context, cb, cookie);
    }

    ::Test::CustomMap< ::Ice::Int, std::string> end_opCustomIntStringDict(::Test::CustomMap< ::Ice::Int, std::string>& odict, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opCustomIntStringDict(::std::map< ::Ice::Int, ::Util::string_view>& iceP_odict, ::std::map< ::Ice::Int, ::Util::string_view>& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opCustomIntStringDict(const ::std::map< ::Ice::Int, ::Util::string_view>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::ShortBuffer opShortBuffer(const ::Test::ShortBuffer& inS, ::Test::ShortBuffer& outS, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opShortBuffer(outS, _iceI_begin_opShortBuffer(inS, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opShortBuffer(const ::Test::ShortBuffer& inS, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opShortBuffer(inS, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opShortBuffer(const ::Test::ShortBuffer& inS, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opShortBuffer(inS, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opShortBuffer(const ::Test::ShortBuffer& inS, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opShortBuffer(inS, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opShortBuffer(const ::Test::ShortBuffer& inS, const ::Test::Callback_TestIntf_opShortBufferPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opShortBuffer(inS, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opShortBuffer(const ::Test::ShortBuffer& inS, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opShortBufferPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opShortBuffer(inS, context, cb, cookie);
    }

    ::Test::ShortBuffer end_opShortBuffer(::Test::ShortBuffer& outS, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opShortBuffer(::Test::ShortBuffer& iceP_outS, ::Test::ShortBuffer& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opShortBuffer(const ::Test::ShortBuffer&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::CustomBuffer<bool> opBoolBuffer(const ::Test::CustomBuffer<bool>& inS, ::Test::CustomBuffer<bool>& outS, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opBoolBuffer(outS, _iceI_begin_opBoolBuffer(inS, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opBoolBuffer(const ::Test::CustomBuffer<bool>& inS, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opBoolBuffer(inS, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opBoolBuffer(const ::Test::CustomBuffer<bool>& inS, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opBoolBuffer(inS, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opBoolBuffer(const ::Test::CustomBuffer<bool>& inS, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opBoolBuffer(inS, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opBoolBuffer(const ::Test::CustomBuffer<bool>& inS, const ::Test::Callback_TestIntf_opBoolBufferPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opBoolBuffer(inS, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opBoolBuffer(const ::Test::CustomBuffer<bool>& inS, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opBoolBufferPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opBoolBuffer(inS, context, cb, cookie);
    }

    ::Test::CustomBuffer<bool> end_opBoolBuffer(::Test::CustomBuffer<bool>& outS, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opBoolBuffer(::Test::CustomBuffer<bool>& iceP_outS, ::Test::CustomBuffer<bool>& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opBoolBuffer(const ::Test::CustomBuffer<bool>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::BufferStruct opBufferStruct(const ::Test::BufferStruct& s, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opBufferStruct(_iceI_begin_opBufferStruct(s, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opBufferStruct(const ::Test::BufferStruct& s, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opBufferStruct(s, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opBufferStruct(const ::Test::BufferStruct& s, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opBufferStruct(s, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opBufferStruct(const ::Test::BufferStruct& s, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opBufferStruct(s, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opBufferStruct(const ::Test::BufferStruct& s, const ::Test::Callback_TestIntf_opBufferStructPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opBufferStruct(s, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opBufferStruct(const ::Test::BufferStruct& s, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opBufferStructPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opBufferStruct(s, context, cb, cookie);
    }

    ::Test::BufferStruct end_opBufferStruct(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_opBufferStruct(const ::Test::BufferStruct&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void shutdown(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_shutdown(_iceI_begin_shutdown(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_shutdown(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_shutdown(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_shutdown(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_shutdown(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_shutdown(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_shutdown(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_shutdown(const ::Test::Callback_TestIntf_shutdownPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_shutdown(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_shutdown(const ::Ice::Context& context, const ::Test::Callback_TestIntf_shutdownPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_shutdown(context, cb, cookie);
    }

    void end_shutdown(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_shutdown(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

}

}

namespace Test
{

class D : public virtual ::Ice::Object
{
public:

    typedef DPrx ProxyType;

    virtual ~D();
    D() = default;
    D(const D&) = default;
    D& operator=(const D&) = default;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();
};

class TestIntf : public virtual ::Ice::Object
{
public:

    typedef TestIntfPrx ProxyType;

    virtual ~TestIntf();
    TestIntf() = default;
    TestIntf(const TestIntf&) = default;
    TestIntf& operator=(const TestIntf&) = default;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void opDoubleArray_async(const ::Test::AMD_TestIntf_opDoubleArrayPtr& cb, const ::std::pair<const ::Ice::Double*, const ::Ice::Double*>& inSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opDoubleArray(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opBoolArray_async(const ::Test::AMD_TestIntf_opBoolArrayPtr& cb, const ::std::pair<const bool*, const bool*>& inSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opBoolArray(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opByteArray_async(const ::Test::AMD_TestIntf_opByteArrayPtr& cb, const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>& inSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opByteArray(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opVariableArray_async(const ::Test::AMD_TestIntf_opVariableArrayPtr& cb, const ::std::pair<const Variable*, const Variable*>& inSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opVariableArray(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opBoolRange_async(const ::Test::AMD_TestIntf_opBoolRangePtr& cb, const ::std::pair<BoolSeq::const_iterator, BoolSeq::const_iterator>& inSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opBoolRange(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opByteRange_async(const ::Test::AMD_TestIntf_opByteRangePtr& cb, const ::std::pair<ByteList::const_iterator, ByteList::const_iterator>& inSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opByteRange(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opVariableRange_async(const ::Test::AMD_TestIntf_opVariableRangePtr& cb, const ::std::pair<VariableList::const_iterator, VariableList::const_iterator>& inSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opVariableRange(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opByteRangeType_async(const ::Test::AMD_TestIntf_opByteRangeTypePtr& cb, const ::std::pair< ::Test::ByteList::const_iterator,  ::Test::ByteList::const_iterator>& inSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opByteRangeType(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opVariableRangeType_async(const ::Test::AMD_TestIntf_opVariableRangeTypePtr& cb, const ::std::pair<std::deque< ::Test::Variable>::const_iterator, std::deque< ::Test::Variable>::const_iterator>& inSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opVariableRangeType(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opBoolSeq_async(const ::Test::AMD_TestIntf_opBoolSeqPtr& cb, const std::deque<bool>& inSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opBoolSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opBoolList_async(const ::Test::AMD_TestIntf_opBoolListPtr& cb, const BoolList& inSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opBoolList(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opByteSeq_async(const ::Test::AMD_TestIntf_opByteSeqPtr& cb, const std::deque< ::Ice::Byte>& inSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opByteSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opByteList_async(const ::Test::AMD_TestIntf_opByteListPtr& cb, const ByteList& inSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opByteList(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opMyByteSeq_async(const ::Test::AMD_TestIntf_opMyByteSeqPtr& cb, const MyByteSeq& inSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opMyByteSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opString_async(const ::Test::AMD_TestIntf_opStringPtr& cb, const Util::string_view& inString, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opString(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opStringSeq_async(const ::Test::AMD_TestIntf_opStringSeqPtr& cb, const std::deque<std::string>& inSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opStringSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opStringList_async(const ::Test::AMD_TestIntf_opStringListPtr& cb, const StringList& inSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opStringList(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opFixedSeq_async(const ::Test::AMD_TestIntf_opFixedSeqPtr& cb, const std::deque< ::Test::Fixed>& inSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opFixedSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opFixedList_async(const ::Test::AMD_TestIntf_opFixedListPtr& cb, const FixedList& inSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opFixedList(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opVariableSeq_async(const ::Test::AMD_TestIntf_opVariableSeqPtr& cb, const std::deque< ::Test::Variable>& inSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opVariableSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opVariableList_async(const ::Test::AMD_TestIntf_opVariableListPtr& cb, const VariableList& inSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opVariableList(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opStringStringDictSeq_async(const ::Test::AMD_TestIntf_opStringStringDictSeqPtr& cb, const std::deque< ::Test::StringStringDict>& inSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opStringStringDictSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opStringStringDictList_async(const ::Test::AMD_TestIntf_opStringStringDictListPtr& cb, const StringStringDictList& inSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opStringStringDictList(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opESeq_async(const ::Test::AMD_TestIntf_opESeqPtr& cb, const std::deque< ::Test::E>& inSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opESeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opEList_async(const ::Test::AMD_TestIntf_opEListPtr& cb, const EList& inSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opEList(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opDPrxSeq_async(const ::Test::AMD_TestIntf_opDPrxSeqPtr& cb, const std::deque< ::Test::DPrx>& inSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opDPrxSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opDPrxList_async(const ::Test::AMD_TestIntf_opDPrxListPtr& cb, const DPrxList& inSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opDPrxList(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opCSeq_async(const ::Test::AMD_TestIntf_opCSeqPtr& cb, const std::deque< ::Test::CPtr>& inSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opCSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opCList_async(const ::Test::AMD_TestIntf_opCListPtr& cb, const CList& inSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opCList(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opClassStruct_async(const ::Test::AMD_TestIntf_opClassStructPtr& cb, const ClassStructPtr& inS, const ClassStructSeq& inSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opClassStruct(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opOutArrayByteSeq_async(const ::Test::AMD_TestIntf_opOutArrayByteSeqPtr& cb, const ByteSeq& org, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opOutArrayByteSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opOutRangeByteSeq_async(const ::Test::AMD_TestIntf_opOutRangeByteSeqPtr& cb, const ByteSeq& org, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opOutRangeByteSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opIntStringDict_async(const ::Test::AMD_TestIntf_opIntStringDictPtr& cb, const IntStringDict& idict, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opIntStringDict(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opVarDict_async(const ::Test::AMD_TestIntf_opVarDictPtr& cb, const ::Test::CustomMap<std::string, ::Ice::Int>& idict, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opVarDict(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opCustomIntStringDict_async(const ::Test::AMD_TestIntf_opCustomIntStringDictPtr& cb, const ::std::map< ::Ice::Int, ::Util::string_view>& idict, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opCustomIntStringDict(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opShortBuffer_async(const ::Test::AMD_TestIntf_opShortBufferPtr& cb, const ShortBuffer& inS, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opShortBuffer(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opBoolBuffer_async(const ::Test::AMD_TestIntf_opBoolBufferPtr& cb, const ::Test::CustomBuffer<bool>& inS, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opBoolBuffer(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opBufferStruct_async(const ::Test::AMD_TestIntf_opBufferStructPtr& cb, const BufferStruct& s, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opBufferStruct(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void shutdown_async(const ::Test::AMD_TestIntf_shutdownPtr& cb, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_shutdown(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond
};

}

namespace Test
{

class C : public ::Ice::ValueHelper<C, ::Ice::Value>
{
public:

    virtual ~C();

    C() = default;

    C(const C&) = default;
    C(C&&) = default;
    C& operator=(const C&) = default;
    C& operator=(C&&) = default;

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<> ice_tuple() const
    {
        return std::tie();
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();
};

/// \cond INTERNAL
static C _iceS_C_init;
/// \endcond

class DictClass : public ::Ice::ValueHelper<DictClass, ::Ice::Value>
{
public:

    virtual ~DictClass();

    DictClass() = default;

    DictClass(const DictClass&) = default;
    DictClass(DictClass&&) = default;
    DictClass& operator=(const DictClass&) = default;
    DictClass& operator=(DictClass&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit DictClass(const ::Test::IntStringDict& isdict) :
        isdict(isdict)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::Test::IntStringDict&> ice_tuple() const
    {
        return std::tie(isdict);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::Test::IntStringDict isdict;
};

}

/// \cond STREAM
namespace Ice
{

template<>
struct StreamableTraits< ::Test::Fixed>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 2;
    static const bool fixedLength = true;
};

template<typename S>
struct StreamWriter< ::Test::Fixed, S>
{
    static void write(S* ostr, const ::Test::Fixed& v)
    {
        ostr->write(v.s);
    }
};

template<typename S>
struct StreamReader< ::Test::Fixed, S>
{
    static void read(S* istr, ::Test::Fixed& v)
    {
        istr->read(v.s);
    }
};

template<>
struct StreamableTraits< ::Test::Variable>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 3;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::Test::Variable, S>
{
    static void write(S* ostr, const ::Test::Variable& v)
    {
        ostr->write(v.s);
        ostr->write(v.bl);
        ostr->write(v.ss);
    }
};

template<typename S>
struct StreamReader< ::Test::Variable, S>
{
    static void read(S* istr, ::Test::Variable& v)
    {
        istr->read(v.s);
        istr->read(v.bl);
        istr->read(v.ss);
    }
};

template<>
struct StreamableTraits< ::Test::E>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 2;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits< ::Test::ClassOtherStructPtr>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStructClass;
    static const int minWireSize = 4;
    static const bool fixedLength = true;
};

template<typename S>
struct StreamWriter< ::Test::ClassOtherStructPtr, S>
{
    static void write(S* ostr, const ::Test::ClassOtherStructPtr& v)
    {
        ostr->write(v->x);
    }
};

template<typename S>
struct StreamReader< ::Test::ClassOtherStructPtr, S>
{
    static void read(S* istr, ::Test::ClassOtherStructPtr& v)
    {
        istr->read(v->x);
    }
};

template<>
struct StreamableTraits< ::Test::ClassStructPtr>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStructClass;
    static const int minWireSize = 9;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::Test::ClassStructPtr, S>
{
    static void write(S* ostr, const ::Test::ClassStructPtr& v)
    {
        ostr->write(v->otherSeq);
        ostr->write(v->other);
        ostr->write(v->y);
    }
};

template<typename S>
struct StreamReader< ::Test::ClassStructPtr, S>
{
    static void read(S* istr, ::Test::ClassStructPtr& v)
    {
        istr->read(v->otherSeq);
        istr->read(v->other);
        istr->read(v->y);
    }
};

template<typename S>
struct StreamWriter< ::Test::DictClass, S>
{
    static void write(S* ostr, const ::Test::DictClass& v)
    {
        ostr->write(v.isdict);
    }
};

template<typename S>
struct StreamReader< ::Test::DictClass, S>
{
    static void read(S* istr, ::Test::DictClass& v)
    {
        istr->read(v.isdict);
    }
};

template<>
struct StreamableTraits< ::Test::BufferStruct>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 7;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::Test::BufferStruct, S>
{
    static void write(S* ostr, const ::Test::BufferStruct& v)
    {
        ostr->write(v.byteBuf);
        ostr->write(v.boolBuf);
        ostr->write(v.shortBuf);
        ostr->write(v.intBuf);
        ostr->write(v.longBuf);
        ostr->write(v.floatBuf);
        ostr->write(v.doubleBuf);
    }
};

template<typename S>
struct StreamReader< ::Test::BufferStruct, S>
{
    static void read(S* istr, ::Test::BufferStruct& v)
    {
        istr->read(v.byteBuf);
        istr->read(v.boolBuf);
        istr->read(v.shortBuf);
        istr->read(v.intBuf);
        istr->read(v.longBuf);
        istr->read(v.floatBuf);
        istr->read(v.doubleBuf);
    }
};

}
/// \endcond

namespace Test
{

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opDoubleArray.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opDoubleArray.
 */
template<class T>
class CallbackNC_TestIntf_opDoubleArray : public Callback_TestIntf_opDoubleArray_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const DoubleSeq&, const DoubleSeq&);

    CallbackNC_TestIntf_opDoubleArray(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        DoubleSeq iceP_outSeq;
        DoubleSeq ret;
        try
        {
            ret = proxy->end_opDoubleArray(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opDoubleArray.
 */
template<class T> Callback_TestIntf_opDoubleArrayPtr
newCallback_TestIntf_opDoubleArray(const IceUtil::Handle<T>& instance, void (T::*cb)(const DoubleSeq&, const DoubleSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opDoubleArray<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opDoubleArray.
 */
template<class T> Callback_TestIntf_opDoubleArrayPtr
newCallback_TestIntf_opDoubleArray(T* instance, void (T::*cb)(const DoubleSeq&, const DoubleSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opDoubleArray<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opDoubleArray.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opDoubleArray.
 */
template<class T, typename CT>
class Callback_TestIntf_opDoubleArray : public Callback_TestIntf_opDoubleArray_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const DoubleSeq&, const DoubleSeq&, const CT&);

    Callback_TestIntf_opDoubleArray(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        DoubleSeq iceP_outSeq;
        DoubleSeq ret;
        try
        {
            ret = proxy->end_opDoubleArray(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opDoubleArray.
 */
template<class T, typename CT> Callback_TestIntf_opDoubleArrayPtr
newCallback_TestIntf_opDoubleArray(const IceUtil::Handle<T>& instance, void (T::*cb)(const DoubleSeq&, const DoubleSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opDoubleArray<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opDoubleArray.
 */
template<class T, typename CT> Callback_TestIntf_opDoubleArrayPtr
newCallback_TestIntf_opDoubleArray(T* instance, void (T::*cb)(const DoubleSeq&, const DoubleSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opDoubleArray<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opBoolArray.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opBoolArray.
 */
template<class T>
class CallbackNC_TestIntf_opBoolArray : public Callback_TestIntf_opBoolArray_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const BoolSeq&, const BoolSeq&);

    CallbackNC_TestIntf_opBoolArray(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        BoolSeq iceP_outSeq;
        BoolSeq ret;
        try
        {
            ret = proxy->end_opBoolArray(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opBoolArray.
 */
template<class T> Callback_TestIntf_opBoolArrayPtr
newCallback_TestIntf_opBoolArray(const IceUtil::Handle<T>& instance, void (T::*cb)(const BoolSeq&, const BoolSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opBoolArray<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opBoolArray.
 */
template<class T> Callback_TestIntf_opBoolArrayPtr
newCallback_TestIntf_opBoolArray(T* instance, void (T::*cb)(const BoolSeq&, const BoolSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opBoolArray<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opBoolArray.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opBoolArray.
 */
template<class T, typename CT>
class Callback_TestIntf_opBoolArray : public Callback_TestIntf_opBoolArray_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const BoolSeq&, const BoolSeq&, const CT&);

    Callback_TestIntf_opBoolArray(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        BoolSeq iceP_outSeq;
        BoolSeq ret;
        try
        {
            ret = proxy->end_opBoolArray(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opBoolArray.
 */
template<class T, typename CT> Callback_TestIntf_opBoolArrayPtr
newCallback_TestIntf_opBoolArray(const IceUtil::Handle<T>& instance, void (T::*cb)(const BoolSeq&, const BoolSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opBoolArray<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opBoolArray.
 */
template<class T, typename CT> Callback_TestIntf_opBoolArrayPtr
newCallback_TestIntf_opBoolArray(T* instance, void (T::*cb)(const BoolSeq&, const BoolSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opBoolArray<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opByteArray.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opByteArray.
 */
template<class T>
class CallbackNC_TestIntf_opByteArray : public Callback_TestIntf_opByteArray_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>&, const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>&);

    CallbackNC_TestIntf_opByteArray(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*> iceP_outSeq;
        ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*> ret;
        try
        {
            proxy->_iceI_end_opByteArray(iceP_outSeq, ret, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opByteArray.
 */
template<class T> Callback_TestIntf_opByteArrayPtr
newCallback_TestIntf_opByteArray(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>&, const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opByteArray<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opByteArray.
 */
template<class T> Callback_TestIntf_opByteArrayPtr
newCallback_TestIntf_opByteArray(T* instance, void (T::*cb)(const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>&, const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opByteArray<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opByteArray.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opByteArray.
 */
template<class T, typename CT>
class Callback_TestIntf_opByteArray : public Callback_TestIntf_opByteArray_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>&, const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>&, const CT&);

    Callback_TestIntf_opByteArray(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*> iceP_outSeq;
        ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*> ret;
        try
        {
            proxy->_iceI_end_opByteArray(iceP_outSeq, ret, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opByteArray.
 */
template<class T, typename CT> Callback_TestIntf_opByteArrayPtr
newCallback_TestIntf_opByteArray(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>&, const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opByteArray<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opByteArray.
 */
template<class T, typename CT> Callback_TestIntf_opByteArrayPtr
newCallback_TestIntf_opByteArray(T* instance, void (T::*cb)(const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>&, const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opByteArray<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opVariableArray.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opVariableArray.
 */
template<class T>
class CallbackNC_TestIntf_opVariableArray : public Callback_TestIntf_opVariableArray_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const VariableList&, const VariableList&);

    CallbackNC_TestIntf_opVariableArray(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        VariableList iceP_outSeq;
        VariableList ret;
        try
        {
            ret = proxy->end_opVariableArray(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opVariableArray.
 */
template<class T> Callback_TestIntf_opVariableArrayPtr
newCallback_TestIntf_opVariableArray(const IceUtil::Handle<T>& instance, void (T::*cb)(const VariableList&, const VariableList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opVariableArray<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opVariableArray.
 */
template<class T> Callback_TestIntf_opVariableArrayPtr
newCallback_TestIntf_opVariableArray(T* instance, void (T::*cb)(const VariableList&, const VariableList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opVariableArray<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opVariableArray.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opVariableArray.
 */
template<class T, typename CT>
class Callback_TestIntf_opVariableArray : public Callback_TestIntf_opVariableArray_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const VariableList&, const VariableList&, const CT&);

    Callback_TestIntf_opVariableArray(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        VariableList iceP_outSeq;
        VariableList ret;
        try
        {
            ret = proxy->end_opVariableArray(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opVariableArray.
 */
template<class T, typename CT> Callback_TestIntf_opVariableArrayPtr
newCallback_TestIntf_opVariableArray(const IceUtil::Handle<T>& instance, void (T::*cb)(const VariableList&, const VariableList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opVariableArray<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opVariableArray.
 */
template<class T, typename CT> Callback_TestIntf_opVariableArrayPtr
newCallback_TestIntf_opVariableArray(T* instance, void (T::*cb)(const VariableList&, const VariableList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opVariableArray<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opBoolRange.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opBoolRange.
 */
template<class T>
class CallbackNC_TestIntf_opBoolRange : public Callback_TestIntf_opBoolRange_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const BoolSeq&, const BoolSeq&);

    CallbackNC_TestIntf_opBoolRange(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        BoolSeq iceP_outSeq;
        BoolSeq ret;
        try
        {
            ret = proxy->end_opBoolRange(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opBoolRange.
 */
template<class T> Callback_TestIntf_opBoolRangePtr
newCallback_TestIntf_opBoolRange(const IceUtil::Handle<T>& instance, void (T::*cb)(const BoolSeq&, const BoolSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opBoolRange<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opBoolRange.
 */
template<class T> Callback_TestIntf_opBoolRangePtr
newCallback_TestIntf_opBoolRange(T* instance, void (T::*cb)(const BoolSeq&, const BoolSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opBoolRange<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opBoolRange.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opBoolRange.
 */
template<class T, typename CT>
class Callback_TestIntf_opBoolRange : public Callback_TestIntf_opBoolRange_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const BoolSeq&, const BoolSeq&, const CT&);

    Callback_TestIntf_opBoolRange(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        BoolSeq iceP_outSeq;
        BoolSeq ret;
        try
        {
            ret = proxy->end_opBoolRange(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opBoolRange.
 */
template<class T, typename CT> Callback_TestIntf_opBoolRangePtr
newCallback_TestIntf_opBoolRange(const IceUtil::Handle<T>& instance, void (T::*cb)(const BoolSeq&, const BoolSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opBoolRange<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opBoolRange.
 */
template<class T, typename CT> Callback_TestIntf_opBoolRangePtr
newCallback_TestIntf_opBoolRange(T* instance, void (T::*cb)(const BoolSeq&, const BoolSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opBoolRange<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opByteRange.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opByteRange.
 */
template<class T>
class CallbackNC_TestIntf_opByteRange : public Callback_TestIntf_opByteRange_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::pair<ByteList::const_iterator, ByteList::const_iterator>&, const ::std::pair<ByteList::const_iterator, ByteList::const_iterator>&);

    CallbackNC_TestIntf_opByteRange(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        ::std::pair<ByteList::const_iterator, ByteList::const_iterator> iceP_outSeq;
        ByteList iceP_outSeq_tmp_;
        ::std::pair<ByteList::const_iterator, ByteList::const_iterator> ret;
        ByteList ret_tmp_;
        try
        {
            ret_tmp_ = proxy->end_opByteRange(iceP_outSeq_tmp_, result);
            iceP_outSeq.first = iceP_outSeq_tmp_.begin();
            iceP_outSeq.second = iceP_outSeq_tmp_.end();
            ret.first = ret_tmp_.begin();
            ret.second = ret_tmp_.end();
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opByteRange.
 */
template<class T> Callback_TestIntf_opByteRangePtr
newCallback_TestIntf_opByteRange(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::pair<ByteList::const_iterator, ByteList::const_iterator>&, const ::std::pair<ByteList::const_iterator, ByteList::const_iterator>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opByteRange<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opByteRange.
 */
template<class T> Callback_TestIntf_opByteRangePtr
newCallback_TestIntf_opByteRange(T* instance, void (T::*cb)(const ::std::pair<ByteList::const_iterator, ByteList::const_iterator>&, const ::std::pair<ByteList::const_iterator, ByteList::const_iterator>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opByteRange<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opByteRange.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opByteRange.
 */
template<class T, typename CT>
class Callback_TestIntf_opByteRange : public Callback_TestIntf_opByteRange_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::pair<ByteList::const_iterator, ByteList::const_iterator>&, const ::std::pair<ByteList::const_iterator, ByteList::const_iterator>&, const CT&);

    Callback_TestIntf_opByteRange(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        ::std::pair<ByteList::const_iterator, ByteList::const_iterator> iceP_outSeq;
        ByteList iceP_outSeq_tmp_;
        ::std::pair<ByteList::const_iterator, ByteList::const_iterator> ret;
        ByteList ret_tmp_;
        try
        {
            ret_tmp_ = proxy->end_opByteRange(iceP_outSeq_tmp_, result);
            iceP_outSeq.first = iceP_outSeq_tmp_.begin();
            iceP_outSeq.second = iceP_outSeq_tmp_.end();
            ret.first = ret_tmp_.begin();
            ret.second = ret_tmp_.end();
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opByteRange.
 */
template<class T, typename CT> Callback_TestIntf_opByteRangePtr
newCallback_TestIntf_opByteRange(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::pair<ByteList::const_iterator, ByteList::const_iterator>&, const ::std::pair<ByteList::const_iterator, ByteList::const_iterator>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opByteRange<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opByteRange.
 */
template<class T, typename CT> Callback_TestIntf_opByteRangePtr
newCallback_TestIntf_opByteRange(T* instance, void (T::*cb)(const ::std::pair<ByteList::const_iterator, ByteList::const_iterator>&, const ::std::pair<ByteList::const_iterator, ByteList::const_iterator>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opByteRange<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opVariableRange.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opVariableRange.
 */
template<class T>
class CallbackNC_TestIntf_opVariableRange : public Callback_TestIntf_opVariableRange_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const VariableList&, const VariableList&);

    CallbackNC_TestIntf_opVariableRange(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        VariableList iceP_outSeq;
        VariableList ret;
        try
        {
            ret = proxy->end_opVariableRange(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opVariableRange.
 */
template<class T> Callback_TestIntf_opVariableRangePtr
newCallback_TestIntf_opVariableRange(const IceUtil::Handle<T>& instance, void (T::*cb)(const VariableList&, const VariableList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opVariableRange<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opVariableRange.
 */
template<class T> Callback_TestIntf_opVariableRangePtr
newCallback_TestIntf_opVariableRange(T* instance, void (T::*cb)(const VariableList&, const VariableList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opVariableRange<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opVariableRange.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opVariableRange.
 */
template<class T, typename CT>
class Callback_TestIntf_opVariableRange : public Callback_TestIntf_opVariableRange_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const VariableList&, const VariableList&, const CT&);

    Callback_TestIntf_opVariableRange(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        VariableList iceP_outSeq;
        VariableList ret;
        try
        {
            ret = proxy->end_opVariableRange(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opVariableRange.
 */
template<class T, typename CT> Callback_TestIntf_opVariableRangePtr
newCallback_TestIntf_opVariableRange(const IceUtil::Handle<T>& instance, void (T::*cb)(const VariableList&, const VariableList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opVariableRange<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opVariableRange.
 */
template<class T, typename CT> Callback_TestIntf_opVariableRangePtr
newCallback_TestIntf_opVariableRange(T* instance, void (T::*cb)(const VariableList&, const VariableList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opVariableRange<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opByteRangeType.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opByteRangeType.
 */
template<class T>
class CallbackNC_TestIntf_opByteRangeType : public Callback_TestIntf_opByteRangeType_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ByteList&, const ByteList&);

    CallbackNC_TestIntf_opByteRangeType(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        ByteList iceP_outSeq;
        ByteList ret;
        try
        {
            ret = proxy->end_opByteRangeType(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opByteRangeType.
 */
template<class T> Callback_TestIntf_opByteRangeTypePtr
newCallback_TestIntf_opByteRangeType(const IceUtil::Handle<T>& instance, void (T::*cb)(const ByteList&, const ByteList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opByteRangeType<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opByteRangeType.
 */
template<class T> Callback_TestIntf_opByteRangeTypePtr
newCallback_TestIntf_opByteRangeType(T* instance, void (T::*cb)(const ByteList&, const ByteList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opByteRangeType<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opByteRangeType.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opByteRangeType.
 */
template<class T, typename CT>
class Callback_TestIntf_opByteRangeType : public Callback_TestIntf_opByteRangeType_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ByteList&, const ByteList&, const CT&);

    Callback_TestIntf_opByteRangeType(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        ByteList iceP_outSeq;
        ByteList ret;
        try
        {
            ret = proxy->end_opByteRangeType(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opByteRangeType.
 */
template<class T, typename CT> Callback_TestIntf_opByteRangeTypePtr
newCallback_TestIntf_opByteRangeType(const IceUtil::Handle<T>& instance, void (T::*cb)(const ByteList&, const ByteList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opByteRangeType<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opByteRangeType.
 */
template<class T, typename CT> Callback_TestIntf_opByteRangeTypePtr
newCallback_TestIntf_opByteRangeType(T* instance, void (T::*cb)(const ByteList&, const ByteList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opByteRangeType<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opVariableRangeType.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opVariableRangeType.
 */
template<class T>
class CallbackNC_TestIntf_opVariableRangeType : public Callback_TestIntf_opVariableRangeType_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const VariableList&, const VariableList&);

    CallbackNC_TestIntf_opVariableRangeType(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        VariableList iceP_outSeq;
        VariableList ret;
        try
        {
            ret = proxy->end_opVariableRangeType(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opVariableRangeType.
 */
template<class T> Callback_TestIntf_opVariableRangeTypePtr
newCallback_TestIntf_opVariableRangeType(const IceUtil::Handle<T>& instance, void (T::*cb)(const VariableList&, const VariableList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opVariableRangeType<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opVariableRangeType.
 */
template<class T> Callback_TestIntf_opVariableRangeTypePtr
newCallback_TestIntf_opVariableRangeType(T* instance, void (T::*cb)(const VariableList&, const VariableList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opVariableRangeType<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opVariableRangeType.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opVariableRangeType.
 */
template<class T, typename CT>
class Callback_TestIntf_opVariableRangeType : public Callback_TestIntf_opVariableRangeType_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const VariableList&, const VariableList&, const CT&);

    Callback_TestIntf_opVariableRangeType(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        VariableList iceP_outSeq;
        VariableList ret;
        try
        {
            ret = proxy->end_opVariableRangeType(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opVariableRangeType.
 */
template<class T, typename CT> Callback_TestIntf_opVariableRangeTypePtr
newCallback_TestIntf_opVariableRangeType(const IceUtil::Handle<T>& instance, void (T::*cb)(const VariableList&, const VariableList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opVariableRangeType<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opVariableRangeType.
 */
template<class T, typename CT> Callback_TestIntf_opVariableRangeTypePtr
newCallback_TestIntf_opVariableRangeType(T* instance, void (T::*cb)(const VariableList&, const VariableList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opVariableRangeType<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opBoolSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opBoolSeq.
 */
template<class T>
class CallbackNC_TestIntf_opBoolSeq : public Callback_TestIntf_opBoolSeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const std::deque<bool>&, const std::deque<bool>&);

    CallbackNC_TestIntf_opBoolSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        std::deque<bool> iceP_outSeq;
        std::deque<bool> ret;
        try
        {
            ret = proxy->end_opBoolSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opBoolSeq.
 */
template<class T> Callback_TestIntf_opBoolSeqPtr
newCallback_TestIntf_opBoolSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const std::deque<bool>&, const std::deque<bool>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opBoolSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opBoolSeq.
 */
template<class T> Callback_TestIntf_opBoolSeqPtr
newCallback_TestIntf_opBoolSeq(T* instance, void (T::*cb)(const std::deque<bool>&, const std::deque<bool>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opBoolSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opBoolSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opBoolSeq.
 */
template<class T, typename CT>
class Callback_TestIntf_opBoolSeq : public Callback_TestIntf_opBoolSeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const std::deque<bool>&, const std::deque<bool>&, const CT&);

    Callback_TestIntf_opBoolSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        std::deque<bool> iceP_outSeq;
        std::deque<bool> ret;
        try
        {
            ret = proxy->end_opBoolSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opBoolSeq.
 */
template<class T, typename CT> Callback_TestIntf_opBoolSeqPtr
newCallback_TestIntf_opBoolSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const std::deque<bool>&, const std::deque<bool>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opBoolSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opBoolSeq.
 */
template<class T, typename CT> Callback_TestIntf_opBoolSeqPtr
newCallback_TestIntf_opBoolSeq(T* instance, void (T::*cb)(const std::deque<bool>&, const std::deque<bool>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opBoolSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opBoolList.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opBoolList.
 */
template<class T>
class CallbackNC_TestIntf_opBoolList : public Callback_TestIntf_opBoolList_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const BoolList&, const BoolList&);

    CallbackNC_TestIntf_opBoolList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        BoolList iceP_outSeq;
        BoolList ret;
        try
        {
            ret = proxy->end_opBoolList(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opBoolList.
 */
template<class T> Callback_TestIntf_opBoolListPtr
newCallback_TestIntf_opBoolList(const IceUtil::Handle<T>& instance, void (T::*cb)(const BoolList&, const BoolList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opBoolList<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opBoolList.
 */
template<class T> Callback_TestIntf_opBoolListPtr
newCallback_TestIntf_opBoolList(T* instance, void (T::*cb)(const BoolList&, const BoolList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opBoolList<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opBoolList.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opBoolList.
 */
template<class T, typename CT>
class Callback_TestIntf_opBoolList : public Callback_TestIntf_opBoolList_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const BoolList&, const BoolList&, const CT&);

    Callback_TestIntf_opBoolList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        BoolList iceP_outSeq;
        BoolList ret;
        try
        {
            ret = proxy->end_opBoolList(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opBoolList.
 */
template<class T, typename CT> Callback_TestIntf_opBoolListPtr
newCallback_TestIntf_opBoolList(const IceUtil::Handle<T>& instance, void (T::*cb)(const BoolList&, const BoolList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opBoolList<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opBoolList.
 */
template<class T, typename CT> Callback_TestIntf_opBoolListPtr
newCallback_TestIntf_opBoolList(T* instance, void (T::*cb)(const BoolList&, const BoolList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opBoolList<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opByteSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opByteSeq.
 */
template<class T>
class CallbackNC_TestIntf_opByteSeq : public Callback_TestIntf_opByteSeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const std::deque< ::Ice::Byte>&, const std::deque< ::Ice::Byte>&);

    CallbackNC_TestIntf_opByteSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        std::deque< ::Ice::Byte> iceP_outSeq;
        std::deque< ::Ice::Byte> ret;
        try
        {
            ret = proxy->end_opByteSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opByteSeq.
 */
template<class T> Callback_TestIntf_opByteSeqPtr
newCallback_TestIntf_opByteSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const std::deque< ::Ice::Byte>&, const std::deque< ::Ice::Byte>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opByteSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opByteSeq.
 */
template<class T> Callback_TestIntf_opByteSeqPtr
newCallback_TestIntf_opByteSeq(T* instance, void (T::*cb)(const std::deque< ::Ice::Byte>&, const std::deque< ::Ice::Byte>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opByteSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opByteSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opByteSeq.
 */
template<class T, typename CT>
class Callback_TestIntf_opByteSeq : public Callback_TestIntf_opByteSeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const std::deque< ::Ice::Byte>&, const std::deque< ::Ice::Byte>&, const CT&);

    Callback_TestIntf_opByteSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        std::deque< ::Ice::Byte> iceP_outSeq;
        std::deque< ::Ice::Byte> ret;
        try
        {
            ret = proxy->end_opByteSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opByteSeq.
 */
template<class T, typename CT> Callback_TestIntf_opByteSeqPtr
newCallback_TestIntf_opByteSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const std::deque< ::Ice::Byte>&, const std::deque< ::Ice::Byte>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opByteSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opByteSeq.
 */
template<class T, typename CT> Callback_TestIntf_opByteSeqPtr
newCallback_TestIntf_opByteSeq(T* instance, void (T::*cb)(const std::deque< ::Ice::Byte>&, const std::deque< ::Ice::Byte>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opByteSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opByteList.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opByteList.
 */
template<class T>
class CallbackNC_TestIntf_opByteList : public Callback_TestIntf_opByteList_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ByteList&, const ByteList&);

    CallbackNC_TestIntf_opByteList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        ByteList iceP_outSeq;
        ByteList ret;
        try
        {
            ret = proxy->end_opByteList(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opByteList.
 */
template<class T> Callback_TestIntf_opByteListPtr
newCallback_TestIntf_opByteList(const IceUtil::Handle<T>& instance, void (T::*cb)(const ByteList&, const ByteList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opByteList<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opByteList.
 */
template<class T> Callback_TestIntf_opByteListPtr
newCallback_TestIntf_opByteList(T* instance, void (T::*cb)(const ByteList&, const ByteList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opByteList<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opByteList.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opByteList.
 */
template<class T, typename CT>
class Callback_TestIntf_opByteList : public Callback_TestIntf_opByteList_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ByteList&, const ByteList&, const CT&);

    Callback_TestIntf_opByteList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        ByteList iceP_outSeq;
        ByteList ret;
        try
        {
            ret = proxy->end_opByteList(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opByteList.
 */
template<class T, typename CT> Callback_TestIntf_opByteListPtr
newCallback_TestIntf_opByteList(const IceUtil::Handle<T>& instance, void (T::*cb)(const ByteList&, const ByteList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opByteList<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opByteList.
 */
template<class T, typename CT> Callback_TestIntf_opByteListPtr
newCallback_TestIntf_opByteList(T* instance, void (T::*cb)(const ByteList&, const ByteList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opByteList<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opMyByteSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opMyByteSeq.
 */
template<class T>
class CallbackNC_TestIntf_opMyByteSeq : public Callback_TestIntf_opMyByteSeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const MyByteSeq&, const MyByteSeq&);

    CallbackNC_TestIntf_opMyByteSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        MyByteSeq iceP_outSeq;
        MyByteSeq ret;
        try
        {
            ret = proxy->end_opMyByteSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opMyByteSeq.
 */
template<class T> Callback_TestIntf_opMyByteSeqPtr
newCallback_TestIntf_opMyByteSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const MyByteSeq&, const MyByteSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opMyByteSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opMyByteSeq.
 */
template<class T> Callback_TestIntf_opMyByteSeqPtr
newCallback_TestIntf_opMyByteSeq(T* instance, void (T::*cb)(const MyByteSeq&, const MyByteSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opMyByteSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opMyByteSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opMyByteSeq.
 */
template<class T, typename CT>
class Callback_TestIntf_opMyByteSeq : public Callback_TestIntf_opMyByteSeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const MyByteSeq&, const MyByteSeq&, const CT&);

    Callback_TestIntf_opMyByteSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        MyByteSeq iceP_outSeq;
        MyByteSeq ret;
        try
        {
            ret = proxy->end_opMyByteSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opMyByteSeq.
 */
template<class T, typename CT> Callback_TestIntf_opMyByteSeqPtr
newCallback_TestIntf_opMyByteSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const MyByteSeq&, const MyByteSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opMyByteSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opMyByteSeq.
 */
template<class T, typename CT> Callback_TestIntf_opMyByteSeqPtr
newCallback_TestIntf_opMyByteSeq(T* instance, void (T::*cb)(const MyByteSeq&, const MyByteSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opMyByteSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opString.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opString.
 */
template<class T>
class CallbackNC_TestIntf_opString : public Callback_TestIntf_opString_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const Util::string_view&, const Util::string_view&);

    CallbackNC_TestIntf_opString(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        Util::string_view iceP_outString;
        Util::string_view ret;
        try
        {
            proxy->_iceI_end_opString(iceP_outString, ret, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outString);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opString.
 */
template<class T> Callback_TestIntf_opStringPtr
newCallback_TestIntf_opString(const IceUtil::Handle<T>& instance, void (T::*cb)(const Util::string_view&, const Util::string_view&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opString<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opString.
 */
template<class T> Callback_TestIntf_opStringPtr
newCallback_TestIntf_opString(T* instance, void (T::*cb)(const Util::string_view&, const Util::string_view&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opString<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opString.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opString.
 */
template<class T, typename CT>
class Callback_TestIntf_opString : public Callback_TestIntf_opString_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const Util::string_view&, const Util::string_view&, const CT&);

    Callback_TestIntf_opString(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        Util::string_view iceP_outString;
        Util::string_view ret;
        try
        {
            proxy->_iceI_end_opString(iceP_outString, ret, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outString, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opString.
 */
template<class T, typename CT> Callback_TestIntf_opStringPtr
newCallback_TestIntf_opString(const IceUtil::Handle<T>& instance, void (T::*cb)(const Util::string_view&, const Util::string_view&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opString<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opString.
 */
template<class T, typename CT> Callback_TestIntf_opStringPtr
newCallback_TestIntf_opString(T* instance, void (T::*cb)(const Util::string_view&, const Util::string_view&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opString<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opStringSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opStringSeq.
 */
template<class T>
class CallbackNC_TestIntf_opStringSeq : public Callback_TestIntf_opStringSeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const std::deque<std::string>&, const std::deque<std::string>&);

    CallbackNC_TestIntf_opStringSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        std::deque<std::string> iceP_outSeq;
        std::deque<std::string> ret;
        try
        {
            ret = proxy->end_opStringSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opStringSeq.
 */
template<class T> Callback_TestIntf_opStringSeqPtr
newCallback_TestIntf_opStringSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const std::deque<std::string>&, const std::deque<std::string>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opStringSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opStringSeq.
 */
template<class T> Callback_TestIntf_opStringSeqPtr
newCallback_TestIntf_opStringSeq(T* instance, void (T::*cb)(const std::deque<std::string>&, const std::deque<std::string>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opStringSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opStringSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opStringSeq.
 */
template<class T, typename CT>
class Callback_TestIntf_opStringSeq : public Callback_TestIntf_opStringSeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const std::deque<std::string>&, const std::deque<std::string>&, const CT&);

    Callback_TestIntf_opStringSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        std::deque<std::string> iceP_outSeq;
        std::deque<std::string> ret;
        try
        {
            ret = proxy->end_opStringSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opStringSeq.
 */
template<class T, typename CT> Callback_TestIntf_opStringSeqPtr
newCallback_TestIntf_opStringSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const std::deque<std::string>&, const std::deque<std::string>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opStringSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opStringSeq.
 */
template<class T, typename CT> Callback_TestIntf_opStringSeqPtr
newCallback_TestIntf_opStringSeq(T* instance, void (T::*cb)(const std::deque<std::string>&, const std::deque<std::string>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opStringSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opStringList.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opStringList.
 */
template<class T>
class CallbackNC_TestIntf_opStringList : public Callback_TestIntf_opStringList_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const StringList&, const StringList&);

    CallbackNC_TestIntf_opStringList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        StringList iceP_outSeq;
        StringList ret;
        try
        {
            ret = proxy->end_opStringList(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opStringList.
 */
template<class T> Callback_TestIntf_opStringListPtr
newCallback_TestIntf_opStringList(const IceUtil::Handle<T>& instance, void (T::*cb)(const StringList&, const StringList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opStringList<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opStringList.
 */
template<class T> Callback_TestIntf_opStringListPtr
newCallback_TestIntf_opStringList(T* instance, void (T::*cb)(const StringList&, const StringList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opStringList<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opStringList.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opStringList.
 */
template<class T, typename CT>
class Callback_TestIntf_opStringList : public Callback_TestIntf_opStringList_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const StringList&, const StringList&, const CT&);

    Callback_TestIntf_opStringList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        StringList iceP_outSeq;
        StringList ret;
        try
        {
            ret = proxy->end_opStringList(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opStringList.
 */
template<class T, typename CT> Callback_TestIntf_opStringListPtr
newCallback_TestIntf_opStringList(const IceUtil::Handle<T>& instance, void (T::*cb)(const StringList&, const StringList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opStringList<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opStringList.
 */
template<class T, typename CT> Callback_TestIntf_opStringListPtr
newCallback_TestIntf_opStringList(T* instance, void (T::*cb)(const StringList&, const StringList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opStringList<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opFixedSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opFixedSeq.
 */
template<class T>
class CallbackNC_TestIntf_opFixedSeq : public Callback_TestIntf_opFixedSeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const std::deque< ::Test::Fixed>&, const std::deque< ::Test::Fixed>&);

    CallbackNC_TestIntf_opFixedSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        std::deque< ::Test::Fixed> iceP_outSeq;
        std::deque< ::Test::Fixed> ret;
        try
        {
            ret = proxy->end_opFixedSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opFixedSeq.
 */
template<class T> Callback_TestIntf_opFixedSeqPtr
newCallback_TestIntf_opFixedSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const std::deque< ::Test::Fixed>&, const std::deque< ::Test::Fixed>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opFixedSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opFixedSeq.
 */
template<class T> Callback_TestIntf_opFixedSeqPtr
newCallback_TestIntf_opFixedSeq(T* instance, void (T::*cb)(const std::deque< ::Test::Fixed>&, const std::deque< ::Test::Fixed>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opFixedSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opFixedSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opFixedSeq.
 */
template<class T, typename CT>
class Callback_TestIntf_opFixedSeq : public Callback_TestIntf_opFixedSeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const std::deque< ::Test::Fixed>&, const std::deque< ::Test::Fixed>&, const CT&);

    Callback_TestIntf_opFixedSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        std::deque< ::Test::Fixed> iceP_outSeq;
        std::deque< ::Test::Fixed> ret;
        try
        {
            ret = proxy->end_opFixedSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opFixedSeq.
 */
template<class T, typename CT> Callback_TestIntf_opFixedSeqPtr
newCallback_TestIntf_opFixedSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const std::deque< ::Test::Fixed>&, const std::deque< ::Test::Fixed>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opFixedSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opFixedSeq.
 */
template<class T, typename CT> Callback_TestIntf_opFixedSeqPtr
newCallback_TestIntf_opFixedSeq(T* instance, void (T::*cb)(const std::deque< ::Test::Fixed>&, const std::deque< ::Test::Fixed>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opFixedSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opFixedList.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opFixedList.
 */
template<class T>
class CallbackNC_TestIntf_opFixedList : public Callback_TestIntf_opFixedList_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const FixedList&, const FixedList&);

    CallbackNC_TestIntf_opFixedList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        FixedList iceP_outSeq;
        FixedList ret;
        try
        {
            ret = proxy->end_opFixedList(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opFixedList.
 */
template<class T> Callback_TestIntf_opFixedListPtr
newCallback_TestIntf_opFixedList(const IceUtil::Handle<T>& instance, void (T::*cb)(const FixedList&, const FixedList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opFixedList<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opFixedList.
 */
template<class T> Callback_TestIntf_opFixedListPtr
newCallback_TestIntf_opFixedList(T* instance, void (T::*cb)(const FixedList&, const FixedList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opFixedList<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opFixedList.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opFixedList.
 */
template<class T, typename CT>
class Callback_TestIntf_opFixedList : public Callback_TestIntf_opFixedList_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const FixedList&, const FixedList&, const CT&);

    Callback_TestIntf_opFixedList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        FixedList iceP_outSeq;
        FixedList ret;
        try
        {
            ret = proxy->end_opFixedList(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opFixedList.
 */
template<class T, typename CT> Callback_TestIntf_opFixedListPtr
newCallback_TestIntf_opFixedList(const IceUtil::Handle<T>& instance, void (T::*cb)(const FixedList&, const FixedList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opFixedList<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opFixedList.
 */
template<class T, typename CT> Callback_TestIntf_opFixedListPtr
newCallback_TestIntf_opFixedList(T* instance, void (T::*cb)(const FixedList&, const FixedList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opFixedList<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opVariableSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opVariableSeq.
 */
template<class T>
class CallbackNC_TestIntf_opVariableSeq : public Callback_TestIntf_opVariableSeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const std::deque< ::Test::Variable>&, const std::deque< ::Test::Variable>&);

    CallbackNC_TestIntf_opVariableSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        std::deque< ::Test::Variable> iceP_outSeq;
        std::deque< ::Test::Variable> ret;
        try
        {
            ret = proxy->end_opVariableSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opVariableSeq.
 */
template<class T> Callback_TestIntf_opVariableSeqPtr
newCallback_TestIntf_opVariableSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const std::deque< ::Test::Variable>&, const std::deque< ::Test::Variable>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opVariableSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opVariableSeq.
 */
template<class T> Callback_TestIntf_opVariableSeqPtr
newCallback_TestIntf_opVariableSeq(T* instance, void (T::*cb)(const std::deque< ::Test::Variable>&, const std::deque< ::Test::Variable>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opVariableSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opVariableSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opVariableSeq.
 */
template<class T, typename CT>
class Callback_TestIntf_opVariableSeq : public Callback_TestIntf_opVariableSeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const std::deque< ::Test::Variable>&, const std::deque< ::Test::Variable>&, const CT&);

    Callback_TestIntf_opVariableSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        std::deque< ::Test::Variable> iceP_outSeq;
        std::deque< ::Test::Variable> ret;
        try
        {
            ret = proxy->end_opVariableSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opVariableSeq.
 */
template<class T, typename CT> Callback_TestIntf_opVariableSeqPtr
newCallback_TestIntf_opVariableSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const std::deque< ::Test::Variable>&, const std::deque< ::Test::Variable>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opVariableSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opVariableSeq.
 */
template<class T, typename CT> Callback_TestIntf_opVariableSeqPtr
newCallback_TestIntf_opVariableSeq(T* instance, void (T::*cb)(const std::deque< ::Test::Variable>&, const std::deque< ::Test::Variable>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opVariableSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opVariableList.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opVariableList.
 */
template<class T>
class CallbackNC_TestIntf_opVariableList : public Callback_TestIntf_opVariableList_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const VariableList&, const VariableList&);

    CallbackNC_TestIntf_opVariableList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        VariableList iceP_outSeq;
        VariableList ret;
        try
        {
            ret = proxy->end_opVariableList(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opVariableList.
 */
template<class T> Callback_TestIntf_opVariableListPtr
newCallback_TestIntf_opVariableList(const IceUtil::Handle<T>& instance, void (T::*cb)(const VariableList&, const VariableList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opVariableList<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opVariableList.
 */
template<class T> Callback_TestIntf_opVariableListPtr
newCallback_TestIntf_opVariableList(T* instance, void (T::*cb)(const VariableList&, const VariableList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opVariableList<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opVariableList.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opVariableList.
 */
template<class T, typename CT>
class Callback_TestIntf_opVariableList : public Callback_TestIntf_opVariableList_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const VariableList&, const VariableList&, const CT&);

    Callback_TestIntf_opVariableList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        VariableList iceP_outSeq;
        VariableList ret;
        try
        {
            ret = proxy->end_opVariableList(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opVariableList.
 */
template<class T, typename CT> Callback_TestIntf_opVariableListPtr
newCallback_TestIntf_opVariableList(const IceUtil::Handle<T>& instance, void (T::*cb)(const VariableList&, const VariableList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opVariableList<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opVariableList.
 */
template<class T, typename CT> Callback_TestIntf_opVariableListPtr
newCallback_TestIntf_opVariableList(T* instance, void (T::*cb)(const VariableList&, const VariableList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opVariableList<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opStringStringDictSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opStringStringDictSeq.
 */
template<class T>
class CallbackNC_TestIntf_opStringStringDictSeq : public Callback_TestIntf_opStringStringDictSeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const std::deque< ::Test::StringStringDict>&, const std::deque< ::Test::StringStringDict>&);

    CallbackNC_TestIntf_opStringStringDictSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        std::deque< ::Test::StringStringDict> iceP_outSeq;
        std::deque< ::Test::StringStringDict> ret;
        try
        {
            ret = proxy->end_opStringStringDictSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opStringStringDictSeq.
 */
template<class T> Callback_TestIntf_opStringStringDictSeqPtr
newCallback_TestIntf_opStringStringDictSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const std::deque< ::Test::StringStringDict>&, const std::deque< ::Test::StringStringDict>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opStringStringDictSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opStringStringDictSeq.
 */
template<class T> Callback_TestIntf_opStringStringDictSeqPtr
newCallback_TestIntf_opStringStringDictSeq(T* instance, void (T::*cb)(const std::deque< ::Test::StringStringDict>&, const std::deque< ::Test::StringStringDict>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opStringStringDictSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opStringStringDictSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opStringStringDictSeq.
 */
template<class T, typename CT>
class Callback_TestIntf_opStringStringDictSeq : public Callback_TestIntf_opStringStringDictSeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const std::deque< ::Test::StringStringDict>&, const std::deque< ::Test::StringStringDict>&, const CT&);

    Callback_TestIntf_opStringStringDictSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        std::deque< ::Test::StringStringDict> iceP_outSeq;
        std::deque< ::Test::StringStringDict> ret;
        try
        {
            ret = proxy->end_opStringStringDictSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opStringStringDictSeq.
 */
template<class T, typename CT> Callback_TestIntf_opStringStringDictSeqPtr
newCallback_TestIntf_opStringStringDictSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const std::deque< ::Test::StringStringDict>&, const std::deque< ::Test::StringStringDict>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opStringStringDictSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opStringStringDictSeq.
 */
template<class T, typename CT> Callback_TestIntf_opStringStringDictSeqPtr
newCallback_TestIntf_opStringStringDictSeq(T* instance, void (T::*cb)(const std::deque< ::Test::StringStringDict>&, const std::deque< ::Test::StringStringDict>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opStringStringDictSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opStringStringDictList.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opStringStringDictList.
 */
template<class T>
class CallbackNC_TestIntf_opStringStringDictList : public Callback_TestIntf_opStringStringDictList_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const StringStringDictList&, const StringStringDictList&);

    CallbackNC_TestIntf_opStringStringDictList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        StringStringDictList iceP_outSeq;
        StringStringDictList ret;
        try
        {
            ret = proxy->end_opStringStringDictList(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opStringStringDictList.
 */
template<class T> Callback_TestIntf_opStringStringDictListPtr
newCallback_TestIntf_opStringStringDictList(const IceUtil::Handle<T>& instance, void (T::*cb)(const StringStringDictList&, const StringStringDictList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opStringStringDictList<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opStringStringDictList.
 */
template<class T> Callback_TestIntf_opStringStringDictListPtr
newCallback_TestIntf_opStringStringDictList(T* instance, void (T::*cb)(const StringStringDictList&, const StringStringDictList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opStringStringDictList<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opStringStringDictList.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opStringStringDictList.
 */
template<class T, typename CT>
class Callback_TestIntf_opStringStringDictList : public Callback_TestIntf_opStringStringDictList_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const StringStringDictList&, const StringStringDictList&, const CT&);

    Callback_TestIntf_opStringStringDictList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        StringStringDictList iceP_outSeq;
        StringStringDictList ret;
        try
        {
            ret = proxy->end_opStringStringDictList(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opStringStringDictList.
 */
template<class T, typename CT> Callback_TestIntf_opStringStringDictListPtr
newCallback_TestIntf_opStringStringDictList(const IceUtil::Handle<T>& instance, void (T::*cb)(const StringStringDictList&, const StringStringDictList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opStringStringDictList<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opStringStringDictList.
 */
template<class T, typename CT> Callback_TestIntf_opStringStringDictListPtr
newCallback_TestIntf_opStringStringDictList(T* instance, void (T::*cb)(const StringStringDictList&, const StringStringDictList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opStringStringDictList<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opESeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opESeq.
 */
template<class T>
class CallbackNC_TestIntf_opESeq : public Callback_TestIntf_opESeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const std::deque< ::Test::E>&, const std::deque< ::Test::E>&);

    CallbackNC_TestIntf_opESeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        std::deque< ::Test::E> iceP_outSeq;
        std::deque< ::Test::E> ret;
        try
        {
            ret = proxy->end_opESeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opESeq.
 */
template<class T> Callback_TestIntf_opESeqPtr
newCallback_TestIntf_opESeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const std::deque< ::Test::E>&, const std::deque< ::Test::E>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opESeq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opESeq.
 */
template<class T> Callback_TestIntf_opESeqPtr
newCallback_TestIntf_opESeq(T* instance, void (T::*cb)(const std::deque< ::Test::E>&, const std::deque< ::Test::E>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opESeq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opESeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opESeq.
 */
template<class T, typename CT>
class Callback_TestIntf_opESeq : public Callback_TestIntf_opESeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const std::deque< ::Test::E>&, const std::deque< ::Test::E>&, const CT&);

    Callback_TestIntf_opESeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        std::deque< ::Test::E> iceP_outSeq;
        std::deque< ::Test::E> ret;
        try
        {
            ret = proxy->end_opESeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opESeq.
 */
template<class T, typename CT> Callback_TestIntf_opESeqPtr
newCallback_TestIntf_opESeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const std::deque< ::Test::E>&, const std::deque< ::Test::E>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opESeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opESeq.
 */
template<class T, typename CT> Callback_TestIntf_opESeqPtr
newCallback_TestIntf_opESeq(T* instance, void (T::*cb)(const std::deque< ::Test::E>&, const std::deque< ::Test::E>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opESeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opEList.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opEList.
 */
template<class T>
class CallbackNC_TestIntf_opEList : public Callback_TestIntf_opEList_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const EList&, const EList&);

    CallbackNC_TestIntf_opEList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        EList iceP_outSeq;
        EList ret;
        try
        {
            ret = proxy->end_opEList(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opEList.
 */
template<class T> Callback_TestIntf_opEListPtr
newCallback_TestIntf_opEList(const IceUtil::Handle<T>& instance, void (T::*cb)(const EList&, const EList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opEList<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opEList.
 */
template<class T> Callback_TestIntf_opEListPtr
newCallback_TestIntf_opEList(T* instance, void (T::*cb)(const EList&, const EList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opEList<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opEList.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opEList.
 */
template<class T, typename CT>
class Callback_TestIntf_opEList : public Callback_TestIntf_opEList_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const EList&, const EList&, const CT&);

    Callback_TestIntf_opEList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        EList iceP_outSeq;
        EList ret;
        try
        {
            ret = proxy->end_opEList(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opEList.
 */
template<class T, typename CT> Callback_TestIntf_opEListPtr
newCallback_TestIntf_opEList(const IceUtil::Handle<T>& instance, void (T::*cb)(const EList&, const EList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opEList<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opEList.
 */
template<class T, typename CT> Callback_TestIntf_opEListPtr
newCallback_TestIntf_opEList(T* instance, void (T::*cb)(const EList&, const EList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opEList<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opDPrxSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opDPrxSeq.
 */
template<class T>
class CallbackNC_TestIntf_opDPrxSeq : public Callback_TestIntf_opDPrxSeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const std::deque< ::Test::DPrx>&, const std::deque< ::Test::DPrx>&);

    CallbackNC_TestIntf_opDPrxSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        std::deque< ::Test::DPrx> iceP_outSeq;
        std::deque< ::Test::DPrx> ret;
        try
        {
            ret = proxy->end_opDPrxSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opDPrxSeq.
 */
template<class T> Callback_TestIntf_opDPrxSeqPtr
newCallback_TestIntf_opDPrxSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const std::deque< ::Test::DPrx>&, const std::deque< ::Test::DPrx>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opDPrxSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opDPrxSeq.
 */
template<class T> Callback_TestIntf_opDPrxSeqPtr
newCallback_TestIntf_opDPrxSeq(T* instance, void (T::*cb)(const std::deque< ::Test::DPrx>&, const std::deque< ::Test::DPrx>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opDPrxSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opDPrxSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opDPrxSeq.
 */
template<class T, typename CT>
class Callback_TestIntf_opDPrxSeq : public Callback_TestIntf_opDPrxSeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const std::deque< ::Test::DPrx>&, const std::deque< ::Test::DPrx>&, const CT&);

    Callback_TestIntf_opDPrxSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        std::deque< ::Test::DPrx> iceP_outSeq;
        std::deque< ::Test::DPrx> ret;
        try
        {
            ret = proxy->end_opDPrxSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opDPrxSeq.
 */
template<class T, typename CT> Callback_TestIntf_opDPrxSeqPtr
newCallback_TestIntf_opDPrxSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const std::deque< ::Test::DPrx>&, const std::deque< ::Test::DPrx>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opDPrxSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opDPrxSeq.
 */
template<class T, typename CT> Callback_TestIntf_opDPrxSeqPtr
newCallback_TestIntf_opDPrxSeq(T* instance, void (T::*cb)(const std::deque< ::Test::DPrx>&, const std::deque< ::Test::DPrx>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opDPrxSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opDPrxList.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opDPrxList.
 */
template<class T>
class CallbackNC_TestIntf_opDPrxList : public Callback_TestIntf_opDPrxList_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const DPrxList&, const DPrxList&);

    CallbackNC_TestIntf_opDPrxList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        DPrxList iceP_outSeq;
        DPrxList ret;
        try
        {
            ret = proxy->end_opDPrxList(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opDPrxList.
 */
template<class T> Callback_TestIntf_opDPrxListPtr
newCallback_TestIntf_opDPrxList(const IceUtil::Handle<T>& instance, void (T::*cb)(const DPrxList&, const DPrxList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opDPrxList<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opDPrxList.
 */
template<class T> Callback_TestIntf_opDPrxListPtr
newCallback_TestIntf_opDPrxList(T* instance, void (T::*cb)(const DPrxList&, const DPrxList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opDPrxList<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opDPrxList.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opDPrxList.
 */
template<class T, typename CT>
class Callback_TestIntf_opDPrxList : public Callback_TestIntf_opDPrxList_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const DPrxList&, const DPrxList&, const CT&);

    Callback_TestIntf_opDPrxList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        DPrxList iceP_outSeq;
        DPrxList ret;
        try
        {
            ret = proxy->end_opDPrxList(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opDPrxList.
 */
template<class T, typename CT> Callback_TestIntf_opDPrxListPtr
newCallback_TestIntf_opDPrxList(const IceUtil::Handle<T>& instance, void (T::*cb)(const DPrxList&, const DPrxList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opDPrxList<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opDPrxList.
 */
template<class T, typename CT> Callback_TestIntf_opDPrxListPtr
newCallback_TestIntf_opDPrxList(T* instance, void (T::*cb)(const DPrxList&, const DPrxList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opDPrxList<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opCSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opCSeq.
 */
template<class T>
class CallbackNC_TestIntf_opCSeq : public Callback_TestIntf_opCSeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const std::deque< ::Test::CPtr>&, const std::deque< ::Test::CPtr>&);

    CallbackNC_TestIntf_opCSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        std::deque< ::Test::CPtr> iceP_outSeq;
        std::deque< ::Test::CPtr> ret;
        try
        {
            ret = proxy->end_opCSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opCSeq.
 */
template<class T> Callback_TestIntf_opCSeqPtr
newCallback_TestIntf_opCSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const std::deque< ::Test::CPtr>&, const std::deque< ::Test::CPtr>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opCSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opCSeq.
 */
template<class T> Callback_TestIntf_opCSeqPtr
newCallback_TestIntf_opCSeq(T* instance, void (T::*cb)(const std::deque< ::Test::CPtr>&, const std::deque< ::Test::CPtr>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opCSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opCSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opCSeq.
 */
template<class T, typename CT>
class Callback_TestIntf_opCSeq : public Callback_TestIntf_opCSeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const std::deque< ::Test::CPtr>&, const std::deque< ::Test::CPtr>&, const CT&);

    Callback_TestIntf_opCSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        std::deque< ::Test::CPtr> iceP_outSeq;
        std::deque< ::Test::CPtr> ret;
        try
        {
            ret = proxy->end_opCSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opCSeq.
 */
template<class T, typename CT> Callback_TestIntf_opCSeqPtr
newCallback_TestIntf_opCSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const std::deque< ::Test::CPtr>&, const std::deque< ::Test::CPtr>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opCSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opCSeq.
 */
template<class T, typename CT> Callback_TestIntf_opCSeqPtr
newCallback_TestIntf_opCSeq(T* instance, void (T::*cb)(const std::deque< ::Test::CPtr>&, const std::deque< ::Test::CPtr>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opCSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opCList.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opCList.
 */
template<class T>
class CallbackNC_TestIntf_opCList : public Callback_TestIntf_opCList_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const CList&, const CList&);

    CallbackNC_TestIntf_opCList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        CList iceP_outSeq;
        CList ret;
        try
        {
            ret = proxy->end_opCList(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opCList.
 */
template<class T> Callback_TestIntf_opCListPtr
newCallback_TestIntf_opCList(const IceUtil::Handle<T>& instance, void (T::*cb)(const CList&, const CList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opCList<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opCList.
 */
template<class T> Callback_TestIntf_opCListPtr
newCallback_TestIntf_opCList(T* instance, void (T::*cb)(const CList&, const CList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opCList<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opCList.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opCList.
 */
template<class T, typename CT>
class Callback_TestIntf_opCList : public Callback_TestIntf_opCList_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CList&, const CList&, const CT&);

    Callback_TestIntf_opCList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        CList iceP_outSeq;
        CList ret;
        try
        {
            ret = proxy->end_opCList(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opCList.
 */
template<class T, typename CT> Callback_TestIntf_opCListPtr
newCallback_TestIntf_opCList(const IceUtil::Handle<T>& instance, void (T::*cb)(const CList&, const CList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opCList<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opCList.
 */
template<class T, typename CT> Callback_TestIntf_opCListPtr
newCallback_TestIntf_opCList(T* instance, void (T::*cb)(const CList&, const CList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opCList<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opClassStruct.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opClassStruct.
 */
template<class T>
class CallbackNC_TestIntf_opClassStruct : public Callback_TestIntf_opClassStruct_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ClassStructPtr&, const ClassStructPtr&, const ClassStructSeq&);

    CallbackNC_TestIntf_opClassStruct(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        ClassStructPtr iceP_outS;
        ClassStructSeq iceP_outSeq;
        ClassStructPtr ret;
        try
        {
            ret = proxy->end_opClassStruct(iceP_outS, iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outS, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opClassStruct.
 */
template<class T> Callback_TestIntf_opClassStructPtr
newCallback_TestIntf_opClassStruct(const IceUtil::Handle<T>& instance, void (T::*cb)(const ClassStructPtr&, const ClassStructPtr&, const ClassStructSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opClassStruct<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opClassStruct.
 */
template<class T> Callback_TestIntf_opClassStructPtr
newCallback_TestIntf_opClassStruct(T* instance, void (T::*cb)(const ClassStructPtr&, const ClassStructPtr&, const ClassStructSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opClassStruct<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opClassStruct.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opClassStruct.
 */
template<class T, typename CT>
class Callback_TestIntf_opClassStruct : public Callback_TestIntf_opClassStruct_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ClassStructPtr&, const ClassStructPtr&, const ClassStructSeq&, const CT&);

    Callback_TestIntf_opClassStruct(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        ClassStructPtr iceP_outS;
        ClassStructSeq iceP_outSeq;
        ClassStructPtr ret;
        try
        {
            ret = proxy->end_opClassStruct(iceP_outS, iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outS, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opClassStruct.
 */
template<class T, typename CT> Callback_TestIntf_opClassStructPtr
newCallback_TestIntf_opClassStruct(const IceUtil::Handle<T>& instance, void (T::*cb)(const ClassStructPtr&, const ClassStructPtr&, const ClassStructSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opClassStruct<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opClassStruct.
 */
template<class T, typename CT> Callback_TestIntf_opClassStructPtr
newCallback_TestIntf_opClassStruct(T* instance, void (T::*cb)(const ClassStructPtr&, const ClassStructPtr&, const ClassStructSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opClassStruct<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opOutArrayByteSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opOutArrayByteSeq.
 */
template<class T>
class CallbackNC_TestIntf_opOutArrayByteSeq : public Callback_TestIntf_opOutArrayByteSeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>&);

    CallbackNC_TestIntf_opOutArrayByteSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*> iceP_copy;
        try
        {
            proxy->_iceI_end_opOutArrayByteSeq(iceP_copy, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(iceP_copy);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opOutArrayByteSeq.
 */
template<class T> Callback_TestIntf_opOutArrayByteSeqPtr
newCallback_TestIntf_opOutArrayByteSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opOutArrayByteSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opOutArrayByteSeq.
 */
template<class T> Callback_TestIntf_opOutArrayByteSeqPtr
newCallback_TestIntf_opOutArrayByteSeq(T* instance, void (T::*cb)(const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opOutArrayByteSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opOutArrayByteSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opOutArrayByteSeq.
 */
template<class T, typename CT>
class Callback_TestIntf_opOutArrayByteSeq : public Callback_TestIntf_opOutArrayByteSeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>&, const CT&);

    Callback_TestIntf_opOutArrayByteSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*> iceP_copy;
        try
        {
            proxy->_iceI_end_opOutArrayByteSeq(iceP_copy, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(iceP_copy, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opOutArrayByteSeq.
 */
template<class T, typename CT> Callback_TestIntf_opOutArrayByteSeqPtr
newCallback_TestIntf_opOutArrayByteSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opOutArrayByteSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opOutArrayByteSeq.
 */
template<class T, typename CT> Callback_TestIntf_opOutArrayByteSeqPtr
newCallback_TestIntf_opOutArrayByteSeq(T* instance, void (T::*cb)(const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opOutArrayByteSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opOutRangeByteSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opOutRangeByteSeq.
 */
template<class T>
class CallbackNC_TestIntf_opOutRangeByteSeq : public Callback_TestIntf_opOutRangeByteSeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::pair<ByteSeq::const_iterator, ByteSeq::const_iterator>&);

    CallbackNC_TestIntf_opOutRangeByteSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        ::std::pair<ByteSeq::const_iterator, ByteSeq::const_iterator> iceP_copy;
        ByteSeq iceP_copy_tmp_;
        try
        {
            proxy->end_opOutRangeByteSeq(iceP_copy_tmp_, result);
            iceP_copy.first = iceP_copy_tmp_.begin();
            iceP_copy.second = iceP_copy_tmp_.end();
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(iceP_copy);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opOutRangeByteSeq.
 */
template<class T> Callback_TestIntf_opOutRangeByteSeqPtr
newCallback_TestIntf_opOutRangeByteSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::pair<ByteSeq::const_iterator, ByteSeq::const_iterator>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opOutRangeByteSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opOutRangeByteSeq.
 */
template<class T> Callback_TestIntf_opOutRangeByteSeqPtr
newCallback_TestIntf_opOutRangeByteSeq(T* instance, void (T::*cb)(const ::std::pair<ByteSeq::const_iterator, ByteSeq::const_iterator>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opOutRangeByteSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opOutRangeByteSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opOutRangeByteSeq.
 */
template<class T, typename CT>
class Callback_TestIntf_opOutRangeByteSeq : public Callback_TestIntf_opOutRangeByteSeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::pair<ByteSeq::const_iterator, ByteSeq::const_iterator>&, const CT&);

    Callback_TestIntf_opOutRangeByteSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        ::std::pair<ByteSeq::const_iterator, ByteSeq::const_iterator> iceP_copy;
        ByteSeq iceP_copy_tmp_;
        try
        {
            proxy->end_opOutRangeByteSeq(iceP_copy_tmp_, result);
            iceP_copy.first = iceP_copy_tmp_.begin();
            iceP_copy.second = iceP_copy_tmp_.end();
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(iceP_copy, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opOutRangeByteSeq.
 */
template<class T, typename CT> Callback_TestIntf_opOutRangeByteSeqPtr
newCallback_TestIntf_opOutRangeByteSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::pair<ByteSeq::const_iterator, ByteSeq::const_iterator>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opOutRangeByteSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opOutRangeByteSeq.
 */
template<class T, typename CT> Callback_TestIntf_opOutRangeByteSeqPtr
newCallback_TestIntf_opOutRangeByteSeq(T* instance, void (T::*cb)(const ::std::pair<ByteSeq::const_iterator, ByteSeq::const_iterator>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opOutRangeByteSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opIntStringDict.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opIntStringDict.
 */
template<class T>
class CallbackNC_TestIntf_opIntStringDict : public Callback_TestIntf_opIntStringDict_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IntStringDict&, const IntStringDict&);

    CallbackNC_TestIntf_opIntStringDict(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        IntStringDict iceP_odict;
        IntStringDict ret;
        try
        {
            ret = proxy->end_opIntStringDict(iceP_odict, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_odict);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opIntStringDict.
 */
template<class T> Callback_TestIntf_opIntStringDictPtr
newCallback_TestIntf_opIntStringDict(const IceUtil::Handle<T>& instance, void (T::*cb)(const IntStringDict&, const IntStringDict&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opIntStringDict<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opIntStringDict.
 */
template<class T> Callback_TestIntf_opIntStringDictPtr
newCallback_TestIntf_opIntStringDict(T* instance, void (T::*cb)(const IntStringDict&, const IntStringDict&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opIntStringDict<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opIntStringDict.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opIntStringDict.
 */
template<class T, typename CT>
class Callback_TestIntf_opIntStringDict : public Callback_TestIntf_opIntStringDict_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IntStringDict&, const IntStringDict&, const CT&);

    Callback_TestIntf_opIntStringDict(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        IntStringDict iceP_odict;
        IntStringDict ret;
        try
        {
            ret = proxy->end_opIntStringDict(iceP_odict, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_odict, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opIntStringDict.
 */
template<class T, typename CT> Callback_TestIntf_opIntStringDictPtr
newCallback_TestIntf_opIntStringDict(const IceUtil::Handle<T>& instance, void (T::*cb)(const IntStringDict&, const IntStringDict&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opIntStringDict<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opIntStringDict.
 */
template<class T, typename CT> Callback_TestIntf_opIntStringDictPtr
newCallback_TestIntf_opIntStringDict(T* instance, void (T::*cb)(const IntStringDict&, const IntStringDict&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opIntStringDict<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opVarDict.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opVarDict.
 */
template<class T>
class CallbackNC_TestIntf_opVarDict : public Callback_TestIntf_opVarDict_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Test::CustomMap< ::Ice::Long, ::Ice::Long>&, const ::Test::CustomMap<std::string, ::Ice::Int>&);

    CallbackNC_TestIntf_opVarDict(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        ::Test::CustomMap<std::string, ::Ice::Int> iceP_odict;
        ::Test::CustomMap< ::Ice::Long, ::Ice::Long> ret;
        try
        {
            ret = proxy->end_opVarDict(iceP_odict, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_odict);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opVarDict.
 */
template<class T> Callback_TestIntf_opVarDictPtr
newCallback_TestIntf_opVarDict(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::CustomMap< ::Ice::Long, ::Ice::Long>&, const ::Test::CustomMap<std::string, ::Ice::Int>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opVarDict<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opVarDict.
 */
template<class T> Callback_TestIntf_opVarDictPtr
newCallback_TestIntf_opVarDict(T* instance, void (T::*cb)(const ::Test::CustomMap< ::Ice::Long, ::Ice::Long>&, const ::Test::CustomMap<std::string, ::Ice::Int>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opVarDict<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opVarDict.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opVarDict.
 */
template<class T, typename CT>
class Callback_TestIntf_opVarDict : public Callback_TestIntf_opVarDict_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Test::CustomMap< ::Ice::Long, ::Ice::Long>&, const ::Test::CustomMap<std::string, ::Ice::Int>&, const CT&);

    Callback_TestIntf_opVarDict(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        ::Test::CustomMap<std::string, ::Ice::Int> iceP_odict;
        ::Test::CustomMap< ::Ice::Long, ::Ice::Long> ret;
        try
        {
            ret = proxy->end_opVarDict(iceP_odict, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_odict, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opVarDict.
 */
template<class T, typename CT> Callback_TestIntf_opVarDictPtr
newCallback_TestIntf_opVarDict(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::CustomMap< ::Ice::Long, ::Ice::Long>&, const ::Test::CustomMap<std::string, ::Ice::Int>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opVarDict<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opVarDict.
 */
template<class T, typename CT> Callback_TestIntf_opVarDictPtr
newCallback_TestIntf_opVarDict(T* instance, void (T::*cb)(const ::Test::CustomMap< ::Ice::Long, ::Ice::Long>&, const ::Test::CustomMap<std::string, ::Ice::Int>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opVarDict<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opCustomIntStringDict.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opCustomIntStringDict.
 */
template<class T>
class CallbackNC_TestIntf_opCustomIntStringDict : public Callback_TestIntf_opCustomIntStringDict_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::map< ::Ice::Int, ::Util::string_view>&, const ::std::map< ::Ice::Int, ::Util::string_view>&);

    CallbackNC_TestIntf_opCustomIntStringDict(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        ::std::map< ::Ice::Int, ::Util::string_view> iceP_odict;
        ::std::map< ::Ice::Int, ::Util::string_view> ret;
        try
        {
            proxy->_iceI_end_opCustomIntStringDict(iceP_odict, ret, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_odict);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opCustomIntStringDict.
 */
template<class T> Callback_TestIntf_opCustomIntStringDictPtr
newCallback_TestIntf_opCustomIntStringDict(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::map< ::Ice::Int, ::Util::string_view>&, const ::std::map< ::Ice::Int, ::Util::string_view>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opCustomIntStringDict<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opCustomIntStringDict.
 */
template<class T> Callback_TestIntf_opCustomIntStringDictPtr
newCallback_TestIntf_opCustomIntStringDict(T* instance, void (T::*cb)(const ::std::map< ::Ice::Int, ::Util::string_view>&, const ::std::map< ::Ice::Int, ::Util::string_view>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opCustomIntStringDict<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opCustomIntStringDict.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opCustomIntStringDict.
 */
template<class T, typename CT>
class Callback_TestIntf_opCustomIntStringDict : public Callback_TestIntf_opCustomIntStringDict_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::map< ::Ice::Int, ::Util::string_view>&, const ::std::map< ::Ice::Int, ::Util::string_view>&, const CT&);

    Callback_TestIntf_opCustomIntStringDict(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        ::std::map< ::Ice::Int, ::Util::string_view> iceP_odict;
        ::std::map< ::Ice::Int, ::Util::string_view> ret;
        try
        {
            proxy->_iceI_end_opCustomIntStringDict(iceP_odict, ret, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_odict, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opCustomIntStringDict.
 */
template<class T, typename CT> Callback_TestIntf_opCustomIntStringDictPtr
newCallback_TestIntf_opCustomIntStringDict(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::map< ::Ice::Int, ::Util::string_view>&, const ::std::map< ::Ice::Int, ::Util::string_view>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opCustomIntStringDict<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opCustomIntStringDict.
 */
template<class T, typename CT> Callback_TestIntf_opCustomIntStringDictPtr
newCallback_TestIntf_opCustomIntStringDict(T* instance, void (T::*cb)(const ::std::map< ::Ice::Int, ::Util::string_view>&, const ::std::map< ::Ice::Int, ::Util::string_view>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opCustomIntStringDict<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opShortBuffer.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opShortBuffer.
 */
template<class T>
class CallbackNC_TestIntf_opShortBuffer : public Callback_TestIntf_opShortBuffer_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ShortBuffer&, const ShortBuffer&);

    CallbackNC_TestIntf_opShortBuffer(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        ShortBuffer iceP_outS;
        ShortBuffer ret;
        try
        {
            ret = proxy->end_opShortBuffer(iceP_outS, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outS);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opShortBuffer.
 */
template<class T> Callback_TestIntf_opShortBufferPtr
newCallback_TestIntf_opShortBuffer(const IceUtil::Handle<T>& instance, void (T::*cb)(const ShortBuffer&, const ShortBuffer&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opShortBuffer<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opShortBuffer.
 */
template<class T> Callback_TestIntf_opShortBufferPtr
newCallback_TestIntf_opShortBuffer(T* instance, void (T::*cb)(const ShortBuffer&, const ShortBuffer&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opShortBuffer<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opShortBuffer.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opShortBuffer.
 */
template<class T, typename CT>
class Callback_TestIntf_opShortBuffer : public Callback_TestIntf_opShortBuffer_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ShortBuffer&, const ShortBuffer&, const CT&);

    Callback_TestIntf_opShortBuffer(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        ShortBuffer iceP_outS;
        ShortBuffer ret;
        try
        {
            ret = proxy->end_opShortBuffer(iceP_outS, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outS, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opShortBuffer.
 */
template<class T, typename CT> Callback_TestIntf_opShortBufferPtr
newCallback_TestIntf_opShortBuffer(const IceUtil::Handle<T>& instance, void (T::*cb)(const ShortBuffer&, const ShortBuffer&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opShortBuffer<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opShortBuffer.
 */
template<class T, typename CT> Callback_TestIntf_opShortBufferPtr
newCallback_TestIntf_opShortBuffer(T* instance, void (T::*cb)(const ShortBuffer&, const ShortBuffer&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opShortBuffer<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opBoolBuffer.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opBoolBuffer.
 */
template<class T>
class CallbackNC_TestIntf_opBoolBuffer : public Callback_TestIntf_opBoolBuffer_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Test::CustomBuffer<bool>&, const ::Test::CustomBuffer<bool>&);

    CallbackNC_TestIntf_opBoolBuffer(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        ::Test::CustomBuffer<bool> iceP_outS;
        ::Test::CustomBuffer<bool> ret;
        try
        {
            ret = proxy->end_opBoolBuffer(iceP_outS, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outS);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opBoolBuffer.
 */
template<class T> Callback_TestIntf_opBoolBufferPtr
newCallback_TestIntf_opBoolBuffer(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::CustomBuffer<bool>&, const ::Test::CustomBuffer<bool>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opBoolBuffer<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opBoolBuffer.
 */
template<class T> Callback_TestIntf_opBoolBufferPtr
newCallback_TestIntf_opBoolBuffer(T* instance, void (T::*cb)(const ::Test::CustomBuffer<bool>&, const ::Test::CustomBuffer<bool>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opBoolBuffer<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opBoolBuffer.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opBoolBuffer.
 */
template<class T, typename CT>
class Callback_TestIntf_opBoolBuffer : public Callback_TestIntf_opBoolBuffer_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Test::CustomBuffer<bool>&, const ::Test::CustomBuffer<bool>&, const CT&);

    Callback_TestIntf_opBoolBuffer(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        ::Test::CustomBuffer<bool> iceP_outS;
        ::Test::CustomBuffer<bool> ret;
        try
        {
            ret = proxy->end_opBoolBuffer(iceP_outS, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outS, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opBoolBuffer.
 */
template<class T, typename CT> Callback_TestIntf_opBoolBufferPtr
newCallback_TestIntf_opBoolBuffer(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Test::CustomBuffer<bool>&, const ::Test::CustomBuffer<bool>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opBoolBuffer<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opBoolBuffer.
 */
template<class T, typename CT> Callback_TestIntf_opBoolBufferPtr
newCallback_TestIntf_opBoolBuffer(T* instance, void (T::*cb)(const ::Test::CustomBuffer<bool>&, const ::Test::CustomBuffer<bool>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opBoolBuffer<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opBufferStruct.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opBufferStruct.
 */
template<class T>
class CallbackNC_TestIntf_opBufferStruct : public Callback_TestIntf_opBufferStruct_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const BufferStruct&);

    CallbackNC_TestIntf_opBufferStruct(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        BufferStruct ret;
        try
        {
            ret = proxy->end_opBufferStruct(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opBufferStruct.
 */
template<class T> Callback_TestIntf_opBufferStructPtr
newCallback_TestIntf_opBufferStruct(const IceUtil::Handle<T>& instance, void (T::*cb)(const BufferStruct&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opBufferStruct<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opBufferStruct.
 */
template<class T> Callback_TestIntf_opBufferStructPtr
newCallback_TestIntf_opBufferStruct(T* instance, void (T::*cb)(const BufferStruct&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opBufferStruct<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opBufferStruct.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opBufferStruct.
 */
template<class T, typename CT>
class Callback_TestIntf_opBufferStruct : public Callback_TestIntf_opBufferStruct_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const BufferStruct&, const CT&);

    Callback_TestIntf_opBufferStruct(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        BufferStruct ret;
        try
        {
            ret = proxy->end_opBufferStruct(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opBufferStruct.
 */
template<class T, typename CT> Callback_TestIntf_opBufferStructPtr
newCallback_TestIntf_opBufferStruct(const IceUtil::Handle<T>& instance, void (T::*cb)(const BufferStruct&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opBufferStruct<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opBufferStruct.
 */
template<class T, typename CT> Callback_TestIntf_opBufferStructPtr
newCallback_TestIntf_opBufferStruct(T* instance, void (T::*cb)(const BufferStruct&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opBufferStruct<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_shutdown.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_shutdown.
 */
template<class T>
class CallbackNC_TestIntf_shutdown : public Callback_TestIntf_shutdown_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_TestIntf_shutdown(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_shutdown.
 */
template<class T> Callback_TestIntf_shutdownPtr
newCallback_TestIntf_shutdown(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_shutdown<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_shutdown.
 */
template<class T> Callback_TestIntf_shutdownPtr
newCallback_TestIntf_shutdown(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_shutdown<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_shutdown.
 */
template<class T> Callback_TestIntf_shutdownPtr
newCallback_TestIntf_shutdown(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_shutdown<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_shutdown.
 */
template<class T> Callback_TestIntf_shutdownPtr
newCallback_TestIntf_shutdown(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_shutdown<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_shutdown.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_shutdown.
 */
template<class T, typename CT>
class Callback_TestIntf_shutdown : public Callback_TestIntf_shutdown_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_TestIntf_shutdown(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_shutdown.
 */
template<class T, typename CT> Callback_TestIntf_shutdownPtr
newCallback_TestIntf_shutdown(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_shutdown<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_shutdown.
 */
template<class T, typename CT> Callback_TestIntf_shutdownPtr
newCallback_TestIntf_shutdown(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_shutdown<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_shutdown.
 */
template<class T, typename CT> Callback_TestIntf_shutdownPtr
newCallback_TestIntf_shutdown(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_shutdown<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_shutdown.
 */
template<class T, typename CT> Callback_TestIntf_shutdownPtr
newCallback_TestIntf_shutdown(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_shutdown<T, CT>(instance, 0, excb, sentcb);
}

}

#endif

#include <IceUtil/PopDisableWarnings.h>
#endif
