//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.7.10
//
// <auto-generated>
//
// Generated from file `Test.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __Test_h__
#define __Test_h__

#include <IceUtil/PushDisableWarnings.h>
#include <Ice/ProxyF.h>
#include <Ice/ObjectF.h>
#include <Ice/ValueF.h>
#include <Ice/Exception.h>
#include <Ice/LocalObject.h>
#include <Ice/StreamHelpers.h>
#include <Ice/Comparable.h>
#include <Ice/Proxy.h>
#include <Ice/Object.h>
#include <Ice/GCObject.h>
#include <Ice/Value.h>
#include <Ice/Incoming.h>
#include <Ice/FactoryTableInit.h>
#include <IceUtil/ScopedArray.h>
#include <Ice/Optional.h>
#include <IceUtil/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 307
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 >= 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 10
#       error Ice patch level mismatch!
#   endif
#endif

#ifdef ICE_CPP11_MAPPING // C++11 mapping

namespace Test
{

class C;
class C2;
class Leaf;
class Node;
class CTest;

namespace AAA
{

class B;
class C;

}

namespace AAA
{

class B;

}

namespace CCC
{

class Forward;

}

namespace CCC
{

class Forward;

}

namespace DDD
{

class I;
class IPrx;
class C;
class C2;
class U;

}

}

namespace Test
{

using CSeq = ::std::vector<::std::shared_ptr<C>>;

using CDict = ::std::map<int, ::std::shared_ptr<C>>;

struct S
{
    ::std::shared_ptr<::Test::C> theC;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::shared_ptr<::Test::C>&> ice_tuple() const
    {
        return std::tie(theC);
    }
};

using SSeq = ::std::vector<S>;

using C2Dict = ::std::map<int, ::std::shared_ptr<C2>>;

struct S2
{
    ::Test::C2Dict theC2Dict;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::Test::C2Dict&> ice_tuple() const
    {
        return std::tie(theC2Dict);
    }
};

using S2Seq = ::std::vector<S2>;

using C2DictSeq = ::std::vector<C2Dict>;

using CSeqSeq = ::std::vector<CSeq>;

struct A
{
    ::Test::SSeq theSSeq;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::Test::SSeq&> ice_tuple() const
    {
        return std::tie(theSSeq);
    }
};

struct B
{
    ::Test::S theS;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::Test::S&> ice_tuple() const
    {
        return std::tie(theS);
    }
};

using CSeqDict = ::std::map<int, CSeq>;

using SDict = ::std::map<int, S>;

using CDictDict = ::std::map<int, CDict>;

namespace AAA
{

using BSeq = ::std::vector<::std::shared_ptr<B>>;

using BDict = ::std::map<int, ::std::shared_ptr<B>>;

struct BStruct
{
    ::std::shared_ptr<::Test::AAA::B> bMem;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::shared_ptr<::Test::AAA::B>&> ice_tuple() const
    {
        return std::tie(bMem);
    }
};

using Ice::operator<;
using Ice::operator<=;
using Ice::operator>;
using Ice::operator>=;
using Ice::operator==;
using Ice::operator!=;

}

namespace AAA
{

using CSeq = ::std::vector<::std::shared_ptr<C>>;

using CDict = ::std::map<int, ::std::shared_ptr<C>>;

struct CStruct
{
    ::std::shared_ptr<::Test::AAA::C> cMem;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::shared_ptr<::Test::AAA::C>&> ice_tuple() const
    {
        return std::tie(cMem);
    }
};

using Ice::operator<;
using Ice::operator<=;
using Ice::operator>;
using Ice::operator>=;
using Ice::operator==;
using Ice::operator!=;

}

namespace CCC
{

using ForwardProxySeq = ::std::vector<::std::shared_ptr<::Ice::ObjectPrx>>;

}

using Ice::operator<;
using Ice::operator<=;
using Ice::operator>;
using Ice::operator>=;
using Ice::operator==;
using Ice::operator!=;

}

namespace Test
{

namespace DDD
{

class I : public virtual ::Ice::Object
{
public:

    using ProxyType = IPrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void op(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_op(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

}

}

namespace Test
{

class C : public ::Ice::ValueHelper<C, ::Ice::Value>
{
public:

    virtual ~C();

    C() = default;

    C(const C&) = default;
    C(C&&) = default;
    C& operator=(const C&) = default;
    C& operator=(C&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    C(const ::std::shared_ptr<::Test::C>& left, const ::std::shared_ptr<::Test::C>& right) :
        left(left),
        right(right)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::shared_ptr<::Test::C>&, const ::std::shared_ptr<::Test::C>&> ice_tuple() const
    {
        return std::tie(left, right);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::std::shared_ptr<::Test::C> left;
    ::std::shared_ptr<::Test::C> right;
};

/// \cond INTERNAL
static C _iceS_C_init;
/// \endcond

class C2 : public ::Ice::ValueHelper<C2, ::Ice::Value>
{
public:

    virtual ~C2();

    C2() = default;

    C2(const C2&) = default;
    C2(C2&&) = default;
    C2& operator=(const C2&) = default;
    C2& operator=(C2&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit C2(const ::Test::S2Seq& theS2Seq) :
        theS2Seq(theS2Seq)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::Test::S2Seq&> ice_tuple() const
    {
        return std::tie(theS2Seq);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::Test::S2Seq theS2Seq;
};

class Leaf : public ::Ice::ValueHelper<Leaf, ::Ice::Value>
{
public:

    virtual ~Leaf();

    Leaf() = default;

    Leaf(const Leaf&) = default;
    Leaf(Leaf&&) = default;
    Leaf& operator=(const Leaf&) = default;
    Leaf& operator=(Leaf&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit Leaf(int i) :
        i(i)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const int&> ice_tuple() const
    {
        return std::tie(i);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    int i;
};

class Node : public ::Ice::ValueHelper<Node, ::Ice::Value>
{
public:

    virtual ~Node();

    Node() = default;

    Node(const Node&) = default;
    Node(Node&&) = default;
    Node& operator=(const Node&) = default;
    Node& operator=(Node&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    Node(const ::std::shared_ptr<::Test::Leaf>& l, const ::std::shared_ptr<::Test::Node>& n) :
        l(l),
        n(n)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::shared_ptr<::Test::Leaf>&, const ::std::shared_ptr<::Test::Node>&> ice_tuple() const
    {
        return std::tie(l, n);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::std::shared_ptr<::Test::Leaf> l;
    ::std::shared_ptr<::Test::Node> n;
};

class CTest : public ::Ice::ValueHelper<CTest, ::Ice::Value>
{
public:

    virtual ~CTest();

    CTest() = default;

    CTest(const CTest&) = default;
    CTest(CTest&&) = default;
    CTest& operator=(const CTest&) = default;
    CTest& operator=(CTest&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    CTest(const ::Test::CSeq& theCSeq, const ::Test::SSeq& theSSeq, const ::Test::C2DictSeq& theC2DictSeq, const ::Test::CSeqSeq& theCSeqSeq, const ::Test::S& theS, const ::Test::A& theA, const ::Test::S2& theS2, const ::Test::B& theB, const ::Test::CDict& theCDict, const ::Test::CSeqDict& theCSeqDict, const ::Test::SDict& theSDict, const ::Test::CDictDict& theCDictDict) :
        theCSeq(theCSeq),
        theSSeq(theSSeq),
        theC2DictSeq(theC2DictSeq),
        theCSeqSeq(theCSeqSeq),
        theS(theS),
        theA(theA),
        theS2(theS2),
        theB(theB),
        theCDict(theCDict),
        theCSeqDict(theCSeqDict),
        theSDict(theSDict),
        theCDictDict(theCDictDict)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::Test::CSeq&, const ::Test::SSeq&, const ::Test::C2DictSeq&, const ::Test::CSeqSeq&, const ::Test::S&, const ::Test::A&, const ::Test::S2&, const ::Test::B&, const ::Test::CDict&, const ::Test::CSeqDict&, const ::Test::SDict&, const ::Test::CDictDict&> ice_tuple() const
    {
        return std::tie(theCSeq, theSSeq, theC2DictSeq, theCSeqSeq, theS, theA, theS2, theB, theCDict, theCSeqDict, theSDict, theCDictDict);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::Test::CSeq theCSeq;
    ::Test::SSeq theSSeq;
    ::Test::C2DictSeq theC2DictSeq;
    ::Test::CSeqSeq theCSeqSeq;
    ::Test::S theS;
    ::Test::A theA;
    ::Test::S2 theS2;
    ::Test::B theB;
    ::Test::CDict theCDict;
    ::Test::CSeqDict theCSeqDict;
    ::Test::SDict theSDict;
    ::Test::CDictDict theCDictDict;
};

namespace AAA
{

class C : public ::Ice::ValueHelper<C, ::Ice::Value>
{
public:

    virtual ~C();

    C() = default;

    C(const C&) = default;
    C(C&&) = default;
    C& operator=(const C&) = default;
    C& operator=(C&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    C(const ::std::shared_ptr<::Ice::Value>& obj1, const ::std::shared_ptr<::Ice::Value>& obj2, const ::std::shared_ptr<::Test::AAA::B>& b1, const ::std::shared_ptr<::Test::AAA::B>& b2, const ::Test::AAA::BSeq& x, const ::Test::AAA::BDict& y, const ::Test::AAA::BStruct& z) :
        obj1(obj1),
        obj2(obj2),
        b1(b1),
        b2(b2),
        x(x),
        y(y),
        z(z)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::shared_ptr<::Ice::Value>&, const ::std::shared_ptr<::Ice::Value>&, const ::std::shared_ptr<::Test::AAA::B>&, const ::std::shared_ptr<::Test::AAA::B>&, const ::Test::AAA::BSeq&, const ::Test::AAA::BDict&, const ::Test::AAA::BStruct&> ice_tuple() const
    {
        return std::tie(obj1, obj2, b1, b2, x, y, z);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::std::shared_ptr<::Ice::Value> obj1;
    ::std::shared_ptr<::Ice::Value> obj2;
    ::std::shared_ptr<::Test::AAA::B> b1;
    ::std::shared_ptr<::Test::AAA::B> b2;
    ::Test::AAA::BSeq x;
    ::Test::AAA::BDict y;
    ::Test::AAA::BStruct z;
};

}

namespace AAA
{

class B : public ::Ice::ValueHelper<B, ::Ice::Value>
{
public:

    virtual ~B();

    B() = default;

    B(const B&) = default;
    B(B&&) = default;
    B& operator=(const B&) = default;
    B& operator=(B&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    B(const ::std::shared_ptr<::Ice::Value>& obj1, const ::std::shared_ptr<::Ice::Value>& obj2, const ::std::shared_ptr<::Test::AAA::C>& c1, const ::std::shared_ptr<::Test::AAA::C>& c2, const ::Test::AAA::CSeq& x, const ::Test::AAA::CDict& y, const ::Test::AAA::CStruct& z) :
        obj1(obj1),
        obj2(obj2),
        c1(c1),
        c2(c2),
        x(x),
        y(y),
        z(z)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::shared_ptr<::Ice::Value>&, const ::std::shared_ptr<::Ice::Value>&, const ::std::shared_ptr<::Test::AAA::C>&, const ::std::shared_ptr<::Test::AAA::C>&, const ::Test::AAA::CSeq&, const ::Test::AAA::CDict&, const ::Test::AAA::CStruct&> ice_tuple() const
    {
        return std::tie(obj1, obj2, c1, c2, x, y, z);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::std::shared_ptr<::Ice::Value> obj1;
    ::std::shared_ptr<::Ice::Value> obj2;
    ::std::shared_ptr<::Test::AAA::C> c1;
    ::std::shared_ptr<::Test::AAA::C> c2;
    ::Test::AAA::CSeq x;
    ::Test::AAA::CDict y;
    ::Test::AAA::CStruct z;
};

}

namespace CCC
{

class Forward : public ::Ice::ValueHelper<Forward, ::Ice::Value>
{
public:

    virtual ~Forward();

    Forward() = default;

    Forward(const Forward&) = default;
    Forward(Forward&&) = default;
    Forward& operator=(const Forward&) = default;
    Forward& operator=(Forward&&) = default;

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<> ice_tuple() const
    {
        return std::tie();
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();
};

}

namespace DDD
{

class C : public ::Ice::ValueHelper<C, ::Ice::Value>
{
public:

    virtual ~C();

    C() = default;

    C(const C&) = default;
    C(C&&) = default;
    C& operator=(const C&) = default;
    C& operator=(C&&) = default;

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<> ice_tuple() const
    {
        return std::tie();
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();
};

class U : public ::Ice::ValueHelper<U, ::Ice::Value>
{
public:

    virtual ~U();

    U() = default;

    U(const U&) = default;
    U(U&&) = default;
    U& operator=(const U&) = default;
    U& operator=(U&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    U(const ::std::shared_ptr<::Ice::Value>& myI, const ::std::shared_ptr<::Test::DDD::IPrx>& myIstar, const ::std::shared_ptr<::Test::DDD::C>& myC, const ::std::shared_ptr<::Ice::ObjectPrx>& myCstar, const ::std::shared_ptr<::Test::DDD::C2>& myC2, const ::std::shared_ptr<::Ice::ObjectPrx>& myC2star) :
        myI(myI),
        myIstar(myIstar),
        myC(myC),
        myCstar(myCstar),
        myC2(myC2),
        myC2star(myC2star)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::shared_ptr<::Ice::Value>&, const ::std::shared_ptr<::Test::DDD::IPrx>&, const ::std::shared_ptr<::Test::DDD::C>&, const ::std::shared_ptr<::Ice::ObjectPrx>&, const ::std::shared_ptr<::Test::DDD::C2>&, const ::std::shared_ptr<::Ice::ObjectPrx>&> ice_tuple() const
    {
        return std::tie(myI, myIstar, myC, myCstar, myC2, myC2star);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::std::shared_ptr<::Ice::Value> myI;
    ::std::shared_ptr<::Test::DDD::IPrx> myIstar;
    ::std::shared_ptr<::Test::DDD::C> myC;
    ::std::shared_ptr<::Ice::ObjectPrx> myCstar;
    ::std::shared_ptr<::Test::DDD::C2> myC2;
    ::std::shared_ptr<::Ice::ObjectPrx> myC2star;
};

class C2 : public ::Ice::ValueHelper<C2, ::Ice::Value>
{
public:

    virtual ~C2();

    C2() = default;

    C2(const C2&) = default;
    C2(C2&&) = default;
    C2& operator=(const C2&) = default;
    C2& operator=(C2&&) = default;

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<> ice_tuple() const
    {
        return std::tie();
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();
};

}

}

namespace Test
{

namespace AAA
{

}

namespace AAA
{

}

namespace CCC
{

}

namespace DDD
{

class IPrx : public virtual ::Ice::Proxy<IPrx, ::Ice::ObjectPrx>
{
public:

    void op(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &IPrx::_iceI_op, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto opAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &IPrx::_iceI_op, context);
    }

    ::std::function<void()>
    opAsync(::std::function<void()> response,
            ::std::function<void(::std::exception_ptr)> ex = nullptr,
            ::std::function<void(bool)> sent = nullptr,
            const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::DDD::IPrx::_iceI_op, context);
    }

    /// \cond INTERNAL
    void _iceI_op(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    IPrx() = default;
    friend ::std::shared_ptr<IPrx> IceInternal::createProxy<IPrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

}

}

/// \cond STREAM
namespace Ice
{

template<typename S>
struct StreamReader<::Test::C, S>
{
    static void read(S* istr, ::Test::C& v)
    {
        istr->readAll(v.left, v.right);
    }
};

template<>
struct StreamableTraits<::Test::S>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::Test::S, S>
{
    static void read(S* istr, ::Test::S& v)
    {
        istr->readAll(v.theC);
    }
};

template<>
struct StreamableTraits<::Test::S2>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::Test::S2, S>
{
    static void read(S* istr, ::Test::S2& v)
    {
        istr->readAll(v.theC2Dict);
    }
};

template<typename S>
struct StreamReader<::Test::C2, S>
{
    static void read(S* istr, ::Test::C2& v)
    {
        istr->readAll(v.theS2Seq);
    }
};

template<typename S>
struct StreamReader<::Test::Leaf, S>
{
    static void read(S* istr, ::Test::Leaf& v)
    {
        istr->readAll(v.i);
    }
};

template<typename S>
struct StreamReader<::Test::Node, S>
{
    static void read(S* istr, ::Test::Node& v)
    {
        istr->readAll(v.l, v.n);
    }
};

template<>
struct StreamableTraits<::Test::A>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::Test::A, S>
{
    static void read(S* istr, ::Test::A& v)
    {
        istr->readAll(v.theSSeq);
    }
};

template<>
struct StreamableTraits<::Test::B>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::Test::B, S>
{
    static void read(S* istr, ::Test::B& v)
    {
        istr->readAll(v.theS);
    }
};

template<typename S>
struct StreamReader<::Test::CTest, S>
{
    static void read(S* istr, ::Test::CTest& v)
    {
        istr->readAll(v.theCSeq, v.theSSeq, v.theC2DictSeq, v.theCSeqSeq, v.theS, v.theA, v.theS2, v.theB, v.theCDict, v.theCSeqDict, v.theSDict, v.theCDictDict);
    }
};

template<>
struct StreamableTraits<::Test::AAA::BStruct>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::Test::AAA::BStruct, S>
{
    static void read(S* istr, ::Test::AAA::BStruct& v)
    {
        istr->readAll(v.bMem);
    }
};

template<typename S>
struct StreamReader<::Test::AAA::C, S>
{
    static void read(S* istr, ::Test::AAA::C& v)
    {
        istr->readAll(v.obj1, v.obj2, v.b1, v.b2, v.x, v.y, v.z);
    }
};

template<>
struct StreamableTraits<::Test::AAA::CStruct>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::Test::AAA::CStruct, S>
{
    static void read(S* istr, ::Test::AAA::CStruct& v)
    {
        istr->readAll(v.cMem);
    }
};

template<typename S>
struct StreamReader<::Test::AAA::B, S>
{
    static void read(S* istr, ::Test::AAA::B& v)
    {
        istr->readAll(v.obj1, v.obj2, v.c1, v.c2, v.x, v.y, v.z);
    }
};

template<typename S>
struct StreamReader<::Test::DDD::U, S>
{
    static void read(S* istr, ::Test::DDD::U& v)
    {
        istr->readAll(v.myI, v.myIstar, v.myC, v.myCstar, v.myC2, v.myC2star);
    }
};

}
/// \endcond

/// \cond INTERNAL
namespace Test
{

using CPtr = ::std::shared_ptr<C>;

using C2Ptr = ::std::shared_ptr<C2>;

using LeafPtr = ::std::shared_ptr<Leaf>;

using NodePtr = ::std::shared_ptr<Node>;

using CTestPtr = ::std::shared_ptr<CTest>;

/// \cond INTERNAL
namespace AAA
{

using BPtr = ::std::shared_ptr<B>;

using CPtr = ::std::shared_ptr<C>;

}
/// \endcond

/// \cond INTERNAL
namespace AAA
{

using BPtr = ::std::shared_ptr<B>;

}
/// \endcond

/// \cond INTERNAL
namespace CCC
{

using ForwardPtr = ::std::shared_ptr<Forward>;

}
/// \endcond

/// \cond INTERNAL
namespace CCC
{

using ForwardPtr = ::std::shared_ptr<Forward>;

}
/// \endcond

/// \cond INTERNAL
namespace DDD
{

using IPtr = ::std::shared_ptr<I>;
using IPrxPtr = ::std::shared_ptr<IPrx>;

using CPtr = ::std::shared_ptr<C>;

using C2Ptr = ::std::shared_ptr<C2>;

using UPtr = ::std::shared_ptr<U>;

}
/// \endcond

}
/// \endcond

#else // C++98 mapping

namespace IceProxy
{

namespace Test
{

class C;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< C>&);
::IceProxy::Ice::Object* upCast(C*);
/// \endcond

class C2;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< C2>&);
::IceProxy::Ice::Object* upCast(C2*);
/// \endcond

class Leaf;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< Leaf>&);
::IceProxy::Ice::Object* upCast(Leaf*);
/// \endcond

class Node;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< Node>&);
::IceProxy::Ice::Object* upCast(Node*);
/// \endcond

class CTest;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< CTest>&);
::IceProxy::Ice::Object* upCast(CTest*);
/// \endcond

namespace AAA
{

class B;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< B>&);
::IceProxy::Ice::Object* upCast(B*);
/// \endcond

class C;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< C>&);
::IceProxy::Ice::Object* upCast(C*);
/// \endcond

}

namespace AAA
{

class B;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< B>&);
::IceProxy::Ice::Object* upCast(B*);
/// \endcond

}

namespace CCC
{

class Forward;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< Forward>&);
::IceProxy::Ice::Object* upCast(Forward*);
/// \endcond

}

namespace CCC
{

class Forward;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< Forward>&);
::IceProxy::Ice::Object* upCast(Forward*);
/// \endcond

}

namespace DDD
{

class I;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< I>&);
::IceProxy::Ice::Object* upCast(I*);
/// \endcond

class C;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< C>&);
::IceProxy::Ice::Object* upCast(C*);
/// \endcond

class C2;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< C2>&);
::IceProxy::Ice::Object* upCast(C2*);
/// \endcond

class U;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< U>&);
::IceProxy::Ice::Object* upCast(U*);
/// \endcond

}

}

}

namespace Test
{

class C;
/// \cond INTERNAL
::Ice::Object* upCast(C*);
/// \endcond
typedef ::IceInternal::Handle< C> CPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::C> CPrx;
typedef CPrx CPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(CPtr&, const ::Ice::ObjectPtr&);
/// \endcond

class C2;
/// \cond INTERNAL
::Ice::Object* upCast(C2*);
/// \endcond
typedef ::IceInternal::Handle< C2> C2Ptr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::C2> C2Prx;
typedef C2Prx C2PrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(C2Ptr&, const ::Ice::ObjectPtr&);
/// \endcond

class Leaf;
/// \cond INTERNAL
::Ice::Object* upCast(Leaf*);
/// \endcond
typedef ::IceInternal::Handle< Leaf> LeafPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::Leaf> LeafPrx;
typedef LeafPrx LeafPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(LeafPtr&, const ::Ice::ObjectPtr&);
/// \endcond

class Node;
/// \cond INTERNAL
::Ice::Object* upCast(Node*);
/// \endcond
typedef ::IceInternal::Handle< Node> NodePtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::Node> NodePrx;
typedef NodePrx NodePrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(NodePtr&, const ::Ice::ObjectPtr&);
/// \endcond

class CTest;
/// \cond INTERNAL
::Ice::Object* upCast(CTest*);
/// \endcond
typedef ::IceInternal::Handle< CTest> CTestPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::CTest> CTestPrx;
typedef CTestPrx CTestPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(CTestPtr&, const ::Ice::ObjectPtr&);
/// \endcond

namespace AAA
{

class B;
/// \cond INTERNAL
::Ice::Object* upCast(B*);
/// \endcond
typedef ::IceInternal::Handle< B> BPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::AAA::B> BPrx;
typedef BPrx BPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(BPtr&, const ::Ice::ObjectPtr&);
/// \endcond

class C;
/// \cond INTERNAL
::Ice::Object* upCast(C*);
/// \endcond
typedef ::IceInternal::Handle< C> CPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::AAA::C> CPrx;
typedef CPrx CPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(CPtr&, const ::Ice::ObjectPtr&);
/// \endcond

}

namespace AAA
{

class B;
/// \cond INTERNAL
::Ice::Object* upCast(B*);
/// \endcond
typedef ::IceInternal::Handle< B> BPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::AAA::B> BPrx;
typedef BPrx BPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(BPtr&, const ::Ice::ObjectPtr&);
/// \endcond

}

namespace CCC
{

class Forward;
/// \cond INTERNAL
::Ice::Object* upCast(Forward*);
/// \endcond
typedef ::IceInternal::Handle< Forward> ForwardPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::CCC::Forward> ForwardPrx;
typedef ForwardPrx ForwardPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(ForwardPtr&, const ::Ice::ObjectPtr&);
/// \endcond

}

namespace CCC
{

class Forward;
/// \cond INTERNAL
::Ice::Object* upCast(Forward*);
/// \endcond
typedef ::IceInternal::Handle< Forward> ForwardPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::CCC::Forward> ForwardPrx;
typedef ForwardPrx ForwardPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(ForwardPtr&, const ::Ice::ObjectPtr&);
/// \endcond

}

namespace DDD
{

class I;
/// \cond INTERNAL
::Ice::Object* upCast(I*);
/// \endcond
typedef ::IceInternal::Handle< I> IPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::DDD::I> IPrx;
typedef IPrx IPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(IPtr&, const ::Ice::ObjectPtr&);
/// \endcond

class C;
/// \cond INTERNAL
::Ice::Object* upCast(C*);
/// \endcond
typedef ::IceInternal::Handle< C> CPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::DDD::C> CPrx;
typedef CPrx CPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(CPtr&, const ::Ice::ObjectPtr&);
/// \endcond

class C2;
/// \cond INTERNAL
::Ice::Object* upCast(C2*);
/// \endcond
typedef ::IceInternal::Handle< C2> C2Ptr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::DDD::C2> C2Prx;
typedef C2Prx C2PrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(C2Ptr&, const ::Ice::ObjectPtr&);
/// \endcond

class U;
/// \cond INTERNAL
::Ice::Object* upCast(U*);
/// \endcond
typedef ::IceInternal::Handle< U> UPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::DDD::U> UPrx;
typedef UPrx UPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(UPtr&, const ::Ice::ObjectPtr&);
/// \endcond

}

}

namespace Test
{

typedef ::std::vector<CPtr> CSeq;

typedef ::std::map< ::Ice::Int, CPtr> CDict;

struct S
{
    ::Test::CPtr theC;
};

typedef ::std::vector<S> SSeq;

typedef ::std::map< ::Ice::Int, C2Ptr> C2Dict;

struct S2
{
    ::Test::C2Dict theC2Dict;
};

typedef ::std::vector<S2> S2Seq;

typedef ::std::vector<C2Dict> C2DictSeq;

typedef ::std::vector<CSeq> CSeqSeq;

struct A
{
    ::Test::SSeq theSSeq;
};

struct B
{
    ::Test::S theS;
};

typedef ::std::map< ::Ice::Int, CSeq> CSeqDict;

typedef ::std::map< ::Ice::Int, S> SDict;

typedef ::std::map< ::Ice::Int, CDict> CDictDict;

namespace AAA
{

typedef ::std::vector<BPtr> BSeq;

typedef ::std::map< ::Ice::Int, BPtr> BDict;

struct BStruct
{
    ::Test::AAA::BPtr bMem;
};

}

namespace AAA
{

typedef ::std::vector<CPtr> CSeq;

typedef ::std::map< ::Ice::Int, CPtr> CDict;

struct CStruct
{
    ::Test::AAA::CPtr cMem;
};

}

namespace CCC
{

typedef ::std::vector<ForwardPrx> ForwardProxySeq;

}

}

namespace Test
{

namespace AAA
{

}

namespace AAA
{

}

namespace CCC
{

}

namespace DDD
{

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::DDD::I::begin_op.
 * Create a wrapper instance by calling ::Test::DDD::newCallback_I_op.
 */
class Callback_I_op_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_I_op_Base> Callback_I_opPtr;

}

}

namespace IceProxy
{

namespace Test
{

class C : public virtual ::Ice::Proxy<C, ::IceProxy::Ice::Object>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class C2 : public virtual ::Ice::Proxy<C2, ::IceProxy::Ice::Object>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class Leaf : public virtual ::Ice::Proxy<Leaf, ::IceProxy::Ice::Object>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class Node : public virtual ::Ice::Proxy<Node, ::IceProxy::Ice::Object>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class CTest : public virtual ::Ice::Proxy<CTest, ::IceProxy::Ice::Object>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

namespace AAA
{

class C : public virtual ::Ice::Proxy<C, ::IceProxy::Ice::Object>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

}

namespace AAA
{

class B : public virtual ::Ice::Proxy<B, ::IceProxy::Ice::Object>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

}

namespace CCC
{

class Forward : public virtual ::Ice::Proxy<Forward, ::IceProxy::Ice::Object>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

}

namespace DDD
{

class I : public virtual ::Ice::Proxy<I, ::IceProxy::Ice::Object>
{
public:

    void op(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_op(_iceI_begin_op(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_op(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_op(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_op(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_op(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_op(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_op(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_op(const ::Test::DDD::Callback_I_opPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_op(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_op(const ::Ice::Context& context, const ::Test::DDD::Callback_I_opPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_op(context, cb, cookie);
    }

    void end_op(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_op(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class C : public virtual ::Ice::Proxy<C, ::IceProxy::Ice::Object>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class U : public virtual ::Ice::Proxy<U, ::IceProxy::Ice::Object>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class C2 : public virtual ::Ice::Proxy<C2, ::IceProxy::Ice::Object>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

}

}

}

namespace Test
{

class C : public virtual ::Ice::Object, public ::IceInternal::GCObject
{
public:

    typedef CPrx ProxyType;
    typedef CPtr PointerType;

    virtual ~C();

    C()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    C(const ::Test::CPtr& left, const ::Test::CPtr& right) :
        left(left),
        right(right)
    {
    }

#ifdef ICE_CPP11_COMPILER
    C(const C&) = default;
    C& operator=(const C&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();
    /// \cond INTERNAL
    virtual void _iceGcVisitMembers(::IceInternal::GCVisitor&);
    /// \endcond

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    ::Test::CPtr left;
    ::Test::CPtr right;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_C_init = ::Test::C::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const C& lhs, const C& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const C& lhs, const C& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class C2 : public virtual ::Ice::Object, public ::IceInternal::GCObject
{
public:

    typedef C2Prx ProxyType;
    typedef C2Ptr PointerType;

    virtual ~C2();

    C2()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit C2(const ::Test::S2Seq& theS2Seq) :
        theS2Seq(theS2Seq)
    {
    }

#ifdef ICE_CPP11_COMPILER
    C2(const C2&) = default;
    C2& operator=(const C2&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();
    /// \cond INTERNAL
    virtual void _iceGcVisitMembers(::IceInternal::GCVisitor&);
    /// \endcond

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    ::Test::S2Seq theS2Seq;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_C2_init = ::Test::C2::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const C2& lhs, const C2& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const C2& lhs, const C2& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class Leaf : public virtual ::Ice::Object
{
public:

    typedef LeafPrx ProxyType;
    typedef LeafPtr PointerType;

    virtual ~Leaf();

    Leaf()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit Leaf(::Ice::Int i) :
        i(i)
    {
    }

#ifdef ICE_CPP11_COMPILER
    Leaf(const Leaf&) = default;
    Leaf& operator=(const Leaf&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    ::Ice::Int i;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_Leaf_init = ::Test::Leaf::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const Leaf& lhs, const Leaf& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const Leaf& lhs, const Leaf& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class Node : public virtual ::Ice::Object, public ::IceInternal::GCObject
{
public:

    typedef NodePrx ProxyType;
    typedef NodePtr PointerType;

    virtual ~Node();

    Node()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    Node(const ::Test::LeafPtr& l, const ::Test::NodePtr& n) :
        l(l),
        n(n)
    {
    }

#ifdef ICE_CPP11_COMPILER
    Node(const Node&) = default;
    Node& operator=(const Node&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();
    /// \cond INTERNAL
    virtual void _iceGcVisitMembers(::IceInternal::GCVisitor&);
    /// \endcond

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    ::Test::LeafPtr l;
    ::Test::NodePtr n;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_Node_init = ::Test::Node::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const Node& lhs, const Node& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const Node& lhs, const Node& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class CTest : public virtual ::Ice::Object, public ::IceInternal::GCObject
{
public:

    typedef CTestPrx ProxyType;
    typedef CTestPtr PointerType;

    virtual ~CTest();

    CTest()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    CTest(const ::Test::CSeq& theCSeq, const ::Test::SSeq& theSSeq, const ::Test::C2DictSeq& theC2DictSeq, const ::Test::CSeqSeq& theCSeqSeq, const ::Test::S& theS, const ::Test::A& theA, const ::Test::S2& theS2, const ::Test::B& theB, const ::Test::CDict& theCDict, const ::Test::CSeqDict& theCSeqDict, const ::Test::SDict& theSDict, const ::Test::CDictDict& theCDictDict) :
        theCSeq(theCSeq),
        theSSeq(theSSeq),
        theC2DictSeq(theC2DictSeq),
        theCSeqSeq(theCSeqSeq),
        theS(theS),
        theA(theA),
        theS2(theS2),
        theB(theB),
        theCDict(theCDict),
        theCSeqDict(theCSeqDict),
        theSDict(theSDict),
        theCDictDict(theCDictDict)
    {
    }

#ifdef ICE_CPP11_COMPILER
    CTest(const CTest&) = default;
    CTest& operator=(const CTest&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();
    /// \cond INTERNAL
    virtual void _iceGcVisitMembers(::IceInternal::GCVisitor&);
    /// \endcond

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    ::Test::CSeq theCSeq;
    ::Test::SSeq theSSeq;
    ::Test::C2DictSeq theC2DictSeq;
    ::Test::CSeqSeq theCSeqSeq;
    ::Test::S theS;
    ::Test::A theA;
    ::Test::S2 theS2;
    ::Test::B theB;
    ::Test::CDict theCDict;
    ::Test::CSeqDict theCSeqDict;
    ::Test::SDict theSDict;
    ::Test::CDictDict theCDictDict;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_CTest_init = ::Test::CTest::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const CTest& lhs, const CTest& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const CTest& lhs, const CTest& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

namespace AAA
{

class C : public virtual ::Ice::Object, public ::IceInternal::GCObject
{
public:

    typedef CPrx ProxyType;
    typedef CPtr PointerType;

    virtual ~C();

    C()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    C(const ::Ice::ObjectPtr& obj1, const ::Ice::ObjectPtr& obj2, const ::Test::AAA::BPtr& b1, const ::Test::AAA::BPtr& b2, const ::Test::AAA::BSeq& x, const ::Test::AAA::BDict& y, const ::Test::AAA::BStruct& z) :
        obj1(obj1),
        obj2(obj2),
        b1(b1),
        b2(b2),
        x(x),
        y(y),
        z(z)
    {
    }

#ifdef ICE_CPP11_COMPILER
    C(const C&) = default;
    C& operator=(const C&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();
    /// \cond INTERNAL
    virtual void _iceGcVisitMembers(::IceInternal::GCVisitor&);
    /// \endcond

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    ::Ice::ObjectPtr obj1;
    ::Ice::ObjectPtr obj2;
    ::Test::AAA::BPtr b1;
    ::Test::AAA::BPtr b2;
    ::Test::AAA::BSeq x;
    ::Test::AAA::BDict y;
    ::Test::AAA::BStruct z;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_C_init = ::Test::AAA::C::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const C& lhs, const C& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const C& lhs, const C& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

}

namespace AAA
{

class B : public virtual ::Ice::Object, public ::IceInternal::GCObject
{
public:

    typedef BPrx ProxyType;
    typedef BPtr PointerType;

    virtual ~B();

    B()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    B(const ::Ice::ObjectPtr& obj1, const ::Ice::ObjectPtr& obj2, const ::Test::AAA::CPtr& c1, const ::Test::AAA::CPtr& c2, const ::Test::AAA::CSeq& x, const ::Test::AAA::CDict& y, const ::Test::AAA::CStruct& z) :
        obj1(obj1),
        obj2(obj2),
        c1(c1),
        c2(c2),
        x(x),
        y(y),
        z(z)
    {
    }

#ifdef ICE_CPP11_COMPILER
    B(const B&) = default;
    B& operator=(const B&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();
    /// \cond INTERNAL
    virtual void _iceGcVisitMembers(::IceInternal::GCVisitor&);
    /// \endcond

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    ::Ice::ObjectPtr obj1;
    ::Ice::ObjectPtr obj2;
    ::Test::AAA::CPtr c1;
    ::Test::AAA::CPtr c2;
    ::Test::AAA::CSeq x;
    ::Test::AAA::CDict y;
    ::Test::AAA::CStruct z;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_B_init = ::Test::AAA::B::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const B& lhs, const B& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const B& lhs, const B& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

}

namespace CCC
{

class Forward : public virtual ::Ice::Object
{
public:

    typedef ForwardPrx ProxyType;
    typedef ForwardPtr PointerType;

    virtual ~Forward();

    Forward()
    {
    }

#ifdef ICE_CPP11_COMPILER
    Forward(const Forward&) = default;
    Forward& operator=(const Forward&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_Forward_init = ::Test::CCC::Forward::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const Forward& lhs, const Forward& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const Forward& lhs, const Forward& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

}

namespace DDD
{

class I : public virtual ::Ice::Object
{
public:

    typedef IPrx ProxyType;
    typedef IPtr PointerType;

    virtual ~I();

#ifdef ICE_CPP11_COMPILER
    I() = default;
    I(const I&) = default;
    I& operator=(const I&) = default;
#endif

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void op(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_op(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
inline bool operator==(const I& lhs, const I& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const I& lhs, const I& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class C : public virtual ::Ice::Object
{
public:

    typedef CPrx ProxyType;
    typedef CPtr PointerType;

    virtual ~C();

    C()
    {
    }

#ifdef ICE_CPP11_COMPILER
    C(const C&) = default;
    C& operator=(const C&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_C_init = ::Test::DDD::C::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const C& lhs, const C& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const C& lhs, const C& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class U : public virtual ::Ice::Object, public ::IceInternal::GCObject
{
public:

    typedef UPrx ProxyType;
    typedef UPtr PointerType;

    virtual ~U();

    U()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    U(const ::Test::DDD::IPtr& myI, const ::Test::DDD::IPrx& myIstar, const ::Test::DDD::CPtr& myC, const ::Test::DDD::CPrx& myCstar, const ::Test::DDD::C2Ptr& myC2, const ::Test::DDD::C2Prx& myC2star) :
        myI(myI),
        myIstar(myIstar),
        myC(myC),
        myCstar(myCstar),
        myC2(myC2),
        myC2star(myC2star)
    {
    }

#ifdef ICE_CPP11_COMPILER
    U(const U&) = default;
    U& operator=(const U&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();
    /// \cond INTERNAL
    virtual void _iceGcVisitMembers(::IceInternal::GCVisitor&);
    /// \endcond

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    ::Test::DDD::IPtr myI;
    ::Test::DDD::IPrx myIstar;
    ::Test::DDD::CPtr myC;
    ::Test::DDD::CPrx myCstar;
    ::Test::DDD::C2Ptr myC2;
    ::Test::DDD::C2Prx myC2star;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_U_init = ::Test::DDD::U::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const U& lhs, const U& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const U& lhs, const U& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class C2 : public virtual ::Ice::Object
{
public:

    typedef C2Prx ProxyType;
    typedef C2Ptr PointerType;

    virtual ~C2();

    C2()
    {
    }

#ifdef ICE_CPP11_COMPILER
    C2(const C2&) = default;
    C2& operator=(const C2&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_C2_init = ::Test::DDD::C2::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const C2& lhs, const C2& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const C2& lhs, const C2& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

}

}

/// \cond STREAM
namespace Ice
{

template<typename S>
struct StreamWriter< ::Test::C, S>
{
    static void write(S* ostr, const ::Test::C& v)
    {
        ostr->write(v.left);
        ostr->write(v.right);
    }
};

template<typename S>
struct StreamReader< ::Test::C, S>
{
    static void read(S* istr, ::Test::C& v)
    {
        istr->read(v.left);
        istr->read(v.right);
    }
};

template<>
struct StreamableTraits< ::Test::S>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::Test::S, S>
{
    static void write(S* ostr, const ::Test::S& v)
    {
        ostr->write(v.theC);
    }
};

template<typename S>
struct StreamReader< ::Test::S, S>
{
    static void read(S* istr, ::Test::S& v)
    {
        istr->read(v.theC);
    }
};

template<>
struct StreamableTraits< ::Test::S2>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::Test::S2, S>
{
    static void write(S* ostr, const ::Test::S2& v)
    {
        ostr->write(v.theC2Dict);
    }
};

template<typename S>
struct StreamReader< ::Test::S2, S>
{
    static void read(S* istr, ::Test::S2& v)
    {
        istr->read(v.theC2Dict);
    }
};

template<typename S>
struct StreamWriter< ::Test::C2, S>
{
    static void write(S* ostr, const ::Test::C2& v)
    {
        ostr->write(v.theS2Seq);
    }
};

template<typename S>
struct StreamReader< ::Test::C2, S>
{
    static void read(S* istr, ::Test::C2& v)
    {
        istr->read(v.theS2Seq);
    }
};

template<typename S>
struct StreamWriter< ::Test::Leaf, S>
{
    static void write(S* ostr, const ::Test::Leaf& v)
    {
        ostr->write(v.i);
    }
};

template<typename S>
struct StreamReader< ::Test::Leaf, S>
{
    static void read(S* istr, ::Test::Leaf& v)
    {
        istr->read(v.i);
    }
};

template<typename S>
struct StreamWriter< ::Test::Node, S>
{
    static void write(S* ostr, const ::Test::Node& v)
    {
        ostr->write(v.l);
        ostr->write(v.n);
    }
};

template<typename S>
struct StreamReader< ::Test::Node, S>
{
    static void read(S* istr, ::Test::Node& v)
    {
        istr->read(v.l);
        istr->read(v.n);
    }
};

template<>
struct StreamableTraits< ::Test::A>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::Test::A, S>
{
    static void write(S* ostr, const ::Test::A& v)
    {
        ostr->write(v.theSSeq);
    }
};

template<typename S>
struct StreamReader< ::Test::A, S>
{
    static void read(S* istr, ::Test::A& v)
    {
        istr->read(v.theSSeq);
    }
};

template<>
struct StreamableTraits< ::Test::B>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::Test::B, S>
{
    static void write(S* ostr, const ::Test::B& v)
    {
        ostr->write(v.theS);
    }
};

template<typename S>
struct StreamReader< ::Test::B, S>
{
    static void read(S* istr, ::Test::B& v)
    {
        istr->read(v.theS);
    }
};

template<typename S>
struct StreamWriter< ::Test::CTest, S>
{
    static void write(S* ostr, const ::Test::CTest& v)
    {
        ostr->write(v.theCSeq);
        ostr->write(v.theSSeq);
        ostr->write(v.theC2DictSeq);
        ostr->write(v.theCSeqSeq);
        ostr->write(v.theS);
        ostr->write(v.theA);
        ostr->write(v.theS2);
        ostr->write(v.theB);
        ostr->write(v.theCDict);
        ostr->write(v.theCSeqDict);
        ostr->write(v.theSDict);
        ostr->write(v.theCDictDict);
    }
};

template<typename S>
struct StreamReader< ::Test::CTest, S>
{
    static void read(S* istr, ::Test::CTest& v)
    {
        istr->read(v.theCSeq);
        istr->read(v.theSSeq);
        istr->read(v.theC2DictSeq);
        istr->read(v.theCSeqSeq);
        istr->read(v.theS);
        istr->read(v.theA);
        istr->read(v.theS2);
        istr->read(v.theB);
        istr->read(v.theCDict);
        istr->read(v.theCSeqDict);
        istr->read(v.theSDict);
        istr->read(v.theCDictDict);
    }
};

template<>
struct StreamableTraits< ::Test::AAA::BStruct>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::Test::AAA::BStruct, S>
{
    static void write(S* ostr, const ::Test::AAA::BStruct& v)
    {
        ostr->write(v.bMem);
    }
};

template<typename S>
struct StreamReader< ::Test::AAA::BStruct, S>
{
    static void read(S* istr, ::Test::AAA::BStruct& v)
    {
        istr->read(v.bMem);
    }
};

template<typename S>
struct StreamWriter< ::Test::AAA::C, S>
{
    static void write(S* ostr, const ::Test::AAA::C& v)
    {
        ostr->write(v.obj1);
        ostr->write(v.obj2);
        ostr->write(v.b1);
        ostr->write(v.b2);
        ostr->write(v.x);
        ostr->write(v.y);
        ostr->write(v.z);
    }
};

template<typename S>
struct StreamReader< ::Test::AAA::C, S>
{
    static void read(S* istr, ::Test::AAA::C& v)
    {
        istr->read(v.obj1);
        istr->read(v.obj2);
        istr->read(v.b1);
        istr->read(v.b2);
        istr->read(v.x);
        istr->read(v.y);
        istr->read(v.z);
    }
};

template<>
struct StreamableTraits< ::Test::AAA::CStruct>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::Test::AAA::CStruct, S>
{
    static void write(S* ostr, const ::Test::AAA::CStruct& v)
    {
        ostr->write(v.cMem);
    }
};

template<typename S>
struct StreamReader< ::Test::AAA::CStruct, S>
{
    static void read(S* istr, ::Test::AAA::CStruct& v)
    {
        istr->read(v.cMem);
    }
};

template<typename S>
struct StreamWriter< ::Test::AAA::B, S>
{
    static void write(S* ostr, const ::Test::AAA::B& v)
    {
        ostr->write(v.obj1);
        ostr->write(v.obj2);
        ostr->write(v.c1);
        ostr->write(v.c2);
        ostr->write(v.x);
        ostr->write(v.y);
        ostr->write(v.z);
    }
};

template<typename S>
struct StreamReader< ::Test::AAA::B, S>
{
    static void read(S* istr, ::Test::AAA::B& v)
    {
        istr->read(v.obj1);
        istr->read(v.obj2);
        istr->read(v.c1);
        istr->read(v.c2);
        istr->read(v.x);
        istr->read(v.y);
        istr->read(v.z);
    }
};

template<typename S>
struct StreamWriter< ::Test::DDD::U, S>
{
    static void write(S* ostr, const ::Test::DDD::U& v)
    {
        ostr->write(v.myI);
        ostr->write(v.myIstar);
        ostr->write(v.myC);
        ostr->write(v.myCstar);
        ostr->write(v.myC2);
        ostr->write(v.myC2star);
    }
};

template<typename S>
struct StreamReader< ::Test::DDD::U, S>
{
    static void read(S* istr, ::Test::DDD::U& v)
    {
        istr->read(v.myI);
        istr->read(v.myIstar);
        istr->read(v.myC);
        istr->read(v.myCstar);
        istr->read(v.myC2);
        istr->read(v.myC2star);
    }
};

}
/// \endcond

namespace Test
{

namespace AAA
{

}

namespace AAA
{

}

namespace CCC
{

}

namespace DDD
{

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::DDD::I::begin_op.
 * Create a wrapper instance by calling ::Test::DDD::newCallback_I_op.
 */
template<class T>
class CallbackNC_I_op : public Callback_I_op_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_I_op(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::DDD::I::begin_op.
 */
template<class T> Callback_I_opPtr
newCallback_I_op(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_I_op<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::DDD::I::begin_op.
 */
template<class T> Callback_I_opPtr
newCallback_I_op(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_I_op<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::DDD::I::begin_op.
 */
template<class T> Callback_I_opPtr
newCallback_I_op(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_I_op<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::DDD::I::begin_op.
 */
template<class T> Callback_I_opPtr
newCallback_I_op(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_I_op<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::DDD::I::begin_op.
 * Create a wrapper instance by calling ::Test::DDD::newCallback_I_op.
 */
template<class T, typename CT>
class Callback_I_op : public Callback_I_op_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_I_op(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::DDD::I::begin_op.
 */
template<class T, typename CT> Callback_I_opPtr
newCallback_I_op(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_I_op<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::DDD::I::begin_op.
 */
template<class T, typename CT> Callback_I_opPtr
newCallback_I_op(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_I_op<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::DDD::I::begin_op.
 */
template<class T, typename CT> Callback_I_opPtr
newCallback_I_op(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_I_op<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::DDD::I::begin_op.
 */
template<class T, typename CT> Callback_I_opPtr
newCallback_I_op(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_I_op<T, CT>(instance, 0, excb, sentcb);
}

}

}

#endif

#include <IceUtil/PopDisableWarnings.h>
#endif
