//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.8.0-alpha.0
//
// <auto-generated>
//
// Generated from file `Test.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#define ICE_BUILDING_GENERATED_CODE
#include <Test.h>
#include <Ice/OutgoingAsync.h>

#if defined(_MSC_VER)
#   pragma warning(disable:4458) // declaration of ... hides class member
#elif defined(__clang__)
#   pragma clang diagnostic ignored "-Wshadow"
#elif defined(__GNUC__)
#   pragma GCC diagnostic ignored "-Wshadow"
#endif

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION  != 30850
#       error Ice version mismatch: an exact match is required for beta generated code
#   endif
#endif

namespace
{

const ::IceInternal::DefaultUserExceptionFactoryInit<::Test::SomeException> iceC_Test_SomeException_init("::Test::SomeException");

const ::IceInternal::DefaultValueFactoryInit<::Test::MyClass1> iceC_Test_MyClass1_init("::Test::MyClass1");

}

void
Test::MyClassPrx::shutdown(const ::Ice::Context& context) const
{
    ::IceInternal::makePromiseOutgoing<void>(true, this, &MyClassPrx::_iceI_shutdown, context).get();
}

::std::future<void>
Test::MyClassPrx::shutdownAsync(const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<void>(false, this, &MyClassPrx::_iceI_shutdown, context);
}

::std::function<void()>
Test::MyClassPrx::shutdownAsync(::std::function<void ()> response,
                                ::std::function<void(::std::exception_ptr)> ex,
                                ::std::function<void(bool)> sent,
                                const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_shutdown, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_shutdown(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "shutdown";

    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

bool
Test::MyClassPrx::supportsCompress(const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<bool>(true, this, &MyClassPrx::_iceI_supportsCompress, context).get();
}

::std::future<bool>
Test::MyClassPrx::supportsCompressAsync(const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<bool>(false, this, &MyClassPrx::_iceI_supportsCompress, context);
}

::std::function<void()>
Test::MyClassPrx::supportsCompressAsync(::std::function<void (bool)> response,
                                        ::std::function<void(::std::exception_ptr)> ex,
                                        ::std::function<void(bool)> sent,
                                        const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<bool>(std::move(response), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_supportsCompress, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_supportsCompress(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>& outAsync, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "supportsCompress";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

void
Test::MyClassPrx::opVoid(const ::Ice::Context& context) const
{
    ::IceInternal::makePromiseOutgoing<void>(true, this, &MyClassPrx::_iceI_opVoid, context).get();
}

::std::future<void>
Test::MyClassPrx::opVoidAsync(const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<void>(false, this, &MyClassPrx::_iceI_opVoid, context);
}

::std::function<void()>
Test::MyClassPrx::opVoidAsync(::std::function<void ()> response,
                              ::std::function<void(::std::exception_ptr)> ex,
                              ::std::function<void(bool)> sent,
                              const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opVoid, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opVoid(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "opVoid";

    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

::std::uint8_t
Test::MyClassPrx::opByte(::std::uint8_t iceP_p1, ::std::uint8_t iceP_p2, ::std::uint8_t& iceP_p3, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<::std::uint8_t, ::std::uint8_t>>(true, this, &MyClassPrx::_iceI_opByte, iceP_p1, iceP_p2, context).get();
    iceP_p3 = ::std::get<1>(_result);
    return ::std::get<0>(_result);
}

::std::future<::std::tuple<::std::uint8_t, ::std::uint8_t>>
Test::MyClassPrx::opByteAsync(::std::uint8_t iceP_p1, ::std::uint8_t iceP_p2, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<::std::uint8_t, ::std::uint8_t>>(false, this, &MyClassPrx::_iceI_opByte, iceP_p1, iceP_p2, context);
}

::std::function<void()>
Test::MyClassPrx::opByteAsync(::std::uint8_t iceP_p1, ::std::uint8_t iceP_p2,
                              ::std::function<void (::std::uint8_t, ::std::uint8_t)> response,
                              ::std::function<void(::std::exception_ptr)> ex,
                              ::std::function<void(bool)> sent,
                              const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<::std::uint8_t, ::std::uint8_t>&& _result)
    {
        response(::std::get<0>(_result), ::std::get<1>(_result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<::std::uint8_t, ::std::uint8_t>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opByte, iceP_p1, iceP_p2, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opByte(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::uint8_t, ::std::uint8_t>>>& outAsync, ::std::uint8_t iceP_p1, ::std::uint8_t iceP_p2, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "opByte";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p1, iceP_p2);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<::std::uint8_t, ::std::uint8_t> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

bool
Test::MyClassPrx::opBool(bool iceP_p1, bool iceP_p2, bool& iceP_p3, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<bool, bool>>(true, this, &MyClassPrx::_iceI_opBool, iceP_p1, iceP_p2, context).get();
    iceP_p3 = ::std::get<1>(_result);
    return ::std::get<0>(_result);
}

::std::future<::std::tuple<bool, bool>>
Test::MyClassPrx::opBoolAsync(bool iceP_p1, bool iceP_p2, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<bool, bool>>(false, this, &MyClassPrx::_iceI_opBool, iceP_p1, iceP_p2, context);
}

::std::function<void()>
Test::MyClassPrx::opBoolAsync(bool iceP_p1, bool iceP_p2,
                              ::std::function<void (bool, bool)> response,
                              ::std::function<void(::std::exception_ptr)> ex,
                              ::std::function<void(bool)> sent,
                              const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<bool, bool>&& _result)
    {
        response(::std::get<0>(_result), ::std::get<1>(_result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<bool, bool>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opBool, iceP_p1, iceP_p2, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opBool(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<bool, bool>>>& outAsync, bool iceP_p1, bool iceP_p2, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "opBool";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p1, iceP_p2);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<bool, bool> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::std::int64_t
Test::MyClassPrx::opShortIntLong(::std::int16_t iceP_p1, ::std::int32_t iceP_p2, ::std::int64_t iceP_p3, ::std::int16_t& iceP_p4, ::std::int32_t& iceP_p5, ::std::int64_t& iceP_p6, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<::std::int64_t, ::std::int16_t, ::std::int32_t, ::std::int64_t>>(true, this, &MyClassPrx::_iceI_opShortIntLong, iceP_p1, iceP_p2, iceP_p3, context).get();
    iceP_p4 = ::std::get<1>(_result);
    iceP_p5 = ::std::get<2>(_result);
    iceP_p6 = ::std::get<3>(_result);
    return ::std::get<0>(_result);
}

::std::future<::std::tuple<::std::int64_t, ::std::int16_t, ::std::int32_t, ::std::int64_t>>
Test::MyClassPrx::opShortIntLongAsync(::std::int16_t iceP_p1, ::std::int32_t iceP_p2, ::std::int64_t iceP_p3, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<::std::int64_t, ::std::int16_t, ::std::int32_t, ::std::int64_t>>(false, this, &MyClassPrx::_iceI_opShortIntLong, iceP_p1, iceP_p2, iceP_p3, context);
}

::std::function<void()>
Test::MyClassPrx::opShortIntLongAsync(::std::int16_t iceP_p1, ::std::int32_t iceP_p2, ::std::int64_t iceP_p3,
                                      ::std::function<void (::std::int64_t, ::std::int16_t, ::std::int32_t, ::std::int64_t)> response,
                                      ::std::function<void(::std::exception_ptr)> ex,
                                      ::std::function<void(bool)> sent,
                                      const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<::std::int64_t, ::std::int16_t, ::std::int32_t, ::std::int64_t>&& _result)
    {
        response(::std::get<0>(_result), ::std::get<1>(_result), ::std::get<2>(_result), ::std::get<3>(_result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<::std::int64_t, ::std::int16_t, ::std::int32_t, ::std::int64_t>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opShortIntLong, iceP_p1, iceP_p2, iceP_p3, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opShortIntLong(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::int64_t, ::std::int16_t, ::std::int32_t, ::std::int64_t>>>& outAsync, ::std::int16_t iceP_p1, ::std::int32_t iceP_p2, ::std::int64_t iceP_p3, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "opShortIntLong";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p1, iceP_p2, iceP_p3);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<::std::int64_t, ::std::int16_t, ::std::int32_t, ::std::int64_t> v;
            istr->readAll(::std::get<1>(v), ::std::get<2>(v), ::std::get<3>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

double
Test::MyClassPrx::opFloatDouble(float iceP_p1, double iceP_p2, float& iceP_p3, double& iceP_p4, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<double, float, double>>(true, this, &MyClassPrx::_iceI_opFloatDouble, iceP_p1, iceP_p2, context).get();
    iceP_p3 = ::std::get<1>(_result);
    iceP_p4 = ::std::get<2>(_result);
    return ::std::get<0>(_result);
}

::std::future<::std::tuple<double, float, double>>
Test::MyClassPrx::opFloatDoubleAsync(float iceP_p1, double iceP_p2, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<double, float, double>>(false, this, &MyClassPrx::_iceI_opFloatDouble, iceP_p1, iceP_p2, context);
}

::std::function<void()>
Test::MyClassPrx::opFloatDoubleAsync(float iceP_p1, double iceP_p2,
                                     ::std::function<void (double, float, double)> response,
                                     ::std::function<void(::std::exception_ptr)> ex,
                                     ::std::function<void(bool)> sent,
                                     const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<double, float, double>&& _result)
    {
        response(::std::get<0>(_result), ::std::get<1>(_result), ::std::get<2>(_result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<double, float, double>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opFloatDouble, iceP_p1, iceP_p2, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opFloatDouble(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<double, float, double>>>& outAsync, float iceP_p1, double iceP_p2, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "opFloatDouble";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p1, iceP_p2);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<double, float, double> v;
            istr->readAll(::std::get<1>(v), ::std::get<2>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::std::string
Test::MyClassPrx::opString(::std::string_view iceP_p1, ::std::string_view iceP_p2, ::std::string& iceP_p3, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<::std::string, ::std::string>>(true, this, &MyClassPrx::_iceI_opString, iceP_p1, iceP_p2, context).get();
    iceP_p3 = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::std::string, ::std::string>>
Test::MyClassPrx::opStringAsync(::std::string_view iceP_p1, ::std::string_view iceP_p2, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<::std::string, ::std::string>>(false, this, &MyClassPrx::_iceI_opString, iceP_p1, iceP_p2, context);
}

::std::function<void()>
Test::MyClassPrx::opStringAsync(::std::string_view iceP_p1, ::std::string_view iceP_p2,
                                ::std::function<void (::std::string, ::std::string)> response,
                                ::std::function<void(::std::exception_ptr)> ex,
                                ::std::function<void(bool)> sent,
                                const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<::std::string, ::std::string>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<::std::string, ::std::string>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opString, iceP_p1, iceP_p2, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opString(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::string, ::std::string>>>& outAsync, ::std::string_view iceP_p1, ::std::string_view iceP_p2, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "opString";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p1, iceP_p2);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<::std::string, ::std::string> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::MyEnum
Test::MyClassPrx::opMyEnum(MyEnum iceP_p1, MyEnum& iceP_p2, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<MyEnum, MyEnum>>(true, this, &MyClassPrx::_iceI_opMyEnum, iceP_p1, context).get();
    iceP_p2 = ::std::get<1>(_result);
    return ::std::get<0>(_result);
}

::std::future<::std::tuple<::Test::MyEnum, ::Test::MyEnum>>
Test::MyClassPrx::opMyEnumAsync(MyEnum iceP_p1, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<MyEnum, MyEnum>>(false, this, &MyClassPrx::_iceI_opMyEnum, iceP_p1, context);
}

::std::function<void()>
Test::MyClassPrx::opMyEnumAsync(MyEnum iceP_p1,
                                ::std::function<void (::Test::MyEnum, ::Test::MyEnum)> response,
                                ::std::function<void(::std::exception_ptr)> ex,
                                ::std::function<void(bool)> sent,
                                const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<MyEnum, MyEnum>&& _result)
    {
        response(::std::get<0>(_result), ::std::get<1>(_result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<MyEnum, MyEnum>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opMyEnum, iceP_p1, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opMyEnum(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<MyEnum, MyEnum>>>& outAsync, MyEnum iceP_p1, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "opMyEnum";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p1);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<MyEnum, MyEnum> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::std::optional<::Test::MyClassPrx>
Test::MyClassPrx::opMyClass(const ::std::optional<MyClassPrx>& iceP_p1, ::std::optional<MyClassPrx>& iceP_p2, ::std::optional<MyClassPrx>& iceP_p3, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<::std::optional<MyClassPrx>, ::std::optional<MyClassPrx>, ::std::optional<MyClassPrx>>>(true, this, &MyClassPrx::_iceI_opMyClass, iceP_p1, context).get();
    iceP_p2 = ::std::move(::std::get<1>(_result));
    iceP_p3 = ::std::move(::std::get<2>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::std::optional<::Test::MyClassPrx>, ::std::optional<::Test::MyClassPrx>, ::std::optional<::Test::MyClassPrx>>>
Test::MyClassPrx::opMyClassAsync(const ::std::optional<MyClassPrx>& iceP_p1, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<::std::optional<MyClassPrx>, ::std::optional<MyClassPrx>, ::std::optional<MyClassPrx>>>(false, this, &MyClassPrx::_iceI_opMyClass, iceP_p1, context);
}

::std::function<void()>
Test::MyClassPrx::opMyClassAsync(const ::std::optional<MyClassPrx>& iceP_p1,
                                 ::std::function<void (::std::optional<::Test::MyClassPrx>, ::std::optional<::Test::MyClassPrx>, ::std::optional<::Test::MyClassPrx>)> response,
                                 ::std::function<void(::std::exception_ptr)> ex,
                                 ::std::function<void(bool)> sent,
                                 const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<::std::optional<MyClassPrx>, ::std::optional<MyClassPrx>, ::std::optional<MyClassPrx>>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)), ::std::move(::std::get<2>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<::std::optional<MyClassPrx>, ::std::optional<MyClassPrx>, ::std::optional<MyClassPrx>>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opMyClass, iceP_p1, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opMyClass(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::optional<MyClassPrx>, ::std::optional<MyClassPrx>, ::std::optional<MyClassPrx>>>>& outAsync, const ::std::optional<MyClassPrx>& iceP_p1, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "opMyClass";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p1);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<::std::optional<MyClassPrx>, ::std::optional<MyClassPrx>, ::std::optional<MyClassPrx>> v;
            istr->readAll(::std::get<1>(v), ::std::get<2>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::Structure
Test::MyClassPrx::opStruct(const Structure& iceP_p1, const Structure& iceP_p2, Structure& iceP_p3, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<Structure, Structure>>(true, this, &MyClassPrx::_iceI_opStruct, iceP_p1, iceP_p2, context).get();
    iceP_p3 = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::Structure, ::Test::Structure>>
Test::MyClassPrx::opStructAsync(const Structure& iceP_p1, const Structure& iceP_p2, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<Structure, Structure>>(false, this, &MyClassPrx::_iceI_opStruct, iceP_p1, iceP_p2, context);
}

::std::function<void()>
Test::MyClassPrx::opStructAsync(const Structure& iceP_p1, const Structure& iceP_p2,
                                ::std::function<void (::Test::Structure, ::Test::Structure)> response,
                                ::std::function<void(::std::exception_ptr)> ex,
                                ::std::function<void(bool)> sent,
                                const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<Structure, Structure>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<Structure, Structure>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opStruct, iceP_p1, iceP_p2, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opStruct(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<Structure, Structure>>>& outAsync, const Structure& iceP_p1, const Structure& iceP_p2, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "opStruct";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p1, iceP_p2);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<Structure, Structure> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::ByteS
Test::MyClassPrx::opByteS(const ByteS& iceP_p1, const ByteS& iceP_p2, ByteS& iceP_p3, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<ByteS, ByteS>>(true, this, &MyClassPrx::_iceI_opByteS, iceP_p1, iceP_p2, context).get();
    iceP_p3 = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::ByteS, ::Test::ByteS>>
Test::MyClassPrx::opByteSAsync(const ByteS& iceP_p1, const ByteS& iceP_p2, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<ByteS, ByteS>>(false, this, &MyClassPrx::_iceI_opByteS, iceP_p1, iceP_p2, context);
}

::std::function<void()>
Test::MyClassPrx::opByteSAsync(const ByteS& iceP_p1, const ByteS& iceP_p2,
                               ::std::function<void (::Test::ByteS, ::Test::ByteS)> response,
                               ::std::function<void(::std::exception_ptr)> ex,
                               ::std::function<void(bool)> sent,
                               const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<ByteS, ByteS>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<ByteS, ByteS>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opByteS, iceP_p1, iceP_p2, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opByteS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<ByteS, ByteS>>>& outAsync, const ByteS& iceP_p1, const ByteS& iceP_p2, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "opByteS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p1, iceP_p2);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<ByteS, ByteS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::BoolS
Test::MyClassPrx::opBoolS(const BoolS& iceP_p1, const BoolS& iceP_p2, BoolS& iceP_p3, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<BoolS, BoolS>>(true, this, &MyClassPrx::_iceI_opBoolS, iceP_p1, iceP_p2, context).get();
    iceP_p3 = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::BoolS, ::Test::BoolS>>
Test::MyClassPrx::opBoolSAsync(const BoolS& iceP_p1, const BoolS& iceP_p2, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<BoolS, BoolS>>(false, this, &MyClassPrx::_iceI_opBoolS, iceP_p1, iceP_p2, context);
}

::std::function<void()>
Test::MyClassPrx::opBoolSAsync(const BoolS& iceP_p1, const BoolS& iceP_p2,
                               ::std::function<void (::Test::BoolS, ::Test::BoolS)> response,
                               ::std::function<void(::std::exception_ptr)> ex,
                               ::std::function<void(bool)> sent,
                               const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<BoolS, BoolS>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<BoolS, BoolS>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opBoolS, iceP_p1, iceP_p2, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opBoolS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<BoolS, BoolS>>>& outAsync, const BoolS& iceP_p1, const BoolS& iceP_p2, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "opBoolS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p1, iceP_p2);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<BoolS, BoolS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::LongS
Test::MyClassPrx::opShortIntLongS(const ShortS& iceP_p1, const IntS& iceP_p2, const LongS& iceP_p3, ShortS& iceP_p4, IntS& iceP_p5, LongS& iceP_p6, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<LongS, ShortS, IntS, LongS>>(true, this, &MyClassPrx::_iceI_opShortIntLongS, iceP_p1, iceP_p2, iceP_p3, context).get();
    iceP_p4 = ::std::move(::std::get<1>(_result));
    iceP_p5 = ::std::move(::std::get<2>(_result));
    iceP_p6 = ::std::move(::std::get<3>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::LongS, ::Test::ShortS, ::Test::IntS, ::Test::LongS>>
Test::MyClassPrx::opShortIntLongSAsync(const ShortS& iceP_p1, const IntS& iceP_p2, const LongS& iceP_p3, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<LongS, ShortS, IntS, LongS>>(false, this, &MyClassPrx::_iceI_opShortIntLongS, iceP_p1, iceP_p2, iceP_p3, context);
}

::std::function<void()>
Test::MyClassPrx::opShortIntLongSAsync(const ShortS& iceP_p1, const IntS& iceP_p2, const LongS& iceP_p3,
                                       ::std::function<void (::Test::LongS, ::Test::ShortS, ::Test::IntS, ::Test::LongS)> response,
                                       ::std::function<void(::std::exception_ptr)> ex,
                                       ::std::function<void(bool)> sent,
                                       const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<LongS, ShortS, IntS, LongS>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)), ::std::move(::std::get<2>(_result)), ::std::move(::std::get<3>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<LongS, ShortS, IntS, LongS>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opShortIntLongS, iceP_p1, iceP_p2, iceP_p3, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opShortIntLongS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<LongS, ShortS, IntS, LongS>>>& outAsync, const ShortS& iceP_p1, const IntS& iceP_p2, const LongS& iceP_p3, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "opShortIntLongS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p1, iceP_p2, iceP_p3);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<LongS, ShortS, IntS, LongS> v;
            istr->readAll(::std::get<1>(v), ::std::get<2>(v), ::std::get<3>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::DoubleS
Test::MyClassPrx::opFloatDoubleS(const FloatS& iceP_p1, const DoubleS& iceP_p2, FloatS& iceP_p3, DoubleS& iceP_p4, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<DoubleS, FloatS, DoubleS>>(true, this, &MyClassPrx::_iceI_opFloatDoubleS, iceP_p1, iceP_p2, context).get();
    iceP_p3 = ::std::move(::std::get<1>(_result));
    iceP_p4 = ::std::move(::std::get<2>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::DoubleS, ::Test::FloatS, ::Test::DoubleS>>
Test::MyClassPrx::opFloatDoubleSAsync(const FloatS& iceP_p1, const DoubleS& iceP_p2, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<DoubleS, FloatS, DoubleS>>(false, this, &MyClassPrx::_iceI_opFloatDoubleS, iceP_p1, iceP_p2, context);
}

::std::function<void()>
Test::MyClassPrx::opFloatDoubleSAsync(const FloatS& iceP_p1, const DoubleS& iceP_p2,
                                      ::std::function<void (::Test::DoubleS, ::Test::FloatS, ::Test::DoubleS)> response,
                                      ::std::function<void(::std::exception_ptr)> ex,
                                      ::std::function<void(bool)> sent,
                                      const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<DoubleS, FloatS, DoubleS>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)), ::std::move(::std::get<2>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<DoubleS, FloatS, DoubleS>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opFloatDoubleS, iceP_p1, iceP_p2, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opFloatDoubleS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<DoubleS, FloatS, DoubleS>>>& outAsync, const FloatS& iceP_p1, const DoubleS& iceP_p2, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "opFloatDoubleS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p1, iceP_p2);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<DoubleS, FloatS, DoubleS> v;
            istr->readAll(::std::get<1>(v), ::std::get<2>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::StringS
Test::MyClassPrx::opStringS(const StringS& iceP_p1, const StringS& iceP_p2, StringS& iceP_p3, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<StringS, StringS>>(true, this, &MyClassPrx::_iceI_opStringS, iceP_p1, iceP_p2, context).get();
    iceP_p3 = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::StringS, ::Test::StringS>>
Test::MyClassPrx::opStringSAsync(const StringS& iceP_p1, const StringS& iceP_p2, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<StringS, StringS>>(false, this, &MyClassPrx::_iceI_opStringS, iceP_p1, iceP_p2, context);
}

::std::function<void()>
Test::MyClassPrx::opStringSAsync(const StringS& iceP_p1, const StringS& iceP_p2,
                                 ::std::function<void (::Test::StringS, ::Test::StringS)> response,
                                 ::std::function<void(::std::exception_ptr)> ex,
                                 ::std::function<void(bool)> sent,
                                 const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<StringS, StringS>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<StringS, StringS>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opStringS, iceP_p1, iceP_p2, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opStringS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<StringS, StringS>>>& outAsync, const StringS& iceP_p1, const StringS& iceP_p2, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "opStringS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p1, iceP_p2);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<StringS, StringS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::ByteSS
Test::MyClassPrx::opByteSS(const ByteSS& iceP_p1, const ByteSS& iceP_p2, ByteSS& iceP_p3, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<ByteSS, ByteSS>>(true, this, &MyClassPrx::_iceI_opByteSS, iceP_p1, iceP_p2, context).get();
    iceP_p3 = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::ByteSS, ::Test::ByteSS>>
Test::MyClassPrx::opByteSSAsync(const ByteSS& iceP_p1, const ByteSS& iceP_p2, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<ByteSS, ByteSS>>(false, this, &MyClassPrx::_iceI_opByteSS, iceP_p1, iceP_p2, context);
}

::std::function<void()>
Test::MyClassPrx::opByteSSAsync(const ByteSS& iceP_p1, const ByteSS& iceP_p2,
                                ::std::function<void (::Test::ByteSS, ::Test::ByteSS)> response,
                                ::std::function<void(::std::exception_ptr)> ex,
                                ::std::function<void(bool)> sent,
                                const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<ByteSS, ByteSS>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<ByteSS, ByteSS>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opByteSS, iceP_p1, iceP_p2, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opByteSS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<ByteSS, ByteSS>>>& outAsync, const ByteSS& iceP_p1, const ByteSS& iceP_p2, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "opByteSS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p1, iceP_p2);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<ByteSS, ByteSS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::BoolSS
Test::MyClassPrx::opBoolSS(const BoolSS& iceP_p1, const BoolSS& iceP_p2, BoolSS& iceP_p3, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<BoolSS, BoolSS>>(true, this, &MyClassPrx::_iceI_opBoolSS, iceP_p1, iceP_p2, context).get();
    iceP_p3 = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::BoolSS, ::Test::BoolSS>>
Test::MyClassPrx::opBoolSSAsync(const BoolSS& iceP_p1, const BoolSS& iceP_p2, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<BoolSS, BoolSS>>(false, this, &MyClassPrx::_iceI_opBoolSS, iceP_p1, iceP_p2, context);
}

::std::function<void()>
Test::MyClassPrx::opBoolSSAsync(const BoolSS& iceP_p1, const BoolSS& iceP_p2,
                                ::std::function<void (::Test::BoolSS, ::Test::BoolSS)> response,
                                ::std::function<void(::std::exception_ptr)> ex,
                                ::std::function<void(bool)> sent,
                                const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<BoolSS, BoolSS>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<BoolSS, BoolSS>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opBoolSS, iceP_p1, iceP_p2, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opBoolSS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<BoolSS, BoolSS>>>& outAsync, const BoolSS& iceP_p1, const BoolSS& iceP_p2, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "opBoolSS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p1, iceP_p2);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<BoolSS, BoolSS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::LongSS
Test::MyClassPrx::opShortIntLongSS(const ShortSS& iceP_p1, const IntSS& iceP_p2, const LongSS& iceP_p3, ShortSS& iceP_p4, IntSS& iceP_p5, LongSS& iceP_p6, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<LongSS, ShortSS, IntSS, LongSS>>(true, this, &MyClassPrx::_iceI_opShortIntLongSS, iceP_p1, iceP_p2, iceP_p3, context).get();
    iceP_p4 = ::std::move(::std::get<1>(_result));
    iceP_p5 = ::std::move(::std::get<2>(_result));
    iceP_p6 = ::std::move(::std::get<3>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::LongSS, ::Test::ShortSS, ::Test::IntSS, ::Test::LongSS>>
Test::MyClassPrx::opShortIntLongSSAsync(const ShortSS& iceP_p1, const IntSS& iceP_p2, const LongSS& iceP_p3, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<LongSS, ShortSS, IntSS, LongSS>>(false, this, &MyClassPrx::_iceI_opShortIntLongSS, iceP_p1, iceP_p2, iceP_p3, context);
}

::std::function<void()>
Test::MyClassPrx::opShortIntLongSSAsync(const ShortSS& iceP_p1, const IntSS& iceP_p2, const LongSS& iceP_p3,
                                        ::std::function<void (::Test::LongSS, ::Test::ShortSS, ::Test::IntSS, ::Test::LongSS)> response,
                                        ::std::function<void(::std::exception_ptr)> ex,
                                        ::std::function<void(bool)> sent,
                                        const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<LongSS, ShortSS, IntSS, LongSS>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)), ::std::move(::std::get<2>(_result)), ::std::move(::std::get<3>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<LongSS, ShortSS, IntSS, LongSS>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opShortIntLongSS, iceP_p1, iceP_p2, iceP_p3, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opShortIntLongSS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<LongSS, ShortSS, IntSS, LongSS>>>& outAsync, const ShortSS& iceP_p1, const IntSS& iceP_p2, const LongSS& iceP_p3, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "opShortIntLongSS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p1, iceP_p2, iceP_p3);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<LongSS, ShortSS, IntSS, LongSS> v;
            istr->readAll(::std::get<1>(v), ::std::get<2>(v), ::std::get<3>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::DoubleSS
Test::MyClassPrx::opFloatDoubleSS(const FloatSS& iceP_p1, const DoubleSS& iceP_p2, FloatSS& iceP_p3, DoubleSS& iceP_p4, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<DoubleSS, FloatSS, DoubleSS>>(true, this, &MyClassPrx::_iceI_opFloatDoubleSS, iceP_p1, iceP_p2, context).get();
    iceP_p3 = ::std::move(::std::get<1>(_result));
    iceP_p4 = ::std::move(::std::get<2>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::DoubleSS, ::Test::FloatSS, ::Test::DoubleSS>>
Test::MyClassPrx::opFloatDoubleSSAsync(const FloatSS& iceP_p1, const DoubleSS& iceP_p2, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<DoubleSS, FloatSS, DoubleSS>>(false, this, &MyClassPrx::_iceI_opFloatDoubleSS, iceP_p1, iceP_p2, context);
}

::std::function<void()>
Test::MyClassPrx::opFloatDoubleSSAsync(const FloatSS& iceP_p1, const DoubleSS& iceP_p2,
                                       ::std::function<void (::Test::DoubleSS, ::Test::FloatSS, ::Test::DoubleSS)> response,
                                       ::std::function<void(::std::exception_ptr)> ex,
                                       ::std::function<void(bool)> sent,
                                       const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<DoubleSS, FloatSS, DoubleSS>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)), ::std::move(::std::get<2>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<DoubleSS, FloatSS, DoubleSS>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opFloatDoubleSS, iceP_p1, iceP_p2, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opFloatDoubleSS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<DoubleSS, FloatSS, DoubleSS>>>& outAsync, const FloatSS& iceP_p1, const DoubleSS& iceP_p2, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "opFloatDoubleSS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p1, iceP_p2);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<DoubleSS, FloatSS, DoubleSS> v;
            istr->readAll(::std::get<1>(v), ::std::get<2>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::StringSS
Test::MyClassPrx::opStringSS(const StringSS& iceP_p1, const StringSS& iceP_p2, StringSS& iceP_p3, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<StringSS, StringSS>>(true, this, &MyClassPrx::_iceI_opStringSS, iceP_p1, iceP_p2, context).get();
    iceP_p3 = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::StringSS, ::Test::StringSS>>
Test::MyClassPrx::opStringSSAsync(const StringSS& iceP_p1, const StringSS& iceP_p2, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<StringSS, StringSS>>(false, this, &MyClassPrx::_iceI_opStringSS, iceP_p1, iceP_p2, context);
}

::std::function<void()>
Test::MyClassPrx::opStringSSAsync(const StringSS& iceP_p1, const StringSS& iceP_p2,
                                  ::std::function<void (::Test::StringSS, ::Test::StringSS)> response,
                                  ::std::function<void(::std::exception_ptr)> ex,
                                  ::std::function<void(bool)> sent,
                                  const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<StringSS, StringSS>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<StringSS, StringSS>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opStringSS, iceP_p1, iceP_p2, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opStringSS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<StringSS, StringSS>>>& outAsync, const StringSS& iceP_p1, const StringSS& iceP_p2, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "opStringSS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p1, iceP_p2);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<StringSS, StringSS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::StringSSS
Test::MyClassPrx::opStringSSS(const StringSSS& iceP_p1, const StringSSS& iceP_p2, StringSSS& iceP_p3, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<StringSSS, StringSSS>>(true, this, &MyClassPrx::_iceI_opStringSSS, iceP_p1, iceP_p2, context).get();
    iceP_p3 = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::StringSSS, ::Test::StringSSS>>
Test::MyClassPrx::opStringSSSAsync(const StringSSS& iceP_p1, const StringSSS& iceP_p2, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<StringSSS, StringSSS>>(false, this, &MyClassPrx::_iceI_opStringSSS, iceP_p1, iceP_p2, context);
}

::std::function<void()>
Test::MyClassPrx::opStringSSSAsync(const StringSSS& iceP_p1, const StringSSS& iceP_p2,
                                   ::std::function<void (::Test::StringSSS, ::Test::StringSSS)> response,
                                   ::std::function<void(::std::exception_ptr)> ex,
                                   ::std::function<void(bool)> sent,
                                   const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<StringSSS, StringSSS>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<StringSSS, StringSSS>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opStringSSS, iceP_p1, iceP_p2, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opStringSSS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<StringSSS, StringSSS>>>& outAsync, const StringSSS& iceP_p1, const StringSSS& iceP_p2, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "opStringSSS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p1, iceP_p2);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<StringSSS, StringSSS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::ByteBoolD
Test::MyClassPrx::opByteBoolD(const ByteBoolD& iceP_p1, const ByteBoolD& iceP_p2, ByteBoolD& iceP_p3, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<ByteBoolD, ByteBoolD>>(true, this, &MyClassPrx::_iceI_opByteBoolD, iceP_p1, iceP_p2, context).get();
    iceP_p3 = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::ByteBoolD, ::Test::ByteBoolD>>
Test::MyClassPrx::opByteBoolDAsync(const ByteBoolD& iceP_p1, const ByteBoolD& iceP_p2, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<ByteBoolD, ByteBoolD>>(false, this, &MyClassPrx::_iceI_opByteBoolD, iceP_p1, iceP_p2, context);
}

::std::function<void()>
Test::MyClassPrx::opByteBoolDAsync(const ByteBoolD& iceP_p1, const ByteBoolD& iceP_p2,
                                   ::std::function<void (::Test::ByteBoolD, ::Test::ByteBoolD)> response,
                                   ::std::function<void(::std::exception_ptr)> ex,
                                   ::std::function<void(bool)> sent,
                                   const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<ByteBoolD, ByteBoolD>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<ByteBoolD, ByteBoolD>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opByteBoolD, iceP_p1, iceP_p2, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opByteBoolD(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<ByteBoolD, ByteBoolD>>>& outAsync, const ByteBoolD& iceP_p1, const ByteBoolD& iceP_p2, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "opByteBoolD";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p1, iceP_p2);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<ByteBoolD, ByteBoolD> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::ShortIntD
Test::MyClassPrx::opShortIntD(const ShortIntD& iceP_p1, const ShortIntD& iceP_p2, ShortIntD& iceP_p3, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<ShortIntD, ShortIntD>>(true, this, &MyClassPrx::_iceI_opShortIntD, iceP_p1, iceP_p2, context).get();
    iceP_p3 = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::ShortIntD, ::Test::ShortIntD>>
Test::MyClassPrx::opShortIntDAsync(const ShortIntD& iceP_p1, const ShortIntD& iceP_p2, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<ShortIntD, ShortIntD>>(false, this, &MyClassPrx::_iceI_opShortIntD, iceP_p1, iceP_p2, context);
}

::std::function<void()>
Test::MyClassPrx::opShortIntDAsync(const ShortIntD& iceP_p1, const ShortIntD& iceP_p2,
                                   ::std::function<void (::Test::ShortIntD, ::Test::ShortIntD)> response,
                                   ::std::function<void(::std::exception_ptr)> ex,
                                   ::std::function<void(bool)> sent,
                                   const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<ShortIntD, ShortIntD>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<ShortIntD, ShortIntD>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opShortIntD, iceP_p1, iceP_p2, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opShortIntD(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<ShortIntD, ShortIntD>>>& outAsync, const ShortIntD& iceP_p1, const ShortIntD& iceP_p2, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "opShortIntD";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p1, iceP_p2);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<ShortIntD, ShortIntD> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::LongFloatD
Test::MyClassPrx::opLongFloatD(const LongFloatD& iceP_p1, const LongFloatD& iceP_p2, LongFloatD& iceP_p3, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<LongFloatD, LongFloatD>>(true, this, &MyClassPrx::_iceI_opLongFloatD, iceP_p1, iceP_p2, context).get();
    iceP_p3 = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::LongFloatD, ::Test::LongFloatD>>
Test::MyClassPrx::opLongFloatDAsync(const LongFloatD& iceP_p1, const LongFloatD& iceP_p2, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<LongFloatD, LongFloatD>>(false, this, &MyClassPrx::_iceI_opLongFloatD, iceP_p1, iceP_p2, context);
}

::std::function<void()>
Test::MyClassPrx::opLongFloatDAsync(const LongFloatD& iceP_p1, const LongFloatD& iceP_p2,
                                    ::std::function<void (::Test::LongFloatD, ::Test::LongFloatD)> response,
                                    ::std::function<void(::std::exception_ptr)> ex,
                                    ::std::function<void(bool)> sent,
                                    const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<LongFloatD, LongFloatD>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<LongFloatD, LongFloatD>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opLongFloatD, iceP_p1, iceP_p2, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opLongFloatD(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<LongFloatD, LongFloatD>>>& outAsync, const LongFloatD& iceP_p1, const LongFloatD& iceP_p2, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "opLongFloatD";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p1, iceP_p2);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<LongFloatD, LongFloatD> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::StringStringD
Test::MyClassPrx::opStringStringD(const StringStringD& iceP_p1, const StringStringD& iceP_p2, StringStringD& iceP_p3, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<StringStringD, StringStringD>>(true, this, &MyClassPrx::_iceI_opStringStringD, iceP_p1, iceP_p2, context).get();
    iceP_p3 = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::StringStringD, ::Test::StringStringD>>
Test::MyClassPrx::opStringStringDAsync(const StringStringD& iceP_p1, const StringStringD& iceP_p2, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<StringStringD, StringStringD>>(false, this, &MyClassPrx::_iceI_opStringStringD, iceP_p1, iceP_p2, context);
}

::std::function<void()>
Test::MyClassPrx::opStringStringDAsync(const StringStringD& iceP_p1, const StringStringD& iceP_p2,
                                       ::std::function<void (::Test::StringStringD, ::Test::StringStringD)> response,
                                       ::std::function<void(::std::exception_ptr)> ex,
                                       ::std::function<void(bool)> sent,
                                       const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<StringStringD, StringStringD>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<StringStringD, StringStringD>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opStringStringD, iceP_p1, iceP_p2, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opStringStringD(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<StringStringD, StringStringD>>>& outAsync, const StringStringD& iceP_p1, const StringStringD& iceP_p2, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "opStringStringD";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p1, iceP_p2);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<StringStringD, StringStringD> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::StringMyEnumD
Test::MyClassPrx::opStringMyEnumD(const StringMyEnumD& iceP_p1, const StringMyEnumD& iceP_p2, StringMyEnumD& iceP_p3, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<StringMyEnumD, StringMyEnumD>>(true, this, &MyClassPrx::_iceI_opStringMyEnumD, iceP_p1, iceP_p2, context).get();
    iceP_p3 = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::StringMyEnumD, ::Test::StringMyEnumD>>
Test::MyClassPrx::opStringMyEnumDAsync(const StringMyEnumD& iceP_p1, const StringMyEnumD& iceP_p2, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<StringMyEnumD, StringMyEnumD>>(false, this, &MyClassPrx::_iceI_opStringMyEnumD, iceP_p1, iceP_p2, context);
}

::std::function<void()>
Test::MyClassPrx::opStringMyEnumDAsync(const StringMyEnumD& iceP_p1, const StringMyEnumD& iceP_p2,
                                       ::std::function<void (::Test::StringMyEnumD, ::Test::StringMyEnumD)> response,
                                       ::std::function<void(::std::exception_ptr)> ex,
                                       ::std::function<void(bool)> sent,
                                       const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<StringMyEnumD, StringMyEnumD>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<StringMyEnumD, StringMyEnumD>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opStringMyEnumD, iceP_p1, iceP_p2, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opStringMyEnumD(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<StringMyEnumD, StringMyEnumD>>>& outAsync, const StringMyEnumD& iceP_p1, const StringMyEnumD& iceP_p2, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "opStringMyEnumD";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p1, iceP_p2);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<StringMyEnumD, StringMyEnumD> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::MyEnumStringD
Test::MyClassPrx::opMyEnumStringD(const MyEnumStringD& iceP_p1, const MyEnumStringD& iceP_p2, MyEnumStringD& iceP_p3, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<MyEnumStringD, MyEnumStringD>>(true, this, &MyClassPrx::_iceI_opMyEnumStringD, iceP_p1, iceP_p2, context).get();
    iceP_p3 = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::MyEnumStringD, ::Test::MyEnumStringD>>
Test::MyClassPrx::opMyEnumStringDAsync(const MyEnumStringD& iceP_p1, const MyEnumStringD& iceP_p2, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<MyEnumStringD, MyEnumStringD>>(false, this, &MyClassPrx::_iceI_opMyEnumStringD, iceP_p1, iceP_p2, context);
}

::std::function<void()>
Test::MyClassPrx::opMyEnumStringDAsync(const MyEnumStringD& iceP_p1, const MyEnumStringD& iceP_p2,
                                       ::std::function<void (::Test::MyEnumStringD, ::Test::MyEnumStringD)> response,
                                       ::std::function<void(::std::exception_ptr)> ex,
                                       ::std::function<void(bool)> sent,
                                       const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<MyEnumStringD, MyEnumStringD>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<MyEnumStringD, MyEnumStringD>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opMyEnumStringD, iceP_p1, iceP_p2, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opMyEnumStringD(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<MyEnumStringD, MyEnumStringD>>>& outAsync, const MyEnumStringD& iceP_p1, const MyEnumStringD& iceP_p2, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "opMyEnumStringD";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p1, iceP_p2);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<MyEnumStringD, MyEnumStringD> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::MyStructMyEnumD
Test::MyClassPrx::opMyStructMyEnumD(const MyStructMyEnumD& iceP_p1, const MyStructMyEnumD& iceP_p2, MyStructMyEnumD& iceP_p3, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<MyStructMyEnumD, MyStructMyEnumD>>(true, this, &MyClassPrx::_iceI_opMyStructMyEnumD, iceP_p1, iceP_p2, context).get();
    iceP_p3 = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::MyStructMyEnumD, ::Test::MyStructMyEnumD>>
Test::MyClassPrx::opMyStructMyEnumDAsync(const MyStructMyEnumD& iceP_p1, const MyStructMyEnumD& iceP_p2, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<MyStructMyEnumD, MyStructMyEnumD>>(false, this, &MyClassPrx::_iceI_opMyStructMyEnumD, iceP_p1, iceP_p2, context);
}

::std::function<void()>
Test::MyClassPrx::opMyStructMyEnumDAsync(const MyStructMyEnumD& iceP_p1, const MyStructMyEnumD& iceP_p2,
                                         ::std::function<void (::Test::MyStructMyEnumD, ::Test::MyStructMyEnumD)> response,
                                         ::std::function<void(::std::exception_ptr)> ex,
                                         ::std::function<void(bool)> sent,
                                         const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<MyStructMyEnumD, MyStructMyEnumD>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<MyStructMyEnumD, MyStructMyEnumD>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opMyStructMyEnumD, iceP_p1, iceP_p2, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opMyStructMyEnumD(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<MyStructMyEnumD, MyStructMyEnumD>>>& outAsync, const MyStructMyEnumD& iceP_p1, const MyStructMyEnumD& iceP_p2, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "opMyStructMyEnumD";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p1, iceP_p2);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<MyStructMyEnumD, MyStructMyEnumD> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::ByteBoolDS
Test::MyClassPrx::opByteBoolDS(const ByteBoolDS& iceP_p1, const ByteBoolDS& iceP_p2, ByteBoolDS& iceP_p3, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<ByteBoolDS, ByteBoolDS>>(true, this, &MyClassPrx::_iceI_opByteBoolDS, iceP_p1, iceP_p2, context).get();
    iceP_p3 = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::ByteBoolDS, ::Test::ByteBoolDS>>
Test::MyClassPrx::opByteBoolDSAsync(const ByteBoolDS& iceP_p1, const ByteBoolDS& iceP_p2, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<ByteBoolDS, ByteBoolDS>>(false, this, &MyClassPrx::_iceI_opByteBoolDS, iceP_p1, iceP_p2, context);
}

::std::function<void()>
Test::MyClassPrx::opByteBoolDSAsync(const ByteBoolDS& iceP_p1, const ByteBoolDS& iceP_p2,
                                    ::std::function<void (::Test::ByteBoolDS, ::Test::ByteBoolDS)> response,
                                    ::std::function<void(::std::exception_ptr)> ex,
                                    ::std::function<void(bool)> sent,
                                    const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<ByteBoolDS, ByteBoolDS>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<ByteBoolDS, ByteBoolDS>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opByteBoolDS, iceP_p1, iceP_p2, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opByteBoolDS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<ByteBoolDS, ByteBoolDS>>>& outAsync, const ByteBoolDS& iceP_p1, const ByteBoolDS& iceP_p2, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "opByteBoolDS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p1, iceP_p2);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<ByteBoolDS, ByteBoolDS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::ShortIntDS
Test::MyClassPrx::opShortIntDS(const ShortIntDS& iceP_p1, const ShortIntDS& iceP_p2, ShortIntDS& iceP_p3, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<ShortIntDS, ShortIntDS>>(true, this, &MyClassPrx::_iceI_opShortIntDS, iceP_p1, iceP_p2, context).get();
    iceP_p3 = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::ShortIntDS, ::Test::ShortIntDS>>
Test::MyClassPrx::opShortIntDSAsync(const ShortIntDS& iceP_p1, const ShortIntDS& iceP_p2, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<ShortIntDS, ShortIntDS>>(false, this, &MyClassPrx::_iceI_opShortIntDS, iceP_p1, iceP_p2, context);
}

::std::function<void()>
Test::MyClassPrx::opShortIntDSAsync(const ShortIntDS& iceP_p1, const ShortIntDS& iceP_p2,
                                    ::std::function<void (::Test::ShortIntDS, ::Test::ShortIntDS)> response,
                                    ::std::function<void(::std::exception_ptr)> ex,
                                    ::std::function<void(bool)> sent,
                                    const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<ShortIntDS, ShortIntDS>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<ShortIntDS, ShortIntDS>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opShortIntDS, iceP_p1, iceP_p2, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opShortIntDS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<ShortIntDS, ShortIntDS>>>& outAsync, const ShortIntDS& iceP_p1, const ShortIntDS& iceP_p2, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "opShortIntDS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p1, iceP_p2);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<ShortIntDS, ShortIntDS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::LongFloatDS
Test::MyClassPrx::opLongFloatDS(const LongFloatDS& iceP_p1, const LongFloatDS& iceP_p2, LongFloatDS& iceP_p3, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<LongFloatDS, LongFloatDS>>(true, this, &MyClassPrx::_iceI_opLongFloatDS, iceP_p1, iceP_p2, context).get();
    iceP_p3 = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::LongFloatDS, ::Test::LongFloatDS>>
Test::MyClassPrx::opLongFloatDSAsync(const LongFloatDS& iceP_p1, const LongFloatDS& iceP_p2, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<LongFloatDS, LongFloatDS>>(false, this, &MyClassPrx::_iceI_opLongFloatDS, iceP_p1, iceP_p2, context);
}

::std::function<void()>
Test::MyClassPrx::opLongFloatDSAsync(const LongFloatDS& iceP_p1, const LongFloatDS& iceP_p2,
                                     ::std::function<void (::Test::LongFloatDS, ::Test::LongFloatDS)> response,
                                     ::std::function<void(::std::exception_ptr)> ex,
                                     ::std::function<void(bool)> sent,
                                     const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<LongFloatDS, LongFloatDS>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<LongFloatDS, LongFloatDS>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opLongFloatDS, iceP_p1, iceP_p2, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opLongFloatDS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<LongFloatDS, LongFloatDS>>>& outAsync, const LongFloatDS& iceP_p1, const LongFloatDS& iceP_p2, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "opLongFloatDS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p1, iceP_p2);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<LongFloatDS, LongFloatDS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::StringStringDS
Test::MyClassPrx::opStringStringDS(const StringStringDS& iceP_p1, const StringStringDS& iceP_p2, StringStringDS& iceP_p3, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<StringStringDS, StringStringDS>>(true, this, &MyClassPrx::_iceI_opStringStringDS, iceP_p1, iceP_p2, context).get();
    iceP_p3 = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::StringStringDS, ::Test::StringStringDS>>
Test::MyClassPrx::opStringStringDSAsync(const StringStringDS& iceP_p1, const StringStringDS& iceP_p2, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<StringStringDS, StringStringDS>>(false, this, &MyClassPrx::_iceI_opStringStringDS, iceP_p1, iceP_p2, context);
}

::std::function<void()>
Test::MyClassPrx::opStringStringDSAsync(const StringStringDS& iceP_p1, const StringStringDS& iceP_p2,
                                        ::std::function<void (::Test::StringStringDS, ::Test::StringStringDS)> response,
                                        ::std::function<void(::std::exception_ptr)> ex,
                                        ::std::function<void(bool)> sent,
                                        const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<StringStringDS, StringStringDS>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<StringStringDS, StringStringDS>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opStringStringDS, iceP_p1, iceP_p2, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opStringStringDS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<StringStringDS, StringStringDS>>>& outAsync, const StringStringDS& iceP_p1, const StringStringDS& iceP_p2, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "opStringStringDS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p1, iceP_p2);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<StringStringDS, StringStringDS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::StringMyEnumDS
Test::MyClassPrx::opStringMyEnumDS(const StringMyEnumDS& iceP_p1, const StringMyEnumDS& iceP_p2, StringMyEnumDS& iceP_p3, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<StringMyEnumDS, StringMyEnumDS>>(true, this, &MyClassPrx::_iceI_opStringMyEnumDS, iceP_p1, iceP_p2, context).get();
    iceP_p3 = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::StringMyEnumDS, ::Test::StringMyEnumDS>>
Test::MyClassPrx::opStringMyEnumDSAsync(const StringMyEnumDS& iceP_p1, const StringMyEnumDS& iceP_p2, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<StringMyEnumDS, StringMyEnumDS>>(false, this, &MyClassPrx::_iceI_opStringMyEnumDS, iceP_p1, iceP_p2, context);
}

::std::function<void()>
Test::MyClassPrx::opStringMyEnumDSAsync(const StringMyEnumDS& iceP_p1, const StringMyEnumDS& iceP_p2,
                                        ::std::function<void (::Test::StringMyEnumDS, ::Test::StringMyEnumDS)> response,
                                        ::std::function<void(::std::exception_ptr)> ex,
                                        ::std::function<void(bool)> sent,
                                        const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<StringMyEnumDS, StringMyEnumDS>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<StringMyEnumDS, StringMyEnumDS>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opStringMyEnumDS, iceP_p1, iceP_p2, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opStringMyEnumDS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<StringMyEnumDS, StringMyEnumDS>>>& outAsync, const StringMyEnumDS& iceP_p1, const StringMyEnumDS& iceP_p2, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "opStringMyEnumDS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p1, iceP_p2);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<StringMyEnumDS, StringMyEnumDS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::MyEnumStringDS
Test::MyClassPrx::opMyEnumStringDS(const MyEnumStringDS& iceP_p1, const MyEnumStringDS& iceP_p2, MyEnumStringDS& iceP_p3, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<MyEnumStringDS, MyEnumStringDS>>(true, this, &MyClassPrx::_iceI_opMyEnumStringDS, iceP_p1, iceP_p2, context).get();
    iceP_p3 = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::MyEnumStringDS, ::Test::MyEnumStringDS>>
Test::MyClassPrx::opMyEnumStringDSAsync(const MyEnumStringDS& iceP_p1, const MyEnumStringDS& iceP_p2, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<MyEnumStringDS, MyEnumStringDS>>(false, this, &MyClassPrx::_iceI_opMyEnumStringDS, iceP_p1, iceP_p2, context);
}

::std::function<void()>
Test::MyClassPrx::opMyEnumStringDSAsync(const MyEnumStringDS& iceP_p1, const MyEnumStringDS& iceP_p2,
                                        ::std::function<void (::Test::MyEnumStringDS, ::Test::MyEnumStringDS)> response,
                                        ::std::function<void(::std::exception_ptr)> ex,
                                        ::std::function<void(bool)> sent,
                                        const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<MyEnumStringDS, MyEnumStringDS>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<MyEnumStringDS, MyEnumStringDS>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opMyEnumStringDS, iceP_p1, iceP_p2, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opMyEnumStringDS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<MyEnumStringDS, MyEnumStringDS>>>& outAsync, const MyEnumStringDS& iceP_p1, const MyEnumStringDS& iceP_p2, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "opMyEnumStringDS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p1, iceP_p2);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<MyEnumStringDS, MyEnumStringDS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::MyStructMyEnumDS
Test::MyClassPrx::opMyStructMyEnumDS(const MyStructMyEnumDS& iceP_p1, const MyStructMyEnumDS& iceP_p2, MyStructMyEnumDS& iceP_p3, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<MyStructMyEnumDS, MyStructMyEnumDS>>(true, this, &MyClassPrx::_iceI_opMyStructMyEnumDS, iceP_p1, iceP_p2, context).get();
    iceP_p3 = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::MyStructMyEnumDS, ::Test::MyStructMyEnumDS>>
Test::MyClassPrx::opMyStructMyEnumDSAsync(const MyStructMyEnumDS& iceP_p1, const MyStructMyEnumDS& iceP_p2, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<MyStructMyEnumDS, MyStructMyEnumDS>>(false, this, &MyClassPrx::_iceI_opMyStructMyEnumDS, iceP_p1, iceP_p2, context);
}

::std::function<void()>
Test::MyClassPrx::opMyStructMyEnumDSAsync(const MyStructMyEnumDS& iceP_p1, const MyStructMyEnumDS& iceP_p2,
                                          ::std::function<void (::Test::MyStructMyEnumDS, ::Test::MyStructMyEnumDS)> response,
                                          ::std::function<void(::std::exception_ptr)> ex,
                                          ::std::function<void(bool)> sent,
                                          const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<MyStructMyEnumDS, MyStructMyEnumDS>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<MyStructMyEnumDS, MyStructMyEnumDS>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opMyStructMyEnumDS, iceP_p1, iceP_p2, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opMyStructMyEnumDS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<MyStructMyEnumDS, MyStructMyEnumDS>>>& outAsync, const MyStructMyEnumDS& iceP_p1, const MyStructMyEnumDS& iceP_p2, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "opMyStructMyEnumDS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p1, iceP_p2);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<MyStructMyEnumDS, MyStructMyEnumDS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::ByteByteSD
Test::MyClassPrx::opByteByteSD(const ByteByteSD& iceP_p1, const ByteByteSD& iceP_p2, ByteByteSD& iceP_p3, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<ByteByteSD, ByteByteSD>>(true, this, &MyClassPrx::_iceI_opByteByteSD, iceP_p1, iceP_p2, context).get();
    iceP_p3 = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::ByteByteSD, ::Test::ByteByteSD>>
Test::MyClassPrx::opByteByteSDAsync(const ByteByteSD& iceP_p1, const ByteByteSD& iceP_p2, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<ByteByteSD, ByteByteSD>>(false, this, &MyClassPrx::_iceI_opByteByteSD, iceP_p1, iceP_p2, context);
}

::std::function<void()>
Test::MyClassPrx::opByteByteSDAsync(const ByteByteSD& iceP_p1, const ByteByteSD& iceP_p2,
                                    ::std::function<void (::Test::ByteByteSD, ::Test::ByteByteSD)> response,
                                    ::std::function<void(::std::exception_ptr)> ex,
                                    ::std::function<void(bool)> sent,
                                    const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<ByteByteSD, ByteByteSD>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<ByteByteSD, ByteByteSD>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opByteByteSD, iceP_p1, iceP_p2, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opByteByteSD(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<ByteByteSD, ByteByteSD>>>& outAsync, const ByteByteSD& iceP_p1, const ByteByteSD& iceP_p2, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "opByteByteSD";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p1, iceP_p2);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<ByteByteSD, ByteByteSD> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::BoolBoolSD
Test::MyClassPrx::opBoolBoolSD(const BoolBoolSD& iceP_p1, const BoolBoolSD& iceP_p2, BoolBoolSD& iceP_p3, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<BoolBoolSD, BoolBoolSD>>(true, this, &MyClassPrx::_iceI_opBoolBoolSD, iceP_p1, iceP_p2, context).get();
    iceP_p3 = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::BoolBoolSD, ::Test::BoolBoolSD>>
Test::MyClassPrx::opBoolBoolSDAsync(const BoolBoolSD& iceP_p1, const BoolBoolSD& iceP_p2, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<BoolBoolSD, BoolBoolSD>>(false, this, &MyClassPrx::_iceI_opBoolBoolSD, iceP_p1, iceP_p2, context);
}

::std::function<void()>
Test::MyClassPrx::opBoolBoolSDAsync(const BoolBoolSD& iceP_p1, const BoolBoolSD& iceP_p2,
                                    ::std::function<void (::Test::BoolBoolSD, ::Test::BoolBoolSD)> response,
                                    ::std::function<void(::std::exception_ptr)> ex,
                                    ::std::function<void(bool)> sent,
                                    const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<BoolBoolSD, BoolBoolSD>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<BoolBoolSD, BoolBoolSD>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opBoolBoolSD, iceP_p1, iceP_p2, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opBoolBoolSD(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<BoolBoolSD, BoolBoolSD>>>& outAsync, const BoolBoolSD& iceP_p1, const BoolBoolSD& iceP_p2, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "opBoolBoolSD";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p1, iceP_p2);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<BoolBoolSD, BoolBoolSD> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::ShortShortSD
Test::MyClassPrx::opShortShortSD(const ShortShortSD& iceP_p1, const ShortShortSD& iceP_p2, ShortShortSD& iceP_p3, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<ShortShortSD, ShortShortSD>>(true, this, &MyClassPrx::_iceI_opShortShortSD, iceP_p1, iceP_p2, context).get();
    iceP_p3 = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::ShortShortSD, ::Test::ShortShortSD>>
Test::MyClassPrx::opShortShortSDAsync(const ShortShortSD& iceP_p1, const ShortShortSD& iceP_p2, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<ShortShortSD, ShortShortSD>>(false, this, &MyClassPrx::_iceI_opShortShortSD, iceP_p1, iceP_p2, context);
}

::std::function<void()>
Test::MyClassPrx::opShortShortSDAsync(const ShortShortSD& iceP_p1, const ShortShortSD& iceP_p2,
                                      ::std::function<void (::Test::ShortShortSD, ::Test::ShortShortSD)> response,
                                      ::std::function<void(::std::exception_ptr)> ex,
                                      ::std::function<void(bool)> sent,
                                      const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<ShortShortSD, ShortShortSD>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<ShortShortSD, ShortShortSD>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opShortShortSD, iceP_p1, iceP_p2, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opShortShortSD(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<ShortShortSD, ShortShortSD>>>& outAsync, const ShortShortSD& iceP_p1, const ShortShortSD& iceP_p2, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "opShortShortSD";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p1, iceP_p2);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<ShortShortSD, ShortShortSD> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::IntIntSD
Test::MyClassPrx::opIntIntSD(const IntIntSD& iceP_p1, const IntIntSD& iceP_p2, IntIntSD& iceP_p3, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<IntIntSD, IntIntSD>>(true, this, &MyClassPrx::_iceI_opIntIntSD, iceP_p1, iceP_p2, context).get();
    iceP_p3 = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::IntIntSD, ::Test::IntIntSD>>
Test::MyClassPrx::opIntIntSDAsync(const IntIntSD& iceP_p1, const IntIntSD& iceP_p2, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<IntIntSD, IntIntSD>>(false, this, &MyClassPrx::_iceI_opIntIntSD, iceP_p1, iceP_p2, context);
}

::std::function<void()>
Test::MyClassPrx::opIntIntSDAsync(const IntIntSD& iceP_p1, const IntIntSD& iceP_p2,
                                  ::std::function<void (::Test::IntIntSD, ::Test::IntIntSD)> response,
                                  ::std::function<void(::std::exception_ptr)> ex,
                                  ::std::function<void(bool)> sent,
                                  const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<IntIntSD, IntIntSD>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<IntIntSD, IntIntSD>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opIntIntSD, iceP_p1, iceP_p2, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opIntIntSD(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<IntIntSD, IntIntSD>>>& outAsync, const IntIntSD& iceP_p1, const IntIntSD& iceP_p2, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "opIntIntSD";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p1, iceP_p2);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<IntIntSD, IntIntSD> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::LongLongSD
Test::MyClassPrx::opLongLongSD(const LongLongSD& iceP_p1, const LongLongSD& iceP_p2, LongLongSD& iceP_p3, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<LongLongSD, LongLongSD>>(true, this, &MyClassPrx::_iceI_opLongLongSD, iceP_p1, iceP_p2, context).get();
    iceP_p3 = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::LongLongSD, ::Test::LongLongSD>>
Test::MyClassPrx::opLongLongSDAsync(const LongLongSD& iceP_p1, const LongLongSD& iceP_p2, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<LongLongSD, LongLongSD>>(false, this, &MyClassPrx::_iceI_opLongLongSD, iceP_p1, iceP_p2, context);
}

::std::function<void()>
Test::MyClassPrx::opLongLongSDAsync(const LongLongSD& iceP_p1, const LongLongSD& iceP_p2,
                                    ::std::function<void (::Test::LongLongSD, ::Test::LongLongSD)> response,
                                    ::std::function<void(::std::exception_ptr)> ex,
                                    ::std::function<void(bool)> sent,
                                    const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<LongLongSD, LongLongSD>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<LongLongSD, LongLongSD>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opLongLongSD, iceP_p1, iceP_p2, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opLongLongSD(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<LongLongSD, LongLongSD>>>& outAsync, const LongLongSD& iceP_p1, const LongLongSD& iceP_p2, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "opLongLongSD";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p1, iceP_p2);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<LongLongSD, LongLongSD> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::StringFloatSD
Test::MyClassPrx::opStringFloatSD(const StringFloatSD& iceP_p1, const StringFloatSD& iceP_p2, StringFloatSD& iceP_p3, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<StringFloatSD, StringFloatSD>>(true, this, &MyClassPrx::_iceI_opStringFloatSD, iceP_p1, iceP_p2, context).get();
    iceP_p3 = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::StringFloatSD, ::Test::StringFloatSD>>
Test::MyClassPrx::opStringFloatSDAsync(const StringFloatSD& iceP_p1, const StringFloatSD& iceP_p2, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<StringFloatSD, StringFloatSD>>(false, this, &MyClassPrx::_iceI_opStringFloatSD, iceP_p1, iceP_p2, context);
}

::std::function<void()>
Test::MyClassPrx::opStringFloatSDAsync(const StringFloatSD& iceP_p1, const StringFloatSD& iceP_p2,
                                       ::std::function<void (::Test::StringFloatSD, ::Test::StringFloatSD)> response,
                                       ::std::function<void(::std::exception_ptr)> ex,
                                       ::std::function<void(bool)> sent,
                                       const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<StringFloatSD, StringFloatSD>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<StringFloatSD, StringFloatSD>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opStringFloatSD, iceP_p1, iceP_p2, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opStringFloatSD(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<StringFloatSD, StringFloatSD>>>& outAsync, const StringFloatSD& iceP_p1, const StringFloatSD& iceP_p2, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "opStringFloatSD";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p1, iceP_p2);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<StringFloatSD, StringFloatSD> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::StringDoubleSD
Test::MyClassPrx::opStringDoubleSD(const StringDoubleSD& iceP_p1, const StringDoubleSD& iceP_p2, StringDoubleSD& iceP_p3, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<StringDoubleSD, StringDoubleSD>>(true, this, &MyClassPrx::_iceI_opStringDoubleSD, iceP_p1, iceP_p2, context).get();
    iceP_p3 = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::StringDoubleSD, ::Test::StringDoubleSD>>
Test::MyClassPrx::opStringDoubleSDAsync(const StringDoubleSD& iceP_p1, const StringDoubleSD& iceP_p2, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<StringDoubleSD, StringDoubleSD>>(false, this, &MyClassPrx::_iceI_opStringDoubleSD, iceP_p1, iceP_p2, context);
}

::std::function<void()>
Test::MyClassPrx::opStringDoubleSDAsync(const StringDoubleSD& iceP_p1, const StringDoubleSD& iceP_p2,
                                        ::std::function<void (::Test::StringDoubleSD, ::Test::StringDoubleSD)> response,
                                        ::std::function<void(::std::exception_ptr)> ex,
                                        ::std::function<void(bool)> sent,
                                        const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<StringDoubleSD, StringDoubleSD>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<StringDoubleSD, StringDoubleSD>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opStringDoubleSD, iceP_p1, iceP_p2, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opStringDoubleSD(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<StringDoubleSD, StringDoubleSD>>>& outAsync, const StringDoubleSD& iceP_p1, const StringDoubleSD& iceP_p2, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "opStringDoubleSD";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p1, iceP_p2);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<StringDoubleSD, StringDoubleSD> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::StringStringSD
Test::MyClassPrx::opStringStringSD(const StringStringSD& iceP_p1, const StringStringSD& iceP_p2, StringStringSD& iceP_p3, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<StringStringSD, StringStringSD>>(true, this, &MyClassPrx::_iceI_opStringStringSD, iceP_p1, iceP_p2, context).get();
    iceP_p3 = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::StringStringSD, ::Test::StringStringSD>>
Test::MyClassPrx::opStringStringSDAsync(const StringStringSD& iceP_p1, const StringStringSD& iceP_p2, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<StringStringSD, StringStringSD>>(false, this, &MyClassPrx::_iceI_opStringStringSD, iceP_p1, iceP_p2, context);
}

::std::function<void()>
Test::MyClassPrx::opStringStringSDAsync(const StringStringSD& iceP_p1, const StringStringSD& iceP_p2,
                                        ::std::function<void (::Test::StringStringSD, ::Test::StringStringSD)> response,
                                        ::std::function<void(::std::exception_ptr)> ex,
                                        ::std::function<void(bool)> sent,
                                        const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<StringStringSD, StringStringSD>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<StringStringSD, StringStringSD>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opStringStringSD, iceP_p1, iceP_p2, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opStringStringSD(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<StringStringSD, StringStringSD>>>& outAsync, const StringStringSD& iceP_p1, const StringStringSD& iceP_p2, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "opStringStringSD";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p1, iceP_p2);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<StringStringSD, StringStringSD> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::MyEnumMyEnumSD
Test::MyClassPrx::opMyEnumMyEnumSD(const MyEnumMyEnumSD& iceP_p1, const MyEnumMyEnumSD& iceP_p2, MyEnumMyEnumSD& iceP_p3, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<MyEnumMyEnumSD, MyEnumMyEnumSD>>(true, this, &MyClassPrx::_iceI_opMyEnumMyEnumSD, iceP_p1, iceP_p2, context).get();
    iceP_p3 = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::MyEnumMyEnumSD, ::Test::MyEnumMyEnumSD>>
Test::MyClassPrx::opMyEnumMyEnumSDAsync(const MyEnumMyEnumSD& iceP_p1, const MyEnumMyEnumSD& iceP_p2, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<MyEnumMyEnumSD, MyEnumMyEnumSD>>(false, this, &MyClassPrx::_iceI_opMyEnumMyEnumSD, iceP_p1, iceP_p2, context);
}

::std::function<void()>
Test::MyClassPrx::opMyEnumMyEnumSDAsync(const MyEnumMyEnumSD& iceP_p1, const MyEnumMyEnumSD& iceP_p2,
                                        ::std::function<void (::Test::MyEnumMyEnumSD, ::Test::MyEnumMyEnumSD)> response,
                                        ::std::function<void(::std::exception_ptr)> ex,
                                        ::std::function<void(bool)> sent,
                                        const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<MyEnumMyEnumSD, MyEnumMyEnumSD>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<MyEnumMyEnumSD, MyEnumMyEnumSD>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opMyEnumMyEnumSD, iceP_p1, iceP_p2, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opMyEnumMyEnumSD(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<MyEnumMyEnumSD, MyEnumMyEnumSD>>>& outAsync, const MyEnumMyEnumSD& iceP_p1, const MyEnumMyEnumSD& iceP_p2, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "opMyEnumMyEnumSD";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p1, iceP_p2);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<MyEnumMyEnumSD, MyEnumMyEnumSD> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::IntS
Test::MyClassPrx::opIntS(const IntS& iceP_s, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<IntS>(true, this, &MyClassPrx::_iceI_opIntS, iceP_s, context).get();
}

::std::future<::Test::IntS>
Test::MyClassPrx::opIntSAsync(const IntS& iceP_s, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<IntS>(false, this, &MyClassPrx::_iceI_opIntS, iceP_s, context);
}

::std::function<void()>
Test::MyClassPrx::opIntSAsync(const IntS& iceP_s,
                              ::std::function<void (::Test::IntS)> response,
                              ::std::function<void(::std::exception_ptr)> ex,
                              ::std::function<void(bool)> sent,
                              const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<IntS>(std::move(response), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opIntS, iceP_s, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opIntS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<IntS>>& outAsync, const IntS& iceP_s, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "opIntS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_s);
        },
        nullptr);
}
/// \endcond

void
Test::MyClassPrx::opByteSOneway(const ByteS& iceP_s, const ::Ice::Context& context) const
{
    ::IceInternal::makePromiseOutgoing<void>(true, this, &MyClassPrx::_iceI_opByteSOneway, iceP_s, context).get();
}

::std::future<void>
Test::MyClassPrx::opByteSOnewayAsync(const ByteS& iceP_s, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<void>(false, this, &MyClassPrx::_iceI_opByteSOneway, iceP_s, context);
}

::std::function<void()>
Test::MyClassPrx::opByteSOnewayAsync(const ByteS& iceP_s,
                                     ::std::function<void ()> response,
                                     ::std::function<void(::std::exception_ptr)> ex,
                                     ::std::function<void(bool)> sent,
                                     const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opByteSOneway, iceP_s, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opByteSOneway(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ByteS& iceP_s, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "opByteSOneway";

    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_s);
        },
        nullptr);
}
/// \endcond

::std::int32_t
Test::MyClassPrx::opByteSOnewayCallCount(const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::int32_t>(true, this, &MyClassPrx::_iceI_opByteSOnewayCallCount, context).get();
}

::std::future<::std::int32_t>
Test::MyClassPrx::opByteSOnewayCallCountAsync(const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::int32_t>(false, this, &MyClassPrx::_iceI_opByteSOnewayCallCount, context);
}

::std::function<void()>
Test::MyClassPrx::opByteSOnewayCallCountAsync(::std::function<void (::std::int32_t)> response,
                                              ::std::function<void(::std::exception_ptr)> ex,
                                              ::std::function<void(bool)> sent,
                                              const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<::std::int32_t>(std::move(response), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opByteSOnewayCallCount, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opByteSOnewayCallCount(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::int32_t>>& outAsync, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "opByteSOnewayCallCount";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

::Ice::Context
Test::MyClassPrx::opContext(const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::Ice::Context>(true, this, &MyClassPrx::_iceI_opContext, context).get();
}

::std::future<::Ice::Context>
Test::MyClassPrx::opContextAsync(const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::Ice::Context>(false, this, &MyClassPrx::_iceI_opContext, context);
}

::std::function<void()>
Test::MyClassPrx::opContextAsync(::std::function<void (::Ice::Context)> response,
                                 ::std::function<void(::std::exception_ptr)> ex,
                                 ::std::function<void(bool)> sent,
                                 const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<::Ice::Context>(std::move(response), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opContext, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opContext(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::Ice::Context>>& outAsync, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "opContext";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

void
Test::MyClassPrx::opDoubleMarshaling(double iceP_p1, const DoubleS& iceP_p2, const ::Ice::Context& context) const
{
    ::IceInternal::makePromiseOutgoing<void>(true, this, &MyClassPrx::_iceI_opDoubleMarshaling, iceP_p1, iceP_p2, context).get();
}

::std::future<void>
Test::MyClassPrx::opDoubleMarshalingAsync(double iceP_p1, const DoubleS& iceP_p2, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<void>(false, this, &MyClassPrx::_iceI_opDoubleMarshaling, iceP_p1, iceP_p2, context);
}

::std::function<void()>
Test::MyClassPrx::opDoubleMarshalingAsync(double iceP_p1, const DoubleS& iceP_p2,
                                          ::std::function<void ()> response,
                                          ::std::function<void(::std::exception_ptr)> ex,
                                          ::std::function<void(bool)> sent,
                                          const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opDoubleMarshaling, iceP_p1, iceP_p2, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opDoubleMarshaling(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, double iceP_p1, const DoubleS& iceP_p2, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "opDoubleMarshaling";

    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p1, iceP_p2);
        },
        nullptr);
}
/// \endcond

void
Test::MyClassPrx::opIdempotent(const ::Ice::Context& context) const
{
    ::IceInternal::makePromiseOutgoing<void>(true, this, &MyClassPrx::_iceI_opIdempotent, context).get();
}

::std::future<void>
Test::MyClassPrx::opIdempotentAsync(const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<void>(false, this, &MyClassPrx::_iceI_opIdempotent, context);
}

::std::function<void()>
Test::MyClassPrx::opIdempotentAsync(::std::function<void ()> response,
                                    ::std::function<void(::std::exception_ptr)> ex,
                                    ::std::function<void(bool)> sent,
                                    const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opIdempotent, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opIdempotent(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "opIdempotent";

    outAsync->invoke(operationName, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

void
Test::MyClassPrx::opNonmutating(const ::Ice::Context& context) const
{
    ::IceInternal::makePromiseOutgoing<void>(true, this, &MyClassPrx::_iceI_opNonmutating, context).get();
}

::std::future<void>
Test::MyClassPrx::opNonmutatingAsync(const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<void>(false, this, &MyClassPrx::_iceI_opNonmutating, context);
}

::std::function<void()>
Test::MyClassPrx::opNonmutatingAsync(::std::function<void ()> response,
                                     ::std::function<void(::std::exception_ptr)> ex,
                                     ::std::function<void(bool)> sent,
                                     const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opNonmutating, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opNonmutating(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "opNonmutating";

    outAsync->invoke(operationName, ::Ice::OperationMode::Nonmutating, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

::std::uint8_t
Test::MyClassPrx::opByte1(::std::uint8_t iceP_opByte1, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::uint8_t>(true, this, &MyClassPrx::_iceI_opByte1, iceP_opByte1, context).get();
}

::std::future<::std::uint8_t>
Test::MyClassPrx::opByte1Async(::std::uint8_t iceP_opByte1, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::uint8_t>(false, this, &MyClassPrx::_iceI_opByte1, iceP_opByte1, context);
}

::std::function<void()>
Test::MyClassPrx::opByte1Async(::std::uint8_t iceP_opByte1,
                               ::std::function<void (::std::uint8_t)> response,
                               ::std::function<void(::std::exception_ptr)> ex,
                               ::std::function<void(bool)> sent,
                               const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<::std::uint8_t>(std::move(response), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opByte1, iceP_opByte1, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opByte1(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::uint8_t>>& outAsync, ::std::uint8_t iceP_opByte1, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "opByte1";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_opByte1);
        },
        nullptr);
}
/// \endcond

::std::int16_t
Test::MyClassPrx::opShort1(::std::int16_t iceP_opShort1, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::int16_t>(true, this, &MyClassPrx::_iceI_opShort1, iceP_opShort1, context).get();
}

::std::future<::std::int16_t>
Test::MyClassPrx::opShort1Async(::std::int16_t iceP_opShort1, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::int16_t>(false, this, &MyClassPrx::_iceI_opShort1, iceP_opShort1, context);
}

::std::function<void()>
Test::MyClassPrx::opShort1Async(::std::int16_t iceP_opShort1,
                                ::std::function<void (::std::int16_t)> response,
                                ::std::function<void(::std::exception_ptr)> ex,
                                ::std::function<void(bool)> sent,
                                const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<::std::int16_t>(std::move(response), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opShort1, iceP_opShort1, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opShort1(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::int16_t>>& outAsync, ::std::int16_t iceP_opShort1, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "opShort1";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_opShort1);
        },
        nullptr);
}
/// \endcond

::std::int32_t
Test::MyClassPrx::opInt1(::std::int32_t iceP_opInt1, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::int32_t>(true, this, &MyClassPrx::_iceI_opInt1, iceP_opInt1, context).get();
}

::std::future<::std::int32_t>
Test::MyClassPrx::opInt1Async(::std::int32_t iceP_opInt1, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::int32_t>(false, this, &MyClassPrx::_iceI_opInt1, iceP_opInt1, context);
}

::std::function<void()>
Test::MyClassPrx::opInt1Async(::std::int32_t iceP_opInt1,
                              ::std::function<void (::std::int32_t)> response,
                              ::std::function<void(::std::exception_ptr)> ex,
                              ::std::function<void(bool)> sent,
                              const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<::std::int32_t>(std::move(response), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opInt1, iceP_opInt1, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opInt1(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::int32_t>>& outAsync, ::std::int32_t iceP_opInt1, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "opInt1";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_opInt1);
        },
        nullptr);
}
/// \endcond

::std::int64_t
Test::MyClassPrx::opLong1(::std::int64_t iceP_opLong1, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::int64_t>(true, this, &MyClassPrx::_iceI_opLong1, iceP_opLong1, context).get();
}

::std::future<::std::int64_t>
Test::MyClassPrx::opLong1Async(::std::int64_t iceP_opLong1, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::int64_t>(false, this, &MyClassPrx::_iceI_opLong1, iceP_opLong1, context);
}

::std::function<void()>
Test::MyClassPrx::opLong1Async(::std::int64_t iceP_opLong1,
                               ::std::function<void (::std::int64_t)> response,
                               ::std::function<void(::std::exception_ptr)> ex,
                               ::std::function<void(bool)> sent,
                               const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<::std::int64_t>(std::move(response), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opLong1, iceP_opLong1, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opLong1(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::int64_t>>& outAsync, ::std::int64_t iceP_opLong1, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "opLong1";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_opLong1);
        },
        nullptr);
}
/// \endcond

float
Test::MyClassPrx::opFloat1(float iceP_opFloat1, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<float>(true, this, &MyClassPrx::_iceI_opFloat1, iceP_opFloat1, context).get();
}

::std::future<float>
Test::MyClassPrx::opFloat1Async(float iceP_opFloat1, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<float>(false, this, &MyClassPrx::_iceI_opFloat1, iceP_opFloat1, context);
}

::std::function<void()>
Test::MyClassPrx::opFloat1Async(float iceP_opFloat1,
                                ::std::function<void (float)> response,
                                ::std::function<void(::std::exception_ptr)> ex,
                                ::std::function<void(bool)> sent,
                                const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<float>(std::move(response), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opFloat1, iceP_opFloat1, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opFloat1(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<float>>& outAsync, float iceP_opFloat1, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "opFloat1";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_opFloat1);
        },
        nullptr);
}
/// \endcond

double
Test::MyClassPrx::opDouble1(double iceP_opDouble1, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<double>(true, this, &MyClassPrx::_iceI_opDouble1, iceP_opDouble1, context).get();
}

::std::future<double>
Test::MyClassPrx::opDouble1Async(double iceP_opDouble1, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<double>(false, this, &MyClassPrx::_iceI_opDouble1, iceP_opDouble1, context);
}

::std::function<void()>
Test::MyClassPrx::opDouble1Async(double iceP_opDouble1,
                                 ::std::function<void (double)> response,
                                 ::std::function<void(::std::exception_ptr)> ex,
                                 ::std::function<void(bool)> sent,
                                 const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<double>(std::move(response), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opDouble1, iceP_opDouble1, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opDouble1(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<double>>& outAsync, double iceP_opDouble1, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "opDouble1";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_opDouble1);
        },
        nullptr);
}
/// \endcond

::std::string
Test::MyClassPrx::opString1(::std::string_view iceP_opString1, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::string>(true, this, &MyClassPrx::_iceI_opString1, iceP_opString1, context).get();
}

::std::future<::std::string>
Test::MyClassPrx::opString1Async(::std::string_view iceP_opString1, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::string>(false, this, &MyClassPrx::_iceI_opString1, iceP_opString1, context);
}

::std::function<void()>
Test::MyClassPrx::opString1Async(::std::string_view iceP_opString1,
                                 ::std::function<void (::std::string)> response,
                                 ::std::function<void(::std::exception_ptr)> ex,
                                 ::std::function<void(bool)> sent,
                                 const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<::std::string>(std::move(response), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opString1, iceP_opString1, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opString1(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::string>>& outAsync, ::std::string_view iceP_opString1, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "opString1";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_opString1);
        },
        nullptr);
}
/// \endcond

::Test::StringS
Test::MyClassPrx::opStringS1(const StringS& iceP_opStringS1, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<StringS>(true, this, &MyClassPrx::_iceI_opStringS1, iceP_opStringS1, context).get();
}

::std::future<::Test::StringS>
Test::MyClassPrx::opStringS1Async(const StringS& iceP_opStringS1, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<StringS>(false, this, &MyClassPrx::_iceI_opStringS1, iceP_opStringS1, context);
}

::std::function<void()>
Test::MyClassPrx::opStringS1Async(const StringS& iceP_opStringS1,
                                  ::std::function<void (::Test::StringS)> response,
                                  ::std::function<void(::std::exception_ptr)> ex,
                                  ::std::function<void(bool)> sent,
                                  const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<StringS>(std::move(response), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opStringS1, iceP_opStringS1, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opStringS1(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<StringS>>& outAsync, const StringS& iceP_opStringS1, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "opStringS1";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_opStringS1);
        },
        nullptr);
}
/// \endcond

::Test::ByteBoolD
Test::MyClassPrx::opByteBoolD1(const ByteBoolD& iceP_opByteBoolD1, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<ByteBoolD>(true, this, &MyClassPrx::_iceI_opByteBoolD1, iceP_opByteBoolD1, context).get();
}

::std::future<::Test::ByteBoolD>
Test::MyClassPrx::opByteBoolD1Async(const ByteBoolD& iceP_opByteBoolD1, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<ByteBoolD>(false, this, &MyClassPrx::_iceI_opByteBoolD1, iceP_opByteBoolD1, context);
}

::std::function<void()>
Test::MyClassPrx::opByteBoolD1Async(const ByteBoolD& iceP_opByteBoolD1,
                                    ::std::function<void (::Test::ByteBoolD)> response,
                                    ::std::function<void(::std::exception_ptr)> ex,
                                    ::std::function<void(bool)> sent,
                                    const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<ByteBoolD>(std::move(response), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opByteBoolD1, iceP_opByteBoolD1, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opByteBoolD1(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ByteBoolD>>& outAsync, const ByteBoolD& iceP_opByteBoolD1, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "opByteBoolD1";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_opByteBoolD1);
        },
        nullptr);
}
/// \endcond

::Test::StringS
Test::MyClassPrx::opStringS2(const StringS& iceP_stringS, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<StringS>(true, this, &MyClassPrx::_iceI_opStringS2, iceP_stringS, context).get();
}

::std::future<::Test::StringS>
Test::MyClassPrx::opStringS2Async(const StringS& iceP_stringS, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<StringS>(false, this, &MyClassPrx::_iceI_opStringS2, iceP_stringS, context);
}

::std::function<void()>
Test::MyClassPrx::opStringS2Async(const StringS& iceP_stringS,
                                  ::std::function<void (::Test::StringS)> response,
                                  ::std::function<void(::std::exception_ptr)> ex,
                                  ::std::function<void(bool)> sent,
                                  const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<StringS>(std::move(response), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opStringS2, iceP_stringS, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opStringS2(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<StringS>>& outAsync, const StringS& iceP_stringS, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "opStringS2";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_stringS);
        },
        nullptr);
}
/// \endcond

::Test::ByteBoolD
Test::MyClassPrx::opByteBoolD2(const ByteBoolD& iceP_byteBoolD, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<ByteBoolD>(true, this, &MyClassPrx::_iceI_opByteBoolD2, iceP_byteBoolD, context).get();
}

::std::future<::Test::ByteBoolD>
Test::MyClassPrx::opByteBoolD2Async(const ByteBoolD& iceP_byteBoolD, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<ByteBoolD>(false, this, &MyClassPrx::_iceI_opByteBoolD2, iceP_byteBoolD, context);
}

::std::function<void()>
Test::MyClassPrx::opByteBoolD2Async(const ByteBoolD& iceP_byteBoolD,
                                    ::std::function<void (::Test::ByteBoolD)> response,
                                    ::std::function<void(::std::exception_ptr)> ex,
                                    ::std::function<void(bool)> sent,
                                    const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<ByteBoolD>(std::move(response), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opByteBoolD2, iceP_byteBoolD, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opByteBoolD2(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ByteBoolD>>& outAsync, const ByteBoolD& iceP_byteBoolD, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "opByteBoolD2";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_byteBoolD);
        },
        nullptr);
}
/// \endcond

::Test::StringS
Test::MyClassPrx::opStringLiterals(const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<StringS>(true, this, &MyClassPrx::_iceI_opStringLiterals, context).get();
}

::std::future<::Test::StringS>
Test::MyClassPrx::opStringLiteralsAsync(const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<StringS>(false, this, &MyClassPrx::_iceI_opStringLiterals, context);
}

::std::function<void()>
Test::MyClassPrx::opStringLiteralsAsync(::std::function<void (::Test::StringS)> response,
                                        ::std::function<void(::std::exception_ptr)> ex,
                                        ::std::function<void(bool)> sent,
                                        const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<StringS>(std::move(response), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opStringLiterals, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opStringLiterals(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<StringS>>& outAsync, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "opStringLiterals";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

::Test::WStringS
Test::MyClassPrx::opWStringLiterals(const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<WStringS>(true, this, &MyClassPrx::_iceI_opWStringLiterals, context).get();
}

::std::future<::Test::WStringS>
Test::MyClassPrx::opWStringLiteralsAsync(const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<WStringS>(false, this, &MyClassPrx::_iceI_opWStringLiterals, context);
}

::std::function<void()>
Test::MyClassPrx::opWStringLiteralsAsync(::std::function<void (::Test::WStringS)> response,
                                         ::std::function<void(::std::exception_ptr)> ex,
                                         ::std::function<void(bool)> sent,
                                         const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<WStringS>(std::move(response), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opWStringLiterals, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opWStringLiterals(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<WStringS>>& outAsync, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "opWStringLiterals";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

::Test::Structure
Test::MyClassPrx::opMStruct1(const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<Structure>(true, this, &MyClassPrx::_iceI_opMStruct1, context).get();
}

::std::future<::Test::Structure>
Test::MyClassPrx::opMStruct1Async(const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<Structure>(false, this, &MyClassPrx::_iceI_opMStruct1, context);
}

::std::function<void()>
Test::MyClassPrx::opMStruct1Async(::std::function<void (::Test::Structure)> response,
                                  ::std::function<void(::std::exception_ptr)> ex,
                                  ::std::function<void(bool)> sent,
                                  const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<Structure>(std::move(response), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opMStruct1, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opMStruct1(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Structure>>& outAsync, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "opMStruct1";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

::Test::Structure
Test::MyClassPrx::opMStruct2(const Structure& iceP_p1, Structure& iceP_p2, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<Structure, Structure>>(true, this, &MyClassPrx::_iceI_opMStruct2, iceP_p1, context).get();
    iceP_p2 = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::Structure, ::Test::Structure>>
Test::MyClassPrx::opMStruct2Async(const Structure& iceP_p1, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<Structure, Structure>>(false, this, &MyClassPrx::_iceI_opMStruct2, iceP_p1, context);
}

::std::function<void()>
Test::MyClassPrx::opMStruct2Async(const Structure& iceP_p1,
                                  ::std::function<void (::Test::Structure, ::Test::Structure)> response,
                                  ::std::function<void(::std::exception_ptr)> ex,
                                  ::std::function<void(bool)> sent,
                                  const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<Structure, Structure>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<Structure, Structure>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opMStruct2, iceP_p1, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opMStruct2(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<Structure, Structure>>>& outAsync, const Structure& iceP_p1, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "opMStruct2";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p1);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<Structure, Structure> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::StringS
Test::MyClassPrx::opMSeq1(const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<StringS>(true, this, &MyClassPrx::_iceI_opMSeq1, context).get();
}

::std::future<::Test::StringS>
Test::MyClassPrx::opMSeq1Async(const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<StringS>(false, this, &MyClassPrx::_iceI_opMSeq1, context);
}

::std::function<void()>
Test::MyClassPrx::opMSeq1Async(::std::function<void (::Test::StringS)> response,
                               ::std::function<void(::std::exception_ptr)> ex,
                               ::std::function<void(bool)> sent,
                               const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<StringS>(std::move(response), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opMSeq1, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opMSeq1(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<StringS>>& outAsync, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "opMSeq1";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

::Test::StringS
Test::MyClassPrx::opMSeq2(const StringS& iceP_p1, StringS& iceP_p2, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<StringS, StringS>>(true, this, &MyClassPrx::_iceI_opMSeq2, iceP_p1, context).get();
    iceP_p2 = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::StringS, ::Test::StringS>>
Test::MyClassPrx::opMSeq2Async(const StringS& iceP_p1, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<StringS, StringS>>(false, this, &MyClassPrx::_iceI_opMSeq2, iceP_p1, context);
}

::std::function<void()>
Test::MyClassPrx::opMSeq2Async(const StringS& iceP_p1,
                               ::std::function<void (::Test::StringS, ::Test::StringS)> response,
                               ::std::function<void(::std::exception_ptr)> ex,
                               ::std::function<void(bool)> sent,
                               const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<StringS, StringS>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<StringS, StringS>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opMSeq2, iceP_p1, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opMSeq2(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<StringS, StringS>>>& outAsync, const StringS& iceP_p1, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "opMSeq2";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p1);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<StringS, StringS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::StringStringD
Test::MyClassPrx::opMDict1(const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<StringStringD>(true, this, &MyClassPrx::_iceI_opMDict1, context).get();
}

::std::future<::Test::StringStringD>
Test::MyClassPrx::opMDict1Async(const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<StringStringD>(false, this, &MyClassPrx::_iceI_opMDict1, context);
}

::std::function<void()>
Test::MyClassPrx::opMDict1Async(::std::function<void (::Test::StringStringD)> response,
                                ::std::function<void(::std::exception_ptr)> ex,
                                ::std::function<void(bool)> sent,
                                const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<StringStringD>(std::move(response), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opMDict1, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opMDict1(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<StringStringD>>& outAsync, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "opMDict1";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

::Test::StringStringD
Test::MyClassPrx::opMDict2(const StringStringD& iceP_p1, StringStringD& iceP_p2, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<StringStringD, StringStringD>>(true, this, &MyClassPrx::_iceI_opMDict2, iceP_p1, context).get();
    iceP_p2 = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::StringStringD, ::Test::StringStringD>>
Test::MyClassPrx::opMDict2Async(const StringStringD& iceP_p1, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<StringStringD, StringStringD>>(false, this, &MyClassPrx::_iceI_opMDict2, iceP_p1, context);
}

::std::function<void()>
Test::MyClassPrx::opMDict2Async(const StringStringD& iceP_p1,
                                ::std::function<void (::Test::StringStringD, ::Test::StringStringD)> response,
                                ::std::function<void(::std::exception_ptr)> ex,
                                ::std::function<void(bool)> sent,
                                const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<StringStringD, StringStringD>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<StringStringD, StringStringD>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opMDict2, iceP_p1, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opMDict2(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<StringStringD, StringStringD>>>& outAsync, const StringStringD& iceP_p1, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "opMDict2";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p1);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<StringStringD, StringStringD> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::std::string_view
Test::MyClassPrx::ice_staticId()
{
    static constexpr ::std::string_view typeId = "::Test::MyClass";
    return typeId;
}

void
Test::MyDerivedClassPrx::opDerived(const ::Ice::Context& context) const
{
    ::IceInternal::makePromiseOutgoing<void>(true, this, &MyDerivedClassPrx::_iceI_opDerived, context).get();
}

::std::future<void>
Test::MyDerivedClassPrx::opDerivedAsync(const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<void>(false, this, &MyDerivedClassPrx::_iceI_opDerived, context);
}

::std::function<void()>
Test::MyDerivedClassPrx::opDerivedAsync(::std::function<void ()> response,
                                        ::std::function<void(::std::exception_ptr)> ex,
                                        ::std::function<void(bool)> sent,
                                        const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::MyDerivedClassPrx::_iceI_opDerived, context);
}

/// \cond INTERNAL
void
Test::MyDerivedClassPrx::_iceI_opDerived(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "opDerived";

    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

::std::shared_ptr<::Test::MyClass1>
Test::MyDerivedClassPrx::opMyClass1(const ::std::shared_ptr<MyClass1>& iceP_opMyClass1, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::shared_ptr<MyClass1>>(true, this, &MyDerivedClassPrx::_iceI_opMyClass1, iceP_opMyClass1, context).get();
}

::std::future<::std::shared_ptr<::Test::MyClass1>>
Test::MyDerivedClassPrx::opMyClass1Async(const ::std::shared_ptr<MyClass1>& iceP_opMyClass1, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::shared_ptr<MyClass1>>(false, this, &MyDerivedClassPrx::_iceI_opMyClass1, iceP_opMyClass1, context);
}

::std::function<void()>
Test::MyDerivedClassPrx::opMyClass1Async(const ::std::shared_ptr<MyClass1>& iceP_opMyClass1,
                                         ::std::function<void (::std::shared_ptr<::Test::MyClass1>)> response,
                                         ::std::function<void(::std::exception_ptr)> ex,
                                         ::std::function<void(bool)> sent,
                                         const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<::std::shared_ptr<MyClass1>>(std::move(response), std::move(ex), std::move(sent), this, &Test::MyDerivedClassPrx::_iceI_opMyClass1, iceP_opMyClass1, context);
}

/// \cond INTERNAL
void
Test::MyDerivedClassPrx::_iceI_opMyClass1(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<MyClass1>>>& outAsync, const ::std::shared_ptr<MyClass1>& iceP_opMyClass1, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "opMyClass1";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_opMyClass1);
            ostr->writePendingValues();
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::shared_ptr<MyClass1> ret;
            istr->readAll(ret);
            istr->readPendingValues();
            return ret;
        });
}
/// \endcond

::Test::MyStruct1
Test::MyDerivedClassPrx::opMyStruct1(const MyStruct1& iceP_opMyStruct1, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<MyStruct1>(true, this, &MyDerivedClassPrx::_iceI_opMyStruct1, iceP_opMyStruct1, context).get();
}

::std::future<::Test::MyStruct1>
Test::MyDerivedClassPrx::opMyStruct1Async(const MyStruct1& iceP_opMyStruct1, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<MyStruct1>(false, this, &MyDerivedClassPrx::_iceI_opMyStruct1, iceP_opMyStruct1, context);
}

::std::function<void()>
Test::MyDerivedClassPrx::opMyStruct1Async(const MyStruct1& iceP_opMyStruct1,
                                          ::std::function<void (::Test::MyStruct1)> response,
                                          ::std::function<void(::std::exception_ptr)> ex,
                                          ::std::function<void(bool)> sent,
                                          const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<MyStruct1>(std::move(response), std::move(ex), std::move(sent), this, &Test::MyDerivedClassPrx::_iceI_opMyStruct1, iceP_opMyStruct1, context);
}

/// \cond INTERNAL
void
Test::MyDerivedClassPrx::_iceI_opMyStruct1(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyStruct1>>& outAsync, const MyStruct1& iceP_opMyStruct1, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "opMyStruct1";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_opMyStruct1);
        },
        nullptr);
}
/// \endcond

::std::string_view
Test::MyDerivedClassPrx::ice_staticId()
{
    static constexpr ::std::string_view typeId = "::Test::MyDerivedClass";
    return typeId;
}

::std::string_view
Test2::MyDerivedClassPrx::ice_staticId()
{
    static constexpr ::std::string_view typeId = "::Test2::MyDerivedClass";
    return typeId;
}

Test::SomeException::~SomeException()
{
}

::std::string_view
Test::SomeException::ice_staticId()
{
    static constexpr ::std::string_view typeId = "::Test::SomeException";
    return typeId;
}

Test::MyClass1::~MyClass1()
{
}

::std::string_view
Test::MyClass1::ice_staticId()
{
    static constexpr ::std::string_view typeId = "::Test::MyClass1";
    return typeId;
}

::std::vector<::std::string>
Test::MyClass::ice_ids(const ::Ice::Current&) const
{
    static const ::std::vector<::std::string> allTypeIds = { "::Ice::Object", "::Test::MyClass" };
    return allTypeIds;
}

::std::string
Test::MyClass::ice_id(const ::Ice::Current&) const
{
    return ::std::string{ice_staticId()};
}

::std::string_view
Test::MyClass::ice_staticId()
{
    static constexpr ::std::string_view typeId = "::Test::MyClass";
    return typeId;
}

/// \cond INTERNAL
bool
Test::MyClass::_iceD_shutdown(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    this->shutdown(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_supportsCompress(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    bool ret = this->supportsCompress(current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opVoid(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    this->opVoid(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opByte(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::uint8_t iceP_p1;
    ::std::uint8_t iceP_p2;
    istr->readAll(iceP_p1, iceP_p2);
    inS.endReadParams();
    ::std::uint8_t iceP_p3;
    ::std::uint8_t ret = this->opByte(iceP_p1, iceP_p2, iceP_p3, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_p3, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opBool(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    bool iceP_p1;
    bool iceP_p2;
    istr->readAll(iceP_p1, iceP_p2);
    inS.endReadParams();
    bool iceP_p3;
    bool ret = this->opBool(iceP_p1, iceP_p2, iceP_p3, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_p3, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opShortIntLong(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::int16_t iceP_p1;
    ::std::int32_t iceP_p2;
    ::std::int64_t iceP_p3;
    istr->readAll(iceP_p1, iceP_p2, iceP_p3);
    inS.endReadParams();
    ::std::int16_t iceP_p4;
    ::std::int32_t iceP_p5;
    ::std::int64_t iceP_p6;
    ::std::int64_t ret = this->opShortIntLong(iceP_p1, iceP_p2, iceP_p3, iceP_p4, iceP_p5, iceP_p6, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_p4, iceP_p5, iceP_p6, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opFloatDouble(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    float iceP_p1;
    double iceP_p2;
    istr->readAll(iceP_p1, iceP_p2);
    inS.endReadParams();
    float iceP_p3;
    double iceP_p4;
    double ret = this->opFloatDouble(iceP_p1, iceP_p2, iceP_p3, iceP_p4, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_p3, iceP_p4, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opString(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_p1;
    ::std::string iceP_p2;
    istr->readAll(iceP_p1, iceP_p2);
    inS.endReadParams();
    ::std::string iceP_p3;
    ::std::string ret = this->opString(::std::move(iceP_p1), ::std::move(iceP_p2), iceP_p3, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_p3, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opMyEnum(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    MyEnum iceP_p1;
    istr->readAll(iceP_p1);
    inS.endReadParams();
    MyEnum iceP_p2;
    MyEnum ret = this->opMyEnum(iceP_p1, iceP_p2, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_p2, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opMyClass(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::optional<MyClassPrx> iceP_p1;
    istr->readAll(iceP_p1);
    inS.endReadParams();
    ::std::optional<MyClassPrx> iceP_p2;
    ::std::optional<MyClassPrx> iceP_p3;
    ::std::optional<MyClassPrx> ret = this->opMyClass(::std::move(iceP_p1), iceP_p2, iceP_p3, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_p2, iceP_p3, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opStruct(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    Structure iceP_p1;
    Structure iceP_p2;
    istr->readAll(iceP_p1, iceP_p2);
    inS.endReadParams();
    Structure iceP_p3;
    Structure ret = this->opStruct(::std::move(iceP_p1), ::std::move(iceP_p2), iceP_p3, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_p3, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opByteS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ByteS iceP_p1;
    ByteS iceP_p2;
    istr->readAll(iceP_p1, iceP_p2);
    inS.endReadParams();
    ByteS iceP_p3;
    ByteS ret = this->opByteS(::std::move(iceP_p1), ::std::move(iceP_p2), iceP_p3, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_p3, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opBoolS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    BoolS iceP_p1;
    BoolS iceP_p2;
    istr->readAll(iceP_p1, iceP_p2);
    inS.endReadParams();
    BoolS iceP_p3;
    BoolS ret = this->opBoolS(::std::move(iceP_p1), ::std::move(iceP_p2), iceP_p3, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_p3, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opShortIntLongS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ShortS iceP_p1;
    IntS iceP_p2;
    LongS iceP_p3;
    istr->readAll(iceP_p1, iceP_p2, iceP_p3);
    inS.endReadParams();
    ShortS iceP_p4;
    IntS iceP_p5;
    LongS iceP_p6;
    LongS ret = this->opShortIntLongS(::std::move(iceP_p1), ::std::move(iceP_p2), ::std::move(iceP_p3), iceP_p4, iceP_p5, iceP_p6, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_p4, iceP_p5, iceP_p6, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opFloatDoubleS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    FloatS iceP_p1;
    DoubleS iceP_p2;
    istr->readAll(iceP_p1, iceP_p2);
    inS.endReadParams();
    FloatS iceP_p3;
    DoubleS iceP_p4;
    DoubleS ret = this->opFloatDoubleS(::std::move(iceP_p1), ::std::move(iceP_p2), iceP_p3, iceP_p4, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_p3, iceP_p4, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opStringS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    StringS iceP_p1;
    StringS iceP_p2;
    istr->readAll(iceP_p1, iceP_p2);
    inS.endReadParams();
    StringS iceP_p3;
    StringS ret = this->opStringS(::std::move(iceP_p1), ::std::move(iceP_p2), iceP_p3, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_p3, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opByteSS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ByteSS iceP_p1;
    ByteSS iceP_p2;
    istr->readAll(iceP_p1, iceP_p2);
    inS.endReadParams();
    ByteSS iceP_p3;
    ByteSS ret = this->opByteSS(::std::move(iceP_p1), ::std::move(iceP_p2), iceP_p3, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_p3, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opBoolSS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    BoolSS iceP_p1;
    BoolSS iceP_p2;
    istr->readAll(iceP_p1, iceP_p2);
    inS.endReadParams();
    BoolSS iceP_p3;
    BoolSS ret = this->opBoolSS(::std::move(iceP_p1), ::std::move(iceP_p2), iceP_p3, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_p3, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opShortIntLongSS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ShortSS iceP_p1;
    IntSS iceP_p2;
    LongSS iceP_p3;
    istr->readAll(iceP_p1, iceP_p2, iceP_p3);
    inS.endReadParams();
    ShortSS iceP_p4;
    IntSS iceP_p5;
    LongSS iceP_p6;
    LongSS ret = this->opShortIntLongSS(::std::move(iceP_p1), ::std::move(iceP_p2), ::std::move(iceP_p3), iceP_p4, iceP_p5, iceP_p6, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_p4, iceP_p5, iceP_p6, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opFloatDoubleSS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    FloatSS iceP_p1;
    DoubleSS iceP_p2;
    istr->readAll(iceP_p1, iceP_p2);
    inS.endReadParams();
    FloatSS iceP_p3;
    DoubleSS iceP_p4;
    DoubleSS ret = this->opFloatDoubleSS(::std::move(iceP_p1), ::std::move(iceP_p2), iceP_p3, iceP_p4, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_p3, iceP_p4, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opStringSS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    StringSS iceP_p1;
    StringSS iceP_p2;
    istr->readAll(iceP_p1, iceP_p2);
    inS.endReadParams();
    StringSS iceP_p3;
    StringSS ret = this->opStringSS(::std::move(iceP_p1), ::std::move(iceP_p2), iceP_p3, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_p3, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opStringSSS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    StringSSS iceP_p1;
    StringSSS iceP_p2;
    istr->readAll(iceP_p1, iceP_p2);
    inS.endReadParams();
    StringSSS iceP_p3;
    StringSSS ret = this->opStringSSS(::std::move(iceP_p1), ::std::move(iceP_p2), iceP_p3, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_p3, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opByteBoolD(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ByteBoolD iceP_p1;
    ByteBoolD iceP_p2;
    istr->readAll(iceP_p1, iceP_p2);
    inS.endReadParams();
    ByteBoolD iceP_p3;
    ByteBoolD ret = this->opByteBoolD(::std::move(iceP_p1), ::std::move(iceP_p2), iceP_p3, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_p3, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opShortIntD(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ShortIntD iceP_p1;
    ShortIntD iceP_p2;
    istr->readAll(iceP_p1, iceP_p2);
    inS.endReadParams();
    ShortIntD iceP_p3;
    ShortIntD ret = this->opShortIntD(::std::move(iceP_p1), ::std::move(iceP_p2), iceP_p3, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_p3, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opLongFloatD(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    LongFloatD iceP_p1;
    LongFloatD iceP_p2;
    istr->readAll(iceP_p1, iceP_p2);
    inS.endReadParams();
    LongFloatD iceP_p3;
    LongFloatD ret = this->opLongFloatD(::std::move(iceP_p1), ::std::move(iceP_p2), iceP_p3, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_p3, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opStringStringD(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    StringStringD iceP_p1;
    StringStringD iceP_p2;
    istr->readAll(iceP_p1, iceP_p2);
    inS.endReadParams();
    StringStringD iceP_p3;
    StringStringD ret = this->opStringStringD(::std::move(iceP_p1), ::std::move(iceP_p2), iceP_p3, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_p3, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opStringMyEnumD(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    StringMyEnumD iceP_p1;
    StringMyEnumD iceP_p2;
    istr->readAll(iceP_p1, iceP_p2);
    inS.endReadParams();
    StringMyEnumD iceP_p3;
    StringMyEnumD ret = this->opStringMyEnumD(::std::move(iceP_p1), ::std::move(iceP_p2), iceP_p3, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_p3, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opMyEnumStringD(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    MyEnumStringD iceP_p1;
    MyEnumStringD iceP_p2;
    istr->readAll(iceP_p1, iceP_p2);
    inS.endReadParams();
    MyEnumStringD iceP_p3;
    MyEnumStringD ret = this->opMyEnumStringD(::std::move(iceP_p1), ::std::move(iceP_p2), iceP_p3, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_p3, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opMyStructMyEnumD(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    MyStructMyEnumD iceP_p1;
    MyStructMyEnumD iceP_p2;
    istr->readAll(iceP_p1, iceP_p2);
    inS.endReadParams();
    MyStructMyEnumD iceP_p3;
    MyStructMyEnumD ret = this->opMyStructMyEnumD(::std::move(iceP_p1), ::std::move(iceP_p2), iceP_p3, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_p3, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opByteBoolDS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ByteBoolDS iceP_p1;
    ByteBoolDS iceP_p2;
    istr->readAll(iceP_p1, iceP_p2);
    inS.endReadParams();
    ByteBoolDS iceP_p3;
    ByteBoolDS ret = this->opByteBoolDS(::std::move(iceP_p1), ::std::move(iceP_p2), iceP_p3, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_p3, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opShortIntDS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ShortIntDS iceP_p1;
    ShortIntDS iceP_p2;
    istr->readAll(iceP_p1, iceP_p2);
    inS.endReadParams();
    ShortIntDS iceP_p3;
    ShortIntDS ret = this->opShortIntDS(::std::move(iceP_p1), ::std::move(iceP_p2), iceP_p3, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_p3, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opLongFloatDS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    LongFloatDS iceP_p1;
    LongFloatDS iceP_p2;
    istr->readAll(iceP_p1, iceP_p2);
    inS.endReadParams();
    LongFloatDS iceP_p3;
    LongFloatDS ret = this->opLongFloatDS(::std::move(iceP_p1), ::std::move(iceP_p2), iceP_p3, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_p3, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opStringStringDS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    StringStringDS iceP_p1;
    StringStringDS iceP_p2;
    istr->readAll(iceP_p1, iceP_p2);
    inS.endReadParams();
    StringStringDS iceP_p3;
    StringStringDS ret = this->opStringStringDS(::std::move(iceP_p1), ::std::move(iceP_p2), iceP_p3, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_p3, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opStringMyEnumDS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    StringMyEnumDS iceP_p1;
    StringMyEnumDS iceP_p2;
    istr->readAll(iceP_p1, iceP_p2);
    inS.endReadParams();
    StringMyEnumDS iceP_p3;
    StringMyEnumDS ret = this->opStringMyEnumDS(::std::move(iceP_p1), ::std::move(iceP_p2), iceP_p3, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_p3, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opMyEnumStringDS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    MyEnumStringDS iceP_p1;
    MyEnumStringDS iceP_p2;
    istr->readAll(iceP_p1, iceP_p2);
    inS.endReadParams();
    MyEnumStringDS iceP_p3;
    MyEnumStringDS ret = this->opMyEnumStringDS(::std::move(iceP_p1), ::std::move(iceP_p2), iceP_p3, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_p3, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opMyStructMyEnumDS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    MyStructMyEnumDS iceP_p1;
    MyStructMyEnumDS iceP_p2;
    istr->readAll(iceP_p1, iceP_p2);
    inS.endReadParams();
    MyStructMyEnumDS iceP_p3;
    MyStructMyEnumDS ret = this->opMyStructMyEnumDS(::std::move(iceP_p1), ::std::move(iceP_p2), iceP_p3, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_p3, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opByteByteSD(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ByteByteSD iceP_p1;
    ByteByteSD iceP_p2;
    istr->readAll(iceP_p1, iceP_p2);
    inS.endReadParams();
    ByteByteSD iceP_p3;
    ByteByteSD ret = this->opByteByteSD(::std::move(iceP_p1), ::std::move(iceP_p2), iceP_p3, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_p3, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opBoolBoolSD(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    BoolBoolSD iceP_p1;
    BoolBoolSD iceP_p2;
    istr->readAll(iceP_p1, iceP_p2);
    inS.endReadParams();
    BoolBoolSD iceP_p3;
    BoolBoolSD ret = this->opBoolBoolSD(::std::move(iceP_p1), ::std::move(iceP_p2), iceP_p3, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_p3, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opShortShortSD(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ShortShortSD iceP_p1;
    ShortShortSD iceP_p2;
    istr->readAll(iceP_p1, iceP_p2);
    inS.endReadParams();
    ShortShortSD iceP_p3;
    ShortShortSD ret = this->opShortShortSD(::std::move(iceP_p1), ::std::move(iceP_p2), iceP_p3, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_p3, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opIntIntSD(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    IntIntSD iceP_p1;
    IntIntSD iceP_p2;
    istr->readAll(iceP_p1, iceP_p2);
    inS.endReadParams();
    IntIntSD iceP_p3;
    IntIntSD ret = this->opIntIntSD(::std::move(iceP_p1), ::std::move(iceP_p2), iceP_p3, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_p3, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opLongLongSD(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    LongLongSD iceP_p1;
    LongLongSD iceP_p2;
    istr->readAll(iceP_p1, iceP_p2);
    inS.endReadParams();
    LongLongSD iceP_p3;
    LongLongSD ret = this->opLongLongSD(::std::move(iceP_p1), ::std::move(iceP_p2), iceP_p3, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_p3, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opStringFloatSD(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    StringFloatSD iceP_p1;
    StringFloatSD iceP_p2;
    istr->readAll(iceP_p1, iceP_p2);
    inS.endReadParams();
    StringFloatSD iceP_p3;
    StringFloatSD ret = this->opStringFloatSD(::std::move(iceP_p1), ::std::move(iceP_p2), iceP_p3, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_p3, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opStringDoubleSD(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    StringDoubleSD iceP_p1;
    StringDoubleSD iceP_p2;
    istr->readAll(iceP_p1, iceP_p2);
    inS.endReadParams();
    StringDoubleSD iceP_p3;
    StringDoubleSD ret = this->opStringDoubleSD(::std::move(iceP_p1), ::std::move(iceP_p2), iceP_p3, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_p3, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opStringStringSD(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    StringStringSD iceP_p1;
    StringStringSD iceP_p2;
    istr->readAll(iceP_p1, iceP_p2);
    inS.endReadParams();
    StringStringSD iceP_p3;
    StringStringSD ret = this->opStringStringSD(::std::move(iceP_p1), ::std::move(iceP_p2), iceP_p3, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_p3, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opMyEnumMyEnumSD(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    MyEnumMyEnumSD iceP_p1;
    MyEnumMyEnumSD iceP_p2;
    istr->readAll(iceP_p1, iceP_p2);
    inS.endReadParams();
    MyEnumMyEnumSD iceP_p3;
    MyEnumMyEnumSD ret = this->opMyEnumMyEnumSD(::std::move(iceP_p1), ::std::move(iceP_p2), iceP_p3, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_p3, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opIntS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    IntS iceP_s;
    istr->readAll(iceP_s);
    inS.endReadParams();
    IntS ret = this->opIntS(::std::move(iceP_s), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opByteSOneway(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ByteS iceP_s;
    istr->readAll(iceP_s);
    inS.endReadParams();
    this->opByteSOneway(::std::move(iceP_s), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opByteSOnewayCallCount(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    ::std::int32_t ret = this->opByteSOnewayCallCount(current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opContext(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    ::Ice::Context ret = this->opContext(current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opDoubleMarshaling(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    double iceP_p1;
    DoubleS iceP_p2;
    istr->readAll(iceP_p1, iceP_p2);
    inS.endReadParams();
    this->opDoubleMarshaling(iceP_p1, ::std::move(iceP_p2), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opIdempotent(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    inS.readEmptyParams();
    this->opIdempotent(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opNonmutating(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    inS.readEmptyParams();
    this->opNonmutating(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opByte1(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::uint8_t iceP_opByte1;
    istr->readAll(iceP_opByte1);
    inS.endReadParams();
    ::std::uint8_t ret = this->opByte1(iceP_opByte1, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opShort1(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::int16_t iceP_opShort1;
    istr->readAll(iceP_opShort1);
    inS.endReadParams();
    ::std::int16_t ret = this->opShort1(iceP_opShort1, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opInt1(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::int32_t iceP_opInt1;
    istr->readAll(iceP_opInt1);
    inS.endReadParams();
    ::std::int32_t ret = this->opInt1(iceP_opInt1, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opLong1(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::int64_t iceP_opLong1;
    istr->readAll(iceP_opLong1);
    inS.endReadParams();
    ::std::int64_t ret = this->opLong1(iceP_opLong1, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opFloat1(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    float iceP_opFloat1;
    istr->readAll(iceP_opFloat1);
    inS.endReadParams();
    float ret = this->opFloat1(iceP_opFloat1, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opDouble1(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    double iceP_opDouble1;
    istr->readAll(iceP_opDouble1);
    inS.endReadParams();
    double ret = this->opDouble1(iceP_opDouble1, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opString1(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_opString1;
    istr->readAll(iceP_opString1);
    inS.endReadParams();
    ::std::string ret = this->opString1(::std::move(iceP_opString1), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opStringS1(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    StringS iceP_opStringS1;
    istr->readAll(iceP_opStringS1);
    inS.endReadParams();
    StringS ret = this->opStringS1(::std::move(iceP_opStringS1), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opByteBoolD1(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ByteBoolD iceP_opByteBoolD1;
    istr->readAll(iceP_opByteBoolD1);
    inS.endReadParams();
    ByteBoolD ret = this->opByteBoolD1(::std::move(iceP_opByteBoolD1), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opStringS2(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    StringS iceP_stringS;
    istr->readAll(iceP_stringS);
    inS.endReadParams();
    StringS ret = this->opStringS2(::std::move(iceP_stringS), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opByteBoolD2(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ByteBoolD iceP_byteBoolD;
    istr->readAll(iceP_byteBoolD);
    inS.endReadParams();
    ByteBoolD ret = this->opByteBoolD2(::std::move(iceP_byteBoolD), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opStringLiterals(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    StringS ret = this->opStringLiterals(current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opWStringLiterals(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    WStringS ret = this->opWStringLiterals(current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

Test::MyClass::OpMStruct1MarshaledResult::OpMStruct1MarshaledResult(const Structure& ret, const ::Ice::Current& current):
    MarshaledResult(current)
{
    ostr->startEncapsulation(current.encoding, ::Ice::FormatType::DefaultFormat);
    ostr->writeAll(ret);
    ostr->endEncapsulation();
}

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opMStruct1(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    inS.setMarshaledResult(this->opMStruct1(current));
    return true;
}
/// \endcond

Test::MyClass::OpMStruct2MarshaledResult::OpMStruct2MarshaledResult(const Structure& ret, const Structure& iceP_p2, const ::Ice::Current& current):
    MarshaledResult(current)
{
    ostr->startEncapsulation(current.encoding, ::Ice::FormatType::DefaultFormat);
    ostr->writeAll(iceP_p2, ret);
    ostr->endEncapsulation();
}

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opMStruct2(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    Structure iceP_p1;
    istr->readAll(iceP_p1);
    inS.endReadParams();
    inS.setMarshaledResult(this->opMStruct2(::std::move(iceP_p1), current));
    return true;
}
/// \endcond

Test::MyClass::OpMSeq1MarshaledResult::OpMSeq1MarshaledResult(const StringS& ret, const ::Ice::Current& current):
    MarshaledResult(current)
{
    ostr->startEncapsulation(current.encoding, ::Ice::FormatType::DefaultFormat);
    ostr->writeAll(ret);
    ostr->endEncapsulation();
}

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opMSeq1(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    inS.setMarshaledResult(this->opMSeq1(current));
    return true;
}
/// \endcond

Test::MyClass::OpMSeq2MarshaledResult::OpMSeq2MarshaledResult(const StringS& ret, const StringS& iceP_p2, const ::Ice::Current& current):
    MarshaledResult(current)
{
    ostr->startEncapsulation(current.encoding, ::Ice::FormatType::DefaultFormat);
    ostr->writeAll(iceP_p2, ret);
    ostr->endEncapsulation();
}

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opMSeq2(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    StringS iceP_p1;
    istr->readAll(iceP_p1);
    inS.endReadParams();
    inS.setMarshaledResult(this->opMSeq2(::std::move(iceP_p1), current));
    return true;
}
/// \endcond

Test::MyClass::OpMDict1MarshaledResult::OpMDict1MarshaledResult(const StringStringD& ret, const ::Ice::Current& current):
    MarshaledResult(current)
{
    ostr->startEncapsulation(current.encoding, ::Ice::FormatType::DefaultFormat);
    ostr->writeAll(ret);
    ostr->endEncapsulation();
}

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opMDict1(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    inS.setMarshaledResult(this->opMDict1(current));
    return true;
}
/// \endcond

Test::MyClass::OpMDict2MarshaledResult::OpMDict2MarshaledResult(const StringStringD& ret, const StringStringD& iceP_p2, const ::Ice::Current& current):
    MarshaledResult(current)
{
    ostr->startEncapsulation(current.encoding, ::Ice::FormatType::DefaultFormat);
    ostr->writeAll(iceP_p2, ret);
    ostr->endEncapsulation();
}

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opMDict2(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    StringStringD iceP_p1;
    istr->readAll(iceP_p1);
    inS.endReadParams();
    inS.setMarshaledResult(this->opMDict2(::std::move(iceP_p1), current));
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    static constexpr ::std::string_view allOperations[] = { "ice_id", "ice_ids", "ice_isA", "ice_ping", "opBool", "opBoolBoolSD", "opBoolS", "opBoolSS", "opByte", "opByte1", "opByteBoolD", "opByteBoolD1", "opByteBoolD2", "opByteBoolDS", "opByteByteSD", "opByteS", "opByteSOneway", "opByteSOnewayCallCount", "opByteSS", "opContext", "opDouble1", "opDoubleMarshaling", "opFloat1", "opFloatDouble", "opFloatDoubleS", "opFloatDoubleSS", "opIdempotent", "opInt1", "opIntIntSD", "opIntS", "opLong1", "opLongFloatD", "opLongFloatDS", "opLongLongSD", "opMDict1", "opMDict2", "opMSeq1", "opMSeq2", "opMStruct1", "opMStruct2", "opMyClass", "opMyEnum", "opMyEnumMyEnumSD", "opMyEnumStringD", "opMyEnumStringDS", "opMyStructMyEnumD", "opMyStructMyEnumDS", "opNonmutating", "opShort1", "opShortIntD", "opShortIntDS", "opShortIntLong", "opShortIntLongS", "opShortIntLongSS", "opShortShortSD", "opString", "opString1", "opStringDoubleSD", "opStringFloatSD", "opStringLiterals", "opStringMyEnumD", "opStringMyEnumDS", "opStringS", "opStringS1", "opStringS2", "opStringSS", "opStringSSS", "opStringStringD", "opStringStringDS", "opStringStringSD", "opStruct", "opVoid", "opWStringLiterals", "shutdown", "supportsCompress" };

    ::std::pair<const ::std::string_view*, const ::std::string_view*> r = ::std::equal_range(allOperations, allOperations + 75, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - allOperations)
    {
        case 0:
        {
            return _iceD_ice_id(in, current);
        }
        case 1:
        {
            return _iceD_ice_ids(in, current);
        }
        case 2:
        {
            return _iceD_ice_isA(in, current);
        }
        case 3:
        {
            return _iceD_ice_ping(in, current);
        }
        case 4:
        {
            return _iceD_opBool(in, current);
        }
        case 5:
        {
            return _iceD_opBoolBoolSD(in, current);
        }
        case 6:
        {
            return _iceD_opBoolS(in, current);
        }
        case 7:
        {
            return _iceD_opBoolSS(in, current);
        }
        case 8:
        {
            return _iceD_opByte(in, current);
        }
        case 9:
        {
            return _iceD_opByte1(in, current);
        }
        case 10:
        {
            return _iceD_opByteBoolD(in, current);
        }
        case 11:
        {
            return _iceD_opByteBoolD1(in, current);
        }
        case 12:
        {
            return _iceD_opByteBoolD2(in, current);
        }
        case 13:
        {
            return _iceD_opByteBoolDS(in, current);
        }
        case 14:
        {
            return _iceD_opByteByteSD(in, current);
        }
        case 15:
        {
            return _iceD_opByteS(in, current);
        }
        case 16:
        {
            return _iceD_opByteSOneway(in, current);
        }
        case 17:
        {
            return _iceD_opByteSOnewayCallCount(in, current);
        }
        case 18:
        {
            return _iceD_opByteSS(in, current);
        }
        case 19:
        {
            return _iceD_opContext(in, current);
        }
        case 20:
        {
            return _iceD_opDouble1(in, current);
        }
        case 21:
        {
            return _iceD_opDoubleMarshaling(in, current);
        }
        case 22:
        {
            return _iceD_opFloat1(in, current);
        }
        case 23:
        {
            return _iceD_opFloatDouble(in, current);
        }
        case 24:
        {
            return _iceD_opFloatDoubleS(in, current);
        }
        case 25:
        {
            return _iceD_opFloatDoubleSS(in, current);
        }
        case 26:
        {
            return _iceD_opIdempotent(in, current);
        }
        case 27:
        {
            return _iceD_opInt1(in, current);
        }
        case 28:
        {
            return _iceD_opIntIntSD(in, current);
        }
        case 29:
        {
            return _iceD_opIntS(in, current);
        }
        case 30:
        {
            return _iceD_opLong1(in, current);
        }
        case 31:
        {
            return _iceD_opLongFloatD(in, current);
        }
        case 32:
        {
            return _iceD_opLongFloatDS(in, current);
        }
        case 33:
        {
            return _iceD_opLongLongSD(in, current);
        }
        case 34:
        {
            return _iceD_opMDict1(in, current);
        }
        case 35:
        {
            return _iceD_opMDict2(in, current);
        }
        case 36:
        {
            return _iceD_opMSeq1(in, current);
        }
        case 37:
        {
            return _iceD_opMSeq2(in, current);
        }
        case 38:
        {
            return _iceD_opMStruct1(in, current);
        }
        case 39:
        {
            return _iceD_opMStruct2(in, current);
        }
        case 40:
        {
            return _iceD_opMyClass(in, current);
        }
        case 41:
        {
            return _iceD_opMyEnum(in, current);
        }
        case 42:
        {
            return _iceD_opMyEnumMyEnumSD(in, current);
        }
        case 43:
        {
            return _iceD_opMyEnumStringD(in, current);
        }
        case 44:
        {
            return _iceD_opMyEnumStringDS(in, current);
        }
        case 45:
        {
            return _iceD_opMyStructMyEnumD(in, current);
        }
        case 46:
        {
            return _iceD_opMyStructMyEnumDS(in, current);
        }
        case 47:
        {
            return _iceD_opNonmutating(in, current);
        }
        case 48:
        {
            return _iceD_opShort1(in, current);
        }
        case 49:
        {
            return _iceD_opShortIntD(in, current);
        }
        case 50:
        {
            return _iceD_opShortIntDS(in, current);
        }
        case 51:
        {
            return _iceD_opShortIntLong(in, current);
        }
        case 52:
        {
            return _iceD_opShortIntLongS(in, current);
        }
        case 53:
        {
            return _iceD_opShortIntLongSS(in, current);
        }
        case 54:
        {
            return _iceD_opShortShortSD(in, current);
        }
        case 55:
        {
            return _iceD_opString(in, current);
        }
        case 56:
        {
            return _iceD_opString1(in, current);
        }
        case 57:
        {
            return _iceD_opStringDoubleSD(in, current);
        }
        case 58:
        {
            return _iceD_opStringFloatSD(in, current);
        }
        case 59:
        {
            return _iceD_opStringLiterals(in, current);
        }
        case 60:
        {
            return _iceD_opStringMyEnumD(in, current);
        }
        case 61:
        {
            return _iceD_opStringMyEnumDS(in, current);
        }
        case 62:
        {
            return _iceD_opStringS(in, current);
        }
        case 63:
        {
            return _iceD_opStringS1(in, current);
        }
        case 64:
        {
            return _iceD_opStringS2(in, current);
        }
        case 65:
        {
            return _iceD_opStringSS(in, current);
        }
        case 66:
        {
            return _iceD_opStringSSS(in, current);
        }
        case 67:
        {
            return _iceD_opStringStringD(in, current);
        }
        case 68:
        {
            return _iceD_opStringStringDS(in, current);
        }
        case 69:
        {
            return _iceD_opStringStringSD(in, current);
        }
        case 70:
        {
            return _iceD_opStruct(in, current);
        }
        case 71:
        {
            return _iceD_opVoid(in, current);
        }
        case 72:
        {
            return _iceD_opWStringLiterals(in, current);
        }
        case 73:
        {
            return _iceD_shutdown(in, current);
        }
        case 74:
        {
            return _iceD_supportsCompress(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

::std::vector<::std::string>
Test::MyDerivedClass::ice_ids(const ::Ice::Current&) const
{
    static const ::std::vector<::std::string> allTypeIds = { "::Ice::Object", "::Test::MyClass", "::Test::MyDerivedClass" };
    return allTypeIds;
}

::std::string
Test::MyDerivedClass::ice_id(const ::Ice::Current&) const
{
    return ::std::string{ice_staticId()};
}

::std::string_view
Test::MyDerivedClass::ice_staticId()
{
    static constexpr ::std::string_view typeId = "::Test::MyDerivedClass";
    return typeId;
}

/// \cond INTERNAL
bool
Test::MyDerivedClass::_iceD_opDerived(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    this->opDerived(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyDerivedClass::_iceD_opMyClass1(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::shared_ptr<MyClass1> iceP_opMyClass1;
    istr->readAll(iceP_opMyClass1);
    istr->readPendingValues();
    inS.endReadParams();
    ::std::shared_ptr<MyClass1> ret = this->opMyClass1(::std::move(iceP_opMyClass1), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyDerivedClass::_iceD_opMyStruct1(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    MyStruct1 iceP_opMyStruct1;
    istr->readAll(iceP_opMyStruct1);
    inS.endReadParams();
    MyStruct1 ret = this->opMyStruct1(::std::move(iceP_opMyStruct1), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyDerivedClass::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    static constexpr ::std::string_view allOperations[] = { "ice_id", "ice_ids", "ice_isA", "ice_ping", "opBool", "opBoolBoolSD", "opBoolS", "opBoolSS", "opByte", "opByte1", "opByteBoolD", "opByteBoolD1", "opByteBoolD2", "opByteBoolDS", "opByteByteSD", "opByteS", "opByteSOneway", "opByteSOnewayCallCount", "opByteSS", "opContext", "opDerived", "opDouble1", "opDoubleMarshaling", "opFloat1", "opFloatDouble", "opFloatDoubleS", "opFloatDoubleSS", "opIdempotent", "opInt1", "opIntIntSD", "opIntS", "opLong1", "opLongFloatD", "opLongFloatDS", "opLongLongSD", "opMDict1", "opMDict2", "opMSeq1", "opMSeq2", "opMStruct1", "opMStruct2", "opMyClass", "opMyClass1", "opMyEnum", "opMyEnumMyEnumSD", "opMyEnumStringD", "opMyEnumStringDS", "opMyStruct1", "opMyStructMyEnumD", "opMyStructMyEnumDS", "opNonmutating", "opShort1", "opShortIntD", "opShortIntDS", "opShortIntLong", "opShortIntLongS", "opShortIntLongSS", "opShortShortSD", "opString", "opString1", "opStringDoubleSD", "opStringFloatSD", "opStringLiterals", "opStringMyEnumD", "opStringMyEnumDS", "opStringS", "opStringS1", "opStringS2", "opStringSS", "opStringSSS", "opStringStringD", "opStringStringDS", "opStringStringSD", "opStruct", "opVoid", "opWStringLiterals", "shutdown", "supportsCompress" };

    ::std::pair<const ::std::string_view*, const ::std::string_view*> r = ::std::equal_range(allOperations, allOperations + 78, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - allOperations)
    {
        case 0:
        {
            return _iceD_ice_id(in, current);
        }
        case 1:
        {
            return _iceD_ice_ids(in, current);
        }
        case 2:
        {
            return _iceD_ice_isA(in, current);
        }
        case 3:
        {
            return _iceD_ice_ping(in, current);
        }
        case 4:
        {
            return _iceD_opBool(in, current);
        }
        case 5:
        {
            return _iceD_opBoolBoolSD(in, current);
        }
        case 6:
        {
            return _iceD_opBoolS(in, current);
        }
        case 7:
        {
            return _iceD_opBoolSS(in, current);
        }
        case 8:
        {
            return _iceD_opByte(in, current);
        }
        case 9:
        {
            return _iceD_opByte1(in, current);
        }
        case 10:
        {
            return _iceD_opByteBoolD(in, current);
        }
        case 11:
        {
            return _iceD_opByteBoolD1(in, current);
        }
        case 12:
        {
            return _iceD_opByteBoolD2(in, current);
        }
        case 13:
        {
            return _iceD_opByteBoolDS(in, current);
        }
        case 14:
        {
            return _iceD_opByteByteSD(in, current);
        }
        case 15:
        {
            return _iceD_opByteS(in, current);
        }
        case 16:
        {
            return _iceD_opByteSOneway(in, current);
        }
        case 17:
        {
            return _iceD_opByteSOnewayCallCount(in, current);
        }
        case 18:
        {
            return _iceD_opByteSS(in, current);
        }
        case 19:
        {
            return _iceD_opContext(in, current);
        }
        case 20:
        {
            return _iceD_opDerived(in, current);
        }
        case 21:
        {
            return _iceD_opDouble1(in, current);
        }
        case 22:
        {
            return _iceD_opDoubleMarshaling(in, current);
        }
        case 23:
        {
            return _iceD_opFloat1(in, current);
        }
        case 24:
        {
            return _iceD_opFloatDouble(in, current);
        }
        case 25:
        {
            return _iceD_opFloatDoubleS(in, current);
        }
        case 26:
        {
            return _iceD_opFloatDoubleSS(in, current);
        }
        case 27:
        {
            return _iceD_opIdempotent(in, current);
        }
        case 28:
        {
            return _iceD_opInt1(in, current);
        }
        case 29:
        {
            return _iceD_opIntIntSD(in, current);
        }
        case 30:
        {
            return _iceD_opIntS(in, current);
        }
        case 31:
        {
            return _iceD_opLong1(in, current);
        }
        case 32:
        {
            return _iceD_opLongFloatD(in, current);
        }
        case 33:
        {
            return _iceD_opLongFloatDS(in, current);
        }
        case 34:
        {
            return _iceD_opLongLongSD(in, current);
        }
        case 35:
        {
            return _iceD_opMDict1(in, current);
        }
        case 36:
        {
            return _iceD_opMDict2(in, current);
        }
        case 37:
        {
            return _iceD_opMSeq1(in, current);
        }
        case 38:
        {
            return _iceD_opMSeq2(in, current);
        }
        case 39:
        {
            return _iceD_opMStruct1(in, current);
        }
        case 40:
        {
            return _iceD_opMStruct2(in, current);
        }
        case 41:
        {
            return _iceD_opMyClass(in, current);
        }
        case 42:
        {
            return _iceD_opMyClass1(in, current);
        }
        case 43:
        {
            return _iceD_opMyEnum(in, current);
        }
        case 44:
        {
            return _iceD_opMyEnumMyEnumSD(in, current);
        }
        case 45:
        {
            return _iceD_opMyEnumStringD(in, current);
        }
        case 46:
        {
            return _iceD_opMyEnumStringDS(in, current);
        }
        case 47:
        {
            return _iceD_opMyStruct1(in, current);
        }
        case 48:
        {
            return _iceD_opMyStructMyEnumD(in, current);
        }
        case 49:
        {
            return _iceD_opMyStructMyEnumDS(in, current);
        }
        case 50:
        {
            return _iceD_opNonmutating(in, current);
        }
        case 51:
        {
            return _iceD_opShort1(in, current);
        }
        case 52:
        {
            return _iceD_opShortIntD(in, current);
        }
        case 53:
        {
            return _iceD_opShortIntDS(in, current);
        }
        case 54:
        {
            return _iceD_opShortIntLong(in, current);
        }
        case 55:
        {
            return _iceD_opShortIntLongS(in, current);
        }
        case 56:
        {
            return _iceD_opShortIntLongSS(in, current);
        }
        case 57:
        {
            return _iceD_opShortShortSD(in, current);
        }
        case 58:
        {
            return _iceD_opString(in, current);
        }
        case 59:
        {
            return _iceD_opString1(in, current);
        }
        case 60:
        {
            return _iceD_opStringDoubleSD(in, current);
        }
        case 61:
        {
            return _iceD_opStringFloatSD(in, current);
        }
        case 62:
        {
            return _iceD_opStringLiterals(in, current);
        }
        case 63:
        {
            return _iceD_opStringMyEnumD(in, current);
        }
        case 64:
        {
            return _iceD_opStringMyEnumDS(in, current);
        }
        case 65:
        {
            return _iceD_opStringS(in, current);
        }
        case 66:
        {
            return _iceD_opStringS1(in, current);
        }
        case 67:
        {
            return _iceD_opStringS2(in, current);
        }
        case 68:
        {
            return _iceD_opStringSS(in, current);
        }
        case 69:
        {
            return _iceD_opStringSSS(in, current);
        }
        case 70:
        {
            return _iceD_opStringStringD(in, current);
        }
        case 71:
        {
            return _iceD_opStringStringDS(in, current);
        }
        case 72:
        {
            return _iceD_opStringStringSD(in, current);
        }
        case 73:
        {
            return _iceD_opStruct(in, current);
        }
        case 74:
        {
            return _iceD_opVoid(in, current);
        }
        case 75:
        {
            return _iceD_opWStringLiterals(in, current);
        }
        case 76:
        {
            return _iceD_shutdown(in, current);
        }
        case 77:
        {
            return _iceD_supportsCompress(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

::std::vector<::std::string>
Test2::MyDerivedClass::ice_ids(const ::Ice::Current&) const
{
    static const ::std::vector<::std::string> allTypeIds = { "::Ice::Object", "::Test2::MyDerivedClass", "::Test::MyClass" };
    return allTypeIds;
}

::std::string
Test2::MyDerivedClass::ice_id(const ::Ice::Current&) const
{
    return ::std::string{ice_staticId()};
}

::std::string_view
Test2::MyDerivedClass::ice_staticId()
{
    static constexpr ::std::string_view typeId = "::Test2::MyDerivedClass";
    return typeId;
}

/// \cond INTERNAL
bool
Test2::MyDerivedClass::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    static constexpr ::std::string_view allOperations[] = { "ice_id", "ice_ids", "ice_isA", "ice_ping", "opBool", "opBoolBoolSD", "opBoolS", "opBoolSS", "opByte", "opByte1", "opByteBoolD", "opByteBoolD1", "opByteBoolD2", "opByteBoolDS", "opByteByteSD", "opByteS", "opByteSOneway", "opByteSOnewayCallCount", "opByteSS", "opContext", "opDouble1", "opDoubleMarshaling", "opFloat1", "opFloatDouble", "opFloatDoubleS", "opFloatDoubleSS", "opIdempotent", "opInt1", "opIntIntSD", "opIntS", "opLong1", "opLongFloatD", "opLongFloatDS", "opLongLongSD", "opMDict1", "opMDict2", "opMSeq1", "opMSeq2", "opMStruct1", "opMStruct2", "opMyClass", "opMyEnum", "opMyEnumMyEnumSD", "opMyEnumStringD", "opMyEnumStringDS", "opMyStructMyEnumD", "opMyStructMyEnumDS", "opNonmutating", "opShort1", "opShortIntD", "opShortIntDS", "opShortIntLong", "opShortIntLongS", "opShortIntLongSS", "opShortShortSD", "opString", "opString1", "opStringDoubleSD", "opStringFloatSD", "opStringLiterals", "opStringMyEnumD", "opStringMyEnumDS", "opStringS", "opStringS1", "opStringS2", "opStringSS", "opStringSSS", "opStringStringD", "opStringStringDS", "opStringStringSD", "opStruct", "opVoid", "opWStringLiterals", "shutdown", "supportsCompress" };

    ::std::pair<const ::std::string_view*, const ::std::string_view*> r = ::std::equal_range(allOperations, allOperations + 75, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - allOperations)
    {
        case 0:
        {
            return _iceD_ice_id(in, current);
        }
        case 1:
        {
            return _iceD_ice_ids(in, current);
        }
        case 2:
        {
            return _iceD_ice_isA(in, current);
        }
        case 3:
        {
            return _iceD_ice_ping(in, current);
        }
        case 4:
        {
            return _iceD_opBool(in, current);
        }
        case 5:
        {
            return _iceD_opBoolBoolSD(in, current);
        }
        case 6:
        {
            return _iceD_opBoolS(in, current);
        }
        case 7:
        {
            return _iceD_opBoolSS(in, current);
        }
        case 8:
        {
            return _iceD_opByte(in, current);
        }
        case 9:
        {
            return _iceD_opByte1(in, current);
        }
        case 10:
        {
            return _iceD_opByteBoolD(in, current);
        }
        case 11:
        {
            return _iceD_opByteBoolD1(in, current);
        }
        case 12:
        {
            return _iceD_opByteBoolD2(in, current);
        }
        case 13:
        {
            return _iceD_opByteBoolDS(in, current);
        }
        case 14:
        {
            return _iceD_opByteByteSD(in, current);
        }
        case 15:
        {
            return _iceD_opByteS(in, current);
        }
        case 16:
        {
            return _iceD_opByteSOneway(in, current);
        }
        case 17:
        {
            return _iceD_opByteSOnewayCallCount(in, current);
        }
        case 18:
        {
            return _iceD_opByteSS(in, current);
        }
        case 19:
        {
            return _iceD_opContext(in, current);
        }
        case 20:
        {
            return _iceD_opDouble1(in, current);
        }
        case 21:
        {
            return _iceD_opDoubleMarshaling(in, current);
        }
        case 22:
        {
            return _iceD_opFloat1(in, current);
        }
        case 23:
        {
            return _iceD_opFloatDouble(in, current);
        }
        case 24:
        {
            return _iceD_opFloatDoubleS(in, current);
        }
        case 25:
        {
            return _iceD_opFloatDoubleSS(in, current);
        }
        case 26:
        {
            return _iceD_opIdempotent(in, current);
        }
        case 27:
        {
            return _iceD_opInt1(in, current);
        }
        case 28:
        {
            return _iceD_opIntIntSD(in, current);
        }
        case 29:
        {
            return _iceD_opIntS(in, current);
        }
        case 30:
        {
            return _iceD_opLong1(in, current);
        }
        case 31:
        {
            return _iceD_opLongFloatD(in, current);
        }
        case 32:
        {
            return _iceD_opLongFloatDS(in, current);
        }
        case 33:
        {
            return _iceD_opLongLongSD(in, current);
        }
        case 34:
        {
            return _iceD_opMDict1(in, current);
        }
        case 35:
        {
            return _iceD_opMDict2(in, current);
        }
        case 36:
        {
            return _iceD_opMSeq1(in, current);
        }
        case 37:
        {
            return _iceD_opMSeq2(in, current);
        }
        case 38:
        {
            return _iceD_opMStruct1(in, current);
        }
        case 39:
        {
            return _iceD_opMStruct2(in, current);
        }
        case 40:
        {
            return _iceD_opMyClass(in, current);
        }
        case 41:
        {
            return _iceD_opMyEnum(in, current);
        }
        case 42:
        {
            return _iceD_opMyEnumMyEnumSD(in, current);
        }
        case 43:
        {
            return _iceD_opMyEnumStringD(in, current);
        }
        case 44:
        {
            return _iceD_opMyEnumStringDS(in, current);
        }
        case 45:
        {
            return _iceD_opMyStructMyEnumD(in, current);
        }
        case 46:
        {
            return _iceD_opMyStructMyEnumDS(in, current);
        }
        case 47:
        {
            return _iceD_opNonmutating(in, current);
        }
        case 48:
        {
            return _iceD_opShort1(in, current);
        }
        case 49:
        {
            return _iceD_opShortIntD(in, current);
        }
        case 50:
        {
            return _iceD_opShortIntDS(in, current);
        }
        case 51:
        {
            return _iceD_opShortIntLong(in, current);
        }
        case 52:
        {
            return _iceD_opShortIntLongS(in, current);
        }
        case 53:
        {
            return _iceD_opShortIntLongSS(in, current);
        }
        case 54:
        {
            return _iceD_opShortShortSD(in, current);
        }
        case 55:
        {
            return _iceD_opString(in, current);
        }
        case 56:
        {
            return _iceD_opString1(in, current);
        }
        case 57:
        {
            return _iceD_opStringDoubleSD(in, current);
        }
        case 58:
        {
            return _iceD_opStringFloatSD(in, current);
        }
        case 59:
        {
            return _iceD_opStringLiterals(in, current);
        }
        case 60:
        {
            return _iceD_opStringMyEnumD(in, current);
        }
        case 61:
        {
            return _iceD_opStringMyEnumDS(in, current);
        }
        case 62:
        {
            return _iceD_opStringS(in, current);
        }
        case 63:
        {
            return _iceD_opStringS1(in, current);
        }
        case 64:
        {
            return _iceD_opStringS2(in, current);
        }
        case 65:
        {
            return _iceD_opStringSS(in, current);
        }
        case 66:
        {
            return _iceD_opStringSSS(in, current);
        }
        case 67:
        {
            return _iceD_opStringStringD(in, current);
        }
        case 68:
        {
            return _iceD_opStringStringDS(in, current);
        }
        case 69:
        {
            return _iceD_opStringStringSD(in, current);
        }
        case 70:
        {
            return _iceD_opStruct(in, current);
        }
        case 71:
        {
            return _iceD_opVoid(in, current);
        }
        case 72:
        {
            return _iceD_opWStringLiterals(in, current);
        }
        case 73:
        {
            return _iceD_shutdown(in, current);
        }
        case 74:
        {
            return _iceD_supportsCompress(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond
