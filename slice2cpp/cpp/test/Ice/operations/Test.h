//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.7.9
//
// <auto-generated>
//
// Generated from file `Test.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __Test_h__
#define __Test_h__

#include <IceUtil/PushDisableWarnings.h>
#include <Ice/ProxyF.h>
#include <Ice/ObjectF.h>
#include <Ice/ValueF.h>
#include <Ice/Exception.h>
#include <Ice/LocalObject.h>
#include <Ice/StreamHelpers.h>
#include <Ice/Comparable.h>
#include <Ice/Proxy.h>
#include <Ice/Object.h>
#include <Ice/GCObject.h>
#include <Ice/Value.h>
#include <Ice/Incoming.h>
#include <Ice/FactoryTableInit.h>
#include <IceUtil/ScopedArray.h>
#include <Ice/Optional.h>
#include <Ice/ExceptionHelpers.h>
#include <Ice/Current.h>
#include <IceUtil/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 307
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 >= 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 9
#       error Ice patch level mismatch!
#   endif
#endif

#ifdef ICE_CPP11_MAPPING // C++11 mapping

namespace Test
{

class MyClass;
class MyClassPrx;
class MyClass1;
class MyDerivedClass;
class MyDerivedClassPrx;

}

namespace Test2
{

class MyDerivedClass;
class MyDerivedClassPrx;

}

namespace M
{

class A;
class Intf;
class IntfPrx;
class B;
class BPrx;

}

namespace Test
{

enum class MyEnum : unsigned char
{
    enum1,
    enum2,
    enum3
};

struct AnotherStruct
{
    ::std::string s;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&> ice_tuple() const
    {
        return std::tie(s);
    }
};

struct Structure
{
    ::std::shared_ptr<::Test::MyClassPrx> p;
    ::Test::MyEnum e;
    ::Test::AnotherStruct s;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::shared_ptr<::Test::MyClassPrx>&, const ::Test::MyEnum&, const ::Test::AnotherStruct&> ice_tuple() const
    {
        return std::tie(p, e, s);
    }
};

using ByteS = ::std::vector<::Ice::Byte>;

using BoolS = ::std::vector<bool>;

using ShortS = ::std::vector<short>;

using IntS = ::std::vector<int>;

using LongS = ::std::vector<long long int>;

using FloatS = ::std::vector<float>;

using DoubleS = ::std::vector<double>;

using StringS = ::std::vector<::std::string>;

using WStringS = ::std::vector<::std::wstring>;

using MyEnumS = ::std::vector<MyEnum>;

using MyClassS = ::std::vector<::std::shared_ptr<MyClassPrx>>;

using ByteSS = ::std::vector<ByteS>;

using BoolSS = ::std::vector<BoolS>;

using ShortSS = ::std::vector<ShortS>;

using IntSS = ::std::vector<IntS>;

using LongSS = ::std::vector<LongS>;

using FloatSS = ::std::vector<FloatS>;

using DoubleSS = ::std::vector<DoubleS>;

using StringSS = ::std::vector<StringS>;

using MyEnumSS = ::std::vector<MyEnumS>;

using MyClassSS = ::std::vector<MyClassS>;

using StringSSS = ::std::vector<StringSS>;

struct MyStruct
{
    int i;
    int j;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const int&, const int&> ice_tuple() const
    {
        return std::tie(i, j);
    }
};

using ByteBoolD = ::std::map<::Ice::Byte, bool>;

using ShortIntD = ::std::map<short, int>;

using LongFloatD = ::std::map<long long int, float>;

using StringStringD = ::std::map<::std::string, ::std::string>;

using StringMyEnumD = ::std::map<::std::string, MyEnum>;

using MyEnumStringD = ::std::map<MyEnum, ::std::string>;

using MyStructMyEnumD = ::std::map<MyStruct, MyEnum>;

using ByteBoolDS = ::std::vector<ByteBoolD>;

using ShortIntDS = ::std::vector<ShortIntD>;

using LongFloatDS = ::std::vector<LongFloatD>;

using StringStringDS = ::std::vector<StringStringD>;

using StringMyEnumDS = ::std::vector<StringMyEnumD>;

using MyEnumStringDS = ::std::vector<MyEnumStringD>;

using MyStructMyEnumDS = ::std::vector<MyStructMyEnumD>;

using ByteByteSD = ::std::map<::Ice::Byte, ByteS>;

using BoolBoolSD = ::std::map<bool, BoolS>;

using ShortShortSD = ::std::map<short, ShortS>;

using IntIntSD = ::std::map<int, IntS>;

using LongLongSD = ::std::map<long long int, LongS>;

using StringFloatSD = ::std::map<::std::string, FloatS>;

using StringDoubleSD = ::std::map<::std::string, DoubleS>;

using StringStringSD = ::std::map<::std::string, StringS>;

using MyEnumMyEnumSD = ::std::map<MyEnum, MyEnumS>;

class SomeException : public ::Ice::UserExceptionHelper<SomeException, ::Ice::UserException>
{
public:

    virtual ~SomeException();

    SomeException(const SomeException&) = default;

    SomeException() = default;

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<> ice_tuple() const
    {
        return std::tie();
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();
};

/// \cond INTERNAL
static SomeException _iceS_SomeException_init;
/// \endcond

struct MyStruct1
{
    ::std::string tesT;
    ::std::shared_ptr<::Test::MyClassPrx> myClass;
    ::std::string myStruct1;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::std::shared_ptr<::Test::MyClassPrx>&, const ::std::string&> ice_tuple() const
    {
        return std::tie(tesT, myClass, myStruct1);
    }
};

const ::std::string s0 = "\\";

const ::std::string s1 = "A";

const ::std::string s2 = "Ice";

const ::std::string s3 = "A21";

const ::std::string s4 = "\\u0041 \\U00000041";

const ::std::string s5 = "\303\277";

const ::std::string s6 = "\317\277";

const ::std::string s7 = "\327\260";

const ::std::string s8 = "\360\220\200\200";

const ::std::string s9 = "\360\237\215\214";

const ::std::string s10 = "\340\266\247";

const ::std::string s11 = "\342\202\254\342\202\254\342\202\254";

const ::std::string s12 = "\\101";

const ::std::string sw0 = "\\";

const ::std::string sw1 = "A";

const ::std::string sw2 = "Ice";

const ::std::string sw3 = "A21";

const ::std::string sw4 = "\\u0041 \\U00000041";

const ::std::string sw5 = "\303\277";

const ::std::string sw6 = "\317\277";

const ::std::string sw7 = "\327\260";

const ::std::string sw8 = "\360\220\200\200";

const ::std::string sw9 = "\360\237\215\214";

const ::std::string sw10 = "\340\266\247";

/**
 * \'      single quote    byte 0x27 in ASCII encoding
 * \"      double quote    byte 0x22 in ASCII encoding
 * \?      question mark   byte 0x3f in ASCII encoding
 * \\      backslash       byte 0x5c in ASCII encoding
 * \a      audible bell    byte 0x07 in ASCII encoding
 * \b      backspace       byte 0x08 in ASCII encoding
 * \f      form feed - new page    byte 0x0c in ASCII encoding
 * \n      line feed - new line    byte 0x0a in ASCII encoding
 * \r      carriage return byte 0x0d in ASCII encoding
 * \t      horizontal tab  byte 0x09 in ASCII encoding
 * \v      vertical tab    byte 0x0b in ASCII encoding
 */
const ::std::string ss0 = "'\"\?\\\a\b\f\n\r\t\v\006";

const ::std::string ss1 = "'\"\?\\\a\b\f\n\r\t\v\006";

const ::std::string ss2 = "'\"\?\\\a\b\f\n\r\t\v\006";

const ::std::string ss3 = "\\\\U\\u\\";

const ::std::string ss4 = "\\A\\";

const ::std::string ss5 = "\\u0041\\";

const ::std::string su0 = "\304\250\305\270\303\277\304\200\341\274\200\360\220\206\224\360\220\205\252\360\220\206\230\360\237\215\200\360\237\215\201\360\237\215\202\360\237\215\203";

const ::std::string su1 = "\304\250\305\270\303\277\304\200\341\274\200\360\220\206\224\360\220\205\252\360\220\206\230\360\237\215\200\360\237\215\201\360\237\215\202\360\237\215\203";

const ::std::string su2 = "\304\250\305\270\303\277\304\200\341\274\200\360\220\206\224\360\220\205\252\360\220\206\230\360\237\215\200\360\237\215\201\360\237\215\202\360\237\215\203";

const ::std::wstring ws0 = L"\\";

const ::std::wstring ws1 = L"A";

const ::std::wstring ws2 = L"Ice";

const ::std::wstring ws3 = L"A21";

const ::std::wstring ws4 = L"\\u0041 \\U00000041";

const ::std::wstring ws5 = L"\u00FF";

const ::std::wstring ws6 = L"\u03FF";

const ::std::wstring ws7 = L"\u05F0";

const ::std::wstring ws8 = L"\U00010000";

const ::std::wstring ws9 = L"\U0001F34C";

const ::std::wstring ws10 = L"\u0DA7";

const ::std::wstring wsw0 = L"\\";

const ::std::wstring wsw1 = L"A";

const ::std::wstring wsw2 = L"Ice";

const ::std::wstring wsw3 = L"A21";

const ::std::wstring wsw4 = L"\\u0041 \\U00000041";

const ::std::wstring wsw5 = L"\U000000FF";

const ::std::wstring wsw6 = L"\U000003FF";

const ::std::wstring wsw7 = L"\U000005F0";

const ::std::wstring wsw8 = L"\U00010000";

const ::std::wstring wsw9 = L"\U0001F34C";

const ::std::wstring wsw10 = L"\U00000DA7";

/**
 * \'      single quote    byte 0x27 in ASCII encoding
 * \"      double quote    byte 0x22 in ASCII encoding
 * \?      question mark   byte 0x3f in ASCII encoding
 * \\      backslash       byte 0x5c in ASCII encoding
 * \a      audible bell    byte 0x07 in ASCII encoding
 * \b      backspace       byte 0x08 in ASCII encoding
 * \f      form feed - new page    byte 0x0c in ASCII encoding
 * \n      line feed - new line    byte 0x0a in ASCII encoding
 * \r      carriage return byte 0x0d in ASCII encoding
 * \t      horizontal tab  byte 0x09 in ASCII encoding
 * \v      vertical tab    byte 0x0b in ASCII encoding
 */
const ::std::wstring wss0 = L"'\"\?\\\a\b\f\n\r\t\v\u0006";

const ::std::wstring wss1 = L"'\"\?\\\a\b\f\n\r\t\v\u0006";

const ::std::wstring wss2 = L"'\"\?\\\a\b\f\n\r\t\v\u0006";

const ::std::wstring wss3 = L"\\\\U\\u\\";

const ::std::wstring wss4 = L"\\A\\";

const ::std::wstring wss5 = L"\\u0041\\";

const ::std::wstring wsu0 = L"\u0128\u0178\u00ff\u0100\u1f00\U00010194\U0001016a\U00010198\U0001f340\U0001f341\U0001f342\U0001f343";

const ::std::wstring wsu1 = L"\u0128\u0178\u00FF\u0100\u1F00\U00010194\U0001016A\U00010198\U0001F340\U0001F341\U0001F342\U0001F343";

const ::std::wstring wsu2 = L"\U00000128\U00000178\U000000FF\U00000100\U00001F00\U00010194\U0001016A\U00010198\U0001F340\U0001F341\U0001F342\U0001F343";

using Ice::operator<;
using Ice::operator<=;
using Ice::operator>;
using Ice::operator>=;
using Ice::operator==;
using Ice::operator!=;

}

namespace Test
{

class MyClass : public virtual ::Ice::Object
{
public:

    using ProxyType = MyClassPrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void shutdown(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_shutdown(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool supportsCompress(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_supportsCompress(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opVoid(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opVoid(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opByte.
     */
    struct OpByteResult
    {
        ::Ice::Byte returnValue;
        ::Ice::Byte p3;
    };

    virtual ::Ice::Byte opByte(::Ice::Byte p1, ::Ice::Byte p2, ::Ice::Byte& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opByte(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opBool.
     */
    struct OpBoolResult
    {
        bool returnValue;
        bool p3;
    };

    virtual bool opBool(bool p1, bool p2, bool& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opBool(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opShortIntLong.
     */
    struct OpShortIntLongResult
    {
        long long int returnValue;
        short p4;
        int p5;
        long long int p6;
    };

    virtual long long int opShortIntLong(short p1, int p2, long long int p3, short& p4, int& p5, long long int& p6, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opShortIntLong(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opFloatDouble.
     */
    struct OpFloatDoubleResult
    {
        double returnValue;
        float p3;
        double p4;
    };

    virtual double opFloatDouble(float p1, double p2, float& p3, double& p4, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opFloatDouble(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opString.
     */
    struct OpStringResult
    {
        ::std::string returnValue;
        ::std::string p3;
    };

    virtual ::std::string opString(::std::string p1, ::std::string p2, ::std::string& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opString(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opMyEnum.
     */
    struct OpMyEnumResult
    {
        MyEnum returnValue;
        MyEnum p2;
    };

    virtual MyEnum opMyEnum(MyEnum p1, MyEnum& p2, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opMyEnum(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opMyClass.
     */
    struct OpMyClassResult
    {
        ::std::shared_ptr<MyClassPrx> returnValue;
        ::std::shared_ptr<MyClassPrx> p2;
        ::std::shared_ptr<MyClassPrx> p3;
    };

    virtual ::std::shared_ptr<MyClassPrx> opMyClass(::std::shared_ptr<MyClassPrx> p1, ::std::shared_ptr<MyClassPrx>& p2, ::std::shared_ptr<MyClassPrx>& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opMyClass(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opStruct.
     */
    struct OpStructResult
    {
        Structure returnValue;
        Structure p3;
    };

    virtual Structure opStruct(Structure p1, Structure p2, Structure& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opStruct(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opByteS.
     */
    struct OpByteSResult
    {
        ByteS returnValue;
        ByteS p3;
    };

    virtual ByteS opByteS(ByteS p1, ByteS p2, ByteS& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opByteS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opBoolS.
     */
    struct OpBoolSResult
    {
        BoolS returnValue;
        BoolS p3;
    };

    virtual BoolS opBoolS(BoolS p1, BoolS p2, BoolS& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opBoolS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opShortIntLongS.
     */
    struct OpShortIntLongSResult
    {
        LongS returnValue;
        ShortS p4;
        IntS p5;
        LongS p6;
    };

    virtual LongS opShortIntLongS(ShortS p1, IntS p2, LongS p3, ShortS& p4, IntS& p5, LongS& p6, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opShortIntLongS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opFloatDoubleS.
     */
    struct OpFloatDoubleSResult
    {
        DoubleS returnValue;
        FloatS p3;
        DoubleS p4;
    };

    virtual DoubleS opFloatDoubleS(FloatS p1, DoubleS p2, FloatS& p3, DoubleS& p4, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opFloatDoubleS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opStringS.
     */
    struct OpStringSResult
    {
        StringS returnValue;
        StringS p3;
    };

    virtual StringS opStringS(StringS p1, StringS p2, StringS& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opStringS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opByteSS.
     */
    struct OpByteSSResult
    {
        ByteSS returnValue;
        ByteSS p3;
    };

    virtual ByteSS opByteSS(ByteSS p1, ByteSS p2, ByteSS& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opByteSS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opBoolSS.
     */
    struct OpBoolSSResult
    {
        BoolSS returnValue;
        BoolSS p3;
    };

    virtual BoolSS opBoolSS(BoolSS p1, BoolSS p2, BoolSS& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opBoolSS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opShortIntLongSS.
     */
    struct OpShortIntLongSSResult
    {
        LongSS returnValue;
        ShortSS p4;
        IntSS p5;
        LongSS p6;
    };

    virtual LongSS opShortIntLongSS(ShortSS p1, IntSS p2, LongSS p3, ShortSS& p4, IntSS& p5, LongSS& p6, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opShortIntLongSS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opFloatDoubleSS.
     */
    struct OpFloatDoubleSSResult
    {
        DoubleSS returnValue;
        FloatSS p3;
        DoubleSS p4;
    };

    virtual DoubleSS opFloatDoubleSS(FloatSS p1, DoubleSS p2, FloatSS& p3, DoubleSS& p4, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opFloatDoubleSS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opStringSS.
     */
    struct OpStringSSResult
    {
        StringSS returnValue;
        StringSS p3;
    };

    virtual StringSS opStringSS(StringSS p1, StringSS p2, StringSS& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opStringSS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opStringSSS.
     */
    struct OpStringSSSResult
    {
        StringSSS returnValue;
        StringSSS p3;
    };

    virtual StringSSS opStringSSS(StringSSS p1, StringSSS p2, StringSSS& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opStringSSS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opByteBoolD.
     */
    struct OpByteBoolDResult
    {
        ByteBoolD returnValue;
        ByteBoolD p3;
    };

    virtual ByteBoolD opByteBoolD(ByteBoolD p1, ByteBoolD p2, ByteBoolD& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opByteBoolD(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opShortIntD.
     */
    struct OpShortIntDResult
    {
        ShortIntD returnValue;
        ShortIntD p3;
    };

    virtual ShortIntD opShortIntD(ShortIntD p1, ShortIntD p2, ShortIntD& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opShortIntD(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opLongFloatD.
     */
    struct OpLongFloatDResult
    {
        LongFloatD returnValue;
        LongFloatD p3;
    };

    virtual LongFloatD opLongFloatD(LongFloatD p1, LongFloatD p2, LongFloatD& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opLongFloatD(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opStringStringD.
     */
    struct OpStringStringDResult
    {
        StringStringD returnValue;
        StringStringD p3;
    };

    virtual StringStringD opStringStringD(StringStringD p1, StringStringD p2, StringStringD& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opStringStringD(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opStringMyEnumD.
     */
    struct OpStringMyEnumDResult
    {
        StringMyEnumD returnValue;
        StringMyEnumD p3;
    };

    virtual StringMyEnumD opStringMyEnumD(StringMyEnumD p1, StringMyEnumD p2, StringMyEnumD& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opStringMyEnumD(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opMyEnumStringD.
     */
    struct OpMyEnumStringDResult
    {
        MyEnumStringD returnValue;
        MyEnumStringD p3;
    };

    virtual MyEnumStringD opMyEnumStringD(MyEnumStringD p1, MyEnumStringD p2, MyEnumStringD& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opMyEnumStringD(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opMyStructMyEnumD.
     */
    struct OpMyStructMyEnumDResult
    {
        MyStructMyEnumD returnValue;
        MyStructMyEnumD p3;
    };

    virtual MyStructMyEnumD opMyStructMyEnumD(MyStructMyEnumD p1, MyStructMyEnumD p2, MyStructMyEnumD& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opMyStructMyEnumD(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opByteBoolDS.
     */
    struct OpByteBoolDSResult
    {
        ByteBoolDS returnValue;
        ByteBoolDS p3;
    };

    virtual ByteBoolDS opByteBoolDS(ByteBoolDS p1, ByteBoolDS p2, ByteBoolDS& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opByteBoolDS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opShortIntDS.
     */
    struct OpShortIntDSResult
    {
        ShortIntDS returnValue;
        ShortIntDS p3;
    };

    virtual ShortIntDS opShortIntDS(ShortIntDS p1, ShortIntDS p2, ShortIntDS& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opShortIntDS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opLongFloatDS.
     */
    struct OpLongFloatDSResult
    {
        LongFloatDS returnValue;
        LongFloatDS p3;
    };

    virtual LongFloatDS opLongFloatDS(LongFloatDS p1, LongFloatDS p2, LongFloatDS& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opLongFloatDS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opStringStringDS.
     */
    struct OpStringStringDSResult
    {
        StringStringDS returnValue;
        StringStringDS p3;
    };

    virtual StringStringDS opStringStringDS(StringStringDS p1, StringStringDS p2, StringStringDS& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opStringStringDS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opStringMyEnumDS.
     */
    struct OpStringMyEnumDSResult
    {
        StringMyEnumDS returnValue;
        StringMyEnumDS p3;
    };

    virtual StringMyEnumDS opStringMyEnumDS(StringMyEnumDS p1, StringMyEnumDS p2, StringMyEnumDS& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opStringMyEnumDS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opMyEnumStringDS.
     */
    struct OpMyEnumStringDSResult
    {
        MyEnumStringDS returnValue;
        MyEnumStringDS p3;
    };

    virtual MyEnumStringDS opMyEnumStringDS(MyEnumStringDS p1, MyEnumStringDS p2, MyEnumStringDS& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opMyEnumStringDS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opMyStructMyEnumDS.
     */
    struct OpMyStructMyEnumDSResult
    {
        MyStructMyEnumDS returnValue;
        MyStructMyEnumDS p3;
    };

    virtual MyStructMyEnumDS opMyStructMyEnumDS(MyStructMyEnumDS p1, MyStructMyEnumDS p2, MyStructMyEnumDS& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opMyStructMyEnumDS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opByteByteSD.
     */
    struct OpByteByteSDResult
    {
        ByteByteSD returnValue;
        ByteByteSD p3;
    };

    virtual ByteByteSD opByteByteSD(ByteByteSD p1, ByteByteSD p2, ByteByteSD& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opByteByteSD(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opBoolBoolSD.
     */
    struct OpBoolBoolSDResult
    {
        BoolBoolSD returnValue;
        BoolBoolSD p3;
    };

    virtual BoolBoolSD opBoolBoolSD(BoolBoolSD p1, BoolBoolSD p2, BoolBoolSD& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opBoolBoolSD(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opShortShortSD.
     */
    struct OpShortShortSDResult
    {
        ShortShortSD returnValue;
        ShortShortSD p3;
    };

    virtual ShortShortSD opShortShortSD(ShortShortSD p1, ShortShortSD p2, ShortShortSD& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opShortShortSD(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opIntIntSD.
     */
    struct OpIntIntSDResult
    {
        IntIntSD returnValue;
        IntIntSD p3;
    };

    virtual IntIntSD opIntIntSD(IntIntSD p1, IntIntSD p2, IntIntSD& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opIntIntSD(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opLongLongSD.
     */
    struct OpLongLongSDResult
    {
        LongLongSD returnValue;
        LongLongSD p3;
    };

    virtual LongLongSD opLongLongSD(LongLongSD p1, LongLongSD p2, LongLongSD& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opLongLongSD(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opStringFloatSD.
     */
    struct OpStringFloatSDResult
    {
        StringFloatSD returnValue;
        StringFloatSD p3;
    };

    virtual StringFloatSD opStringFloatSD(StringFloatSD p1, StringFloatSD p2, StringFloatSD& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opStringFloatSD(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opStringDoubleSD.
     */
    struct OpStringDoubleSDResult
    {
        StringDoubleSD returnValue;
        StringDoubleSD p3;
    };

    virtual StringDoubleSD opStringDoubleSD(StringDoubleSD p1, StringDoubleSD p2, StringDoubleSD& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opStringDoubleSD(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opStringStringSD.
     */
    struct OpStringStringSDResult
    {
        StringStringSD returnValue;
        StringStringSD p3;
    };

    virtual StringStringSD opStringStringSD(StringStringSD p1, StringStringSD p2, StringStringSD& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opStringStringSD(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opMyEnumMyEnumSD.
     */
    struct OpMyEnumMyEnumSDResult
    {
        MyEnumMyEnumSD returnValue;
        MyEnumMyEnumSD p3;
    };

    virtual MyEnumMyEnumSD opMyEnumMyEnumSD(MyEnumMyEnumSD p1, MyEnumMyEnumSD p2, MyEnumMyEnumSD& p3, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opMyEnumMyEnumSD(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual IntS opIntS(IntS s, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opIntS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opByteSOneway(ByteS s, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opByteSOneway(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual int opByteSOnewayCallCount(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opByteSOnewayCallCount(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::Ice::Context opContext(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opContext(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opDoubleMarshaling(double p1, DoubleS p2, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opDoubleMarshaling(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opIdempotent(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opIdempotent(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opNonmutating(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opNonmutating(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::Ice::Byte opByte1(::Ice::Byte opByte1, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opByte1(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual short opShort1(short opShort1, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opShort1(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual int opInt1(int opInt1, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opInt1(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual long long int opLong1(long long int opLong1, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opLong1(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual float opFloat1(float opFloat1, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opFloat1(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual double opDouble1(double opDouble1, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opDouble1(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::std::string opString1(::std::string opString1, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opString1(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual StringS opStringS1(StringS opStringS1, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opStringS1(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ByteBoolD opByteBoolD1(ByteBoolD opByteBoolD1, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opByteBoolD1(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual StringS opStringS2(StringS stringS, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opStringS2(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ByteBoolD opByteBoolD2(ByteBoolD byteBoolD, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opByteBoolD2(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual StringS opStringLiterals(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opStringLiterals(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual WStringS opWStringLiterals(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opWStringLiterals(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Marshaled result structure for operation opMStruct1.
     */
    class OpMStruct1MarshaledResult : public ::Ice::MarshaledResult
    {
    public:
        /**
         * Marshals the results immediately.
         * @param current The Current object for the invocation.
         */
        OpMStruct1MarshaledResult(const Structure& returnValue, const ::Ice::Current& current);
    };

    virtual OpMStruct1MarshaledResult opMStruct1(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opMStruct1(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opMStruct2.
     */
    struct OpMStruct2Result
    {
        Structure returnValue;
        Structure p2;
    };

    /**
     * Marshaled result structure for operation opMStruct2.
     */
    class OpMStruct2MarshaledResult : public ::Ice::MarshaledResult
    {
    public:
        /**
         * Marshals the results immediately.
         * @param current The Current object for the invocation.
         */
        OpMStruct2MarshaledResult(const Structure& returnValue, const Structure& p2, const ::Ice::Current& current);
    };

    virtual OpMStruct2MarshaledResult opMStruct2(Structure p1, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opMStruct2(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Marshaled result structure for operation opMSeq1.
     */
    class OpMSeq1MarshaledResult : public ::Ice::MarshaledResult
    {
    public:
        /**
         * Marshals the results immediately.
         * @param current The Current object for the invocation.
         */
        OpMSeq1MarshaledResult(const StringS& returnValue, const ::Ice::Current& current);
    };

    virtual OpMSeq1MarshaledResult opMSeq1(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opMSeq1(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opMSeq2.
     */
    struct OpMSeq2Result
    {
        StringS returnValue;
        StringS p2;
    };

    /**
     * Marshaled result structure for operation opMSeq2.
     */
    class OpMSeq2MarshaledResult : public ::Ice::MarshaledResult
    {
    public:
        /**
         * Marshals the results immediately.
         * @param current The Current object for the invocation.
         */
        OpMSeq2MarshaledResult(const StringS& returnValue, const StringS& p2, const ::Ice::Current& current);
    };

    virtual OpMSeq2MarshaledResult opMSeq2(StringS p1, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opMSeq2(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Marshaled result structure for operation opMDict1.
     */
    class OpMDict1MarshaledResult : public ::Ice::MarshaledResult
    {
    public:
        /**
         * Marshals the results immediately.
         * @param current The Current object for the invocation.
         */
        OpMDict1MarshaledResult(const StringStringD& returnValue, const ::Ice::Current& current);
    };

    virtual OpMDict1MarshaledResult opMDict1(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opMDict1(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opMDict2.
     */
    struct OpMDict2Result
    {
        StringStringD returnValue;
        StringStringD p2;
    };

    /**
     * Marshaled result structure for operation opMDict2.
     */
    class OpMDict2MarshaledResult : public ::Ice::MarshaledResult
    {
    public:
        /**
         * Marshals the results immediately.
         * @param current The Current object for the invocation.
         */
        OpMDict2MarshaledResult(const StringStringD& returnValue, const StringStringD& p2, const ::Ice::Current& current);
    };

    virtual OpMDict2MarshaledResult opMDict2(StringStringD p1, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opMDict2(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

class MyDerivedClass : public virtual MyClass
{
public:

    using ProxyType = MyDerivedClassPrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void opDerived(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opDerived(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::std::shared_ptr<MyClass1> opMyClass1(::std::shared_ptr<MyClass1> opMyClass1, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opMyClass1(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual MyStruct1 opMyStruct1(MyStruct1 opMyStruct1, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opMyStruct1(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

}

namespace Test2
{

/**
 * Makes sure that proxy operations are correctly generated when extending an interface from
 * a different module (ICE-7639).
 */
class MyDerivedClass : public virtual ::Test::MyClass
{
public:

    using ProxyType = MyDerivedClassPrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

}

namespace M
{

class Intf : public virtual ::Ice::Object
{
public:

    using ProxyType = IntfPrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void opIntf(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opIntf(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

class BDisp : public virtual Intf
{
public:

    using ProxyType = BPrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void opB(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opB(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

}

namespace Test
{

class MyClass1 : public ::Ice::ValueHelper<MyClass1, ::Ice::Value>
{
public:

    virtual ~MyClass1();

    MyClass1() = default;

    MyClass1(const MyClass1&) = default;
    MyClass1(MyClass1&&) = default;
    MyClass1& operator=(const MyClass1&) = default;
    MyClass1& operator=(MyClass1&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    MyClass1(const ::std::string& tesT, const ::std::shared_ptr<::Test::MyClassPrx>& myClass, const ::std::string& myClass1) :
        tesT(tesT),
        myClass(myClass),
        myClass1(myClass1)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::std::shared_ptr<::Test::MyClassPrx>&, const ::std::string&> ice_tuple() const
    {
        return std::tie(tesT, myClass, myClass1);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::std::string tesT;
    ::std::shared_ptr<::Test::MyClassPrx> myClass;
    ::std::string myClass1;
};

/// \cond INTERNAL
static MyClass1 _iceS_MyClass1_init;
/// \endcond

}

namespace M
{

class A : public ::Ice::ValueHelper<A, ::Ice::Value>
{
public:

    virtual ~A();

    A() = default;

    A(const A&) = default;
    A(A&&) = default;
    A& operator=(const A&) = default;
    A& operator=(A&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit A(int x) :
        x(x)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const int&> ice_tuple() const
    {
        return std::tie(x);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    int x;
};

class B : public ::Ice::ValueHelper<B, A>
{
public:

    virtual ~B();

    B() = default;

    B(const B&) = default;
    B(B&&) = default;
    B& operator=(const B&) = default;
    B& operator=(B&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit B(int x) :
        Ice::ValueHelper<B, A>(x)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const int&> ice_tuple() const
    {
        return std::tie(x);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();
};

}

namespace Test
{

class MyClassPrx : public virtual ::Ice::Proxy<MyClassPrx, ::Ice::ObjectPrx>
{
public:

    void shutdown(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &MyClassPrx::_iceI_shutdown, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto shutdownAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &MyClassPrx::_iceI_shutdown, context);
    }

    ::std::function<void()>
    shutdownAsync(::std::function<void()> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_shutdown, context);
    }

    /// \cond INTERNAL
    void _iceI_shutdown(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    bool supportsCompress(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<bool>(true, this, &MyClassPrx::_iceI_supportsCompress, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto supportsCompressAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<bool>>().get_future())
    {
        return _makePromiseOutgoing<bool, P>(false, this, &MyClassPrx::_iceI_supportsCompress, context);
    }

    ::std::function<void()>
    supportsCompressAsync(::std::function<void(bool)> response,
                          ::std::function<void(::std::exception_ptr)> ex = nullptr,
                          ::std::function<void(bool)> sent = nullptr,
                          const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<bool>(std::move(response), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_supportsCompress, context);
    }

    /// \cond INTERNAL
    void _iceI_supportsCompress(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>&, const ::Ice::Context&);
    /// \endcond

    void opVoid(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &MyClassPrx::_iceI_opVoid, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto opVoidAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &MyClassPrx::_iceI_opVoid, context);
    }

    ::std::function<void()>
    opVoidAsync(::std::function<void()> response,
                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                ::std::function<void(bool)> sent = nullptr,
                const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opVoid, context);
    }

    /// \cond INTERNAL
    void _iceI_opVoid(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    ::Ice::Byte opByte(::Ice::Byte p1, ::Ice::Byte p2, ::Ice::Byte& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpByteResult>(true, this, &MyClassPrx::_iceI_opByte, p1, p2, context).get();
        p3 = _result.p3;
        return _result.returnValue;
    }

    template<template<typename> class P = ::std::promise>
    auto opByteAsync(::Ice::Byte p1, ::Ice::Byte p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpByteResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpByteResult, P>(false, this, &MyClassPrx::_iceI_opByte, p1, p2, context);
    }

    ::std::function<void()>
    opByteAsync(::Ice::Byte p1, ::Ice::Byte p2,
                ::std::function<void(::Ice::Byte, ::Ice::Byte)> response,
                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                ::std::function<void(bool)> sent = nullptr,
                const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpByteResult&& _result)
        {
            response(_result.returnValue, _result.p3);
        };
        return _makeLamdaOutgoing<MyClass::OpByteResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opByte, p1, p2, context);
    }

    /// \cond INTERNAL
    void _iceI_opByte(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpByteResult>>&, ::Ice::Byte, ::Ice::Byte, const ::Ice::Context&);
    /// \endcond

    bool opBool(bool p1, bool p2, bool& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpBoolResult>(true, this, &MyClassPrx::_iceI_opBool, p1, p2, context).get();
        p3 = _result.p3;
        return _result.returnValue;
    }

    template<template<typename> class P = ::std::promise>
    auto opBoolAsync(bool p1, bool p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpBoolResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpBoolResult, P>(false, this, &MyClassPrx::_iceI_opBool, p1, p2, context);
    }

    ::std::function<void()>
    opBoolAsync(bool p1, bool p2,
                ::std::function<void(bool, bool)> response,
                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                ::std::function<void(bool)> sent = nullptr,
                const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpBoolResult&& _result)
        {
            response(_result.returnValue, _result.p3);
        };
        return _makeLamdaOutgoing<MyClass::OpBoolResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opBool, p1, p2, context);
    }

    /// \cond INTERNAL
    void _iceI_opBool(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpBoolResult>>&, bool, bool, const ::Ice::Context&);
    /// \endcond

    long long int opShortIntLong(short p1, int p2, long long int p3, short& p4, int& p5, long long int& p6, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpShortIntLongResult>(true, this, &MyClassPrx::_iceI_opShortIntLong, p1, p2, p3, context).get();
        p4 = _result.p4;
        p5 = _result.p5;
        p6 = _result.p6;
        return _result.returnValue;
    }

    template<template<typename> class P = ::std::promise>
    auto opShortIntLongAsync(short p1, int p2, long long int p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpShortIntLongResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpShortIntLongResult, P>(false, this, &MyClassPrx::_iceI_opShortIntLong, p1, p2, p3, context);
    }

    ::std::function<void()>
    opShortIntLongAsync(short p1, int p2, long long int p3,
                        ::std::function<void(long long int, short, int, long long int)> response,
                        ::std::function<void(::std::exception_ptr)> ex = nullptr,
                        ::std::function<void(bool)> sent = nullptr,
                        const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpShortIntLongResult&& _result)
        {
            response(_result.returnValue, _result.p4, _result.p5, _result.p6);
        };
        return _makeLamdaOutgoing<MyClass::OpShortIntLongResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opShortIntLong, p1, p2, p3, context);
    }

    /// \cond INTERNAL
    void _iceI_opShortIntLong(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpShortIntLongResult>>&, short, int, long long int, const ::Ice::Context&);
    /// \endcond

    double opFloatDouble(float p1, double p2, float& p3, double& p4, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpFloatDoubleResult>(true, this, &MyClassPrx::_iceI_opFloatDouble, p1, p2, context).get();
        p3 = _result.p3;
        p4 = _result.p4;
        return _result.returnValue;
    }

    template<template<typename> class P = ::std::promise>
    auto opFloatDoubleAsync(float p1, double p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpFloatDoubleResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpFloatDoubleResult, P>(false, this, &MyClassPrx::_iceI_opFloatDouble, p1, p2, context);
    }

    ::std::function<void()>
    opFloatDoubleAsync(float p1, double p2,
                       ::std::function<void(double, float, double)> response,
                       ::std::function<void(::std::exception_ptr)> ex = nullptr,
                       ::std::function<void(bool)> sent = nullptr,
                       const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpFloatDoubleResult&& _result)
        {
            response(_result.returnValue, _result.p3, _result.p4);
        };
        return _makeLamdaOutgoing<MyClass::OpFloatDoubleResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opFloatDouble, p1, p2, context);
    }

    /// \cond INTERNAL
    void _iceI_opFloatDouble(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpFloatDoubleResult>>&, float, double, const ::Ice::Context&);
    /// \endcond

    ::std::string opString(const ::std::string& p1, const ::std::string& p2, ::std::string& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpStringResult>(true, this, &MyClassPrx::_iceI_opString, p1, p2, context).get();
        p3 = ::std::move(_result.p3);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opStringAsync(const ::std::string& p1, const ::std::string& p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpStringResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpStringResult, P>(false, this, &MyClassPrx::_iceI_opString, p1, p2, context);
    }

    ::std::function<void()>
    opStringAsync(const ::std::string& p1, const ::std::string& p2,
                  ::std::function<void(::std::string, ::std::string)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpStringResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.p3));
        };
        return _makeLamdaOutgoing<MyClass::OpStringResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opString, p1, p2, context);
    }

    /// \cond INTERNAL
    void _iceI_opString(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpStringResult>>&, const ::std::string&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    MyEnum opMyEnum(MyEnum p1, MyEnum& p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpMyEnumResult>(true, this, &MyClassPrx::_iceI_opMyEnum, p1, context).get();
        p2 = _result.p2;
        return _result.returnValue;
    }

    template<template<typename> class P = ::std::promise>
    auto opMyEnumAsync(MyEnum p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpMyEnumResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpMyEnumResult, P>(false, this, &MyClassPrx::_iceI_opMyEnum, p1, context);
    }

    ::std::function<void()>
    opMyEnumAsync(MyEnum p1,
                  ::std::function<void(::Test::MyEnum, ::Test::MyEnum)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpMyEnumResult&& _result)
        {
            response(_result.returnValue, _result.p2);
        };
        return _makeLamdaOutgoing<MyClass::OpMyEnumResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opMyEnum, p1, context);
    }

    /// \cond INTERNAL
    void _iceI_opMyEnum(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpMyEnumResult>>&, MyEnum, const ::Ice::Context&);
    /// \endcond

    ::std::shared_ptr<MyClassPrx> opMyClass(const ::std::shared_ptr<MyClassPrx>& p1, ::std::shared_ptr<MyClassPrx>& p2, ::std::shared_ptr<MyClassPrx>& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpMyClassResult>(true, this, &MyClassPrx::_iceI_opMyClass, p1, context).get();
        p2 = ::std::move(_result.p2);
        p3 = ::std::move(_result.p3);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opMyClassAsync(const ::std::shared_ptr<MyClassPrx>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpMyClassResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpMyClassResult, P>(false, this, &MyClassPrx::_iceI_opMyClass, p1, context);
    }

    ::std::function<void()>
    opMyClassAsync(const ::std::shared_ptr<MyClassPrx>& p1,
                   ::std::function<void(::std::shared_ptr<::Test::MyClassPrx>, ::std::shared_ptr<::Test::MyClassPrx>, ::std::shared_ptr<::Test::MyClassPrx>)> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpMyClassResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.p2), ::std::move(_result.p3));
        };
        return _makeLamdaOutgoing<MyClass::OpMyClassResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opMyClass, p1, context);
    }

    /// \cond INTERNAL
    void _iceI_opMyClass(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpMyClassResult>>&, const ::std::shared_ptr<MyClassPrx>&, const ::Ice::Context&);
    /// \endcond

    Structure opStruct(const Structure& p1, const Structure& p2, Structure& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpStructResult>(true, this, &MyClassPrx::_iceI_opStruct, p1, p2, context).get();
        p3 = ::std::move(_result.p3);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opStructAsync(const Structure& p1, const Structure& p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpStructResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpStructResult, P>(false, this, &MyClassPrx::_iceI_opStruct, p1, p2, context);
    }

    ::std::function<void()>
    opStructAsync(const Structure& p1, const Structure& p2,
                  ::std::function<void(::Test::Structure, ::Test::Structure)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpStructResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.p3));
        };
        return _makeLamdaOutgoing<MyClass::OpStructResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opStruct, p1, p2, context);
    }

    /// \cond INTERNAL
    void _iceI_opStruct(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpStructResult>>&, const Structure&, const Structure&, const ::Ice::Context&);
    /// \endcond

    ByteS opByteS(const ByteS& p1, const ByteS& p2, ByteS& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpByteSResult>(true, this, &MyClassPrx::_iceI_opByteS, p1, p2, context).get();
        p3 = ::std::move(_result.p3);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opByteSAsync(const ByteS& p1, const ByteS& p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpByteSResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpByteSResult, P>(false, this, &MyClassPrx::_iceI_opByteS, p1, p2, context);
    }

    ::std::function<void()>
    opByteSAsync(const ByteS& p1, const ByteS& p2,
                 ::std::function<void(::Test::ByteS, ::Test::ByteS)> response,
                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                 ::std::function<void(bool)> sent = nullptr,
                 const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpByteSResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.p3));
        };
        return _makeLamdaOutgoing<MyClass::OpByteSResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opByteS, p1, p2, context);
    }

    /// \cond INTERNAL
    void _iceI_opByteS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpByteSResult>>&, const ByteS&, const ByteS&, const ::Ice::Context&);
    /// \endcond

    BoolS opBoolS(const BoolS& p1, const BoolS& p2, BoolS& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpBoolSResult>(true, this, &MyClassPrx::_iceI_opBoolS, p1, p2, context).get();
        p3 = ::std::move(_result.p3);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opBoolSAsync(const BoolS& p1, const BoolS& p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpBoolSResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpBoolSResult, P>(false, this, &MyClassPrx::_iceI_opBoolS, p1, p2, context);
    }

    ::std::function<void()>
    opBoolSAsync(const BoolS& p1, const BoolS& p2,
                 ::std::function<void(::Test::BoolS, ::Test::BoolS)> response,
                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                 ::std::function<void(bool)> sent = nullptr,
                 const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpBoolSResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.p3));
        };
        return _makeLamdaOutgoing<MyClass::OpBoolSResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opBoolS, p1, p2, context);
    }

    /// \cond INTERNAL
    void _iceI_opBoolS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpBoolSResult>>&, const BoolS&, const BoolS&, const ::Ice::Context&);
    /// \endcond

    LongS opShortIntLongS(const ShortS& p1, const IntS& p2, const LongS& p3, ShortS& p4, IntS& p5, LongS& p6, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpShortIntLongSResult>(true, this, &MyClassPrx::_iceI_opShortIntLongS, p1, p2, p3, context).get();
        p4 = ::std::move(_result.p4);
        p5 = ::std::move(_result.p5);
        p6 = ::std::move(_result.p6);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opShortIntLongSAsync(const ShortS& p1, const IntS& p2, const LongS& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpShortIntLongSResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpShortIntLongSResult, P>(false, this, &MyClassPrx::_iceI_opShortIntLongS, p1, p2, p3, context);
    }

    ::std::function<void()>
    opShortIntLongSAsync(const ShortS& p1, const IntS& p2, const LongS& p3,
                         ::std::function<void(::Test::LongS, ::Test::ShortS, ::Test::IntS, ::Test::LongS)> response,
                         ::std::function<void(::std::exception_ptr)> ex = nullptr,
                         ::std::function<void(bool)> sent = nullptr,
                         const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpShortIntLongSResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.p4), ::std::move(_result.p5), ::std::move(_result.p6));
        };
        return _makeLamdaOutgoing<MyClass::OpShortIntLongSResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opShortIntLongS, p1, p2, p3, context);
    }

    /// \cond INTERNAL
    void _iceI_opShortIntLongS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpShortIntLongSResult>>&, const ShortS&, const IntS&, const LongS&, const ::Ice::Context&);
    /// \endcond

    DoubleS opFloatDoubleS(const FloatS& p1, const DoubleS& p2, FloatS& p3, DoubleS& p4, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpFloatDoubleSResult>(true, this, &MyClassPrx::_iceI_opFloatDoubleS, p1, p2, context).get();
        p3 = ::std::move(_result.p3);
        p4 = ::std::move(_result.p4);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opFloatDoubleSAsync(const FloatS& p1, const DoubleS& p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpFloatDoubleSResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpFloatDoubleSResult, P>(false, this, &MyClassPrx::_iceI_opFloatDoubleS, p1, p2, context);
    }

    ::std::function<void()>
    opFloatDoubleSAsync(const FloatS& p1, const DoubleS& p2,
                        ::std::function<void(::Test::DoubleS, ::Test::FloatS, ::Test::DoubleS)> response,
                        ::std::function<void(::std::exception_ptr)> ex = nullptr,
                        ::std::function<void(bool)> sent = nullptr,
                        const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpFloatDoubleSResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.p3), ::std::move(_result.p4));
        };
        return _makeLamdaOutgoing<MyClass::OpFloatDoubleSResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opFloatDoubleS, p1, p2, context);
    }

    /// \cond INTERNAL
    void _iceI_opFloatDoubleS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpFloatDoubleSResult>>&, const FloatS&, const DoubleS&, const ::Ice::Context&);
    /// \endcond

    StringS opStringS(const StringS& p1, const StringS& p2, StringS& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpStringSResult>(true, this, &MyClassPrx::_iceI_opStringS, p1, p2, context).get();
        p3 = ::std::move(_result.p3);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opStringSAsync(const StringS& p1, const StringS& p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpStringSResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpStringSResult, P>(false, this, &MyClassPrx::_iceI_opStringS, p1, p2, context);
    }

    ::std::function<void()>
    opStringSAsync(const StringS& p1, const StringS& p2,
                   ::std::function<void(::Test::StringS, ::Test::StringS)> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpStringSResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.p3));
        };
        return _makeLamdaOutgoing<MyClass::OpStringSResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opStringS, p1, p2, context);
    }

    /// \cond INTERNAL
    void _iceI_opStringS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpStringSResult>>&, const StringS&, const StringS&, const ::Ice::Context&);
    /// \endcond

    ByteSS opByteSS(const ByteSS& p1, const ByteSS& p2, ByteSS& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpByteSSResult>(true, this, &MyClassPrx::_iceI_opByteSS, p1, p2, context).get();
        p3 = ::std::move(_result.p3);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opByteSSAsync(const ByteSS& p1, const ByteSS& p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpByteSSResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpByteSSResult, P>(false, this, &MyClassPrx::_iceI_opByteSS, p1, p2, context);
    }

    ::std::function<void()>
    opByteSSAsync(const ByteSS& p1, const ByteSS& p2,
                  ::std::function<void(::Test::ByteSS, ::Test::ByteSS)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpByteSSResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.p3));
        };
        return _makeLamdaOutgoing<MyClass::OpByteSSResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opByteSS, p1, p2, context);
    }

    /// \cond INTERNAL
    void _iceI_opByteSS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpByteSSResult>>&, const ByteSS&, const ByteSS&, const ::Ice::Context&);
    /// \endcond

    BoolSS opBoolSS(const BoolSS& p1, const BoolSS& p2, BoolSS& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpBoolSSResult>(true, this, &MyClassPrx::_iceI_opBoolSS, p1, p2, context).get();
        p3 = ::std::move(_result.p3);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opBoolSSAsync(const BoolSS& p1, const BoolSS& p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpBoolSSResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpBoolSSResult, P>(false, this, &MyClassPrx::_iceI_opBoolSS, p1, p2, context);
    }

    ::std::function<void()>
    opBoolSSAsync(const BoolSS& p1, const BoolSS& p2,
                  ::std::function<void(::Test::BoolSS, ::Test::BoolSS)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpBoolSSResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.p3));
        };
        return _makeLamdaOutgoing<MyClass::OpBoolSSResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opBoolSS, p1, p2, context);
    }

    /// \cond INTERNAL
    void _iceI_opBoolSS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpBoolSSResult>>&, const BoolSS&, const BoolSS&, const ::Ice::Context&);
    /// \endcond

    LongSS opShortIntLongSS(const ShortSS& p1, const IntSS& p2, const LongSS& p3, ShortSS& p4, IntSS& p5, LongSS& p6, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpShortIntLongSSResult>(true, this, &MyClassPrx::_iceI_opShortIntLongSS, p1, p2, p3, context).get();
        p4 = ::std::move(_result.p4);
        p5 = ::std::move(_result.p5);
        p6 = ::std::move(_result.p6);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opShortIntLongSSAsync(const ShortSS& p1, const IntSS& p2, const LongSS& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpShortIntLongSSResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpShortIntLongSSResult, P>(false, this, &MyClassPrx::_iceI_opShortIntLongSS, p1, p2, p3, context);
    }

    ::std::function<void()>
    opShortIntLongSSAsync(const ShortSS& p1, const IntSS& p2, const LongSS& p3,
                          ::std::function<void(::Test::LongSS, ::Test::ShortSS, ::Test::IntSS, ::Test::LongSS)> response,
                          ::std::function<void(::std::exception_ptr)> ex = nullptr,
                          ::std::function<void(bool)> sent = nullptr,
                          const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpShortIntLongSSResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.p4), ::std::move(_result.p5), ::std::move(_result.p6));
        };
        return _makeLamdaOutgoing<MyClass::OpShortIntLongSSResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opShortIntLongSS, p1, p2, p3, context);
    }

    /// \cond INTERNAL
    void _iceI_opShortIntLongSS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpShortIntLongSSResult>>&, const ShortSS&, const IntSS&, const LongSS&, const ::Ice::Context&);
    /// \endcond

    DoubleSS opFloatDoubleSS(const FloatSS& p1, const DoubleSS& p2, FloatSS& p3, DoubleSS& p4, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpFloatDoubleSSResult>(true, this, &MyClassPrx::_iceI_opFloatDoubleSS, p1, p2, context).get();
        p3 = ::std::move(_result.p3);
        p4 = ::std::move(_result.p4);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opFloatDoubleSSAsync(const FloatSS& p1, const DoubleSS& p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpFloatDoubleSSResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpFloatDoubleSSResult, P>(false, this, &MyClassPrx::_iceI_opFloatDoubleSS, p1, p2, context);
    }

    ::std::function<void()>
    opFloatDoubleSSAsync(const FloatSS& p1, const DoubleSS& p2,
                         ::std::function<void(::Test::DoubleSS, ::Test::FloatSS, ::Test::DoubleSS)> response,
                         ::std::function<void(::std::exception_ptr)> ex = nullptr,
                         ::std::function<void(bool)> sent = nullptr,
                         const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpFloatDoubleSSResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.p3), ::std::move(_result.p4));
        };
        return _makeLamdaOutgoing<MyClass::OpFloatDoubleSSResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opFloatDoubleSS, p1, p2, context);
    }

    /// \cond INTERNAL
    void _iceI_opFloatDoubleSS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpFloatDoubleSSResult>>&, const FloatSS&, const DoubleSS&, const ::Ice::Context&);
    /// \endcond

    StringSS opStringSS(const StringSS& p1, const StringSS& p2, StringSS& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpStringSSResult>(true, this, &MyClassPrx::_iceI_opStringSS, p1, p2, context).get();
        p3 = ::std::move(_result.p3);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opStringSSAsync(const StringSS& p1, const StringSS& p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpStringSSResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpStringSSResult, P>(false, this, &MyClassPrx::_iceI_opStringSS, p1, p2, context);
    }

    ::std::function<void()>
    opStringSSAsync(const StringSS& p1, const StringSS& p2,
                    ::std::function<void(::Test::StringSS, ::Test::StringSS)> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpStringSSResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.p3));
        };
        return _makeLamdaOutgoing<MyClass::OpStringSSResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opStringSS, p1, p2, context);
    }

    /// \cond INTERNAL
    void _iceI_opStringSS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpStringSSResult>>&, const StringSS&, const StringSS&, const ::Ice::Context&);
    /// \endcond

    StringSSS opStringSSS(const StringSSS& p1, const StringSSS& p2, StringSSS& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpStringSSSResult>(true, this, &MyClassPrx::_iceI_opStringSSS, p1, p2, context).get();
        p3 = ::std::move(_result.p3);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opStringSSSAsync(const StringSSS& p1, const StringSSS& p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpStringSSSResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpStringSSSResult, P>(false, this, &MyClassPrx::_iceI_opStringSSS, p1, p2, context);
    }

    ::std::function<void()>
    opStringSSSAsync(const StringSSS& p1, const StringSSS& p2,
                     ::std::function<void(::Test::StringSSS, ::Test::StringSSS)> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpStringSSSResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.p3));
        };
        return _makeLamdaOutgoing<MyClass::OpStringSSSResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opStringSSS, p1, p2, context);
    }

    /// \cond INTERNAL
    void _iceI_opStringSSS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpStringSSSResult>>&, const StringSSS&, const StringSSS&, const ::Ice::Context&);
    /// \endcond

    ByteBoolD opByteBoolD(const ByteBoolD& p1, const ByteBoolD& p2, ByteBoolD& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpByteBoolDResult>(true, this, &MyClassPrx::_iceI_opByteBoolD, p1, p2, context).get();
        p3 = ::std::move(_result.p3);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opByteBoolDAsync(const ByteBoolD& p1, const ByteBoolD& p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpByteBoolDResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpByteBoolDResult, P>(false, this, &MyClassPrx::_iceI_opByteBoolD, p1, p2, context);
    }

    ::std::function<void()>
    opByteBoolDAsync(const ByteBoolD& p1, const ByteBoolD& p2,
                     ::std::function<void(::Test::ByteBoolD, ::Test::ByteBoolD)> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpByteBoolDResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.p3));
        };
        return _makeLamdaOutgoing<MyClass::OpByteBoolDResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opByteBoolD, p1, p2, context);
    }

    /// \cond INTERNAL
    void _iceI_opByteBoolD(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpByteBoolDResult>>&, const ByteBoolD&, const ByteBoolD&, const ::Ice::Context&);
    /// \endcond

    ShortIntD opShortIntD(const ShortIntD& p1, const ShortIntD& p2, ShortIntD& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpShortIntDResult>(true, this, &MyClassPrx::_iceI_opShortIntD, p1, p2, context).get();
        p3 = ::std::move(_result.p3);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opShortIntDAsync(const ShortIntD& p1, const ShortIntD& p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpShortIntDResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpShortIntDResult, P>(false, this, &MyClassPrx::_iceI_opShortIntD, p1, p2, context);
    }

    ::std::function<void()>
    opShortIntDAsync(const ShortIntD& p1, const ShortIntD& p2,
                     ::std::function<void(::Test::ShortIntD, ::Test::ShortIntD)> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpShortIntDResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.p3));
        };
        return _makeLamdaOutgoing<MyClass::OpShortIntDResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opShortIntD, p1, p2, context);
    }

    /// \cond INTERNAL
    void _iceI_opShortIntD(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpShortIntDResult>>&, const ShortIntD&, const ShortIntD&, const ::Ice::Context&);
    /// \endcond

    LongFloatD opLongFloatD(const LongFloatD& p1, const LongFloatD& p2, LongFloatD& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpLongFloatDResult>(true, this, &MyClassPrx::_iceI_opLongFloatD, p1, p2, context).get();
        p3 = ::std::move(_result.p3);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opLongFloatDAsync(const LongFloatD& p1, const LongFloatD& p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpLongFloatDResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpLongFloatDResult, P>(false, this, &MyClassPrx::_iceI_opLongFloatD, p1, p2, context);
    }

    ::std::function<void()>
    opLongFloatDAsync(const LongFloatD& p1, const LongFloatD& p2,
                      ::std::function<void(::Test::LongFloatD, ::Test::LongFloatD)> response,
                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                      ::std::function<void(bool)> sent = nullptr,
                      const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpLongFloatDResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.p3));
        };
        return _makeLamdaOutgoing<MyClass::OpLongFloatDResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opLongFloatD, p1, p2, context);
    }

    /// \cond INTERNAL
    void _iceI_opLongFloatD(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpLongFloatDResult>>&, const LongFloatD&, const LongFloatD&, const ::Ice::Context&);
    /// \endcond

    StringStringD opStringStringD(const StringStringD& p1, const StringStringD& p2, StringStringD& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpStringStringDResult>(true, this, &MyClassPrx::_iceI_opStringStringD, p1, p2, context).get();
        p3 = ::std::move(_result.p3);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opStringStringDAsync(const StringStringD& p1, const StringStringD& p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpStringStringDResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpStringStringDResult, P>(false, this, &MyClassPrx::_iceI_opStringStringD, p1, p2, context);
    }

    ::std::function<void()>
    opStringStringDAsync(const StringStringD& p1, const StringStringD& p2,
                         ::std::function<void(::Test::StringStringD, ::Test::StringStringD)> response,
                         ::std::function<void(::std::exception_ptr)> ex = nullptr,
                         ::std::function<void(bool)> sent = nullptr,
                         const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpStringStringDResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.p3));
        };
        return _makeLamdaOutgoing<MyClass::OpStringStringDResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opStringStringD, p1, p2, context);
    }

    /// \cond INTERNAL
    void _iceI_opStringStringD(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpStringStringDResult>>&, const StringStringD&, const StringStringD&, const ::Ice::Context&);
    /// \endcond

    StringMyEnumD opStringMyEnumD(const StringMyEnumD& p1, const StringMyEnumD& p2, StringMyEnumD& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpStringMyEnumDResult>(true, this, &MyClassPrx::_iceI_opStringMyEnumD, p1, p2, context).get();
        p3 = ::std::move(_result.p3);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opStringMyEnumDAsync(const StringMyEnumD& p1, const StringMyEnumD& p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpStringMyEnumDResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpStringMyEnumDResult, P>(false, this, &MyClassPrx::_iceI_opStringMyEnumD, p1, p2, context);
    }

    ::std::function<void()>
    opStringMyEnumDAsync(const StringMyEnumD& p1, const StringMyEnumD& p2,
                         ::std::function<void(::Test::StringMyEnumD, ::Test::StringMyEnumD)> response,
                         ::std::function<void(::std::exception_ptr)> ex = nullptr,
                         ::std::function<void(bool)> sent = nullptr,
                         const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpStringMyEnumDResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.p3));
        };
        return _makeLamdaOutgoing<MyClass::OpStringMyEnumDResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opStringMyEnumD, p1, p2, context);
    }

    /// \cond INTERNAL
    void _iceI_opStringMyEnumD(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpStringMyEnumDResult>>&, const StringMyEnumD&, const StringMyEnumD&, const ::Ice::Context&);
    /// \endcond

    MyEnumStringD opMyEnumStringD(const MyEnumStringD& p1, const MyEnumStringD& p2, MyEnumStringD& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpMyEnumStringDResult>(true, this, &MyClassPrx::_iceI_opMyEnumStringD, p1, p2, context).get();
        p3 = ::std::move(_result.p3);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opMyEnumStringDAsync(const MyEnumStringD& p1, const MyEnumStringD& p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpMyEnumStringDResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpMyEnumStringDResult, P>(false, this, &MyClassPrx::_iceI_opMyEnumStringD, p1, p2, context);
    }

    ::std::function<void()>
    opMyEnumStringDAsync(const MyEnumStringD& p1, const MyEnumStringD& p2,
                         ::std::function<void(::Test::MyEnumStringD, ::Test::MyEnumStringD)> response,
                         ::std::function<void(::std::exception_ptr)> ex = nullptr,
                         ::std::function<void(bool)> sent = nullptr,
                         const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpMyEnumStringDResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.p3));
        };
        return _makeLamdaOutgoing<MyClass::OpMyEnumStringDResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opMyEnumStringD, p1, p2, context);
    }

    /// \cond INTERNAL
    void _iceI_opMyEnumStringD(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpMyEnumStringDResult>>&, const MyEnumStringD&, const MyEnumStringD&, const ::Ice::Context&);
    /// \endcond

    MyStructMyEnumD opMyStructMyEnumD(const MyStructMyEnumD& p1, const MyStructMyEnumD& p2, MyStructMyEnumD& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpMyStructMyEnumDResult>(true, this, &MyClassPrx::_iceI_opMyStructMyEnumD, p1, p2, context).get();
        p3 = ::std::move(_result.p3);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opMyStructMyEnumDAsync(const MyStructMyEnumD& p1, const MyStructMyEnumD& p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpMyStructMyEnumDResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpMyStructMyEnumDResult, P>(false, this, &MyClassPrx::_iceI_opMyStructMyEnumD, p1, p2, context);
    }

    ::std::function<void()>
    opMyStructMyEnumDAsync(const MyStructMyEnumD& p1, const MyStructMyEnumD& p2,
                           ::std::function<void(::Test::MyStructMyEnumD, ::Test::MyStructMyEnumD)> response,
                           ::std::function<void(::std::exception_ptr)> ex = nullptr,
                           ::std::function<void(bool)> sent = nullptr,
                           const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpMyStructMyEnumDResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.p3));
        };
        return _makeLamdaOutgoing<MyClass::OpMyStructMyEnumDResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opMyStructMyEnumD, p1, p2, context);
    }

    /// \cond INTERNAL
    void _iceI_opMyStructMyEnumD(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpMyStructMyEnumDResult>>&, const MyStructMyEnumD&, const MyStructMyEnumD&, const ::Ice::Context&);
    /// \endcond

    ByteBoolDS opByteBoolDS(const ByteBoolDS& p1, const ByteBoolDS& p2, ByteBoolDS& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpByteBoolDSResult>(true, this, &MyClassPrx::_iceI_opByteBoolDS, p1, p2, context).get();
        p3 = ::std::move(_result.p3);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opByteBoolDSAsync(const ByteBoolDS& p1, const ByteBoolDS& p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpByteBoolDSResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpByteBoolDSResult, P>(false, this, &MyClassPrx::_iceI_opByteBoolDS, p1, p2, context);
    }

    ::std::function<void()>
    opByteBoolDSAsync(const ByteBoolDS& p1, const ByteBoolDS& p2,
                      ::std::function<void(::Test::ByteBoolDS, ::Test::ByteBoolDS)> response,
                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                      ::std::function<void(bool)> sent = nullptr,
                      const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpByteBoolDSResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.p3));
        };
        return _makeLamdaOutgoing<MyClass::OpByteBoolDSResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opByteBoolDS, p1, p2, context);
    }

    /// \cond INTERNAL
    void _iceI_opByteBoolDS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpByteBoolDSResult>>&, const ByteBoolDS&, const ByteBoolDS&, const ::Ice::Context&);
    /// \endcond

    ShortIntDS opShortIntDS(const ShortIntDS& p1, const ShortIntDS& p2, ShortIntDS& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpShortIntDSResult>(true, this, &MyClassPrx::_iceI_opShortIntDS, p1, p2, context).get();
        p3 = ::std::move(_result.p3);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opShortIntDSAsync(const ShortIntDS& p1, const ShortIntDS& p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpShortIntDSResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpShortIntDSResult, P>(false, this, &MyClassPrx::_iceI_opShortIntDS, p1, p2, context);
    }

    ::std::function<void()>
    opShortIntDSAsync(const ShortIntDS& p1, const ShortIntDS& p2,
                      ::std::function<void(::Test::ShortIntDS, ::Test::ShortIntDS)> response,
                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                      ::std::function<void(bool)> sent = nullptr,
                      const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpShortIntDSResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.p3));
        };
        return _makeLamdaOutgoing<MyClass::OpShortIntDSResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opShortIntDS, p1, p2, context);
    }

    /// \cond INTERNAL
    void _iceI_opShortIntDS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpShortIntDSResult>>&, const ShortIntDS&, const ShortIntDS&, const ::Ice::Context&);
    /// \endcond

    LongFloatDS opLongFloatDS(const LongFloatDS& p1, const LongFloatDS& p2, LongFloatDS& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpLongFloatDSResult>(true, this, &MyClassPrx::_iceI_opLongFloatDS, p1, p2, context).get();
        p3 = ::std::move(_result.p3);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opLongFloatDSAsync(const LongFloatDS& p1, const LongFloatDS& p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpLongFloatDSResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpLongFloatDSResult, P>(false, this, &MyClassPrx::_iceI_opLongFloatDS, p1, p2, context);
    }

    ::std::function<void()>
    opLongFloatDSAsync(const LongFloatDS& p1, const LongFloatDS& p2,
                       ::std::function<void(::Test::LongFloatDS, ::Test::LongFloatDS)> response,
                       ::std::function<void(::std::exception_ptr)> ex = nullptr,
                       ::std::function<void(bool)> sent = nullptr,
                       const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpLongFloatDSResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.p3));
        };
        return _makeLamdaOutgoing<MyClass::OpLongFloatDSResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opLongFloatDS, p1, p2, context);
    }

    /// \cond INTERNAL
    void _iceI_opLongFloatDS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpLongFloatDSResult>>&, const LongFloatDS&, const LongFloatDS&, const ::Ice::Context&);
    /// \endcond

    StringStringDS opStringStringDS(const StringStringDS& p1, const StringStringDS& p2, StringStringDS& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpStringStringDSResult>(true, this, &MyClassPrx::_iceI_opStringStringDS, p1, p2, context).get();
        p3 = ::std::move(_result.p3);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opStringStringDSAsync(const StringStringDS& p1, const StringStringDS& p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpStringStringDSResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpStringStringDSResult, P>(false, this, &MyClassPrx::_iceI_opStringStringDS, p1, p2, context);
    }

    ::std::function<void()>
    opStringStringDSAsync(const StringStringDS& p1, const StringStringDS& p2,
                          ::std::function<void(::Test::StringStringDS, ::Test::StringStringDS)> response,
                          ::std::function<void(::std::exception_ptr)> ex = nullptr,
                          ::std::function<void(bool)> sent = nullptr,
                          const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpStringStringDSResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.p3));
        };
        return _makeLamdaOutgoing<MyClass::OpStringStringDSResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opStringStringDS, p1, p2, context);
    }

    /// \cond INTERNAL
    void _iceI_opStringStringDS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpStringStringDSResult>>&, const StringStringDS&, const StringStringDS&, const ::Ice::Context&);
    /// \endcond

    StringMyEnumDS opStringMyEnumDS(const StringMyEnumDS& p1, const StringMyEnumDS& p2, StringMyEnumDS& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpStringMyEnumDSResult>(true, this, &MyClassPrx::_iceI_opStringMyEnumDS, p1, p2, context).get();
        p3 = ::std::move(_result.p3);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opStringMyEnumDSAsync(const StringMyEnumDS& p1, const StringMyEnumDS& p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpStringMyEnumDSResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpStringMyEnumDSResult, P>(false, this, &MyClassPrx::_iceI_opStringMyEnumDS, p1, p2, context);
    }

    ::std::function<void()>
    opStringMyEnumDSAsync(const StringMyEnumDS& p1, const StringMyEnumDS& p2,
                          ::std::function<void(::Test::StringMyEnumDS, ::Test::StringMyEnumDS)> response,
                          ::std::function<void(::std::exception_ptr)> ex = nullptr,
                          ::std::function<void(bool)> sent = nullptr,
                          const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpStringMyEnumDSResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.p3));
        };
        return _makeLamdaOutgoing<MyClass::OpStringMyEnumDSResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opStringMyEnumDS, p1, p2, context);
    }

    /// \cond INTERNAL
    void _iceI_opStringMyEnumDS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpStringMyEnumDSResult>>&, const StringMyEnumDS&, const StringMyEnumDS&, const ::Ice::Context&);
    /// \endcond

    MyEnumStringDS opMyEnumStringDS(const MyEnumStringDS& p1, const MyEnumStringDS& p2, MyEnumStringDS& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpMyEnumStringDSResult>(true, this, &MyClassPrx::_iceI_opMyEnumStringDS, p1, p2, context).get();
        p3 = ::std::move(_result.p3);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opMyEnumStringDSAsync(const MyEnumStringDS& p1, const MyEnumStringDS& p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpMyEnumStringDSResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpMyEnumStringDSResult, P>(false, this, &MyClassPrx::_iceI_opMyEnumStringDS, p1, p2, context);
    }

    ::std::function<void()>
    opMyEnumStringDSAsync(const MyEnumStringDS& p1, const MyEnumStringDS& p2,
                          ::std::function<void(::Test::MyEnumStringDS, ::Test::MyEnumStringDS)> response,
                          ::std::function<void(::std::exception_ptr)> ex = nullptr,
                          ::std::function<void(bool)> sent = nullptr,
                          const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpMyEnumStringDSResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.p3));
        };
        return _makeLamdaOutgoing<MyClass::OpMyEnumStringDSResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opMyEnumStringDS, p1, p2, context);
    }

    /// \cond INTERNAL
    void _iceI_opMyEnumStringDS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpMyEnumStringDSResult>>&, const MyEnumStringDS&, const MyEnumStringDS&, const ::Ice::Context&);
    /// \endcond

    MyStructMyEnumDS opMyStructMyEnumDS(const MyStructMyEnumDS& p1, const MyStructMyEnumDS& p2, MyStructMyEnumDS& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpMyStructMyEnumDSResult>(true, this, &MyClassPrx::_iceI_opMyStructMyEnumDS, p1, p2, context).get();
        p3 = ::std::move(_result.p3);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opMyStructMyEnumDSAsync(const MyStructMyEnumDS& p1, const MyStructMyEnumDS& p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpMyStructMyEnumDSResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpMyStructMyEnumDSResult, P>(false, this, &MyClassPrx::_iceI_opMyStructMyEnumDS, p1, p2, context);
    }

    ::std::function<void()>
    opMyStructMyEnumDSAsync(const MyStructMyEnumDS& p1, const MyStructMyEnumDS& p2,
                            ::std::function<void(::Test::MyStructMyEnumDS, ::Test::MyStructMyEnumDS)> response,
                            ::std::function<void(::std::exception_ptr)> ex = nullptr,
                            ::std::function<void(bool)> sent = nullptr,
                            const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpMyStructMyEnumDSResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.p3));
        };
        return _makeLamdaOutgoing<MyClass::OpMyStructMyEnumDSResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opMyStructMyEnumDS, p1, p2, context);
    }

    /// \cond INTERNAL
    void _iceI_opMyStructMyEnumDS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpMyStructMyEnumDSResult>>&, const MyStructMyEnumDS&, const MyStructMyEnumDS&, const ::Ice::Context&);
    /// \endcond

    ByteByteSD opByteByteSD(const ByteByteSD& p1, const ByteByteSD& p2, ByteByteSD& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpByteByteSDResult>(true, this, &MyClassPrx::_iceI_opByteByteSD, p1, p2, context).get();
        p3 = ::std::move(_result.p3);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opByteByteSDAsync(const ByteByteSD& p1, const ByteByteSD& p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpByteByteSDResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpByteByteSDResult, P>(false, this, &MyClassPrx::_iceI_opByteByteSD, p1, p2, context);
    }

    ::std::function<void()>
    opByteByteSDAsync(const ByteByteSD& p1, const ByteByteSD& p2,
                      ::std::function<void(::Test::ByteByteSD, ::Test::ByteByteSD)> response,
                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                      ::std::function<void(bool)> sent = nullptr,
                      const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpByteByteSDResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.p3));
        };
        return _makeLamdaOutgoing<MyClass::OpByteByteSDResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opByteByteSD, p1, p2, context);
    }

    /// \cond INTERNAL
    void _iceI_opByteByteSD(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpByteByteSDResult>>&, const ByteByteSD&, const ByteByteSD&, const ::Ice::Context&);
    /// \endcond

    BoolBoolSD opBoolBoolSD(const BoolBoolSD& p1, const BoolBoolSD& p2, BoolBoolSD& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpBoolBoolSDResult>(true, this, &MyClassPrx::_iceI_opBoolBoolSD, p1, p2, context).get();
        p3 = ::std::move(_result.p3);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opBoolBoolSDAsync(const BoolBoolSD& p1, const BoolBoolSD& p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpBoolBoolSDResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpBoolBoolSDResult, P>(false, this, &MyClassPrx::_iceI_opBoolBoolSD, p1, p2, context);
    }

    ::std::function<void()>
    opBoolBoolSDAsync(const BoolBoolSD& p1, const BoolBoolSD& p2,
                      ::std::function<void(::Test::BoolBoolSD, ::Test::BoolBoolSD)> response,
                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                      ::std::function<void(bool)> sent = nullptr,
                      const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpBoolBoolSDResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.p3));
        };
        return _makeLamdaOutgoing<MyClass::OpBoolBoolSDResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opBoolBoolSD, p1, p2, context);
    }

    /// \cond INTERNAL
    void _iceI_opBoolBoolSD(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpBoolBoolSDResult>>&, const BoolBoolSD&, const BoolBoolSD&, const ::Ice::Context&);
    /// \endcond

    ShortShortSD opShortShortSD(const ShortShortSD& p1, const ShortShortSD& p2, ShortShortSD& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpShortShortSDResult>(true, this, &MyClassPrx::_iceI_opShortShortSD, p1, p2, context).get();
        p3 = ::std::move(_result.p3);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opShortShortSDAsync(const ShortShortSD& p1, const ShortShortSD& p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpShortShortSDResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpShortShortSDResult, P>(false, this, &MyClassPrx::_iceI_opShortShortSD, p1, p2, context);
    }

    ::std::function<void()>
    opShortShortSDAsync(const ShortShortSD& p1, const ShortShortSD& p2,
                        ::std::function<void(::Test::ShortShortSD, ::Test::ShortShortSD)> response,
                        ::std::function<void(::std::exception_ptr)> ex = nullptr,
                        ::std::function<void(bool)> sent = nullptr,
                        const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpShortShortSDResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.p3));
        };
        return _makeLamdaOutgoing<MyClass::OpShortShortSDResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opShortShortSD, p1, p2, context);
    }

    /// \cond INTERNAL
    void _iceI_opShortShortSD(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpShortShortSDResult>>&, const ShortShortSD&, const ShortShortSD&, const ::Ice::Context&);
    /// \endcond

    IntIntSD opIntIntSD(const IntIntSD& p1, const IntIntSD& p2, IntIntSD& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpIntIntSDResult>(true, this, &MyClassPrx::_iceI_opIntIntSD, p1, p2, context).get();
        p3 = ::std::move(_result.p3);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opIntIntSDAsync(const IntIntSD& p1, const IntIntSD& p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpIntIntSDResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpIntIntSDResult, P>(false, this, &MyClassPrx::_iceI_opIntIntSD, p1, p2, context);
    }

    ::std::function<void()>
    opIntIntSDAsync(const IntIntSD& p1, const IntIntSD& p2,
                    ::std::function<void(::Test::IntIntSD, ::Test::IntIntSD)> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpIntIntSDResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.p3));
        };
        return _makeLamdaOutgoing<MyClass::OpIntIntSDResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opIntIntSD, p1, p2, context);
    }

    /// \cond INTERNAL
    void _iceI_opIntIntSD(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpIntIntSDResult>>&, const IntIntSD&, const IntIntSD&, const ::Ice::Context&);
    /// \endcond

    LongLongSD opLongLongSD(const LongLongSD& p1, const LongLongSD& p2, LongLongSD& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpLongLongSDResult>(true, this, &MyClassPrx::_iceI_opLongLongSD, p1, p2, context).get();
        p3 = ::std::move(_result.p3);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opLongLongSDAsync(const LongLongSD& p1, const LongLongSD& p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpLongLongSDResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpLongLongSDResult, P>(false, this, &MyClassPrx::_iceI_opLongLongSD, p1, p2, context);
    }

    ::std::function<void()>
    opLongLongSDAsync(const LongLongSD& p1, const LongLongSD& p2,
                      ::std::function<void(::Test::LongLongSD, ::Test::LongLongSD)> response,
                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                      ::std::function<void(bool)> sent = nullptr,
                      const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpLongLongSDResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.p3));
        };
        return _makeLamdaOutgoing<MyClass::OpLongLongSDResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opLongLongSD, p1, p2, context);
    }

    /// \cond INTERNAL
    void _iceI_opLongLongSD(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpLongLongSDResult>>&, const LongLongSD&, const LongLongSD&, const ::Ice::Context&);
    /// \endcond

    StringFloatSD opStringFloatSD(const StringFloatSD& p1, const StringFloatSD& p2, StringFloatSD& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpStringFloatSDResult>(true, this, &MyClassPrx::_iceI_opStringFloatSD, p1, p2, context).get();
        p3 = ::std::move(_result.p3);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opStringFloatSDAsync(const StringFloatSD& p1, const StringFloatSD& p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpStringFloatSDResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpStringFloatSDResult, P>(false, this, &MyClassPrx::_iceI_opStringFloatSD, p1, p2, context);
    }

    ::std::function<void()>
    opStringFloatSDAsync(const StringFloatSD& p1, const StringFloatSD& p2,
                         ::std::function<void(::Test::StringFloatSD, ::Test::StringFloatSD)> response,
                         ::std::function<void(::std::exception_ptr)> ex = nullptr,
                         ::std::function<void(bool)> sent = nullptr,
                         const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpStringFloatSDResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.p3));
        };
        return _makeLamdaOutgoing<MyClass::OpStringFloatSDResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opStringFloatSD, p1, p2, context);
    }

    /// \cond INTERNAL
    void _iceI_opStringFloatSD(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpStringFloatSDResult>>&, const StringFloatSD&, const StringFloatSD&, const ::Ice::Context&);
    /// \endcond

    StringDoubleSD opStringDoubleSD(const StringDoubleSD& p1, const StringDoubleSD& p2, StringDoubleSD& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpStringDoubleSDResult>(true, this, &MyClassPrx::_iceI_opStringDoubleSD, p1, p2, context).get();
        p3 = ::std::move(_result.p3);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opStringDoubleSDAsync(const StringDoubleSD& p1, const StringDoubleSD& p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpStringDoubleSDResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpStringDoubleSDResult, P>(false, this, &MyClassPrx::_iceI_opStringDoubleSD, p1, p2, context);
    }

    ::std::function<void()>
    opStringDoubleSDAsync(const StringDoubleSD& p1, const StringDoubleSD& p2,
                          ::std::function<void(::Test::StringDoubleSD, ::Test::StringDoubleSD)> response,
                          ::std::function<void(::std::exception_ptr)> ex = nullptr,
                          ::std::function<void(bool)> sent = nullptr,
                          const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpStringDoubleSDResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.p3));
        };
        return _makeLamdaOutgoing<MyClass::OpStringDoubleSDResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opStringDoubleSD, p1, p2, context);
    }

    /// \cond INTERNAL
    void _iceI_opStringDoubleSD(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpStringDoubleSDResult>>&, const StringDoubleSD&, const StringDoubleSD&, const ::Ice::Context&);
    /// \endcond

    StringStringSD opStringStringSD(const StringStringSD& p1, const StringStringSD& p2, StringStringSD& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpStringStringSDResult>(true, this, &MyClassPrx::_iceI_opStringStringSD, p1, p2, context).get();
        p3 = ::std::move(_result.p3);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opStringStringSDAsync(const StringStringSD& p1, const StringStringSD& p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpStringStringSDResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpStringStringSDResult, P>(false, this, &MyClassPrx::_iceI_opStringStringSD, p1, p2, context);
    }

    ::std::function<void()>
    opStringStringSDAsync(const StringStringSD& p1, const StringStringSD& p2,
                          ::std::function<void(::Test::StringStringSD, ::Test::StringStringSD)> response,
                          ::std::function<void(::std::exception_ptr)> ex = nullptr,
                          ::std::function<void(bool)> sent = nullptr,
                          const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpStringStringSDResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.p3));
        };
        return _makeLamdaOutgoing<MyClass::OpStringStringSDResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opStringStringSD, p1, p2, context);
    }

    /// \cond INTERNAL
    void _iceI_opStringStringSD(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpStringStringSDResult>>&, const StringStringSD&, const StringStringSD&, const ::Ice::Context&);
    /// \endcond

    MyEnumMyEnumSD opMyEnumMyEnumSD(const MyEnumMyEnumSD& p1, const MyEnumMyEnumSD& p2, MyEnumMyEnumSD& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpMyEnumMyEnumSDResult>(true, this, &MyClassPrx::_iceI_opMyEnumMyEnumSD, p1, p2, context).get();
        p3 = ::std::move(_result.p3);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opMyEnumMyEnumSDAsync(const MyEnumMyEnumSD& p1, const MyEnumMyEnumSD& p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpMyEnumMyEnumSDResult>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpMyEnumMyEnumSDResult, P>(false, this, &MyClassPrx::_iceI_opMyEnumMyEnumSD, p1, p2, context);
    }

    ::std::function<void()>
    opMyEnumMyEnumSDAsync(const MyEnumMyEnumSD& p1, const MyEnumMyEnumSD& p2,
                          ::std::function<void(::Test::MyEnumMyEnumSD, ::Test::MyEnumMyEnumSD)> response,
                          ::std::function<void(::std::exception_ptr)> ex = nullptr,
                          ::std::function<void(bool)> sent = nullptr,
                          const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpMyEnumMyEnumSDResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.p3));
        };
        return _makeLamdaOutgoing<MyClass::OpMyEnumMyEnumSDResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opMyEnumMyEnumSD, p1, p2, context);
    }

    /// \cond INTERNAL
    void _iceI_opMyEnumMyEnumSD(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpMyEnumMyEnumSDResult>>&, const MyEnumMyEnumSD&, const MyEnumMyEnumSD&, const ::Ice::Context&);
    /// \endcond

    IntS opIntS(const IntS& s, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::Test::IntS>(true, this, &MyClassPrx::_iceI_opIntS, s, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto opIntSAsync(const IntS& s, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::Test::IntS>>().get_future())
    {
        return _makePromiseOutgoing<::Test::IntS, P>(false, this, &MyClassPrx::_iceI_opIntS, s, context);
    }

    ::std::function<void()>
    opIntSAsync(const IntS& s,
                ::std::function<void(::Test::IntS)> response,
                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                ::std::function<void(bool)> sent = nullptr,
                const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::Test::IntS>(std::move(response), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opIntS, s, context);
    }

    /// \cond INTERNAL
    void _iceI_opIntS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::Test::IntS>>&, const IntS&, const ::Ice::Context&);
    /// \endcond

    void opByteSOneway(const ByteS& s, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &MyClassPrx::_iceI_opByteSOneway, s, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto opByteSOnewayAsync(const ByteS& s, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &MyClassPrx::_iceI_opByteSOneway, s, context);
    }

    ::std::function<void()>
    opByteSOnewayAsync(const ByteS& s,
                       ::std::function<void()> response,
                       ::std::function<void(::std::exception_ptr)> ex = nullptr,
                       ::std::function<void(bool)> sent = nullptr,
                       const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opByteSOneway, s, context);
    }

    /// \cond INTERNAL
    void _iceI_opByteSOneway(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ByteS&, const ::Ice::Context&);
    /// \endcond

    int opByteSOnewayCallCount(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<int>(true, this, &MyClassPrx::_iceI_opByteSOnewayCallCount, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto opByteSOnewayCallCountAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<int>>().get_future())
    {
        return _makePromiseOutgoing<int, P>(false, this, &MyClassPrx::_iceI_opByteSOnewayCallCount, context);
    }

    ::std::function<void()>
    opByteSOnewayCallCountAsync(::std::function<void(int)> response,
                                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                                ::std::function<void(bool)> sent = nullptr,
                                const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<int>(std::move(response), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opByteSOnewayCallCount, context);
    }

    /// \cond INTERNAL
    void _iceI_opByteSOnewayCallCount(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<int>>&, const ::Ice::Context&);
    /// \endcond

    ::Ice::Context opContext(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::Ice::Context>(true, this, &MyClassPrx::_iceI_opContext, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto opContextAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::Ice::Context>>().get_future())
    {
        return _makePromiseOutgoing<::Ice::Context, P>(false, this, &MyClassPrx::_iceI_opContext, context);
    }

    ::std::function<void()>
    opContextAsync(::std::function<void(::Ice::Context)> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::Ice::Context>(std::move(response), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opContext, context);
    }

    /// \cond INTERNAL
    void _iceI_opContext(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::Ice::Context>>&, const ::Ice::Context&);
    /// \endcond

    void opDoubleMarshaling(double p1, const DoubleS& p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &MyClassPrx::_iceI_opDoubleMarshaling, p1, p2, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto opDoubleMarshalingAsync(double p1, const DoubleS& p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &MyClassPrx::_iceI_opDoubleMarshaling, p1, p2, context);
    }

    ::std::function<void()>
    opDoubleMarshalingAsync(double p1, const DoubleS& p2,
                            ::std::function<void()> response,
                            ::std::function<void(::std::exception_ptr)> ex = nullptr,
                            ::std::function<void(bool)> sent = nullptr,
                            const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opDoubleMarshaling, p1, p2, context);
    }

    /// \cond INTERNAL
    void _iceI_opDoubleMarshaling(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, double, const DoubleS&, const ::Ice::Context&);
    /// \endcond

    void opIdempotent(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &MyClassPrx::_iceI_opIdempotent, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto opIdempotentAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &MyClassPrx::_iceI_opIdempotent, context);
    }

    ::std::function<void()>
    opIdempotentAsync(::std::function<void()> response,
                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                      ::std::function<void(bool)> sent = nullptr,
                      const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opIdempotent, context);
    }

    /// \cond INTERNAL
    void _iceI_opIdempotent(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    void opNonmutating(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &MyClassPrx::_iceI_opNonmutating, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto opNonmutatingAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &MyClassPrx::_iceI_opNonmutating, context);
    }

    ::std::function<void()>
    opNonmutatingAsync(::std::function<void()> response,
                       ::std::function<void(::std::exception_ptr)> ex = nullptr,
                       ::std::function<void(bool)> sent = nullptr,
                       const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opNonmutating, context);
    }

    /// \cond INTERNAL
    void _iceI_opNonmutating(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    ::Ice::Byte opByte1(::Ice::Byte opByte1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::Ice::Byte>(true, this, &MyClassPrx::_iceI_opByte1, opByte1, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto opByte1Async(::Ice::Byte opByte1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::Ice::Byte>>().get_future())
    {
        return _makePromiseOutgoing<::Ice::Byte, P>(false, this, &MyClassPrx::_iceI_opByte1, opByte1, context);
    }

    ::std::function<void()>
    opByte1Async(::Ice::Byte opByte1,
                 ::std::function<void(::Ice::Byte)> response,
                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                 ::std::function<void(bool)> sent = nullptr,
                 const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::Ice::Byte>(std::move(response), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opByte1, opByte1, context);
    }

    /// \cond INTERNAL
    void _iceI_opByte1(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::Ice::Byte>>&, ::Ice::Byte, const ::Ice::Context&);
    /// \endcond

    short opShort1(short opShort1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<short>(true, this, &MyClassPrx::_iceI_opShort1, opShort1, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto opShort1Async(short opShort1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<short>>().get_future())
    {
        return _makePromiseOutgoing<short, P>(false, this, &MyClassPrx::_iceI_opShort1, opShort1, context);
    }

    ::std::function<void()>
    opShort1Async(short opShort1,
                  ::std::function<void(short)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<short>(std::move(response), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opShort1, opShort1, context);
    }

    /// \cond INTERNAL
    void _iceI_opShort1(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<short>>&, short, const ::Ice::Context&);
    /// \endcond

    int opInt1(int opInt1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<int>(true, this, &MyClassPrx::_iceI_opInt1, opInt1, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto opInt1Async(int opInt1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<int>>().get_future())
    {
        return _makePromiseOutgoing<int, P>(false, this, &MyClassPrx::_iceI_opInt1, opInt1, context);
    }

    ::std::function<void()>
    opInt1Async(int opInt1,
                ::std::function<void(int)> response,
                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                ::std::function<void(bool)> sent = nullptr,
                const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<int>(std::move(response), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opInt1, opInt1, context);
    }

    /// \cond INTERNAL
    void _iceI_opInt1(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<int>>&, int, const ::Ice::Context&);
    /// \endcond

    long long int opLong1(long long int opLong1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<long long int>(true, this, &MyClassPrx::_iceI_opLong1, opLong1, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto opLong1Async(long long int opLong1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<long long int>>().get_future())
    {
        return _makePromiseOutgoing<long long int, P>(false, this, &MyClassPrx::_iceI_opLong1, opLong1, context);
    }

    ::std::function<void()>
    opLong1Async(long long int opLong1,
                 ::std::function<void(long long int)> response,
                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                 ::std::function<void(bool)> sent = nullptr,
                 const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<long long int>(std::move(response), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opLong1, opLong1, context);
    }

    /// \cond INTERNAL
    void _iceI_opLong1(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<long long int>>&, long long int, const ::Ice::Context&);
    /// \endcond

    float opFloat1(float opFloat1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<float>(true, this, &MyClassPrx::_iceI_opFloat1, opFloat1, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto opFloat1Async(float opFloat1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<float>>().get_future())
    {
        return _makePromiseOutgoing<float, P>(false, this, &MyClassPrx::_iceI_opFloat1, opFloat1, context);
    }

    ::std::function<void()>
    opFloat1Async(float opFloat1,
                  ::std::function<void(float)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<float>(std::move(response), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opFloat1, opFloat1, context);
    }

    /// \cond INTERNAL
    void _iceI_opFloat1(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<float>>&, float, const ::Ice::Context&);
    /// \endcond

    double opDouble1(double opDouble1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<double>(true, this, &MyClassPrx::_iceI_opDouble1, opDouble1, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto opDouble1Async(double opDouble1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<double>>().get_future())
    {
        return _makePromiseOutgoing<double, P>(false, this, &MyClassPrx::_iceI_opDouble1, opDouble1, context);
    }

    ::std::function<void()>
    opDouble1Async(double opDouble1,
                   ::std::function<void(double)> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<double>(std::move(response), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opDouble1, opDouble1, context);
    }

    /// \cond INTERNAL
    void _iceI_opDouble1(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<double>>&, double, const ::Ice::Context&);
    /// \endcond

    ::std::string opString1(const ::std::string& opString1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::std::string>(true, this, &MyClassPrx::_iceI_opString1, opString1, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto opString1Async(const ::std::string& opString1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::string>>().get_future())
    {
        return _makePromiseOutgoing<::std::string, P>(false, this, &MyClassPrx::_iceI_opString1, opString1, context);
    }

    ::std::function<void()>
    opString1Async(const ::std::string& opString1,
                   ::std::function<void(::std::string)> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::std::string>(std::move(response), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opString1, opString1, context);
    }

    /// \cond INTERNAL
    void _iceI_opString1(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::string>>&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    StringS opStringS1(const StringS& opStringS1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::Test::StringS>(true, this, &MyClassPrx::_iceI_opStringS1, opStringS1, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto opStringS1Async(const StringS& opStringS1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::Test::StringS>>().get_future())
    {
        return _makePromiseOutgoing<::Test::StringS, P>(false, this, &MyClassPrx::_iceI_opStringS1, opStringS1, context);
    }

    ::std::function<void()>
    opStringS1Async(const StringS& opStringS1,
                    ::std::function<void(::Test::StringS)> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::Test::StringS>(std::move(response), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opStringS1, opStringS1, context);
    }

    /// \cond INTERNAL
    void _iceI_opStringS1(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::Test::StringS>>&, const StringS&, const ::Ice::Context&);
    /// \endcond

    ByteBoolD opByteBoolD1(const ByteBoolD& opByteBoolD1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::Test::ByteBoolD>(true, this, &MyClassPrx::_iceI_opByteBoolD1, opByteBoolD1, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto opByteBoolD1Async(const ByteBoolD& opByteBoolD1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::Test::ByteBoolD>>().get_future())
    {
        return _makePromiseOutgoing<::Test::ByteBoolD, P>(false, this, &MyClassPrx::_iceI_opByteBoolD1, opByteBoolD1, context);
    }

    ::std::function<void()>
    opByteBoolD1Async(const ByteBoolD& opByteBoolD1,
                      ::std::function<void(::Test::ByteBoolD)> response,
                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                      ::std::function<void(bool)> sent = nullptr,
                      const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::Test::ByteBoolD>(std::move(response), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opByteBoolD1, opByteBoolD1, context);
    }

    /// \cond INTERNAL
    void _iceI_opByteBoolD1(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::Test::ByteBoolD>>&, const ByteBoolD&, const ::Ice::Context&);
    /// \endcond

    StringS opStringS2(const StringS& stringS, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::Test::StringS>(true, this, &MyClassPrx::_iceI_opStringS2, stringS, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto opStringS2Async(const StringS& stringS, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::Test::StringS>>().get_future())
    {
        return _makePromiseOutgoing<::Test::StringS, P>(false, this, &MyClassPrx::_iceI_opStringS2, stringS, context);
    }

    ::std::function<void()>
    opStringS2Async(const StringS& stringS,
                    ::std::function<void(::Test::StringS)> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::Test::StringS>(std::move(response), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opStringS2, stringS, context);
    }

    /// \cond INTERNAL
    void _iceI_opStringS2(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::Test::StringS>>&, const StringS&, const ::Ice::Context&);
    /// \endcond

    ByteBoolD opByteBoolD2(const ByteBoolD& byteBoolD, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::Test::ByteBoolD>(true, this, &MyClassPrx::_iceI_opByteBoolD2, byteBoolD, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto opByteBoolD2Async(const ByteBoolD& byteBoolD, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::Test::ByteBoolD>>().get_future())
    {
        return _makePromiseOutgoing<::Test::ByteBoolD, P>(false, this, &MyClassPrx::_iceI_opByteBoolD2, byteBoolD, context);
    }

    ::std::function<void()>
    opByteBoolD2Async(const ByteBoolD& byteBoolD,
                      ::std::function<void(::Test::ByteBoolD)> response,
                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                      ::std::function<void(bool)> sent = nullptr,
                      const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::Test::ByteBoolD>(std::move(response), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opByteBoolD2, byteBoolD, context);
    }

    /// \cond INTERNAL
    void _iceI_opByteBoolD2(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::Test::ByteBoolD>>&, const ByteBoolD&, const ::Ice::Context&);
    /// \endcond

    StringS opStringLiterals(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::Test::StringS>(true, this, &MyClassPrx::_iceI_opStringLiterals, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto opStringLiteralsAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::Test::StringS>>().get_future())
    {
        return _makePromiseOutgoing<::Test::StringS, P>(false, this, &MyClassPrx::_iceI_opStringLiterals, context);
    }

    ::std::function<void()>
    opStringLiteralsAsync(::std::function<void(::Test::StringS)> response,
                          ::std::function<void(::std::exception_ptr)> ex = nullptr,
                          ::std::function<void(bool)> sent = nullptr,
                          const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::Test::StringS>(std::move(response), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opStringLiterals, context);
    }

    /// \cond INTERNAL
    void _iceI_opStringLiterals(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::Test::StringS>>&, const ::Ice::Context&);
    /// \endcond

    WStringS opWStringLiterals(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::Test::WStringS>(true, this, &MyClassPrx::_iceI_opWStringLiterals, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto opWStringLiteralsAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::Test::WStringS>>().get_future())
    {
        return _makePromiseOutgoing<::Test::WStringS, P>(false, this, &MyClassPrx::_iceI_opWStringLiterals, context);
    }

    ::std::function<void()>
    opWStringLiteralsAsync(::std::function<void(::Test::WStringS)> response,
                           ::std::function<void(::std::exception_ptr)> ex = nullptr,
                           ::std::function<void(bool)> sent = nullptr,
                           const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::Test::WStringS>(std::move(response), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opWStringLiterals, context);
    }

    /// \cond INTERNAL
    void _iceI_opWStringLiterals(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::Test::WStringS>>&, const ::Ice::Context&);
    /// \endcond

    Structure opMStruct1(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::Test::Structure>(true, this, &MyClassPrx::_iceI_opMStruct1, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto opMStruct1Async(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::Test::Structure>>().get_future())
    {
        return _makePromiseOutgoing<::Test::Structure, P>(false, this, &MyClassPrx::_iceI_opMStruct1, context);
    }

    ::std::function<void()>
    opMStruct1Async(::std::function<void(::Test::Structure)> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::Test::Structure>(std::move(response), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opMStruct1, context);
    }

    /// \cond INTERNAL
    void _iceI_opMStruct1(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::Test::Structure>>&, const ::Ice::Context&);
    /// \endcond

    Structure opMStruct2(const Structure& p1, Structure& p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpMStruct2Result>(true, this, &MyClassPrx::_iceI_opMStruct2, p1, context).get();
        p2 = ::std::move(_result.p2);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opMStruct2Async(const Structure& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpMStruct2Result>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpMStruct2Result, P>(false, this, &MyClassPrx::_iceI_opMStruct2, p1, context);
    }

    ::std::function<void()>
    opMStruct2Async(const Structure& p1,
                    ::std::function<void(::Test::Structure, ::Test::Structure)> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpMStruct2Result&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.p2));
        };
        return _makeLamdaOutgoing<MyClass::OpMStruct2Result>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opMStruct2, p1, context);
    }

    /// \cond INTERNAL
    void _iceI_opMStruct2(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpMStruct2Result>>&, const Structure&, const ::Ice::Context&);
    /// \endcond

    StringS opMSeq1(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::Test::StringS>(true, this, &MyClassPrx::_iceI_opMSeq1, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto opMSeq1Async(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::Test::StringS>>().get_future())
    {
        return _makePromiseOutgoing<::Test::StringS, P>(false, this, &MyClassPrx::_iceI_opMSeq1, context);
    }

    ::std::function<void()>
    opMSeq1Async(::std::function<void(::Test::StringS)> response,
                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                 ::std::function<void(bool)> sent = nullptr,
                 const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::Test::StringS>(std::move(response), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opMSeq1, context);
    }

    /// \cond INTERNAL
    void _iceI_opMSeq1(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::Test::StringS>>&, const ::Ice::Context&);
    /// \endcond

    StringS opMSeq2(const StringS& p1, StringS& p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpMSeq2Result>(true, this, &MyClassPrx::_iceI_opMSeq2, p1, context).get();
        p2 = ::std::move(_result.p2);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opMSeq2Async(const StringS& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpMSeq2Result>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpMSeq2Result, P>(false, this, &MyClassPrx::_iceI_opMSeq2, p1, context);
    }

    ::std::function<void()>
    opMSeq2Async(const StringS& p1,
                 ::std::function<void(::Test::StringS, ::Test::StringS)> response,
                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                 ::std::function<void(bool)> sent = nullptr,
                 const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpMSeq2Result&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.p2));
        };
        return _makeLamdaOutgoing<MyClass::OpMSeq2Result>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opMSeq2, p1, context);
    }

    /// \cond INTERNAL
    void _iceI_opMSeq2(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpMSeq2Result>>&, const StringS&, const ::Ice::Context&);
    /// \endcond

    StringStringD opMDict1(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::Test::StringStringD>(true, this, &MyClassPrx::_iceI_opMDict1, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto opMDict1Async(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::Test::StringStringD>>().get_future())
    {
        return _makePromiseOutgoing<::Test::StringStringD, P>(false, this, &MyClassPrx::_iceI_opMDict1, context);
    }

    ::std::function<void()>
    opMDict1Async(::std::function<void(::Test::StringStringD)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::Test::StringStringD>(std::move(response), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opMDict1, context);
    }

    /// \cond INTERNAL
    void _iceI_opMDict1(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::Test::StringStringD>>&, const ::Ice::Context&);
    /// \endcond

    StringStringD opMDict2(const StringStringD& p1, StringStringD& p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<MyClass::OpMDict2Result>(true, this, &MyClassPrx::_iceI_opMDict2, p1, context).get();
        p2 = ::std::move(_result.p2);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opMDict2Async(const StringStringD& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<MyClass::OpMDict2Result>>().get_future())
    {
        return _makePromiseOutgoing<MyClass::OpMDict2Result, P>(false, this, &MyClassPrx::_iceI_opMDict2, p1, context);
    }

    ::std::function<void()>
    opMDict2Async(const StringStringD& p1,
                  ::std::function<void(::Test::StringStringD, ::Test::StringStringD)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](MyClass::OpMDict2Result&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.p2));
        };
        return _makeLamdaOutgoing<MyClass::OpMDict2Result>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opMDict2, p1, context);
    }

    /// \cond INTERNAL
    void _iceI_opMDict2(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpMDict2Result>>&, const StringStringD&, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    MyClassPrx() = default;
    friend ::std::shared_ptr<MyClassPrx> IceInternal::createProxy<MyClassPrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

class MyDerivedClassPrx : public virtual ::Ice::Proxy<MyDerivedClassPrx, MyClassPrx>
{
public:

    void opDerived(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &MyDerivedClassPrx::_iceI_opDerived, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto opDerivedAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &MyDerivedClassPrx::_iceI_opDerived, context);
    }

    ::std::function<void()>
    opDerivedAsync(::std::function<void()> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::MyDerivedClassPrx::_iceI_opDerived, context);
    }

    /// \cond INTERNAL
    void _iceI_opDerived(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    ::std::shared_ptr<MyClass1> opMyClass1(const ::std::shared_ptr<MyClass1>& opMyClass1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Test::MyClass1>>(true, this, &MyDerivedClassPrx::_iceI_opMyClass1, opMyClass1, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto opMyClass1Async(const ::std::shared_ptr<MyClass1>& opMyClass1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::shared_ptr<::Test::MyClass1>>>().get_future())
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Test::MyClass1>, P>(false, this, &MyDerivedClassPrx::_iceI_opMyClass1, opMyClass1, context);
    }

    ::std::function<void()>
    opMyClass1Async(const ::std::shared_ptr<MyClass1>& opMyClass1,
                    ::std::function<void(::std::shared_ptr<::Test::MyClass1>)> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::std::shared_ptr<::Test::MyClass1>>(std::move(response), std::move(ex), std::move(sent), this, &Test::MyDerivedClassPrx::_iceI_opMyClass1, opMyClass1, context);
    }

    /// \cond INTERNAL
    void _iceI_opMyClass1(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Test::MyClass1>>>&, const ::std::shared_ptr<MyClass1>&, const ::Ice::Context&);
    /// \endcond

    MyStruct1 opMyStruct1(const MyStruct1& opMyStruct1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::Test::MyStruct1>(true, this, &MyDerivedClassPrx::_iceI_opMyStruct1, opMyStruct1, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto opMyStruct1Async(const MyStruct1& opMyStruct1, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::Test::MyStruct1>>().get_future())
    {
        return _makePromiseOutgoing<::Test::MyStruct1, P>(false, this, &MyDerivedClassPrx::_iceI_opMyStruct1, opMyStruct1, context);
    }

    ::std::function<void()>
    opMyStruct1Async(const MyStruct1& opMyStruct1,
                     ::std::function<void(::Test::MyStruct1)> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::Test::MyStruct1>(std::move(response), std::move(ex), std::move(sent), this, &Test::MyDerivedClassPrx::_iceI_opMyStruct1, opMyStruct1, context);
    }

    /// \cond INTERNAL
    void _iceI_opMyStruct1(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::Test::MyStruct1>>&, const MyStruct1&, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    MyDerivedClassPrx() = default;
    friend ::std::shared_ptr<MyDerivedClassPrx> IceInternal::createProxy<MyDerivedClassPrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

}

namespace Test2
{

/**
 * Makes sure that proxy operations are correctly generated when extending an interface from
 * a different module (ICE-7639).
 */
class MyDerivedClassPrx : public virtual ::Ice::Proxy<MyDerivedClassPrx, ::Test::MyClassPrx>
{
public:

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    MyDerivedClassPrx() = default;
    friend ::std::shared_ptr<MyDerivedClassPrx> IceInternal::createProxy<MyDerivedClassPrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

}

namespace M
{

class IntfPrx : public virtual ::Ice::Proxy<IntfPrx, ::Ice::ObjectPrx>
{
public:

    void opIntf(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &IntfPrx::_iceI_opIntf, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto opIntfAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &IntfPrx::_iceI_opIntf, context);
    }

    ::std::function<void()>
    opIntfAsync(::std::function<void()> response,
                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                ::std::function<void(bool)> sent = nullptr,
                const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &M::IntfPrx::_iceI_opIntf, context);
    }

    /// \cond INTERNAL
    void _iceI_opIntf(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    IntfPrx() = default;
    friend ::std::shared_ptr<IntfPrx> IceInternal::createProxy<IntfPrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

class BPrx : public virtual ::Ice::Proxy<BPrx, IntfPrx>
{
public:

    void opB(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &BPrx::_iceI_opB, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto opBAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &BPrx::_iceI_opB, context);
    }

    ::std::function<void()>
    opBAsync(::std::function<void()> response,
             ::std::function<void(::std::exception_ptr)> ex = nullptr,
             ::std::function<void(bool)> sent = nullptr,
             const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &M::BPrx::_iceI_opB, context);
    }

    /// \cond INTERNAL
    void _iceI_opB(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this class.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    BPrx() = default;
    friend ::std::shared_ptr<BPrx> IceInternal::createProxy<BPrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

}

/// \cond STREAM
namespace Ice
{

template<>
struct StreamableTraits< ::Test::MyEnum>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 2;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits<::Test::AnotherStruct>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::Test::AnotherStruct, S>
{
    static void read(S* istr, ::Test::AnotherStruct& v)
    {
        istr->readAll(v.s);
    }
};

template<>
struct StreamableTraits<::Test::Structure>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 4;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::Test::Structure, S>
{
    static void read(S* istr, ::Test::Structure& v)
    {
        istr->readAll(v.p, v.e, v.s);
    }
};

template<>
struct StreamableTraits<::Test::MyStruct>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 8;
    static const bool fixedLength = true;
};

template<typename S>
struct StreamReader<::Test::MyStruct, S>
{
    static void read(S* istr, ::Test::MyStruct& v)
    {
        istr->readAll(v.i, v.j);
    }
};

template<>
struct StreamableTraits<::Test::MyStruct1>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 4;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::Test::MyStruct1, S>
{
    static void read(S* istr, ::Test::MyStruct1& v)
    {
        istr->readAll(v.tesT, v.myClass, v.myStruct1);
    }
};

template<typename S>
struct StreamReader<::Test::MyClass1, S>
{
    static void read(S* istr, ::Test::MyClass1& v)
    {
        istr->readAll(v.tesT, v.myClass, v.myClass1);
    }
};

}
/// \endcond

/// \cond STREAM
namespace Ice
{

}
/// \endcond

/// \cond STREAM
namespace Ice
{

template<typename S>
struct StreamReader<::M::A, S>
{
    static void read(S* istr, ::M::A& v)
    {
        istr->readAll(v.x);
    }
};

template<typename S>
struct StreamWriter<::M::B, S>
{
    static void write(S*, const ::M::B&)
    {
    }
};

template<typename S>
struct StreamReader<::M::B, S>
{
    static void read(S*, ::M::B&)
    {
    }
};

}
/// \endcond

/// \cond INTERNAL
namespace Test
{

using MyClassPtr = ::std::shared_ptr<MyClass>;
using MyClassPrxPtr = ::std::shared_ptr<MyClassPrx>;

using MyClass1Ptr = ::std::shared_ptr<MyClass1>;

using MyDerivedClassPtr = ::std::shared_ptr<MyDerivedClass>;
using MyDerivedClassPrxPtr = ::std::shared_ptr<MyDerivedClassPrx>;

}
/// \endcond

/// \cond INTERNAL
namespace Test2
{

using MyDerivedClassPtr = ::std::shared_ptr<MyDerivedClass>;
using MyDerivedClassPrxPtr = ::std::shared_ptr<MyDerivedClassPrx>;

}
/// \endcond

/// \cond INTERNAL
namespace M
{

using APtr = ::std::shared_ptr<A>;

using IntfPtr = ::std::shared_ptr<Intf>;
using IntfPrxPtr = ::std::shared_ptr<IntfPrx>;

using BPtr = ::std::shared_ptr<B>;
using BPrxPtr = ::std::shared_ptr<BPrx>;

}
/// \endcond

#else // C++98 mapping

namespace IceProxy
{

namespace Test
{

class MyClass;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< MyClass>&);
::IceProxy::Ice::Object* upCast(MyClass*);
/// \endcond

class MyClass1;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< MyClass1>&);
::IceProxy::Ice::Object* upCast(MyClass1*);
/// \endcond

class MyDerivedClass;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< MyDerivedClass>&);
::IceProxy::Ice::Object* upCast(MyDerivedClass*);
/// \endcond

}

namespace Test2
{

class MyDerivedClass;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< MyDerivedClass>&);
::IceProxy::Ice::Object* upCast(MyDerivedClass*);
/// \endcond

}

namespace M
{

class A;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< A>&);
::IceProxy::Ice::Object* upCast(A*);
/// \endcond

class Intf;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< Intf>&);
::IceProxy::Ice::Object* upCast(Intf*);
/// \endcond

class B;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< B>&);
::IceProxy::Ice::Object* upCast(B*);
/// \endcond

}

}

namespace Test
{

class MyClass;
/// \cond INTERNAL
::Ice::Object* upCast(MyClass*);
/// \endcond
typedef ::IceInternal::Handle< MyClass> MyClassPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::MyClass> MyClassPrx;
typedef MyClassPrx MyClassPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(MyClassPtr&, const ::Ice::ObjectPtr&);
/// \endcond

class MyClass1;
/// \cond INTERNAL
::Ice::Object* upCast(MyClass1*);
/// \endcond
typedef ::IceInternal::Handle< MyClass1> MyClass1Ptr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::MyClass1> MyClass1Prx;
typedef MyClass1Prx MyClass1PrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(MyClass1Ptr&, const ::Ice::ObjectPtr&);
/// \endcond

class MyDerivedClass;
/// \cond INTERNAL
::Ice::Object* upCast(MyDerivedClass*);
/// \endcond
typedef ::IceInternal::Handle< MyDerivedClass> MyDerivedClassPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::MyDerivedClass> MyDerivedClassPrx;
typedef MyDerivedClassPrx MyDerivedClassPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(MyDerivedClassPtr&, const ::Ice::ObjectPtr&);
/// \endcond

}

namespace Test2
{

class MyDerivedClass;
/// \cond INTERNAL
::Ice::Object* upCast(MyDerivedClass*);
/// \endcond
typedef ::IceInternal::Handle< MyDerivedClass> MyDerivedClassPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test2::MyDerivedClass> MyDerivedClassPrx;
typedef MyDerivedClassPrx MyDerivedClassPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(MyDerivedClassPtr&, const ::Ice::ObjectPtr&);
/// \endcond

}

namespace M
{

class A;
/// \cond INTERNAL
::Ice::Object* upCast(A*);
/// \endcond
typedef ::IceInternal::Handle< A> APtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::M::A> APrx;
typedef APrx APrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(APtr&, const ::Ice::ObjectPtr&);
/// \endcond

class Intf;
/// \cond INTERNAL
::Ice::Object* upCast(Intf*);
/// \endcond
typedef ::IceInternal::Handle< Intf> IntfPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::M::Intf> IntfPrx;
typedef IntfPrx IntfPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(IntfPtr&, const ::Ice::ObjectPtr&);
/// \endcond

class B;
/// \cond INTERNAL
::Ice::Object* upCast(B*);
/// \endcond
typedef ::IceInternal::Handle< B> BPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::M::B> BPrx;
typedef BPrx BPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(BPtr&, const ::Ice::ObjectPtr&);
/// \endcond

}

namespace Test
{

enum MyEnum
{
    enum1,
    enum2,
    enum3
};

struct AnotherStruct
{
    ::std::string s;

    bool operator==(const AnotherStruct& rhs_) const
    {
        if(this == &rhs_)
        {
            return true;
        }
        if(s != rhs_.s)
        {
            return false;
        }
        return true;
    }

    bool operator<(const AnotherStruct& rhs_) const
    {
        if(this == &rhs_)
        {
            return false;
        }
        if(s < rhs_.s)
        {
            return true;
        }
        else if(rhs_.s < s)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const AnotherStruct& rhs_) const
    {
        return !operator==(rhs_);
    }
    bool operator<=(const AnotherStruct& rhs_) const
    {
        return operator<(rhs_) || operator==(rhs_);
    }
    bool operator>(const AnotherStruct& rhs_) const
    {
        return !operator<(rhs_) && !operator==(rhs_);
    }
    bool operator>=(const AnotherStruct& rhs_) const
    {
        return !operator<(rhs_);
    }
};

struct Structure
{
    ::Test::MyClassPrx p;
    ::Test::MyEnum e;
    ::Test::AnotherStruct s;
};

typedef ::std::vector< ::Ice::Byte> ByteS;

typedef ::std::vector<bool> BoolS;

typedef ::std::vector< ::Ice::Short> ShortS;

typedef ::std::vector< ::Ice::Int> IntS;

typedef ::std::vector< ::Ice::Long> LongS;

typedef ::std::vector< ::Ice::Float> FloatS;

typedef ::std::vector< ::Ice::Double> DoubleS;

typedef ::std::vector< ::std::string> StringS;

typedef ::std::vector< ::std::wstring> WStringS;

typedef ::std::vector<MyEnum> MyEnumS;

typedef ::std::vector<MyClassPrx> MyClassS;

typedef ::std::vector<ByteS> ByteSS;

typedef ::std::vector<BoolS> BoolSS;

typedef ::std::vector<ShortS> ShortSS;

typedef ::std::vector<IntS> IntSS;

typedef ::std::vector<LongS> LongSS;

typedef ::std::vector<FloatS> FloatSS;

typedef ::std::vector<DoubleS> DoubleSS;

typedef ::std::vector<StringS> StringSS;

typedef ::std::vector<MyEnumS> MyEnumSS;

typedef ::std::vector<MyClassS> MyClassSS;

typedef ::std::vector<StringSS> StringSSS;

struct MyStruct
{
    ::Ice::Int i;
    ::Ice::Int j;

    bool operator==(const MyStruct& rhs_) const
    {
        if(this == &rhs_)
        {
            return true;
        }
        if(i != rhs_.i)
        {
            return false;
        }
        if(j != rhs_.j)
        {
            return false;
        }
        return true;
    }

    bool operator<(const MyStruct& rhs_) const
    {
        if(this == &rhs_)
        {
            return false;
        }
        if(i < rhs_.i)
        {
            return true;
        }
        else if(rhs_.i < i)
        {
            return false;
        }
        if(j < rhs_.j)
        {
            return true;
        }
        else if(rhs_.j < j)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const MyStruct& rhs_) const
    {
        return !operator==(rhs_);
    }
    bool operator<=(const MyStruct& rhs_) const
    {
        return operator<(rhs_) || operator==(rhs_);
    }
    bool operator>(const MyStruct& rhs_) const
    {
        return !operator<(rhs_) && !operator==(rhs_);
    }
    bool operator>=(const MyStruct& rhs_) const
    {
        return !operator<(rhs_);
    }
};

typedef ::std::map< ::Ice::Byte, bool> ByteBoolD;

typedef ::std::map< ::Ice::Short, ::Ice::Int> ShortIntD;

typedef ::std::map< ::Ice::Long, ::Ice::Float> LongFloatD;

typedef ::std::map< ::std::string, ::std::string> StringStringD;

typedef ::std::map< ::std::string, MyEnum> StringMyEnumD;

typedef ::std::map<MyEnum, ::std::string> MyEnumStringD;

typedef ::std::map<MyStruct, MyEnum> MyStructMyEnumD;

typedef ::std::vector<ByteBoolD> ByteBoolDS;

typedef ::std::vector<ShortIntD> ShortIntDS;

typedef ::std::vector<LongFloatD> LongFloatDS;

typedef ::std::vector<StringStringD> StringStringDS;

typedef ::std::vector<StringMyEnumD> StringMyEnumDS;

typedef ::std::vector<MyEnumStringD> MyEnumStringDS;

typedef ::std::vector<MyStructMyEnumD> MyStructMyEnumDS;

typedef ::std::map< ::Ice::Byte, ByteS> ByteByteSD;

typedef ::std::map<bool, BoolS> BoolBoolSD;

typedef ::std::map< ::Ice::Short, ShortS> ShortShortSD;

typedef ::std::map< ::Ice::Int, IntS> IntIntSD;

typedef ::std::map< ::Ice::Long, LongS> LongLongSD;

typedef ::std::map< ::std::string, FloatS> StringFloatSD;

typedef ::std::map< ::std::string, DoubleS> StringDoubleSD;

typedef ::std::map< ::std::string, StringS> StringStringSD;

typedef ::std::map<MyEnum, MyEnumS> MyEnumMyEnumSD;

class SomeException : public ::Ice::UserException
{
public:

    SomeException() {}

#ifdef ICE_CPP11_COMPILER
    SomeException(const SomeException&) = default;
    virtual ~SomeException();
#else
    virtual ~SomeException() throw();
#endif

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    virtual ::std::string ice_id() const;
    /**
     * Polymorphically clones this exception.
     * @return A shallow copy of this exception.
     */
    virtual SomeException* ice_clone() const;
    /**
     * Throws this exception.
     */
    virtual void ice_throw() const;

protected:

    /// \cond STREAM
    virtual void _writeImpl(::Ice::OutputStream*) const;
    virtual void _readImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
static SomeException _iceS_SomeException_init;
/// \endcond

struct MyStruct1
{
    ::std::string tesT;
    ::Test::MyClassPrx myClass;
    ::std::string myStruct1;
};

const ::std::string s0 = "\\";

const ::std::string s1 = "A";

const ::std::string s2 = "Ice";

const ::std::string s3 = "A21";

const ::std::string s4 = "\\u0041 \\U00000041";

const ::std::string s5 = "\303\277";

const ::std::string s6 = "\317\277";

const ::std::string s7 = "\327\260";

const ::std::string s8 = "\360\220\200\200";

const ::std::string s9 = "\360\237\215\214";

const ::std::string s10 = "\340\266\247";

const ::std::string s11 = "\342\202\254\342\202\254\342\202\254";

const ::std::string s12 = "\\101";

const ::std::string sw0 = "\\";

const ::std::string sw1 = "A";

const ::std::string sw2 = "Ice";

const ::std::string sw3 = "A21";

const ::std::string sw4 = "\\u0041 \\U00000041";

const ::std::string sw5 = "\303\277";

const ::std::string sw6 = "\317\277";

const ::std::string sw7 = "\327\260";

const ::std::string sw8 = "\360\220\200\200";

const ::std::string sw9 = "\360\237\215\214";

const ::std::string sw10 = "\340\266\247";

/**
 * \'      single quote    byte 0x27 in ASCII encoding
 * \"      double quote    byte 0x22 in ASCII encoding
 * \?      question mark   byte 0x3f in ASCII encoding
 * \\      backslash       byte 0x5c in ASCII encoding
 * \a      audible bell    byte 0x07 in ASCII encoding
 * \b      backspace       byte 0x08 in ASCII encoding
 * \f      form feed - new page    byte 0x0c in ASCII encoding
 * \n      line feed - new line    byte 0x0a in ASCII encoding
 * \r      carriage return byte 0x0d in ASCII encoding
 * \t      horizontal tab  byte 0x09 in ASCII encoding
 * \v      vertical tab    byte 0x0b in ASCII encoding
 */
const ::std::string ss0 = "'\"\?\\\a\b\f\n\r\t\v\006";

const ::std::string ss1 = "'\"\?\\\a\b\f\n\r\t\v\006";

const ::std::string ss2 = "'\"\?\\\a\b\f\n\r\t\v\006";

const ::std::string ss3 = "\\\\U\\u\\";

const ::std::string ss4 = "\\A\\";

const ::std::string ss5 = "\\u0041\\";

const ::std::string su0 = "\304\250\305\270\303\277\304\200\341\274\200\360\220\206\224\360\220\205\252\360\220\206\230\360\237\215\200\360\237\215\201\360\237\215\202\360\237\215\203";

const ::std::string su1 = "\304\250\305\270\303\277\304\200\341\274\200\360\220\206\224\360\220\205\252\360\220\206\230\360\237\215\200\360\237\215\201\360\237\215\202\360\237\215\203";

const ::std::string su2 = "\304\250\305\270\303\277\304\200\341\274\200\360\220\206\224\360\220\205\252\360\220\206\230\360\237\215\200\360\237\215\201\360\237\215\202\360\237\215\203";

const ::std::wstring ws0 = L"\\";

const ::std::wstring ws1 = L"A";

const ::std::wstring ws2 = L"Ice";

const ::std::wstring ws3 = L"A21";

const ::std::wstring ws4 = L"\\u0041 \\U00000041";

const ::std::wstring ws5 = L"\u00FF";

const ::std::wstring ws6 = L"\u03FF";

const ::std::wstring ws7 = L"\u05F0";

const ::std::wstring ws8 = L"\U00010000";

const ::std::wstring ws9 = L"\U0001F34C";

const ::std::wstring ws10 = L"\u0DA7";

const ::std::wstring wsw0 = L"\\";

const ::std::wstring wsw1 = L"A";

const ::std::wstring wsw2 = L"Ice";

const ::std::wstring wsw3 = L"A21";

const ::std::wstring wsw4 = L"\\u0041 \\U00000041";

const ::std::wstring wsw5 = L"\U000000FF";

const ::std::wstring wsw6 = L"\U000003FF";

const ::std::wstring wsw7 = L"\U000005F0";

const ::std::wstring wsw8 = L"\U00010000";

const ::std::wstring wsw9 = L"\U0001F34C";

const ::std::wstring wsw10 = L"\U00000DA7";

/**
 * \'      single quote    byte 0x27 in ASCII encoding
 * \"      double quote    byte 0x22 in ASCII encoding
 * \?      question mark   byte 0x3f in ASCII encoding
 * \\      backslash       byte 0x5c in ASCII encoding
 * \a      audible bell    byte 0x07 in ASCII encoding
 * \b      backspace       byte 0x08 in ASCII encoding
 * \f      form feed - new page    byte 0x0c in ASCII encoding
 * \n      line feed - new line    byte 0x0a in ASCII encoding
 * \r      carriage return byte 0x0d in ASCII encoding
 * \t      horizontal tab  byte 0x09 in ASCII encoding
 * \v      vertical tab    byte 0x0b in ASCII encoding
 */
const ::std::wstring wss0 = L"'\"\?\\\a\b\f\n\r\t\v\006";

const ::std::wstring wss1 = L"'\"\?\\\a\b\f\n\r\t\v\006";

const ::std::wstring wss2 = L"'\"\?\\\a\b\f\n\r\t\v\006";

const ::std::wstring wss3 = L"\\\\U\\u\\";

const ::std::wstring wss4 = L"\\A\\";

const ::std::wstring wss5 = L"\\u0041\\";

const ::std::wstring wsu0 = L"\u0128\u0178\u00ff\u0100\u1f00\U00010194\U0001016a\U00010198\U0001f340\U0001f341\U0001f342\U0001f343";

const ::std::wstring wsu1 = L"\u0128\u0178\u00FF\u0100\u1F00\U00010194\U0001016A\U00010198\U0001F340\U0001F341\U0001F342\U0001F343";

const ::std::wstring wsu2 = L"\U00000128\U00000178\U000000FF\U00000100\U00001F00\U00010194\U0001016A\U00010198\U0001F340\U0001F341\U0001F342\U0001F343";

}

namespace Test
{

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_shutdown.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_shutdown.
 */
class Callback_MyClass_shutdown_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_shutdown_Base> Callback_MyClass_shutdownPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_supportsCompress.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_supportsCompress.
 */
class Callback_MyClass_supportsCompress_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_supportsCompress_Base> Callback_MyClass_supportsCompressPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opVoid.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opVoid.
 */
class Callback_MyClass_opVoid_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opVoid_Base> Callback_MyClass_opVoidPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opByte.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opByte.
 */
class Callback_MyClass_opByte_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opByte_Base> Callback_MyClass_opBytePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opBool.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opBool.
 */
class Callback_MyClass_opBool_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opBool_Base> Callback_MyClass_opBoolPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opShortIntLong.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opShortIntLong.
 */
class Callback_MyClass_opShortIntLong_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opShortIntLong_Base> Callback_MyClass_opShortIntLongPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opFloatDouble.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opFloatDouble.
 */
class Callback_MyClass_opFloatDouble_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opFloatDouble_Base> Callback_MyClass_opFloatDoublePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opString.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opString.
 */
class Callback_MyClass_opString_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opString_Base> Callback_MyClass_opStringPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opMyEnum.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opMyEnum.
 */
class Callback_MyClass_opMyEnum_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opMyEnum_Base> Callback_MyClass_opMyEnumPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opMyClass.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opMyClass.
 */
class Callback_MyClass_opMyClass_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opMyClass_Base> Callback_MyClass_opMyClassPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opStruct.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opStruct.
 */
class Callback_MyClass_opStruct_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opStruct_Base> Callback_MyClass_opStructPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opByteS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opByteS.
 */
class Callback_MyClass_opByteS_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opByteS_Base> Callback_MyClass_opByteSPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opBoolS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opBoolS.
 */
class Callback_MyClass_opBoolS_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opBoolS_Base> Callback_MyClass_opBoolSPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opShortIntLongS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opShortIntLongS.
 */
class Callback_MyClass_opShortIntLongS_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opShortIntLongS_Base> Callback_MyClass_opShortIntLongSPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opFloatDoubleS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opFloatDoubleS.
 */
class Callback_MyClass_opFloatDoubleS_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opFloatDoubleS_Base> Callback_MyClass_opFloatDoubleSPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opStringS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opStringS.
 */
class Callback_MyClass_opStringS_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opStringS_Base> Callback_MyClass_opStringSPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opByteSS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opByteSS.
 */
class Callback_MyClass_opByteSS_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opByteSS_Base> Callback_MyClass_opByteSSPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opBoolSS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opBoolSS.
 */
class Callback_MyClass_opBoolSS_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opBoolSS_Base> Callback_MyClass_opBoolSSPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opShortIntLongSS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opShortIntLongSS.
 */
class Callback_MyClass_opShortIntLongSS_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opShortIntLongSS_Base> Callback_MyClass_opShortIntLongSSPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opFloatDoubleSS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opFloatDoubleSS.
 */
class Callback_MyClass_opFloatDoubleSS_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opFloatDoubleSS_Base> Callback_MyClass_opFloatDoubleSSPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opStringSS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opStringSS.
 */
class Callback_MyClass_opStringSS_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opStringSS_Base> Callback_MyClass_opStringSSPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opStringSSS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opStringSSS.
 */
class Callback_MyClass_opStringSSS_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opStringSSS_Base> Callback_MyClass_opStringSSSPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opByteBoolD.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opByteBoolD.
 */
class Callback_MyClass_opByteBoolD_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opByteBoolD_Base> Callback_MyClass_opByteBoolDPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opShortIntD.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opShortIntD.
 */
class Callback_MyClass_opShortIntD_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opShortIntD_Base> Callback_MyClass_opShortIntDPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opLongFloatD.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opLongFloatD.
 */
class Callback_MyClass_opLongFloatD_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opLongFloatD_Base> Callback_MyClass_opLongFloatDPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opStringStringD.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opStringStringD.
 */
class Callback_MyClass_opStringStringD_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opStringStringD_Base> Callback_MyClass_opStringStringDPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opStringMyEnumD.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opStringMyEnumD.
 */
class Callback_MyClass_opStringMyEnumD_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opStringMyEnumD_Base> Callback_MyClass_opStringMyEnumDPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opMyEnumStringD.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opMyEnumStringD.
 */
class Callback_MyClass_opMyEnumStringD_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opMyEnumStringD_Base> Callback_MyClass_opMyEnumStringDPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opMyStructMyEnumD.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opMyStructMyEnumD.
 */
class Callback_MyClass_opMyStructMyEnumD_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opMyStructMyEnumD_Base> Callback_MyClass_opMyStructMyEnumDPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opByteBoolDS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opByteBoolDS.
 */
class Callback_MyClass_opByteBoolDS_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opByteBoolDS_Base> Callback_MyClass_opByteBoolDSPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opShortIntDS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opShortIntDS.
 */
class Callback_MyClass_opShortIntDS_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opShortIntDS_Base> Callback_MyClass_opShortIntDSPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opLongFloatDS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opLongFloatDS.
 */
class Callback_MyClass_opLongFloatDS_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opLongFloatDS_Base> Callback_MyClass_opLongFloatDSPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opStringStringDS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opStringStringDS.
 */
class Callback_MyClass_opStringStringDS_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opStringStringDS_Base> Callback_MyClass_opStringStringDSPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opStringMyEnumDS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opStringMyEnumDS.
 */
class Callback_MyClass_opStringMyEnumDS_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opStringMyEnumDS_Base> Callback_MyClass_opStringMyEnumDSPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opMyEnumStringDS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opMyEnumStringDS.
 */
class Callback_MyClass_opMyEnumStringDS_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opMyEnumStringDS_Base> Callback_MyClass_opMyEnumStringDSPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opMyStructMyEnumDS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opMyStructMyEnumDS.
 */
class Callback_MyClass_opMyStructMyEnumDS_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opMyStructMyEnumDS_Base> Callback_MyClass_opMyStructMyEnumDSPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opByteByteSD.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opByteByteSD.
 */
class Callback_MyClass_opByteByteSD_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opByteByteSD_Base> Callback_MyClass_opByteByteSDPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opBoolBoolSD.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opBoolBoolSD.
 */
class Callback_MyClass_opBoolBoolSD_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opBoolBoolSD_Base> Callback_MyClass_opBoolBoolSDPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opShortShortSD.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opShortShortSD.
 */
class Callback_MyClass_opShortShortSD_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opShortShortSD_Base> Callback_MyClass_opShortShortSDPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opIntIntSD.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opIntIntSD.
 */
class Callback_MyClass_opIntIntSD_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opIntIntSD_Base> Callback_MyClass_opIntIntSDPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opLongLongSD.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opLongLongSD.
 */
class Callback_MyClass_opLongLongSD_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opLongLongSD_Base> Callback_MyClass_opLongLongSDPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opStringFloatSD.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opStringFloatSD.
 */
class Callback_MyClass_opStringFloatSD_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opStringFloatSD_Base> Callback_MyClass_opStringFloatSDPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opStringDoubleSD.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opStringDoubleSD.
 */
class Callback_MyClass_opStringDoubleSD_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opStringDoubleSD_Base> Callback_MyClass_opStringDoubleSDPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opStringStringSD.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opStringStringSD.
 */
class Callback_MyClass_opStringStringSD_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opStringStringSD_Base> Callback_MyClass_opStringStringSDPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opMyEnumMyEnumSD.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opMyEnumMyEnumSD.
 */
class Callback_MyClass_opMyEnumMyEnumSD_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opMyEnumMyEnumSD_Base> Callback_MyClass_opMyEnumMyEnumSDPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opIntS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opIntS.
 */
class Callback_MyClass_opIntS_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opIntS_Base> Callback_MyClass_opIntSPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opByteSOneway.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opByteSOneway.
 */
class Callback_MyClass_opByteSOneway_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opByteSOneway_Base> Callback_MyClass_opByteSOnewayPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opByteSOnewayCallCount.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opByteSOnewayCallCount.
 */
class Callback_MyClass_opByteSOnewayCallCount_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opByteSOnewayCallCount_Base> Callback_MyClass_opByteSOnewayCallCountPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opContext.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opContext.
 */
class Callback_MyClass_opContext_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opContext_Base> Callback_MyClass_opContextPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opDoubleMarshaling.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opDoubleMarshaling.
 */
class Callback_MyClass_opDoubleMarshaling_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opDoubleMarshaling_Base> Callback_MyClass_opDoubleMarshalingPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opIdempotent.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opIdempotent.
 */
class Callback_MyClass_opIdempotent_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opIdempotent_Base> Callback_MyClass_opIdempotentPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opNonmutating.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opNonmutating.
 */
class Callback_MyClass_opNonmutating_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opNonmutating_Base> Callback_MyClass_opNonmutatingPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opByte1.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opByte1.
 */
class Callback_MyClass_opByte1_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opByte1_Base> Callback_MyClass_opByte1Ptr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opShort1.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opShort1.
 */
class Callback_MyClass_opShort1_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opShort1_Base> Callback_MyClass_opShort1Ptr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opInt1.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opInt1.
 */
class Callback_MyClass_opInt1_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opInt1_Base> Callback_MyClass_opInt1Ptr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opLong1.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opLong1.
 */
class Callback_MyClass_opLong1_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opLong1_Base> Callback_MyClass_opLong1Ptr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opFloat1.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opFloat1.
 */
class Callback_MyClass_opFloat1_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opFloat1_Base> Callback_MyClass_opFloat1Ptr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opDouble1.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opDouble1.
 */
class Callback_MyClass_opDouble1_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opDouble1_Base> Callback_MyClass_opDouble1Ptr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opString1.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opString1.
 */
class Callback_MyClass_opString1_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opString1_Base> Callback_MyClass_opString1Ptr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opStringS1.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opStringS1.
 */
class Callback_MyClass_opStringS1_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opStringS1_Base> Callback_MyClass_opStringS1Ptr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opByteBoolD1.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opByteBoolD1.
 */
class Callback_MyClass_opByteBoolD1_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opByteBoolD1_Base> Callback_MyClass_opByteBoolD1Ptr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opStringS2.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opStringS2.
 */
class Callback_MyClass_opStringS2_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opStringS2_Base> Callback_MyClass_opStringS2Ptr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opByteBoolD2.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opByteBoolD2.
 */
class Callback_MyClass_opByteBoolD2_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opByteBoolD2_Base> Callback_MyClass_opByteBoolD2Ptr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opStringLiterals.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opStringLiterals.
 */
class Callback_MyClass_opStringLiterals_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opStringLiterals_Base> Callback_MyClass_opStringLiteralsPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opWStringLiterals.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opWStringLiterals.
 */
class Callback_MyClass_opWStringLiterals_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opWStringLiterals_Base> Callback_MyClass_opWStringLiteralsPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opMStruct1.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opMStruct1.
 */
class Callback_MyClass_opMStruct1_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opMStruct1_Base> Callback_MyClass_opMStruct1Ptr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opMStruct2.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opMStruct2.
 */
class Callback_MyClass_opMStruct2_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opMStruct2_Base> Callback_MyClass_opMStruct2Ptr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opMSeq1.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opMSeq1.
 */
class Callback_MyClass_opMSeq1_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opMSeq1_Base> Callback_MyClass_opMSeq1Ptr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opMSeq2.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opMSeq2.
 */
class Callback_MyClass_opMSeq2_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opMSeq2_Base> Callback_MyClass_opMSeq2Ptr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opMDict1.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opMDict1.
 */
class Callback_MyClass_opMDict1_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opMDict1_Base> Callback_MyClass_opMDict1Ptr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyClass::begin_opMDict2.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opMDict2.
 */
class Callback_MyClass_opMDict2_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyClass_opMDict2_Base> Callback_MyClass_opMDict2Ptr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyDerivedClass::begin_opDerived.
 * Create a wrapper instance by calling ::Test::newCallback_MyDerivedClass_opDerived.
 */
class Callback_MyDerivedClass_opDerived_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyDerivedClass_opDerived_Base> Callback_MyDerivedClass_opDerivedPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyDerivedClass::begin_opMyClass1.
 * Create a wrapper instance by calling ::Test::newCallback_MyDerivedClass_opMyClass1.
 */
class Callback_MyDerivedClass_opMyClass1_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyDerivedClass_opMyClass1_Base> Callback_MyDerivedClass_opMyClass1Ptr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::MyDerivedClass::begin_opMyStruct1.
 * Create a wrapper instance by calling ::Test::newCallback_MyDerivedClass_opMyStruct1.
 */
class Callback_MyDerivedClass_opMyStruct1_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_MyDerivedClass_opMyStruct1_Base> Callback_MyDerivedClass_opMyStruct1Ptr;

}

namespace Test2
{

}

namespace M
{

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::M::Intf::begin_opIntf.
 * Create a wrapper instance by calling ::M::newCallback_Intf_opIntf.
 */
class Callback_Intf_opIntf_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Intf_opIntf_Base> Callback_Intf_opIntfPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::M::B::begin_opB.
 * Create a wrapper instance by calling ::M::newCallback_B_opB.
 */
class Callback_B_opB_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_B_opB_Base> Callback_B_opBPtr;

}

namespace IceProxy
{

namespace Test
{

class MyClass : public virtual ::Ice::Proxy<MyClass, ::IceProxy::Ice::Object>
{
public:

    void shutdown(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_shutdown(_iceI_begin_shutdown(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_shutdown(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_shutdown(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_shutdown(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_shutdown(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_shutdown(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_shutdown(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_shutdown(const ::Test::Callback_MyClass_shutdownPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_shutdown(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_shutdown(const ::Ice::Context& context, const ::Test::Callback_MyClass_shutdownPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_shutdown(context, cb, cookie);
    }

    void end_shutdown(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_shutdown(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    bool supportsCompress(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_supportsCompress(_iceI_begin_supportsCompress(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_supportsCompress(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_supportsCompress(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_supportsCompress(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_supportsCompress(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_supportsCompress(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_supportsCompress(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_supportsCompress(const ::Test::Callback_MyClass_supportsCompressPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_supportsCompress(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_supportsCompress(const ::Ice::Context& context, const ::Test::Callback_MyClass_supportsCompressPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_supportsCompress(context, cb, cookie);
    }

    bool end_supportsCompress(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_supportsCompress(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void opVoid(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_opVoid(_iceI_begin_opVoid(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opVoid(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opVoid(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opVoid(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opVoid(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opVoid(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opVoid(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opVoid(const ::Test::Callback_MyClass_opVoidPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opVoid(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opVoid(const ::Ice::Context& context, const ::Test::Callback_MyClass_opVoidPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opVoid(context, cb, cookie);
    }

    void end_opVoid(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_opVoid(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Ice::Byte opByte(::Ice::Byte p1, ::Ice::Byte p2, ::Ice::Byte& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opByte(p3, _iceI_begin_opByte(p1, p2, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opByte(::Ice::Byte p1, ::Ice::Byte p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opByte(p1, p2, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opByte(::Ice::Byte p1, ::Ice::Byte p2, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByte(p1, p2, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opByte(::Ice::Byte p1, ::Ice::Byte p2, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByte(p1, p2, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opByte(::Ice::Byte p1, ::Ice::Byte p2, const ::Test::Callback_MyClass_opBytePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByte(p1, p2, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opByte(::Ice::Byte p1, ::Ice::Byte p2, const ::Ice::Context& context, const ::Test::Callback_MyClass_opBytePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByte(p1, p2, context, cb, cookie);
    }

    ::Ice::Byte end_opByte(::Ice::Byte& p3, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opByte(::Ice::Byte& iceP_p3, ::Ice::Byte& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opByte(::Ice::Byte, ::Ice::Byte, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    bool opBool(bool p1, bool p2, bool& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opBool(p3, _iceI_begin_opBool(p1, p2, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opBool(bool p1, bool p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opBool(p1, p2, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opBool(bool p1, bool p2, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opBool(p1, p2, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opBool(bool p1, bool p2, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opBool(p1, p2, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opBool(bool p1, bool p2, const ::Test::Callback_MyClass_opBoolPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opBool(p1, p2, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opBool(bool p1, bool p2, const ::Ice::Context& context, const ::Test::Callback_MyClass_opBoolPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opBool(p1, p2, context, cb, cookie);
    }

    bool end_opBool(bool& p3, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opBool(bool& iceP_p3, bool& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opBool(bool, bool, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Ice::Long opShortIntLong(::Ice::Short p1, ::Ice::Int p2, ::Ice::Long p3, ::Ice::Short& p4, ::Ice::Int& p5, ::Ice::Long& p6, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opShortIntLong(p4, p5, p6, _iceI_begin_opShortIntLong(p1, p2, p3, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opShortIntLong(::Ice::Short p1, ::Ice::Int p2, ::Ice::Long p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opShortIntLong(p1, p2, p3, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opShortIntLong(::Ice::Short p1, ::Ice::Int p2, ::Ice::Long p3, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opShortIntLong(p1, p2, p3, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opShortIntLong(::Ice::Short p1, ::Ice::Int p2, ::Ice::Long p3, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opShortIntLong(p1, p2, p3, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opShortIntLong(::Ice::Short p1, ::Ice::Int p2, ::Ice::Long p3, const ::Test::Callback_MyClass_opShortIntLongPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opShortIntLong(p1, p2, p3, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opShortIntLong(::Ice::Short p1, ::Ice::Int p2, ::Ice::Long p3, const ::Ice::Context& context, const ::Test::Callback_MyClass_opShortIntLongPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opShortIntLong(p1, p2, p3, context, cb, cookie);
    }

    ::Ice::Long end_opShortIntLong(::Ice::Short& p4, ::Ice::Int& p5, ::Ice::Long& p6, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opShortIntLong(::Ice::Short& iceP_p4, ::Ice::Int& iceP_p5, ::Ice::Long& iceP_p6, ::Ice::Long& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opShortIntLong(::Ice::Short, ::Ice::Int, ::Ice::Long, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Ice::Double opFloatDouble(::Ice::Float p1, ::Ice::Double p2, ::Ice::Float& p3, ::Ice::Double& p4, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opFloatDouble(p3, p4, _iceI_begin_opFloatDouble(p1, p2, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opFloatDouble(::Ice::Float p1, ::Ice::Double p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opFloatDouble(p1, p2, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opFloatDouble(::Ice::Float p1, ::Ice::Double p2, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opFloatDouble(p1, p2, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opFloatDouble(::Ice::Float p1, ::Ice::Double p2, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opFloatDouble(p1, p2, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opFloatDouble(::Ice::Float p1, ::Ice::Double p2, const ::Test::Callback_MyClass_opFloatDoublePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opFloatDouble(p1, p2, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opFloatDouble(::Ice::Float p1, ::Ice::Double p2, const ::Ice::Context& context, const ::Test::Callback_MyClass_opFloatDoublePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opFloatDouble(p1, p2, context, cb, cookie);
    }

    ::Ice::Double end_opFloatDouble(::Ice::Float& p3, ::Ice::Double& p4, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opFloatDouble(::Ice::Float& iceP_p3, ::Ice::Double& iceP_p4, ::Ice::Double& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opFloatDouble(::Ice::Float, ::Ice::Double, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::std::string opString(const ::std::string& p1, const ::std::string& p2, ::std::string& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opString(p3, _iceI_begin_opString(p1, p2, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opString(const ::std::string& p1, const ::std::string& p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opString(p1, p2, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opString(const ::std::string& p1, const ::std::string& p2, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opString(p1, p2, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opString(const ::std::string& p1, const ::std::string& p2, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opString(p1, p2, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opString(const ::std::string& p1, const ::std::string& p2, const ::Test::Callback_MyClass_opStringPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opString(p1, p2, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opString(const ::std::string& p1, const ::std::string& p2, const ::Ice::Context& context, const ::Test::Callback_MyClass_opStringPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opString(p1, p2, context, cb, cookie);
    }

    ::std::string end_opString(::std::string& p3, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opString(::std::string& iceP_p3, ::std::string& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opString(const ::std::string&, const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::MyEnum opMyEnum(::Test::MyEnum p1, ::Test::MyEnum& p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opMyEnum(p2, _iceI_begin_opMyEnum(p1, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opMyEnum(::Test::MyEnum p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opMyEnum(p1, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opMyEnum(::Test::MyEnum p1, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opMyEnum(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opMyEnum(::Test::MyEnum p1, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opMyEnum(p1, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opMyEnum(::Test::MyEnum p1, const ::Test::Callback_MyClass_opMyEnumPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opMyEnum(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opMyEnum(::Test::MyEnum p1, const ::Ice::Context& context, const ::Test::Callback_MyClass_opMyEnumPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opMyEnum(p1, context, cb, cookie);
    }

    ::Test::MyEnum end_opMyEnum(::Test::MyEnum& p2, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opMyEnum(::Test::MyEnum& iceP_p2, ::Test::MyEnum& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opMyEnum(::Test::MyEnum, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::MyClassPrx opMyClass(const ::Test::MyClassPrx& p1, ::Test::MyClassPrx& p2, ::Test::MyClassPrx& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opMyClass(p2, p3, _iceI_begin_opMyClass(p1, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opMyClass(const ::Test::MyClassPrx& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opMyClass(p1, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opMyClass(const ::Test::MyClassPrx& p1, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opMyClass(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opMyClass(const ::Test::MyClassPrx& p1, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opMyClass(p1, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opMyClass(const ::Test::MyClassPrx& p1, const ::Test::Callback_MyClass_opMyClassPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opMyClass(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opMyClass(const ::Test::MyClassPrx& p1, const ::Ice::Context& context, const ::Test::Callback_MyClass_opMyClassPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opMyClass(p1, context, cb, cookie);
    }

    ::Test::MyClassPrx end_opMyClass(::Test::MyClassPrx& p2, ::Test::MyClassPrx& p3, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opMyClass(::Test::MyClassPrx& iceP_p2, ::Test::MyClassPrx& iceP_p3, ::Test::MyClassPrx& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opMyClass(const ::Test::MyClassPrx&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::Structure opStruct(const ::Test::Structure& p1, const ::Test::Structure& p2, ::Test::Structure& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opStruct(p3, _iceI_begin_opStruct(p1, p2, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opStruct(const ::Test::Structure& p1, const ::Test::Structure& p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opStruct(p1, p2, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opStruct(const ::Test::Structure& p1, const ::Test::Structure& p2, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStruct(p1, p2, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opStruct(const ::Test::Structure& p1, const ::Test::Structure& p2, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStruct(p1, p2, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opStruct(const ::Test::Structure& p1, const ::Test::Structure& p2, const ::Test::Callback_MyClass_opStructPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStruct(p1, p2, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opStruct(const ::Test::Structure& p1, const ::Test::Structure& p2, const ::Ice::Context& context, const ::Test::Callback_MyClass_opStructPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStruct(p1, p2, context, cb, cookie);
    }

    ::Test::Structure end_opStruct(::Test::Structure& p3, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opStruct(::Test::Structure& iceP_p3, ::Test::Structure& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opStruct(const ::Test::Structure&, const ::Test::Structure&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::ByteS opByteS(const ::Test::ByteS& p1, const ::Test::ByteS& p2, ::Test::ByteS& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opByteS(p3, _iceI_begin_opByteS(p1, p2, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opByteS(const ::Test::ByteS& p1, const ::Test::ByteS& p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opByteS(p1, p2, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opByteS(const ::Test::ByteS& p1, const ::Test::ByteS& p2, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByteS(p1, p2, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opByteS(const ::Test::ByteS& p1, const ::Test::ByteS& p2, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByteS(p1, p2, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opByteS(const ::Test::ByteS& p1, const ::Test::ByteS& p2, const ::Test::Callback_MyClass_opByteSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByteS(p1, p2, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opByteS(const ::Test::ByteS& p1, const ::Test::ByteS& p2, const ::Ice::Context& context, const ::Test::Callback_MyClass_opByteSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByteS(p1, p2, context, cb, cookie);
    }

    ::Test::ByteS end_opByteS(::Test::ByteS& p3, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opByteS(::Test::ByteS& iceP_p3, ::Test::ByteS& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opByteS(const ::Test::ByteS&, const ::Test::ByteS&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::BoolS opBoolS(const ::Test::BoolS& p1, const ::Test::BoolS& p2, ::Test::BoolS& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opBoolS(p3, _iceI_begin_opBoolS(p1, p2, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opBoolS(const ::Test::BoolS& p1, const ::Test::BoolS& p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opBoolS(p1, p2, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opBoolS(const ::Test::BoolS& p1, const ::Test::BoolS& p2, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opBoolS(p1, p2, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opBoolS(const ::Test::BoolS& p1, const ::Test::BoolS& p2, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opBoolS(p1, p2, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opBoolS(const ::Test::BoolS& p1, const ::Test::BoolS& p2, const ::Test::Callback_MyClass_opBoolSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opBoolS(p1, p2, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opBoolS(const ::Test::BoolS& p1, const ::Test::BoolS& p2, const ::Ice::Context& context, const ::Test::Callback_MyClass_opBoolSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opBoolS(p1, p2, context, cb, cookie);
    }

    ::Test::BoolS end_opBoolS(::Test::BoolS& p3, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opBoolS(::Test::BoolS& iceP_p3, ::Test::BoolS& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opBoolS(const ::Test::BoolS&, const ::Test::BoolS&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::LongS opShortIntLongS(const ::Test::ShortS& p1, const ::Test::IntS& p2, const ::Test::LongS& p3, ::Test::ShortS& p4, ::Test::IntS& p5, ::Test::LongS& p6, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opShortIntLongS(p4, p5, p6, _iceI_begin_opShortIntLongS(p1, p2, p3, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opShortIntLongS(const ::Test::ShortS& p1, const ::Test::IntS& p2, const ::Test::LongS& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opShortIntLongS(p1, p2, p3, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opShortIntLongS(const ::Test::ShortS& p1, const ::Test::IntS& p2, const ::Test::LongS& p3, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opShortIntLongS(p1, p2, p3, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opShortIntLongS(const ::Test::ShortS& p1, const ::Test::IntS& p2, const ::Test::LongS& p3, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opShortIntLongS(p1, p2, p3, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opShortIntLongS(const ::Test::ShortS& p1, const ::Test::IntS& p2, const ::Test::LongS& p3, const ::Test::Callback_MyClass_opShortIntLongSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opShortIntLongS(p1, p2, p3, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opShortIntLongS(const ::Test::ShortS& p1, const ::Test::IntS& p2, const ::Test::LongS& p3, const ::Ice::Context& context, const ::Test::Callback_MyClass_opShortIntLongSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opShortIntLongS(p1, p2, p3, context, cb, cookie);
    }

    ::Test::LongS end_opShortIntLongS(::Test::ShortS& p4, ::Test::IntS& p5, ::Test::LongS& p6, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opShortIntLongS(::Test::ShortS& iceP_p4, ::Test::IntS& iceP_p5, ::Test::LongS& iceP_p6, ::Test::LongS& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opShortIntLongS(const ::Test::ShortS&, const ::Test::IntS&, const ::Test::LongS&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::DoubleS opFloatDoubleS(const ::Test::FloatS& p1, const ::Test::DoubleS& p2, ::Test::FloatS& p3, ::Test::DoubleS& p4, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opFloatDoubleS(p3, p4, _iceI_begin_opFloatDoubleS(p1, p2, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opFloatDoubleS(const ::Test::FloatS& p1, const ::Test::DoubleS& p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opFloatDoubleS(p1, p2, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opFloatDoubleS(const ::Test::FloatS& p1, const ::Test::DoubleS& p2, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opFloatDoubleS(p1, p2, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opFloatDoubleS(const ::Test::FloatS& p1, const ::Test::DoubleS& p2, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opFloatDoubleS(p1, p2, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opFloatDoubleS(const ::Test::FloatS& p1, const ::Test::DoubleS& p2, const ::Test::Callback_MyClass_opFloatDoubleSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opFloatDoubleS(p1, p2, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opFloatDoubleS(const ::Test::FloatS& p1, const ::Test::DoubleS& p2, const ::Ice::Context& context, const ::Test::Callback_MyClass_opFloatDoubleSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opFloatDoubleS(p1, p2, context, cb, cookie);
    }

    ::Test::DoubleS end_opFloatDoubleS(::Test::FloatS& p3, ::Test::DoubleS& p4, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opFloatDoubleS(::Test::FloatS& iceP_p3, ::Test::DoubleS& iceP_p4, ::Test::DoubleS& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opFloatDoubleS(const ::Test::FloatS&, const ::Test::DoubleS&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::StringS opStringS(const ::Test::StringS& p1, const ::Test::StringS& p2, ::Test::StringS& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opStringS(p3, _iceI_begin_opStringS(p1, p2, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opStringS(const ::Test::StringS& p1, const ::Test::StringS& p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opStringS(p1, p2, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opStringS(const ::Test::StringS& p1, const ::Test::StringS& p2, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringS(p1, p2, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringS(const ::Test::StringS& p1, const ::Test::StringS& p2, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringS(p1, p2, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringS(const ::Test::StringS& p1, const ::Test::StringS& p2, const ::Test::Callback_MyClass_opStringSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringS(p1, p2, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringS(const ::Test::StringS& p1, const ::Test::StringS& p2, const ::Ice::Context& context, const ::Test::Callback_MyClass_opStringSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringS(p1, p2, context, cb, cookie);
    }

    ::Test::StringS end_opStringS(::Test::StringS& p3, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opStringS(::Test::StringS& iceP_p3, ::Test::StringS& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opStringS(const ::Test::StringS&, const ::Test::StringS&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::ByteSS opByteSS(const ::Test::ByteSS& p1, const ::Test::ByteSS& p2, ::Test::ByteSS& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opByteSS(p3, _iceI_begin_opByteSS(p1, p2, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opByteSS(const ::Test::ByteSS& p1, const ::Test::ByteSS& p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opByteSS(p1, p2, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opByteSS(const ::Test::ByteSS& p1, const ::Test::ByteSS& p2, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByteSS(p1, p2, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opByteSS(const ::Test::ByteSS& p1, const ::Test::ByteSS& p2, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByteSS(p1, p2, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opByteSS(const ::Test::ByteSS& p1, const ::Test::ByteSS& p2, const ::Test::Callback_MyClass_opByteSSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByteSS(p1, p2, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opByteSS(const ::Test::ByteSS& p1, const ::Test::ByteSS& p2, const ::Ice::Context& context, const ::Test::Callback_MyClass_opByteSSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByteSS(p1, p2, context, cb, cookie);
    }

    ::Test::ByteSS end_opByteSS(::Test::ByteSS& p3, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opByteSS(::Test::ByteSS& iceP_p3, ::Test::ByteSS& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opByteSS(const ::Test::ByteSS&, const ::Test::ByteSS&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::BoolSS opBoolSS(const ::Test::BoolSS& p1, const ::Test::BoolSS& p2, ::Test::BoolSS& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opBoolSS(p3, _iceI_begin_opBoolSS(p1, p2, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opBoolSS(const ::Test::BoolSS& p1, const ::Test::BoolSS& p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opBoolSS(p1, p2, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opBoolSS(const ::Test::BoolSS& p1, const ::Test::BoolSS& p2, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opBoolSS(p1, p2, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opBoolSS(const ::Test::BoolSS& p1, const ::Test::BoolSS& p2, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opBoolSS(p1, p2, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opBoolSS(const ::Test::BoolSS& p1, const ::Test::BoolSS& p2, const ::Test::Callback_MyClass_opBoolSSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opBoolSS(p1, p2, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opBoolSS(const ::Test::BoolSS& p1, const ::Test::BoolSS& p2, const ::Ice::Context& context, const ::Test::Callback_MyClass_opBoolSSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opBoolSS(p1, p2, context, cb, cookie);
    }

    ::Test::BoolSS end_opBoolSS(::Test::BoolSS& p3, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opBoolSS(::Test::BoolSS& iceP_p3, ::Test::BoolSS& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opBoolSS(const ::Test::BoolSS&, const ::Test::BoolSS&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::LongSS opShortIntLongSS(const ::Test::ShortSS& p1, const ::Test::IntSS& p2, const ::Test::LongSS& p3, ::Test::ShortSS& p4, ::Test::IntSS& p5, ::Test::LongSS& p6, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opShortIntLongSS(p4, p5, p6, _iceI_begin_opShortIntLongSS(p1, p2, p3, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opShortIntLongSS(const ::Test::ShortSS& p1, const ::Test::IntSS& p2, const ::Test::LongSS& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opShortIntLongSS(p1, p2, p3, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opShortIntLongSS(const ::Test::ShortSS& p1, const ::Test::IntSS& p2, const ::Test::LongSS& p3, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opShortIntLongSS(p1, p2, p3, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opShortIntLongSS(const ::Test::ShortSS& p1, const ::Test::IntSS& p2, const ::Test::LongSS& p3, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opShortIntLongSS(p1, p2, p3, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opShortIntLongSS(const ::Test::ShortSS& p1, const ::Test::IntSS& p2, const ::Test::LongSS& p3, const ::Test::Callback_MyClass_opShortIntLongSSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opShortIntLongSS(p1, p2, p3, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opShortIntLongSS(const ::Test::ShortSS& p1, const ::Test::IntSS& p2, const ::Test::LongSS& p3, const ::Ice::Context& context, const ::Test::Callback_MyClass_opShortIntLongSSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opShortIntLongSS(p1, p2, p3, context, cb, cookie);
    }

    ::Test::LongSS end_opShortIntLongSS(::Test::ShortSS& p4, ::Test::IntSS& p5, ::Test::LongSS& p6, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opShortIntLongSS(::Test::ShortSS& iceP_p4, ::Test::IntSS& iceP_p5, ::Test::LongSS& iceP_p6, ::Test::LongSS& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opShortIntLongSS(const ::Test::ShortSS&, const ::Test::IntSS&, const ::Test::LongSS&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::DoubleSS opFloatDoubleSS(const ::Test::FloatSS& p1, const ::Test::DoubleSS& p2, ::Test::FloatSS& p3, ::Test::DoubleSS& p4, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opFloatDoubleSS(p3, p4, _iceI_begin_opFloatDoubleSS(p1, p2, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opFloatDoubleSS(const ::Test::FloatSS& p1, const ::Test::DoubleSS& p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opFloatDoubleSS(p1, p2, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opFloatDoubleSS(const ::Test::FloatSS& p1, const ::Test::DoubleSS& p2, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opFloatDoubleSS(p1, p2, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opFloatDoubleSS(const ::Test::FloatSS& p1, const ::Test::DoubleSS& p2, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opFloatDoubleSS(p1, p2, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opFloatDoubleSS(const ::Test::FloatSS& p1, const ::Test::DoubleSS& p2, const ::Test::Callback_MyClass_opFloatDoubleSSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opFloatDoubleSS(p1, p2, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opFloatDoubleSS(const ::Test::FloatSS& p1, const ::Test::DoubleSS& p2, const ::Ice::Context& context, const ::Test::Callback_MyClass_opFloatDoubleSSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opFloatDoubleSS(p1, p2, context, cb, cookie);
    }

    ::Test::DoubleSS end_opFloatDoubleSS(::Test::FloatSS& p3, ::Test::DoubleSS& p4, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opFloatDoubleSS(::Test::FloatSS& iceP_p3, ::Test::DoubleSS& iceP_p4, ::Test::DoubleSS& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opFloatDoubleSS(const ::Test::FloatSS&, const ::Test::DoubleSS&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::StringSS opStringSS(const ::Test::StringSS& p1, const ::Test::StringSS& p2, ::Test::StringSS& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opStringSS(p3, _iceI_begin_opStringSS(p1, p2, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opStringSS(const ::Test::StringSS& p1, const ::Test::StringSS& p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opStringSS(p1, p2, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opStringSS(const ::Test::StringSS& p1, const ::Test::StringSS& p2, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringSS(p1, p2, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringSS(const ::Test::StringSS& p1, const ::Test::StringSS& p2, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringSS(p1, p2, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringSS(const ::Test::StringSS& p1, const ::Test::StringSS& p2, const ::Test::Callback_MyClass_opStringSSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringSS(p1, p2, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringSS(const ::Test::StringSS& p1, const ::Test::StringSS& p2, const ::Ice::Context& context, const ::Test::Callback_MyClass_opStringSSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringSS(p1, p2, context, cb, cookie);
    }

    ::Test::StringSS end_opStringSS(::Test::StringSS& p3, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opStringSS(::Test::StringSS& iceP_p3, ::Test::StringSS& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opStringSS(const ::Test::StringSS&, const ::Test::StringSS&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::StringSSS opStringSSS(const ::Test::StringSSS& p1, const ::Test::StringSSS& p2, ::Test::StringSSS& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opStringSSS(p3, _iceI_begin_opStringSSS(p1, p2, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opStringSSS(const ::Test::StringSSS& p1, const ::Test::StringSSS& p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opStringSSS(p1, p2, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opStringSSS(const ::Test::StringSSS& p1, const ::Test::StringSSS& p2, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringSSS(p1, p2, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringSSS(const ::Test::StringSSS& p1, const ::Test::StringSSS& p2, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringSSS(p1, p2, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringSSS(const ::Test::StringSSS& p1, const ::Test::StringSSS& p2, const ::Test::Callback_MyClass_opStringSSSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringSSS(p1, p2, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringSSS(const ::Test::StringSSS& p1, const ::Test::StringSSS& p2, const ::Ice::Context& context, const ::Test::Callback_MyClass_opStringSSSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringSSS(p1, p2, context, cb, cookie);
    }

    ::Test::StringSSS end_opStringSSS(::Test::StringSSS& p3, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opStringSSS(::Test::StringSSS& iceP_p3, ::Test::StringSSS& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opStringSSS(const ::Test::StringSSS&, const ::Test::StringSSS&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::ByteBoolD opByteBoolD(const ::Test::ByteBoolD& p1, const ::Test::ByteBoolD& p2, ::Test::ByteBoolD& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opByteBoolD(p3, _iceI_begin_opByteBoolD(p1, p2, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opByteBoolD(const ::Test::ByteBoolD& p1, const ::Test::ByteBoolD& p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opByteBoolD(p1, p2, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opByteBoolD(const ::Test::ByteBoolD& p1, const ::Test::ByteBoolD& p2, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByteBoolD(p1, p2, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opByteBoolD(const ::Test::ByteBoolD& p1, const ::Test::ByteBoolD& p2, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByteBoolD(p1, p2, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opByteBoolD(const ::Test::ByteBoolD& p1, const ::Test::ByteBoolD& p2, const ::Test::Callback_MyClass_opByteBoolDPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByteBoolD(p1, p2, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opByteBoolD(const ::Test::ByteBoolD& p1, const ::Test::ByteBoolD& p2, const ::Ice::Context& context, const ::Test::Callback_MyClass_opByteBoolDPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByteBoolD(p1, p2, context, cb, cookie);
    }

    ::Test::ByteBoolD end_opByteBoolD(::Test::ByteBoolD& p3, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opByteBoolD(::Test::ByteBoolD& iceP_p3, ::Test::ByteBoolD& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opByteBoolD(const ::Test::ByteBoolD&, const ::Test::ByteBoolD&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::ShortIntD opShortIntD(const ::Test::ShortIntD& p1, const ::Test::ShortIntD& p2, ::Test::ShortIntD& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opShortIntD(p3, _iceI_begin_opShortIntD(p1, p2, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opShortIntD(const ::Test::ShortIntD& p1, const ::Test::ShortIntD& p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opShortIntD(p1, p2, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opShortIntD(const ::Test::ShortIntD& p1, const ::Test::ShortIntD& p2, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opShortIntD(p1, p2, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opShortIntD(const ::Test::ShortIntD& p1, const ::Test::ShortIntD& p2, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opShortIntD(p1, p2, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opShortIntD(const ::Test::ShortIntD& p1, const ::Test::ShortIntD& p2, const ::Test::Callback_MyClass_opShortIntDPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opShortIntD(p1, p2, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opShortIntD(const ::Test::ShortIntD& p1, const ::Test::ShortIntD& p2, const ::Ice::Context& context, const ::Test::Callback_MyClass_opShortIntDPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opShortIntD(p1, p2, context, cb, cookie);
    }

    ::Test::ShortIntD end_opShortIntD(::Test::ShortIntD& p3, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opShortIntD(::Test::ShortIntD& iceP_p3, ::Test::ShortIntD& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opShortIntD(const ::Test::ShortIntD&, const ::Test::ShortIntD&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::LongFloatD opLongFloatD(const ::Test::LongFloatD& p1, const ::Test::LongFloatD& p2, ::Test::LongFloatD& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opLongFloatD(p3, _iceI_begin_opLongFloatD(p1, p2, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opLongFloatD(const ::Test::LongFloatD& p1, const ::Test::LongFloatD& p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opLongFloatD(p1, p2, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opLongFloatD(const ::Test::LongFloatD& p1, const ::Test::LongFloatD& p2, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opLongFloatD(p1, p2, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opLongFloatD(const ::Test::LongFloatD& p1, const ::Test::LongFloatD& p2, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opLongFloatD(p1, p2, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opLongFloatD(const ::Test::LongFloatD& p1, const ::Test::LongFloatD& p2, const ::Test::Callback_MyClass_opLongFloatDPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opLongFloatD(p1, p2, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opLongFloatD(const ::Test::LongFloatD& p1, const ::Test::LongFloatD& p2, const ::Ice::Context& context, const ::Test::Callback_MyClass_opLongFloatDPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opLongFloatD(p1, p2, context, cb, cookie);
    }

    ::Test::LongFloatD end_opLongFloatD(::Test::LongFloatD& p3, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opLongFloatD(::Test::LongFloatD& iceP_p3, ::Test::LongFloatD& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opLongFloatD(const ::Test::LongFloatD&, const ::Test::LongFloatD&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::StringStringD opStringStringD(const ::Test::StringStringD& p1, const ::Test::StringStringD& p2, ::Test::StringStringD& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opStringStringD(p3, _iceI_begin_opStringStringD(p1, p2, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opStringStringD(const ::Test::StringStringD& p1, const ::Test::StringStringD& p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opStringStringD(p1, p2, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opStringStringD(const ::Test::StringStringD& p1, const ::Test::StringStringD& p2, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringStringD(p1, p2, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringStringD(const ::Test::StringStringD& p1, const ::Test::StringStringD& p2, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringStringD(p1, p2, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringStringD(const ::Test::StringStringD& p1, const ::Test::StringStringD& p2, const ::Test::Callback_MyClass_opStringStringDPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringStringD(p1, p2, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringStringD(const ::Test::StringStringD& p1, const ::Test::StringStringD& p2, const ::Ice::Context& context, const ::Test::Callback_MyClass_opStringStringDPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringStringD(p1, p2, context, cb, cookie);
    }

    ::Test::StringStringD end_opStringStringD(::Test::StringStringD& p3, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opStringStringD(::Test::StringStringD& iceP_p3, ::Test::StringStringD& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opStringStringD(const ::Test::StringStringD&, const ::Test::StringStringD&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::StringMyEnumD opStringMyEnumD(const ::Test::StringMyEnumD& p1, const ::Test::StringMyEnumD& p2, ::Test::StringMyEnumD& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opStringMyEnumD(p3, _iceI_begin_opStringMyEnumD(p1, p2, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opStringMyEnumD(const ::Test::StringMyEnumD& p1, const ::Test::StringMyEnumD& p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opStringMyEnumD(p1, p2, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opStringMyEnumD(const ::Test::StringMyEnumD& p1, const ::Test::StringMyEnumD& p2, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringMyEnumD(p1, p2, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringMyEnumD(const ::Test::StringMyEnumD& p1, const ::Test::StringMyEnumD& p2, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringMyEnumD(p1, p2, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringMyEnumD(const ::Test::StringMyEnumD& p1, const ::Test::StringMyEnumD& p2, const ::Test::Callback_MyClass_opStringMyEnumDPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringMyEnumD(p1, p2, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringMyEnumD(const ::Test::StringMyEnumD& p1, const ::Test::StringMyEnumD& p2, const ::Ice::Context& context, const ::Test::Callback_MyClass_opStringMyEnumDPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringMyEnumD(p1, p2, context, cb, cookie);
    }

    ::Test::StringMyEnumD end_opStringMyEnumD(::Test::StringMyEnumD& p3, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opStringMyEnumD(::Test::StringMyEnumD& iceP_p3, ::Test::StringMyEnumD& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opStringMyEnumD(const ::Test::StringMyEnumD&, const ::Test::StringMyEnumD&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::MyEnumStringD opMyEnumStringD(const ::Test::MyEnumStringD& p1, const ::Test::MyEnumStringD& p2, ::Test::MyEnumStringD& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opMyEnumStringD(p3, _iceI_begin_opMyEnumStringD(p1, p2, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opMyEnumStringD(const ::Test::MyEnumStringD& p1, const ::Test::MyEnumStringD& p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opMyEnumStringD(p1, p2, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opMyEnumStringD(const ::Test::MyEnumStringD& p1, const ::Test::MyEnumStringD& p2, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opMyEnumStringD(p1, p2, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opMyEnumStringD(const ::Test::MyEnumStringD& p1, const ::Test::MyEnumStringD& p2, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opMyEnumStringD(p1, p2, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opMyEnumStringD(const ::Test::MyEnumStringD& p1, const ::Test::MyEnumStringD& p2, const ::Test::Callback_MyClass_opMyEnumStringDPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opMyEnumStringD(p1, p2, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opMyEnumStringD(const ::Test::MyEnumStringD& p1, const ::Test::MyEnumStringD& p2, const ::Ice::Context& context, const ::Test::Callback_MyClass_opMyEnumStringDPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opMyEnumStringD(p1, p2, context, cb, cookie);
    }

    ::Test::MyEnumStringD end_opMyEnumStringD(::Test::MyEnumStringD& p3, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opMyEnumStringD(::Test::MyEnumStringD& iceP_p3, ::Test::MyEnumStringD& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opMyEnumStringD(const ::Test::MyEnumStringD&, const ::Test::MyEnumStringD&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::MyStructMyEnumD opMyStructMyEnumD(const ::Test::MyStructMyEnumD& p1, const ::Test::MyStructMyEnumD& p2, ::Test::MyStructMyEnumD& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opMyStructMyEnumD(p3, _iceI_begin_opMyStructMyEnumD(p1, p2, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opMyStructMyEnumD(const ::Test::MyStructMyEnumD& p1, const ::Test::MyStructMyEnumD& p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opMyStructMyEnumD(p1, p2, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opMyStructMyEnumD(const ::Test::MyStructMyEnumD& p1, const ::Test::MyStructMyEnumD& p2, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opMyStructMyEnumD(p1, p2, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opMyStructMyEnumD(const ::Test::MyStructMyEnumD& p1, const ::Test::MyStructMyEnumD& p2, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opMyStructMyEnumD(p1, p2, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opMyStructMyEnumD(const ::Test::MyStructMyEnumD& p1, const ::Test::MyStructMyEnumD& p2, const ::Test::Callback_MyClass_opMyStructMyEnumDPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opMyStructMyEnumD(p1, p2, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opMyStructMyEnumD(const ::Test::MyStructMyEnumD& p1, const ::Test::MyStructMyEnumD& p2, const ::Ice::Context& context, const ::Test::Callback_MyClass_opMyStructMyEnumDPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opMyStructMyEnumD(p1, p2, context, cb, cookie);
    }

    ::Test::MyStructMyEnumD end_opMyStructMyEnumD(::Test::MyStructMyEnumD& p3, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opMyStructMyEnumD(::Test::MyStructMyEnumD& iceP_p3, ::Test::MyStructMyEnumD& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opMyStructMyEnumD(const ::Test::MyStructMyEnumD&, const ::Test::MyStructMyEnumD&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::ByteBoolDS opByteBoolDS(const ::Test::ByteBoolDS& p1, const ::Test::ByteBoolDS& p2, ::Test::ByteBoolDS& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opByteBoolDS(p3, _iceI_begin_opByteBoolDS(p1, p2, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opByteBoolDS(const ::Test::ByteBoolDS& p1, const ::Test::ByteBoolDS& p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opByteBoolDS(p1, p2, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opByteBoolDS(const ::Test::ByteBoolDS& p1, const ::Test::ByteBoolDS& p2, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByteBoolDS(p1, p2, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opByteBoolDS(const ::Test::ByteBoolDS& p1, const ::Test::ByteBoolDS& p2, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByteBoolDS(p1, p2, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opByteBoolDS(const ::Test::ByteBoolDS& p1, const ::Test::ByteBoolDS& p2, const ::Test::Callback_MyClass_opByteBoolDSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByteBoolDS(p1, p2, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opByteBoolDS(const ::Test::ByteBoolDS& p1, const ::Test::ByteBoolDS& p2, const ::Ice::Context& context, const ::Test::Callback_MyClass_opByteBoolDSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByteBoolDS(p1, p2, context, cb, cookie);
    }

    ::Test::ByteBoolDS end_opByteBoolDS(::Test::ByteBoolDS& p3, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opByteBoolDS(::Test::ByteBoolDS& iceP_p3, ::Test::ByteBoolDS& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opByteBoolDS(const ::Test::ByteBoolDS&, const ::Test::ByteBoolDS&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::ShortIntDS opShortIntDS(const ::Test::ShortIntDS& p1, const ::Test::ShortIntDS& p2, ::Test::ShortIntDS& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opShortIntDS(p3, _iceI_begin_opShortIntDS(p1, p2, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opShortIntDS(const ::Test::ShortIntDS& p1, const ::Test::ShortIntDS& p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opShortIntDS(p1, p2, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opShortIntDS(const ::Test::ShortIntDS& p1, const ::Test::ShortIntDS& p2, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opShortIntDS(p1, p2, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opShortIntDS(const ::Test::ShortIntDS& p1, const ::Test::ShortIntDS& p2, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opShortIntDS(p1, p2, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opShortIntDS(const ::Test::ShortIntDS& p1, const ::Test::ShortIntDS& p2, const ::Test::Callback_MyClass_opShortIntDSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opShortIntDS(p1, p2, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opShortIntDS(const ::Test::ShortIntDS& p1, const ::Test::ShortIntDS& p2, const ::Ice::Context& context, const ::Test::Callback_MyClass_opShortIntDSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opShortIntDS(p1, p2, context, cb, cookie);
    }

    ::Test::ShortIntDS end_opShortIntDS(::Test::ShortIntDS& p3, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opShortIntDS(::Test::ShortIntDS& iceP_p3, ::Test::ShortIntDS& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opShortIntDS(const ::Test::ShortIntDS&, const ::Test::ShortIntDS&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::LongFloatDS opLongFloatDS(const ::Test::LongFloatDS& p1, const ::Test::LongFloatDS& p2, ::Test::LongFloatDS& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opLongFloatDS(p3, _iceI_begin_opLongFloatDS(p1, p2, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opLongFloatDS(const ::Test::LongFloatDS& p1, const ::Test::LongFloatDS& p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opLongFloatDS(p1, p2, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opLongFloatDS(const ::Test::LongFloatDS& p1, const ::Test::LongFloatDS& p2, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opLongFloatDS(p1, p2, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opLongFloatDS(const ::Test::LongFloatDS& p1, const ::Test::LongFloatDS& p2, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opLongFloatDS(p1, p2, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opLongFloatDS(const ::Test::LongFloatDS& p1, const ::Test::LongFloatDS& p2, const ::Test::Callback_MyClass_opLongFloatDSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opLongFloatDS(p1, p2, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opLongFloatDS(const ::Test::LongFloatDS& p1, const ::Test::LongFloatDS& p2, const ::Ice::Context& context, const ::Test::Callback_MyClass_opLongFloatDSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opLongFloatDS(p1, p2, context, cb, cookie);
    }

    ::Test::LongFloatDS end_opLongFloatDS(::Test::LongFloatDS& p3, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opLongFloatDS(::Test::LongFloatDS& iceP_p3, ::Test::LongFloatDS& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opLongFloatDS(const ::Test::LongFloatDS&, const ::Test::LongFloatDS&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::StringStringDS opStringStringDS(const ::Test::StringStringDS& p1, const ::Test::StringStringDS& p2, ::Test::StringStringDS& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opStringStringDS(p3, _iceI_begin_opStringStringDS(p1, p2, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opStringStringDS(const ::Test::StringStringDS& p1, const ::Test::StringStringDS& p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opStringStringDS(p1, p2, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opStringStringDS(const ::Test::StringStringDS& p1, const ::Test::StringStringDS& p2, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringStringDS(p1, p2, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringStringDS(const ::Test::StringStringDS& p1, const ::Test::StringStringDS& p2, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringStringDS(p1, p2, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringStringDS(const ::Test::StringStringDS& p1, const ::Test::StringStringDS& p2, const ::Test::Callback_MyClass_opStringStringDSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringStringDS(p1, p2, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringStringDS(const ::Test::StringStringDS& p1, const ::Test::StringStringDS& p2, const ::Ice::Context& context, const ::Test::Callback_MyClass_opStringStringDSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringStringDS(p1, p2, context, cb, cookie);
    }

    ::Test::StringStringDS end_opStringStringDS(::Test::StringStringDS& p3, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opStringStringDS(::Test::StringStringDS& iceP_p3, ::Test::StringStringDS& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opStringStringDS(const ::Test::StringStringDS&, const ::Test::StringStringDS&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::StringMyEnumDS opStringMyEnumDS(const ::Test::StringMyEnumDS& p1, const ::Test::StringMyEnumDS& p2, ::Test::StringMyEnumDS& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opStringMyEnumDS(p3, _iceI_begin_opStringMyEnumDS(p1, p2, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opStringMyEnumDS(const ::Test::StringMyEnumDS& p1, const ::Test::StringMyEnumDS& p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opStringMyEnumDS(p1, p2, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opStringMyEnumDS(const ::Test::StringMyEnumDS& p1, const ::Test::StringMyEnumDS& p2, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringMyEnumDS(p1, p2, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringMyEnumDS(const ::Test::StringMyEnumDS& p1, const ::Test::StringMyEnumDS& p2, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringMyEnumDS(p1, p2, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringMyEnumDS(const ::Test::StringMyEnumDS& p1, const ::Test::StringMyEnumDS& p2, const ::Test::Callback_MyClass_opStringMyEnumDSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringMyEnumDS(p1, p2, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringMyEnumDS(const ::Test::StringMyEnumDS& p1, const ::Test::StringMyEnumDS& p2, const ::Ice::Context& context, const ::Test::Callback_MyClass_opStringMyEnumDSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringMyEnumDS(p1, p2, context, cb, cookie);
    }

    ::Test::StringMyEnumDS end_opStringMyEnumDS(::Test::StringMyEnumDS& p3, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opStringMyEnumDS(::Test::StringMyEnumDS& iceP_p3, ::Test::StringMyEnumDS& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opStringMyEnumDS(const ::Test::StringMyEnumDS&, const ::Test::StringMyEnumDS&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::MyEnumStringDS opMyEnumStringDS(const ::Test::MyEnumStringDS& p1, const ::Test::MyEnumStringDS& p2, ::Test::MyEnumStringDS& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opMyEnumStringDS(p3, _iceI_begin_opMyEnumStringDS(p1, p2, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opMyEnumStringDS(const ::Test::MyEnumStringDS& p1, const ::Test::MyEnumStringDS& p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opMyEnumStringDS(p1, p2, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opMyEnumStringDS(const ::Test::MyEnumStringDS& p1, const ::Test::MyEnumStringDS& p2, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opMyEnumStringDS(p1, p2, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opMyEnumStringDS(const ::Test::MyEnumStringDS& p1, const ::Test::MyEnumStringDS& p2, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opMyEnumStringDS(p1, p2, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opMyEnumStringDS(const ::Test::MyEnumStringDS& p1, const ::Test::MyEnumStringDS& p2, const ::Test::Callback_MyClass_opMyEnumStringDSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opMyEnumStringDS(p1, p2, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opMyEnumStringDS(const ::Test::MyEnumStringDS& p1, const ::Test::MyEnumStringDS& p2, const ::Ice::Context& context, const ::Test::Callback_MyClass_opMyEnumStringDSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opMyEnumStringDS(p1, p2, context, cb, cookie);
    }

    ::Test::MyEnumStringDS end_opMyEnumStringDS(::Test::MyEnumStringDS& p3, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opMyEnumStringDS(::Test::MyEnumStringDS& iceP_p3, ::Test::MyEnumStringDS& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opMyEnumStringDS(const ::Test::MyEnumStringDS&, const ::Test::MyEnumStringDS&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::MyStructMyEnumDS opMyStructMyEnumDS(const ::Test::MyStructMyEnumDS& p1, const ::Test::MyStructMyEnumDS& p2, ::Test::MyStructMyEnumDS& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opMyStructMyEnumDS(p3, _iceI_begin_opMyStructMyEnumDS(p1, p2, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opMyStructMyEnumDS(const ::Test::MyStructMyEnumDS& p1, const ::Test::MyStructMyEnumDS& p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opMyStructMyEnumDS(p1, p2, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opMyStructMyEnumDS(const ::Test::MyStructMyEnumDS& p1, const ::Test::MyStructMyEnumDS& p2, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opMyStructMyEnumDS(p1, p2, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opMyStructMyEnumDS(const ::Test::MyStructMyEnumDS& p1, const ::Test::MyStructMyEnumDS& p2, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opMyStructMyEnumDS(p1, p2, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opMyStructMyEnumDS(const ::Test::MyStructMyEnumDS& p1, const ::Test::MyStructMyEnumDS& p2, const ::Test::Callback_MyClass_opMyStructMyEnumDSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opMyStructMyEnumDS(p1, p2, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opMyStructMyEnumDS(const ::Test::MyStructMyEnumDS& p1, const ::Test::MyStructMyEnumDS& p2, const ::Ice::Context& context, const ::Test::Callback_MyClass_opMyStructMyEnumDSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opMyStructMyEnumDS(p1, p2, context, cb, cookie);
    }

    ::Test::MyStructMyEnumDS end_opMyStructMyEnumDS(::Test::MyStructMyEnumDS& p3, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opMyStructMyEnumDS(::Test::MyStructMyEnumDS& iceP_p3, ::Test::MyStructMyEnumDS& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opMyStructMyEnumDS(const ::Test::MyStructMyEnumDS&, const ::Test::MyStructMyEnumDS&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::ByteByteSD opByteByteSD(const ::Test::ByteByteSD& p1, const ::Test::ByteByteSD& p2, ::Test::ByteByteSD& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opByteByteSD(p3, _iceI_begin_opByteByteSD(p1, p2, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opByteByteSD(const ::Test::ByteByteSD& p1, const ::Test::ByteByteSD& p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opByteByteSD(p1, p2, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opByteByteSD(const ::Test::ByteByteSD& p1, const ::Test::ByteByteSD& p2, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByteByteSD(p1, p2, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opByteByteSD(const ::Test::ByteByteSD& p1, const ::Test::ByteByteSD& p2, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByteByteSD(p1, p2, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opByteByteSD(const ::Test::ByteByteSD& p1, const ::Test::ByteByteSD& p2, const ::Test::Callback_MyClass_opByteByteSDPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByteByteSD(p1, p2, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opByteByteSD(const ::Test::ByteByteSD& p1, const ::Test::ByteByteSD& p2, const ::Ice::Context& context, const ::Test::Callback_MyClass_opByteByteSDPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByteByteSD(p1, p2, context, cb, cookie);
    }

    ::Test::ByteByteSD end_opByteByteSD(::Test::ByteByteSD& p3, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opByteByteSD(::Test::ByteByteSD& iceP_p3, ::Test::ByteByteSD& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opByteByteSD(const ::Test::ByteByteSD&, const ::Test::ByteByteSD&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::BoolBoolSD opBoolBoolSD(const ::Test::BoolBoolSD& p1, const ::Test::BoolBoolSD& p2, ::Test::BoolBoolSD& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opBoolBoolSD(p3, _iceI_begin_opBoolBoolSD(p1, p2, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opBoolBoolSD(const ::Test::BoolBoolSD& p1, const ::Test::BoolBoolSD& p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opBoolBoolSD(p1, p2, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opBoolBoolSD(const ::Test::BoolBoolSD& p1, const ::Test::BoolBoolSD& p2, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opBoolBoolSD(p1, p2, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opBoolBoolSD(const ::Test::BoolBoolSD& p1, const ::Test::BoolBoolSD& p2, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opBoolBoolSD(p1, p2, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opBoolBoolSD(const ::Test::BoolBoolSD& p1, const ::Test::BoolBoolSD& p2, const ::Test::Callback_MyClass_opBoolBoolSDPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opBoolBoolSD(p1, p2, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opBoolBoolSD(const ::Test::BoolBoolSD& p1, const ::Test::BoolBoolSD& p2, const ::Ice::Context& context, const ::Test::Callback_MyClass_opBoolBoolSDPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opBoolBoolSD(p1, p2, context, cb, cookie);
    }

    ::Test::BoolBoolSD end_opBoolBoolSD(::Test::BoolBoolSD& p3, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opBoolBoolSD(::Test::BoolBoolSD& iceP_p3, ::Test::BoolBoolSD& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opBoolBoolSD(const ::Test::BoolBoolSD&, const ::Test::BoolBoolSD&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::ShortShortSD opShortShortSD(const ::Test::ShortShortSD& p1, const ::Test::ShortShortSD& p2, ::Test::ShortShortSD& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opShortShortSD(p3, _iceI_begin_opShortShortSD(p1, p2, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opShortShortSD(const ::Test::ShortShortSD& p1, const ::Test::ShortShortSD& p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opShortShortSD(p1, p2, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opShortShortSD(const ::Test::ShortShortSD& p1, const ::Test::ShortShortSD& p2, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opShortShortSD(p1, p2, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opShortShortSD(const ::Test::ShortShortSD& p1, const ::Test::ShortShortSD& p2, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opShortShortSD(p1, p2, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opShortShortSD(const ::Test::ShortShortSD& p1, const ::Test::ShortShortSD& p2, const ::Test::Callback_MyClass_opShortShortSDPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opShortShortSD(p1, p2, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opShortShortSD(const ::Test::ShortShortSD& p1, const ::Test::ShortShortSD& p2, const ::Ice::Context& context, const ::Test::Callback_MyClass_opShortShortSDPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opShortShortSD(p1, p2, context, cb, cookie);
    }

    ::Test::ShortShortSD end_opShortShortSD(::Test::ShortShortSD& p3, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opShortShortSD(::Test::ShortShortSD& iceP_p3, ::Test::ShortShortSD& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opShortShortSD(const ::Test::ShortShortSD&, const ::Test::ShortShortSD&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::IntIntSD opIntIntSD(const ::Test::IntIntSD& p1, const ::Test::IntIntSD& p2, ::Test::IntIntSD& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opIntIntSD(p3, _iceI_begin_opIntIntSD(p1, p2, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opIntIntSD(const ::Test::IntIntSD& p1, const ::Test::IntIntSD& p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opIntIntSD(p1, p2, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opIntIntSD(const ::Test::IntIntSD& p1, const ::Test::IntIntSD& p2, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opIntIntSD(p1, p2, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opIntIntSD(const ::Test::IntIntSD& p1, const ::Test::IntIntSD& p2, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opIntIntSD(p1, p2, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opIntIntSD(const ::Test::IntIntSD& p1, const ::Test::IntIntSD& p2, const ::Test::Callback_MyClass_opIntIntSDPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opIntIntSD(p1, p2, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opIntIntSD(const ::Test::IntIntSD& p1, const ::Test::IntIntSD& p2, const ::Ice::Context& context, const ::Test::Callback_MyClass_opIntIntSDPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opIntIntSD(p1, p2, context, cb, cookie);
    }

    ::Test::IntIntSD end_opIntIntSD(::Test::IntIntSD& p3, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opIntIntSD(::Test::IntIntSD& iceP_p3, ::Test::IntIntSD& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opIntIntSD(const ::Test::IntIntSD&, const ::Test::IntIntSD&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::LongLongSD opLongLongSD(const ::Test::LongLongSD& p1, const ::Test::LongLongSD& p2, ::Test::LongLongSD& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opLongLongSD(p3, _iceI_begin_opLongLongSD(p1, p2, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opLongLongSD(const ::Test::LongLongSD& p1, const ::Test::LongLongSD& p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opLongLongSD(p1, p2, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opLongLongSD(const ::Test::LongLongSD& p1, const ::Test::LongLongSD& p2, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opLongLongSD(p1, p2, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opLongLongSD(const ::Test::LongLongSD& p1, const ::Test::LongLongSD& p2, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opLongLongSD(p1, p2, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opLongLongSD(const ::Test::LongLongSD& p1, const ::Test::LongLongSD& p2, const ::Test::Callback_MyClass_opLongLongSDPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opLongLongSD(p1, p2, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opLongLongSD(const ::Test::LongLongSD& p1, const ::Test::LongLongSD& p2, const ::Ice::Context& context, const ::Test::Callback_MyClass_opLongLongSDPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opLongLongSD(p1, p2, context, cb, cookie);
    }

    ::Test::LongLongSD end_opLongLongSD(::Test::LongLongSD& p3, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opLongLongSD(::Test::LongLongSD& iceP_p3, ::Test::LongLongSD& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opLongLongSD(const ::Test::LongLongSD&, const ::Test::LongLongSD&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::StringFloatSD opStringFloatSD(const ::Test::StringFloatSD& p1, const ::Test::StringFloatSD& p2, ::Test::StringFloatSD& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opStringFloatSD(p3, _iceI_begin_opStringFloatSD(p1, p2, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opStringFloatSD(const ::Test::StringFloatSD& p1, const ::Test::StringFloatSD& p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opStringFloatSD(p1, p2, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opStringFloatSD(const ::Test::StringFloatSD& p1, const ::Test::StringFloatSD& p2, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringFloatSD(p1, p2, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringFloatSD(const ::Test::StringFloatSD& p1, const ::Test::StringFloatSD& p2, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringFloatSD(p1, p2, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringFloatSD(const ::Test::StringFloatSD& p1, const ::Test::StringFloatSD& p2, const ::Test::Callback_MyClass_opStringFloatSDPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringFloatSD(p1, p2, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringFloatSD(const ::Test::StringFloatSD& p1, const ::Test::StringFloatSD& p2, const ::Ice::Context& context, const ::Test::Callback_MyClass_opStringFloatSDPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringFloatSD(p1, p2, context, cb, cookie);
    }

    ::Test::StringFloatSD end_opStringFloatSD(::Test::StringFloatSD& p3, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opStringFloatSD(::Test::StringFloatSD& iceP_p3, ::Test::StringFloatSD& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opStringFloatSD(const ::Test::StringFloatSD&, const ::Test::StringFloatSD&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::StringDoubleSD opStringDoubleSD(const ::Test::StringDoubleSD& p1, const ::Test::StringDoubleSD& p2, ::Test::StringDoubleSD& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opStringDoubleSD(p3, _iceI_begin_opStringDoubleSD(p1, p2, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opStringDoubleSD(const ::Test::StringDoubleSD& p1, const ::Test::StringDoubleSD& p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opStringDoubleSD(p1, p2, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opStringDoubleSD(const ::Test::StringDoubleSD& p1, const ::Test::StringDoubleSD& p2, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringDoubleSD(p1, p2, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringDoubleSD(const ::Test::StringDoubleSD& p1, const ::Test::StringDoubleSD& p2, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringDoubleSD(p1, p2, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringDoubleSD(const ::Test::StringDoubleSD& p1, const ::Test::StringDoubleSD& p2, const ::Test::Callback_MyClass_opStringDoubleSDPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringDoubleSD(p1, p2, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringDoubleSD(const ::Test::StringDoubleSD& p1, const ::Test::StringDoubleSD& p2, const ::Ice::Context& context, const ::Test::Callback_MyClass_opStringDoubleSDPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringDoubleSD(p1, p2, context, cb, cookie);
    }

    ::Test::StringDoubleSD end_opStringDoubleSD(::Test::StringDoubleSD& p3, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opStringDoubleSD(::Test::StringDoubleSD& iceP_p3, ::Test::StringDoubleSD& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opStringDoubleSD(const ::Test::StringDoubleSD&, const ::Test::StringDoubleSD&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::StringStringSD opStringStringSD(const ::Test::StringStringSD& p1, const ::Test::StringStringSD& p2, ::Test::StringStringSD& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opStringStringSD(p3, _iceI_begin_opStringStringSD(p1, p2, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opStringStringSD(const ::Test::StringStringSD& p1, const ::Test::StringStringSD& p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opStringStringSD(p1, p2, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opStringStringSD(const ::Test::StringStringSD& p1, const ::Test::StringStringSD& p2, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringStringSD(p1, p2, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringStringSD(const ::Test::StringStringSD& p1, const ::Test::StringStringSD& p2, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringStringSD(p1, p2, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringStringSD(const ::Test::StringStringSD& p1, const ::Test::StringStringSD& p2, const ::Test::Callback_MyClass_opStringStringSDPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringStringSD(p1, p2, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringStringSD(const ::Test::StringStringSD& p1, const ::Test::StringStringSD& p2, const ::Ice::Context& context, const ::Test::Callback_MyClass_opStringStringSDPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringStringSD(p1, p2, context, cb, cookie);
    }

    ::Test::StringStringSD end_opStringStringSD(::Test::StringStringSD& p3, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opStringStringSD(::Test::StringStringSD& iceP_p3, ::Test::StringStringSD& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opStringStringSD(const ::Test::StringStringSD&, const ::Test::StringStringSD&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::MyEnumMyEnumSD opMyEnumMyEnumSD(const ::Test::MyEnumMyEnumSD& p1, const ::Test::MyEnumMyEnumSD& p2, ::Test::MyEnumMyEnumSD& p3, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opMyEnumMyEnumSD(p3, _iceI_begin_opMyEnumMyEnumSD(p1, p2, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opMyEnumMyEnumSD(const ::Test::MyEnumMyEnumSD& p1, const ::Test::MyEnumMyEnumSD& p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opMyEnumMyEnumSD(p1, p2, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opMyEnumMyEnumSD(const ::Test::MyEnumMyEnumSD& p1, const ::Test::MyEnumMyEnumSD& p2, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opMyEnumMyEnumSD(p1, p2, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opMyEnumMyEnumSD(const ::Test::MyEnumMyEnumSD& p1, const ::Test::MyEnumMyEnumSD& p2, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opMyEnumMyEnumSD(p1, p2, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opMyEnumMyEnumSD(const ::Test::MyEnumMyEnumSD& p1, const ::Test::MyEnumMyEnumSD& p2, const ::Test::Callback_MyClass_opMyEnumMyEnumSDPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opMyEnumMyEnumSD(p1, p2, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opMyEnumMyEnumSD(const ::Test::MyEnumMyEnumSD& p1, const ::Test::MyEnumMyEnumSD& p2, const ::Ice::Context& context, const ::Test::Callback_MyClass_opMyEnumMyEnumSDPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opMyEnumMyEnumSD(p1, p2, context, cb, cookie);
    }

    ::Test::MyEnumMyEnumSD end_opMyEnumMyEnumSD(::Test::MyEnumMyEnumSD& p3, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opMyEnumMyEnumSD(::Test::MyEnumMyEnumSD& iceP_p3, ::Test::MyEnumMyEnumSD& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opMyEnumMyEnumSD(const ::Test::MyEnumMyEnumSD&, const ::Test::MyEnumMyEnumSD&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::IntS opIntS(const ::Test::IntS& s, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opIntS(_iceI_begin_opIntS(s, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opIntS(const ::Test::IntS& s, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opIntS(s, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opIntS(const ::Test::IntS& s, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opIntS(s, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opIntS(const ::Test::IntS& s, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opIntS(s, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opIntS(const ::Test::IntS& s, const ::Test::Callback_MyClass_opIntSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opIntS(s, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opIntS(const ::Test::IntS& s, const ::Ice::Context& context, const ::Test::Callback_MyClass_opIntSPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opIntS(s, context, cb, cookie);
    }

    ::Test::IntS end_opIntS(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_opIntS(const ::Test::IntS&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void opByteSOneway(const ::Test::ByteS& s, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_opByteSOneway(_iceI_begin_opByteSOneway(s, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opByteSOneway(const ::Test::ByteS& s, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opByteSOneway(s, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opByteSOneway(const ::Test::ByteS& s, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByteSOneway(s, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opByteSOneway(const ::Test::ByteS& s, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByteSOneway(s, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opByteSOneway(const ::Test::ByteS& s, const ::Test::Callback_MyClass_opByteSOnewayPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByteSOneway(s, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opByteSOneway(const ::Test::ByteS& s, const ::Ice::Context& context, const ::Test::Callback_MyClass_opByteSOnewayPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByteSOneway(s, context, cb, cookie);
    }

    void end_opByteSOneway(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_opByteSOneway(const ::Test::ByteS&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Ice::Int opByteSOnewayCallCount(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opByteSOnewayCallCount(_iceI_begin_opByteSOnewayCallCount(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opByteSOnewayCallCount(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opByteSOnewayCallCount(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opByteSOnewayCallCount(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByteSOnewayCallCount(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opByteSOnewayCallCount(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByteSOnewayCallCount(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opByteSOnewayCallCount(const ::Test::Callback_MyClass_opByteSOnewayCallCountPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByteSOnewayCallCount(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opByteSOnewayCallCount(const ::Ice::Context& context, const ::Test::Callback_MyClass_opByteSOnewayCallCountPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByteSOnewayCallCount(context, cb, cookie);
    }

    ::Ice::Int end_opByteSOnewayCallCount(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_opByteSOnewayCallCount(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Ice::Context opContext(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opContext(_iceI_begin_opContext(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opContext(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opContext(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opContext(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opContext(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opContext(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opContext(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opContext(const ::Test::Callback_MyClass_opContextPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opContext(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opContext(const ::Ice::Context& context, const ::Test::Callback_MyClass_opContextPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opContext(context, cb, cookie);
    }

    ::Ice::Context end_opContext(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_opContext(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void opDoubleMarshaling(::Ice::Double p1, const ::Test::DoubleS& p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_opDoubleMarshaling(_iceI_begin_opDoubleMarshaling(p1, p2, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opDoubleMarshaling(::Ice::Double p1, const ::Test::DoubleS& p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opDoubleMarshaling(p1, p2, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opDoubleMarshaling(::Ice::Double p1, const ::Test::DoubleS& p2, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opDoubleMarshaling(p1, p2, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opDoubleMarshaling(::Ice::Double p1, const ::Test::DoubleS& p2, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opDoubleMarshaling(p1, p2, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opDoubleMarshaling(::Ice::Double p1, const ::Test::DoubleS& p2, const ::Test::Callback_MyClass_opDoubleMarshalingPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opDoubleMarshaling(p1, p2, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opDoubleMarshaling(::Ice::Double p1, const ::Test::DoubleS& p2, const ::Ice::Context& context, const ::Test::Callback_MyClass_opDoubleMarshalingPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opDoubleMarshaling(p1, p2, context, cb, cookie);
    }

    void end_opDoubleMarshaling(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_opDoubleMarshaling(::Ice::Double, const ::Test::DoubleS&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void opIdempotent(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_opIdempotent(_iceI_begin_opIdempotent(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opIdempotent(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opIdempotent(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opIdempotent(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opIdempotent(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opIdempotent(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opIdempotent(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opIdempotent(const ::Test::Callback_MyClass_opIdempotentPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opIdempotent(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opIdempotent(const ::Ice::Context& context, const ::Test::Callback_MyClass_opIdempotentPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opIdempotent(context, cb, cookie);
    }

    void end_opIdempotent(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_opIdempotent(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void opNonmutating(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_opNonmutating(_iceI_begin_opNonmutating(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opNonmutating(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opNonmutating(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opNonmutating(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opNonmutating(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opNonmutating(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opNonmutating(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opNonmutating(const ::Test::Callback_MyClass_opNonmutatingPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opNonmutating(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opNonmutating(const ::Ice::Context& context, const ::Test::Callback_MyClass_opNonmutatingPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opNonmutating(context, cb, cookie);
    }

    void end_opNonmutating(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_opNonmutating(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Ice::Byte opByte1(::Ice::Byte opByte1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opByte1(_iceI_begin_opByte1(opByte1, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opByte1(::Ice::Byte opByte1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opByte1(opByte1, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opByte1(::Ice::Byte opByte1, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByte1(opByte1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opByte1(::Ice::Byte opByte1, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByte1(opByte1, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opByte1(::Ice::Byte opByte1, const ::Test::Callback_MyClass_opByte1Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByte1(opByte1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opByte1(::Ice::Byte opByte1, const ::Ice::Context& context, const ::Test::Callback_MyClass_opByte1Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByte1(opByte1, context, cb, cookie);
    }

    ::Ice::Byte end_opByte1(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_opByte1(::Ice::Byte, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Ice::Short opShort1(::Ice::Short opShort1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opShort1(_iceI_begin_opShort1(opShort1, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opShort1(::Ice::Short opShort1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opShort1(opShort1, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opShort1(::Ice::Short opShort1, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opShort1(opShort1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opShort1(::Ice::Short opShort1, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opShort1(opShort1, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opShort1(::Ice::Short opShort1, const ::Test::Callback_MyClass_opShort1Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opShort1(opShort1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opShort1(::Ice::Short opShort1, const ::Ice::Context& context, const ::Test::Callback_MyClass_opShort1Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opShort1(opShort1, context, cb, cookie);
    }

    ::Ice::Short end_opShort1(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_opShort1(::Ice::Short, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Ice::Int opInt1(::Ice::Int opInt1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opInt1(_iceI_begin_opInt1(opInt1, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opInt1(::Ice::Int opInt1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opInt1(opInt1, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opInt1(::Ice::Int opInt1, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opInt1(opInt1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opInt1(::Ice::Int opInt1, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opInt1(opInt1, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opInt1(::Ice::Int opInt1, const ::Test::Callback_MyClass_opInt1Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opInt1(opInt1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opInt1(::Ice::Int opInt1, const ::Ice::Context& context, const ::Test::Callback_MyClass_opInt1Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opInt1(opInt1, context, cb, cookie);
    }

    ::Ice::Int end_opInt1(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_opInt1(::Ice::Int, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Ice::Long opLong1(::Ice::Long opLong1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opLong1(_iceI_begin_opLong1(opLong1, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opLong1(::Ice::Long opLong1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opLong1(opLong1, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opLong1(::Ice::Long opLong1, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opLong1(opLong1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opLong1(::Ice::Long opLong1, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opLong1(opLong1, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opLong1(::Ice::Long opLong1, const ::Test::Callback_MyClass_opLong1Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opLong1(opLong1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opLong1(::Ice::Long opLong1, const ::Ice::Context& context, const ::Test::Callback_MyClass_opLong1Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opLong1(opLong1, context, cb, cookie);
    }

    ::Ice::Long end_opLong1(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_opLong1(::Ice::Long, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Ice::Float opFloat1(::Ice::Float opFloat1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opFloat1(_iceI_begin_opFloat1(opFloat1, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opFloat1(::Ice::Float opFloat1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opFloat1(opFloat1, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opFloat1(::Ice::Float opFloat1, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opFloat1(opFloat1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opFloat1(::Ice::Float opFloat1, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opFloat1(opFloat1, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opFloat1(::Ice::Float opFloat1, const ::Test::Callback_MyClass_opFloat1Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opFloat1(opFloat1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opFloat1(::Ice::Float opFloat1, const ::Ice::Context& context, const ::Test::Callback_MyClass_opFloat1Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opFloat1(opFloat1, context, cb, cookie);
    }

    ::Ice::Float end_opFloat1(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_opFloat1(::Ice::Float, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Ice::Double opDouble1(::Ice::Double opDouble1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opDouble1(_iceI_begin_opDouble1(opDouble1, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opDouble1(::Ice::Double opDouble1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opDouble1(opDouble1, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opDouble1(::Ice::Double opDouble1, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opDouble1(opDouble1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opDouble1(::Ice::Double opDouble1, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opDouble1(opDouble1, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opDouble1(::Ice::Double opDouble1, const ::Test::Callback_MyClass_opDouble1Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opDouble1(opDouble1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opDouble1(::Ice::Double opDouble1, const ::Ice::Context& context, const ::Test::Callback_MyClass_opDouble1Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opDouble1(opDouble1, context, cb, cookie);
    }

    ::Ice::Double end_opDouble1(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_opDouble1(::Ice::Double, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::std::string opString1(const ::std::string& opString1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opString1(_iceI_begin_opString1(opString1, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opString1(const ::std::string& opString1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opString1(opString1, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opString1(const ::std::string& opString1, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opString1(opString1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opString1(const ::std::string& opString1, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opString1(opString1, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opString1(const ::std::string& opString1, const ::Test::Callback_MyClass_opString1Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opString1(opString1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opString1(const ::std::string& opString1, const ::Ice::Context& context, const ::Test::Callback_MyClass_opString1Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opString1(opString1, context, cb, cookie);
    }

    ::std::string end_opString1(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_opString1(const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::StringS opStringS1(const ::Test::StringS& opStringS1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opStringS1(_iceI_begin_opStringS1(opStringS1, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opStringS1(const ::Test::StringS& opStringS1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opStringS1(opStringS1, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opStringS1(const ::Test::StringS& opStringS1, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringS1(opStringS1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringS1(const ::Test::StringS& opStringS1, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringS1(opStringS1, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringS1(const ::Test::StringS& opStringS1, const ::Test::Callback_MyClass_opStringS1Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringS1(opStringS1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringS1(const ::Test::StringS& opStringS1, const ::Ice::Context& context, const ::Test::Callback_MyClass_opStringS1Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringS1(opStringS1, context, cb, cookie);
    }

    ::Test::StringS end_opStringS1(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_opStringS1(const ::Test::StringS&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::ByteBoolD opByteBoolD1(const ::Test::ByteBoolD& opByteBoolD1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opByteBoolD1(_iceI_begin_opByteBoolD1(opByteBoolD1, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opByteBoolD1(const ::Test::ByteBoolD& opByteBoolD1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opByteBoolD1(opByteBoolD1, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opByteBoolD1(const ::Test::ByteBoolD& opByteBoolD1, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByteBoolD1(opByteBoolD1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opByteBoolD1(const ::Test::ByteBoolD& opByteBoolD1, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByteBoolD1(opByteBoolD1, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opByteBoolD1(const ::Test::ByteBoolD& opByteBoolD1, const ::Test::Callback_MyClass_opByteBoolD1Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByteBoolD1(opByteBoolD1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opByteBoolD1(const ::Test::ByteBoolD& opByteBoolD1, const ::Ice::Context& context, const ::Test::Callback_MyClass_opByteBoolD1Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByteBoolD1(opByteBoolD1, context, cb, cookie);
    }

    ::Test::ByteBoolD end_opByteBoolD1(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_opByteBoolD1(const ::Test::ByteBoolD&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::StringS opStringS2(const ::Test::StringS& stringS, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opStringS2(_iceI_begin_opStringS2(stringS, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opStringS2(const ::Test::StringS& stringS, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opStringS2(stringS, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opStringS2(const ::Test::StringS& stringS, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringS2(stringS, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringS2(const ::Test::StringS& stringS, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringS2(stringS, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringS2(const ::Test::StringS& stringS, const ::Test::Callback_MyClass_opStringS2Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringS2(stringS, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringS2(const ::Test::StringS& stringS, const ::Ice::Context& context, const ::Test::Callback_MyClass_opStringS2Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringS2(stringS, context, cb, cookie);
    }

    ::Test::StringS end_opStringS2(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_opStringS2(const ::Test::StringS&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::ByteBoolD opByteBoolD2(const ::Test::ByteBoolD& byteBoolD, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opByteBoolD2(_iceI_begin_opByteBoolD2(byteBoolD, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opByteBoolD2(const ::Test::ByteBoolD& byteBoolD, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opByteBoolD2(byteBoolD, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opByteBoolD2(const ::Test::ByteBoolD& byteBoolD, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByteBoolD2(byteBoolD, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opByteBoolD2(const ::Test::ByteBoolD& byteBoolD, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByteBoolD2(byteBoolD, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opByteBoolD2(const ::Test::ByteBoolD& byteBoolD, const ::Test::Callback_MyClass_opByteBoolD2Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByteBoolD2(byteBoolD, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opByteBoolD2(const ::Test::ByteBoolD& byteBoolD, const ::Ice::Context& context, const ::Test::Callback_MyClass_opByteBoolD2Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByteBoolD2(byteBoolD, context, cb, cookie);
    }

    ::Test::ByteBoolD end_opByteBoolD2(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_opByteBoolD2(const ::Test::ByteBoolD&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::StringS opStringLiterals(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opStringLiterals(_iceI_begin_opStringLiterals(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opStringLiterals(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opStringLiterals(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opStringLiterals(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringLiterals(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringLiterals(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringLiterals(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringLiterals(const ::Test::Callback_MyClass_opStringLiteralsPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringLiterals(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringLiterals(const ::Ice::Context& context, const ::Test::Callback_MyClass_opStringLiteralsPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringLiterals(context, cb, cookie);
    }

    ::Test::StringS end_opStringLiterals(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_opStringLiterals(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::WStringS opWStringLiterals(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opWStringLiterals(_iceI_begin_opWStringLiterals(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opWStringLiterals(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opWStringLiterals(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opWStringLiterals(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opWStringLiterals(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opWStringLiterals(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opWStringLiterals(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opWStringLiterals(const ::Test::Callback_MyClass_opWStringLiteralsPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opWStringLiterals(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opWStringLiterals(const ::Ice::Context& context, const ::Test::Callback_MyClass_opWStringLiteralsPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opWStringLiterals(context, cb, cookie);
    }

    ::Test::WStringS end_opWStringLiterals(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_opWStringLiterals(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::Structure opMStruct1(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opMStruct1(_iceI_begin_opMStruct1(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opMStruct1(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opMStruct1(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opMStruct1(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opMStruct1(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opMStruct1(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opMStruct1(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opMStruct1(const ::Test::Callback_MyClass_opMStruct1Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opMStruct1(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opMStruct1(const ::Ice::Context& context, const ::Test::Callback_MyClass_opMStruct1Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opMStruct1(context, cb, cookie);
    }

    ::Test::Structure end_opMStruct1(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_opMStruct1(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::Structure opMStruct2(const ::Test::Structure& p1, ::Test::Structure& p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opMStruct2(p2, _iceI_begin_opMStruct2(p1, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opMStruct2(const ::Test::Structure& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opMStruct2(p1, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opMStruct2(const ::Test::Structure& p1, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opMStruct2(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opMStruct2(const ::Test::Structure& p1, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opMStruct2(p1, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opMStruct2(const ::Test::Structure& p1, const ::Test::Callback_MyClass_opMStruct2Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opMStruct2(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opMStruct2(const ::Test::Structure& p1, const ::Ice::Context& context, const ::Test::Callback_MyClass_opMStruct2Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opMStruct2(p1, context, cb, cookie);
    }

    ::Test::Structure end_opMStruct2(::Test::Structure& p2, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opMStruct2(::Test::Structure& iceP_p2, ::Test::Structure& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opMStruct2(const ::Test::Structure&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::StringS opMSeq1(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opMSeq1(_iceI_begin_opMSeq1(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opMSeq1(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opMSeq1(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opMSeq1(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opMSeq1(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opMSeq1(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opMSeq1(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opMSeq1(const ::Test::Callback_MyClass_opMSeq1Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opMSeq1(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opMSeq1(const ::Ice::Context& context, const ::Test::Callback_MyClass_opMSeq1Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opMSeq1(context, cb, cookie);
    }

    ::Test::StringS end_opMSeq1(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_opMSeq1(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::StringS opMSeq2(const ::Test::StringS& p1, ::Test::StringS& p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opMSeq2(p2, _iceI_begin_opMSeq2(p1, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opMSeq2(const ::Test::StringS& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opMSeq2(p1, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opMSeq2(const ::Test::StringS& p1, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opMSeq2(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opMSeq2(const ::Test::StringS& p1, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opMSeq2(p1, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opMSeq2(const ::Test::StringS& p1, const ::Test::Callback_MyClass_opMSeq2Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opMSeq2(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opMSeq2(const ::Test::StringS& p1, const ::Ice::Context& context, const ::Test::Callback_MyClass_opMSeq2Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opMSeq2(p1, context, cb, cookie);
    }

    ::Test::StringS end_opMSeq2(::Test::StringS& p2, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opMSeq2(::Test::StringS& iceP_p2, ::Test::StringS& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opMSeq2(const ::Test::StringS&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::StringStringD opMDict1(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opMDict1(_iceI_begin_opMDict1(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opMDict1(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opMDict1(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opMDict1(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opMDict1(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opMDict1(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opMDict1(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opMDict1(const ::Test::Callback_MyClass_opMDict1Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opMDict1(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opMDict1(const ::Ice::Context& context, const ::Test::Callback_MyClass_opMDict1Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opMDict1(context, cb, cookie);
    }

    ::Test::StringStringD end_opMDict1(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_opMDict1(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::StringStringD opMDict2(const ::Test::StringStringD& p1, ::Test::StringStringD& p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opMDict2(p2, _iceI_begin_opMDict2(p1, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opMDict2(const ::Test::StringStringD& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opMDict2(p1, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opMDict2(const ::Test::StringStringD& p1, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opMDict2(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opMDict2(const ::Test::StringStringD& p1, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opMDict2(p1, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opMDict2(const ::Test::StringStringD& p1, const ::Test::Callback_MyClass_opMDict2Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opMDict2(p1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opMDict2(const ::Test::StringStringD& p1, const ::Ice::Context& context, const ::Test::Callback_MyClass_opMDict2Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opMDict2(p1, context, cb, cookie);
    }

    ::Test::StringStringD end_opMDict2(::Test::StringStringD& p2, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opMDict2(::Test::StringStringD& iceP_p2, ::Test::StringStringD& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opMDict2(const ::Test::StringStringD&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class MyClass1 : public virtual ::Ice::Proxy<MyClass1, ::IceProxy::Ice::Object>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class MyDerivedClass : public virtual ::Ice::Proxy<MyDerivedClass, ::IceProxy::Test::MyClass>
{
public:

    void opDerived(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_opDerived(_iceI_begin_opDerived(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opDerived(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opDerived(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opDerived(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opDerived(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opDerived(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opDerived(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opDerived(const ::Test::Callback_MyDerivedClass_opDerivedPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opDerived(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opDerived(const ::Ice::Context& context, const ::Test::Callback_MyDerivedClass_opDerivedPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opDerived(context, cb, cookie);
    }

    void end_opDerived(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_opDerived(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::MyClass1Ptr opMyClass1(const ::Test::MyClass1Ptr& opMyClass1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opMyClass1(_iceI_begin_opMyClass1(opMyClass1, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opMyClass1(const ::Test::MyClass1Ptr& opMyClass1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opMyClass1(opMyClass1, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opMyClass1(const ::Test::MyClass1Ptr& opMyClass1, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opMyClass1(opMyClass1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opMyClass1(const ::Test::MyClass1Ptr& opMyClass1, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opMyClass1(opMyClass1, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opMyClass1(const ::Test::MyClass1Ptr& opMyClass1, const ::Test::Callback_MyDerivedClass_opMyClass1Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opMyClass1(opMyClass1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opMyClass1(const ::Test::MyClass1Ptr& opMyClass1, const ::Ice::Context& context, const ::Test::Callback_MyDerivedClass_opMyClass1Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opMyClass1(opMyClass1, context, cb, cookie);
    }

    ::Test::MyClass1Ptr end_opMyClass1(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_opMyClass1(const ::Test::MyClass1Ptr&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::MyStruct1 opMyStruct1(const ::Test::MyStruct1& opMyStruct1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opMyStruct1(_iceI_begin_opMyStruct1(opMyStruct1, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opMyStruct1(const ::Test::MyStruct1& opMyStruct1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opMyStruct1(opMyStruct1, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opMyStruct1(const ::Test::MyStruct1& opMyStruct1, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opMyStruct1(opMyStruct1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opMyStruct1(const ::Test::MyStruct1& opMyStruct1, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opMyStruct1(opMyStruct1, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opMyStruct1(const ::Test::MyStruct1& opMyStruct1, const ::Test::Callback_MyDerivedClass_opMyStruct1Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opMyStruct1(opMyStruct1, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opMyStruct1(const ::Test::MyStruct1& opMyStruct1, const ::Ice::Context& context, const ::Test::Callback_MyDerivedClass_opMyStruct1Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opMyStruct1(opMyStruct1, context, cb, cookie);
    }

    ::Test::MyStruct1 end_opMyStruct1(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_opMyStruct1(const ::Test::MyStruct1&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

}

namespace Test2
{

class MyDerivedClass : public virtual ::Ice::Proxy<MyDerivedClass, ::IceProxy::Test::MyClass>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

}

namespace M
{

class A : public virtual ::Ice::Proxy<A, ::IceProxy::Ice::Object>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class Intf : public virtual ::Ice::Proxy<Intf, ::IceProxy::Ice::Object>
{
public:

    void opIntf(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_opIntf(_iceI_begin_opIntf(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opIntf(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opIntf(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opIntf(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opIntf(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opIntf(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opIntf(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opIntf(const ::M::Callback_Intf_opIntfPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opIntf(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opIntf(const ::Ice::Context& context, const ::M::Callback_Intf_opIntfPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opIntf(context, cb, cookie);
    }

    void end_opIntf(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_opIntf(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

/// \cond INTERNAL
class _BBase : public virtual ::IceProxy::M::A, 
               public virtual ::IceProxy::M::Intf
{
public:

    virtual ~_BBase();

protected:

    virtual Object* _newInstance() const = 0;
};
/// \endcond

class B : public virtual ::Ice::Proxy<B, _BBase>
{
public:

    void opB(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_opB(_iceI_begin_opB(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opB(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opB(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opB(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opB(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opB(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opB(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opB(const ::M::Callback_B_opBPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opB(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opB(const ::Ice::Context& context, const ::M::Callback_B_opBPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opB(context, cb, cookie);
    }

    void end_opB(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_opB(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

}

}

namespace Test
{

class MyClass : public virtual ::Ice::Object
{
public:

    typedef MyClassPrx ProxyType;
    typedef MyClassPtr PointerType;

    virtual ~MyClass();

#ifdef ICE_CPP11_COMPILER
    MyClass() = default;
    MyClass(const MyClass&) = default;
    MyClass& operator=(const MyClass&) = default;
#endif

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void shutdown(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_shutdown(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool supportsCompress(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_supportsCompress(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opVoid(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opVoid(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::Ice::Byte opByte(::Ice::Byte p1, ::Ice::Byte p2, ::Ice::Byte& p3, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opByte(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool opBool(bool p1, bool p2, bool& p3, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opBool(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::Ice::Long opShortIntLong(::Ice::Short p1, ::Ice::Int p2, ::Ice::Long p3, ::Ice::Short& p4, ::Ice::Int& p5, ::Ice::Long& p6, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opShortIntLong(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::Ice::Double opFloatDouble(::Ice::Float p1, ::Ice::Double p2, ::Ice::Float& p3, ::Ice::Double& p4, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opFloatDouble(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::std::string opString(const ::std::string& p1, const ::std::string& p2, ::std::string& p3, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opString(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual MyEnum opMyEnum(MyEnum p1, MyEnum& p2, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opMyEnum(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual MyClassPrx opMyClass(const MyClassPrx& p1, MyClassPrx& p2, MyClassPrx& p3, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opMyClass(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual Structure opStruct(const Structure& p1, const Structure& p2, Structure& p3, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opStruct(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ByteS opByteS(const ByteS& p1, const ByteS& p2, ByteS& p3, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opByteS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual BoolS opBoolS(const BoolS& p1, const BoolS& p2, BoolS& p3, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opBoolS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual LongS opShortIntLongS(const ShortS& p1, const IntS& p2, const LongS& p3, ShortS& p4, IntS& p5, LongS& p6, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opShortIntLongS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual DoubleS opFloatDoubleS(const FloatS& p1, const DoubleS& p2, FloatS& p3, DoubleS& p4, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opFloatDoubleS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual StringS opStringS(const StringS& p1, const StringS& p2, StringS& p3, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opStringS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ByteSS opByteSS(const ByteSS& p1, const ByteSS& p2, ByteSS& p3, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opByteSS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual BoolSS opBoolSS(const BoolSS& p1, const BoolSS& p2, BoolSS& p3, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opBoolSS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual LongSS opShortIntLongSS(const ShortSS& p1, const IntSS& p2, const LongSS& p3, ShortSS& p4, IntSS& p5, LongSS& p6, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opShortIntLongSS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual DoubleSS opFloatDoubleSS(const FloatSS& p1, const DoubleSS& p2, FloatSS& p3, DoubleSS& p4, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opFloatDoubleSS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual StringSS opStringSS(const StringSS& p1, const StringSS& p2, StringSS& p3, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opStringSS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual StringSSS opStringSSS(const StringSSS& p1, const StringSSS& p2, StringSSS& p3, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opStringSSS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ByteBoolD opByteBoolD(const ByteBoolD& p1, const ByteBoolD& p2, ByteBoolD& p3, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opByteBoolD(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ShortIntD opShortIntD(const ShortIntD& p1, const ShortIntD& p2, ShortIntD& p3, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opShortIntD(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual LongFloatD opLongFloatD(const LongFloatD& p1, const LongFloatD& p2, LongFloatD& p3, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opLongFloatD(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual StringStringD opStringStringD(const StringStringD& p1, const StringStringD& p2, StringStringD& p3, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opStringStringD(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual StringMyEnumD opStringMyEnumD(const StringMyEnumD& p1, const StringMyEnumD& p2, StringMyEnumD& p3, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opStringMyEnumD(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual MyEnumStringD opMyEnumStringD(const MyEnumStringD& p1, const MyEnumStringD& p2, MyEnumStringD& p3, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opMyEnumStringD(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual MyStructMyEnumD opMyStructMyEnumD(const MyStructMyEnumD& p1, const MyStructMyEnumD& p2, MyStructMyEnumD& p3, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opMyStructMyEnumD(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ByteBoolDS opByteBoolDS(const ByteBoolDS& p1, const ByteBoolDS& p2, ByteBoolDS& p3, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opByteBoolDS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ShortIntDS opShortIntDS(const ShortIntDS& p1, const ShortIntDS& p2, ShortIntDS& p3, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opShortIntDS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual LongFloatDS opLongFloatDS(const LongFloatDS& p1, const LongFloatDS& p2, LongFloatDS& p3, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opLongFloatDS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual StringStringDS opStringStringDS(const StringStringDS& p1, const StringStringDS& p2, StringStringDS& p3, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opStringStringDS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual StringMyEnumDS opStringMyEnumDS(const StringMyEnumDS& p1, const StringMyEnumDS& p2, StringMyEnumDS& p3, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opStringMyEnumDS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual MyEnumStringDS opMyEnumStringDS(const MyEnumStringDS& p1, const MyEnumStringDS& p2, MyEnumStringDS& p3, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opMyEnumStringDS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual MyStructMyEnumDS opMyStructMyEnumDS(const MyStructMyEnumDS& p1, const MyStructMyEnumDS& p2, MyStructMyEnumDS& p3, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opMyStructMyEnumDS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ByteByteSD opByteByteSD(const ByteByteSD& p1, const ByteByteSD& p2, ByteByteSD& p3, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opByteByteSD(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual BoolBoolSD opBoolBoolSD(const BoolBoolSD& p1, const BoolBoolSD& p2, BoolBoolSD& p3, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opBoolBoolSD(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ShortShortSD opShortShortSD(const ShortShortSD& p1, const ShortShortSD& p2, ShortShortSD& p3, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opShortShortSD(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual IntIntSD opIntIntSD(const IntIntSD& p1, const IntIntSD& p2, IntIntSD& p3, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opIntIntSD(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual LongLongSD opLongLongSD(const LongLongSD& p1, const LongLongSD& p2, LongLongSD& p3, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opLongLongSD(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual StringFloatSD opStringFloatSD(const StringFloatSD& p1, const StringFloatSD& p2, StringFloatSD& p3, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opStringFloatSD(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual StringDoubleSD opStringDoubleSD(const StringDoubleSD& p1, const StringDoubleSD& p2, StringDoubleSD& p3, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opStringDoubleSD(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual StringStringSD opStringStringSD(const StringStringSD& p1, const StringStringSD& p2, StringStringSD& p3, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opStringStringSD(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual MyEnumMyEnumSD opMyEnumMyEnumSD(const MyEnumMyEnumSD& p1, const MyEnumMyEnumSD& p2, MyEnumMyEnumSD& p3, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opMyEnumMyEnumSD(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual IntS opIntS(const IntS& s, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opIntS(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opByteSOneway(const ByteS& s, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opByteSOneway(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::Ice::Int opByteSOnewayCallCount(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opByteSOnewayCallCount(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::Ice::Context opContext(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opContext(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opDoubleMarshaling(::Ice::Double p1, const DoubleS& p2, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opDoubleMarshaling(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opIdempotent(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opIdempotent(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void opNonmutating(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opNonmutating(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::Ice::Byte opByte1(::Ice::Byte opByte1, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opByte1(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::Ice::Short opShort1(::Ice::Short opShort1, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opShort1(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::Ice::Int opInt1(::Ice::Int opInt1, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opInt1(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::Ice::Long opLong1(::Ice::Long opLong1, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opLong1(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::Ice::Float opFloat1(::Ice::Float opFloat1, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opFloat1(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::Ice::Double opDouble1(::Ice::Double opDouble1, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opDouble1(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::std::string opString1(const ::std::string& opString1, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opString1(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual StringS opStringS1(const StringS& opStringS1, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opStringS1(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ByteBoolD opByteBoolD1(const ByteBoolD& opByteBoolD1, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opByteBoolD1(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual StringS opStringS2(const StringS& stringS, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opStringS2(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ByteBoolD opByteBoolD2(const ByteBoolD& byteBoolD, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opByteBoolD2(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual StringS opStringLiterals(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opStringLiterals(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual WStringS opWStringLiterals(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opWStringLiterals(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual Structure opMStruct1(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opMStruct1(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual Structure opMStruct2(const Structure& p1, Structure& p2, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opMStruct2(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual StringS opMSeq1(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opMSeq1(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual StringS opMSeq2(const StringS& p1, StringS& p2, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opMSeq2(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual StringStringD opMDict1(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opMDict1(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual StringStringD opMDict2(const StringStringD& p1, StringStringD& p2, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opMDict2(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
inline bool operator==(const MyClass& lhs, const MyClass& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const MyClass& lhs, const MyClass& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class MyClass1 : public virtual ::Ice::Object
{
public:

    typedef MyClass1Prx ProxyType;
    typedef MyClass1Ptr PointerType;

    virtual ~MyClass1();

    MyClass1()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    MyClass1(const ::std::string& tesT, const ::Test::MyClassPrx& myClass, const ::std::string& myClass1) :
        tesT(tesT),
        myClass(myClass),
        myClass1(myClass1)
    {
    }

#ifdef ICE_CPP11_COMPILER
    MyClass1(const MyClass1&) = default;
    MyClass1& operator=(const MyClass1&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    ::std::string tesT;
    ::Test::MyClassPrx myClass;
    ::std::string myClass1;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_MyClass1_init = ::Test::MyClass1::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const MyClass1& lhs, const MyClass1& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const MyClass1& lhs, const MyClass1& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class MyDerivedClass : virtual public MyClass
{
public:

    typedef MyDerivedClassPrx ProxyType;
    typedef MyDerivedClassPtr PointerType;

    virtual ~MyDerivedClass();

#ifdef ICE_CPP11_COMPILER
    MyDerivedClass() = default;
    MyDerivedClass(const MyDerivedClass&) = default;
    MyDerivedClass& operator=(const MyDerivedClass&) = default;
#endif

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void opDerived(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opDerived(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual MyClass1Ptr opMyClass1(const MyClass1Ptr& opMyClass1, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opMyClass1(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual MyStruct1 opMyStruct1(const MyStruct1& opMyStruct1, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opMyStruct1(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
inline bool operator==(const MyDerivedClass& lhs, const MyDerivedClass& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const MyDerivedClass& lhs, const MyDerivedClass& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

}

namespace Test2
{

/**
 * Makes sure that proxy operations are correctly generated when extending an interface from
 * a different module (ICE-7639).
 */
class MyDerivedClass : virtual public ::Test::MyClass
{
public:

    typedef MyDerivedClassPrx ProxyType;
    typedef MyDerivedClassPtr PointerType;

    virtual ~MyDerivedClass();

#ifdef ICE_CPP11_COMPILER
    MyDerivedClass() = default;
    MyDerivedClass(const MyDerivedClass&) = default;
    MyDerivedClass& operator=(const MyDerivedClass&) = default;
#endif

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
inline bool operator==(const MyDerivedClass& lhs, const MyDerivedClass& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const MyDerivedClass& lhs, const MyDerivedClass& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

}

namespace M
{

class A : public virtual ::Ice::Object
{
public:

    typedef APrx ProxyType;
    typedef APtr PointerType;

    virtual ~A();

    A()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit A(::Ice::Int x) :
        x(x)
    {
    }

#ifdef ICE_CPP11_COMPILER
    A(const A&) = default;
    A& operator=(const A&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    ::Ice::Int x;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_A_init = ::M::A::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const A& lhs, const A& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const A& lhs, const A& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class Intf : public virtual ::Ice::Object
{
public:

    typedef IntfPrx ProxyType;
    typedef IntfPtr PointerType;

    virtual ~Intf();

#ifdef ICE_CPP11_COMPILER
    Intf() = default;
    Intf(const Intf&) = default;
    Intf& operator=(const Intf&) = default;
#endif

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void opIntf(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opIntf(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
inline bool operator==(const Intf& lhs, const Intf& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const Intf& lhs, const Intf& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class B : public A,
          virtual public Intf
{
public:

    typedef BPrx ProxyType;
    typedef BPtr PointerType;

    virtual ~B();

    B()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit B(::Ice::Int x) :
        ::M::A(x)
    {
    }

#ifdef ICE_CPP11_COMPILER
    B(const B&) = default;
    B& operator=(const B&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void opB(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opB(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
inline bool operator==(const B& lhs, const B& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const B& lhs, const B& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

}

/// \cond STREAM
namespace Ice
{

template<>
struct StreamableTraits< ::Test::MyEnum>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 2;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits< ::Test::AnotherStruct>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::Test::AnotherStruct, S>
{
    static void write(S* ostr, const ::Test::AnotherStruct& v)
    {
        ostr->write(v.s);
    }
};

template<typename S>
struct StreamReader< ::Test::AnotherStruct, S>
{
    static void read(S* istr, ::Test::AnotherStruct& v)
    {
        istr->read(v.s);
    }
};

template<>
struct StreamableTraits< ::Test::Structure>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 4;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::Test::Structure, S>
{
    static void write(S* ostr, const ::Test::Structure& v)
    {
        ostr->write(v.p);
        ostr->write(v.e);
        ostr->write(v.s);
    }
};

template<typename S>
struct StreamReader< ::Test::Structure, S>
{
    static void read(S* istr, ::Test::Structure& v)
    {
        istr->read(v.p);
        istr->read(v.e);
        istr->read(v.s);
    }
};

template<>
struct StreamableTraits< ::Test::MyStruct>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 8;
    static const bool fixedLength = true;
};

template<typename S>
struct StreamWriter< ::Test::MyStruct, S>
{
    static void write(S* ostr, const ::Test::MyStruct& v)
    {
        ostr->write(v.i);
        ostr->write(v.j);
    }
};

template<typename S>
struct StreamReader< ::Test::MyStruct, S>
{
    static void read(S* istr, ::Test::MyStruct& v)
    {
        istr->read(v.i);
        istr->read(v.j);
    }
};

template<>
struct StreamableTraits< ::Test::SomeException>
{
    static const StreamHelperCategory helper = StreamHelperCategoryUserException;
};

template<>
struct StreamableTraits< ::Test::MyStruct1>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 4;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::Test::MyStruct1, S>
{
    static void write(S* ostr, const ::Test::MyStruct1& v)
    {
        ostr->write(v.tesT);
        ostr->write(v.myClass);
        ostr->write(v.myStruct1);
    }
};

template<typename S>
struct StreamReader< ::Test::MyStruct1, S>
{
    static void read(S* istr, ::Test::MyStruct1& v)
    {
        istr->read(v.tesT);
        istr->read(v.myClass);
        istr->read(v.myStruct1);
    }
};

template<typename S>
struct StreamWriter< ::Test::MyClass1, S>
{
    static void write(S* ostr, const ::Test::MyClass1& v)
    {
        ostr->write(v.tesT);
        ostr->write(v.myClass);
        ostr->write(v.myClass1);
    }
};

template<typename S>
struct StreamReader< ::Test::MyClass1, S>
{
    static void read(S* istr, ::Test::MyClass1& v)
    {
        istr->read(v.tesT);
        istr->read(v.myClass);
        istr->read(v.myClass1);
    }
};

}
/// \endcond

/// \cond STREAM
namespace Ice
{

}
/// \endcond

/// \cond STREAM
namespace Ice
{

template<typename S>
struct StreamWriter< ::M::A, S>
{
    static void write(S* ostr, const ::M::A& v)
    {
        ostr->write(v.x);
    }
};

template<typename S>
struct StreamReader< ::M::A, S>
{
    static void read(S* istr, ::M::A& v)
    {
        istr->read(v.x);
    }
};

}
/// \endcond

namespace Test
{

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_shutdown.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_shutdown.
 */
template<class T>
class CallbackNC_MyClass_shutdown : public Callback_MyClass_shutdown_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_MyClass_shutdown(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_shutdown.
 */
template<class T> Callback_MyClass_shutdownPtr
newCallback_MyClass_shutdown(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_shutdown<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_shutdown.
 */
template<class T> Callback_MyClass_shutdownPtr
newCallback_MyClass_shutdown(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_shutdown<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_shutdown.
 */
template<class T> Callback_MyClass_shutdownPtr
newCallback_MyClass_shutdown(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_shutdown<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_shutdown.
 */
template<class T> Callback_MyClass_shutdownPtr
newCallback_MyClass_shutdown(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_shutdown<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_shutdown.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_shutdown.
 */
template<class T, typename CT>
class Callback_MyClass_shutdown : public Callback_MyClass_shutdown_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_MyClass_shutdown(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_shutdown.
 */
template<class T, typename CT> Callback_MyClass_shutdownPtr
newCallback_MyClass_shutdown(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_shutdown<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_shutdown.
 */
template<class T, typename CT> Callback_MyClass_shutdownPtr
newCallback_MyClass_shutdown(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_shutdown<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_shutdown.
 */
template<class T, typename CT> Callback_MyClass_shutdownPtr
newCallback_MyClass_shutdown(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_shutdown<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_shutdown.
 */
template<class T, typename CT> Callback_MyClass_shutdownPtr
newCallback_MyClass_shutdown(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_shutdown<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_supportsCompress.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_supportsCompress.
 */
template<class T>
class CallbackNC_MyClass_supportsCompress : public Callback_MyClass_supportsCompress_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_MyClass_supportsCompress(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_supportsCompress(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_supportsCompress.
 */
template<class T> Callback_MyClass_supportsCompressPtr
newCallback_MyClass_supportsCompress(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_supportsCompress<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_supportsCompress.
 */
template<class T> Callback_MyClass_supportsCompressPtr
newCallback_MyClass_supportsCompress(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_supportsCompress<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_supportsCompress.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_supportsCompress.
 */
template<class T, typename CT>
class Callback_MyClass_supportsCompress : public Callback_MyClass_supportsCompress_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_MyClass_supportsCompress(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_supportsCompress(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_supportsCompress.
 */
template<class T, typename CT> Callback_MyClass_supportsCompressPtr
newCallback_MyClass_supportsCompress(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_supportsCompress<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_supportsCompress.
 */
template<class T, typename CT> Callback_MyClass_supportsCompressPtr
newCallback_MyClass_supportsCompress(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_supportsCompress<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opVoid.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opVoid.
 */
template<class T>
class CallbackNC_MyClass_opVoid : public Callback_MyClass_opVoid_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_MyClass_opVoid(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opVoid.
 */
template<class T> Callback_MyClass_opVoidPtr
newCallback_MyClass_opVoid(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opVoid<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opVoid.
 */
template<class T> Callback_MyClass_opVoidPtr
newCallback_MyClass_opVoid(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opVoid<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opVoid.
 */
template<class T> Callback_MyClass_opVoidPtr
newCallback_MyClass_opVoid(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opVoid<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opVoid.
 */
template<class T> Callback_MyClass_opVoidPtr
newCallback_MyClass_opVoid(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opVoid<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opVoid.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opVoid.
 */
template<class T, typename CT>
class Callback_MyClass_opVoid : public Callback_MyClass_opVoid_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_MyClass_opVoid(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opVoid.
 */
template<class T, typename CT> Callback_MyClass_opVoidPtr
newCallback_MyClass_opVoid(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opVoid<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opVoid.
 */
template<class T, typename CT> Callback_MyClass_opVoidPtr
newCallback_MyClass_opVoid(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opVoid<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opVoid.
 */
template<class T, typename CT> Callback_MyClass_opVoidPtr
newCallback_MyClass_opVoid(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opVoid<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opVoid.
 */
template<class T, typename CT> Callback_MyClass_opVoidPtr
newCallback_MyClass_opVoid(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opVoid<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opByte.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opByte.
 */
template<class T>
class CallbackNC_MyClass_opByte : public Callback_MyClass_opByte_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Byte, ::Ice::Byte);

    CallbackNC_MyClass_opByte(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        ::Ice::Byte iceP_p3;
        ::Ice::Byte ret;
        try
        {
            ret = proxy->end_opByte(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p3);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opByte.
 */
template<class T> Callback_MyClass_opBytePtr
newCallback_MyClass_opByte(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Byte, ::Ice::Byte), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opByte<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opByte.
 */
template<class T> Callback_MyClass_opBytePtr
newCallback_MyClass_opByte(T* instance, void (T::*cb)(::Ice::Byte, ::Ice::Byte), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opByte<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opByte.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opByte.
 */
template<class T, typename CT>
class Callback_MyClass_opByte : public Callback_MyClass_opByte_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Byte, ::Ice::Byte, const CT&);

    Callback_MyClass_opByte(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        ::Ice::Byte iceP_p3;
        ::Ice::Byte ret;
        try
        {
            ret = proxy->end_opByte(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p3, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opByte.
 */
template<class T, typename CT> Callback_MyClass_opBytePtr
newCallback_MyClass_opByte(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Byte, ::Ice::Byte, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opByte<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opByte.
 */
template<class T, typename CT> Callback_MyClass_opBytePtr
newCallback_MyClass_opByte(T* instance, void (T::*cb)(::Ice::Byte, ::Ice::Byte, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opByte<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opBool.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opBool.
 */
template<class T>
class CallbackNC_MyClass_opBool : public Callback_MyClass_opBool_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool, bool);

    CallbackNC_MyClass_opBool(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        bool iceP_p3;
        bool ret;
        try
        {
            ret = proxy->end_opBool(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p3);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opBool.
 */
template<class T> Callback_MyClass_opBoolPtr
newCallback_MyClass_opBool(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opBool<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opBool.
 */
template<class T> Callback_MyClass_opBoolPtr
newCallback_MyClass_opBool(T* instance, void (T::*cb)(bool, bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opBool<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opBool.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opBool.
 */
template<class T, typename CT>
class Callback_MyClass_opBool : public Callback_MyClass_opBool_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, bool, const CT&);

    Callback_MyClass_opBool(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        bool iceP_p3;
        bool ret;
        try
        {
            ret = proxy->end_opBool(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p3, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opBool.
 */
template<class T, typename CT> Callback_MyClass_opBoolPtr
newCallback_MyClass_opBool(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opBool<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opBool.
 */
template<class T, typename CT> Callback_MyClass_opBoolPtr
newCallback_MyClass_opBool(T* instance, void (T::*cb)(bool, bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opBool<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opShortIntLong.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opShortIntLong.
 */
template<class T>
class CallbackNC_MyClass_opShortIntLong : public Callback_MyClass_opShortIntLong_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Long, ::Ice::Short, ::Ice::Int, ::Ice::Long);

    CallbackNC_MyClass_opShortIntLong(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        ::Ice::Short iceP_p4;
        ::Ice::Int iceP_p5;
        ::Ice::Long iceP_p6;
        ::Ice::Long ret;
        try
        {
            ret = proxy->end_opShortIntLong(iceP_p4, iceP_p5, iceP_p6, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p4, iceP_p5, iceP_p6);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opShortIntLong.
 */
template<class T> Callback_MyClass_opShortIntLongPtr
newCallback_MyClass_opShortIntLong(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Long, ::Ice::Short, ::Ice::Int, ::Ice::Long), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opShortIntLong<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opShortIntLong.
 */
template<class T> Callback_MyClass_opShortIntLongPtr
newCallback_MyClass_opShortIntLong(T* instance, void (T::*cb)(::Ice::Long, ::Ice::Short, ::Ice::Int, ::Ice::Long), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opShortIntLong<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opShortIntLong.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opShortIntLong.
 */
template<class T, typename CT>
class Callback_MyClass_opShortIntLong : public Callback_MyClass_opShortIntLong_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Long, ::Ice::Short, ::Ice::Int, ::Ice::Long, const CT&);

    Callback_MyClass_opShortIntLong(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        ::Ice::Short iceP_p4;
        ::Ice::Int iceP_p5;
        ::Ice::Long iceP_p6;
        ::Ice::Long ret;
        try
        {
            ret = proxy->end_opShortIntLong(iceP_p4, iceP_p5, iceP_p6, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p4, iceP_p5, iceP_p6, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opShortIntLong.
 */
template<class T, typename CT> Callback_MyClass_opShortIntLongPtr
newCallback_MyClass_opShortIntLong(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Long, ::Ice::Short, ::Ice::Int, ::Ice::Long, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opShortIntLong<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opShortIntLong.
 */
template<class T, typename CT> Callback_MyClass_opShortIntLongPtr
newCallback_MyClass_opShortIntLong(T* instance, void (T::*cb)(::Ice::Long, ::Ice::Short, ::Ice::Int, ::Ice::Long, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opShortIntLong<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opFloatDouble.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opFloatDouble.
 */
template<class T>
class CallbackNC_MyClass_opFloatDouble : public Callback_MyClass_opFloatDouble_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Double, ::Ice::Float, ::Ice::Double);

    CallbackNC_MyClass_opFloatDouble(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        ::Ice::Float iceP_p3;
        ::Ice::Double iceP_p4;
        ::Ice::Double ret;
        try
        {
            ret = proxy->end_opFloatDouble(iceP_p3, iceP_p4, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p3, iceP_p4);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opFloatDouble.
 */
template<class T> Callback_MyClass_opFloatDoublePtr
newCallback_MyClass_opFloatDouble(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Double, ::Ice::Float, ::Ice::Double), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opFloatDouble<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opFloatDouble.
 */
template<class T> Callback_MyClass_opFloatDoublePtr
newCallback_MyClass_opFloatDouble(T* instance, void (T::*cb)(::Ice::Double, ::Ice::Float, ::Ice::Double), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opFloatDouble<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opFloatDouble.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opFloatDouble.
 */
template<class T, typename CT>
class Callback_MyClass_opFloatDouble : public Callback_MyClass_opFloatDouble_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Double, ::Ice::Float, ::Ice::Double, const CT&);

    Callback_MyClass_opFloatDouble(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        ::Ice::Float iceP_p3;
        ::Ice::Double iceP_p4;
        ::Ice::Double ret;
        try
        {
            ret = proxy->end_opFloatDouble(iceP_p3, iceP_p4, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p3, iceP_p4, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opFloatDouble.
 */
template<class T, typename CT> Callback_MyClass_opFloatDoublePtr
newCallback_MyClass_opFloatDouble(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Double, ::Ice::Float, ::Ice::Double, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opFloatDouble<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opFloatDouble.
 */
template<class T, typename CT> Callback_MyClass_opFloatDoublePtr
newCallback_MyClass_opFloatDouble(T* instance, void (T::*cb)(::Ice::Double, ::Ice::Float, ::Ice::Double, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opFloatDouble<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opString.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opString.
 */
template<class T>
class CallbackNC_MyClass_opString : public Callback_MyClass_opString_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&, const ::std::string&);

    CallbackNC_MyClass_opString(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        ::std::string iceP_p3;
        ::std::string ret;
        try
        {
            ret = proxy->end_opString(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p3);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opString.
 */
template<class T> Callback_MyClass_opStringPtr
newCallback_MyClass_opString(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opString<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opString.
 */
template<class T> Callback_MyClass_opStringPtr
newCallback_MyClass_opString(T* instance, void (T::*cb)(const ::std::string&, const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opString<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opString.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opString.
 */
template<class T, typename CT>
class Callback_MyClass_opString : public Callback_MyClass_opString_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const ::std::string&, const CT&);

    Callback_MyClass_opString(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        ::std::string iceP_p3;
        ::std::string ret;
        try
        {
            ret = proxy->end_opString(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p3, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opString.
 */
template<class T, typename CT> Callback_MyClass_opStringPtr
newCallback_MyClass_opString(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opString<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opString.
 */
template<class T, typename CT> Callback_MyClass_opStringPtr
newCallback_MyClass_opString(T* instance, void (T::*cb)(const ::std::string&, const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opString<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opMyEnum.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opMyEnum.
 */
template<class T>
class CallbackNC_MyClass_opMyEnum : public Callback_MyClass_opMyEnum_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(MyEnum, MyEnum);

    CallbackNC_MyClass_opMyEnum(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        MyEnum iceP_p2;
        MyEnum ret;
        try
        {
            ret = proxy->end_opMyEnum(iceP_p2, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p2);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opMyEnum.
 */
template<class T> Callback_MyClass_opMyEnumPtr
newCallback_MyClass_opMyEnum(const IceUtil::Handle<T>& instance, void (T::*cb)(MyEnum, MyEnum), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opMyEnum<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opMyEnum.
 */
template<class T> Callback_MyClass_opMyEnumPtr
newCallback_MyClass_opMyEnum(T* instance, void (T::*cb)(MyEnum, MyEnum), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opMyEnum<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opMyEnum.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opMyEnum.
 */
template<class T, typename CT>
class Callback_MyClass_opMyEnum : public Callback_MyClass_opMyEnum_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(MyEnum, MyEnum, const CT&);

    Callback_MyClass_opMyEnum(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        MyEnum iceP_p2;
        MyEnum ret;
        try
        {
            ret = proxy->end_opMyEnum(iceP_p2, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p2, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opMyEnum.
 */
template<class T, typename CT> Callback_MyClass_opMyEnumPtr
newCallback_MyClass_opMyEnum(const IceUtil::Handle<T>& instance, void (T::*cb)(MyEnum, MyEnum, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opMyEnum<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opMyEnum.
 */
template<class T, typename CT> Callback_MyClass_opMyEnumPtr
newCallback_MyClass_opMyEnum(T* instance, void (T::*cb)(MyEnum, MyEnum, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opMyEnum<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opMyClass.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opMyClass.
 */
template<class T>
class CallbackNC_MyClass_opMyClass : public Callback_MyClass_opMyClass_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const MyClassPrx&, const MyClassPrx&, const MyClassPrx&);

    CallbackNC_MyClass_opMyClass(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        MyClassPrx iceP_p2;
        MyClassPrx iceP_p3;
        MyClassPrx ret;
        try
        {
            ret = proxy->end_opMyClass(iceP_p2, iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p2, iceP_p3);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opMyClass.
 */
template<class T> Callback_MyClass_opMyClassPtr
newCallback_MyClass_opMyClass(const IceUtil::Handle<T>& instance, void (T::*cb)(const MyClassPrx&, const MyClassPrx&, const MyClassPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opMyClass<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opMyClass.
 */
template<class T> Callback_MyClass_opMyClassPtr
newCallback_MyClass_opMyClass(T* instance, void (T::*cb)(const MyClassPrx&, const MyClassPrx&, const MyClassPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opMyClass<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opMyClass.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opMyClass.
 */
template<class T, typename CT>
class Callback_MyClass_opMyClass : public Callback_MyClass_opMyClass_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const MyClassPrx&, const MyClassPrx&, const MyClassPrx&, const CT&);

    Callback_MyClass_opMyClass(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        MyClassPrx iceP_p2;
        MyClassPrx iceP_p3;
        MyClassPrx ret;
        try
        {
            ret = proxy->end_opMyClass(iceP_p2, iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p2, iceP_p3, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opMyClass.
 */
template<class T, typename CT> Callback_MyClass_opMyClassPtr
newCallback_MyClass_opMyClass(const IceUtil::Handle<T>& instance, void (T::*cb)(const MyClassPrx&, const MyClassPrx&, const MyClassPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opMyClass<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opMyClass.
 */
template<class T, typename CT> Callback_MyClass_opMyClassPtr
newCallback_MyClass_opMyClass(T* instance, void (T::*cb)(const MyClassPrx&, const MyClassPrx&, const MyClassPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opMyClass<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opStruct.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opStruct.
 */
template<class T>
class CallbackNC_MyClass_opStruct : public Callback_MyClass_opStruct_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const Structure&, const Structure&);

    CallbackNC_MyClass_opStruct(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        Structure iceP_p3;
        Structure ret;
        try
        {
            ret = proxy->end_opStruct(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p3);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opStruct.
 */
template<class T> Callback_MyClass_opStructPtr
newCallback_MyClass_opStruct(const IceUtil::Handle<T>& instance, void (T::*cb)(const Structure&, const Structure&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opStruct<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opStruct.
 */
template<class T> Callback_MyClass_opStructPtr
newCallback_MyClass_opStruct(T* instance, void (T::*cb)(const Structure&, const Structure&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opStruct<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opStruct.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opStruct.
 */
template<class T, typename CT>
class Callback_MyClass_opStruct : public Callback_MyClass_opStruct_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const Structure&, const Structure&, const CT&);

    Callback_MyClass_opStruct(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        Structure iceP_p3;
        Structure ret;
        try
        {
            ret = proxy->end_opStruct(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p3, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opStruct.
 */
template<class T, typename CT> Callback_MyClass_opStructPtr
newCallback_MyClass_opStruct(const IceUtil::Handle<T>& instance, void (T::*cb)(const Structure&, const Structure&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opStruct<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opStruct.
 */
template<class T, typename CT> Callback_MyClass_opStructPtr
newCallback_MyClass_opStruct(T* instance, void (T::*cb)(const Structure&, const Structure&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opStruct<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opByteS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opByteS.
 */
template<class T>
class CallbackNC_MyClass_opByteS : public Callback_MyClass_opByteS_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ByteS&, const ByteS&);

    CallbackNC_MyClass_opByteS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        ByteS iceP_p3;
        ByteS ret;
        try
        {
            ret = proxy->end_opByteS(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p3);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opByteS.
 */
template<class T> Callback_MyClass_opByteSPtr
newCallback_MyClass_opByteS(const IceUtil::Handle<T>& instance, void (T::*cb)(const ByteS&, const ByteS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opByteS<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opByteS.
 */
template<class T> Callback_MyClass_opByteSPtr
newCallback_MyClass_opByteS(T* instance, void (T::*cb)(const ByteS&, const ByteS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opByteS<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opByteS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opByteS.
 */
template<class T, typename CT>
class Callback_MyClass_opByteS : public Callback_MyClass_opByteS_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ByteS&, const ByteS&, const CT&);

    Callback_MyClass_opByteS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        ByteS iceP_p3;
        ByteS ret;
        try
        {
            ret = proxy->end_opByteS(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p3, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opByteS.
 */
template<class T, typename CT> Callback_MyClass_opByteSPtr
newCallback_MyClass_opByteS(const IceUtil::Handle<T>& instance, void (T::*cb)(const ByteS&, const ByteS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opByteS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opByteS.
 */
template<class T, typename CT> Callback_MyClass_opByteSPtr
newCallback_MyClass_opByteS(T* instance, void (T::*cb)(const ByteS&, const ByteS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opByteS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opBoolS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opBoolS.
 */
template<class T>
class CallbackNC_MyClass_opBoolS : public Callback_MyClass_opBoolS_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const BoolS&, const BoolS&);

    CallbackNC_MyClass_opBoolS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        BoolS iceP_p3;
        BoolS ret;
        try
        {
            ret = proxy->end_opBoolS(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p3);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opBoolS.
 */
template<class T> Callback_MyClass_opBoolSPtr
newCallback_MyClass_opBoolS(const IceUtil::Handle<T>& instance, void (T::*cb)(const BoolS&, const BoolS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opBoolS<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opBoolS.
 */
template<class T> Callback_MyClass_opBoolSPtr
newCallback_MyClass_opBoolS(T* instance, void (T::*cb)(const BoolS&, const BoolS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opBoolS<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opBoolS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opBoolS.
 */
template<class T, typename CT>
class Callback_MyClass_opBoolS : public Callback_MyClass_opBoolS_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const BoolS&, const BoolS&, const CT&);

    Callback_MyClass_opBoolS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        BoolS iceP_p3;
        BoolS ret;
        try
        {
            ret = proxy->end_opBoolS(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p3, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opBoolS.
 */
template<class T, typename CT> Callback_MyClass_opBoolSPtr
newCallback_MyClass_opBoolS(const IceUtil::Handle<T>& instance, void (T::*cb)(const BoolS&, const BoolS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opBoolS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opBoolS.
 */
template<class T, typename CT> Callback_MyClass_opBoolSPtr
newCallback_MyClass_opBoolS(T* instance, void (T::*cb)(const BoolS&, const BoolS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opBoolS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opShortIntLongS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opShortIntLongS.
 */
template<class T>
class CallbackNC_MyClass_opShortIntLongS : public Callback_MyClass_opShortIntLongS_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const LongS&, const ShortS&, const IntS&, const LongS&);

    CallbackNC_MyClass_opShortIntLongS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        ShortS iceP_p4;
        IntS iceP_p5;
        LongS iceP_p6;
        LongS ret;
        try
        {
            ret = proxy->end_opShortIntLongS(iceP_p4, iceP_p5, iceP_p6, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p4, iceP_p5, iceP_p6);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opShortIntLongS.
 */
template<class T> Callback_MyClass_opShortIntLongSPtr
newCallback_MyClass_opShortIntLongS(const IceUtil::Handle<T>& instance, void (T::*cb)(const LongS&, const ShortS&, const IntS&, const LongS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opShortIntLongS<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opShortIntLongS.
 */
template<class T> Callback_MyClass_opShortIntLongSPtr
newCallback_MyClass_opShortIntLongS(T* instance, void (T::*cb)(const LongS&, const ShortS&, const IntS&, const LongS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opShortIntLongS<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opShortIntLongS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opShortIntLongS.
 */
template<class T, typename CT>
class Callback_MyClass_opShortIntLongS : public Callback_MyClass_opShortIntLongS_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const LongS&, const ShortS&, const IntS&, const LongS&, const CT&);

    Callback_MyClass_opShortIntLongS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        ShortS iceP_p4;
        IntS iceP_p5;
        LongS iceP_p6;
        LongS ret;
        try
        {
            ret = proxy->end_opShortIntLongS(iceP_p4, iceP_p5, iceP_p6, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p4, iceP_p5, iceP_p6, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opShortIntLongS.
 */
template<class T, typename CT> Callback_MyClass_opShortIntLongSPtr
newCallback_MyClass_opShortIntLongS(const IceUtil::Handle<T>& instance, void (T::*cb)(const LongS&, const ShortS&, const IntS&, const LongS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opShortIntLongS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opShortIntLongS.
 */
template<class T, typename CT> Callback_MyClass_opShortIntLongSPtr
newCallback_MyClass_opShortIntLongS(T* instance, void (T::*cb)(const LongS&, const ShortS&, const IntS&, const LongS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opShortIntLongS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opFloatDoubleS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opFloatDoubleS.
 */
template<class T>
class CallbackNC_MyClass_opFloatDoubleS : public Callback_MyClass_opFloatDoubleS_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const DoubleS&, const FloatS&, const DoubleS&);

    CallbackNC_MyClass_opFloatDoubleS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        FloatS iceP_p3;
        DoubleS iceP_p4;
        DoubleS ret;
        try
        {
            ret = proxy->end_opFloatDoubleS(iceP_p3, iceP_p4, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p3, iceP_p4);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opFloatDoubleS.
 */
template<class T> Callback_MyClass_opFloatDoubleSPtr
newCallback_MyClass_opFloatDoubleS(const IceUtil::Handle<T>& instance, void (T::*cb)(const DoubleS&, const FloatS&, const DoubleS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opFloatDoubleS<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opFloatDoubleS.
 */
template<class T> Callback_MyClass_opFloatDoubleSPtr
newCallback_MyClass_opFloatDoubleS(T* instance, void (T::*cb)(const DoubleS&, const FloatS&, const DoubleS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opFloatDoubleS<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opFloatDoubleS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opFloatDoubleS.
 */
template<class T, typename CT>
class Callback_MyClass_opFloatDoubleS : public Callback_MyClass_opFloatDoubleS_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const DoubleS&, const FloatS&, const DoubleS&, const CT&);

    Callback_MyClass_opFloatDoubleS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        FloatS iceP_p3;
        DoubleS iceP_p4;
        DoubleS ret;
        try
        {
            ret = proxy->end_opFloatDoubleS(iceP_p3, iceP_p4, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p3, iceP_p4, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opFloatDoubleS.
 */
template<class T, typename CT> Callback_MyClass_opFloatDoubleSPtr
newCallback_MyClass_opFloatDoubleS(const IceUtil::Handle<T>& instance, void (T::*cb)(const DoubleS&, const FloatS&, const DoubleS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opFloatDoubleS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opFloatDoubleS.
 */
template<class T, typename CT> Callback_MyClass_opFloatDoubleSPtr
newCallback_MyClass_opFloatDoubleS(T* instance, void (T::*cb)(const DoubleS&, const FloatS&, const DoubleS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opFloatDoubleS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opStringS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opStringS.
 */
template<class T>
class CallbackNC_MyClass_opStringS : public Callback_MyClass_opStringS_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const StringS&, const StringS&);

    CallbackNC_MyClass_opStringS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        StringS iceP_p3;
        StringS ret;
        try
        {
            ret = proxy->end_opStringS(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p3);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opStringS.
 */
template<class T> Callback_MyClass_opStringSPtr
newCallback_MyClass_opStringS(const IceUtil::Handle<T>& instance, void (T::*cb)(const StringS&, const StringS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opStringS<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opStringS.
 */
template<class T> Callback_MyClass_opStringSPtr
newCallback_MyClass_opStringS(T* instance, void (T::*cb)(const StringS&, const StringS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opStringS<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opStringS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opStringS.
 */
template<class T, typename CT>
class Callback_MyClass_opStringS : public Callback_MyClass_opStringS_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const StringS&, const StringS&, const CT&);

    Callback_MyClass_opStringS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        StringS iceP_p3;
        StringS ret;
        try
        {
            ret = proxy->end_opStringS(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p3, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opStringS.
 */
template<class T, typename CT> Callback_MyClass_opStringSPtr
newCallback_MyClass_opStringS(const IceUtil::Handle<T>& instance, void (T::*cb)(const StringS&, const StringS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opStringS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opStringS.
 */
template<class T, typename CT> Callback_MyClass_opStringSPtr
newCallback_MyClass_opStringS(T* instance, void (T::*cb)(const StringS&, const StringS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opStringS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opByteSS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opByteSS.
 */
template<class T>
class CallbackNC_MyClass_opByteSS : public Callback_MyClass_opByteSS_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ByteSS&, const ByteSS&);

    CallbackNC_MyClass_opByteSS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        ByteSS iceP_p3;
        ByteSS ret;
        try
        {
            ret = proxy->end_opByteSS(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p3);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opByteSS.
 */
template<class T> Callback_MyClass_opByteSSPtr
newCallback_MyClass_opByteSS(const IceUtil::Handle<T>& instance, void (T::*cb)(const ByteSS&, const ByteSS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opByteSS<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opByteSS.
 */
template<class T> Callback_MyClass_opByteSSPtr
newCallback_MyClass_opByteSS(T* instance, void (T::*cb)(const ByteSS&, const ByteSS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opByteSS<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opByteSS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opByteSS.
 */
template<class T, typename CT>
class Callback_MyClass_opByteSS : public Callback_MyClass_opByteSS_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ByteSS&, const ByteSS&, const CT&);

    Callback_MyClass_opByteSS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        ByteSS iceP_p3;
        ByteSS ret;
        try
        {
            ret = proxy->end_opByteSS(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p3, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opByteSS.
 */
template<class T, typename CT> Callback_MyClass_opByteSSPtr
newCallback_MyClass_opByteSS(const IceUtil::Handle<T>& instance, void (T::*cb)(const ByteSS&, const ByteSS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opByteSS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opByteSS.
 */
template<class T, typename CT> Callback_MyClass_opByteSSPtr
newCallback_MyClass_opByteSS(T* instance, void (T::*cb)(const ByteSS&, const ByteSS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opByteSS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opBoolSS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opBoolSS.
 */
template<class T>
class CallbackNC_MyClass_opBoolSS : public Callback_MyClass_opBoolSS_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const BoolSS&, const BoolSS&);

    CallbackNC_MyClass_opBoolSS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        BoolSS iceP_p3;
        BoolSS ret;
        try
        {
            ret = proxy->end_opBoolSS(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p3);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opBoolSS.
 */
template<class T> Callback_MyClass_opBoolSSPtr
newCallback_MyClass_opBoolSS(const IceUtil::Handle<T>& instance, void (T::*cb)(const BoolSS&, const BoolSS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opBoolSS<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opBoolSS.
 */
template<class T> Callback_MyClass_opBoolSSPtr
newCallback_MyClass_opBoolSS(T* instance, void (T::*cb)(const BoolSS&, const BoolSS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opBoolSS<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opBoolSS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opBoolSS.
 */
template<class T, typename CT>
class Callback_MyClass_opBoolSS : public Callback_MyClass_opBoolSS_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const BoolSS&, const BoolSS&, const CT&);

    Callback_MyClass_opBoolSS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        BoolSS iceP_p3;
        BoolSS ret;
        try
        {
            ret = proxy->end_opBoolSS(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p3, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opBoolSS.
 */
template<class T, typename CT> Callback_MyClass_opBoolSSPtr
newCallback_MyClass_opBoolSS(const IceUtil::Handle<T>& instance, void (T::*cb)(const BoolSS&, const BoolSS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opBoolSS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opBoolSS.
 */
template<class T, typename CT> Callback_MyClass_opBoolSSPtr
newCallback_MyClass_opBoolSS(T* instance, void (T::*cb)(const BoolSS&, const BoolSS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opBoolSS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opShortIntLongSS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opShortIntLongSS.
 */
template<class T>
class CallbackNC_MyClass_opShortIntLongSS : public Callback_MyClass_opShortIntLongSS_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const LongSS&, const ShortSS&, const IntSS&, const LongSS&);

    CallbackNC_MyClass_opShortIntLongSS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        ShortSS iceP_p4;
        IntSS iceP_p5;
        LongSS iceP_p6;
        LongSS ret;
        try
        {
            ret = proxy->end_opShortIntLongSS(iceP_p4, iceP_p5, iceP_p6, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p4, iceP_p5, iceP_p6);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opShortIntLongSS.
 */
template<class T> Callback_MyClass_opShortIntLongSSPtr
newCallback_MyClass_opShortIntLongSS(const IceUtil::Handle<T>& instance, void (T::*cb)(const LongSS&, const ShortSS&, const IntSS&, const LongSS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opShortIntLongSS<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opShortIntLongSS.
 */
template<class T> Callback_MyClass_opShortIntLongSSPtr
newCallback_MyClass_opShortIntLongSS(T* instance, void (T::*cb)(const LongSS&, const ShortSS&, const IntSS&, const LongSS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opShortIntLongSS<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opShortIntLongSS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opShortIntLongSS.
 */
template<class T, typename CT>
class Callback_MyClass_opShortIntLongSS : public Callback_MyClass_opShortIntLongSS_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const LongSS&, const ShortSS&, const IntSS&, const LongSS&, const CT&);

    Callback_MyClass_opShortIntLongSS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        ShortSS iceP_p4;
        IntSS iceP_p5;
        LongSS iceP_p6;
        LongSS ret;
        try
        {
            ret = proxy->end_opShortIntLongSS(iceP_p4, iceP_p5, iceP_p6, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p4, iceP_p5, iceP_p6, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opShortIntLongSS.
 */
template<class T, typename CT> Callback_MyClass_opShortIntLongSSPtr
newCallback_MyClass_opShortIntLongSS(const IceUtil::Handle<T>& instance, void (T::*cb)(const LongSS&, const ShortSS&, const IntSS&, const LongSS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opShortIntLongSS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opShortIntLongSS.
 */
template<class T, typename CT> Callback_MyClass_opShortIntLongSSPtr
newCallback_MyClass_opShortIntLongSS(T* instance, void (T::*cb)(const LongSS&, const ShortSS&, const IntSS&, const LongSS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opShortIntLongSS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opFloatDoubleSS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opFloatDoubleSS.
 */
template<class T>
class CallbackNC_MyClass_opFloatDoubleSS : public Callback_MyClass_opFloatDoubleSS_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const DoubleSS&, const FloatSS&, const DoubleSS&);

    CallbackNC_MyClass_opFloatDoubleSS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        FloatSS iceP_p3;
        DoubleSS iceP_p4;
        DoubleSS ret;
        try
        {
            ret = proxy->end_opFloatDoubleSS(iceP_p3, iceP_p4, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p3, iceP_p4);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opFloatDoubleSS.
 */
template<class T> Callback_MyClass_opFloatDoubleSSPtr
newCallback_MyClass_opFloatDoubleSS(const IceUtil::Handle<T>& instance, void (T::*cb)(const DoubleSS&, const FloatSS&, const DoubleSS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opFloatDoubleSS<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opFloatDoubleSS.
 */
template<class T> Callback_MyClass_opFloatDoubleSSPtr
newCallback_MyClass_opFloatDoubleSS(T* instance, void (T::*cb)(const DoubleSS&, const FloatSS&, const DoubleSS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opFloatDoubleSS<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opFloatDoubleSS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opFloatDoubleSS.
 */
template<class T, typename CT>
class Callback_MyClass_opFloatDoubleSS : public Callback_MyClass_opFloatDoubleSS_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const DoubleSS&, const FloatSS&, const DoubleSS&, const CT&);

    Callback_MyClass_opFloatDoubleSS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        FloatSS iceP_p3;
        DoubleSS iceP_p4;
        DoubleSS ret;
        try
        {
            ret = proxy->end_opFloatDoubleSS(iceP_p3, iceP_p4, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p3, iceP_p4, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opFloatDoubleSS.
 */
template<class T, typename CT> Callback_MyClass_opFloatDoubleSSPtr
newCallback_MyClass_opFloatDoubleSS(const IceUtil::Handle<T>& instance, void (T::*cb)(const DoubleSS&, const FloatSS&, const DoubleSS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opFloatDoubleSS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opFloatDoubleSS.
 */
template<class T, typename CT> Callback_MyClass_opFloatDoubleSSPtr
newCallback_MyClass_opFloatDoubleSS(T* instance, void (T::*cb)(const DoubleSS&, const FloatSS&, const DoubleSS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opFloatDoubleSS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opStringSS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opStringSS.
 */
template<class T>
class CallbackNC_MyClass_opStringSS : public Callback_MyClass_opStringSS_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const StringSS&, const StringSS&);

    CallbackNC_MyClass_opStringSS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        StringSS iceP_p3;
        StringSS ret;
        try
        {
            ret = proxy->end_opStringSS(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p3);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opStringSS.
 */
template<class T> Callback_MyClass_opStringSSPtr
newCallback_MyClass_opStringSS(const IceUtil::Handle<T>& instance, void (T::*cb)(const StringSS&, const StringSS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opStringSS<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opStringSS.
 */
template<class T> Callback_MyClass_opStringSSPtr
newCallback_MyClass_opStringSS(T* instance, void (T::*cb)(const StringSS&, const StringSS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opStringSS<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opStringSS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opStringSS.
 */
template<class T, typename CT>
class Callback_MyClass_opStringSS : public Callback_MyClass_opStringSS_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const StringSS&, const StringSS&, const CT&);

    Callback_MyClass_opStringSS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        StringSS iceP_p3;
        StringSS ret;
        try
        {
            ret = proxy->end_opStringSS(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p3, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opStringSS.
 */
template<class T, typename CT> Callback_MyClass_opStringSSPtr
newCallback_MyClass_opStringSS(const IceUtil::Handle<T>& instance, void (T::*cb)(const StringSS&, const StringSS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opStringSS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opStringSS.
 */
template<class T, typename CT> Callback_MyClass_opStringSSPtr
newCallback_MyClass_opStringSS(T* instance, void (T::*cb)(const StringSS&, const StringSS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opStringSS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opStringSSS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opStringSSS.
 */
template<class T>
class CallbackNC_MyClass_opStringSSS : public Callback_MyClass_opStringSSS_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const StringSSS&, const StringSSS&);

    CallbackNC_MyClass_opStringSSS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        StringSSS iceP_p3;
        StringSSS ret;
        try
        {
            ret = proxy->end_opStringSSS(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p3);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opStringSSS.
 */
template<class T> Callback_MyClass_opStringSSSPtr
newCallback_MyClass_opStringSSS(const IceUtil::Handle<T>& instance, void (T::*cb)(const StringSSS&, const StringSSS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opStringSSS<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opStringSSS.
 */
template<class T> Callback_MyClass_opStringSSSPtr
newCallback_MyClass_opStringSSS(T* instance, void (T::*cb)(const StringSSS&, const StringSSS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opStringSSS<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opStringSSS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opStringSSS.
 */
template<class T, typename CT>
class Callback_MyClass_opStringSSS : public Callback_MyClass_opStringSSS_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const StringSSS&, const StringSSS&, const CT&);

    Callback_MyClass_opStringSSS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        StringSSS iceP_p3;
        StringSSS ret;
        try
        {
            ret = proxy->end_opStringSSS(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p3, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opStringSSS.
 */
template<class T, typename CT> Callback_MyClass_opStringSSSPtr
newCallback_MyClass_opStringSSS(const IceUtil::Handle<T>& instance, void (T::*cb)(const StringSSS&, const StringSSS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opStringSSS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opStringSSS.
 */
template<class T, typename CT> Callback_MyClass_opStringSSSPtr
newCallback_MyClass_opStringSSS(T* instance, void (T::*cb)(const StringSSS&, const StringSSS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opStringSSS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opByteBoolD.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opByteBoolD.
 */
template<class T>
class CallbackNC_MyClass_opByteBoolD : public Callback_MyClass_opByteBoolD_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ByteBoolD&, const ByteBoolD&);

    CallbackNC_MyClass_opByteBoolD(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        ByteBoolD iceP_p3;
        ByteBoolD ret;
        try
        {
            ret = proxy->end_opByteBoolD(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p3);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opByteBoolD.
 */
template<class T> Callback_MyClass_opByteBoolDPtr
newCallback_MyClass_opByteBoolD(const IceUtil::Handle<T>& instance, void (T::*cb)(const ByteBoolD&, const ByteBoolD&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opByteBoolD<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opByteBoolD.
 */
template<class T> Callback_MyClass_opByteBoolDPtr
newCallback_MyClass_opByteBoolD(T* instance, void (T::*cb)(const ByteBoolD&, const ByteBoolD&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opByteBoolD<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opByteBoolD.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opByteBoolD.
 */
template<class T, typename CT>
class Callback_MyClass_opByteBoolD : public Callback_MyClass_opByteBoolD_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ByteBoolD&, const ByteBoolD&, const CT&);

    Callback_MyClass_opByteBoolD(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        ByteBoolD iceP_p3;
        ByteBoolD ret;
        try
        {
            ret = proxy->end_opByteBoolD(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p3, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opByteBoolD.
 */
template<class T, typename CT> Callback_MyClass_opByteBoolDPtr
newCallback_MyClass_opByteBoolD(const IceUtil::Handle<T>& instance, void (T::*cb)(const ByteBoolD&, const ByteBoolD&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opByteBoolD<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opByteBoolD.
 */
template<class T, typename CT> Callback_MyClass_opByteBoolDPtr
newCallback_MyClass_opByteBoolD(T* instance, void (T::*cb)(const ByteBoolD&, const ByteBoolD&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opByteBoolD<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opShortIntD.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opShortIntD.
 */
template<class T>
class CallbackNC_MyClass_opShortIntD : public Callback_MyClass_opShortIntD_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ShortIntD&, const ShortIntD&);

    CallbackNC_MyClass_opShortIntD(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        ShortIntD iceP_p3;
        ShortIntD ret;
        try
        {
            ret = proxy->end_opShortIntD(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p3);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opShortIntD.
 */
template<class T> Callback_MyClass_opShortIntDPtr
newCallback_MyClass_opShortIntD(const IceUtil::Handle<T>& instance, void (T::*cb)(const ShortIntD&, const ShortIntD&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opShortIntD<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opShortIntD.
 */
template<class T> Callback_MyClass_opShortIntDPtr
newCallback_MyClass_opShortIntD(T* instance, void (T::*cb)(const ShortIntD&, const ShortIntD&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opShortIntD<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opShortIntD.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opShortIntD.
 */
template<class T, typename CT>
class Callback_MyClass_opShortIntD : public Callback_MyClass_opShortIntD_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ShortIntD&, const ShortIntD&, const CT&);

    Callback_MyClass_opShortIntD(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        ShortIntD iceP_p3;
        ShortIntD ret;
        try
        {
            ret = proxy->end_opShortIntD(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p3, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opShortIntD.
 */
template<class T, typename CT> Callback_MyClass_opShortIntDPtr
newCallback_MyClass_opShortIntD(const IceUtil::Handle<T>& instance, void (T::*cb)(const ShortIntD&, const ShortIntD&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opShortIntD<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opShortIntD.
 */
template<class T, typename CT> Callback_MyClass_opShortIntDPtr
newCallback_MyClass_opShortIntD(T* instance, void (T::*cb)(const ShortIntD&, const ShortIntD&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opShortIntD<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opLongFloatD.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opLongFloatD.
 */
template<class T>
class CallbackNC_MyClass_opLongFloatD : public Callback_MyClass_opLongFloatD_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const LongFloatD&, const LongFloatD&);

    CallbackNC_MyClass_opLongFloatD(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        LongFloatD iceP_p3;
        LongFloatD ret;
        try
        {
            ret = proxy->end_opLongFloatD(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p3);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opLongFloatD.
 */
template<class T> Callback_MyClass_opLongFloatDPtr
newCallback_MyClass_opLongFloatD(const IceUtil::Handle<T>& instance, void (T::*cb)(const LongFloatD&, const LongFloatD&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opLongFloatD<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opLongFloatD.
 */
template<class T> Callback_MyClass_opLongFloatDPtr
newCallback_MyClass_opLongFloatD(T* instance, void (T::*cb)(const LongFloatD&, const LongFloatD&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opLongFloatD<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opLongFloatD.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opLongFloatD.
 */
template<class T, typename CT>
class Callback_MyClass_opLongFloatD : public Callback_MyClass_opLongFloatD_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const LongFloatD&, const LongFloatD&, const CT&);

    Callback_MyClass_opLongFloatD(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        LongFloatD iceP_p3;
        LongFloatD ret;
        try
        {
            ret = proxy->end_opLongFloatD(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p3, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opLongFloatD.
 */
template<class T, typename CT> Callback_MyClass_opLongFloatDPtr
newCallback_MyClass_opLongFloatD(const IceUtil::Handle<T>& instance, void (T::*cb)(const LongFloatD&, const LongFloatD&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opLongFloatD<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opLongFloatD.
 */
template<class T, typename CT> Callback_MyClass_opLongFloatDPtr
newCallback_MyClass_opLongFloatD(T* instance, void (T::*cb)(const LongFloatD&, const LongFloatD&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opLongFloatD<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opStringStringD.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opStringStringD.
 */
template<class T>
class CallbackNC_MyClass_opStringStringD : public Callback_MyClass_opStringStringD_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const StringStringD&, const StringStringD&);

    CallbackNC_MyClass_opStringStringD(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        StringStringD iceP_p3;
        StringStringD ret;
        try
        {
            ret = proxy->end_opStringStringD(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p3);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opStringStringD.
 */
template<class T> Callback_MyClass_opStringStringDPtr
newCallback_MyClass_opStringStringD(const IceUtil::Handle<T>& instance, void (T::*cb)(const StringStringD&, const StringStringD&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opStringStringD<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opStringStringD.
 */
template<class T> Callback_MyClass_opStringStringDPtr
newCallback_MyClass_opStringStringD(T* instance, void (T::*cb)(const StringStringD&, const StringStringD&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opStringStringD<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opStringStringD.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opStringStringD.
 */
template<class T, typename CT>
class Callback_MyClass_opStringStringD : public Callback_MyClass_opStringStringD_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const StringStringD&, const StringStringD&, const CT&);

    Callback_MyClass_opStringStringD(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        StringStringD iceP_p3;
        StringStringD ret;
        try
        {
            ret = proxy->end_opStringStringD(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p3, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opStringStringD.
 */
template<class T, typename CT> Callback_MyClass_opStringStringDPtr
newCallback_MyClass_opStringStringD(const IceUtil::Handle<T>& instance, void (T::*cb)(const StringStringD&, const StringStringD&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opStringStringD<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opStringStringD.
 */
template<class T, typename CT> Callback_MyClass_opStringStringDPtr
newCallback_MyClass_opStringStringD(T* instance, void (T::*cb)(const StringStringD&, const StringStringD&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opStringStringD<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opStringMyEnumD.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opStringMyEnumD.
 */
template<class T>
class CallbackNC_MyClass_opStringMyEnumD : public Callback_MyClass_opStringMyEnumD_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const StringMyEnumD&, const StringMyEnumD&);

    CallbackNC_MyClass_opStringMyEnumD(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        StringMyEnumD iceP_p3;
        StringMyEnumD ret;
        try
        {
            ret = proxy->end_opStringMyEnumD(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p3);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opStringMyEnumD.
 */
template<class T> Callback_MyClass_opStringMyEnumDPtr
newCallback_MyClass_opStringMyEnumD(const IceUtil::Handle<T>& instance, void (T::*cb)(const StringMyEnumD&, const StringMyEnumD&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opStringMyEnumD<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opStringMyEnumD.
 */
template<class T> Callback_MyClass_opStringMyEnumDPtr
newCallback_MyClass_opStringMyEnumD(T* instance, void (T::*cb)(const StringMyEnumD&, const StringMyEnumD&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opStringMyEnumD<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opStringMyEnumD.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opStringMyEnumD.
 */
template<class T, typename CT>
class Callback_MyClass_opStringMyEnumD : public Callback_MyClass_opStringMyEnumD_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const StringMyEnumD&, const StringMyEnumD&, const CT&);

    Callback_MyClass_opStringMyEnumD(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        StringMyEnumD iceP_p3;
        StringMyEnumD ret;
        try
        {
            ret = proxy->end_opStringMyEnumD(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p3, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opStringMyEnumD.
 */
template<class T, typename CT> Callback_MyClass_opStringMyEnumDPtr
newCallback_MyClass_opStringMyEnumD(const IceUtil::Handle<T>& instance, void (T::*cb)(const StringMyEnumD&, const StringMyEnumD&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opStringMyEnumD<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opStringMyEnumD.
 */
template<class T, typename CT> Callback_MyClass_opStringMyEnumDPtr
newCallback_MyClass_opStringMyEnumD(T* instance, void (T::*cb)(const StringMyEnumD&, const StringMyEnumD&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opStringMyEnumD<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opMyEnumStringD.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opMyEnumStringD.
 */
template<class T>
class CallbackNC_MyClass_opMyEnumStringD : public Callback_MyClass_opMyEnumStringD_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const MyEnumStringD&, const MyEnumStringD&);

    CallbackNC_MyClass_opMyEnumStringD(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        MyEnumStringD iceP_p3;
        MyEnumStringD ret;
        try
        {
            ret = proxy->end_opMyEnumStringD(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p3);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opMyEnumStringD.
 */
template<class T> Callback_MyClass_opMyEnumStringDPtr
newCallback_MyClass_opMyEnumStringD(const IceUtil::Handle<T>& instance, void (T::*cb)(const MyEnumStringD&, const MyEnumStringD&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opMyEnumStringD<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opMyEnumStringD.
 */
template<class T> Callback_MyClass_opMyEnumStringDPtr
newCallback_MyClass_opMyEnumStringD(T* instance, void (T::*cb)(const MyEnumStringD&, const MyEnumStringD&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opMyEnumStringD<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opMyEnumStringD.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opMyEnumStringD.
 */
template<class T, typename CT>
class Callback_MyClass_opMyEnumStringD : public Callback_MyClass_opMyEnumStringD_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const MyEnumStringD&, const MyEnumStringD&, const CT&);

    Callback_MyClass_opMyEnumStringD(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        MyEnumStringD iceP_p3;
        MyEnumStringD ret;
        try
        {
            ret = proxy->end_opMyEnumStringD(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p3, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opMyEnumStringD.
 */
template<class T, typename CT> Callback_MyClass_opMyEnumStringDPtr
newCallback_MyClass_opMyEnumStringD(const IceUtil::Handle<T>& instance, void (T::*cb)(const MyEnumStringD&, const MyEnumStringD&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opMyEnumStringD<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opMyEnumStringD.
 */
template<class T, typename CT> Callback_MyClass_opMyEnumStringDPtr
newCallback_MyClass_opMyEnumStringD(T* instance, void (T::*cb)(const MyEnumStringD&, const MyEnumStringD&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opMyEnumStringD<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opMyStructMyEnumD.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opMyStructMyEnumD.
 */
template<class T>
class CallbackNC_MyClass_opMyStructMyEnumD : public Callback_MyClass_opMyStructMyEnumD_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const MyStructMyEnumD&, const MyStructMyEnumD&);

    CallbackNC_MyClass_opMyStructMyEnumD(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        MyStructMyEnumD iceP_p3;
        MyStructMyEnumD ret;
        try
        {
            ret = proxy->end_opMyStructMyEnumD(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p3);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opMyStructMyEnumD.
 */
template<class T> Callback_MyClass_opMyStructMyEnumDPtr
newCallback_MyClass_opMyStructMyEnumD(const IceUtil::Handle<T>& instance, void (T::*cb)(const MyStructMyEnumD&, const MyStructMyEnumD&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opMyStructMyEnumD<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opMyStructMyEnumD.
 */
template<class T> Callback_MyClass_opMyStructMyEnumDPtr
newCallback_MyClass_opMyStructMyEnumD(T* instance, void (T::*cb)(const MyStructMyEnumD&, const MyStructMyEnumD&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opMyStructMyEnumD<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opMyStructMyEnumD.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opMyStructMyEnumD.
 */
template<class T, typename CT>
class Callback_MyClass_opMyStructMyEnumD : public Callback_MyClass_opMyStructMyEnumD_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const MyStructMyEnumD&, const MyStructMyEnumD&, const CT&);

    Callback_MyClass_opMyStructMyEnumD(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        MyStructMyEnumD iceP_p3;
        MyStructMyEnumD ret;
        try
        {
            ret = proxy->end_opMyStructMyEnumD(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p3, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opMyStructMyEnumD.
 */
template<class T, typename CT> Callback_MyClass_opMyStructMyEnumDPtr
newCallback_MyClass_opMyStructMyEnumD(const IceUtil::Handle<T>& instance, void (T::*cb)(const MyStructMyEnumD&, const MyStructMyEnumD&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opMyStructMyEnumD<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opMyStructMyEnumD.
 */
template<class T, typename CT> Callback_MyClass_opMyStructMyEnumDPtr
newCallback_MyClass_opMyStructMyEnumD(T* instance, void (T::*cb)(const MyStructMyEnumD&, const MyStructMyEnumD&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opMyStructMyEnumD<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opByteBoolDS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opByteBoolDS.
 */
template<class T>
class CallbackNC_MyClass_opByteBoolDS : public Callback_MyClass_opByteBoolDS_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ByteBoolDS&, const ByteBoolDS&);

    CallbackNC_MyClass_opByteBoolDS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        ByteBoolDS iceP_p3;
        ByteBoolDS ret;
        try
        {
            ret = proxy->end_opByteBoolDS(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p3);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opByteBoolDS.
 */
template<class T> Callback_MyClass_opByteBoolDSPtr
newCallback_MyClass_opByteBoolDS(const IceUtil::Handle<T>& instance, void (T::*cb)(const ByteBoolDS&, const ByteBoolDS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opByteBoolDS<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opByteBoolDS.
 */
template<class T> Callback_MyClass_opByteBoolDSPtr
newCallback_MyClass_opByteBoolDS(T* instance, void (T::*cb)(const ByteBoolDS&, const ByteBoolDS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opByteBoolDS<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opByteBoolDS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opByteBoolDS.
 */
template<class T, typename CT>
class Callback_MyClass_opByteBoolDS : public Callback_MyClass_opByteBoolDS_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ByteBoolDS&, const ByteBoolDS&, const CT&);

    Callback_MyClass_opByteBoolDS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        ByteBoolDS iceP_p3;
        ByteBoolDS ret;
        try
        {
            ret = proxy->end_opByteBoolDS(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p3, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opByteBoolDS.
 */
template<class T, typename CT> Callback_MyClass_opByteBoolDSPtr
newCallback_MyClass_opByteBoolDS(const IceUtil::Handle<T>& instance, void (T::*cb)(const ByteBoolDS&, const ByteBoolDS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opByteBoolDS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opByteBoolDS.
 */
template<class T, typename CT> Callback_MyClass_opByteBoolDSPtr
newCallback_MyClass_opByteBoolDS(T* instance, void (T::*cb)(const ByteBoolDS&, const ByteBoolDS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opByteBoolDS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opShortIntDS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opShortIntDS.
 */
template<class T>
class CallbackNC_MyClass_opShortIntDS : public Callback_MyClass_opShortIntDS_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ShortIntDS&, const ShortIntDS&);

    CallbackNC_MyClass_opShortIntDS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        ShortIntDS iceP_p3;
        ShortIntDS ret;
        try
        {
            ret = proxy->end_opShortIntDS(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p3);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opShortIntDS.
 */
template<class T> Callback_MyClass_opShortIntDSPtr
newCallback_MyClass_opShortIntDS(const IceUtil::Handle<T>& instance, void (T::*cb)(const ShortIntDS&, const ShortIntDS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opShortIntDS<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opShortIntDS.
 */
template<class T> Callback_MyClass_opShortIntDSPtr
newCallback_MyClass_opShortIntDS(T* instance, void (T::*cb)(const ShortIntDS&, const ShortIntDS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opShortIntDS<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opShortIntDS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opShortIntDS.
 */
template<class T, typename CT>
class Callback_MyClass_opShortIntDS : public Callback_MyClass_opShortIntDS_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ShortIntDS&, const ShortIntDS&, const CT&);

    Callback_MyClass_opShortIntDS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        ShortIntDS iceP_p3;
        ShortIntDS ret;
        try
        {
            ret = proxy->end_opShortIntDS(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p3, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opShortIntDS.
 */
template<class T, typename CT> Callback_MyClass_opShortIntDSPtr
newCallback_MyClass_opShortIntDS(const IceUtil::Handle<T>& instance, void (T::*cb)(const ShortIntDS&, const ShortIntDS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opShortIntDS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opShortIntDS.
 */
template<class T, typename CT> Callback_MyClass_opShortIntDSPtr
newCallback_MyClass_opShortIntDS(T* instance, void (T::*cb)(const ShortIntDS&, const ShortIntDS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opShortIntDS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opLongFloatDS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opLongFloatDS.
 */
template<class T>
class CallbackNC_MyClass_opLongFloatDS : public Callback_MyClass_opLongFloatDS_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const LongFloatDS&, const LongFloatDS&);

    CallbackNC_MyClass_opLongFloatDS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        LongFloatDS iceP_p3;
        LongFloatDS ret;
        try
        {
            ret = proxy->end_opLongFloatDS(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p3);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opLongFloatDS.
 */
template<class T> Callback_MyClass_opLongFloatDSPtr
newCallback_MyClass_opLongFloatDS(const IceUtil::Handle<T>& instance, void (T::*cb)(const LongFloatDS&, const LongFloatDS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opLongFloatDS<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opLongFloatDS.
 */
template<class T> Callback_MyClass_opLongFloatDSPtr
newCallback_MyClass_opLongFloatDS(T* instance, void (T::*cb)(const LongFloatDS&, const LongFloatDS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opLongFloatDS<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opLongFloatDS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opLongFloatDS.
 */
template<class T, typename CT>
class Callback_MyClass_opLongFloatDS : public Callback_MyClass_opLongFloatDS_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const LongFloatDS&, const LongFloatDS&, const CT&);

    Callback_MyClass_opLongFloatDS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        LongFloatDS iceP_p3;
        LongFloatDS ret;
        try
        {
            ret = proxy->end_opLongFloatDS(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p3, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opLongFloatDS.
 */
template<class T, typename CT> Callback_MyClass_opLongFloatDSPtr
newCallback_MyClass_opLongFloatDS(const IceUtil::Handle<T>& instance, void (T::*cb)(const LongFloatDS&, const LongFloatDS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opLongFloatDS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opLongFloatDS.
 */
template<class T, typename CT> Callback_MyClass_opLongFloatDSPtr
newCallback_MyClass_opLongFloatDS(T* instance, void (T::*cb)(const LongFloatDS&, const LongFloatDS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opLongFloatDS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opStringStringDS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opStringStringDS.
 */
template<class T>
class CallbackNC_MyClass_opStringStringDS : public Callback_MyClass_opStringStringDS_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const StringStringDS&, const StringStringDS&);

    CallbackNC_MyClass_opStringStringDS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        StringStringDS iceP_p3;
        StringStringDS ret;
        try
        {
            ret = proxy->end_opStringStringDS(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p3);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opStringStringDS.
 */
template<class T> Callback_MyClass_opStringStringDSPtr
newCallback_MyClass_opStringStringDS(const IceUtil::Handle<T>& instance, void (T::*cb)(const StringStringDS&, const StringStringDS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opStringStringDS<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opStringStringDS.
 */
template<class T> Callback_MyClass_opStringStringDSPtr
newCallback_MyClass_opStringStringDS(T* instance, void (T::*cb)(const StringStringDS&, const StringStringDS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opStringStringDS<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opStringStringDS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opStringStringDS.
 */
template<class T, typename CT>
class Callback_MyClass_opStringStringDS : public Callback_MyClass_opStringStringDS_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const StringStringDS&, const StringStringDS&, const CT&);

    Callback_MyClass_opStringStringDS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        StringStringDS iceP_p3;
        StringStringDS ret;
        try
        {
            ret = proxy->end_opStringStringDS(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p3, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opStringStringDS.
 */
template<class T, typename CT> Callback_MyClass_opStringStringDSPtr
newCallback_MyClass_opStringStringDS(const IceUtil::Handle<T>& instance, void (T::*cb)(const StringStringDS&, const StringStringDS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opStringStringDS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opStringStringDS.
 */
template<class T, typename CT> Callback_MyClass_opStringStringDSPtr
newCallback_MyClass_opStringStringDS(T* instance, void (T::*cb)(const StringStringDS&, const StringStringDS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opStringStringDS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opStringMyEnumDS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opStringMyEnumDS.
 */
template<class T>
class CallbackNC_MyClass_opStringMyEnumDS : public Callback_MyClass_opStringMyEnumDS_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const StringMyEnumDS&, const StringMyEnumDS&);

    CallbackNC_MyClass_opStringMyEnumDS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        StringMyEnumDS iceP_p3;
        StringMyEnumDS ret;
        try
        {
            ret = proxy->end_opStringMyEnumDS(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p3);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opStringMyEnumDS.
 */
template<class T> Callback_MyClass_opStringMyEnumDSPtr
newCallback_MyClass_opStringMyEnumDS(const IceUtil::Handle<T>& instance, void (T::*cb)(const StringMyEnumDS&, const StringMyEnumDS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opStringMyEnumDS<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opStringMyEnumDS.
 */
template<class T> Callback_MyClass_opStringMyEnumDSPtr
newCallback_MyClass_opStringMyEnumDS(T* instance, void (T::*cb)(const StringMyEnumDS&, const StringMyEnumDS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opStringMyEnumDS<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opStringMyEnumDS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opStringMyEnumDS.
 */
template<class T, typename CT>
class Callback_MyClass_opStringMyEnumDS : public Callback_MyClass_opStringMyEnumDS_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const StringMyEnumDS&, const StringMyEnumDS&, const CT&);

    Callback_MyClass_opStringMyEnumDS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        StringMyEnumDS iceP_p3;
        StringMyEnumDS ret;
        try
        {
            ret = proxy->end_opStringMyEnumDS(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p3, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opStringMyEnumDS.
 */
template<class T, typename CT> Callback_MyClass_opStringMyEnumDSPtr
newCallback_MyClass_opStringMyEnumDS(const IceUtil::Handle<T>& instance, void (T::*cb)(const StringMyEnumDS&, const StringMyEnumDS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opStringMyEnumDS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opStringMyEnumDS.
 */
template<class T, typename CT> Callback_MyClass_opStringMyEnumDSPtr
newCallback_MyClass_opStringMyEnumDS(T* instance, void (T::*cb)(const StringMyEnumDS&, const StringMyEnumDS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opStringMyEnumDS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opMyEnumStringDS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opMyEnumStringDS.
 */
template<class T>
class CallbackNC_MyClass_opMyEnumStringDS : public Callback_MyClass_opMyEnumStringDS_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const MyEnumStringDS&, const MyEnumStringDS&);

    CallbackNC_MyClass_opMyEnumStringDS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        MyEnumStringDS iceP_p3;
        MyEnumStringDS ret;
        try
        {
            ret = proxy->end_opMyEnumStringDS(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p3);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opMyEnumStringDS.
 */
template<class T> Callback_MyClass_opMyEnumStringDSPtr
newCallback_MyClass_opMyEnumStringDS(const IceUtil::Handle<T>& instance, void (T::*cb)(const MyEnumStringDS&, const MyEnumStringDS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opMyEnumStringDS<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opMyEnumStringDS.
 */
template<class T> Callback_MyClass_opMyEnumStringDSPtr
newCallback_MyClass_opMyEnumStringDS(T* instance, void (T::*cb)(const MyEnumStringDS&, const MyEnumStringDS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opMyEnumStringDS<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opMyEnumStringDS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opMyEnumStringDS.
 */
template<class T, typename CT>
class Callback_MyClass_opMyEnumStringDS : public Callback_MyClass_opMyEnumStringDS_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const MyEnumStringDS&, const MyEnumStringDS&, const CT&);

    Callback_MyClass_opMyEnumStringDS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        MyEnumStringDS iceP_p3;
        MyEnumStringDS ret;
        try
        {
            ret = proxy->end_opMyEnumStringDS(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p3, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opMyEnumStringDS.
 */
template<class T, typename CT> Callback_MyClass_opMyEnumStringDSPtr
newCallback_MyClass_opMyEnumStringDS(const IceUtil::Handle<T>& instance, void (T::*cb)(const MyEnumStringDS&, const MyEnumStringDS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opMyEnumStringDS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opMyEnumStringDS.
 */
template<class T, typename CT> Callback_MyClass_opMyEnumStringDSPtr
newCallback_MyClass_opMyEnumStringDS(T* instance, void (T::*cb)(const MyEnumStringDS&, const MyEnumStringDS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opMyEnumStringDS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opMyStructMyEnumDS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opMyStructMyEnumDS.
 */
template<class T>
class CallbackNC_MyClass_opMyStructMyEnumDS : public Callback_MyClass_opMyStructMyEnumDS_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const MyStructMyEnumDS&, const MyStructMyEnumDS&);

    CallbackNC_MyClass_opMyStructMyEnumDS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        MyStructMyEnumDS iceP_p3;
        MyStructMyEnumDS ret;
        try
        {
            ret = proxy->end_opMyStructMyEnumDS(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p3);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opMyStructMyEnumDS.
 */
template<class T> Callback_MyClass_opMyStructMyEnumDSPtr
newCallback_MyClass_opMyStructMyEnumDS(const IceUtil::Handle<T>& instance, void (T::*cb)(const MyStructMyEnumDS&, const MyStructMyEnumDS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opMyStructMyEnumDS<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opMyStructMyEnumDS.
 */
template<class T> Callback_MyClass_opMyStructMyEnumDSPtr
newCallback_MyClass_opMyStructMyEnumDS(T* instance, void (T::*cb)(const MyStructMyEnumDS&, const MyStructMyEnumDS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opMyStructMyEnumDS<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opMyStructMyEnumDS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opMyStructMyEnumDS.
 */
template<class T, typename CT>
class Callback_MyClass_opMyStructMyEnumDS : public Callback_MyClass_opMyStructMyEnumDS_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const MyStructMyEnumDS&, const MyStructMyEnumDS&, const CT&);

    Callback_MyClass_opMyStructMyEnumDS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        MyStructMyEnumDS iceP_p3;
        MyStructMyEnumDS ret;
        try
        {
            ret = proxy->end_opMyStructMyEnumDS(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p3, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opMyStructMyEnumDS.
 */
template<class T, typename CT> Callback_MyClass_opMyStructMyEnumDSPtr
newCallback_MyClass_opMyStructMyEnumDS(const IceUtil::Handle<T>& instance, void (T::*cb)(const MyStructMyEnumDS&, const MyStructMyEnumDS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opMyStructMyEnumDS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opMyStructMyEnumDS.
 */
template<class T, typename CT> Callback_MyClass_opMyStructMyEnumDSPtr
newCallback_MyClass_opMyStructMyEnumDS(T* instance, void (T::*cb)(const MyStructMyEnumDS&, const MyStructMyEnumDS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opMyStructMyEnumDS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opByteByteSD.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opByteByteSD.
 */
template<class T>
class CallbackNC_MyClass_opByteByteSD : public Callback_MyClass_opByteByteSD_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ByteByteSD&, const ByteByteSD&);

    CallbackNC_MyClass_opByteByteSD(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        ByteByteSD iceP_p3;
        ByteByteSD ret;
        try
        {
            ret = proxy->end_opByteByteSD(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p3);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opByteByteSD.
 */
template<class T> Callback_MyClass_opByteByteSDPtr
newCallback_MyClass_opByteByteSD(const IceUtil::Handle<T>& instance, void (T::*cb)(const ByteByteSD&, const ByteByteSD&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opByteByteSD<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opByteByteSD.
 */
template<class T> Callback_MyClass_opByteByteSDPtr
newCallback_MyClass_opByteByteSD(T* instance, void (T::*cb)(const ByteByteSD&, const ByteByteSD&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opByteByteSD<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opByteByteSD.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opByteByteSD.
 */
template<class T, typename CT>
class Callback_MyClass_opByteByteSD : public Callback_MyClass_opByteByteSD_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ByteByteSD&, const ByteByteSD&, const CT&);

    Callback_MyClass_opByteByteSD(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        ByteByteSD iceP_p3;
        ByteByteSD ret;
        try
        {
            ret = proxy->end_opByteByteSD(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p3, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opByteByteSD.
 */
template<class T, typename CT> Callback_MyClass_opByteByteSDPtr
newCallback_MyClass_opByteByteSD(const IceUtil::Handle<T>& instance, void (T::*cb)(const ByteByteSD&, const ByteByteSD&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opByteByteSD<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opByteByteSD.
 */
template<class T, typename CT> Callback_MyClass_opByteByteSDPtr
newCallback_MyClass_opByteByteSD(T* instance, void (T::*cb)(const ByteByteSD&, const ByteByteSD&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opByteByteSD<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opBoolBoolSD.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opBoolBoolSD.
 */
template<class T>
class CallbackNC_MyClass_opBoolBoolSD : public Callback_MyClass_opBoolBoolSD_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const BoolBoolSD&, const BoolBoolSD&);

    CallbackNC_MyClass_opBoolBoolSD(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        BoolBoolSD iceP_p3;
        BoolBoolSD ret;
        try
        {
            ret = proxy->end_opBoolBoolSD(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p3);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opBoolBoolSD.
 */
template<class T> Callback_MyClass_opBoolBoolSDPtr
newCallback_MyClass_opBoolBoolSD(const IceUtil::Handle<T>& instance, void (T::*cb)(const BoolBoolSD&, const BoolBoolSD&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opBoolBoolSD<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opBoolBoolSD.
 */
template<class T> Callback_MyClass_opBoolBoolSDPtr
newCallback_MyClass_opBoolBoolSD(T* instance, void (T::*cb)(const BoolBoolSD&, const BoolBoolSD&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opBoolBoolSD<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opBoolBoolSD.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opBoolBoolSD.
 */
template<class T, typename CT>
class Callback_MyClass_opBoolBoolSD : public Callback_MyClass_opBoolBoolSD_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const BoolBoolSD&, const BoolBoolSD&, const CT&);

    Callback_MyClass_opBoolBoolSD(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        BoolBoolSD iceP_p3;
        BoolBoolSD ret;
        try
        {
            ret = proxy->end_opBoolBoolSD(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p3, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opBoolBoolSD.
 */
template<class T, typename CT> Callback_MyClass_opBoolBoolSDPtr
newCallback_MyClass_opBoolBoolSD(const IceUtil::Handle<T>& instance, void (T::*cb)(const BoolBoolSD&, const BoolBoolSD&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opBoolBoolSD<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opBoolBoolSD.
 */
template<class T, typename CT> Callback_MyClass_opBoolBoolSDPtr
newCallback_MyClass_opBoolBoolSD(T* instance, void (T::*cb)(const BoolBoolSD&, const BoolBoolSD&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opBoolBoolSD<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opShortShortSD.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opShortShortSD.
 */
template<class T>
class CallbackNC_MyClass_opShortShortSD : public Callback_MyClass_opShortShortSD_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ShortShortSD&, const ShortShortSD&);

    CallbackNC_MyClass_opShortShortSD(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        ShortShortSD iceP_p3;
        ShortShortSD ret;
        try
        {
            ret = proxy->end_opShortShortSD(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p3);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opShortShortSD.
 */
template<class T> Callback_MyClass_opShortShortSDPtr
newCallback_MyClass_opShortShortSD(const IceUtil::Handle<T>& instance, void (T::*cb)(const ShortShortSD&, const ShortShortSD&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opShortShortSD<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opShortShortSD.
 */
template<class T> Callback_MyClass_opShortShortSDPtr
newCallback_MyClass_opShortShortSD(T* instance, void (T::*cb)(const ShortShortSD&, const ShortShortSD&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opShortShortSD<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opShortShortSD.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opShortShortSD.
 */
template<class T, typename CT>
class Callback_MyClass_opShortShortSD : public Callback_MyClass_opShortShortSD_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ShortShortSD&, const ShortShortSD&, const CT&);

    Callback_MyClass_opShortShortSD(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        ShortShortSD iceP_p3;
        ShortShortSD ret;
        try
        {
            ret = proxy->end_opShortShortSD(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p3, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opShortShortSD.
 */
template<class T, typename CT> Callback_MyClass_opShortShortSDPtr
newCallback_MyClass_opShortShortSD(const IceUtil::Handle<T>& instance, void (T::*cb)(const ShortShortSD&, const ShortShortSD&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opShortShortSD<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opShortShortSD.
 */
template<class T, typename CT> Callback_MyClass_opShortShortSDPtr
newCallback_MyClass_opShortShortSD(T* instance, void (T::*cb)(const ShortShortSD&, const ShortShortSD&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opShortShortSD<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opIntIntSD.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opIntIntSD.
 */
template<class T>
class CallbackNC_MyClass_opIntIntSD : public Callback_MyClass_opIntIntSD_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IntIntSD&, const IntIntSD&);

    CallbackNC_MyClass_opIntIntSD(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        IntIntSD iceP_p3;
        IntIntSD ret;
        try
        {
            ret = proxy->end_opIntIntSD(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p3);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opIntIntSD.
 */
template<class T> Callback_MyClass_opIntIntSDPtr
newCallback_MyClass_opIntIntSD(const IceUtil::Handle<T>& instance, void (T::*cb)(const IntIntSD&, const IntIntSD&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opIntIntSD<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opIntIntSD.
 */
template<class T> Callback_MyClass_opIntIntSDPtr
newCallback_MyClass_opIntIntSD(T* instance, void (T::*cb)(const IntIntSD&, const IntIntSD&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opIntIntSD<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opIntIntSD.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opIntIntSD.
 */
template<class T, typename CT>
class Callback_MyClass_opIntIntSD : public Callback_MyClass_opIntIntSD_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IntIntSD&, const IntIntSD&, const CT&);

    Callback_MyClass_opIntIntSD(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        IntIntSD iceP_p3;
        IntIntSD ret;
        try
        {
            ret = proxy->end_opIntIntSD(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p3, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opIntIntSD.
 */
template<class T, typename CT> Callback_MyClass_opIntIntSDPtr
newCallback_MyClass_opIntIntSD(const IceUtil::Handle<T>& instance, void (T::*cb)(const IntIntSD&, const IntIntSD&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opIntIntSD<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opIntIntSD.
 */
template<class T, typename CT> Callback_MyClass_opIntIntSDPtr
newCallback_MyClass_opIntIntSD(T* instance, void (T::*cb)(const IntIntSD&, const IntIntSD&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opIntIntSD<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opLongLongSD.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opLongLongSD.
 */
template<class T>
class CallbackNC_MyClass_opLongLongSD : public Callback_MyClass_opLongLongSD_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const LongLongSD&, const LongLongSD&);

    CallbackNC_MyClass_opLongLongSD(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        LongLongSD iceP_p3;
        LongLongSD ret;
        try
        {
            ret = proxy->end_opLongLongSD(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p3);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opLongLongSD.
 */
template<class T> Callback_MyClass_opLongLongSDPtr
newCallback_MyClass_opLongLongSD(const IceUtil::Handle<T>& instance, void (T::*cb)(const LongLongSD&, const LongLongSD&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opLongLongSD<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opLongLongSD.
 */
template<class T> Callback_MyClass_opLongLongSDPtr
newCallback_MyClass_opLongLongSD(T* instance, void (T::*cb)(const LongLongSD&, const LongLongSD&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opLongLongSD<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opLongLongSD.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opLongLongSD.
 */
template<class T, typename CT>
class Callback_MyClass_opLongLongSD : public Callback_MyClass_opLongLongSD_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const LongLongSD&, const LongLongSD&, const CT&);

    Callback_MyClass_opLongLongSD(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        LongLongSD iceP_p3;
        LongLongSD ret;
        try
        {
            ret = proxy->end_opLongLongSD(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p3, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opLongLongSD.
 */
template<class T, typename CT> Callback_MyClass_opLongLongSDPtr
newCallback_MyClass_opLongLongSD(const IceUtil::Handle<T>& instance, void (T::*cb)(const LongLongSD&, const LongLongSD&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opLongLongSD<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opLongLongSD.
 */
template<class T, typename CT> Callback_MyClass_opLongLongSDPtr
newCallback_MyClass_opLongLongSD(T* instance, void (T::*cb)(const LongLongSD&, const LongLongSD&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opLongLongSD<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opStringFloatSD.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opStringFloatSD.
 */
template<class T>
class CallbackNC_MyClass_opStringFloatSD : public Callback_MyClass_opStringFloatSD_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const StringFloatSD&, const StringFloatSD&);

    CallbackNC_MyClass_opStringFloatSD(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        StringFloatSD iceP_p3;
        StringFloatSD ret;
        try
        {
            ret = proxy->end_opStringFloatSD(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p3);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opStringFloatSD.
 */
template<class T> Callback_MyClass_opStringFloatSDPtr
newCallback_MyClass_opStringFloatSD(const IceUtil::Handle<T>& instance, void (T::*cb)(const StringFloatSD&, const StringFloatSD&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opStringFloatSD<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opStringFloatSD.
 */
template<class T> Callback_MyClass_opStringFloatSDPtr
newCallback_MyClass_opStringFloatSD(T* instance, void (T::*cb)(const StringFloatSD&, const StringFloatSD&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opStringFloatSD<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opStringFloatSD.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opStringFloatSD.
 */
template<class T, typename CT>
class Callback_MyClass_opStringFloatSD : public Callback_MyClass_opStringFloatSD_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const StringFloatSD&, const StringFloatSD&, const CT&);

    Callback_MyClass_opStringFloatSD(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        StringFloatSD iceP_p3;
        StringFloatSD ret;
        try
        {
            ret = proxy->end_opStringFloatSD(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p3, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opStringFloatSD.
 */
template<class T, typename CT> Callback_MyClass_opStringFloatSDPtr
newCallback_MyClass_opStringFloatSD(const IceUtil::Handle<T>& instance, void (T::*cb)(const StringFloatSD&, const StringFloatSD&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opStringFloatSD<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opStringFloatSD.
 */
template<class T, typename CT> Callback_MyClass_opStringFloatSDPtr
newCallback_MyClass_opStringFloatSD(T* instance, void (T::*cb)(const StringFloatSD&, const StringFloatSD&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opStringFloatSD<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opStringDoubleSD.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opStringDoubleSD.
 */
template<class T>
class CallbackNC_MyClass_opStringDoubleSD : public Callback_MyClass_opStringDoubleSD_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const StringDoubleSD&, const StringDoubleSD&);

    CallbackNC_MyClass_opStringDoubleSD(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        StringDoubleSD iceP_p3;
        StringDoubleSD ret;
        try
        {
            ret = proxy->end_opStringDoubleSD(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p3);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opStringDoubleSD.
 */
template<class T> Callback_MyClass_opStringDoubleSDPtr
newCallback_MyClass_opStringDoubleSD(const IceUtil::Handle<T>& instance, void (T::*cb)(const StringDoubleSD&, const StringDoubleSD&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opStringDoubleSD<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opStringDoubleSD.
 */
template<class T> Callback_MyClass_opStringDoubleSDPtr
newCallback_MyClass_opStringDoubleSD(T* instance, void (T::*cb)(const StringDoubleSD&, const StringDoubleSD&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opStringDoubleSD<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opStringDoubleSD.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opStringDoubleSD.
 */
template<class T, typename CT>
class Callback_MyClass_opStringDoubleSD : public Callback_MyClass_opStringDoubleSD_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const StringDoubleSD&, const StringDoubleSD&, const CT&);

    Callback_MyClass_opStringDoubleSD(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        StringDoubleSD iceP_p3;
        StringDoubleSD ret;
        try
        {
            ret = proxy->end_opStringDoubleSD(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p3, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opStringDoubleSD.
 */
template<class T, typename CT> Callback_MyClass_opStringDoubleSDPtr
newCallback_MyClass_opStringDoubleSD(const IceUtil::Handle<T>& instance, void (T::*cb)(const StringDoubleSD&, const StringDoubleSD&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opStringDoubleSD<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opStringDoubleSD.
 */
template<class T, typename CT> Callback_MyClass_opStringDoubleSDPtr
newCallback_MyClass_opStringDoubleSD(T* instance, void (T::*cb)(const StringDoubleSD&, const StringDoubleSD&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opStringDoubleSD<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opStringStringSD.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opStringStringSD.
 */
template<class T>
class CallbackNC_MyClass_opStringStringSD : public Callback_MyClass_opStringStringSD_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const StringStringSD&, const StringStringSD&);

    CallbackNC_MyClass_opStringStringSD(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        StringStringSD iceP_p3;
        StringStringSD ret;
        try
        {
            ret = proxy->end_opStringStringSD(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p3);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opStringStringSD.
 */
template<class T> Callback_MyClass_opStringStringSDPtr
newCallback_MyClass_opStringStringSD(const IceUtil::Handle<T>& instance, void (T::*cb)(const StringStringSD&, const StringStringSD&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opStringStringSD<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opStringStringSD.
 */
template<class T> Callback_MyClass_opStringStringSDPtr
newCallback_MyClass_opStringStringSD(T* instance, void (T::*cb)(const StringStringSD&, const StringStringSD&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opStringStringSD<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opStringStringSD.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opStringStringSD.
 */
template<class T, typename CT>
class Callback_MyClass_opStringStringSD : public Callback_MyClass_opStringStringSD_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const StringStringSD&, const StringStringSD&, const CT&);

    Callback_MyClass_opStringStringSD(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        StringStringSD iceP_p3;
        StringStringSD ret;
        try
        {
            ret = proxy->end_opStringStringSD(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p3, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opStringStringSD.
 */
template<class T, typename CT> Callback_MyClass_opStringStringSDPtr
newCallback_MyClass_opStringStringSD(const IceUtil::Handle<T>& instance, void (T::*cb)(const StringStringSD&, const StringStringSD&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opStringStringSD<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opStringStringSD.
 */
template<class T, typename CT> Callback_MyClass_opStringStringSDPtr
newCallback_MyClass_opStringStringSD(T* instance, void (T::*cb)(const StringStringSD&, const StringStringSD&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opStringStringSD<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opMyEnumMyEnumSD.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opMyEnumMyEnumSD.
 */
template<class T>
class CallbackNC_MyClass_opMyEnumMyEnumSD : public Callback_MyClass_opMyEnumMyEnumSD_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const MyEnumMyEnumSD&, const MyEnumMyEnumSD&);

    CallbackNC_MyClass_opMyEnumMyEnumSD(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        MyEnumMyEnumSD iceP_p3;
        MyEnumMyEnumSD ret;
        try
        {
            ret = proxy->end_opMyEnumMyEnumSD(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p3);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opMyEnumMyEnumSD.
 */
template<class T> Callback_MyClass_opMyEnumMyEnumSDPtr
newCallback_MyClass_opMyEnumMyEnumSD(const IceUtil::Handle<T>& instance, void (T::*cb)(const MyEnumMyEnumSD&, const MyEnumMyEnumSD&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opMyEnumMyEnumSD<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opMyEnumMyEnumSD.
 */
template<class T> Callback_MyClass_opMyEnumMyEnumSDPtr
newCallback_MyClass_opMyEnumMyEnumSD(T* instance, void (T::*cb)(const MyEnumMyEnumSD&, const MyEnumMyEnumSD&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opMyEnumMyEnumSD<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opMyEnumMyEnumSD.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opMyEnumMyEnumSD.
 */
template<class T, typename CT>
class Callback_MyClass_opMyEnumMyEnumSD : public Callback_MyClass_opMyEnumMyEnumSD_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const MyEnumMyEnumSD&, const MyEnumMyEnumSD&, const CT&);

    Callback_MyClass_opMyEnumMyEnumSD(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        MyEnumMyEnumSD iceP_p3;
        MyEnumMyEnumSD ret;
        try
        {
            ret = proxy->end_opMyEnumMyEnumSD(iceP_p3, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p3, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opMyEnumMyEnumSD.
 */
template<class T, typename CT> Callback_MyClass_opMyEnumMyEnumSDPtr
newCallback_MyClass_opMyEnumMyEnumSD(const IceUtil::Handle<T>& instance, void (T::*cb)(const MyEnumMyEnumSD&, const MyEnumMyEnumSD&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opMyEnumMyEnumSD<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opMyEnumMyEnumSD.
 */
template<class T, typename CT> Callback_MyClass_opMyEnumMyEnumSDPtr
newCallback_MyClass_opMyEnumMyEnumSD(T* instance, void (T::*cb)(const MyEnumMyEnumSD&, const MyEnumMyEnumSD&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opMyEnumMyEnumSD<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opIntS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opIntS.
 */
template<class T>
class CallbackNC_MyClass_opIntS : public Callback_MyClass_opIntS_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IntS&);

    CallbackNC_MyClass_opIntS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        IntS ret;
        try
        {
            ret = proxy->end_opIntS(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opIntS.
 */
template<class T> Callback_MyClass_opIntSPtr
newCallback_MyClass_opIntS(const IceUtil::Handle<T>& instance, void (T::*cb)(const IntS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opIntS<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opIntS.
 */
template<class T> Callback_MyClass_opIntSPtr
newCallback_MyClass_opIntS(T* instance, void (T::*cb)(const IntS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opIntS<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opIntS.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opIntS.
 */
template<class T, typename CT>
class Callback_MyClass_opIntS : public Callback_MyClass_opIntS_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IntS&, const CT&);

    Callback_MyClass_opIntS(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        IntS ret;
        try
        {
            ret = proxy->end_opIntS(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opIntS.
 */
template<class T, typename CT> Callback_MyClass_opIntSPtr
newCallback_MyClass_opIntS(const IceUtil::Handle<T>& instance, void (T::*cb)(const IntS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opIntS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opIntS.
 */
template<class T, typename CT> Callback_MyClass_opIntSPtr
newCallback_MyClass_opIntS(T* instance, void (T::*cb)(const IntS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opIntS<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opByteSOneway.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opByteSOneway.
 */
template<class T>
class CallbackNC_MyClass_opByteSOneway : public Callback_MyClass_opByteSOneway_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_MyClass_opByteSOneway(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opByteSOneway.
 */
template<class T> Callback_MyClass_opByteSOnewayPtr
newCallback_MyClass_opByteSOneway(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opByteSOneway<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opByteSOneway.
 */
template<class T> Callback_MyClass_opByteSOnewayPtr
newCallback_MyClass_opByteSOneway(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opByteSOneway<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opByteSOneway.
 */
template<class T> Callback_MyClass_opByteSOnewayPtr
newCallback_MyClass_opByteSOneway(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opByteSOneway<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opByteSOneway.
 */
template<class T> Callback_MyClass_opByteSOnewayPtr
newCallback_MyClass_opByteSOneway(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opByteSOneway<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opByteSOneway.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opByteSOneway.
 */
template<class T, typename CT>
class Callback_MyClass_opByteSOneway : public Callback_MyClass_opByteSOneway_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_MyClass_opByteSOneway(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opByteSOneway.
 */
template<class T, typename CT> Callback_MyClass_opByteSOnewayPtr
newCallback_MyClass_opByteSOneway(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opByteSOneway<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opByteSOneway.
 */
template<class T, typename CT> Callback_MyClass_opByteSOnewayPtr
newCallback_MyClass_opByteSOneway(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opByteSOneway<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opByteSOneway.
 */
template<class T, typename CT> Callback_MyClass_opByteSOnewayPtr
newCallback_MyClass_opByteSOneway(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opByteSOneway<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opByteSOneway.
 */
template<class T, typename CT> Callback_MyClass_opByteSOnewayPtr
newCallback_MyClass_opByteSOneway(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opByteSOneway<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opByteSOnewayCallCount.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opByteSOnewayCallCount.
 */
template<class T>
class CallbackNC_MyClass_opByteSOnewayCallCount : public Callback_MyClass_opByteSOnewayCallCount_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int);

    CallbackNC_MyClass_opByteSOnewayCallCount(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        ::Ice::Int ret;
        try
        {
            ret = proxy->end_opByteSOnewayCallCount(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opByteSOnewayCallCount.
 */
template<class T> Callback_MyClass_opByteSOnewayCallCountPtr
newCallback_MyClass_opByteSOnewayCallCount(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opByteSOnewayCallCount<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opByteSOnewayCallCount.
 */
template<class T> Callback_MyClass_opByteSOnewayCallCountPtr
newCallback_MyClass_opByteSOnewayCallCount(T* instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opByteSOnewayCallCount<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opByteSOnewayCallCount.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opByteSOnewayCallCount.
 */
template<class T, typename CT>
class Callback_MyClass_opByteSOnewayCallCount : public Callback_MyClass_opByteSOnewayCallCount_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const CT&);

    Callback_MyClass_opByteSOnewayCallCount(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        ::Ice::Int ret;
        try
        {
            ret = proxy->end_opByteSOnewayCallCount(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opByteSOnewayCallCount.
 */
template<class T, typename CT> Callback_MyClass_opByteSOnewayCallCountPtr
newCallback_MyClass_opByteSOnewayCallCount(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opByteSOnewayCallCount<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opByteSOnewayCallCount.
 */
template<class T, typename CT> Callback_MyClass_opByteSOnewayCallCountPtr
newCallback_MyClass_opByteSOnewayCallCount(T* instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opByteSOnewayCallCount<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opContext.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opContext.
 */
template<class T>
class CallbackNC_MyClass_opContext : public Callback_MyClass_opContext_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Ice::Context&);

    CallbackNC_MyClass_opContext(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        ::Ice::Context ret;
        try
        {
            ret = proxy->end_opContext(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opContext.
 */
template<class T> Callback_MyClass_opContextPtr
newCallback_MyClass_opContext(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Ice::Context&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opContext<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opContext.
 */
template<class T> Callback_MyClass_opContextPtr
newCallback_MyClass_opContext(T* instance, void (T::*cb)(const ::Ice::Context&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opContext<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opContext.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opContext.
 */
template<class T, typename CT>
class Callback_MyClass_opContext : public Callback_MyClass_opContext_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Ice::Context&, const CT&);

    Callback_MyClass_opContext(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        ::Ice::Context ret;
        try
        {
            ret = proxy->end_opContext(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opContext.
 */
template<class T, typename CT> Callback_MyClass_opContextPtr
newCallback_MyClass_opContext(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Ice::Context&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opContext<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opContext.
 */
template<class T, typename CT> Callback_MyClass_opContextPtr
newCallback_MyClass_opContext(T* instance, void (T::*cb)(const ::Ice::Context&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opContext<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opDoubleMarshaling.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opDoubleMarshaling.
 */
template<class T>
class CallbackNC_MyClass_opDoubleMarshaling : public Callback_MyClass_opDoubleMarshaling_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_MyClass_opDoubleMarshaling(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opDoubleMarshaling.
 */
template<class T> Callback_MyClass_opDoubleMarshalingPtr
newCallback_MyClass_opDoubleMarshaling(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opDoubleMarshaling<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opDoubleMarshaling.
 */
template<class T> Callback_MyClass_opDoubleMarshalingPtr
newCallback_MyClass_opDoubleMarshaling(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opDoubleMarshaling<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opDoubleMarshaling.
 */
template<class T> Callback_MyClass_opDoubleMarshalingPtr
newCallback_MyClass_opDoubleMarshaling(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opDoubleMarshaling<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opDoubleMarshaling.
 */
template<class T> Callback_MyClass_opDoubleMarshalingPtr
newCallback_MyClass_opDoubleMarshaling(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opDoubleMarshaling<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opDoubleMarshaling.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opDoubleMarshaling.
 */
template<class T, typename CT>
class Callback_MyClass_opDoubleMarshaling : public Callback_MyClass_opDoubleMarshaling_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_MyClass_opDoubleMarshaling(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opDoubleMarshaling.
 */
template<class T, typename CT> Callback_MyClass_opDoubleMarshalingPtr
newCallback_MyClass_opDoubleMarshaling(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opDoubleMarshaling<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opDoubleMarshaling.
 */
template<class T, typename CT> Callback_MyClass_opDoubleMarshalingPtr
newCallback_MyClass_opDoubleMarshaling(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opDoubleMarshaling<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opDoubleMarshaling.
 */
template<class T, typename CT> Callback_MyClass_opDoubleMarshalingPtr
newCallback_MyClass_opDoubleMarshaling(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opDoubleMarshaling<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opDoubleMarshaling.
 */
template<class T, typename CT> Callback_MyClass_opDoubleMarshalingPtr
newCallback_MyClass_opDoubleMarshaling(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opDoubleMarshaling<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opIdempotent.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opIdempotent.
 */
template<class T>
class CallbackNC_MyClass_opIdempotent : public Callback_MyClass_opIdempotent_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_MyClass_opIdempotent(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opIdempotent.
 */
template<class T> Callback_MyClass_opIdempotentPtr
newCallback_MyClass_opIdempotent(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opIdempotent<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opIdempotent.
 */
template<class T> Callback_MyClass_opIdempotentPtr
newCallback_MyClass_opIdempotent(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opIdempotent<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opIdempotent.
 */
template<class T> Callback_MyClass_opIdempotentPtr
newCallback_MyClass_opIdempotent(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opIdempotent<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opIdempotent.
 */
template<class T> Callback_MyClass_opIdempotentPtr
newCallback_MyClass_opIdempotent(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opIdempotent<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opIdempotent.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opIdempotent.
 */
template<class T, typename CT>
class Callback_MyClass_opIdempotent : public Callback_MyClass_opIdempotent_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_MyClass_opIdempotent(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opIdempotent.
 */
template<class T, typename CT> Callback_MyClass_opIdempotentPtr
newCallback_MyClass_opIdempotent(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opIdempotent<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opIdempotent.
 */
template<class T, typename CT> Callback_MyClass_opIdempotentPtr
newCallback_MyClass_opIdempotent(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opIdempotent<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opIdempotent.
 */
template<class T, typename CT> Callback_MyClass_opIdempotentPtr
newCallback_MyClass_opIdempotent(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opIdempotent<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opIdempotent.
 */
template<class T, typename CT> Callback_MyClass_opIdempotentPtr
newCallback_MyClass_opIdempotent(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opIdempotent<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opNonmutating.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opNonmutating.
 */
template<class T>
class CallbackNC_MyClass_opNonmutating : public Callback_MyClass_opNonmutating_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_MyClass_opNonmutating(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opNonmutating.
 */
template<class T> Callback_MyClass_opNonmutatingPtr
newCallback_MyClass_opNonmutating(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opNonmutating<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opNonmutating.
 */
template<class T> Callback_MyClass_opNonmutatingPtr
newCallback_MyClass_opNonmutating(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opNonmutating<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opNonmutating.
 */
template<class T> Callback_MyClass_opNonmutatingPtr
newCallback_MyClass_opNonmutating(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opNonmutating<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opNonmutating.
 */
template<class T> Callback_MyClass_opNonmutatingPtr
newCallback_MyClass_opNonmutating(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opNonmutating<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opNonmutating.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opNonmutating.
 */
template<class T, typename CT>
class Callback_MyClass_opNonmutating : public Callback_MyClass_opNonmutating_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_MyClass_opNonmutating(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opNonmutating.
 */
template<class T, typename CT> Callback_MyClass_opNonmutatingPtr
newCallback_MyClass_opNonmutating(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opNonmutating<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opNonmutating.
 */
template<class T, typename CT> Callback_MyClass_opNonmutatingPtr
newCallback_MyClass_opNonmutating(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opNonmutating<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opNonmutating.
 */
template<class T, typename CT> Callback_MyClass_opNonmutatingPtr
newCallback_MyClass_opNonmutating(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opNonmutating<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opNonmutating.
 */
template<class T, typename CT> Callback_MyClass_opNonmutatingPtr
newCallback_MyClass_opNonmutating(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opNonmutating<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opByte1.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opByte1.
 */
template<class T>
class CallbackNC_MyClass_opByte1 : public Callback_MyClass_opByte1_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Byte);

    CallbackNC_MyClass_opByte1(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        ::Ice::Byte ret;
        try
        {
            ret = proxy->end_opByte1(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opByte1.
 */
template<class T> Callback_MyClass_opByte1Ptr
newCallback_MyClass_opByte1(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Byte), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opByte1<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opByte1.
 */
template<class T> Callback_MyClass_opByte1Ptr
newCallback_MyClass_opByte1(T* instance, void (T::*cb)(::Ice::Byte), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opByte1<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opByte1.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opByte1.
 */
template<class T, typename CT>
class Callback_MyClass_opByte1 : public Callback_MyClass_opByte1_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Byte, const CT&);

    Callback_MyClass_opByte1(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        ::Ice::Byte ret;
        try
        {
            ret = proxy->end_opByte1(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opByte1.
 */
template<class T, typename CT> Callback_MyClass_opByte1Ptr
newCallback_MyClass_opByte1(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Byte, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opByte1<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opByte1.
 */
template<class T, typename CT> Callback_MyClass_opByte1Ptr
newCallback_MyClass_opByte1(T* instance, void (T::*cb)(::Ice::Byte, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opByte1<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opShort1.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opShort1.
 */
template<class T>
class CallbackNC_MyClass_opShort1 : public Callback_MyClass_opShort1_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Short);

    CallbackNC_MyClass_opShort1(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        ::Ice::Short ret;
        try
        {
            ret = proxy->end_opShort1(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opShort1.
 */
template<class T> Callback_MyClass_opShort1Ptr
newCallback_MyClass_opShort1(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Short), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opShort1<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opShort1.
 */
template<class T> Callback_MyClass_opShort1Ptr
newCallback_MyClass_opShort1(T* instance, void (T::*cb)(::Ice::Short), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opShort1<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opShort1.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opShort1.
 */
template<class T, typename CT>
class Callback_MyClass_opShort1 : public Callback_MyClass_opShort1_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Short, const CT&);

    Callback_MyClass_opShort1(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        ::Ice::Short ret;
        try
        {
            ret = proxy->end_opShort1(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opShort1.
 */
template<class T, typename CT> Callback_MyClass_opShort1Ptr
newCallback_MyClass_opShort1(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Short, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opShort1<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opShort1.
 */
template<class T, typename CT> Callback_MyClass_opShort1Ptr
newCallback_MyClass_opShort1(T* instance, void (T::*cb)(::Ice::Short, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opShort1<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opInt1.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opInt1.
 */
template<class T>
class CallbackNC_MyClass_opInt1 : public Callback_MyClass_opInt1_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int);

    CallbackNC_MyClass_opInt1(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        ::Ice::Int ret;
        try
        {
            ret = proxy->end_opInt1(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opInt1.
 */
template<class T> Callback_MyClass_opInt1Ptr
newCallback_MyClass_opInt1(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opInt1<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opInt1.
 */
template<class T> Callback_MyClass_opInt1Ptr
newCallback_MyClass_opInt1(T* instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opInt1<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opInt1.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opInt1.
 */
template<class T, typename CT>
class Callback_MyClass_opInt1 : public Callback_MyClass_opInt1_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const CT&);

    Callback_MyClass_opInt1(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        ::Ice::Int ret;
        try
        {
            ret = proxy->end_opInt1(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opInt1.
 */
template<class T, typename CT> Callback_MyClass_opInt1Ptr
newCallback_MyClass_opInt1(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opInt1<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opInt1.
 */
template<class T, typename CT> Callback_MyClass_opInt1Ptr
newCallback_MyClass_opInt1(T* instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opInt1<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opLong1.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opLong1.
 */
template<class T>
class CallbackNC_MyClass_opLong1 : public Callback_MyClass_opLong1_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Long);

    CallbackNC_MyClass_opLong1(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        ::Ice::Long ret;
        try
        {
            ret = proxy->end_opLong1(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opLong1.
 */
template<class T> Callback_MyClass_opLong1Ptr
newCallback_MyClass_opLong1(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Long), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opLong1<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opLong1.
 */
template<class T> Callback_MyClass_opLong1Ptr
newCallback_MyClass_opLong1(T* instance, void (T::*cb)(::Ice::Long), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opLong1<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opLong1.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opLong1.
 */
template<class T, typename CT>
class Callback_MyClass_opLong1 : public Callback_MyClass_opLong1_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Long, const CT&);

    Callback_MyClass_opLong1(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        ::Ice::Long ret;
        try
        {
            ret = proxy->end_opLong1(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opLong1.
 */
template<class T, typename CT> Callback_MyClass_opLong1Ptr
newCallback_MyClass_opLong1(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Long, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opLong1<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opLong1.
 */
template<class T, typename CT> Callback_MyClass_opLong1Ptr
newCallback_MyClass_opLong1(T* instance, void (T::*cb)(::Ice::Long, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opLong1<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opFloat1.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opFloat1.
 */
template<class T>
class CallbackNC_MyClass_opFloat1 : public Callback_MyClass_opFloat1_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Float);

    CallbackNC_MyClass_opFloat1(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        ::Ice::Float ret;
        try
        {
            ret = proxy->end_opFloat1(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opFloat1.
 */
template<class T> Callback_MyClass_opFloat1Ptr
newCallback_MyClass_opFloat1(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Float), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opFloat1<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opFloat1.
 */
template<class T> Callback_MyClass_opFloat1Ptr
newCallback_MyClass_opFloat1(T* instance, void (T::*cb)(::Ice::Float), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opFloat1<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opFloat1.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opFloat1.
 */
template<class T, typename CT>
class Callback_MyClass_opFloat1 : public Callback_MyClass_opFloat1_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Float, const CT&);

    Callback_MyClass_opFloat1(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        ::Ice::Float ret;
        try
        {
            ret = proxy->end_opFloat1(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opFloat1.
 */
template<class T, typename CT> Callback_MyClass_opFloat1Ptr
newCallback_MyClass_opFloat1(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Float, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opFloat1<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opFloat1.
 */
template<class T, typename CT> Callback_MyClass_opFloat1Ptr
newCallback_MyClass_opFloat1(T* instance, void (T::*cb)(::Ice::Float, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opFloat1<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opDouble1.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opDouble1.
 */
template<class T>
class CallbackNC_MyClass_opDouble1 : public Callback_MyClass_opDouble1_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Double);

    CallbackNC_MyClass_opDouble1(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        ::Ice::Double ret;
        try
        {
            ret = proxy->end_opDouble1(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opDouble1.
 */
template<class T> Callback_MyClass_opDouble1Ptr
newCallback_MyClass_opDouble1(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Double), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opDouble1<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opDouble1.
 */
template<class T> Callback_MyClass_opDouble1Ptr
newCallback_MyClass_opDouble1(T* instance, void (T::*cb)(::Ice::Double), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opDouble1<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opDouble1.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opDouble1.
 */
template<class T, typename CT>
class Callback_MyClass_opDouble1 : public Callback_MyClass_opDouble1_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Double, const CT&);

    Callback_MyClass_opDouble1(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        ::Ice::Double ret;
        try
        {
            ret = proxy->end_opDouble1(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opDouble1.
 */
template<class T, typename CT> Callback_MyClass_opDouble1Ptr
newCallback_MyClass_opDouble1(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Double, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opDouble1<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opDouble1.
 */
template<class T, typename CT> Callback_MyClass_opDouble1Ptr
newCallback_MyClass_opDouble1(T* instance, void (T::*cb)(::Ice::Double, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opDouble1<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opString1.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opString1.
 */
template<class T>
class CallbackNC_MyClass_opString1 : public Callback_MyClass_opString1_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_MyClass_opString1(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        ::std::string ret;
        try
        {
            ret = proxy->end_opString1(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opString1.
 */
template<class T> Callback_MyClass_opString1Ptr
newCallback_MyClass_opString1(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opString1<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opString1.
 */
template<class T> Callback_MyClass_opString1Ptr
newCallback_MyClass_opString1(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opString1<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opString1.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opString1.
 */
template<class T, typename CT>
class Callback_MyClass_opString1 : public Callback_MyClass_opString1_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_MyClass_opString1(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        ::std::string ret;
        try
        {
            ret = proxy->end_opString1(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opString1.
 */
template<class T, typename CT> Callback_MyClass_opString1Ptr
newCallback_MyClass_opString1(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opString1<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opString1.
 */
template<class T, typename CT> Callback_MyClass_opString1Ptr
newCallback_MyClass_opString1(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opString1<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opStringS1.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opStringS1.
 */
template<class T>
class CallbackNC_MyClass_opStringS1 : public Callback_MyClass_opStringS1_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const StringS&);

    CallbackNC_MyClass_opStringS1(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        StringS ret;
        try
        {
            ret = proxy->end_opStringS1(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opStringS1.
 */
template<class T> Callback_MyClass_opStringS1Ptr
newCallback_MyClass_opStringS1(const IceUtil::Handle<T>& instance, void (T::*cb)(const StringS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opStringS1<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opStringS1.
 */
template<class T> Callback_MyClass_opStringS1Ptr
newCallback_MyClass_opStringS1(T* instance, void (T::*cb)(const StringS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opStringS1<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opStringS1.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opStringS1.
 */
template<class T, typename CT>
class Callback_MyClass_opStringS1 : public Callback_MyClass_opStringS1_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const StringS&, const CT&);

    Callback_MyClass_opStringS1(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        StringS ret;
        try
        {
            ret = proxy->end_opStringS1(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opStringS1.
 */
template<class T, typename CT> Callback_MyClass_opStringS1Ptr
newCallback_MyClass_opStringS1(const IceUtil::Handle<T>& instance, void (T::*cb)(const StringS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opStringS1<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opStringS1.
 */
template<class T, typename CT> Callback_MyClass_opStringS1Ptr
newCallback_MyClass_opStringS1(T* instance, void (T::*cb)(const StringS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opStringS1<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opByteBoolD1.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opByteBoolD1.
 */
template<class T>
class CallbackNC_MyClass_opByteBoolD1 : public Callback_MyClass_opByteBoolD1_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ByteBoolD&);

    CallbackNC_MyClass_opByteBoolD1(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        ByteBoolD ret;
        try
        {
            ret = proxy->end_opByteBoolD1(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opByteBoolD1.
 */
template<class T> Callback_MyClass_opByteBoolD1Ptr
newCallback_MyClass_opByteBoolD1(const IceUtil::Handle<T>& instance, void (T::*cb)(const ByteBoolD&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opByteBoolD1<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opByteBoolD1.
 */
template<class T> Callback_MyClass_opByteBoolD1Ptr
newCallback_MyClass_opByteBoolD1(T* instance, void (T::*cb)(const ByteBoolD&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opByteBoolD1<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opByteBoolD1.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opByteBoolD1.
 */
template<class T, typename CT>
class Callback_MyClass_opByteBoolD1 : public Callback_MyClass_opByteBoolD1_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ByteBoolD&, const CT&);

    Callback_MyClass_opByteBoolD1(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        ByteBoolD ret;
        try
        {
            ret = proxy->end_opByteBoolD1(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opByteBoolD1.
 */
template<class T, typename CT> Callback_MyClass_opByteBoolD1Ptr
newCallback_MyClass_opByteBoolD1(const IceUtil::Handle<T>& instance, void (T::*cb)(const ByteBoolD&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opByteBoolD1<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opByteBoolD1.
 */
template<class T, typename CT> Callback_MyClass_opByteBoolD1Ptr
newCallback_MyClass_opByteBoolD1(T* instance, void (T::*cb)(const ByteBoolD&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opByteBoolD1<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opStringS2.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opStringS2.
 */
template<class T>
class CallbackNC_MyClass_opStringS2 : public Callback_MyClass_opStringS2_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const StringS&);

    CallbackNC_MyClass_opStringS2(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        StringS ret;
        try
        {
            ret = proxy->end_opStringS2(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opStringS2.
 */
template<class T> Callback_MyClass_opStringS2Ptr
newCallback_MyClass_opStringS2(const IceUtil::Handle<T>& instance, void (T::*cb)(const StringS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opStringS2<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opStringS2.
 */
template<class T> Callback_MyClass_opStringS2Ptr
newCallback_MyClass_opStringS2(T* instance, void (T::*cb)(const StringS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opStringS2<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opStringS2.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opStringS2.
 */
template<class T, typename CT>
class Callback_MyClass_opStringS2 : public Callback_MyClass_opStringS2_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const StringS&, const CT&);

    Callback_MyClass_opStringS2(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        StringS ret;
        try
        {
            ret = proxy->end_opStringS2(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opStringS2.
 */
template<class T, typename CT> Callback_MyClass_opStringS2Ptr
newCallback_MyClass_opStringS2(const IceUtil::Handle<T>& instance, void (T::*cb)(const StringS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opStringS2<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opStringS2.
 */
template<class T, typename CT> Callback_MyClass_opStringS2Ptr
newCallback_MyClass_opStringS2(T* instance, void (T::*cb)(const StringS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opStringS2<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opByteBoolD2.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opByteBoolD2.
 */
template<class T>
class CallbackNC_MyClass_opByteBoolD2 : public Callback_MyClass_opByteBoolD2_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ByteBoolD&);

    CallbackNC_MyClass_opByteBoolD2(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        ByteBoolD ret;
        try
        {
            ret = proxy->end_opByteBoolD2(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opByteBoolD2.
 */
template<class T> Callback_MyClass_opByteBoolD2Ptr
newCallback_MyClass_opByteBoolD2(const IceUtil::Handle<T>& instance, void (T::*cb)(const ByteBoolD&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opByteBoolD2<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opByteBoolD2.
 */
template<class T> Callback_MyClass_opByteBoolD2Ptr
newCallback_MyClass_opByteBoolD2(T* instance, void (T::*cb)(const ByteBoolD&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opByteBoolD2<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opByteBoolD2.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opByteBoolD2.
 */
template<class T, typename CT>
class Callback_MyClass_opByteBoolD2 : public Callback_MyClass_opByteBoolD2_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ByteBoolD&, const CT&);

    Callback_MyClass_opByteBoolD2(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        ByteBoolD ret;
        try
        {
            ret = proxy->end_opByteBoolD2(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opByteBoolD2.
 */
template<class T, typename CT> Callback_MyClass_opByteBoolD2Ptr
newCallback_MyClass_opByteBoolD2(const IceUtil::Handle<T>& instance, void (T::*cb)(const ByteBoolD&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opByteBoolD2<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opByteBoolD2.
 */
template<class T, typename CT> Callback_MyClass_opByteBoolD2Ptr
newCallback_MyClass_opByteBoolD2(T* instance, void (T::*cb)(const ByteBoolD&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opByteBoolD2<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opStringLiterals.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opStringLiterals.
 */
template<class T>
class CallbackNC_MyClass_opStringLiterals : public Callback_MyClass_opStringLiterals_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const StringS&);

    CallbackNC_MyClass_opStringLiterals(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        StringS ret;
        try
        {
            ret = proxy->end_opStringLiterals(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opStringLiterals.
 */
template<class T> Callback_MyClass_opStringLiteralsPtr
newCallback_MyClass_opStringLiterals(const IceUtil::Handle<T>& instance, void (T::*cb)(const StringS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opStringLiterals<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opStringLiterals.
 */
template<class T> Callback_MyClass_opStringLiteralsPtr
newCallback_MyClass_opStringLiterals(T* instance, void (T::*cb)(const StringS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opStringLiterals<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opStringLiterals.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opStringLiterals.
 */
template<class T, typename CT>
class Callback_MyClass_opStringLiterals : public Callback_MyClass_opStringLiterals_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const StringS&, const CT&);

    Callback_MyClass_opStringLiterals(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        StringS ret;
        try
        {
            ret = proxy->end_opStringLiterals(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opStringLiterals.
 */
template<class T, typename CT> Callback_MyClass_opStringLiteralsPtr
newCallback_MyClass_opStringLiterals(const IceUtil::Handle<T>& instance, void (T::*cb)(const StringS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opStringLiterals<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opStringLiterals.
 */
template<class T, typename CT> Callback_MyClass_opStringLiteralsPtr
newCallback_MyClass_opStringLiterals(T* instance, void (T::*cb)(const StringS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opStringLiterals<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opWStringLiterals.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opWStringLiterals.
 */
template<class T>
class CallbackNC_MyClass_opWStringLiterals : public Callback_MyClass_opWStringLiterals_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const WStringS&);

    CallbackNC_MyClass_opWStringLiterals(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        WStringS ret;
        try
        {
            ret = proxy->end_opWStringLiterals(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opWStringLiterals.
 */
template<class T> Callback_MyClass_opWStringLiteralsPtr
newCallback_MyClass_opWStringLiterals(const IceUtil::Handle<T>& instance, void (T::*cb)(const WStringS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opWStringLiterals<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opWStringLiterals.
 */
template<class T> Callback_MyClass_opWStringLiteralsPtr
newCallback_MyClass_opWStringLiterals(T* instance, void (T::*cb)(const WStringS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opWStringLiterals<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opWStringLiterals.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opWStringLiterals.
 */
template<class T, typename CT>
class Callback_MyClass_opWStringLiterals : public Callback_MyClass_opWStringLiterals_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const WStringS&, const CT&);

    Callback_MyClass_opWStringLiterals(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        WStringS ret;
        try
        {
            ret = proxy->end_opWStringLiterals(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opWStringLiterals.
 */
template<class T, typename CT> Callback_MyClass_opWStringLiteralsPtr
newCallback_MyClass_opWStringLiterals(const IceUtil::Handle<T>& instance, void (T::*cb)(const WStringS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opWStringLiterals<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opWStringLiterals.
 */
template<class T, typename CT> Callback_MyClass_opWStringLiteralsPtr
newCallback_MyClass_opWStringLiterals(T* instance, void (T::*cb)(const WStringS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opWStringLiterals<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opMStruct1.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opMStruct1.
 */
template<class T>
class CallbackNC_MyClass_opMStruct1 : public Callback_MyClass_opMStruct1_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const Structure&);

    CallbackNC_MyClass_opMStruct1(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        Structure ret;
        try
        {
            ret = proxy->end_opMStruct1(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opMStruct1.
 */
template<class T> Callback_MyClass_opMStruct1Ptr
newCallback_MyClass_opMStruct1(const IceUtil::Handle<T>& instance, void (T::*cb)(const Structure&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opMStruct1<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opMStruct1.
 */
template<class T> Callback_MyClass_opMStruct1Ptr
newCallback_MyClass_opMStruct1(T* instance, void (T::*cb)(const Structure&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opMStruct1<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opMStruct1.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opMStruct1.
 */
template<class T, typename CT>
class Callback_MyClass_opMStruct1 : public Callback_MyClass_opMStruct1_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const Structure&, const CT&);

    Callback_MyClass_opMStruct1(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        Structure ret;
        try
        {
            ret = proxy->end_opMStruct1(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opMStruct1.
 */
template<class T, typename CT> Callback_MyClass_opMStruct1Ptr
newCallback_MyClass_opMStruct1(const IceUtil::Handle<T>& instance, void (T::*cb)(const Structure&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opMStruct1<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opMStruct1.
 */
template<class T, typename CT> Callback_MyClass_opMStruct1Ptr
newCallback_MyClass_opMStruct1(T* instance, void (T::*cb)(const Structure&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opMStruct1<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opMStruct2.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opMStruct2.
 */
template<class T>
class CallbackNC_MyClass_opMStruct2 : public Callback_MyClass_opMStruct2_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const Structure&, const Structure&);

    CallbackNC_MyClass_opMStruct2(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        Structure iceP_p2;
        Structure ret;
        try
        {
            ret = proxy->end_opMStruct2(iceP_p2, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p2);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opMStruct2.
 */
template<class T> Callback_MyClass_opMStruct2Ptr
newCallback_MyClass_opMStruct2(const IceUtil::Handle<T>& instance, void (T::*cb)(const Structure&, const Structure&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opMStruct2<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opMStruct2.
 */
template<class T> Callback_MyClass_opMStruct2Ptr
newCallback_MyClass_opMStruct2(T* instance, void (T::*cb)(const Structure&, const Structure&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opMStruct2<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opMStruct2.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opMStruct2.
 */
template<class T, typename CT>
class Callback_MyClass_opMStruct2 : public Callback_MyClass_opMStruct2_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const Structure&, const Structure&, const CT&);

    Callback_MyClass_opMStruct2(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        Structure iceP_p2;
        Structure ret;
        try
        {
            ret = proxy->end_opMStruct2(iceP_p2, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p2, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opMStruct2.
 */
template<class T, typename CT> Callback_MyClass_opMStruct2Ptr
newCallback_MyClass_opMStruct2(const IceUtil::Handle<T>& instance, void (T::*cb)(const Structure&, const Structure&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opMStruct2<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opMStruct2.
 */
template<class T, typename CT> Callback_MyClass_opMStruct2Ptr
newCallback_MyClass_opMStruct2(T* instance, void (T::*cb)(const Structure&, const Structure&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opMStruct2<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opMSeq1.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opMSeq1.
 */
template<class T>
class CallbackNC_MyClass_opMSeq1 : public Callback_MyClass_opMSeq1_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const StringS&);

    CallbackNC_MyClass_opMSeq1(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        StringS ret;
        try
        {
            ret = proxy->end_opMSeq1(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opMSeq1.
 */
template<class T> Callback_MyClass_opMSeq1Ptr
newCallback_MyClass_opMSeq1(const IceUtil::Handle<T>& instance, void (T::*cb)(const StringS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opMSeq1<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opMSeq1.
 */
template<class T> Callback_MyClass_opMSeq1Ptr
newCallback_MyClass_opMSeq1(T* instance, void (T::*cb)(const StringS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opMSeq1<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opMSeq1.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opMSeq1.
 */
template<class T, typename CT>
class Callback_MyClass_opMSeq1 : public Callback_MyClass_opMSeq1_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const StringS&, const CT&);

    Callback_MyClass_opMSeq1(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        StringS ret;
        try
        {
            ret = proxy->end_opMSeq1(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opMSeq1.
 */
template<class T, typename CT> Callback_MyClass_opMSeq1Ptr
newCallback_MyClass_opMSeq1(const IceUtil::Handle<T>& instance, void (T::*cb)(const StringS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opMSeq1<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opMSeq1.
 */
template<class T, typename CT> Callback_MyClass_opMSeq1Ptr
newCallback_MyClass_opMSeq1(T* instance, void (T::*cb)(const StringS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opMSeq1<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opMSeq2.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opMSeq2.
 */
template<class T>
class CallbackNC_MyClass_opMSeq2 : public Callback_MyClass_opMSeq2_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const StringS&, const StringS&);

    CallbackNC_MyClass_opMSeq2(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        StringS iceP_p2;
        StringS ret;
        try
        {
            ret = proxy->end_opMSeq2(iceP_p2, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p2);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opMSeq2.
 */
template<class T> Callback_MyClass_opMSeq2Ptr
newCallback_MyClass_opMSeq2(const IceUtil::Handle<T>& instance, void (T::*cb)(const StringS&, const StringS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opMSeq2<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opMSeq2.
 */
template<class T> Callback_MyClass_opMSeq2Ptr
newCallback_MyClass_opMSeq2(T* instance, void (T::*cb)(const StringS&, const StringS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opMSeq2<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opMSeq2.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opMSeq2.
 */
template<class T, typename CT>
class Callback_MyClass_opMSeq2 : public Callback_MyClass_opMSeq2_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const StringS&, const StringS&, const CT&);

    Callback_MyClass_opMSeq2(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        StringS iceP_p2;
        StringS ret;
        try
        {
            ret = proxy->end_opMSeq2(iceP_p2, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p2, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opMSeq2.
 */
template<class T, typename CT> Callback_MyClass_opMSeq2Ptr
newCallback_MyClass_opMSeq2(const IceUtil::Handle<T>& instance, void (T::*cb)(const StringS&, const StringS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opMSeq2<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opMSeq2.
 */
template<class T, typename CT> Callback_MyClass_opMSeq2Ptr
newCallback_MyClass_opMSeq2(T* instance, void (T::*cb)(const StringS&, const StringS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opMSeq2<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opMDict1.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opMDict1.
 */
template<class T>
class CallbackNC_MyClass_opMDict1 : public Callback_MyClass_opMDict1_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const StringStringD&);

    CallbackNC_MyClass_opMDict1(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        StringStringD ret;
        try
        {
            ret = proxy->end_opMDict1(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opMDict1.
 */
template<class T> Callback_MyClass_opMDict1Ptr
newCallback_MyClass_opMDict1(const IceUtil::Handle<T>& instance, void (T::*cb)(const StringStringD&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opMDict1<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opMDict1.
 */
template<class T> Callback_MyClass_opMDict1Ptr
newCallback_MyClass_opMDict1(T* instance, void (T::*cb)(const StringStringD&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opMDict1<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opMDict1.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opMDict1.
 */
template<class T, typename CT>
class Callback_MyClass_opMDict1 : public Callback_MyClass_opMDict1_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const StringStringD&, const CT&);

    Callback_MyClass_opMDict1(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        StringStringD ret;
        try
        {
            ret = proxy->end_opMDict1(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opMDict1.
 */
template<class T, typename CT> Callback_MyClass_opMDict1Ptr
newCallback_MyClass_opMDict1(const IceUtil::Handle<T>& instance, void (T::*cb)(const StringStringD&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opMDict1<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opMDict1.
 */
template<class T, typename CT> Callback_MyClass_opMDict1Ptr
newCallback_MyClass_opMDict1(T* instance, void (T::*cb)(const StringStringD&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opMDict1<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyClass::begin_opMDict2.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opMDict2.
 */
template<class T>
class CallbackNC_MyClass_opMDict2 : public Callback_MyClass_opMDict2_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const StringStringD&, const StringStringD&);

    CallbackNC_MyClass_opMDict2(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        StringStringD iceP_p2;
        StringStringD ret;
        try
        {
            ret = proxy->end_opMDict2(iceP_p2, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p2);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opMDict2.
 */
template<class T> Callback_MyClass_opMDict2Ptr
newCallback_MyClass_opMDict2(const IceUtil::Handle<T>& instance, void (T::*cb)(const StringStringD&, const StringStringD&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opMDict2<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opMDict2.
 */
template<class T> Callback_MyClass_opMDict2Ptr
newCallback_MyClass_opMDict2(T* instance, void (T::*cb)(const StringStringD&, const StringStringD&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyClass_opMDict2<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyClass::begin_opMDict2.
 * Create a wrapper instance by calling ::Test::newCallback_MyClass_opMDict2.
 */
template<class T, typename CT>
class Callback_MyClass_opMDict2 : public Callback_MyClass_opMDict2_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const StringStringD&, const StringStringD&, const CT&);

    Callback_MyClass_opMDict2(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyClassPrx proxy = MyClassPrx::uncheckedCast(result->getProxy());
        StringStringD iceP_p2;
        StringStringD ret;
        try
        {
            ret = proxy->end_opMDict2(iceP_p2, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p2, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opMDict2.
 */
template<class T, typename CT> Callback_MyClass_opMDict2Ptr
newCallback_MyClass_opMDict2(const IceUtil::Handle<T>& instance, void (T::*cb)(const StringStringD&, const StringStringD&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opMDict2<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyClass::begin_opMDict2.
 */
template<class T, typename CT> Callback_MyClass_opMDict2Ptr
newCallback_MyClass_opMDict2(T* instance, void (T::*cb)(const StringStringD&, const StringStringD&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyClass_opMDict2<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyDerivedClass::begin_opDerived.
 * Create a wrapper instance by calling ::Test::newCallback_MyDerivedClass_opDerived.
 */
template<class T>
class CallbackNC_MyDerivedClass_opDerived : public Callback_MyDerivedClass_opDerived_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_MyDerivedClass_opDerived(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyDerivedClass::begin_opDerived.
 */
template<class T> Callback_MyDerivedClass_opDerivedPtr
newCallback_MyDerivedClass_opDerived(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyDerivedClass_opDerived<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyDerivedClass::begin_opDerived.
 */
template<class T> Callback_MyDerivedClass_opDerivedPtr
newCallback_MyDerivedClass_opDerived(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyDerivedClass_opDerived<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyDerivedClass::begin_opDerived.
 */
template<class T> Callback_MyDerivedClass_opDerivedPtr
newCallback_MyDerivedClass_opDerived(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyDerivedClass_opDerived<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyDerivedClass::begin_opDerived.
 */
template<class T> Callback_MyDerivedClass_opDerivedPtr
newCallback_MyDerivedClass_opDerived(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyDerivedClass_opDerived<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyDerivedClass::begin_opDerived.
 * Create a wrapper instance by calling ::Test::newCallback_MyDerivedClass_opDerived.
 */
template<class T, typename CT>
class Callback_MyDerivedClass_opDerived : public Callback_MyDerivedClass_opDerived_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_MyDerivedClass_opDerived(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyDerivedClass::begin_opDerived.
 */
template<class T, typename CT> Callback_MyDerivedClass_opDerivedPtr
newCallback_MyDerivedClass_opDerived(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyDerivedClass_opDerived<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyDerivedClass::begin_opDerived.
 */
template<class T, typename CT> Callback_MyDerivedClass_opDerivedPtr
newCallback_MyDerivedClass_opDerived(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyDerivedClass_opDerived<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyDerivedClass::begin_opDerived.
 */
template<class T, typename CT> Callback_MyDerivedClass_opDerivedPtr
newCallback_MyDerivedClass_opDerived(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyDerivedClass_opDerived<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyDerivedClass::begin_opDerived.
 */
template<class T, typename CT> Callback_MyDerivedClass_opDerivedPtr
newCallback_MyDerivedClass_opDerived(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyDerivedClass_opDerived<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyDerivedClass::begin_opMyClass1.
 * Create a wrapper instance by calling ::Test::newCallback_MyDerivedClass_opMyClass1.
 */
template<class T>
class CallbackNC_MyDerivedClass_opMyClass1 : public Callback_MyDerivedClass_opMyClass1_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const MyClass1Ptr&);

    CallbackNC_MyDerivedClass_opMyClass1(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyDerivedClassPrx proxy = MyDerivedClassPrx::uncheckedCast(result->getProxy());
        MyClass1Ptr ret;
        try
        {
            ret = proxy->end_opMyClass1(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyDerivedClass::begin_opMyClass1.
 */
template<class T> Callback_MyDerivedClass_opMyClass1Ptr
newCallback_MyDerivedClass_opMyClass1(const IceUtil::Handle<T>& instance, void (T::*cb)(const MyClass1Ptr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyDerivedClass_opMyClass1<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyDerivedClass::begin_opMyClass1.
 */
template<class T> Callback_MyDerivedClass_opMyClass1Ptr
newCallback_MyDerivedClass_opMyClass1(T* instance, void (T::*cb)(const MyClass1Ptr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyDerivedClass_opMyClass1<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyDerivedClass::begin_opMyClass1.
 * Create a wrapper instance by calling ::Test::newCallback_MyDerivedClass_opMyClass1.
 */
template<class T, typename CT>
class Callback_MyDerivedClass_opMyClass1 : public Callback_MyDerivedClass_opMyClass1_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const MyClass1Ptr&, const CT&);

    Callback_MyDerivedClass_opMyClass1(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyDerivedClassPrx proxy = MyDerivedClassPrx::uncheckedCast(result->getProxy());
        MyClass1Ptr ret;
        try
        {
            ret = proxy->end_opMyClass1(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyDerivedClass::begin_opMyClass1.
 */
template<class T, typename CT> Callback_MyDerivedClass_opMyClass1Ptr
newCallback_MyDerivedClass_opMyClass1(const IceUtil::Handle<T>& instance, void (T::*cb)(const MyClass1Ptr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyDerivedClass_opMyClass1<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyDerivedClass::begin_opMyClass1.
 */
template<class T, typename CT> Callback_MyDerivedClass_opMyClass1Ptr
newCallback_MyDerivedClass_opMyClass1(T* instance, void (T::*cb)(const MyClass1Ptr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyDerivedClass_opMyClass1<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::MyDerivedClass::begin_opMyStruct1.
 * Create a wrapper instance by calling ::Test::newCallback_MyDerivedClass_opMyStruct1.
 */
template<class T>
class CallbackNC_MyDerivedClass_opMyStruct1 : public Callback_MyDerivedClass_opMyStruct1_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const MyStruct1&);

    CallbackNC_MyDerivedClass_opMyStruct1(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyDerivedClassPrx proxy = MyDerivedClassPrx::uncheckedCast(result->getProxy());
        MyStruct1 ret;
        try
        {
            ret = proxy->end_opMyStruct1(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyDerivedClass::begin_opMyStruct1.
 */
template<class T> Callback_MyDerivedClass_opMyStruct1Ptr
newCallback_MyDerivedClass_opMyStruct1(const IceUtil::Handle<T>& instance, void (T::*cb)(const MyStruct1&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyDerivedClass_opMyStruct1<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyDerivedClass::begin_opMyStruct1.
 */
template<class T> Callback_MyDerivedClass_opMyStruct1Ptr
newCallback_MyDerivedClass_opMyStruct1(T* instance, void (T::*cb)(const MyStruct1&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_MyDerivedClass_opMyStruct1<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::MyDerivedClass::begin_opMyStruct1.
 * Create a wrapper instance by calling ::Test::newCallback_MyDerivedClass_opMyStruct1.
 */
template<class T, typename CT>
class Callback_MyDerivedClass_opMyStruct1 : public Callback_MyDerivedClass_opMyStruct1_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const MyStruct1&, const CT&);

    Callback_MyDerivedClass_opMyStruct1(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        MyDerivedClassPrx proxy = MyDerivedClassPrx::uncheckedCast(result->getProxy());
        MyStruct1 ret;
        try
        {
            ret = proxy->end_opMyStruct1(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyDerivedClass::begin_opMyStruct1.
 */
template<class T, typename CT> Callback_MyDerivedClass_opMyStruct1Ptr
newCallback_MyDerivedClass_opMyStruct1(const IceUtil::Handle<T>& instance, void (T::*cb)(const MyStruct1&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyDerivedClass_opMyStruct1<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::MyDerivedClass::begin_opMyStruct1.
 */
template<class T, typename CT> Callback_MyDerivedClass_opMyStruct1Ptr
newCallback_MyDerivedClass_opMyStruct1(T* instance, void (T::*cb)(const MyStruct1&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_MyDerivedClass_opMyStruct1<T, CT>(instance, cb, excb, sentcb);
}

}

namespace Test2
{

}

namespace M
{

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::M::Intf::begin_opIntf.
 * Create a wrapper instance by calling ::M::newCallback_Intf_opIntf.
 */
template<class T>
class CallbackNC_Intf_opIntf : public Callback_Intf_opIntf_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Intf_opIntf(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::M::Intf::begin_opIntf.
 */
template<class T> Callback_Intf_opIntfPtr
newCallback_Intf_opIntf(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf_opIntf<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::M::Intf::begin_opIntf.
 */
template<class T> Callback_Intf_opIntfPtr
newCallback_Intf_opIntf(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf_opIntf<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::M::Intf::begin_opIntf.
 */
template<class T> Callback_Intf_opIntfPtr
newCallback_Intf_opIntf(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf_opIntf<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::M::Intf::begin_opIntf.
 */
template<class T> Callback_Intf_opIntfPtr
newCallback_Intf_opIntf(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf_opIntf<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::M::Intf::begin_opIntf.
 * Create a wrapper instance by calling ::M::newCallback_Intf_opIntf.
 */
template<class T, typename CT>
class Callback_Intf_opIntf : public Callback_Intf_opIntf_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Intf_opIntf(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::M::Intf::begin_opIntf.
 */
template<class T, typename CT> Callback_Intf_opIntfPtr
newCallback_Intf_opIntf(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf_opIntf<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::M::Intf::begin_opIntf.
 */
template<class T, typename CT> Callback_Intf_opIntfPtr
newCallback_Intf_opIntf(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf_opIntf<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::M::Intf::begin_opIntf.
 */
template<class T, typename CT> Callback_Intf_opIntfPtr
newCallback_Intf_opIntf(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf_opIntf<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::M::Intf::begin_opIntf.
 */
template<class T, typename CT> Callback_Intf_opIntfPtr
newCallback_Intf_opIntf(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf_opIntf<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::M::B::begin_opB.
 * Create a wrapper instance by calling ::M::newCallback_B_opB.
 */
template<class T>
class CallbackNC_B_opB : public Callback_B_opB_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_B_opB(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::M::B::begin_opB.
 */
template<class T> Callback_B_opBPtr
newCallback_B_opB(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_B_opB<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::M::B::begin_opB.
 */
template<class T> Callback_B_opBPtr
newCallback_B_opB(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_B_opB<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::M::B::begin_opB.
 */
template<class T> Callback_B_opBPtr
newCallback_B_opB(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_B_opB<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::M::B::begin_opB.
 */
template<class T> Callback_B_opBPtr
newCallback_B_opB(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_B_opB<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::M::B::begin_opB.
 * Create a wrapper instance by calling ::M::newCallback_B_opB.
 */
template<class T, typename CT>
class Callback_B_opB : public Callback_B_opB_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_B_opB(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::M::B::begin_opB.
 */
template<class T, typename CT> Callback_B_opBPtr
newCallback_B_opB(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_B_opB<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::M::B::begin_opB.
 */
template<class T, typename CT> Callback_B_opBPtr
newCallback_B_opB(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_B_opB<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::M::B::begin_opB.
 */
template<class T, typename CT> Callback_B_opBPtr
newCallback_B_opB(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_B_opB<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::M::B::begin_opB.
 */
template<class T, typename CT> Callback_B_opBPtr
newCallback_B_opB(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_B_opB<T, CT>(instance, 0, excb, sentcb);
}

}

#endif

#include <IceUtil/PopDisableWarnings.h>
#endif
