//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.8.0-alpha.0
//
// <auto-generated>
//
// Generated from file `SubscriberRecord.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __SubscriberRecord_h__
#define __SubscriberRecord_h__

#include <IceUtil/PushDisableWarnings.h>
#include <Ice/Ice.h>
#include <Ice/Identity.h>
#include <IceStorm/IceStorm.h>
#include <IceUtil/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION  != 30850
#       error Ice version mismatch: an exact match is required for beta generated code
#   endif
#endif

namespace IceStorm
{

struct SubscriberRecordKey;
struct SubscriberRecord;

using SubscriberRecordSeq = ::std::vector<SubscriberRecord>;

}

namespace IceStorm
{

/**
 * The key for persistent subscribers, or topics.
 * If the subscriber identity is empty then the record is used as a place holder for the creation of a topic,
 * otherwise the record holds a subscription record.
 */
struct SubscriberRecordKey
{
    /**
     * The topic identity.
     */
    ::Ice::Identity topic;
    /**
     * The identity of the subscriber. If this is empty then the key is a placeholder for a topic.
     */
    ::Ice::Identity id;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::Ice::Identity&, const ::Ice::Identity&> ice_tuple() const
    {
        return std::tie(topic, id);
    }
};

/**
 * Used to store persistent information for persistent subscribers.
 */
struct SubscriberRecord
{
    /**
     * The name of the topic.
     */
    ::std::string topicName;
    /**
     * The subscriber identity.
     */
    ::Ice::Identity id;
    /**
     * Is this a link record, or a subscriber record?
     */
    bool link;
    /**
     * The subscriber object.
     */
    ::std::optional<::Ice::ObjectPrx> obj;
    /**
     * The QoS.
     */
    ::IceStorm::QoS theQoS;
    /**
     * The cost.
     */
    ::std::int32_t cost;
    /**
     * The linked topic.
     */
    ::std::optional<::IceStorm::TopicPrx> theTopic;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::Ice::Identity&, const bool&, const ::std::optional<::Ice::ObjectPrx>&, const ::IceStorm::QoS&, const ::std::int32_t&, const ::std::optional<::IceStorm::TopicPrx>&> ice_tuple() const
    {
        return std::tie(topicName, id, link, obj, theQoS, cost, theTopic);
    }
};

using Ice::operator<;
using Ice::operator<=;
using Ice::operator>;
using Ice::operator>=;
using Ice::operator==;
using Ice::operator!=;

}

/// \cond STREAM
namespace Ice
{

template<>
struct StreamableTraits<::IceStorm::SubscriberRecordKey>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 4;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::IceStorm::SubscriberRecordKey, S>
{
    static void read(S* istr, ::IceStorm::SubscriberRecordKey& v)
    {
        istr->readAll(v.topic, v.id);
    }
};

template<>
struct StreamableTraits<::IceStorm::SubscriberRecord>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 13;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::IceStorm::SubscriberRecord, S>
{
    static void read(S* istr, ::IceStorm::SubscriberRecord& v)
    {
        istr->readAll(v.topicName, v.id, v.link, v.obj, v.theQoS, v.cost, v.theTopic);
    }
};

}
/// \endcond

#include <IceUtil/PopDisableWarnings.h>
#endif
