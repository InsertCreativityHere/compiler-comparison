//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.8.0-alpha.0
//
// <auto-generated>
//
// Generated from file `SubscriberRecord.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __SubscriberRecord_h__
#define __SubscriberRecord_h__

#include <IceUtil/PushDisableWarnings.h>
#include <Ice/Ice.h>
#include <Ice/Identity.h>
#include <IceStorm/IceStorm.h>
#include <IceUtil/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION  != 30850
#       error Ice version mismatch: an exact match is required for beta generated code
#   endif
#endif

#ifdef ICE_CPP11_MAPPING // C++11 mapping

namespace IceStorm
{


}

namespace IceStorm
{

/**
 * The key for persistent subscribers, or topics.
 * If the subscriber identity is empty then the record is used as a place holder for the creation of a topic,
 * otherwise the record holds a subscription record.
 */
struct SubscriberRecordKey
{
    /**
     * The topic identity.
     */
    ::Ice::Identity topic;
    /**
     * The identity of the subscriber. If this is empty then the key is a placeholder for a topic.
     */
    ::Ice::Identity id;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::Ice::Identity&, const ::Ice::Identity&> ice_tuple() const
    {
        return std::tie(topic, id);
    }
};

/**
 * Used to store persistent information for persistent subscribers.
 */
struct SubscriberRecord
{
    /**
     * The name of the topic.
     */
    ::std::string topicName;
    /**
     * The subscriber identity.
     */
    ::Ice::Identity id;
    /**
     * Is this a link record, or a subscriber record?
     */
    bool link;
    /**
     * The subscriber object.
     */
    ::std::shared_ptr<::Ice::ObjectPrx> obj;
    /**
     * The QoS.
     */
    ::IceStorm::QoS theQoS;
    /**
     * The cost.
     */
    int cost;
    /**
     * The linked topic.
     */
    ::std::shared_ptr<::IceStorm::TopicPrx> theTopic;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::Ice::Identity&, const bool&, const ::std::shared_ptr<::Ice::ObjectPrx>&, const ::IceStorm::QoS&, const int&, const ::std::shared_ptr<::IceStorm::TopicPrx>&> ice_tuple() const
    {
        return std::tie(topicName, id, link, obj, theQoS, cost, theTopic);
    }
};

using SubscriberRecordSeq = ::std::vector<SubscriberRecord>;

using Ice::operator<;
using Ice::operator<=;
using Ice::operator>;
using Ice::operator>=;
using Ice::operator==;
using Ice::operator!=;

}

/// \cond STREAM
namespace Ice
{

template<>
struct StreamableTraits<::IceStorm::SubscriberRecordKey>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 4;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::IceStorm::SubscriberRecordKey, S>
{
    static void read(S* istr, ::IceStorm::SubscriberRecordKey& v)
    {
        istr->readAll(v.topic, v.id);
    }
};

template<>
struct StreamableTraits<::IceStorm::SubscriberRecord>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 13;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::IceStorm::SubscriberRecord, S>
{
    static void read(S* istr, ::IceStorm::SubscriberRecord& v)
    {
        istr->readAll(v.topicName, v.id, v.link, v.obj, v.theQoS, v.cost, v.theTopic);
    }
};

}
/// \endcond

#else // C++98 mapping

namespace IceProxy
{

}

namespace IceStorm
{

}

namespace IceStorm
{

/**
 * The key for persistent subscribers, or topics.
 * If the subscriber identity is empty then the record is used as a place holder for the creation of a topic,
 * otherwise the record holds a subscription record.
 */
struct SubscriberRecordKey
{
    /**
     * The topic identity.
     */
    ::Ice::Identity topic;
    /**
     * The identity of the subscriber. If this is empty then the key is a placeholder for a topic.
     */
    ::Ice::Identity id;

    bool operator==(const SubscriberRecordKey& rhs_) const
    {
        if(this == &rhs_)
        {
            return true;
        }
        if(topic != rhs_.topic)
        {
            return false;
        }
        if(id != rhs_.id)
        {
            return false;
        }
        return true;
    }

    bool operator<(const SubscriberRecordKey& rhs_) const
    {
        if(this == &rhs_)
        {
            return false;
        }
        if(topic < rhs_.topic)
        {
            return true;
        }
        else if(rhs_.topic < topic)
        {
            return false;
        }
        if(id < rhs_.id)
        {
            return true;
        }
        else if(rhs_.id < id)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const SubscriberRecordKey& rhs_) const
    {
        return !operator==(rhs_);
    }
    bool operator<=(const SubscriberRecordKey& rhs_) const
    {
        return operator<(rhs_) || operator==(rhs_);
    }
    bool operator>(const SubscriberRecordKey& rhs_) const
    {
        return !operator<(rhs_) && !operator==(rhs_);
    }
    bool operator>=(const SubscriberRecordKey& rhs_) const
    {
        return !operator<(rhs_);
    }
};

/**
 * Used to store persistent information for persistent subscribers.
 */
struct SubscriberRecord
{
    /**
     * The name of the topic.
     */
    ::std::string topicName;
    /**
     * The subscriber identity.
     */
    ::Ice::Identity id;
    /**
     * Is this a link record, or a subscriber record?
     */
    bool link;
    /**
     * The subscriber object.
     */
    ::Ice::ObjectPrx obj;
    /**
     * The QoS.
     */
    ::IceStorm::QoS theQoS;
    /**
     * The cost.
     */
    ::Ice::Int cost;
    /**
     * The linked topic.
     */
    ::IceStorm::TopicPrx theTopic;
};

typedef ::std::vector<SubscriberRecord> SubscriberRecordSeq;

}

namespace IceProxy
{

}

/// \cond STREAM
namespace Ice
{

template<>
struct StreamableTraits< ::IceStorm::SubscriberRecordKey>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 4;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::IceStorm::SubscriberRecordKey, S>
{
    static void write(S* ostr, const ::IceStorm::SubscriberRecordKey& v)
    {
        ostr->write(v.topic);
        ostr->write(v.id);
    }
};

template<typename S>
struct StreamReader< ::IceStorm::SubscriberRecordKey, S>
{
    static void read(S* istr, ::IceStorm::SubscriberRecordKey& v)
    {
        istr->read(v.topic);
        istr->read(v.id);
    }
};

template<>
struct StreamableTraits< ::IceStorm::SubscriberRecord>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 13;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::IceStorm::SubscriberRecord, S>
{
    static void write(S* ostr, const ::IceStorm::SubscriberRecord& v)
    {
        ostr->write(v.topicName);
        ostr->write(v.id);
        ostr->write(v.link);
        ostr->write(v.obj);
        ostr->write(v.theQoS);
        ostr->write(v.cost);
        ostr->write(v.theTopic);
    }
};

template<typename S>
struct StreamReader< ::IceStorm::SubscriberRecord, S>
{
    static void read(S* istr, ::IceStorm::SubscriberRecord& v)
    {
        istr->read(v.topicName);
        istr->read(v.id);
        istr->read(v.link);
        istr->read(v.obj);
        istr->read(v.theQoS);
        istr->read(v.cost);
        istr->read(v.theTopic);
    }
};

}
/// \endcond

#endif

#include <IceUtil/PopDisableWarnings.h>
#endif
