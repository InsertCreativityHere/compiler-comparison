//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.8.0-alpha.0
//
// <auto-generated>
//
// Generated from file `Internal.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __Internal_h__
#define __Internal_h__

#include <IceUtil/PushDisableWarnings.h>
#include <Ice/Ice.h>
#include <Ice/Identity.h>
#include <Ice/BuiltinSequences.h>
#include <Ice/Process.h>
#include <Glacier2/Session.h>
#include <IceGrid/Admin.h>
#include <IceGrid/Registry.h>
#include <IceUtil/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION  != 30850
#       error Ice version mismatch: an exact match is required for beta generated code
#   endif
#endif

namespace IceGrid
{

class InternalDbEnvDescriptor;

using InternalDbEnvDescriptorPtr = ::std::shared_ptr<InternalDbEnvDescriptor>;

using InternalDbEnvDescriptorSeq = ::std::vector<::std::shared_ptr<InternalDbEnvDescriptor>>;
class InternalAdapterDescriptor;

using InternalAdapterDescriptorPtr = ::std::shared_ptr<InternalAdapterDescriptor>;

using InternalAdapterDescriptorSeq = ::std::vector<::std::shared_ptr<InternalAdapterDescriptor>>;
class InternalDistributionDescriptor;

using InternalDistributionDescriptorPtr = ::std::shared_ptr<InternalDistributionDescriptor>;

using PropertyDescriptorSeqDict = ::std::map<::std::string, PropertyDescriptorSeq>;
class InternalServerDescriptor;

using InternalServerDescriptorPtr = ::std::shared_ptr<InternalServerDescriptor>;
class AdapterPrx;

using AdapterPrxPtr = ::std::optional<AdapterPrx>;

using AdapterPrxDict = ::std::map<::std::string, ::std::optional<AdapterPrx>>;
class FileReaderPrx;

using FileReaderPrxPtr = ::std::optional<FileReaderPrx>;
class ServerPrx;

using ServerPrxPtr = ::std::optional<ServerPrx>;
class InternalRegistryPrx;

using InternalRegistryPrxPtr = ::std::optional<InternalRegistryPrx>;

using InternalRegistryPrxSeq = ::std::vector<::std::optional<InternalRegistryPrx>>;
class ReplicaObserverPrx;

using ReplicaObserverPrxPtr = ::std::optional<ReplicaObserverPrx>;
class PatcherFeedbackPrx;

using PatcherFeedbackPrxPtr = ::std::optional<PatcherFeedbackPrx>;
class NodePrx;

using NodePrxPtr = ::std::optional<NodePrx>;

using NodePrxSeq = ::std::vector<::std::optional<NodePrx>>;
class NodeSessionPrx;

using NodeSessionPrxPtr = ::std::optional<NodeSessionPrx>;

enum class TopicName : unsigned char
{
    RegistryObserver,
    NodeObserver,
    ApplicationObserver,
    AdapterObserver,
    ObjectObserver
};
class DatabaseObserverPrx;

using DatabaseObserverPrxPtr = ::std::optional<DatabaseObserverPrx>;

using StringLongDict = ::std::map<::std::string, ::std::int64_t>;
class ReplicaSessionPrx;

using ReplicaSessionPrxPtr = ::std::optional<ReplicaSessionPrx>;
class InternalNodeInfo;

using InternalNodeInfoPtr = ::std::shared_ptr<InternalNodeInfo>;
class InternalReplicaInfo;

using InternalReplicaInfoPtr = ::std::shared_ptr<InternalReplicaInfo>;

}

namespace IceGrid
{

class AdapterPrx : public ::Ice::Proxy<AdapterPrx, ::Ice::ObjectPrx>
{
public:

    /**
     * Activate this adapter. If this adapter can be activated, this will activate the adapter and return the direct
     * proxy of the adapter once it's active. If this adapter can be activated on demand, this will return 0 if the
     * adapter is inactive or the adapter direct proxy it's active.
     * @param context The Context map to send with the invocation.
     */
    ::std::optional<::Ice::ObjectPrx> activate(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Activate this adapter. If this adapter can be activated, this will activate the adapter and return the direct
     * proxy of the adapter once it's active. If this adapter can be activated on demand, this will return 0 if the
     * adapter is inactive or the adapter direct proxy it's active.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    ::std::future<::std::optional<::Ice::ObjectPrx>> activateAsync(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Activate this adapter. If this adapter can be activated, this will activate the adapter and return the direct
     * proxy of the adapter once it's active. If this adapter can be activated on demand, this will return 0 if the
     * adapter is inactive or the adapter direct proxy it's active.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    activateAsync(::std::function<void(::std::optional<::Ice::ObjectPrx>)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_activate(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::optional<::Ice::ObjectPrx>>>&, const ::Ice::Context&) const;
    /// \endcond

    /**
     * Get the adapter direct proxy. The adapter direct proxy is a proxy created with the object adapter. The proxy
     * contains the last known adapter endpoints.
     * @param context The Context map to send with the invocation.
     * @return A direct proxy containing the last known adapter endpoints if the adapter is already active.
     */
    ::std::optional<::Ice::ObjectPrx> getDirectProxy(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Get the adapter direct proxy. The adapter direct proxy is a proxy created with the object adapter. The proxy
     * contains the last known adapter endpoints.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    ::std::future<::std::optional<::Ice::ObjectPrx>> getDirectProxyAsync(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Get the adapter direct proxy. The adapter direct proxy is a proxy created with the object adapter. The proxy
     * contains the last known adapter endpoints.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    getDirectProxyAsync(::std::function<void(::std::optional<::Ice::ObjectPrx>)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_getDirectProxy(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::optional<::Ice::ObjectPrx>>>&, const ::Ice::Context&) const;
    /// \endcond

    /**
     * Set the direct proxy for this adapter.
     * @param context The Context map to send with the invocation.
     * @throws IceGrid::AdapterActiveException The adapter is already active. It's not possible to override the direct proxy of
     * an active adapter.
     */
    void setDirectProxy(const ::std::optional<::Ice::ObjectPrx>& proxy, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Set the direct proxy for this adapter.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    ::std::future<void> setDirectProxyAsync(const ::std::optional<::Ice::ObjectPrx>& proxy, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Set the direct proxy for this adapter.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    setDirectProxyAsync(const ::std::optional<::Ice::ObjectPrx>& proxy, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_setDirectProxy(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::optional<::Ice::ObjectPrx>&, const ::Ice::Context&) const;
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId();

    explicit AdapterPrx(const ::Ice::ObjectPrx& other) : ::Ice::ObjectPrx(other)
    {
    }

    AdapterPrx(const AdapterPrx& other) noexcept : ::Ice::ObjectPrx(other)
    {
    }

    AdapterPrx(AdapterPrx&& other) noexcept : ::Ice::ObjectPrx(::std::move(other))
    {
    }

    AdapterPrx(const ::std::shared_ptr<::Ice::Communicator>& communicator, const ::std::string& proxyString) :
        ::Ice::ObjectPrx(communicator, proxyString)
    {
    }

    AdapterPrx& operator=(const AdapterPrx& rhs) noexcept
    {
        ::Ice::ObjectPrx::operator=(rhs);
        return *this;
    }

    AdapterPrx& operator=(AdapterPrx&& rhs) noexcept
    {
        ::Ice::ObjectPrx::operator=(::std::move(rhs));
        return *this;
    }

    /// \cond INTERNAL
    static AdapterPrx _fromReference(::IceInternal::ReferencePtr ref) { return AdapterPrx(::std::move(ref)); }

protected:

    AdapterPrx() = default;

    explicit AdapterPrx(::IceInternal::ReferencePtr&& ref) : ::Ice::ObjectPrx(::std::move(ref))
    {
    }
    /// \endcond
};

class FileReaderPrx : public ::Ice::Proxy<FileReaderPrx, ::Ice::ObjectPrx>
{
public:

    /**
     * Count the number of given lines from the end of the file and return the file offset.
     * @param context The Context map to send with the invocation.
     */
    ::std::int64_t getOffsetFromEnd(::std::string_view filename, ::std::int32_t lines, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Count the number of given lines from the end of the file and return the file offset.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    ::std::future<::std::int64_t> getOffsetFromEndAsync(::std::string_view filename, ::std::int32_t lines, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Count the number of given lines from the end of the file and return the file offset.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    getOffsetFromEndAsync(::std::string_view filename, ::std::int32_t lines, ::std::function<void(::std::int64_t)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_getOffsetFromEnd(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::int64_t>>&, ::std::string_view, ::std::int32_t, const ::Ice::Context&) const;
    /// \endcond

    /**
     * Read lines (or size bytes) at the specified position from the given file.
     * @param context The Context map to send with the invocation.
     */
    bool read(::std::string_view filename, ::std::int64_t pos, ::std::int32_t size, ::std::int64_t& newPos, ::Ice::StringSeq& lines, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Read lines (or size bytes) at the specified position from the given file.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    ::std::future<::std::tuple<bool, ::std::int64_t, ::Ice::StringSeq>> readAsync(::std::string_view filename, ::std::int64_t pos, ::std::int32_t size, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Read lines (or size bytes) at the specified position from the given file.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    readAsync(::std::string_view filename, ::std::int64_t pos, ::std::int32_t size, ::std::function<void(bool, ::std::int64_t, ::Ice::StringSeq)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_read(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<bool, ::std::int64_t, ::Ice::StringSeq>>>&, ::std::string_view, ::std::int64_t, ::std::int32_t, const ::Ice::Context&) const;
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId();

    explicit FileReaderPrx(const ::Ice::ObjectPrx& other) : ::Ice::ObjectPrx(other)
    {
    }

    FileReaderPrx(const FileReaderPrx& other) noexcept : ::Ice::ObjectPrx(other)
    {
    }

    FileReaderPrx(FileReaderPrx&& other) noexcept : ::Ice::ObjectPrx(::std::move(other))
    {
    }

    FileReaderPrx(const ::std::shared_ptr<::Ice::Communicator>& communicator, const ::std::string& proxyString) :
        ::Ice::ObjectPrx(communicator, proxyString)
    {
    }

    FileReaderPrx& operator=(const FileReaderPrx& rhs) noexcept
    {
        ::Ice::ObjectPrx::operator=(rhs);
        return *this;
    }

    FileReaderPrx& operator=(FileReaderPrx&& rhs) noexcept
    {
        ::Ice::ObjectPrx::operator=(::std::move(rhs));
        return *this;
    }

    /// \cond INTERNAL
    static FileReaderPrx _fromReference(::IceInternal::ReferencePtr ref) { return FileReaderPrx(::std::move(ref)); }

protected:

    FileReaderPrx() = default;

    explicit FileReaderPrx(::IceInternal::ReferencePtr&& ref) : ::Ice::ObjectPrx(::std::move(ref))
    {
    }
    /// \endcond
};

class ServerPrx : public ::Ice::Proxy<ServerPrx, FileReaderPrx>
{
public:

    /**
     * Start the server.
     * @param context The Context map to send with the invocation.
     */
    void start(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Start the server.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    ::std::future<void> startAsync(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Start the server.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    startAsync(::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_start(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&) const;
    /// \endcond

    /**
     * Stop the server. This methods returns only when the server is deactivated. If the server doesn't stop after a
     * configurable amount of time, it will be killed.
     * @param context The Context map to send with the invocation.
     */
    void stop(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Stop the server. This methods returns only when the server is deactivated. If the server doesn't stop after a
     * configurable amount of time, it will be killed.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    ::std::future<void> stopAsync(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Stop the server. This methods returns only when the server is deactivated. If the server doesn't stop after a
     * configurable amount of time, it will be killed.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    stopAsync(::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_stop(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&) const;
    /// \endcond

    /**
     * Check if the given server can be loaded on this node.
     * @param context The Context map to send with the invocation.
     * @return True if the server is inactive.
     * @throws IceGrid::DeploymentException Raised if the server can't be updated.
     */
    bool checkUpdate(const ::std::shared_ptr<InternalServerDescriptor>& svr, bool noRestart, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Check if the given server can be loaded on this node.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    ::std::future<bool> checkUpdateAsync(const ::std::shared_ptr<InternalServerDescriptor>& svr, bool noRestart, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Check if the given server can be loaded on this node.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    checkUpdateAsync(const ::std::shared_ptr<InternalServerDescriptor>& svr, bool noRestart, ::std::function<void(bool)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_checkUpdate(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>&, const ::std::shared_ptr<InternalServerDescriptor>&, bool, const ::Ice::Context&) const;
    /// \endcond

    /**
     * Enable or disable the server.
     * @param context The Context map to send with the invocation.
     */
    void setEnabled(bool enable, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Enable or disable the server.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    ::std::future<void> setEnabledAsync(bool enable, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Enable or disable the server.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    setEnabledAsync(bool enable, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_setEnabled(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, bool, const ::Ice::Context&) const;
    /// \endcond

    /**
     * Check if the server is enabled.
     * @param context The Context map to send with the invocation.
     */
    bool isEnabled(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Check if the server is enabled.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    ::std::future<bool> isEnabledAsync(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Check if the server is enabled.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    isEnabledAsync(::std::function<void(bool)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_isEnabled(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>&, const ::Ice::Context&) const;
    /// \endcond

    /**
     * Send signal to the server
     * @param context The Context map to send with the invocation.
     */
    void sendSignal(::std::string_view signal, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Send signal to the server
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    ::std::future<void> sendSignalAsync(::std::string_view signal, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Send signal to the server
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    sendSignalAsync(::std::string_view signal, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_sendSignal(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, ::std::string_view, const ::Ice::Context&) const;
    /// \endcond

    /**
     * Write message on servers' stdout or stderr.
     * @param context The Context map to send with the invocation.
     */
    void writeMessage(::std::string_view message, ::std::int32_t fd, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Write message on servers' stdout or stderr.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    ::std::future<void> writeMessageAsync(::std::string_view message, ::std::int32_t fd, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Write message on servers' stdout or stderr.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    writeMessageAsync(::std::string_view message, ::std::int32_t fd, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_writeMessage(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, ::std::string_view, ::std::int32_t, const ::Ice::Context&) const;
    /// \endcond

    /**
     * Return the server state.
     * @param context The Context map to send with the invocation.
     * @return The server state.
     * @see ServerState
     */
    ServerState getState(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Return the server state.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     * @see ServerState
     */
    ::std::future<ServerState> getStateAsync(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Return the server state.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     * @see ServerState
     */
    ::std::function<void()>
    getStateAsync(::std::function<void(::IceGrid::ServerState)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_getState(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ServerState>>&, const ::Ice::Context&) const;
    /// \endcond

    /**
     * Get the server pid. Note that the value returned by this method is system dependant. On Unix operating systems,
     * it's the pid value returned by the fork() system call and converted to an integer.
     * @param context The Context map to send with the invocation.
     */
    ::std::int32_t getPid(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Get the server pid. Note that the value returned by this method is system dependant. On Unix operating systems,
     * it's the pid value returned by the fork() system call and converted to an integer.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    ::std::future<::std::int32_t> getPidAsync(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Get the server pid. Note that the value returned by this method is system dependant. On Unix operating systems,
     * it's the pid value returned by the fork() system call and converted to an integer.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    getPidAsync(::std::function<void(::std::int32_t)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_getPid(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::int32_t>>&, const ::Ice::Context&) const;
    /// \endcond

    /**
     * Set the process proxy.
     * @param context The Context map to send with the invocation.
     */
    void setProcess(const ::std::optional<::Ice::ProcessPrx>& proc, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Set the process proxy.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    ::std::future<void> setProcessAsync(const ::std::optional<::Ice::ProcessPrx>& proc, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Set the process proxy.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    setProcessAsync(const ::std::optional<::Ice::ProcessPrx>& proc, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_setProcess(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::optional<::Ice::ProcessPrx>&, const ::Ice::Context&) const;
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId();

#if defined(__GNUC__)
#   pragma GCC diagnostic push
#   pragma GCC diagnostic ignored "-Wextra" // initialize all virtual bases in correct order
#endif

    explicit ServerPrx(const ::Ice::ObjectPrx& other) : ::Ice::ObjectPrx(other)
    {
    }

    ServerPrx(const ServerPrx& other) noexcept : ::Ice::ObjectPrx(other)
    {
    }

    ServerPrx(ServerPrx&& other) noexcept : ::Ice::ObjectPrx(::std::move(other))
    {
    }

    ServerPrx(const ::std::shared_ptr<::Ice::Communicator>& communicator, const ::std::string& proxyString) :
        ::Ice::ObjectPrx(communicator, proxyString)
    {
    }

    ServerPrx& operator=(const ServerPrx& rhs) noexcept
    {
        ::Ice::ObjectPrx::operator=(rhs);
        return *this;
    }

    ServerPrx& operator=(ServerPrx&& rhs) noexcept
    {
        ::Ice::ObjectPrx::operator=(::std::move(rhs));
        return *this;
    }

    /// \cond INTERNAL
    static ServerPrx _fromReference(::IceInternal::ReferencePtr ref) { return ServerPrx(::std::move(ref)); }

protected:

    ServerPrx() = default;

    explicit ServerPrx(::IceInternal::ReferencePtr&& ref) : ::Ice::ObjectPrx(::std::move(ref))
    {
    }
    /// \endcond

#if defined(__GNUC__)
#   pragma GCC diagnostic pop
#endif
};

class ReplicaObserverPrx : public ::Ice::Proxy<ReplicaObserverPrx, ::Ice::ObjectPrx>
{
public:

    /**
     * Initialization of the replica observer.
     * @param context The Context map to send with the invocation.
     */
    void replicaInit(const InternalRegistryPrxSeq& replicas, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Initialization of the replica observer.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    ::std::future<void> replicaInitAsync(const InternalRegistryPrxSeq& replicas, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Initialization of the replica observer.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    replicaInitAsync(const InternalRegistryPrxSeq& replicas, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_replicaInit(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const InternalRegistryPrxSeq&, const ::Ice::Context&) const;
    /// \endcond

    /**
     * Notification that a replica has been added. The node should establish a session with this new replica.
     * @param context The Context map to send with the invocation.
     */
    void replicaAdded(const ::std::optional<InternalRegistryPrx>& replica, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Notification that a replica has been added. The node should establish a session with this new replica.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    ::std::future<void> replicaAddedAsync(const ::std::optional<InternalRegistryPrx>& replica, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Notification that a replica has been added. The node should establish a session with this new replica.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    replicaAddedAsync(const ::std::optional<InternalRegistryPrx>& replica, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_replicaAdded(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::optional<InternalRegistryPrx>&, const ::Ice::Context&) const;
    /// \endcond

    /**
     * Notification that a replica has been removed. The node should destroy the session to this replica.
     * @param context The Context map to send with the invocation.
     */
    void replicaRemoved(const ::std::optional<InternalRegistryPrx>& replica, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Notification that a replica has been removed. The node should destroy the session to this replica.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    ::std::future<void> replicaRemovedAsync(const ::std::optional<InternalRegistryPrx>& replica, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Notification that a replica has been removed. The node should destroy the session to this replica.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    replicaRemovedAsync(const ::std::optional<InternalRegistryPrx>& replica, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_replicaRemoved(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::optional<InternalRegistryPrx>&, const ::Ice::Context&) const;
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId();

    explicit ReplicaObserverPrx(const ::Ice::ObjectPrx& other) : ::Ice::ObjectPrx(other)
    {
    }

    ReplicaObserverPrx(const ReplicaObserverPrx& other) noexcept : ::Ice::ObjectPrx(other)
    {
    }

    ReplicaObserverPrx(ReplicaObserverPrx&& other) noexcept : ::Ice::ObjectPrx(::std::move(other))
    {
    }

    ReplicaObserverPrx(const ::std::shared_ptr<::Ice::Communicator>& communicator, const ::std::string& proxyString) :
        ::Ice::ObjectPrx(communicator, proxyString)
    {
    }

    ReplicaObserverPrx& operator=(const ReplicaObserverPrx& rhs) noexcept
    {
        ::Ice::ObjectPrx::operator=(rhs);
        return *this;
    }

    ReplicaObserverPrx& operator=(ReplicaObserverPrx&& rhs) noexcept
    {
        ::Ice::ObjectPrx::operator=(::std::move(rhs));
        return *this;
    }

    /// \cond INTERNAL
    static ReplicaObserverPrx _fromReference(::IceInternal::ReferencePtr ref) { return ReplicaObserverPrx(::std::move(ref)); }

protected:

    ReplicaObserverPrx() = default;

    explicit ReplicaObserverPrx(::IceInternal::ReferencePtr&& ref) : ::Ice::ObjectPrx(::std::move(ref))
    {
    }
    /// \endcond
};

class PatcherFeedbackPrx : public ::Ice::Proxy<PatcherFeedbackPrx, ::Ice::ObjectPrx>
{
public:

    /**
     * The patch completed successfully.
     * @param context The Context map to send with the invocation.
     */
    void finished(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * The patch completed successfully.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    ::std::future<void> finishedAsync(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * The patch completed successfully.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    finishedAsync(::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_finished(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&) const;
    /// \endcond

    /**
     * The patch on the given node failed for the given reason.
     * @param context The Context map to send with the invocation.
     */
    void failed(::std::string_view reason, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * The patch on the given node failed for the given reason.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    ::std::future<void> failedAsync(::std::string_view reason, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * The patch on the given node failed for the given reason.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    failedAsync(::std::string_view reason, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_failed(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, ::std::string_view, const ::Ice::Context&) const;
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId();

    explicit PatcherFeedbackPrx(const ::Ice::ObjectPrx& other) : ::Ice::ObjectPrx(other)
    {
    }

    PatcherFeedbackPrx(const PatcherFeedbackPrx& other) noexcept : ::Ice::ObjectPrx(other)
    {
    }

    PatcherFeedbackPrx(PatcherFeedbackPrx&& other) noexcept : ::Ice::ObjectPrx(::std::move(other))
    {
    }

    PatcherFeedbackPrx(const ::std::shared_ptr<::Ice::Communicator>& communicator, const ::std::string& proxyString) :
        ::Ice::ObjectPrx(communicator, proxyString)
    {
    }

    PatcherFeedbackPrx& operator=(const PatcherFeedbackPrx& rhs) noexcept
    {
        ::Ice::ObjectPrx::operator=(rhs);
        return *this;
    }

    PatcherFeedbackPrx& operator=(PatcherFeedbackPrx&& rhs) noexcept
    {
        ::Ice::ObjectPrx::operator=(::std::move(rhs));
        return *this;
    }

    /// \cond INTERNAL
    static PatcherFeedbackPrx _fromReference(::IceInternal::ReferencePtr ref) { return PatcherFeedbackPrx(::std::move(ref)); }

protected:

    PatcherFeedbackPrx() = default;

    explicit PatcherFeedbackPrx(::IceInternal::ReferencePtr&& ref) : ::Ice::ObjectPrx(::std::move(ref))
    {
    }
    /// \endcond
};

class NodePrx : public ::Ice::Proxy<NodePrx, FileReaderPrx, ReplicaObserverPrx>
{
public:

    /**
     * Load the given server. If the server resources weren't already created (database environment directories,
     * property files, etc), they will be created.
     * @param context The Context map to send with the invocation.
     */
    ::std::optional<ServerPrx> loadServer(const ::std::shared_ptr<InternalServerDescriptor>& svr, ::std::string_view replicaName, AdapterPrxDict& adapters, ::std::int32_t& actTimeout, ::std::int32_t& deactTimeout, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Load the given server. If the server resources weren't already created (database environment directories,
     * property files, etc), they will be created.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    ::std::future<::std::tuple<::std::optional<ServerPrx>, AdapterPrxDict, ::std::int32_t, ::std::int32_t>> loadServerAsync(const ::std::shared_ptr<InternalServerDescriptor>& svr, ::std::string_view replicaName, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Load the given server. If the server resources weren't already created (database environment directories,
     * property files, etc), they will be created.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    loadServerAsync(const ::std::shared_ptr<InternalServerDescriptor>& svr, ::std::string_view replicaName, ::std::function<void(::std::optional<::IceGrid::ServerPrx>, ::IceGrid::AdapterPrxDict, ::std::int32_t, ::std::int32_t)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_loadServer(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::optional<ServerPrx>, AdapterPrxDict, ::std::int32_t, ::std::int32_t>>>&, const ::std::shared_ptr<InternalServerDescriptor>&, ::std::string_view, const ::Ice::Context&) const;
    /// \endcond

    /**
     * Load the given server and ensure the server won't be restarted. If the server resources weren't already created
     * (database environment directories, property files, etc), they will be created. If the server can't be updated
     * without a restart, a DeploymentException is raised.
     * @param context The Context map to send with the invocation.
     */
    ::std::optional<ServerPrx> loadServerWithoutRestart(const ::std::shared_ptr<InternalServerDescriptor>& svr, ::std::string_view replicaName, AdapterPrxDict& adapters, ::std::int32_t& actTimeout, ::std::int32_t& deactTimeout, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Load the given server and ensure the server won't be restarted. If the server resources weren't already created
     * (database environment directories, property files, etc), they will be created. If the server can't be updated
     * without a restart, a DeploymentException is raised.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    ::std::future<::std::tuple<::std::optional<ServerPrx>, AdapterPrxDict, ::std::int32_t, ::std::int32_t>> loadServerWithoutRestartAsync(const ::std::shared_ptr<InternalServerDescriptor>& svr, ::std::string_view replicaName, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Load the given server and ensure the server won't be restarted. If the server resources weren't already created
     * (database environment directories, property files, etc), they will be created. If the server can't be updated
     * without a restart, a DeploymentException is raised.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    loadServerWithoutRestartAsync(const ::std::shared_ptr<InternalServerDescriptor>& svr, ::std::string_view replicaName, ::std::function<void(::std::optional<::IceGrid::ServerPrx>, ::IceGrid::AdapterPrxDict, ::std::int32_t, ::std::int32_t)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_loadServerWithoutRestart(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::optional<ServerPrx>, AdapterPrxDict, ::std::int32_t, ::std::int32_t>>>&, const ::std::shared_ptr<InternalServerDescriptor>&, ::std::string_view, const ::Ice::Context&) const;
    /// \endcond

    /**
     * Destroy the given server.
     * @param context The Context map to send with the invocation.
     */
    void destroyServer(::std::string_view name, ::std::string_view uuid, ::std::int32_t revision, ::std::string_view replicaName, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Destroy the given server.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    ::std::future<void> destroyServerAsync(::std::string_view name, ::std::string_view uuid, ::std::int32_t revision, ::std::string_view replicaName, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Destroy the given server.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    destroyServerAsync(::std::string_view name, ::std::string_view uuid, ::std::int32_t revision, ::std::string_view replicaName, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_destroyServer(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, ::std::string_view, ::std::string_view, ::std::int32_t, ::std::string_view, const ::Ice::Context&) const;
    /// \endcond

    /**
     * Destroy the server if it's not active.
     * @param context The Context map to send with the invocation.
     */
    void destroyServerWithoutRestart(::std::string_view name, ::std::string_view uuid, ::std::int32_t revision, ::std::string_view replicaName, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Destroy the server if it's not active.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    ::std::future<void> destroyServerWithoutRestartAsync(::std::string_view name, ::std::string_view uuid, ::std::int32_t revision, ::std::string_view replicaName, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Destroy the server if it's not active.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    destroyServerWithoutRestartAsync(::std::string_view name, ::std::string_view uuid, ::std::int32_t revision, ::std::string_view replicaName, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_destroyServerWithoutRestart(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, ::std::string_view, ::std::string_view, ::std::int32_t, ::std::string_view, const ::Ice::Context&) const;
    /// \endcond

    /**
     * Patch application and server distributions. If some servers using a distribution directory to patch are active,
     * this method will raise a PatchException unless shutdown is set to true. In which case the servers will be
     * shutdown.
     * @param context The Context map to send with the invocation.
     */
    void patch(const ::std::optional<PatcherFeedbackPrx>& feedback, ::std::string_view application, ::std::string_view server, const ::std::shared_ptr<InternalDistributionDescriptor>& appDistrib, bool shutdown, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Patch application and server distributions. If some servers using a distribution directory to patch are active,
     * this method will raise a PatchException unless shutdown is set to true. In which case the servers will be
     * shutdown.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    ::std::future<void> patchAsync(const ::std::optional<PatcherFeedbackPrx>& feedback, ::std::string_view application, ::std::string_view server, const ::std::shared_ptr<InternalDistributionDescriptor>& appDistrib, bool shutdown, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Patch application and server distributions. If some servers using a distribution directory to patch are active,
     * this method will raise a PatchException unless shutdown is set to true. In which case the servers will be
     * shutdown.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    patchAsync(const ::std::optional<PatcherFeedbackPrx>& feedback, ::std::string_view application, ::std::string_view server, const ::std::shared_ptr<InternalDistributionDescriptor>& appDistrib, bool shutdown, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_patch(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::optional<PatcherFeedbackPrx>&, ::std::string_view, ::std::string_view, const ::std::shared_ptr<InternalDistributionDescriptor>&, bool, const ::Ice::Context&) const;
    /// \endcond

    /**
     * Establish a session to the given replica, this method only returns once the registration was attempted (unlike
     * replicaAdded below).
     * @param context The Context map to send with the invocation.
     */
    void registerWithReplica(const ::std::optional<InternalRegistryPrx>& replica, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Establish a session to the given replica, this method only returns once the registration was attempted (unlike
     * replicaAdded below).
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    ::std::future<void> registerWithReplicaAsync(const ::std::optional<InternalRegistryPrx>& replica, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Establish a session to the given replica, this method only returns once the registration was attempted (unlike
     * replicaAdded below).
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    registerWithReplicaAsync(const ::std::optional<InternalRegistryPrx>& replica, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_registerWithReplica(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::optional<InternalRegistryPrx>&, const ::Ice::Context&) const;
    /// \endcond

    /**
     * Get the node name.
     * @param context The Context map to send with the invocation.
     */
    ::std::string getName(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Get the node name.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    ::std::future<::std::string> getNameAsync(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Get the node name.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    getNameAsync(::std::function<void(::std::string)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_getName(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::string>>&, const ::Ice::Context&) const;
    /// \endcond

    /**
     * Get the node hostname.
     * @param context The Context map to send with the invocation.
     */
    ::std::string getHostname(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Get the node hostname.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    ::std::future<::std::string> getHostnameAsync(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Get the node hostname.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    getHostnameAsync(::std::function<void(::std::string)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_getHostname(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::string>>&, const ::Ice::Context&) const;
    /// \endcond

    /**
     * Get the node load.
     * @param context The Context map to send with the invocation.
     */
    LoadInfo getLoad(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Get the node load.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    ::std::future<LoadInfo> getLoadAsync(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Get the node load.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    getLoadAsync(::std::function<void(::IceGrid::LoadInfo)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_getLoad(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<LoadInfo>>&, const ::Ice::Context&) const;
    /// \endcond

    /**
     * Get the number of processor sockets for the machine where this node is running.
     * @param context The Context map to send with the invocation.
     */
    ::std::int32_t getProcessorSocketCount(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Get the number of processor sockets for the machine where this node is running.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    ::std::future<::std::int32_t> getProcessorSocketCountAsync(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Get the number of processor sockets for the machine where this node is running.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    getProcessorSocketCountAsync(::std::function<void(::std::int32_t)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_getProcessorSocketCount(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::int32_t>>&, const ::Ice::Context&) const;
    /// \endcond

    /**
     * Shutdown the node.
     * @param context The Context map to send with the invocation.
     */
    void shutdown(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Shutdown the node.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    ::std::future<void> shutdownAsync(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Shutdown the node.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    shutdownAsync(::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_shutdown(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&) const;
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId();

#if defined(__GNUC__)
#   pragma GCC diagnostic push
#   pragma GCC diagnostic ignored "-Wextra" // initialize all virtual bases in correct order
#endif

    explicit NodePrx(const ::Ice::ObjectPrx& other) : ::Ice::ObjectPrx(other)
    {
    }

    NodePrx(const NodePrx& other) noexcept : ::Ice::ObjectPrx(other)
    {
    }

    NodePrx(NodePrx&& other) noexcept : ::Ice::ObjectPrx(::std::move(other))
    {
    }

    NodePrx(const ::std::shared_ptr<::Ice::Communicator>& communicator, const ::std::string& proxyString) :
        ::Ice::ObjectPrx(communicator, proxyString)
    {
    }

    NodePrx& operator=(const NodePrx& rhs) noexcept
    {
        ::Ice::ObjectPrx::operator=(rhs);
        return *this;
    }

    NodePrx& operator=(NodePrx&& rhs) noexcept
    {
        ::Ice::ObjectPrx::operator=(::std::move(rhs));
        return *this;
    }

    /// \cond INTERNAL
    static NodePrx _fromReference(::IceInternal::ReferencePtr ref) { return NodePrx(::std::move(ref)); }

protected:

    NodePrx() = default;

    explicit NodePrx(::IceInternal::ReferencePtr&& ref) : ::Ice::ObjectPrx(::std::move(ref))
    {
    }
    /// \endcond

#if defined(__GNUC__)
#   pragma GCC diagnostic pop
#endif
};

class NodeSessionPrx : public ::Ice::Proxy<NodeSessionPrx, ::Ice::ObjectPrx>
{
public:

    /**
     * The node call this method to keep the session alive.
     * @param context The Context map to send with the invocation.
     */
    void keepAlive(const LoadInfo& load, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * The node call this method to keep the session alive.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    ::std::future<void> keepAliveAsync(const LoadInfo& load, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * The node call this method to keep the session alive.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    keepAliveAsync(const LoadInfo& load, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_keepAlive(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const LoadInfo&, const ::Ice::Context&) const;
    /// \endcond

    /**
     * Set the replica observer. The node calls this method when it's ready to receive notifications for the replicas.
     * It only calls this for the session with the master.
     * @param context The Context map to send with the invocation.
     */
    void setReplicaObserver(const ::std::optional<ReplicaObserverPrx>& observer, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Set the replica observer. The node calls this method when it's ready to receive notifications for the replicas.
     * It only calls this for the session with the master.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    ::std::future<void> setReplicaObserverAsync(const ::std::optional<ReplicaObserverPrx>& observer, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Set the replica observer. The node calls this method when it's ready to receive notifications for the replicas.
     * It only calls this for the session with the master.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    setReplicaObserverAsync(const ::std::optional<ReplicaObserverPrx>& observer, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_setReplicaObserver(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::optional<ReplicaObserverPrx>&, const ::Ice::Context&) const;
    /// \endcond

    /**
     * Return the node session timeout.
     * @param context The Context map to send with the invocation.
     */
    ::std::int32_t getTimeout(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Return the node session timeout.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    ::std::future<::std::int32_t> getTimeoutAsync(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Return the node session timeout.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    getTimeoutAsync(::std::function<void(::std::int32_t)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_getTimeout(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::int32_t>>&, const ::Ice::Context&) const;
    /// \endcond

    /**
     * Return the node observer.
     * @param context The Context map to send with the invocation.
     */
    ::std::optional<NodeObserverPrx> getObserver(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Return the node observer.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    ::std::future<::std::optional<NodeObserverPrx>> getObserverAsync(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Return the node observer.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    getObserverAsync(::std::function<void(::std::optional<::IceGrid::NodeObserverPrx>)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_getObserver(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::optional<NodeObserverPrx>>>&, const ::Ice::Context&) const;
    /// \endcond

    /**
     * Ask the registry to load the servers on the node.
     * @param context The Context map to send with the invocation.
     */
    void loadServers(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Ask the registry to load the servers on the node.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    ::std::future<void> loadServersAsync(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Ask the registry to load the servers on the node.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    loadServersAsync(::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_loadServers(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&) const;
    /// \endcond

    /**
     * Get the name of the servers deployed on the node.
     * @param context The Context map to send with the invocation.
     */
    ::Ice::StringSeq getServers(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Get the name of the servers deployed on the node.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    ::std::future<::Ice::StringSeq> getServersAsync(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Get the name of the servers deployed on the node.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    getServersAsync(::std::function<void(::Ice::StringSeq)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_getServers(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::Ice::StringSeq>>&, const ::Ice::Context&) const;
    /// \endcond

    /**
     * Wait for the application update to complete (the application is completely updated once all the registry
     * replicas have been updated). This is used by the node to ensure that before to start a server all the
     * replicas have the up-to-date descriptor of the server.
     * @param context The Context map to send with the invocation.
     */
    void waitForApplicationUpdate(::std::string_view application, ::std::int32_t revision, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Wait for the application update to complete (the application is completely updated once all the registry
     * replicas have been updated). This is used by the node to ensure that before to start a server all the
     * replicas have the up-to-date descriptor of the server.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    ::std::future<void> waitForApplicationUpdateAsync(::std::string_view application, ::std::int32_t revision, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Wait for the application update to complete (the application is completely updated once all the registry
     * replicas have been updated). This is used by the node to ensure that before to start a server all the
     * replicas have the up-to-date descriptor of the server.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    waitForApplicationUpdateAsync(::std::string_view application, ::std::int32_t revision, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_waitForApplicationUpdate(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, ::std::string_view, ::std::int32_t, const ::Ice::Context&) const;
    /// \endcond

    /**
     * Destroy the session.
     * @param context The Context map to send with the invocation.
     */
    void destroy(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Destroy the session.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    ::std::future<void> destroyAsync(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Destroy the session.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    destroyAsync(::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_destroy(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&) const;
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId();

    explicit NodeSessionPrx(const ::Ice::ObjectPrx& other) : ::Ice::ObjectPrx(other)
    {
    }

    NodeSessionPrx(const NodeSessionPrx& other) noexcept : ::Ice::ObjectPrx(other)
    {
    }

    NodeSessionPrx(NodeSessionPrx&& other) noexcept : ::Ice::ObjectPrx(::std::move(other))
    {
    }

    NodeSessionPrx(const ::std::shared_ptr<::Ice::Communicator>& communicator, const ::std::string& proxyString) :
        ::Ice::ObjectPrx(communicator, proxyString)
    {
    }

    NodeSessionPrx& operator=(const NodeSessionPrx& rhs) noexcept
    {
        ::Ice::ObjectPrx::operator=(rhs);
        return *this;
    }

    NodeSessionPrx& operator=(NodeSessionPrx&& rhs) noexcept
    {
        ::Ice::ObjectPrx::operator=(::std::move(rhs));
        return *this;
    }

    /// \cond INTERNAL
    static NodeSessionPrx _fromReference(::IceInternal::ReferencePtr ref) { return NodeSessionPrx(::std::move(ref)); }

protected:

    NodeSessionPrx() = default;

    explicit NodeSessionPrx(::IceInternal::ReferencePtr&& ref) : ::Ice::ObjectPrx(::std::move(ref))
    {
    }
    /// \endcond
};

class DatabaseObserverPrx : public ::Ice::Proxy<DatabaseObserverPrx, ApplicationObserverPrx, ObjectObserverPrx, AdapterObserverPrx>
{
public:

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId();

#if defined(__GNUC__)
#   pragma GCC diagnostic push
#   pragma GCC diagnostic ignored "-Wextra" // initialize all virtual bases in correct order
#endif

    explicit DatabaseObserverPrx(const ::Ice::ObjectPrx& other) : ::Ice::ObjectPrx(other)
    {
    }

    DatabaseObserverPrx(const DatabaseObserverPrx& other) noexcept : ::Ice::ObjectPrx(other)
    {
    }

    DatabaseObserverPrx(DatabaseObserverPrx&& other) noexcept : ::Ice::ObjectPrx(::std::move(other))
    {
    }

    DatabaseObserverPrx(const ::std::shared_ptr<::Ice::Communicator>& communicator, const ::std::string& proxyString) :
        ::Ice::ObjectPrx(communicator, proxyString)
    {
    }

    DatabaseObserverPrx& operator=(const DatabaseObserverPrx& rhs) noexcept
    {
        ::Ice::ObjectPrx::operator=(rhs);
        return *this;
    }

    DatabaseObserverPrx& operator=(DatabaseObserverPrx&& rhs) noexcept
    {
        ::Ice::ObjectPrx::operator=(::std::move(rhs));
        return *this;
    }

    /// \cond INTERNAL
    static DatabaseObserverPrx _fromReference(::IceInternal::ReferencePtr ref) { return DatabaseObserverPrx(::std::move(ref)); }

protected:

    DatabaseObserverPrx() = default;

    explicit DatabaseObserverPrx(::IceInternal::ReferencePtr&& ref) : ::Ice::ObjectPrx(::std::move(ref))
    {
    }
    /// \endcond

#if defined(__GNUC__)
#   pragma GCC diagnostic pop
#endif
};

class ReplicaSessionPrx : public ::Ice::Proxy<ReplicaSessionPrx, ::Ice::ObjectPrx>
{
public:

    /**
     * The replica call this method to keep the session alive.
     * @param context The Context map to send with the invocation.
     */
    void keepAlive(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * The replica call this method to keep the session alive.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    ::std::future<void> keepAliveAsync(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * The replica call this method to keep the session alive.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    keepAliveAsync(::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_keepAlive(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&) const;
    /// \endcond

    /**
     * Return the replica session timeout.
     * @param context The Context map to send with the invocation.
     */
    ::std::int32_t getTimeout(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Return the replica session timeout.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    ::std::future<::std::int32_t> getTimeoutAsync(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Return the replica session timeout.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    getTimeoutAsync(::std::function<void(::std::int32_t)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_getTimeout(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::int32_t>>&, const ::Ice::Context&) const;
    /// \endcond

    /**
     * Set the database observer. Once the observer is subscribed, it will receive the database and database updates.
     * @param context The Context map to send with the invocation.
     */
    void setDatabaseObserver(const ::std::optional<DatabaseObserverPrx>& dbObs, const ::std::optional<StringLongDict>& serials, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Set the database observer. Once the observer is subscribed, it will receive the database and database updates.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    ::std::future<void> setDatabaseObserverAsync(const ::std::optional<DatabaseObserverPrx>& dbObs, const ::std::optional<StringLongDict>& serials, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Set the database observer. Once the observer is subscribed, it will receive the database and database updates.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    setDatabaseObserverAsync(const ::std::optional<DatabaseObserverPrx>& dbObs, const ::std::optional<StringLongDict>& serials, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_setDatabaseObserver(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::optional<DatabaseObserverPrx>&, const ::std::optional<StringLongDict>&, const ::Ice::Context&) const;
    /// \endcond

    /**
     * This method sets the endpoints of the replica. This allows the master to create proxies with multiple endpoints
     * for replicated objects (e.g.: IceGrid::Query object).
     * @param context The Context map to send with the invocation.
     */
    void setEndpoints(const StringObjectProxyDict& endpoints, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * This method sets the endpoints of the replica. This allows the master to create proxies with multiple endpoints
     * for replicated objects (e.g.: IceGrid::Query object).
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    ::std::future<void> setEndpointsAsync(const StringObjectProxyDict& endpoints, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * This method sets the endpoints of the replica. This allows the master to create proxies with multiple endpoints
     * for replicated objects (e.g.: IceGrid::Query object).
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    setEndpointsAsync(const StringObjectProxyDict& endpoints, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_setEndpoints(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const StringObjectProxyDict&, const ::Ice::Context&) const;
    /// \endcond

    /**
     * Registers the replica well-known objects with the master.
     * @param context The Context map to send with the invocation.
     */
    void registerWellKnownObjects(const ObjectInfoSeq& objects, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Registers the replica well-known objects with the master.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    ::std::future<void> registerWellKnownObjectsAsync(const ObjectInfoSeq& objects, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Registers the replica well-known objects with the master.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    registerWellKnownObjectsAsync(const ObjectInfoSeq& objects, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_registerWellKnownObjects(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ObjectInfoSeq&, const ::Ice::Context&) const;
    /// \endcond

    /**
     * Set the adapter direct proxy of the given adapter in the master. This is used to support dynamic registration
     * with the locator registry interface.
     * @param context The Context map to send with the invocation.
     */
    void setAdapterDirectProxy(::std::string_view adapterId, ::std::string_view replicaGroupId, const ::std::optional<::Ice::ObjectPrx>& proxy, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Set the adapter direct proxy of the given adapter in the master. This is used to support dynamic registration
     * with the locator registry interface.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    ::std::future<void> setAdapterDirectProxyAsync(::std::string_view adapterId, ::std::string_view replicaGroupId, const ::std::optional<::Ice::ObjectPrx>& proxy, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Set the adapter direct proxy of the given adapter in the master. This is used to support dynamic registration
     * with the locator registry interface.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    setAdapterDirectProxyAsync(::std::string_view adapterId, ::std::string_view replicaGroupId, const ::std::optional<::Ice::ObjectPrx>& proxy, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_setAdapterDirectProxy(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, ::std::string_view, ::std::string_view, const ::std::optional<::Ice::ObjectPrx>&, const ::Ice::Context&) const;
    /// \endcond

    /**
     * Notify the master that an update was received. The master might wait for replication updates to be received by
     * all the replicas before to continue.
     * @param context The Context map to send with the invocation.
     */
    void receivedUpdate(TopicName name, ::std::int32_t serial, ::std::string_view failure, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Notify the master that an update was received. The master might wait for replication updates to be received by
     * all the replicas before to continue.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    ::std::future<void> receivedUpdateAsync(TopicName name, ::std::int32_t serial, ::std::string_view failure, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Notify the master that an update was received. The master might wait for replication updates to be received by
     * all the replicas before to continue.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    receivedUpdateAsync(TopicName name, ::std::int32_t serial, ::std::string_view failure, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_receivedUpdate(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, TopicName, ::std::int32_t, ::std::string_view, const ::Ice::Context&) const;
    /// \endcond

    /**
     * Destroy the session.
     * @param context The Context map to send with the invocation.
     */
    void destroy(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Destroy the session.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    ::std::future<void> destroyAsync(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Destroy the session.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    destroyAsync(::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_destroy(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&) const;
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId();

    explicit ReplicaSessionPrx(const ::Ice::ObjectPrx& other) : ::Ice::ObjectPrx(other)
    {
    }

    ReplicaSessionPrx(const ReplicaSessionPrx& other) noexcept : ::Ice::ObjectPrx(other)
    {
    }

    ReplicaSessionPrx(ReplicaSessionPrx&& other) noexcept : ::Ice::ObjectPrx(::std::move(other))
    {
    }

    ReplicaSessionPrx(const ::std::shared_ptr<::Ice::Communicator>& communicator, const ::std::string& proxyString) :
        ::Ice::ObjectPrx(communicator, proxyString)
    {
    }

    ReplicaSessionPrx& operator=(const ReplicaSessionPrx& rhs) noexcept
    {
        ::Ice::ObjectPrx::operator=(rhs);
        return *this;
    }

    ReplicaSessionPrx& operator=(ReplicaSessionPrx&& rhs) noexcept
    {
        ::Ice::ObjectPrx::operator=(::std::move(rhs));
        return *this;
    }

    /// \cond INTERNAL
    static ReplicaSessionPrx _fromReference(::IceInternal::ReferencePtr ref) { return ReplicaSessionPrx(::std::move(ref)); }

protected:

    ReplicaSessionPrx() = default;

    explicit ReplicaSessionPrx(::IceInternal::ReferencePtr&& ref) : ::Ice::ObjectPrx(::std::move(ref))
    {
    }
    /// \endcond
};

class InternalRegistryPrx : public ::Ice::Proxy<InternalRegistryPrx, FileReaderPrx>
{
public:

    /**
     * Register a node with the registry. If a node with the same name is already registered, [registerNode] will
     * overide the previous node only if it's not active.
     * @param info Some information on the node.
     * @param prx The proxy of the node.
     * @param loadInf The load information of the node.
     * @param context The Context map to send with the invocation.
     * @return The node session proxy.
     * @throws IceGrid::NodeActiveException Raised if the node is already registered and currently active.
     */
    ::std::optional<NodeSessionPrx> registerNode(const ::std::shared_ptr<InternalNodeInfo>& info, const ::std::optional<NodePrx>& prx, const LoadInfo& loadInf, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Register a node with the registry. If a node with the same name is already registered, [registerNode] will
     * overide the previous node only if it's not active.
     * @param info Some information on the node.
     * @param prx The proxy of the node.
     * @param loadInf The load information of the node.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    ::std::future<::std::optional<NodeSessionPrx>> registerNodeAsync(const ::std::shared_ptr<InternalNodeInfo>& info, const ::std::optional<NodePrx>& prx, const LoadInfo& loadInf, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Register a node with the registry. If a node with the same name is already registered, [registerNode] will
     * overide the previous node only if it's not active.
     * @param info Some information on the node.
     * @param prx The proxy of the node.
     * @param loadInf The load information of the node.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    registerNodeAsync(const ::std::shared_ptr<InternalNodeInfo>& info, const ::std::optional<NodePrx>& prx, const LoadInfo& loadInf, ::std::function<void(::std::optional<::IceGrid::NodeSessionPrx>)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_registerNode(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::optional<NodeSessionPrx>>>&, const ::std::shared_ptr<InternalNodeInfo>&, const ::std::optional<NodePrx>&, const LoadInfo&, const ::Ice::Context&) const;
    /// \endcond

    /**
     * Register a replica with the registry. If a replica with the  same name is already registered, [registerReplica]
     * will overide the previous replica only if it's not active.
     * @param info Some information on the replica.
     * @param prx The proxy of the replica.
     * @param context The Context map to send with the invocation.
     * @return The replica session proxy.
     * @throws IceGrid::ReplicaActiveException Raised if the replica is already registered and currently active.
     */
    ::std::optional<ReplicaSessionPrx> registerReplica(const ::std::shared_ptr<InternalReplicaInfo>& info, const ::std::optional<InternalRegistryPrx>& prx, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Register a replica with the registry. If a replica with the  same name is already registered, [registerReplica]
     * will overide the previous replica only if it's not active.
     * @param info Some information on the replica.
     * @param prx The proxy of the replica.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    ::std::future<::std::optional<ReplicaSessionPrx>> registerReplicaAsync(const ::std::shared_ptr<InternalReplicaInfo>& info, const ::std::optional<InternalRegistryPrx>& prx, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Register a replica with the registry. If a replica with the  same name is already registered, [registerReplica]
     * will overide the previous replica only if it's not active.
     * @param info Some information on the replica.
     * @param prx The proxy of the replica.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    registerReplicaAsync(const ::std::shared_ptr<InternalReplicaInfo>& info, const ::std::optional<InternalRegistryPrx>& prx, ::std::function<void(::std::optional<::IceGrid::ReplicaSessionPrx>)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_registerReplica(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::optional<ReplicaSessionPrx>>>&, const ::std::shared_ptr<InternalReplicaInfo>&, const ::std::optional<InternalRegistryPrx>&, const ::Ice::Context&) const;
    /// \endcond

    /**
     * Create a session with the given registry replica. This method returns only once the session creation has been
     * attempted.
     * @param context The Context map to send with the invocation.
     */
    void registerWithReplica(const ::std::optional<InternalRegistryPrx>& prx, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Create a session with the given registry replica. This method returns only once the session creation has been
     * attempted.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    ::std::future<void> registerWithReplicaAsync(const ::std::optional<InternalRegistryPrx>& prx, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Create a session with the given registry replica. This method returns only once the session creation has been
     * attempted.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    registerWithReplicaAsync(const ::std::optional<InternalRegistryPrx>& prx, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_registerWithReplica(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::optional<InternalRegistryPrx>&, const ::Ice::Context&) const;
    /// \endcond

    /**
     * Return the proxies of all the nodes known by this registry.
     * @param context The Context map to send with the invocation.
     */
    NodePrxSeq getNodes(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Return the proxies of all the nodes known by this registry.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    ::std::future<NodePrxSeq> getNodesAsync(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Return the proxies of all the nodes known by this registry.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    getNodesAsync(::std::function<void(::IceGrid::NodePrxSeq)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_getNodes(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<NodePrxSeq>>&, const ::Ice::Context&) const;
    /// \endcond

    /**
     * Return the proxies of all the registry replicas known by this registry.
     * @param context The Context map to send with the invocation.
     */
    InternalRegistryPrxSeq getReplicas(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Return the proxies of all the registry replicas known by this registry.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    ::std::future<InternalRegistryPrxSeq> getReplicasAsync(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Return the proxies of all the registry replicas known by this registry.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    getReplicasAsync(::std::function<void(::IceGrid::InternalRegistryPrxSeq)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_getReplicas(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<InternalRegistryPrxSeq>>&, const ::Ice::Context&) const;
    /// \endcond

    /**
     * Return applications, adapters, objects from this replica.
     * @param context The Context map to send with the invocation.
     */
    ApplicationInfoSeq getApplications(::std::int64_t& serial, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Return applications, adapters, objects from this replica.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    ::std::future<::std::tuple<ApplicationInfoSeq, ::std::int64_t>> getApplicationsAsync(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Return applications, adapters, objects from this replica.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    getApplicationsAsync(::std::function<void(::IceGrid::ApplicationInfoSeq, ::std::int64_t)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_getApplications(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<ApplicationInfoSeq, ::std::int64_t>>>&, const ::Ice::Context&) const;
    /// \endcond

    AdapterInfoSeq getAdapters(::std::int64_t& serial, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<AdapterInfoSeq, ::std::int64_t>> getAdaptersAsync(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    getAdaptersAsync(::std::function<void(::IceGrid::AdapterInfoSeq, ::std::int64_t)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_getAdapters(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<AdapterInfoSeq, ::std::int64_t>>>&, const ::Ice::Context&) const;
    /// \endcond

    ObjectInfoSeq getObjects(::std::int64_t& serial, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<ObjectInfoSeq, ::std::int64_t>> getObjectsAsync(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    getObjectsAsync(::std::function<void(::IceGrid::ObjectInfoSeq, ::std::int64_t)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_getObjects(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<ObjectInfoSeq, ::std::int64_t>>>&, const ::Ice::Context&) const;
    /// \endcond

    /**
     * Shutdown this registry.
     * @param context The Context map to send with the invocation.
     */
    void shutdown(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Shutdown this registry.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    ::std::future<void> shutdownAsync(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Shutdown this registry.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    shutdownAsync(::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_shutdown(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&) const;
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId();

#if defined(__GNUC__)
#   pragma GCC diagnostic push
#   pragma GCC diagnostic ignored "-Wextra" // initialize all virtual bases in correct order
#endif

    explicit InternalRegistryPrx(const ::Ice::ObjectPrx& other) : ::Ice::ObjectPrx(other)
    {
    }

    InternalRegistryPrx(const InternalRegistryPrx& other) noexcept : ::Ice::ObjectPrx(other)
    {
    }

    InternalRegistryPrx(InternalRegistryPrx&& other) noexcept : ::Ice::ObjectPrx(::std::move(other))
    {
    }

    InternalRegistryPrx(const ::std::shared_ptr<::Ice::Communicator>& communicator, const ::std::string& proxyString) :
        ::Ice::ObjectPrx(communicator, proxyString)
    {
    }

    InternalRegistryPrx& operator=(const InternalRegistryPrx& rhs) noexcept
    {
        ::Ice::ObjectPrx::operator=(rhs);
        return *this;
    }

    InternalRegistryPrx& operator=(InternalRegistryPrx&& rhs) noexcept
    {
        ::Ice::ObjectPrx::operator=(::std::move(rhs));
        return *this;
    }

    /// \cond INTERNAL
    static InternalRegistryPrx _fromReference(::IceInternal::ReferencePtr ref) { return InternalRegistryPrx(::std::move(ref)); }

protected:

    InternalRegistryPrx() = default;

    explicit InternalRegistryPrx(::IceInternal::ReferencePtr&& ref) : ::Ice::ObjectPrx(::std::move(ref))
    {
    }
    /// \endcond

#if defined(__GNUC__)
#   pragma GCC diagnostic pop
#endif
};

}

namespace IceGrid
{

class InternalDbEnvDescriptor : public ::Ice::ValueHelper<InternalDbEnvDescriptor, ::Ice::Value>
{
public:

    virtual ~InternalDbEnvDescriptor();

    InternalDbEnvDescriptor() = default;

    InternalDbEnvDescriptor(const InternalDbEnvDescriptor&) = default;
    InternalDbEnvDescriptor(InternalDbEnvDescriptor&&) = default;
    InternalDbEnvDescriptor& operator=(const InternalDbEnvDescriptor&) = default;
    InternalDbEnvDescriptor& operator=(InternalDbEnvDescriptor&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     * @param name The name of the database environment.
     * @param properties The database properties.
     */
    InternalDbEnvDescriptor(::std::string_view name, const ::IceGrid::PropertyDescriptorSeq& properties) :
        name(name),
        properties(properties)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::IceGrid::PropertyDescriptorSeq&> ice_tuple() const
    {
        return std::tie(name, properties);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId();

    /**
     * The name of the database environment.
     */
    ::std::string name;
    /**
     * The database properties.
     */
    ::IceGrid::PropertyDescriptorSeq properties;
};

/// \cond INTERNAL
static InternalDbEnvDescriptor _iceS_InternalDbEnvDescriptor_init;
/// \endcond

class InternalAdapterDescriptor : public ::Ice::ValueHelper<InternalAdapterDescriptor, ::Ice::Value>
{
public:

    virtual ~InternalAdapterDescriptor();

    InternalAdapterDescriptor() = default;

    InternalAdapterDescriptor(const InternalAdapterDescriptor&) = default;
    InternalAdapterDescriptor(InternalAdapterDescriptor&&) = default;
    InternalAdapterDescriptor& operator=(const InternalAdapterDescriptor&) = default;
    InternalAdapterDescriptor& operator=(InternalAdapterDescriptor&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     * @param id The identifier of the server.
     * @param serverLifetime Specifies if the lifetime of the adapter is the same as the server.
     */
    InternalAdapterDescriptor(::std::string_view id, bool serverLifetime) :
        id(id),
        serverLifetime(serverLifetime)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const bool&> ice_tuple() const
    {
        return std::tie(id, serverLifetime);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId();

    /**
     * The identifier of the server.
     */
    ::std::string id;
    /**
     * Specifies if the lifetime of the adapter is the same as the server.
     */
    bool serverLifetime;
};

class InternalDistributionDescriptor : public ::Ice::ValueHelper<InternalDistributionDescriptor, ::Ice::Value>
{
public:

    virtual ~InternalDistributionDescriptor();

    InternalDistributionDescriptor() = default;

    InternalDistributionDescriptor(const InternalDistributionDescriptor&) = default;
    InternalDistributionDescriptor(InternalDistributionDescriptor&&) = default;
    InternalDistributionDescriptor& operator=(const InternalDistributionDescriptor&) = default;
    InternalDistributionDescriptor& operator=(InternalDistributionDescriptor&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     * @param icepatch The proxy of the IcePatch2 server.
     * @param directories The source directories.
     */
    InternalDistributionDescriptor(::std::string_view icepatch, const ::Ice::StringSeq& directories) :
        icepatch(icepatch),
        directories(directories)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::Ice::StringSeq&> ice_tuple() const
    {
        return std::tie(icepatch, directories);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId();

    /**
     * The proxy of the IcePatch2 server.
     */
    ::std::string icepatch;
    /**
     * The source directories.
     */
    ::Ice::StringSeq directories;
};

class InternalServerDescriptor : public ::Ice::ValueHelper<InternalServerDescriptor, ::Ice::Value>
{
public:

    virtual ~InternalServerDescriptor();

    InternalServerDescriptor() = default;

    InternalServerDescriptor(const InternalServerDescriptor&) = default;
    InternalServerDescriptor(InternalServerDescriptor&&) = default;
    InternalServerDescriptor& operator=(const InternalServerDescriptor&) = default;
    InternalServerDescriptor& operator=(InternalServerDescriptor&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     * @param id The server ID.
     * @param application The server application
     * @param uuid The application uuid.
     * @param revision The application revision.
     * @param sessionId The id of the session which allocated the server.
     * @param exe The server executable.
     * @param pwd The server working directory.
     * @param user The user ID to use to run the server.
     * @param activation The server activation mode.
     * @param activationTimeout The server activation timeout.
     * @param deactivationTimeout The server deactivation timeout.
     * @param applicationDistrib Specifies if the server depends on the application distrib.
     * @param distrib The distribution descriptor of this server.
     * @param processRegistered Specifies if a process object is registered.
     * @param options The server command line options.
     * @param envs The server environment variables.
     * @param logs The path of the server logs.
     * @param adapters The indirect object adapters.
     * @param properties The configuration files of the server.
     * @param services IceBox service names
     */
    InternalServerDescriptor(::std::string_view id, ::std::string_view application, ::std::string_view uuid, ::std::int32_t revision, ::std::string_view sessionId, ::std::string_view exe, ::std::string_view pwd, ::std::string_view user, ::std::string_view activation, ::std::string_view activationTimeout, ::std::string_view deactivationTimeout, bool applicationDistrib, const ::std::shared_ptr<::IceGrid::InternalDistributionDescriptor>& distrib, bool processRegistered, const ::Ice::StringSeq& options, const ::Ice::StringSeq& envs, const ::Ice::StringSeq& logs, const ::IceGrid::InternalAdapterDescriptorSeq& adapters, const ::IceGrid::InternalDbEnvDescriptorSeq& dbEnvs, const ::IceGrid::PropertyDescriptorSeqDict& properties, const ::std::optional<::Ice::StringSeq>& services) :
        id(id),
        application(application),
        uuid(uuid),
        revision(revision),
        sessionId(sessionId),
        exe(exe),
        pwd(pwd),
        user(user),
        activation(activation),
        activationTimeout(activationTimeout),
        deactivationTimeout(deactivationTimeout),
        applicationDistrib(applicationDistrib),
        distrib(distrib),
        processRegistered(processRegistered),
        options(options),
        envs(envs),
        logs(logs),
        adapters(adapters),
        dbEnvs(dbEnvs),
        properties(properties),
        services(services)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::std::string&, const ::std::string&, const ::std::int32_t&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const bool&, const ::std::shared_ptr<::IceGrid::InternalDistributionDescriptor>&, const bool&, const ::Ice::StringSeq&, const ::Ice::StringSeq&, const ::Ice::StringSeq&, const ::IceGrid::InternalAdapterDescriptorSeq&, const ::IceGrid::InternalDbEnvDescriptorSeq&, const ::IceGrid::PropertyDescriptorSeqDict&, const ::std::optional<::Ice::StringSeq>&> ice_tuple() const
    {
        return std::tie(id, application, uuid, revision, sessionId, exe, pwd, user, activation, activationTimeout, deactivationTimeout, applicationDistrib, distrib, processRegistered, options, envs, logs, adapters, dbEnvs, properties, services);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId();

    /**
     * The server ID.
     */
    ::std::string id;
    /**
     * The server application
     */
    ::std::string application;
    /**
     * The application uuid.
     */
    ::std::string uuid;
    /**
     * The application revision.
     */
    ::std::int32_t revision;
    /**
     * The id of the session which allocated the server.
     */
    ::std::string sessionId;
    /**
     * The server executable.
     */
    ::std::string exe;
    /**
     * The server working directory.
     */
    ::std::string pwd;
    /**
     * The user ID to use to run the server.
     */
    ::std::string user;
    /**
     * The server activation mode.
     */
    ::std::string activation;
    /**
     * The server activation timeout.
     */
    ::std::string activationTimeout;
    /**
     * The server deactivation timeout.
     */
    ::std::string deactivationTimeout;
    /**
     * Specifies if the server depends on the application distrib.
     */
    bool applicationDistrib;
    /**
     * The distribution descriptor of this server.
     */
    ::std::shared_ptr<::IceGrid::InternalDistributionDescriptor> distrib;
    /**
     * Specifies if a process object is registered.
     */
    bool processRegistered;
    /**
     * The server command line options.
     */
    ::Ice::StringSeq options;
    /**
     * The server environment variables.
     */
    ::Ice::StringSeq envs;
    /**
     * The path of the server logs.
     */
    ::Ice::StringSeq logs;
    /**
     * The indirect object adapters.
     */
    ::IceGrid::InternalAdapterDescriptorSeq adapters;
    ::IceGrid::InternalDbEnvDescriptorSeq dbEnvs;
    /**
     * The configuration files of the server.
     */
    ::IceGrid::PropertyDescriptorSeqDict properties;
    /**
     * IceBox service names
     */
    ::std::optional<::Ice::StringSeq> services;
};

/**
 * This exception is raised if an adapter is active.
 */
class AdapterActiveException : public ::Ice::UserExceptionHelper<AdapterActiveException, ::Ice::UserException>
{
public:

    virtual ~AdapterActiveException();

    AdapterActiveException(const AdapterActiveException&) = default;

    AdapterActiveException() = default;

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<> ice_tuple() const
    {
        return std::tie();
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId();
};

class AdapterNotActiveException : public ::Ice::UserExceptionHelper<AdapterNotActiveException, ::Ice::UserException>
{
public:

    virtual ~AdapterNotActiveException();

    AdapterNotActiveException(const AdapterNotActiveException&) = default;

    AdapterNotActiveException() = default;

    /**
     * One-shot constructor to initialize all data members.
     * @param activatable True if the adapter can be activated on demand.
     */
    AdapterNotActiveException(bool activatable) :
        activatable(activatable)
    {
    }

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const bool&> ice_tuple() const
    {
        return std::tie(activatable);
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId();

    /**
     * True if the adapter can be activated on demand.
     */
    bool activatable;
};

/**
 * This exception is raised if an adapter with the same name already exists.
 */
class AdapterExistsException : public ::Ice::UserExceptionHelper<AdapterExistsException, ::Ice::UserException>
{
public:

    virtual ~AdapterExistsException();

    AdapterExistsException(const AdapterExistsException&) = default;

    AdapterExistsException() = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    AdapterExistsException(::std::string_view id) :
        id(id)
    {
    }

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&> ice_tuple() const
    {
        return std::tie(id);
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId();

    ::std::string id;
};

/**
 * This exception is raised if a node is already registered and active.
 */
class NodeActiveException : public ::Ice::UserExceptionHelper<NodeActiveException, ::Ice::UserException>
{
public:

    virtual ~NodeActiveException();

    NodeActiveException(const NodeActiveException&) = default;

    NodeActiveException() = default;

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<> ice_tuple() const
    {
        return std::tie();
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId();
};

/**
 * This exception is raised if a replica is already registered and active.
 */
class ReplicaActiveException : public ::Ice::UserExceptionHelper<ReplicaActiveException, ::Ice::UserException>
{
public:

    virtual ~ReplicaActiveException();

    ReplicaActiveException(const ReplicaActiveException&) = default;

    ReplicaActiveException() = default;

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<> ice_tuple() const
    {
        return std::tie();
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId();
};

/**
 * Information about an IceGrid node.
 */
class InternalNodeInfo : public ::Ice::ValueHelper<InternalNodeInfo, ::Ice::Value>
{
public:

    virtual ~InternalNodeInfo();

    InternalNodeInfo() = default;

    InternalNodeInfo(const InternalNodeInfo&) = default;
    InternalNodeInfo(InternalNodeInfo&&) = default;
    InternalNodeInfo& operator=(const InternalNodeInfo&) = default;
    InternalNodeInfo& operator=(InternalNodeInfo&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     * @param name The name of the node.
     * @param os The operating system name.
     * @param hostname The network name of the host running this node (as defined in uname()).
     * @param release The operation system release level (as defined in uname()).
     * @param version The operation system version (as defined in uname()).
     * @param machine The machine hardware type (as defined in uname()).
     * @param nProcessors The number of processor threads (e.g.
     * @param dataDir The path to the node data directory.
     */
    InternalNodeInfo(::std::string_view name, ::std::string_view os, ::std::string_view hostname, ::std::string_view release, ::std::string_view version, ::std::string_view machine, ::std::int32_t nProcessors, ::std::string_view dataDir) :
        name(name),
        os(os),
        hostname(hostname),
        release(release),
        version(version),
        machine(machine),
        nProcessors(nProcessors),
        dataDir(dataDir)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::int32_t&, const ::std::string&> ice_tuple() const
    {
        return std::tie(name, os, hostname, release, version, machine, nProcessors, dataDir);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId();

    /**
     * The name of the node.
     */
    ::std::string name;
    /**
     * The operating system name.
     */
    ::std::string os;
    /**
     * The network name of the host running this node (as defined in uname()).
     */
    ::std::string hostname;
    /**
     * The operation system release level (as defined in uname()).
     */
    ::std::string release;
    /**
     * The operation system version (as defined in uname()).
     */
    ::std::string version;
    /**
     * The machine hardware type (as defined in uname()).
     */
    ::std::string machine;
    /**
     * The number of processor threads (e.g. 8 on system with 1 quad-core CPU, with 2 threads per core)
     */
    ::std::int32_t nProcessors;
    /**
     * The path to the node data directory.
     */
    ::std::string dataDir;
};

/**
 * Information about an IceGrid registry replica.
 */
class InternalReplicaInfo : public ::Ice::ValueHelper<InternalReplicaInfo, ::Ice::Value>
{
public:

    virtual ~InternalReplicaInfo();

    InternalReplicaInfo() = default;

    InternalReplicaInfo(const InternalReplicaInfo&) = default;
    InternalReplicaInfo(InternalReplicaInfo&&) = default;
    InternalReplicaInfo& operator=(const InternalReplicaInfo&) = default;
    InternalReplicaInfo& operator=(InternalReplicaInfo&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     * @param name The name of the registry.
     * @param hostname The network name of the host running this registry (as defined in uname()).
     */
    InternalReplicaInfo(::std::string_view name, ::std::string_view hostname) :
        name(name),
        hostname(hostname)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::std::string&> ice_tuple() const
    {
        return std::tie(name, hostname);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId();

    /**
     * The name of the registry.
     */
    ::std::string name;
    /**
     * The network name of the host running this registry (as defined in uname()).
     */
    ::std::string hostname;
};

}

namespace IceGrid
{

class Adapter : public virtual ::Ice::Object
{
public:

    using ProxyType = AdapterPrx;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static ::std::string_view ice_staticId();

    /**
     * Activate this adapter. If this adapter can be activated, this will activate the adapter and return the direct
     * proxy of the adapter once it's active. If this adapter can be activated on demand, this will return 0 if the
     * adapter is inactive or the adapter direct proxy it's active.
     * @param response The response callback.
     * @param exception The exception callback.
     * @param current The Current object for the invocation.
     */
    virtual void activateAsync(::std::function<void(const ::std::optional<::Ice::ObjectPrx>& returnValue)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_activate(::IceInternal::Incoming&);
    /// \endcond

    /**
     * Get the adapter direct proxy. The adapter direct proxy is a proxy created with the object adapter. The proxy
     * contains the last known adapter endpoints.
     * @param current The Current object for the invocation.
     * @return A direct proxy containing the last known adapter endpoints if the adapter is already active.
     */
    virtual ::std::optional<::Ice::ObjectPrx> getDirectProxy(const ::Ice::Current& current) const = 0;
    /// \cond INTERNAL
    bool _iceD_getDirectProxy(::IceInternal::Incoming&) const;
    /// \endcond

    /**
     * Set the direct proxy for this adapter.
     * @param current The Current object for the invocation.
     * @throws IceGrid::AdapterActiveException The adapter is already active. It's not possible to override the direct proxy of
     * an active adapter.
     */
    virtual void setDirectProxy(::std::optional<::Ice::ObjectPrx> proxy, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_setDirectProxy(::IceInternal::Incoming&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&) override;
    /// \endcond
};

using AdapterPtr = ::std::shared_ptr<Adapter>;

class FileReader : public virtual ::Ice::Object
{
public:

    using ProxyType = FileReaderPrx;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static ::std::string_view ice_staticId();

    /**
     * Count the number of given lines from the end of the file and return the file offset.
     * @param current The Current object for the invocation.
     */
    virtual ::std::int64_t getOffsetFromEnd(::std::string filename, ::std::int32_t lines, const ::Ice::Current& current) const = 0;
    /// \cond INTERNAL
    bool _iceD_getOffsetFromEnd(::IceInternal::Incoming&) const;
    /// \endcond

    /**
     * Read lines (or size bytes) at the specified position from the given file.
     * @param current The Current object for the invocation.
     */
    virtual bool read(::std::string filename, ::std::int64_t pos, ::std::int32_t size, ::std::int64_t& newPos, ::Ice::StringSeq& lines, const ::Ice::Current& current) const = 0;
    /// \cond INTERNAL
    bool _iceD_read(::IceInternal::Incoming&) const;
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&) override;
    /// \endcond
};

using FileReaderPtr = ::std::shared_ptr<FileReader>;

class Server : public virtual FileReader
{
public:

    using ProxyType = ServerPrx;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static ::std::string_view ice_staticId();

    /**
     * Start the server.
     * @param response The response callback.
     * @param exception The exception callback.
     * @param current The Current object for the invocation.
     */
    virtual void startAsync(::std::function<void()> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_start(::IceInternal::Incoming&);
    /// \endcond

    /**
     * Stop the server. This methods returns only when the server is deactivated. If the server doesn't stop after a
     * configurable amount of time, it will be killed.
     * @param response The response callback.
     * @param exception The exception callback.
     * @param current The Current object for the invocation.
     */
    virtual void stopAsync(::std::function<void()> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_stop(::IceInternal::Incoming&);
    /// \endcond

    /**
     * Check if the given server can be loaded on this node.
     * @param current The Current object for the invocation.
     * @return True if the server is inactive.
     * @throws IceGrid::DeploymentException Raised if the server can't be updated.
     */
    virtual bool checkUpdate(::std::shared_ptr<InternalServerDescriptor> svr, bool noRestart, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_checkUpdate(::IceInternal::Incoming&);
    /// \endcond

    /**
     * Enable or disable the server.
     * @param current The Current object for the invocation.
     */
    virtual void setEnabled(bool enable, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_setEnabled(::IceInternal::Incoming&);
    /// \endcond

    /**
     * Check if the server is enabled.
     * @param current The Current object for the invocation.
     */
    virtual bool isEnabled(const ::Ice::Current& current) const = 0;
    /// \cond INTERNAL
    bool _iceD_isEnabled(::IceInternal::Incoming&) const;
    /// \endcond

    /**
     * Send signal to the server
     * @param current The Current object for the invocation.
     */
    virtual void sendSignal(::std::string signal, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_sendSignal(::IceInternal::Incoming&);
    /// \endcond

    /**
     * Write message on servers' stdout or stderr.
     * @param current The Current object for the invocation.
     */
    virtual void writeMessage(::std::string message, ::std::int32_t fd, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_writeMessage(::IceInternal::Incoming&);
    /// \endcond

    /**
     * Return the server state.
     * @param current The Current object for the invocation.
     * @return The server state.
     * @see ServerState
     */
    virtual ServerState getState(const ::Ice::Current& current) const = 0;
    /// \cond INTERNAL
    bool _iceD_getState(::IceInternal::Incoming&) const;
    /// \endcond

    /**
     * Get the server pid. Note that the value returned by this method is system dependant. On Unix operating systems,
     * it's the pid value returned by the fork() system call and converted to an integer.
     * @param current The Current object for the invocation.
     */
    virtual ::std::int32_t getPid(const ::Ice::Current& current) const = 0;
    /// \cond INTERNAL
    bool _iceD_getPid(::IceInternal::Incoming&) const;
    /// \endcond

    /**
     * Set the process proxy.
     * @param response The response callback.
     * @param exception The exception callback.
     * @param current The Current object for the invocation.
     */
    virtual void setProcessAsync(::std::optional<::Ice::ProcessPrx> proc, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_setProcess(::IceInternal::Incoming&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&) override;
    /// \endcond
};

using ServerPtr = ::std::shared_ptr<Server>;

class ReplicaObserver : public virtual ::Ice::Object
{
public:

    using ProxyType = ReplicaObserverPrx;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static ::std::string_view ice_staticId();

    /**
     * Initialization of the replica observer.
     * @param current The Current object for the invocation.
     */
    virtual void replicaInit(InternalRegistryPrxSeq replicas, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_replicaInit(::IceInternal::Incoming&);
    /// \endcond

    /**
     * Notification that a replica has been added. The node should establish a session with this new replica.
     * @param current The Current object for the invocation.
     */
    virtual void replicaAdded(::std::optional<InternalRegistryPrx> replica, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_replicaAdded(::IceInternal::Incoming&);
    /// \endcond

    /**
     * Notification that a replica has been removed. The node should destroy the session to this replica.
     * @param current The Current object for the invocation.
     */
    virtual void replicaRemoved(::std::optional<InternalRegistryPrx> replica, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_replicaRemoved(::IceInternal::Incoming&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&) override;
    /// \endcond
};

using ReplicaObserverPtr = ::std::shared_ptr<ReplicaObserver>;

class PatcherFeedback : public virtual ::Ice::Object
{
public:

    using ProxyType = PatcherFeedbackPrx;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static ::std::string_view ice_staticId();

    /**
     * The patch completed successfully.
     * @param current The Current object for the invocation.
     */
    virtual void finished(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_finished(::IceInternal::Incoming&);
    /// \endcond

    /**
     * The patch on the given node failed for the given reason.
     * @param current The Current object for the invocation.
     */
    virtual void failed(::std::string reason, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_failed(::IceInternal::Incoming&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&) override;
    /// \endcond
};

using PatcherFeedbackPtr = ::std::shared_ptr<PatcherFeedback>;

class Node : public virtual FileReader,
             public virtual ReplicaObserver
{
public:

    using ProxyType = NodePrx;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static ::std::string_view ice_staticId();

    /**
     * Load the given server. If the server resources weren't already created (database environment directories,
     * property files, etc), they will be created.
     * @param response The response callback.
     * @param exception The exception callback.
     * @param current The Current object for the invocation.
     */
    virtual void loadServerAsync(::std::shared_ptr<InternalServerDescriptor> svr, ::std::string replicaName, ::std::function<void(const ::std::optional<ServerPrx>& returnValue, const AdapterPrxDict& adapters, ::std::int32_t actTimeout, ::std::int32_t deactTimeout)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_loadServer(::IceInternal::Incoming&);
    /// \endcond

    /**
     * Load the given server and ensure the server won't be restarted. If the server resources weren't already created
     * (database environment directories, property files, etc), they will be created. If the server can't be updated
     * without a restart, a DeploymentException is raised.
     * @param response The response callback.
     * @param exception The exception callback.
     * @param current The Current object for the invocation.
     */
    virtual void loadServerWithoutRestartAsync(::std::shared_ptr<InternalServerDescriptor> svr, ::std::string replicaName, ::std::function<void(const ::std::optional<ServerPrx>& returnValue, const AdapterPrxDict& adapters, ::std::int32_t actTimeout, ::std::int32_t deactTimeout)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_loadServerWithoutRestart(::IceInternal::Incoming&);
    /// \endcond

    /**
     * Destroy the given server.
     * @param response The response callback.
     * @param exception The exception callback.
     * @param current The Current object for the invocation.
     */
    virtual void destroyServerAsync(::std::string name, ::std::string uuid, ::std::int32_t revision, ::std::string replicaName, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_destroyServer(::IceInternal::Incoming&);
    /// \endcond

    /**
     * Destroy the server if it's not active.
     * @param response The response callback.
     * @param exception The exception callback.
     * @param current The Current object for the invocation.
     */
    virtual void destroyServerWithoutRestartAsync(::std::string name, ::std::string uuid, ::std::int32_t revision, ::std::string replicaName, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_destroyServerWithoutRestart(::IceInternal::Incoming&);
    /// \endcond

    /**
     * Patch application and server distributions. If some servers using a distribution directory to patch are active,
     * this method will raise a PatchException unless shutdown is set to true. In which case the servers will be
     * shutdown.
     * @param response The response callback.
     * @param exception The exception callback.
     * @param current The Current object for the invocation.
     */
    virtual void patchAsync(::std::optional<PatcherFeedbackPrx> feedback, ::std::string application, ::std::string server, ::std::shared_ptr<InternalDistributionDescriptor> appDistrib, bool shutdown, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_patch(::IceInternal::Incoming&);
    /// \endcond

    /**
     * Establish a session to the given replica, this method only returns once the registration was attempted (unlike
     * replicaAdded below).
     * @param current The Current object for the invocation.
     */
    virtual void registerWithReplica(::std::optional<InternalRegistryPrx> replica, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_registerWithReplica(::IceInternal::Incoming&);
    /// \endcond

    /**
     * Get the node name.
     * @param current The Current object for the invocation.
     */
    virtual ::std::string getName(const ::Ice::Current& current) const = 0;
    /// \cond INTERNAL
    bool _iceD_getName(::IceInternal::Incoming&) const;
    /// \endcond

    /**
     * Get the node hostname.
     * @param current The Current object for the invocation.
     */
    virtual ::std::string getHostname(const ::Ice::Current& current) const = 0;
    /// \cond INTERNAL
    bool _iceD_getHostname(::IceInternal::Incoming&) const;
    /// \endcond

    /**
     * Get the node load.
     * @param current The Current object for the invocation.
     */
    virtual LoadInfo getLoad(const ::Ice::Current& current) const = 0;
    /// \cond INTERNAL
    bool _iceD_getLoad(::IceInternal::Incoming&) const;
    /// \endcond

    /**
     * Get the number of processor sockets for the machine where this node is running.
     * @param current The Current object for the invocation.
     */
    virtual ::std::int32_t getProcessorSocketCount(const ::Ice::Current& current) const = 0;
    /// \cond INTERNAL
    bool _iceD_getProcessorSocketCount(::IceInternal::Incoming&) const;
    /// \endcond

    /**
     * Shutdown the node.
     * @param current The Current object for the invocation.
     */
    virtual void shutdown(const ::Ice::Current& current) const = 0;
    /// \cond INTERNAL
    bool _iceD_shutdown(::IceInternal::Incoming&) const;
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&) override;
    /// \endcond
};

using NodePtr = ::std::shared_ptr<Node>;

class NodeSession : public virtual ::Ice::Object
{
public:

    using ProxyType = NodeSessionPrx;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static ::std::string_view ice_staticId();

    /**
     * The node call this method to keep the session alive.
     * @param current The Current object for the invocation.
     */
    virtual void keepAlive(LoadInfo load, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_keepAlive(::IceInternal::Incoming&);
    /// \endcond

    /**
     * Set the replica observer. The node calls this method when it's ready to receive notifications for the replicas.
     * It only calls this for the session with the master.
     * @param current The Current object for the invocation.
     */
    virtual void setReplicaObserver(::std::optional<ReplicaObserverPrx> observer, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_setReplicaObserver(::IceInternal::Incoming&);
    /// \endcond

    /**
     * Return the node session timeout.
     * @param current The Current object for the invocation.
     */
    virtual ::std::int32_t getTimeout(const ::Ice::Current& current) const = 0;
    /// \cond INTERNAL
    bool _iceD_getTimeout(::IceInternal::Incoming&) const;
    /// \endcond

    /**
     * Return the node observer.
     * @param current The Current object for the invocation.
     */
    virtual ::std::optional<NodeObserverPrx> getObserver(const ::Ice::Current& current) const = 0;
    /// \cond INTERNAL
    bool _iceD_getObserver(::IceInternal::Incoming&) const;
    /// \endcond

    /**
     * Ask the registry to load the servers on the node.
     * @param response The response callback.
     * @param exception The exception callback.
     * @param current The Current object for the invocation.
     */
    virtual void loadServersAsync(::std::function<void()> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) const = 0;
    /// \cond INTERNAL
    bool _iceD_loadServers(::IceInternal::Incoming&) const;
    /// \endcond

    /**
     * Get the name of the servers deployed on the node.
     * @param current The Current object for the invocation.
     */
    virtual ::Ice::StringSeq getServers(const ::Ice::Current& current) const = 0;
    /// \cond INTERNAL
    bool _iceD_getServers(::IceInternal::Incoming&) const;
    /// \endcond

    /**
     * Wait for the application update to complete (the application is completely updated once all the registry
     * replicas have been updated). This is used by the node to ensure that before to start a server all the
     * replicas have the up-to-date descriptor of the server.
     * @param response The response callback.
     * @param exception The exception callback.
     * @param current The Current object for the invocation.
     */
    virtual void waitForApplicationUpdateAsync(::std::string application, ::std::int32_t revision, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) const = 0;
    /// \cond INTERNAL
    bool _iceD_waitForApplicationUpdate(::IceInternal::Incoming&) const;
    /// \endcond

    /**
     * Destroy the session.
     * @param current The Current object for the invocation.
     */
    virtual void destroy(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_destroy(::IceInternal::Incoming&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&) override;
    /// \endcond
};

using NodeSessionPtr = ::std::shared_ptr<NodeSession>;

class DatabaseObserver : public virtual ApplicationObserver,
                         public virtual ObjectObserver,
                         public virtual AdapterObserver
{
public:

    using ProxyType = DatabaseObserverPrx;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static ::std::string_view ice_staticId();

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&) override;
    /// \endcond
};

using DatabaseObserverPtr = ::std::shared_ptr<DatabaseObserver>;

class ReplicaSession : public virtual ::Ice::Object
{
public:

    using ProxyType = ReplicaSessionPrx;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static ::std::string_view ice_staticId();

    /**
     * The replica call this method to keep the session alive.
     * @param current The Current object for the invocation.
     */
    virtual void keepAlive(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_keepAlive(::IceInternal::Incoming&);
    /// \endcond

    /**
     * Return the replica session timeout.
     * @param current The Current object for the invocation.
     */
    virtual ::std::int32_t getTimeout(const ::Ice::Current& current) const = 0;
    /// \cond INTERNAL
    bool _iceD_getTimeout(::IceInternal::Incoming&) const;
    /// \endcond

    /**
     * Set the database observer. Once the observer is subscribed, it will receive the database and database updates.
     * @param current The Current object for the invocation.
     */
    virtual void setDatabaseObserver(::std::optional<DatabaseObserverPrx> dbObs, ::std::optional<StringLongDict> serials, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_setDatabaseObserver(::IceInternal::Incoming&);
    /// \endcond

    /**
     * This method sets the endpoints of the replica. This allows the master to create proxies with multiple endpoints
     * for replicated objects (e.g.: IceGrid::Query object).
     * @param current The Current object for the invocation.
     */
    virtual void setEndpoints(StringObjectProxyDict endpoints, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_setEndpoints(::IceInternal::Incoming&);
    /// \endcond

    /**
     * Registers the replica well-known objects with the master.
     * @param current The Current object for the invocation.
     */
    virtual void registerWellKnownObjects(ObjectInfoSeq objects, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_registerWellKnownObjects(::IceInternal::Incoming&);
    /// \endcond

    /**
     * Set the adapter direct proxy of the given adapter in the master. This is used to support dynamic registration
     * with the locator registry interface.
     * @param current The Current object for the invocation.
     */
    virtual void setAdapterDirectProxy(::std::string adapterId, ::std::string replicaGroupId, ::std::optional<::Ice::ObjectPrx> proxy, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_setAdapterDirectProxy(::IceInternal::Incoming&);
    /// \endcond

    /**
     * Notify the master that an update was received. The master might wait for replication updates to be received by
     * all the replicas before to continue.
     * @param current The Current object for the invocation.
     */
    virtual void receivedUpdate(TopicName name, ::std::int32_t serial, ::std::string failure, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_receivedUpdate(::IceInternal::Incoming&);
    /// \endcond

    /**
     * Destroy the session.
     * @param current The Current object for the invocation.
     */
    virtual void destroy(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_destroy(::IceInternal::Incoming&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&) override;
    /// \endcond
};

using ReplicaSessionPtr = ::std::shared_ptr<ReplicaSession>;

class InternalRegistry : public virtual FileReader
{
public:

    using ProxyType = InternalRegistryPrx;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static ::std::string_view ice_staticId();

    /**
     * Register a node with the registry. If a node with the same name is already registered, [registerNode] will
     * overide the previous node only if it's not active.
     * @param info Some information on the node.
     * @param prx The proxy of the node.
     * @param loadInf The load information of the node.
     * @param current The Current object for the invocation.
     * @return The node session proxy.
     * @throws IceGrid::NodeActiveException Raised if the node is already registered and currently active.
     */
    virtual ::std::optional<NodeSessionPrx> registerNode(::std::shared_ptr<InternalNodeInfo> info, ::std::optional<NodePrx> prx, LoadInfo loadInf, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_registerNode(::IceInternal::Incoming&);
    /// \endcond

    /**
     * Register a replica with the registry. If a replica with the  same name is already registered, [registerReplica]
     * will overide the previous replica only if it's not active.
     * @param info Some information on the replica.
     * @param prx The proxy of the replica.
     * @param current The Current object for the invocation.
     * @return The replica session proxy.
     * @throws IceGrid::ReplicaActiveException Raised if the replica is already registered and currently active.
     */
    virtual ::std::optional<ReplicaSessionPrx> registerReplica(::std::shared_ptr<InternalReplicaInfo> info, ::std::optional<InternalRegistryPrx> prx, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_registerReplica(::IceInternal::Incoming&);
    /// \endcond

    /**
     * Create a session with the given registry replica. This method returns only once the session creation has been
     * attempted.
     * @param current The Current object for the invocation.
     */
    virtual void registerWithReplica(::std::optional<InternalRegistryPrx> prx, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_registerWithReplica(::IceInternal::Incoming&);
    /// \endcond

    /**
     * Return the proxies of all the nodes known by this registry.
     * @param current The Current object for the invocation.
     */
    virtual NodePrxSeq getNodes(const ::Ice::Current& current) const = 0;
    /// \cond INTERNAL
    bool _iceD_getNodes(::IceInternal::Incoming&) const;
    /// \endcond

    /**
     * Return the proxies of all the registry replicas known by this registry.
     * @param current The Current object for the invocation.
     */
    virtual InternalRegistryPrxSeq getReplicas(const ::Ice::Current& current) const = 0;
    /// \cond INTERNAL
    bool _iceD_getReplicas(::IceInternal::Incoming&) const;
    /// \endcond

    /**
     * Return applications, adapters, objects from this replica.
     * @param current The Current object for the invocation.
     */
    virtual ApplicationInfoSeq getApplications(::std::int64_t& serial, const ::Ice::Current& current) const = 0;
    /// \cond INTERNAL
    bool _iceD_getApplications(::IceInternal::Incoming&) const;
    /// \endcond

    virtual AdapterInfoSeq getAdapters(::std::int64_t& serial, const ::Ice::Current& current) const = 0;
    /// \cond INTERNAL
    bool _iceD_getAdapters(::IceInternal::Incoming&) const;
    /// \endcond

    virtual ObjectInfoSeq getObjects(::std::int64_t& serial, const ::Ice::Current& current) const = 0;
    /// \cond INTERNAL
    bool _iceD_getObjects(::IceInternal::Incoming&) const;
    /// \endcond

    /**
     * Shutdown this registry.
     * @param current The Current object for the invocation.
     */
    virtual void shutdown(const ::Ice::Current& current) const = 0;
    /// \cond INTERNAL
    bool _iceD_shutdown(::IceInternal::Incoming&) const;
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&) override;
    /// \endcond
};

using InternalRegistryPtr = ::std::shared_ptr<InternalRegistry>;

}

/// \cond STREAM
namespace Ice
{

template<typename S>
struct StreamReader<::IceGrid::InternalDbEnvDescriptor, S>
{
    static void read(S* istr, ::IceGrid::InternalDbEnvDescriptor& v)
    {
        istr->readAll(v.name, v.properties);
    }
};

template<typename S>
struct StreamReader<::IceGrid::InternalAdapterDescriptor, S>
{
    static void read(S* istr, ::IceGrid::InternalAdapterDescriptor& v)
    {
        istr->readAll(v.id, v.serverLifetime);
    }
};

template<typename S>
struct StreamReader<::IceGrid::InternalDistributionDescriptor, S>
{
    static void read(S* istr, ::IceGrid::InternalDistributionDescriptor& v)
    {
        istr->readAll(v.icepatch, v.directories);
    }
};

template<typename S>
struct StreamWriter<::IceGrid::InternalServerDescriptor, S>
{
    static void write(S* ostr, const ::IceGrid::InternalServerDescriptor& v)
    {
        ostr->writeAll(v.id, v.application, v.uuid, v.revision, v.sessionId, v.exe, v.pwd, v.user, v.activation, v.activationTimeout, v.deactivationTimeout, v.applicationDistrib, v.distrib, v.processRegistered, v.options, v.envs, v.logs, v.adapters, v.dbEnvs, v.properties);
        ostr->writeAll({1}, v.services);
    }
};

template<typename S>
struct StreamReader<::IceGrid::InternalServerDescriptor, S>
{
    static void read(S* istr, ::IceGrid::InternalServerDescriptor& v)
    {
        istr->readAll(v.id, v.application, v.uuid, v.revision, v.sessionId, v.exe, v.pwd, v.user, v.activation, v.activationTimeout, v.deactivationTimeout, v.applicationDistrib, v.distrib, v.processRegistered, v.options, v.envs, v.logs, v.adapters, v.dbEnvs, v.properties);
        istr->readAll({1}, v.services);
    }
};

template<typename S>
struct StreamReader<::IceGrid::AdapterNotActiveException, S>
{
    static void read(S* istr, ::IceGrid::AdapterNotActiveException& v)
    {
        istr->readAll(v.activatable);
    }
};

template<typename S>
struct StreamReader<::IceGrid::AdapterExistsException, S>
{
    static void read(S* istr, ::IceGrid::AdapterExistsException& v)
    {
        istr->readAll(v.id);
    }
};

template<>
struct StreamableTraits< ::IceGrid::TopicName>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 4;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::IceGrid::InternalNodeInfo, S>
{
    static void read(S* istr, ::IceGrid::InternalNodeInfo& v)
    {
        istr->readAll(v.name, v.os, v.hostname, v.release, v.version, v.machine, v.nProcessors, v.dataDir);
    }
};

template<typename S>
struct StreamReader<::IceGrid::InternalReplicaInfo, S>
{
    static void read(S* istr, ::IceGrid::InternalReplicaInfo& v)
    {
        istr->readAll(v.name, v.hostname);
    }
};

}
/// \endcond

#include <IceUtil/PopDisableWarnings.h>
#endif
