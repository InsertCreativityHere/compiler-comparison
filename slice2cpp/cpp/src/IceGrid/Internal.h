//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.8.0-alpha.0
//
// <auto-generated>
//
// Generated from file `Internal.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __Internal_h__
#define __Internal_h__

#include <IceUtil/PushDisableWarnings.h>
#include <Ice/Ice.h>
#include <Ice/Identity.h>
#include <Ice/BuiltinSequences.h>
#include <Ice/Process.h>
#include <Glacier2/Session.h>
#include <IceGrid/Admin.h>
#include <IceGrid/Registry.h>
#include <IceUtil/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION  != 30850
#       error Ice version mismatch: an exact match is required for beta generated code
#   endif
#endif

namespace IceGrid
{

class InternalDbEnvDescriptor;
class InternalAdapterDescriptor;
class InternalDistributionDescriptor;
class InternalServerDescriptor;
class Adapter;
class AdapterPrx;
class FileReader;
class FileReaderPrx;
class Server;
class ServerPrx;
class InternalRegistry;
class InternalRegistryPrx;
class ReplicaObserver;
class ReplicaObserverPrx;
class PatcherFeedback;
class PatcherFeedbackPrx;
class Node;
class NodePrx;
class NodeSession;
class NodeSessionPrx;
class DatabaseObserver;
class DatabaseObserverPrx;
class ReplicaSession;
class ReplicaSessionPrx;
class InternalNodeInfo;
class InternalReplicaInfo;

}

namespace IceGrid
{

using InternalDbEnvDescriptorSeq = ::std::vector<::std::shared_ptr<InternalDbEnvDescriptor>>;

using InternalAdapterDescriptorSeq = ::std::vector<::std::shared_ptr<InternalAdapterDescriptor>>;

using PropertyDescriptorSeqDict = ::std::map<::std::string, PropertyDescriptorSeq>;

/**
 * This exception is raised if an adapter is active.
 */
class AdapterActiveException : public ::Ice::UserExceptionHelper<AdapterActiveException, ::Ice::UserException>
{
public:

    virtual ~AdapterActiveException();

    AdapterActiveException(const AdapterActiveException&) = default;

    AdapterActiveException() = default;

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<> ice_tuple() const
    {
        return std::tie();
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();
};

/// \cond INTERNAL
static AdapterActiveException _iceS_AdapterActiveException_init;
/// \endcond

class AdapterNotActiveException : public ::Ice::UserExceptionHelper<AdapterNotActiveException, ::Ice::UserException>
{
public:

    virtual ~AdapterNotActiveException();

    AdapterNotActiveException(const AdapterNotActiveException&) = default;

    AdapterNotActiveException() = default;

    /**
     * One-shot constructor to initialize all data members.
     * @param activatable True if the adapter can be activated on demand.
     */
    AdapterNotActiveException(bool activatable) :
        activatable(activatable)
    {
    }

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const bool&> ice_tuple() const
    {
        return std::tie(activatable);
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /**
     * True if the adapter can be activated on demand.
     */
    bool activatable;
};

/**
 * This exception is raised if an adapter with the same name already exists.
 */
class AdapterExistsException : public ::Ice::UserExceptionHelper<AdapterExistsException, ::Ice::UserException>
{
public:

    virtual ~AdapterExistsException();

    AdapterExistsException(const AdapterExistsException&) = default;

    AdapterExistsException() = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    AdapterExistsException(const ::std::string& id) :
        id(id)
    {
    }

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&> ice_tuple() const
    {
        return std::tie(id);
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::std::string id;
};

using AdapterPrxDict = ::std::map<::std::string, ::std::shared_ptr<AdapterPrx>>;

using InternalRegistryPrxSeq = ::std::vector<::std::shared_ptr<InternalRegistryPrx>>;

using NodePrxSeq = ::std::vector<::std::shared_ptr<NodePrx>>;

/**
 * This exception is raised if a node is already registered and active.
 */
class NodeActiveException : public ::Ice::UserExceptionHelper<NodeActiveException, ::Ice::UserException>
{
public:

    virtual ~NodeActiveException();

    NodeActiveException(const NodeActiveException&) = default;

    NodeActiveException() = default;

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<> ice_tuple() const
    {
        return std::tie();
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();
};

/**
 * This exception is raised if a replica is already registered and active.
 */
class ReplicaActiveException : public ::Ice::UserExceptionHelper<ReplicaActiveException, ::Ice::UserException>
{
public:

    virtual ~ReplicaActiveException();

    ReplicaActiveException(const ReplicaActiveException&) = default;

    ReplicaActiveException() = default;

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<> ice_tuple() const
    {
        return std::tie();
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();
};

enum class TopicName : unsigned char
{
    RegistryObserver,
    NodeObserver,
    ApplicationObserver,
    AdapterObserver,
    ObjectObserver
};

using StringLongDict = ::std::map<::std::string, long long int>;

}

namespace IceGrid
{

class Adapter : public virtual ::Ice::Object
{
public:

    using ProxyType = AdapterPrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /**
     * Activate this adapter. If this adapter can be activated, this will activate the adapter and return the direct
     * proxy of the adapter once it's active. If this adapter can be activated on demand, this will return 0 if the
     * adapter is inactive or the adapter direct proxy it's active.
     * @param response The response callback.
     * @param exception The exception callback.
     * @param current The Current object for the invocation.
     */
    virtual void activateAsync(::std::function<void(const ::std::shared_ptr<::Ice::ObjectPrx>& returnValue)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_activate(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Get the adapter direct proxy. The adapter direct proxy is a proxy created with the object adapter. The proxy
     * contains the last known adapter endpoints.
     * @param current The Current object for the invocation.
     * @return A direct proxy containing the last known adapter endpoints if the adapter is already active.
     */
    virtual ::std::shared_ptr<::Ice::ObjectPrx> getDirectProxy(const ::Ice::Current& current) const = 0;
    /// \cond INTERNAL
    bool _iceD_getDirectProxy(::IceInternal::Incoming&, const ::Ice::Current&) const;
    /// \endcond

    /**
     * Set the direct proxy for this adapter.
     * @param current The Current object for the invocation.
     * @throws IceGrid::AdapterActiveException The adapter is already active. It's not possible to override the direct proxy of
     * an active adapter.
     */
    virtual void setDirectProxy(::std::shared_ptr<::Ice::ObjectPrx> proxy, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_setDirectProxy(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

class FileReader : public virtual ::Ice::Object
{
public:

    using ProxyType = FileReaderPrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /**
     * Count the number of given lines from the end of the file and return the file offset.
     * @param current The Current object for the invocation.
     */
    virtual long long int getOffsetFromEnd(::std::string filename, int lines, const ::Ice::Current& current) const = 0;
    /// \cond INTERNAL
    bool _iceD_getOffsetFromEnd(::IceInternal::Incoming&, const ::Ice::Current&) const;
    /// \endcond

    /**
     * Encapsulates the results of a call to read.
     */
    struct ReadResult
    {
        bool returnValue;
        long long int newPos;
        ::Ice::StringSeq lines;
    };

    /**
     * Read lines (or size bytes) at the specified position from the given file.
     * @param current The Current object for the invocation.
     */
    virtual bool read(::std::string filename, long long int pos, int size, long long int& newPos, ::Ice::StringSeq& lines, const ::Ice::Current& current) const = 0;
    /// \cond INTERNAL
    bool _iceD_read(::IceInternal::Incoming&, const ::Ice::Current&) const;
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

class Server : public virtual FileReader
{
public:

    using ProxyType = ServerPrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /**
     * Start the server.
     * @param response The response callback.
     * @param exception The exception callback.
     * @param current The Current object for the invocation.
     */
    virtual void startAsync(::std::function<void()> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_start(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Stop the server. This methods returns only when the server is deactivated. If the server doesn't stop after a
     * configurable amount of time, it will be killed.
     * @param response The response callback.
     * @param exception The exception callback.
     * @param current The Current object for the invocation.
     */
    virtual void stopAsync(::std::function<void()> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_stop(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Check if the given server can be loaded on this node.
     * @param current The Current object for the invocation.
     * @return True if the server is inactive.
     * @throws IceGrid::DeploymentException Raised if the server can't be updated.
     */
    virtual bool checkUpdate(::std::shared_ptr<InternalServerDescriptor> svr, bool noRestart, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_checkUpdate(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Enable or disable the server.
     * @param current The Current object for the invocation.
     */
    virtual void setEnabled(bool enable, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_setEnabled(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Check if the server is enabled.
     * @param current The Current object for the invocation.
     */
    virtual bool isEnabled(const ::Ice::Current& current) const = 0;
    /// \cond INTERNAL
    bool _iceD_isEnabled(::IceInternal::Incoming&, const ::Ice::Current&) const;
    /// \endcond

    /**
     * Send signal to the server
     * @param current The Current object for the invocation.
     */
    virtual void sendSignal(::std::string signal, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_sendSignal(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Write message on servers' stdout or stderr.
     * @param current The Current object for the invocation.
     */
    virtual void writeMessage(::std::string message, int fd, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_writeMessage(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Return the server state.
     * @param current The Current object for the invocation.
     * @return The server state.
     * @see ServerState
     */
    virtual ServerState getState(const ::Ice::Current& current) const = 0;
    /// \cond INTERNAL
    bool _iceD_getState(::IceInternal::Incoming&, const ::Ice::Current&) const;
    /// \endcond

    /**
     * Get the server pid. Note that the value returned by this method is system dependant. On Unix operating systems,
     * it's the pid value returned by the fork() system call and converted to an integer.
     * @param current The Current object for the invocation.
     */
    virtual int getPid(const ::Ice::Current& current) const = 0;
    /// \cond INTERNAL
    bool _iceD_getPid(::IceInternal::Incoming&, const ::Ice::Current&) const;
    /// \endcond

    /**
     * Set the process proxy.
     * @param response The response callback.
     * @param exception The exception callback.
     * @param current The Current object for the invocation.
     */
    virtual void setProcessAsync(::std::shared_ptr<::Ice::ProcessPrx> proc, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_setProcess(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

class ReplicaObserver : public virtual ::Ice::Object
{
public:

    using ProxyType = ReplicaObserverPrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /**
     * Initialization of the replica observer.
     * @param current The Current object for the invocation.
     */
    virtual void replicaInit(InternalRegistryPrxSeq replicas, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_replicaInit(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Notification that a replica has been added. The node should establish a session with this new replica.
     * @param current The Current object for the invocation.
     */
    virtual void replicaAdded(::std::shared_ptr<InternalRegistryPrx> replica, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_replicaAdded(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Notification that a replica has been removed. The node should destroy the session to this replica.
     * @param current The Current object for the invocation.
     */
    virtual void replicaRemoved(::std::shared_ptr<InternalRegistryPrx> replica, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_replicaRemoved(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

class PatcherFeedback : public virtual ::Ice::Object
{
public:

    using ProxyType = PatcherFeedbackPrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /**
     * The patch completed successfully.
     * @param current The Current object for the invocation.
     */
    virtual void finished(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_finished(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * The patch on the given node failed for the given reason.
     * @param current The Current object for the invocation.
     */
    virtual void failed(::std::string reason, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_failed(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

class Node : public virtual FileReader,
             public virtual ReplicaObserver
{
public:

    using ProxyType = NodePrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /**
     * Encapsulates the results of a call to loadServer.
     */
    struct LoadServerResult
    {
        ::std::shared_ptr<ServerPrx> returnValue;
        AdapterPrxDict adapters;
        int actTimeout;
        int deactTimeout;
    };

    /**
     * Load the given server. If the server resources weren't already created (database environment directories,
     * property files, etc), they will be created.
     * @param response The response callback.
     * @param exception The exception callback.
     * @param current The Current object for the invocation.
     */
    virtual void loadServerAsync(::std::shared_ptr<InternalServerDescriptor> svr, ::std::string replicaName, ::std::function<void(const ::std::shared_ptr<ServerPrx>& returnValue, const AdapterPrxDict& adapters, int actTimeout, int deactTimeout)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_loadServer(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to loadServerWithoutRestart.
     */
    struct LoadServerWithoutRestartResult
    {
        ::std::shared_ptr<ServerPrx> returnValue;
        AdapterPrxDict adapters;
        int actTimeout;
        int deactTimeout;
    };

    /**
     * Load the given server and ensure the server won't be restarted. If the server resources weren't already created
     * (database environment directories, property files, etc), they will be created. If the server can't be updated
     * without a restart, a DeploymentException is raised.
     * @param response The response callback.
     * @param exception The exception callback.
     * @param current The Current object for the invocation.
     */
    virtual void loadServerWithoutRestartAsync(::std::shared_ptr<InternalServerDescriptor> svr, ::std::string replicaName, ::std::function<void(const ::std::shared_ptr<ServerPrx>& returnValue, const AdapterPrxDict& adapters, int actTimeout, int deactTimeout)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_loadServerWithoutRestart(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Destroy the given server.
     * @param response The response callback.
     * @param exception The exception callback.
     * @param current The Current object for the invocation.
     */
    virtual void destroyServerAsync(::std::string name, ::std::string uuid, int revision, ::std::string replicaName, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_destroyServer(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Destroy the server if it's not active.
     * @param response The response callback.
     * @param exception The exception callback.
     * @param current The Current object for the invocation.
     */
    virtual void destroyServerWithoutRestartAsync(::std::string name, ::std::string uuid, int revision, ::std::string replicaName, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_destroyServerWithoutRestart(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Patch application and server distributions. If some servers using a distribution directory to patch are active,
     * this method will raise a PatchException unless shutdown is set to true. In which case the servers will be
     * shutdown.
     * @param response The response callback.
     * @param exception The exception callback.
     * @param current The Current object for the invocation.
     */
    virtual void patchAsync(::std::shared_ptr<PatcherFeedbackPrx> feedback, ::std::string application, ::std::string server, ::std::shared_ptr<InternalDistributionDescriptor> appDistrib, bool shutdown, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_patch(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Establish a session to the given replica, this method only returns once the registration was attempted (unlike
     * replicaAdded below).
     * @param current The Current object for the invocation.
     */
    virtual void registerWithReplica(::std::shared_ptr<InternalRegistryPrx> replica, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_registerWithReplica(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Get the node name.
     * @param current The Current object for the invocation.
     */
    virtual ::std::string getName(const ::Ice::Current& current) const = 0;
    /// \cond INTERNAL
    bool _iceD_getName(::IceInternal::Incoming&, const ::Ice::Current&) const;
    /// \endcond

    /**
     * Get the node hostname.
     * @param current The Current object for the invocation.
     */
    virtual ::std::string getHostname(const ::Ice::Current& current) const = 0;
    /// \cond INTERNAL
    bool _iceD_getHostname(::IceInternal::Incoming&, const ::Ice::Current&) const;
    /// \endcond

    /**
     * Get the node load.
     * @param current The Current object for the invocation.
     */
    virtual LoadInfo getLoad(const ::Ice::Current& current) const = 0;
    /// \cond INTERNAL
    bool _iceD_getLoad(::IceInternal::Incoming&, const ::Ice::Current&) const;
    /// \endcond

    /**
     * Get the number of processor sockets for the machine where this node is running.
     * @param current The Current object for the invocation.
     */
    virtual int getProcessorSocketCount(const ::Ice::Current& current) const = 0;
    /// \cond INTERNAL
    bool _iceD_getProcessorSocketCount(::IceInternal::Incoming&, const ::Ice::Current&) const;
    /// \endcond

    /**
     * Shutdown the node.
     * @param current The Current object for the invocation.
     */
    virtual void shutdown(const ::Ice::Current& current) const = 0;
    /// \cond INTERNAL
    bool _iceD_shutdown(::IceInternal::Incoming&, const ::Ice::Current&) const;
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

class NodeSession : public virtual ::Ice::Object
{
public:

    using ProxyType = NodeSessionPrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /**
     * The node call this method to keep the session alive.
     * @param current The Current object for the invocation.
     */
    virtual void keepAlive(LoadInfo load, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_keepAlive(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Set the replica observer. The node calls this method when it's ready to receive notifications for the replicas.
     * It only calls this for the session with the master.
     * @param current The Current object for the invocation.
     */
    virtual void setReplicaObserver(::std::shared_ptr<ReplicaObserverPrx> observer, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_setReplicaObserver(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Return the node session timeout.
     * @param current The Current object for the invocation.
     */
    virtual int getTimeout(const ::Ice::Current& current) const = 0;
    /// \cond INTERNAL
    bool _iceD_getTimeout(::IceInternal::Incoming&, const ::Ice::Current&) const;
    /// \endcond

    /**
     * Return the node observer.
     * @param current The Current object for the invocation.
     */
    virtual ::std::shared_ptr<NodeObserverPrx> getObserver(const ::Ice::Current& current) const = 0;
    /// \cond INTERNAL
    bool _iceD_getObserver(::IceInternal::Incoming&, const ::Ice::Current&) const;
    /// \endcond

    /**
     * Ask the registry to load the servers on the node.
     * @param response The response callback.
     * @param exception The exception callback.
     * @param current The Current object for the invocation.
     */
    virtual void loadServersAsync(::std::function<void()> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) const = 0;
    /// \cond INTERNAL
    bool _iceD_loadServers(::IceInternal::Incoming&, const ::Ice::Current&) const;
    /// \endcond

    /**
     * Get the name of the servers deployed on the node.
     * @param current The Current object for the invocation.
     */
    virtual ::Ice::StringSeq getServers(const ::Ice::Current& current) const = 0;
    /// \cond INTERNAL
    bool _iceD_getServers(::IceInternal::Incoming&, const ::Ice::Current&) const;
    /// \endcond

    /**
     * Wait for the application update to complete (the application is completely updated once all the registry
     * replicas have been updated). This is used by the node to ensure that before to start a server all the
     * replicas have the up-to-date descriptor of the server.
     * @param response The response callback.
     * @param exception The exception callback.
     * @param current The Current object for the invocation.
     */
    virtual void waitForApplicationUpdateAsync(::std::string application, int revision, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) const = 0;
    /// \cond INTERNAL
    bool _iceD_waitForApplicationUpdate(::IceInternal::Incoming&, const ::Ice::Current&) const;
    /// \endcond

    /**
     * Destroy the session.
     * @param current The Current object for the invocation.
     */
    virtual void destroy(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_destroy(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

class DatabaseObserver : public virtual ApplicationObserver,
                         public virtual ObjectObserver,
                         public virtual AdapterObserver
{
public:

    using ProxyType = DatabaseObserverPrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

class ReplicaSession : public virtual ::Ice::Object
{
public:

    using ProxyType = ReplicaSessionPrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /**
     * The replica call this method to keep the session alive.
     * @param current The Current object for the invocation.
     */
    virtual void keepAlive(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_keepAlive(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Return the replica session timeout.
     * @param current The Current object for the invocation.
     */
    virtual int getTimeout(const ::Ice::Current& current) const = 0;
    /// \cond INTERNAL
    bool _iceD_getTimeout(::IceInternal::Incoming&, const ::Ice::Current&) const;
    /// \endcond

    /**
     * Set the database observer. Once the observer is subscribed, it will receive the database and database updates.
     * @param current The Current object for the invocation.
     */
    virtual void setDatabaseObserver(::std::shared_ptr<DatabaseObserverPrx> dbObs, std::optional<StringLongDict> serials, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_setDatabaseObserver(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * This method sets the endpoints of the replica. This allows the master to create proxies with multiple endpoints
     * for replicated objects (e.g.: IceGrid::Query object).
     * @param current The Current object for the invocation.
     */
    virtual void setEndpoints(StringObjectProxyDict endpoints, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_setEndpoints(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Registers the replica well-known objects with the master.
     * @param current The Current object for the invocation.
     */
    virtual void registerWellKnownObjects(ObjectInfoSeq objects, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_registerWellKnownObjects(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Set the adapter direct proxy of the given adapter in the master. This is used to support dynamic registration
     * with the locator registry interface.
     * @param current The Current object for the invocation.
     */
    virtual void setAdapterDirectProxy(::std::string adapterId, ::std::string replicaGroupId, ::std::shared_ptr<::Ice::ObjectPrx> proxy, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_setAdapterDirectProxy(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Notify the master that an update was received. The master might wait for replication updates to be received by
     * all the replicas before to continue.
     * @param current The Current object for the invocation.
     */
    virtual void receivedUpdate(TopicName name, int serial, ::std::string failure, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_receivedUpdate(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Destroy the session.
     * @param current The Current object for the invocation.
     */
    virtual void destroy(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_destroy(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

class InternalRegistry : public virtual FileReader
{
public:

    using ProxyType = InternalRegistryPrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /**
     * Register a node with the registry. If a node with the same name is already registered, [registerNode] will
     * overide the previous node only if it's not active.
     * @param info Some information on the node.
     * @param prx The proxy of the node.
     * @param loadInf The load information of the node.
     * @param current The Current object for the invocation.
     * @return The node session proxy.
     * @throws IceGrid::NodeActiveException Raised if the node is already registered and currently active.
     */
    virtual ::std::shared_ptr<NodeSessionPrx> registerNode(::std::shared_ptr<InternalNodeInfo> info, ::std::shared_ptr<NodePrx> prx, LoadInfo loadInf, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_registerNode(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Register a replica with the registry. If a replica with the  same name is already registered, [registerReplica]
     * will overide the previous replica only if it's not active.
     * @param info Some information on the replica.
     * @param prx The proxy of the replica.
     * @param current The Current object for the invocation.
     * @return The replica session proxy.
     * @throws IceGrid::ReplicaActiveException Raised if the replica is already registered and currently active.
     */
    virtual ::std::shared_ptr<ReplicaSessionPrx> registerReplica(::std::shared_ptr<InternalReplicaInfo> info, ::std::shared_ptr<InternalRegistryPrx> prx, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_registerReplica(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Create a session with the given registry replica. This method returns only once the session creation has been
     * attempted.
     * @param current The Current object for the invocation.
     */
    virtual void registerWithReplica(::std::shared_ptr<InternalRegistryPrx> prx, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_registerWithReplica(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Return the proxies of all the nodes known by this registry.
     * @param current The Current object for the invocation.
     */
    virtual NodePrxSeq getNodes(const ::Ice::Current& current) const = 0;
    /// \cond INTERNAL
    bool _iceD_getNodes(::IceInternal::Incoming&, const ::Ice::Current&) const;
    /// \endcond

    /**
     * Return the proxies of all the registry replicas known by this registry.
     * @param current The Current object for the invocation.
     */
    virtual InternalRegistryPrxSeq getReplicas(const ::Ice::Current& current) const = 0;
    /// \cond INTERNAL
    bool _iceD_getReplicas(::IceInternal::Incoming&, const ::Ice::Current&) const;
    /// \endcond

    /**
     * Encapsulates the results of a call to getApplications.
     */
    struct GetApplicationsResult
    {
        ApplicationInfoSeq returnValue;
        long long int serial;
    };

    /**
     * Return applications, adapters, objects from this replica.
     * @param current The Current object for the invocation.
     */
    virtual ApplicationInfoSeq getApplications(long long int& serial, const ::Ice::Current& current) const = 0;
    /// \cond INTERNAL
    bool _iceD_getApplications(::IceInternal::Incoming&, const ::Ice::Current&) const;
    /// \endcond

    /**
     * Encapsulates the results of a call to getAdapters.
     */
    struct GetAdaptersResult
    {
        AdapterInfoSeq returnValue;
        long long int serial;
    };

    virtual AdapterInfoSeq getAdapters(long long int& serial, const ::Ice::Current& current) const = 0;
    /// \cond INTERNAL
    bool _iceD_getAdapters(::IceInternal::Incoming&, const ::Ice::Current&) const;
    /// \endcond

    /**
     * Encapsulates the results of a call to getObjects.
     */
    struct GetObjectsResult
    {
        ObjectInfoSeq returnValue;
        long long int serial;
    };

    virtual ObjectInfoSeq getObjects(long long int& serial, const ::Ice::Current& current) const = 0;
    /// \cond INTERNAL
    bool _iceD_getObjects(::IceInternal::Incoming&, const ::Ice::Current&) const;
    /// \endcond

    /**
     * Shutdown this registry.
     * @param current The Current object for the invocation.
     */
    virtual void shutdown(const ::Ice::Current& current) const = 0;
    /// \cond INTERNAL
    bool _iceD_shutdown(::IceInternal::Incoming&, const ::Ice::Current&) const;
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

}

namespace IceGrid
{

class InternalDbEnvDescriptor : public ::Ice::ValueHelper<InternalDbEnvDescriptor, ::Ice::Value>
{
public:

    virtual ~InternalDbEnvDescriptor();

    InternalDbEnvDescriptor() = default;

    InternalDbEnvDescriptor(const InternalDbEnvDescriptor&) = default;
    InternalDbEnvDescriptor(InternalDbEnvDescriptor&&) = default;
    InternalDbEnvDescriptor& operator=(const InternalDbEnvDescriptor&) = default;
    InternalDbEnvDescriptor& operator=(InternalDbEnvDescriptor&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     * @param name The name of the database environment.
     * @param properties The database properties.
     */
    InternalDbEnvDescriptor(const ::std::string& name, const ::IceGrid::PropertyDescriptorSeq& properties) :
        name(name),
        properties(properties)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::IceGrid::PropertyDescriptorSeq&> ice_tuple() const
    {
        return std::tie(name, properties);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /**
     * The name of the database environment.
     */
    ::std::string name;
    /**
     * The database properties.
     */
    ::IceGrid::PropertyDescriptorSeq properties;
};

/// \cond INTERNAL
static InternalDbEnvDescriptor _iceS_InternalDbEnvDescriptor_init;
/// \endcond

class InternalAdapterDescriptor : public ::Ice::ValueHelper<InternalAdapterDescriptor, ::Ice::Value>
{
public:

    virtual ~InternalAdapterDescriptor();

    InternalAdapterDescriptor() = default;

    InternalAdapterDescriptor(const InternalAdapterDescriptor&) = default;
    InternalAdapterDescriptor(InternalAdapterDescriptor&&) = default;
    InternalAdapterDescriptor& operator=(const InternalAdapterDescriptor&) = default;
    InternalAdapterDescriptor& operator=(InternalAdapterDescriptor&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     * @param id The identifier of the server.
     * @param serverLifetime Specifies if the lifetime of the adapter is the same as the server.
     */
    InternalAdapterDescriptor(const ::std::string& id, bool serverLifetime) :
        id(id),
        serverLifetime(serverLifetime)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const bool&> ice_tuple() const
    {
        return std::tie(id, serverLifetime);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /**
     * The identifier of the server.
     */
    ::std::string id;
    /**
     * Specifies if the lifetime of the adapter is the same as the server.
     */
    bool serverLifetime;
};

class InternalDistributionDescriptor : public ::Ice::ValueHelper<InternalDistributionDescriptor, ::Ice::Value>
{
public:

    virtual ~InternalDistributionDescriptor();

    InternalDistributionDescriptor() = default;

    InternalDistributionDescriptor(const InternalDistributionDescriptor&) = default;
    InternalDistributionDescriptor(InternalDistributionDescriptor&&) = default;
    InternalDistributionDescriptor& operator=(const InternalDistributionDescriptor&) = default;
    InternalDistributionDescriptor& operator=(InternalDistributionDescriptor&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     * @param icepatch The proxy of the IcePatch2 server.
     * @param directories The source directories.
     */
    InternalDistributionDescriptor(const ::std::string& icepatch, const ::Ice::StringSeq& directories) :
        icepatch(icepatch),
        directories(directories)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::Ice::StringSeq&> ice_tuple() const
    {
        return std::tie(icepatch, directories);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /**
     * The proxy of the IcePatch2 server.
     */
    ::std::string icepatch;
    /**
     * The source directories.
     */
    ::Ice::StringSeq directories;
};

class InternalServerDescriptor : public ::Ice::ValueHelper<InternalServerDescriptor, ::Ice::Value>
{
public:

    virtual ~InternalServerDescriptor();

    InternalServerDescriptor() = default;

    InternalServerDescriptor(const InternalServerDescriptor&) = default;
    InternalServerDescriptor(InternalServerDescriptor&&) = default;
    InternalServerDescriptor& operator=(const InternalServerDescriptor&) = default;
    InternalServerDescriptor& operator=(InternalServerDescriptor&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     * @param id The server ID.
     * @param application The server application
     * @param uuid The application uuid.
     * @param revision The application revision.
     * @param sessionId The id of the session which allocated the server.
     * @param exe The server executable.
     * @param pwd The server working directory.
     * @param user The user ID to use to run the server.
     * @param activation The server activation mode.
     * @param activationTimeout The server activation timeout.
     * @param deactivationTimeout The server deactivation timeout.
     * @param applicationDistrib Specifies if the server depends on the application distrib.
     * @param distrib The distribution descriptor of this server.
     * @param processRegistered Specifies if a process object is registered.
     * @param options The server command line options.
     * @param envs The server environment variables.
     * @param logs The path of the server logs.
     * @param adapters The indirect object adapters.
     * @param properties The configuration files of the server.
     * @param services IceBox service names
     */
    InternalServerDescriptor(const ::std::string& id, const ::std::string& application, const ::std::string& uuid, int revision, const ::std::string& sessionId, const ::std::string& exe, const ::std::string& pwd, const ::std::string& user, const ::std::string& activation, const ::std::string& activationTimeout, const ::std::string& deactivationTimeout, bool applicationDistrib, const ::std::shared_ptr<::IceGrid::InternalDistributionDescriptor>& distrib, bool processRegistered, const ::Ice::StringSeq& options, const ::Ice::StringSeq& envs, const ::Ice::StringSeq& logs, const ::IceGrid::InternalAdapterDescriptorSeq& adapters, const ::IceGrid::InternalDbEnvDescriptorSeq& dbEnvs, const ::IceGrid::PropertyDescriptorSeqDict& properties, const std::optional<::Ice::StringSeq>& services) :
        id(id),
        application(application),
        uuid(uuid),
        revision(revision),
        sessionId(sessionId),
        exe(exe),
        pwd(pwd),
        user(user),
        activation(activation),
        activationTimeout(activationTimeout),
        deactivationTimeout(deactivationTimeout),
        applicationDistrib(applicationDistrib),
        distrib(distrib),
        processRegistered(processRegistered),
        options(options),
        envs(envs),
        logs(logs),
        adapters(adapters),
        dbEnvs(dbEnvs),
        properties(properties),
        services(services)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::std::string&, const ::std::string&, const int&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const bool&, const ::std::shared_ptr<::IceGrid::InternalDistributionDescriptor>&, const bool&, const ::Ice::StringSeq&, const ::Ice::StringSeq&, const ::Ice::StringSeq&, const ::IceGrid::InternalAdapterDescriptorSeq&, const ::IceGrid::InternalDbEnvDescriptorSeq&, const ::IceGrid::PropertyDescriptorSeqDict&, const std::optional<::Ice::StringSeq>&> ice_tuple() const
    {
        return std::tie(id, application, uuid, revision, sessionId, exe, pwd, user, activation, activationTimeout, deactivationTimeout, applicationDistrib, distrib, processRegistered, options, envs, logs, adapters, dbEnvs, properties, services);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /**
     * The server ID.
     */
    ::std::string id;
    /**
     * The server application
     */
    ::std::string application;
    /**
     * The application uuid.
     */
    ::std::string uuid;
    /**
     * The application revision.
     */
    int revision;
    /**
     * The id of the session which allocated the server.
     */
    ::std::string sessionId;
    /**
     * The server executable.
     */
    ::std::string exe;
    /**
     * The server working directory.
     */
    ::std::string pwd;
    /**
     * The user ID to use to run the server.
     */
    ::std::string user;
    /**
     * The server activation mode.
     */
    ::std::string activation;
    /**
     * The server activation timeout.
     */
    ::std::string activationTimeout;
    /**
     * The server deactivation timeout.
     */
    ::std::string deactivationTimeout;
    /**
     * Specifies if the server depends on the application distrib.
     */
    bool applicationDistrib;
    /**
     * The distribution descriptor of this server.
     */
    ::std::shared_ptr<::IceGrid::InternalDistributionDescriptor> distrib;
    /**
     * Specifies if a process object is registered.
     */
    bool processRegistered;
    /**
     * The server command line options.
     */
    ::Ice::StringSeq options;
    /**
     * The server environment variables.
     */
    ::Ice::StringSeq envs;
    /**
     * The path of the server logs.
     */
    ::Ice::StringSeq logs;
    /**
     * The indirect object adapters.
     */
    ::IceGrid::InternalAdapterDescriptorSeq adapters;
    ::IceGrid::InternalDbEnvDescriptorSeq dbEnvs;
    /**
     * The configuration files of the server.
     */
    ::IceGrid::PropertyDescriptorSeqDict properties;
    /**
     * IceBox service names
     */
    std::optional<::Ice::StringSeq> services;
};

/**
 * Information about an IceGrid node.
 */
class InternalNodeInfo : public ::Ice::ValueHelper<InternalNodeInfo, ::Ice::Value>
{
public:

    virtual ~InternalNodeInfo();

    InternalNodeInfo() = default;

    InternalNodeInfo(const InternalNodeInfo&) = default;
    InternalNodeInfo(InternalNodeInfo&&) = default;
    InternalNodeInfo& operator=(const InternalNodeInfo&) = default;
    InternalNodeInfo& operator=(InternalNodeInfo&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     * @param name The name of the node.
     * @param os The operating system name.
     * @param hostname The network name of the host running this node (as defined in uname()).
     * @param release The operation system release level (as defined in uname()).
     * @param version The operation system version (as defined in uname()).
     * @param machine The machine hardware type (as defined in uname()).
     * @param nProcessors The number of processor threads (e.g.
     * @param dataDir The path to the node data directory.
     */
    InternalNodeInfo(const ::std::string& name, const ::std::string& os, const ::std::string& hostname, const ::std::string& release, const ::std::string& version, const ::std::string& machine, int nProcessors, const ::std::string& dataDir) :
        name(name),
        os(os),
        hostname(hostname),
        release(release),
        version(version),
        machine(machine),
        nProcessors(nProcessors),
        dataDir(dataDir)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const int&, const ::std::string&> ice_tuple() const
    {
        return std::tie(name, os, hostname, release, version, machine, nProcessors, dataDir);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /**
     * The name of the node.
     */
    ::std::string name;
    /**
     * The operating system name.
     */
    ::std::string os;
    /**
     * The network name of the host running this node (as defined in uname()).
     */
    ::std::string hostname;
    /**
     * The operation system release level (as defined in uname()).
     */
    ::std::string release;
    /**
     * The operation system version (as defined in uname()).
     */
    ::std::string version;
    /**
     * The machine hardware type (as defined in uname()).
     */
    ::std::string machine;
    /**
     * The number of processor threads (e.g. 8 on system with 1 quad-core CPU, with 2 threads per core)
     */
    int nProcessors;
    /**
     * The path to the node data directory.
     */
    ::std::string dataDir;
};

/**
 * Information about an IceGrid registry replica.
 */
class InternalReplicaInfo : public ::Ice::ValueHelper<InternalReplicaInfo, ::Ice::Value>
{
public:

    virtual ~InternalReplicaInfo();

    InternalReplicaInfo() = default;

    InternalReplicaInfo(const InternalReplicaInfo&) = default;
    InternalReplicaInfo(InternalReplicaInfo&&) = default;
    InternalReplicaInfo& operator=(const InternalReplicaInfo&) = default;
    InternalReplicaInfo& operator=(InternalReplicaInfo&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     * @param name The name of the registry.
     * @param hostname The network name of the host running this registry (as defined in uname()).
     */
    InternalReplicaInfo(const ::std::string& name, const ::std::string& hostname) :
        name(name),
        hostname(hostname)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::std::string&> ice_tuple() const
    {
        return std::tie(name, hostname);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /**
     * The name of the registry.
     */
    ::std::string name;
    /**
     * The network name of the host running this registry (as defined in uname()).
     */
    ::std::string hostname;
};

}

namespace IceGrid
{

class AdapterPrx : public ::Ice::Proxy<AdapterPrx, ::Ice::ObjectPrx>
{
public:

    /**
     * Activate this adapter. If this adapter can be activated, this will activate the adapter and return the direct
     * proxy of the adapter once it's active. If this adapter can be activated on demand, this will return 0 if the
     * adapter is inactive or the adapter direct proxy it's active.
     * @param context The Context map to send with the invocation.
     */
    ::std::shared_ptr<::Ice::ObjectPrx> activate(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Ice::ObjectPrx>>(true, this, &AdapterPrx::_iceI_activate, context).get();
    }

    /**
     * Activate this adapter. If this adapter can be activated, this will activate the adapter and return the direct
     * proxy of the adapter once it's active. If this adapter can be activated on demand, this will return 0 if the
     * adapter is inactive or the adapter direct proxy it's active.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    template<template<typename> class P = ::std::promise>
    auto activateAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::shared_ptr<::Ice::ObjectPrx>>>().get_future())
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Ice::ObjectPrx>, P>(false, this, &AdapterPrx::_iceI_activate, context);
    }

    /**
     * Activate this adapter. If this adapter can be activated, this will activate the adapter and return the direct
     * proxy of the adapter once it's active. If this adapter can be activated on demand, this will return 0 if the
     * adapter is inactive or the adapter direct proxy it's active.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    activateAsync(::std::function<void(::std::shared_ptr<::Ice::ObjectPrx>)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<::std::shared_ptr<::Ice::ObjectPrx>>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdapterPrx::_iceI_activate, context);
    }

    /// \cond INTERNAL
    void _iceI_activate(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Ice::ObjectPrx>>>&, const ::Ice::Context&);
    /// \endcond

    /**
     * Get the adapter direct proxy. The adapter direct proxy is a proxy created with the object adapter. The proxy
     * contains the last known adapter endpoints.
     * @param context The Context map to send with the invocation.
     * @return A direct proxy containing the last known adapter endpoints if the adapter is already active.
     */
    ::std::shared_ptr<::Ice::ObjectPrx> getDirectProxy(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Ice::ObjectPrx>>(true, this, &AdapterPrx::_iceI_getDirectProxy, context).get();
    }

    /**
     * Get the adapter direct proxy. The adapter direct proxy is a proxy created with the object adapter. The proxy
     * contains the last known adapter endpoints.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    template<template<typename> class P = ::std::promise>
    auto getDirectProxyAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::shared_ptr<::Ice::ObjectPrx>>>().get_future())
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Ice::ObjectPrx>, P>(false, this, &AdapterPrx::_iceI_getDirectProxy, context);
    }

    /**
     * Get the adapter direct proxy. The adapter direct proxy is a proxy created with the object adapter. The proxy
     * contains the last known adapter endpoints.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    getDirectProxyAsync(::std::function<void(::std::shared_ptr<::Ice::ObjectPrx>)> response,
                        ::std::function<void(::std::exception_ptr)> ex = nullptr,
                        ::std::function<void(bool)> sent = nullptr,
                        const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<::std::shared_ptr<::Ice::ObjectPrx>>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdapterPrx::_iceI_getDirectProxy, context);
    }

    /// \cond INTERNAL
    void _iceI_getDirectProxy(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Ice::ObjectPrx>>>&, const ::Ice::Context&);
    /// \endcond

    /**
     * Set the direct proxy for this adapter.
     * @param context The Context map to send with the invocation.
     * @throws IceGrid::AdapterActiveException The adapter is already active. It's not possible to override the direct proxy of
     * an active adapter.
     */
    void setDirectProxy(const ::std::shared_ptr<::Ice::ObjectPrx>& proxy, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &AdapterPrx::_iceI_setDirectProxy, proxy, context).get();
    }

    /**
     * Set the direct proxy for this adapter.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    template<template<typename> class P = ::std::promise>
    auto setDirectProxyAsync(const ::std::shared_ptr<::Ice::ObjectPrx>& proxy, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &AdapterPrx::_iceI_setDirectProxy, proxy, context);
    }

    /**
     * Set the direct proxy for this adapter.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    setDirectProxyAsync(const ::std::shared_ptr<::Ice::ObjectPrx>& proxy,
                        ::std::function<void()> response,
                        ::std::function<void(::std::exception_ptr)> ex = nullptr,
                        ::std::function<void(bool)> sent = nullptr,
                        const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdapterPrx::_iceI_setDirectProxy, proxy, context);
    }

    /// \cond INTERNAL
    void _iceI_setDirectProxy(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::shared_ptr<::Ice::ObjectPrx>&, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    explicit AdapterPrx(const ::Ice::ObjectPrx& other) : ::Ice::ObjectPrx(other)
    {
    }

    /// \cond INTERNAL
    AdapterPrx(const ::IceInternal::ReferencePtr& ref) : ::Ice::ObjectPrx(ref)
    {
    }
    /// \endcond

protected:

    /// \cond INTERNAL
    AdapterPrx() = default;
    /// \endcond
};

class FileReaderPrx : public ::Ice::Proxy<FileReaderPrx, ::Ice::ObjectPrx>
{
public:

    /**
     * Count the number of given lines from the end of the file and return the file offset.
     * @param context The Context map to send with the invocation.
     */
    long long int getOffsetFromEnd(const ::std::string& filename, int lines, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<long long int>(true, this, &FileReaderPrx::_iceI_getOffsetFromEnd, filename, lines, context).get();
    }

    /**
     * Count the number of given lines from the end of the file and return the file offset.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    template<template<typename> class P = ::std::promise>
    auto getOffsetFromEndAsync(const ::std::string& filename, int lines, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<long long int>>().get_future())
    {
        return _makePromiseOutgoing<long long int, P>(false, this, &FileReaderPrx::_iceI_getOffsetFromEnd, filename, lines, context);
    }

    /**
     * Count the number of given lines from the end of the file and return the file offset.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    getOffsetFromEndAsync(const ::std::string& filename, int lines,
                          ::std::function<void(long long int)> response,
                          ::std::function<void(::std::exception_ptr)> ex = nullptr,
                          ::std::function<void(bool)> sent = nullptr,
                          const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<long long int>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::FileReaderPrx::_iceI_getOffsetFromEnd, filename, lines, context);
    }

    /// \cond INTERNAL
    void _iceI_getOffsetFromEnd(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<long long int>>&, const ::std::string&, int, const ::Ice::Context&);
    /// \endcond

    /**
     * Read lines (or size bytes) at the specified position from the given file.
     * @param context The Context map to send with the invocation.
     */
    bool read(const ::std::string& filename, long long int pos, int size, long long int& newPos, ::Ice::StringSeq& lines, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<FileReader::ReadResult>(true, this, &FileReaderPrx::_iceI_read, filename, pos, size, context).get();
        newPos = _result.newPos;
        lines = ::std::move(_result.lines);
        return _result.returnValue;
    }

    /**
     * Read lines (or size bytes) at the specified position from the given file.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    template<template<typename> class P = ::std::promise>
    auto readAsync(const ::std::string& filename, long long int pos, int size, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<FileReader::ReadResult>>().get_future())
    {
        return _makePromiseOutgoing<FileReader::ReadResult, P>(false, this, &FileReaderPrx::_iceI_read, filename, pos, size, context);
    }

    /**
     * Read lines (or size bytes) at the specified position from the given file.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    readAsync(const ::std::string& filename, long long int pos, int size,
              ::std::function<void(bool, long long int, ::Ice::StringSeq)> response,
              ::std::function<void(::std::exception_ptr)> ex = nullptr,
              ::std::function<void(bool)> sent = nullptr,
              const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](FileReader::ReadResult&& _result)
        {
            response(_result.returnValue, _result.newPos, ::std::move(_result.lines));
        };
        return _makeLambdaOutgoing<FileReader::ReadResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &IceGrid::FileReaderPrx::_iceI_read, filename, pos, size, context);
    }

    /// \cond INTERNAL
    void _iceI_read(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<FileReader::ReadResult>>&, const ::std::string&, long long int, int, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    explicit FileReaderPrx(const ::Ice::ObjectPrx& other) : ::Ice::ObjectPrx(other)
    {
    }

    /// \cond INTERNAL
    FileReaderPrx(const ::IceInternal::ReferencePtr& ref) : ::Ice::ObjectPrx(ref)
    {
    }
    /// \endcond

protected:

    /// \cond INTERNAL
    FileReaderPrx() = default;
    /// \endcond
};

class ServerPrx : public ::Ice::Proxy<ServerPrx, FileReaderPrx>
{
public:

    /**
     * Start the server.
     * @param context The Context map to send with the invocation.
     */
    void start(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &ServerPrx::_iceI_start, context).get();
    }

    /**
     * Start the server.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    template<template<typename> class P = ::std::promise>
    auto startAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &ServerPrx::_iceI_start, context);
    }

    /**
     * Start the server.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    startAsync(::std::function<void()> response,
               ::std::function<void(::std::exception_ptr)> ex = nullptr,
               ::std::function<void(bool)> sent = nullptr,
               const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::ServerPrx::_iceI_start, context);
    }

    /// \cond INTERNAL
    void _iceI_start(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    /**
     * Stop the server. This methods returns only when the server is deactivated. If the server doesn't stop after a
     * configurable amount of time, it will be killed.
     * @param context The Context map to send with the invocation.
     */
    void stop(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &ServerPrx::_iceI_stop, context).get();
    }

    /**
     * Stop the server. This methods returns only when the server is deactivated. If the server doesn't stop after a
     * configurable amount of time, it will be killed.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    template<template<typename> class P = ::std::promise>
    auto stopAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &ServerPrx::_iceI_stop, context);
    }

    /**
     * Stop the server. This methods returns only when the server is deactivated. If the server doesn't stop after a
     * configurable amount of time, it will be killed.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    stopAsync(::std::function<void()> response,
              ::std::function<void(::std::exception_ptr)> ex = nullptr,
              ::std::function<void(bool)> sent = nullptr,
              const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::ServerPrx::_iceI_stop, context);
    }

    /// \cond INTERNAL
    void _iceI_stop(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    /**
     * Check if the given server can be loaded on this node.
     * @param context The Context map to send with the invocation.
     * @return True if the server is inactive.
     * @throws IceGrid::DeploymentException Raised if the server can't be updated.
     */
    bool checkUpdate(const ::std::shared_ptr<InternalServerDescriptor>& svr, bool noRestart, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<bool>(true, this, &ServerPrx::_iceI_checkUpdate, svr, noRestart, context).get();
    }

    /**
     * Check if the given server can be loaded on this node.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    template<template<typename> class P = ::std::promise>
    auto checkUpdateAsync(const ::std::shared_ptr<InternalServerDescriptor>& svr, bool noRestart, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<bool>>().get_future())
    {
        return _makePromiseOutgoing<bool, P>(false, this, &ServerPrx::_iceI_checkUpdate, svr, noRestart, context);
    }

    /**
     * Check if the given server can be loaded on this node.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    checkUpdateAsync(const ::std::shared_ptr<InternalServerDescriptor>& svr, bool noRestart,
                     ::std::function<void(bool)> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<bool>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::ServerPrx::_iceI_checkUpdate, svr, noRestart, context);
    }

    /// \cond INTERNAL
    void _iceI_checkUpdate(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>&, const ::std::shared_ptr<InternalServerDescriptor>&, bool, const ::Ice::Context&);
    /// \endcond

    /**
     * Enable or disable the server.
     * @param context The Context map to send with the invocation.
     */
    void setEnabled(bool enable, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &ServerPrx::_iceI_setEnabled, enable, context).get();
    }

    /**
     * Enable or disable the server.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    template<template<typename> class P = ::std::promise>
    auto setEnabledAsync(bool enable, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &ServerPrx::_iceI_setEnabled, enable, context);
    }

    /**
     * Enable or disable the server.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    setEnabledAsync(bool enable,
                    ::std::function<void()> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::ServerPrx::_iceI_setEnabled, enable, context);
    }

    /// \cond INTERNAL
    void _iceI_setEnabled(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, bool, const ::Ice::Context&);
    /// \endcond

    /**
     * Check if the server is enabled.
     * @param context The Context map to send with the invocation.
     */
    bool isEnabled(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<bool>(true, this, &ServerPrx::_iceI_isEnabled, context).get();
    }

    /**
     * Check if the server is enabled.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    template<template<typename> class P = ::std::promise>
    auto isEnabledAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<bool>>().get_future())
    {
        return _makePromiseOutgoing<bool, P>(false, this, &ServerPrx::_iceI_isEnabled, context);
    }

    /**
     * Check if the server is enabled.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    isEnabledAsync(::std::function<void(bool)> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<bool>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::ServerPrx::_iceI_isEnabled, context);
    }

    /// \cond INTERNAL
    void _iceI_isEnabled(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>&, const ::Ice::Context&);
    /// \endcond

    /**
     * Send signal to the server
     * @param context The Context map to send with the invocation.
     */
    void sendSignal(const ::std::string& signal, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &ServerPrx::_iceI_sendSignal, signal, context).get();
    }

    /**
     * Send signal to the server
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    template<template<typename> class P = ::std::promise>
    auto sendSignalAsync(const ::std::string& signal, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &ServerPrx::_iceI_sendSignal, signal, context);
    }

    /**
     * Send signal to the server
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    sendSignalAsync(const ::std::string& signal,
                    ::std::function<void()> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::ServerPrx::_iceI_sendSignal, signal, context);
    }

    /// \cond INTERNAL
    void _iceI_sendSignal(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    /**
     * Write message on servers' stdout or stderr.
     * @param context The Context map to send with the invocation.
     */
    void writeMessage(const ::std::string& message, int fd, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &ServerPrx::_iceI_writeMessage, message, fd, context).get();
    }

    /**
     * Write message on servers' stdout or stderr.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    template<template<typename> class P = ::std::promise>
    auto writeMessageAsync(const ::std::string& message, int fd, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &ServerPrx::_iceI_writeMessage, message, fd, context);
    }

    /**
     * Write message on servers' stdout or stderr.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    writeMessageAsync(const ::std::string& message, int fd,
                      ::std::function<void()> response,
                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                      ::std::function<void(bool)> sent = nullptr,
                      const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::ServerPrx::_iceI_writeMessage, message, fd, context);
    }

    /// \cond INTERNAL
    void _iceI_writeMessage(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, int, const ::Ice::Context&);
    /// \endcond

    /**
     * Return the server state.
     * @param context The Context map to send with the invocation.
     * @return The server state.
     * @see ServerState
     */
    ServerState getState(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::IceGrid::ServerState>(true, this, &ServerPrx::_iceI_getState, context).get();
    }

    /**
     * Return the server state.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     * @see ServerState
     */
    template<template<typename> class P = ::std::promise>
    auto getStateAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::IceGrid::ServerState>>().get_future())
    {
        return _makePromiseOutgoing<::IceGrid::ServerState, P>(false, this, &ServerPrx::_iceI_getState, context);
    }

    /**
     * Return the server state.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     * @see ServerState
     */
    ::std::function<void()>
    getStateAsync(::std::function<void(::IceGrid::ServerState)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<::IceGrid::ServerState>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::ServerPrx::_iceI_getState, context);
    }

    /// \cond INTERNAL
    void _iceI_getState(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::IceGrid::ServerState>>&, const ::Ice::Context&);
    /// \endcond

    /**
     * Get the server pid. Note that the value returned by this method is system dependant. On Unix operating systems,
     * it's the pid value returned by the fork() system call and converted to an integer.
     * @param context The Context map to send with the invocation.
     */
    int getPid(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<int>(true, this, &ServerPrx::_iceI_getPid, context).get();
    }

    /**
     * Get the server pid. Note that the value returned by this method is system dependant. On Unix operating systems,
     * it's the pid value returned by the fork() system call and converted to an integer.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    template<template<typename> class P = ::std::promise>
    auto getPidAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<int>>().get_future())
    {
        return _makePromiseOutgoing<int, P>(false, this, &ServerPrx::_iceI_getPid, context);
    }

    /**
     * Get the server pid. Note that the value returned by this method is system dependant. On Unix operating systems,
     * it's the pid value returned by the fork() system call and converted to an integer.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    getPidAsync(::std::function<void(int)> response,
                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                ::std::function<void(bool)> sent = nullptr,
                const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<int>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::ServerPrx::_iceI_getPid, context);
    }

    /// \cond INTERNAL
    void _iceI_getPid(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<int>>&, const ::Ice::Context&);
    /// \endcond

    /**
     * Set the process proxy.
     * @param context The Context map to send with the invocation.
     */
    void setProcess(const ::std::shared_ptr<::Ice::ProcessPrx>& proc, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &ServerPrx::_iceI_setProcess, proc, context).get();
    }

    /**
     * Set the process proxy.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    template<template<typename> class P = ::std::promise>
    auto setProcessAsync(const ::std::shared_ptr<::Ice::ProcessPrx>& proc, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &ServerPrx::_iceI_setProcess, proc, context);
    }

    /**
     * Set the process proxy.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    setProcessAsync(const ::std::shared_ptr<::Ice::ProcessPrx>& proc,
                    ::std::function<void()> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::ServerPrx::_iceI_setProcess, proc, context);
    }

    /// \cond INTERNAL
    void _iceI_setProcess(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::shared_ptr<::Ice::ProcessPrx>&, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    explicit ServerPrx(const ::Ice::ObjectPrx& other) : ::Ice::ObjectPrx(other)
    {
    }

    /// \cond INTERNAL
    ServerPrx(const ::IceInternal::ReferencePtr& ref) : ::Ice::ObjectPrx(ref)
    {
    }
    /// \endcond

protected:

    /// \cond INTERNAL
    ServerPrx() = default;
    /// \endcond
};

class ReplicaObserverPrx : public ::Ice::Proxy<ReplicaObserverPrx, ::Ice::ObjectPrx>
{
public:

    /**
     * Initialization of the replica observer.
     * @param context The Context map to send with the invocation.
     */
    void replicaInit(const InternalRegistryPrxSeq& replicas, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &ReplicaObserverPrx::_iceI_replicaInit, replicas, context).get();
    }

    /**
     * Initialization of the replica observer.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    template<template<typename> class P = ::std::promise>
    auto replicaInitAsync(const InternalRegistryPrxSeq& replicas, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &ReplicaObserverPrx::_iceI_replicaInit, replicas, context);
    }

    /**
     * Initialization of the replica observer.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    replicaInitAsync(const InternalRegistryPrxSeq& replicas,
                     ::std::function<void()> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::ReplicaObserverPrx::_iceI_replicaInit, replicas, context);
    }

    /// \cond INTERNAL
    void _iceI_replicaInit(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const InternalRegistryPrxSeq&, const ::Ice::Context&);
    /// \endcond

    /**
     * Notification that a replica has been added. The node should establish a session with this new replica.
     * @param context The Context map to send with the invocation.
     */
    void replicaAdded(const ::std::shared_ptr<InternalRegistryPrx>& replica, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &ReplicaObserverPrx::_iceI_replicaAdded, replica, context).get();
    }

    /**
     * Notification that a replica has been added. The node should establish a session with this new replica.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    template<template<typename> class P = ::std::promise>
    auto replicaAddedAsync(const ::std::shared_ptr<InternalRegistryPrx>& replica, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &ReplicaObserverPrx::_iceI_replicaAdded, replica, context);
    }

    /**
     * Notification that a replica has been added. The node should establish a session with this new replica.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    replicaAddedAsync(const ::std::shared_ptr<InternalRegistryPrx>& replica,
                      ::std::function<void()> response,
                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                      ::std::function<void(bool)> sent = nullptr,
                      const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::ReplicaObserverPrx::_iceI_replicaAdded, replica, context);
    }

    /// \cond INTERNAL
    void _iceI_replicaAdded(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::shared_ptr<InternalRegistryPrx>&, const ::Ice::Context&);
    /// \endcond

    /**
     * Notification that a replica has been removed. The node should destroy the session to this replica.
     * @param context The Context map to send with the invocation.
     */
    void replicaRemoved(const ::std::shared_ptr<InternalRegistryPrx>& replica, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &ReplicaObserverPrx::_iceI_replicaRemoved, replica, context).get();
    }

    /**
     * Notification that a replica has been removed. The node should destroy the session to this replica.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    template<template<typename> class P = ::std::promise>
    auto replicaRemovedAsync(const ::std::shared_ptr<InternalRegistryPrx>& replica, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &ReplicaObserverPrx::_iceI_replicaRemoved, replica, context);
    }

    /**
     * Notification that a replica has been removed. The node should destroy the session to this replica.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    replicaRemovedAsync(const ::std::shared_ptr<InternalRegistryPrx>& replica,
                        ::std::function<void()> response,
                        ::std::function<void(::std::exception_ptr)> ex = nullptr,
                        ::std::function<void(bool)> sent = nullptr,
                        const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::ReplicaObserverPrx::_iceI_replicaRemoved, replica, context);
    }

    /// \cond INTERNAL
    void _iceI_replicaRemoved(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::shared_ptr<InternalRegistryPrx>&, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    explicit ReplicaObserverPrx(const ::Ice::ObjectPrx& other) : ::Ice::ObjectPrx(other)
    {
    }

    /// \cond INTERNAL
    ReplicaObserverPrx(const ::IceInternal::ReferencePtr& ref) : ::Ice::ObjectPrx(ref)
    {
    }
    /// \endcond

protected:

    /// \cond INTERNAL
    ReplicaObserverPrx() = default;
    /// \endcond
};

class PatcherFeedbackPrx : public ::Ice::Proxy<PatcherFeedbackPrx, ::Ice::ObjectPrx>
{
public:

    /**
     * The patch completed successfully.
     * @param context The Context map to send with the invocation.
     */
    void finished(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &PatcherFeedbackPrx::_iceI_finished, context).get();
    }

    /**
     * The patch completed successfully.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    template<template<typename> class P = ::std::promise>
    auto finishedAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &PatcherFeedbackPrx::_iceI_finished, context);
    }

    /**
     * The patch completed successfully.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    finishedAsync(::std::function<void()> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::PatcherFeedbackPrx::_iceI_finished, context);
    }

    /// \cond INTERNAL
    void _iceI_finished(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    /**
     * The patch on the given node failed for the given reason.
     * @param context The Context map to send with the invocation.
     */
    void failed(const ::std::string& reason, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &PatcherFeedbackPrx::_iceI_failed, reason, context).get();
    }

    /**
     * The patch on the given node failed for the given reason.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    template<template<typename> class P = ::std::promise>
    auto failedAsync(const ::std::string& reason, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &PatcherFeedbackPrx::_iceI_failed, reason, context);
    }

    /**
     * The patch on the given node failed for the given reason.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    failedAsync(const ::std::string& reason,
                ::std::function<void()> response,
                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                ::std::function<void(bool)> sent = nullptr,
                const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::PatcherFeedbackPrx::_iceI_failed, reason, context);
    }

    /// \cond INTERNAL
    void _iceI_failed(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    explicit PatcherFeedbackPrx(const ::Ice::ObjectPrx& other) : ::Ice::ObjectPrx(other)
    {
    }

    /// \cond INTERNAL
    PatcherFeedbackPrx(const ::IceInternal::ReferencePtr& ref) : ::Ice::ObjectPrx(ref)
    {
    }
    /// \endcond

protected:

    /// \cond INTERNAL
    PatcherFeedbackPrx() = default;
    /// \endcond
};

class NodePrx : public ::Ice::Proxy<NodePrx, FileReaderPrx, ReplicaObserverPrx>
{
public:

    /**
     * Load the given server. If the server resources weren't already created (database environment directories,
     * property files, etc), they will be created.
     * @param context The Context map to send with the invocation.
     */
    ::std::shared_ptr<ServerPrx> loadServer(const ::std::shared_ptr<InternalServerDescriptor>& svr, const ::std::string& replicaName, AdapterPrxDict& adapters, int& actTimeout, int& deactTimeout, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Node::LoadServerResult>(true, this, &NodePrx::_iceI_loadServer, svr, replicaName, context).get();
        adapters = ::std::move(_result.adapters);
        actTimeout = _result.actTimeout;
        deactTimeout = _result.deactTimeout;
        return ::std::move(_result.returnValue);
    }

    /**
     * Load the given server. If the server resources weren't already created (database environment directories,
     * property files, etc), they will be created.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    template<template<typename> class P = ::std::promise>
    auto loadServerAsync(const ::std::shared_ptr<InternalServerDescriptor>& svr, const ::std::string& replicaName, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Node::LoadServerResult>>().get_future())
    {
        return _makePromiseOutgoing<Node::LoadServerResult, P>(false, this, &NodePrx::_iceI_loadServer, svr, replicaName, context);
    }

    /**
     * Load the given server. If the server resources weren't already created (database environment directories,
     * property files, etc), they will be created.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    loadServerAsync(const ::std::shared_ptr<InternalServerDescriptor>& svr, const ::std::string& replicaName,
                    ::std::function<void(::std::shared_ptr<::IceGrid::ServerPrx>, ::IceGrid::AdapterPrxDict, int, int)> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Node::LoadServerResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.adapters), _result.actTimeout, _result.deactTimeout);
        };
        return _makeLambdaOutgoing<Node::LoadServerResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &IceGrid::NodePrx::_iceI_loadServer, svr, replicaName, context);
    }

    /// \cond INTERNAL
    void _iceI_loadServer(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Node::LoadServerResult>>&, const ::std::shared_ptr<InternalServerDescriptor>&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    /**
     * Load the given server and ensure the server won't be restarted. If the server resources weren't already created
     * (database environment directories, property files, etc), they will be created. If the server can't be updated
     * without a restart, a DeploymentException is raised.
     * @param context The Context map to send with the invocation.
     */
    ::std::shared_ptr<ServerPrx> loadServerWithoutRestart(const ::std::shared_ptr<InternalServerDescriptor>& svr, const ::std::string& replicaName, AdapterPrxDict& adapters, int& actTimeout, int& deactTimeout, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Node::LoadServerWithoutRestartResult>(true, this, &NodePrx::_iceI_loadServerWithoutRestart, svr, replicaName, context).get();
        adapters = ::std::move(_result.adapters);
        actTimeout = _result.actTimeout;
        deactTimeout = _result.deactTimeout;
        return ::std::move(_result.returnValue);
    }

    /**
     * Load the given server and ensure the server won't be restarted. If the server resources weren't already created
     * (database environment directories, property files, etc), they will be created. If the server can't be updated
     * without a restart, a DeploymentException is raised.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    template<template<typename> class P = ::std::promise>
    auto loadServerWithoutRestartAsync(const ::std::shared_ptr<InternalServerDescriptor>& svr, const ::std::string& replicaName, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Node::LoadServerWithoutRestartResult>>().get_future())
    {
        return _makePromiseOutgoing<Node::LoadServerWithoutRestartResult, P>(false, this, &NodePrx::_iceI_loadServerWithoutRestart, svr, replicaName, context);
    }

    /**
     * Load the given server and ensure the server won't be restarted. If the server resources weren't already created
     * (database environment directories, property files, etc), they will be created. If the server can't be updated
     * without a restart, a DeploymentException is raised.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    loadServerWithoutRestartAsync(const ::std::shared_ptr<InternalServerDescriptor>& svr, const ::std::string& replicaName,
                                  ::std::function<void(::std::shared_ptr<::IceGrid::ServerPrx>, ::IceGrid::AdapterPrxDict, int, int)> response,
                                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                                  ::std::function<void(bool)> sent = nullptr,
                                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Node::LoadServerWithoutRestartResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.adapters), _result.actTimeout, _result.deactTimeout);
        };
        return _makeLambdaOutgoing<Node::LoadServerWithoutRestartResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &IceGrid::NodePrx::_iceI_loadServerWithoutRestart, svr, replicaName, context);
    }

    /// \cond INTERNAL
    void _iceI_loadServerWithoutRestart(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Node::LoadServerWithoutRestartResult>>&, const ::std::shared_ptr<InternalServerDescriptor>&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    /**
     * Destroy the given server.
     * @param context The Context map to send with the invocation.
     */
    void destroyServer(const ::std::string& name, const ::std::string& uuid, int revision, const ::std::string& replicaName, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &NodePrx::_iceI_destroyServer, name, uuid, revision, replicaName, context).get();
    }

    /**
     * Destroy the given server.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    template<template<typename> class P = ::std::promise>
    auto destroyServerAsync(const ::std::string& name, const ::std::string& uuid, int revision, const ::std::string& replicaName, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &NodePrx::_iceI_destroyServer, name, uuid, revision, replicaName, context);
    }

    /**
     * Destroy the given server.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    destroyServerAsync(const ::std::string& name, const ::std::string& uuid, int revision, const ::std::string& replicaName,
                       ::std::function<void()> response,
                       ::std::function<void(::std::exception_ptr)> ex = nullptr,
                       ::std::function<void(bool)> sent = nullptr,
                       const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::NodePrx::_iceI_destroyServer, name, uuid, revision, replicaName, context);
    }

    /// \cond INTERNAL
    void _iceI_destroyServer(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, const ::std::string&, int, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    /**
     * Destroy the server if it's not active.
     * @param context The Context map to send with the invocation.
     */
    void destroyServerWithoutRestart(const ::std::string& name, const ::std::string& uuid, int revision, const ::std::string& replicaName, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &NodePrx::_iceI_destroyServerWithoutRestart, name, uuid, revision, replicaName, context).get();
    }

    /**
     * Destroy the server if it's not active.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    template<template<typename> class P = ::std::promise>
    auto destroyServerWithoutRestartAsync(const ::std::string& name, const ::std::string& uuid, int revision, const ::std::string& replicaName, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &NodePrx::_iceI_destroyServerWithoutRestart, name, uuid, revision, replicaName, context);
    }

    /**
     * Destroy the server if it's not active.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    destroyServerWithoutRestartAsync(const ::std::string& name, const ::std::string& uuid, int revision, const ::std::string& replicaName,
                                     ::std::function<void()> response,
                                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                                     ::std::function<void(bool)> sent = nullptr,
                                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::NodePrx::_iceI_destroyServerWithoutRestart, name, uuid, revision, replicaName, context);
    }

    /// \cond INTERNAL
    void _iceI_destroyServerWithoutRestart(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, const ::std::string&, int, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    /**
     * Patch application and server distributions. If some servers using a distribution directory to patch are active,
     * this method will raise a PatchException unless shutdown is set to true. In which case the servers will be
     * shutdown.
     * @param context The Context map to send with the invocation.
     */
    void patch(const ::std::shared_ptr<PatcherFeedbackPrx>& feedback, const ::std::string& application, const ::std::string& server, const ::std::shared_ptr<InternalDistributionDescriptor>& appDistrib, bool shutdown, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &NodePrx::_iceI_patch, feedback, application, server, appDistrib, shutdown, context).get();
    }

    /**
     * Patch application and server distributions. If some servers using a distribution directory to patch are active,
     * this method will raise a PatchException unless shutdown is set to true. In which case the servers will be
     * shutdown.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    template<template<typename> class P = ::std::promise>
    auto patchAsync(const ::std::shared_ptr<PatcherFeedbackPrx>& feedback, const ::std::string& application, const ::std::string& server, const ::std::shared_ptr<InternalDistributionDescriptor>& appDistrib, bool shutdown, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &NodePrx::_iceI_patch, feedback, application, server, appDistrib, shutdown, context);
    }

    /**
     * Patch application and server distributions. If some servers using a distribution directory to patch are active,
     * this method will raise a PatchException unless shutdown is set to true. In which case the servers will be
     * shutdown.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    patchAsync(const ::std::shared_ptr<PatcherFeedbackPrx>& feedback, const ::std::string& application, const ::std::string& server, const ::std::shared_ptr<InternalDistributionDescriptor>& appDistrib, bool shutdown,
               ::std::function<void()> response,
               ::std::function<void(::std::exception_ptr)> ex = nullptr,
               ::std::function<void(bool)> sent = nullptr,
               const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::NodePrx::_iceI_patch, feedback, application, server, appDistrib, shutdown, context);
    }

    /// \cond INTERNAL
    void _iceI_patch(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::shared_ptr<PatcherFeedbackPrx>&, const ::std::string&, const ::std::string&, const ::std::shared_ptr<InternalDistributionDescriptor>&, bool, const ::Ice::Context&);
    /// \endcond

    /**
     * Establish a session to the given replica, this method only returns once the registration was attempted (unlike
     * replicaAdded below).
     * @param context The Context map to send with the invocation.
     */
    void registerWithReplica(const ::std::shared_ptr<InternalRegistryPrx>& replica, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &NodePrx::_iceI_registerWithReplica, replica, context).get();
    }

    /**
     * Establish a session to the given replica, this method only returns once the registration was attempted (unlike
     * replicaAdded below).
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    template<template<typename> class P = ::std::promise>
    auto registerWithReplicaAsync(const ::std::shared_ptr<InternalRegistryPrx>& replica, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &NodePrx::_iceI_registerWithReplica, replica, context);
    }

    /**
     * Establish a session to the given replica, this method only returns once the registration was attempted (unlike
     * replicaAdded below).
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    registerWithReplicaAsync(const ::std::shared_ptr<InternalRegistryPrx>& replica,
                             ::std::function<void()> response,
                             ::std::function<void(::std::exception_ptr)> ex = nullptr,
                             ::std::function<void(bool)> sent = nullptr,
                             const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::NodePrx::_iceI_registerWithReplica, replica, context);
    }

    /// \cond INTERNAL
    void _iceI_registerWithReplica(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::shared_ptr<InternalRegistryPrx>&, const ::Ice::Context&);
    /// \endcond

    /**
     * Get the node name.
     * @param context The Context map to send with the invocation.
     */
    ::std::string getName(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::std::string>(true, this, &NodePrx::_iceI_getName, context).get();
    }

    /**
     * Get the node name.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    template<template<typename> class P = ::std::promise>
    auto getNameAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::string>>().get_future())
    {
        return _makePromiseOutgoing<::std::string, P>(false, this, &NodePrx::_iceI_getName, context);
    }

    /**
     * Get the node name.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    getNameAsync(::std::function<void(::std::string)> response,
                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                 ::std::function<void(bool)> sent = nullptr,
                 const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<::std::string>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::NodePrx::_iceI_getName, context);
    }

    /// \cond INTERNAL
    void _iceI_getName(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::string>>&, const ::Ice::Context&);
    /// \endcond

    /**
     * Get the node hostname.
     * @param context The Context map to send with the invocation.
     */
    ::std::string getHostname(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::std::string>(true, this, &NodePrx::_iceI_getHostname, context).get();
    }

    /**
     * Get the node hostname.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    template<template<typename> class P = ::std::promise>
    auto getHostnameAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::string>>().get_future())
    {
        return _makePromiseOutgoing<::std::string, P>(false, this, &NodePrx::_iceI_getHostname, context);
    }

    /**
     * Get the node hostname.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    getHostnameAsync(::std::function<void(::std::string)> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<::std::string>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::NodePrx::_iceI_getHostname, context);
    }

    /// \cond INTERNAL
    void _iceI_getHostname(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::string>>&, const ::Ice::Context&);
    /// \endcond

    /**
     * Get the node load.
     * @param context The Context map to send with the invocation.
     */
    LoadInfo getLoad(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::IceGrid::LoadInfo>(true, this, &NodePrx::_iceI_getLoad, context).get();
    }

    /**
     * Get the node load.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    template<template<typename> class P = ::std::promise>
    auto getLoadAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::IceGrid::LoadInfo>>().get_future())
    {
        return _makePromiseOutgoing<::IceGrid::LoadInfo, P>(false, this, &NodePrx::_iceI_getLoad, context);
    }

    /**
     * Get the node load.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    getLoadAsync(::std::function<void(::IceGrid::LoadInfo)> response,
                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                 ::std::function<void(bool)> sent = nullptr,
                 const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<::IceGrid::LoadInfo>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::NodePrx::_iceI_getLoad, context);
    }

    /// \cond INTERNAL
    void _iceI_getLoad(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::IceGrid::LoadInfo>>&, const ::Ice::Context&);
    /// \endcond

    /**
     * Get the number of processor sockets for the machine where this node is running.
     * @param context The Context map to send with the invocation.
     */
    int getProcessorSocketCount(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<int>(true, this, &NodePrx::_iceI_getProcessorSocketCount, context).get();
    }

    /**
     * Get the number of processor sockets for the machine where this node is running.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    template<template<typename> class P = ::std::promise>
    auto getProcessorSocketCountAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<int>>().get_future())
    {
        return _makePromiseOutgoing<int, P>(false, this, &NodePrx::_iceI_getProcessorSocketCount, context);
    }

    /**
     * Get the number of processor sockets for the machine where this node is running.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    getProcessorSocketCountAsync(::std::function<void(int)> response,
                                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                                 ::std::function<void(bool)> sent = nullptr,
                                 const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<int>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::NodePrx::_iceI_getProcessorSocketCount, context);
    }

    /// \cond INTERNAL
    void _iceI_getProcessorSocketCount(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<int>>&, const ::Ice::Context&);
    /// \endcond

    /**
     * Shutdown the node.
     * @param context The Context map to send with the invocation.
     */
    void shutdown(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &NodePrx::_iceI_shutdown, context).get();
    }

    /**
     * Shutdown the node.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    template<template<typename> class P = ::std::promise>
    auto shutdownAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &NodePrx::_iceI_shutdown, context);
    }

    /**
     * Shutdown the node.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    shutdownAsync(::std::function<void()> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::NodePrx::_iceI_shutdown, context);
    }

    /// \cond INTERNAL
    void _iceI_shutdown(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    explicit NodePrx(const ::Ice::ObjectPrx& other) : ::Ice::ObjectPrx(other)
    {
    }

    /// \cond INTERNAL
    NodePrx(const ::IceInternal::ReferencePtr& ref) : ::Ice::ObjectPrx(ref)
    {
    }
    /// \endcond

protected:

    /// \cond INTERNAL
    NodePrx() = default;
    /// \endcond
};

class NodeSessionPrx : public ::Ice::Proxy<NodeSessionPrx, ::Ice::ObjectPrx>
{
public:

    /**
     * The node call this method to keep the session alive.
     * @param context The Context map to send with the invocation.
     */
    void keepAlive(const LoadInfo& load, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &NodeSessionPrx::_iceI_keepAlive, load, context).get();
    }

    /**
     * The node call this method to keep the session alive.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    template<template<typename> class P = ::std::promise>
    auto keepAliveAsync(const LoadInfo& load, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &NodeSessionPrx::_iceI_keepAlive, load, context);
    }

    /**
     * The node call this method to keep the session alive.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    keepAliveAsync(const LoadInfo& load,
                   ::std::function<void()> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::NodeSessionPrx::_iceI_keepAlive, load, context);
    }

    /// \cond INTERNAL
    void _iceI_keepAlive(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const LoadInfo&, const ::Ice::Context&);
    /// \endcond

    /**
     * Set the replica observer. The node calls this method when it's ready to receive notifications for the replicas.
     * It only calls this for the session with the master.
     * @param context The Context map to send with the invocation.
     */
    void setReplicaObserver(const ::std::shared_ptr<ReplicaObserverPrx>& observer, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &NodeSessionPrx::_iceI_setReplicaObserver, observer, context).get();
    }

    /**
     * Set the replica observer. The node calls this method when it's ready to receive notifications for the replicas.
     * It only calls this for the session with the master.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    template<template<typename> class P = ::std::promise>
    auto setReplicaObserverAsync(const ::std::shared_ptr<ReplicaObserverPrx>& observer, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &NodeSessionPrx::_iceI_setReplicaObserver, observer, context);
    }

    /**
     * Set the replica observer. The node calls this method when it's ready to receive notifications for the replicas.
     * It only calls this for the session with the master.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    setReplicaObserverAsync(const ::std::shared_ptr<ReplicaObserverPrx>& observer,
                            ::std::function<void()> response,
                            ::std::function<void(::std::exception_ptr)> ex = nullptr,
                            ::std::function<void(bool)> sent = nullptr,
                            const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::NodeSessionPrx::_iceI_setReplicaObserver, observer, context);
    }

    /// \cond INTERNAL
    void _iceI_setReplicaObserver(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::shared_ptr<ReplicaObserverPrx>&, const ::Ice::Context&);
    /// \endcond

    /**
     * Return the node session timeout.
     * @param context The Context map to send with the invocation.
     */
    int getTimeout(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<int>(true, this, &NodeSessionPrx::_iceI_getTimeout, context).get();
    }

    /**
     * Return the node session timeout.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    template<template<typename> class P = ::std::promise>
    auto getTimeoutAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<int>>().get_future())
    {
        return _makePromiseOutgoing<int, P>(false, this, &NodeSessionPrx::_iceI_getTimeout, context);
    }

    /**
     * Return the node session timeout.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    getTimeoutAsync(::std::function<void(int)> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<int>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::NodeSessionPrx::_iceI_getTimeout, context);
    }

    /// \cond INTERNAL
    void _iceI_getTimeout(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<int>>&, const ::Ice::Context&);
    /// \endcond

    /**
     * Return the node observer.
     * @param context The Context map to send with the invocation.
     */
    ::std::shared_ptr<NodeObserverPrx> getObserver(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::std::shared_ptr<::IceGrid::NodeObserverPrx>>(true, this, &NodeSessionPrx::_iceI_getObserver, context).get();
    }

    /**
     * Return the node observer.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    template<template<typename> class P = ::std::promise>
    auto getObserverAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::shared_ptr<::IceGrid::NodeObserverPrx>>>().get_future())
    {
        return _makePromiseOutgoing<::std::shared_ptr<::IceGrid::NodeObserverPrx>, P>(false, this, &NodeSessionPrx::_iceI_getObserver, context);
    }

    /**
     * Return the node observer.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    getObserverAsync(::std::function<void(::std::shared_ptr<::IceGrid::NodeObserverPrx>)> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<::std::shared_ptr<::IceGrid::NodeObserverPrx>>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::NodeSessionPrx::_iceI_getObserver, context);
    }

    /// \cond INTERNAL
    void _iceI_getObserver(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::IceGrid::NodeObserverPrx>>>&, const ::Ice::Context&);
    /// \endcond

    /**
     * Ask the registry to load the servers on the node.
     * @param context The Context map to send with the invocation.
     */
    void loadServers(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &NodeSessionPrx::_iceI_loadServers, context).get();
    }

    /**
     * Ask the registry to load the servers on the node.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    template<template<typename> class P = ::std::promise>
    auto loadServersAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &NodeSessionPrx::_iceI_loadServers, context);
    }

    /**
     * Ask the registry to load the servers on the node.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    loadServersAsync(::std::function<void()> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::NodeSessionPrx::_iceI_loadServers, context);
    }

    /// \cond INTERNAL
    void _iceI_loadServers(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    /**
     * Get the name of the servers deployed on the node.
     * @param context The Context map to send with the invocation.
     */
    ::Ice::StringSeq getServers(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::Ice::StringSeq>(true, this, &NodeSessionPrx::_iceI_getServers, context).get();
    }

    /**
     * Get the name of the servers deployed on the node.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    template<template<typename> class P = ::std::promise>
    auto getServersAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::Ice::StringSeq>>().get_future())
    {
        return _makePromiseOutgoing<::Ice::StringSeq, P>(false, this, &NodeSessionPrx::_iceI_getServers, context);
    }

    /**
     * Get the name of the servers deployed on the node.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    getServersAsync(::std::function<void(::Ice::StringSeq)> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<::Ice::StringSeq>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::NodeSessionPrx::_iceI_getServers, context);
    }

    /// \cond INTERNAL
    void _iceI_getServers(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::Ice::StringSeq>>&, const ::Ice::Context&);
    /// \endcond

    /**
     * Wait for the application update to complete (the application is completely updated once all the registry
     * replicas have been updated). This is used by the node to ensure that before to start a server all the
     * replicas have the up-to-date descriptor of the server.
     * @param context The Context map to send with the invocation.
     */
    void waitForApplicationUpdate(const ::std::string& application, int revision, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &NodeSessionPrx::_iceI_waitForApplicationUpdate, application, revision, context).get();
    }

    /**
     * Wait for the application update to complete (the application is completely updated once all the registry
     * replicas have been updated). This is used by the node to ensure that before to start a server all the
     * replicas have the up-to-date descriptor of the server.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    template<template<typename> class P = ::std::promise>
    auto waitForApplicationUpdateAsync(const ::std::string& application, int revision, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &NodeSessionPrx::_iceI_waitForApplicationUpdate, application, revision, context);
    }

    /**
     * Wait for the application update to complete (the application is completely updated once all the registry
     * replicas have been updated). This is used by the node to ensure that before to start a server all the
     * replicas have the up-to-date descriptor of the server.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    waitForApplicationUpdateAsync(const ::std::string& application, int revision,
                                  ::std::function<void()> response,
                                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                                  ::std::function<void(bool)> sent = nullptr,
                                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::NodeSessionPrx::_iceI_waitForApplicationUpdate, application, revision, context);
    }

    /// \cond INTERNAL
    void _iceI_waitForApplicationUpdate(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, int, const ::Ice::Context&);
    /// \endcond

    /**
     * Destroy the session.
     * @param context The Context map to send with the invocation.
     */
    void destroy(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &NodeSessionPrx::_iceI_destroy, context).get();
    }

    /**
     * Destroy the session.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    template<template<typename> class P = ::std::promise>
    auto destroyAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &NodeSessionPrx::_iceI_destroy, context);
    }

    /**
     * Destroy the session.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    destroyAsync(::std::function<void()> response,
                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                 ::std::function<void(bool)> sent = nullptr,
                 const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::NodeSessionPrx::_iceI_destroy, context);
    }

    /// \cond INTERNAL
    void _iceI_destroy(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    explicit NodeSessionPrx(const ::Ice::ObjectPrx& other) : ::Ice::ObjectPrx(other)
    {
    }

    /// \cond INTERNAL
    NodeSessionPrx(const ::IceInternal::ReferencePtr& ref) : ::Ice::ObjectPrx(ref)
    {
    }
    /// \endcond

protected:

    /// \cond INTERNAL
    NodeSessionPrx() = default;
    /// \endcond
};

class DatabaseObserverPrx : public ::Ice::Proxy<DatabaseObserverPrx, ApplicationObserverPrx, ObjectObserverPrx, AdapterObserverPrx>
{
public:

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    explicit DatabaseObserverPrx(const ::Ice::ObjectPrx& other) : ::Ice::ObjectPrx(other)
    {
    }

    /// \cond INTERNAL
    DatabaseObserverPrx(const ::IceInternal::ReferencePtr& ref) : ::Ice::ObjectPrx(ref)
    {
    }
    /// \endcond

protected:

    /// \cond INTERNAL
    DatabaseObserverPrx() = default;
    /// \endcond
};

class ReplicaSessionPrx : public ::Ice::Proxy<ReplicaSessionPrx, ::Ice::ObjectPrx>
{
public:

    /**
     * The replica call this method to keep the session alive.
     * @param context The Context map to send with the invocation.
     */
    void keepAlive(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &ReplicaSessionPrx::_iceI_keepAlive, context).get();
    }

    /**
     * The replica call this method to keep the session alive.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    template<template<typename> class P = ::std::promise>
    auto keepAliveAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &ReplicaSessionPrx::_iceI_keepAlive, context);
    }

    /**
     * The replica call this method to keep the session alive.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    keepAliveAsync(::std::function<void()> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::ReplicaSessionPrx::_iceI_keepAlive, context);
    }

    /// \cond INTERNAL
    void _iceI_keepAlive(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    /**
     * Return the replica session timeout.
     * @param context The Context map to send with the invocation.
     */
    int getTimeout(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<int>(true, this, &ReplicaSessionPrx::_iceI_getTimeout, context).get();
    }

    /**
     * Return the replica session timeout.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    template<template<typename> class P = ::std::promise>
    auto getTimeoutAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<int>>().get_future())
    {
        return _makePromiseOutgoing<int, P>(false, this, &ReplicaSessionPrx::_iceI_getTimeout, context);
    }

    /**
     * Return the replica session timeout.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    getTimeoutAsync(::std::function<void(int)> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<int>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::ReplicaSessionPrx::_iceI_getTimeout, context);
    }

    /// \cond INTERNAL
    void _iceI_getTimeout(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<int>>&, const ::Ice::Context&);
    /// \endcond

    /**
     * Set the database observer. Once the observer is subscribed, it will receive the database and database updates.
     * @param context The Context map to send with the invocation.
     */
    void setDatabaseObserver(const ::std::shared_ptr<DatabaseObserverPrx>& dbObs, const std::optional<StringLongDict>& serials, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &ReplicaSessionPrx::_iceI_setDatabaseObserver, dbObs, serials, context).get();
    }

    /**
     * Set the database observer. Once the observer is subscribed, it will receive the database and database updates.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    template<template<typename> class P = ::std::promise>
    auto setDatabaseObserverAsync(const ::std::shared_ptr<DatabaseObserverPrx>& dbObs, const std::optional<StringLongDict>& serials, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &ReplicaSessionPrx::_iceI_setDatabaseObserver, dbObs, serials, context);
    }

    /**
     * Set the database observer. Once the observer is subscribed, it will receive the database and database updates.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    setDatabaseObserverAsync(const ::std::shared_ptr<DatabaseObserverPrx>& dbObs, const std::optional<StringLongDict>& serials,
                             ::std::function<void()> response,
                             ::std::function<void(::std::exception_ptr)> ex = nullptr,
                             ::std::function<void(bool)> sent = nullptr,
                             const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::ReplicaSessionPrx::_iceI_setDatabaseObserver, dbObs, serials, context);
    }

    /// \cond INTERNAL
    void _iceI_setDatabaseObserver(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::shared_ptr<DatabaseObserverPrx>&, const std::optional<StringLongDict>&, const ::Ice::Context&);
    /// \endcond

    /**
     * This method sets the endpoints of the replica. This allows the master to create proxies with multiple endpoints
     * for replicated objects (e.g.: IceGrid::Query object).
     * @param context The Context map to send with the invocation.
     */
    void setEndpoints(const StringObjectProxyDict& endpoints, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &ReplicaSessionPrx::_iceI_setEndpoints, endpoints, context).get();
    }

    /**
     * This method sets the endpoints of the replica. This allows the master to create proxies with multiple endpoints
     * for replicated objects (e.g.: IceGrid::Query object).
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    template<template<typename> class P = ::std::promise>
    auto setEndpointsAsync(const StringObjectProxyDict& endpoints, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &ReplicaSessionPrx::_iceI_setEndpoints, endpoints, context);
    }

    /**
     * This method sets the endpoints of the replica. This allows the master to create proxies with multiple endpoints
     * for replicated objects (e.g.: IceGrid::Query object).
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    setEndpointsAsync(const StringObjectProxyDict& endpoints,
                      ::std::function<void()> response,
                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                      ::std::function<void(bool)> sent = nullptr,
                      const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::ReplicaSessionPrx::_iceI_setEndpoints, endpoints, context);
    }

    /// \cond INTERNAL
    void _iceI_setEndpoints(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const StringObjectProxyDict&, const ::Ice::Context&);
    /// \endcond

    /**
     * Registers the replica well-known objects with the master.
     * @param context The Context map to send with the invocation.
     */
    void registerWellKnownObjects(const ObjectInfoSeq& objects, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &ReplicaSessionPrx::_iceI_registerWellKnownObjects, objects, context).get();
    }

    /**
     * Registers the replica well-known objects with the master.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    template<template<typename> class P = ::std::promise>
    auto registerWellKnownObjectsAsync(const ObjectInfoSeq& objects, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &ReplicaSessionPrx::_iceI_registerWellKnownObjects, objects, context);
    }

    /**
     * Registers the replica well-known objects with the master.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    registerWellKnownObjectsAsync(const ObjectInfoSeq& objects,
                                  ::std::function<void()> response,
                                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                                  ::std::function<void(bool)> sent = nullptr,
                                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::ReplicaSessionPrx::_iceI_registerWellKnownObjects, objects, context);
    }

    /// \cond INTERNAL
    void _iceI_registerWellKnownObjects(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ObjectInfoSeq&, const ::Ice::Context&);
    /// \endcond

    /**
     * Set the adapter direct proxy of the given adapter in the master. This is used to support dynamic registration
     * with the locator registry interface.
     * @param context The Context map to send with the invocation.
     */
    void setAdapterDirectProxy(const ::std::string& adapterId, const ::std::string& replicaGroupId, const ::std::shared_ptr<::Ice::ObjectPrx>& proxy, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &ReplicaSessionPrx::_iceI_setAdapterDirectProxy, adapterId, replicaGroupId, proxy, context).get();
    }

    /**
     * Set the adapter direct proxy of the given adapter in the master. This is used to support dynamic registration
     * with the locator registry interface.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    template<template<typename> class P = ::std::promise>
    auto setAdapterDirectProxyAsync(const ::std::string& adapterId, const ::std::string& replicaGroupId, const ::std::shared_ptr<::Ice::ObjectPrx>& proxy, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &ReplicaSessionPrx::_iceI_setAdapterDirectProxy, adapterId, replicaGroupId, proxy, context);
    }

    /**
     * Set the adapter direct proxy of the given adapter in the master. This is used to support dynamic registration
     * with the locator registry interface.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    setAdapterDirectProxyAsync(const ::std::string& adapterId, const ::std::string& replicaGroupId, const ::std::shared_ptr<::Ice::ObjectPrx>& proxy,
                               ::std::function<void()> response,
                               ::std::function<void(::std::exception_ptr)> ex = nullptr,
                               ::std::function<void(bool)> sent = nullptr,
                               const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::ReplicaSessionPrx::_iceI_setAdapterDirectProxy, adapterId, replicaGroupId, proxy, context);
    }

    /// \cond INTERNAL
    void _iceI_setAdapterDirectProxy(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, const ::std::string&, const ::std::shared_ptr<::Ice::ObjectPrx>&, const ::Ice::Context&);
    /// \endcond

    /**
     * Notify the master that an update was received. The master might wait for replication updates to be received by
     * all the replicas before to continue.
     * @param context The Context map to send with the invocation.
     */
    void receivedUpdate(TopicName name, int serial, const ::std::string& failure, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &ReplicaSessionPrx::_iceI_receivedUpdate, name, serial, failure, context).get();
    }

    /**
     * Notify the master that an update was received. The master might wait for replication updates to be received by
     * all the replicas before to continue.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    template<template<typename> class P = ::std::promise>
    auto receivedUpdateAsync(TopicName name, int serial, const ::std::string& failure, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &ReplicaSessionPrx::_iceI_receivedUpdate, name, serial, failure, context);
    }

    /**
     * Notify the master that an update was received. The master might wait for replication updates to be received by
     * all the replicas before to continue.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    receivedUpdateAsync(TopicName name, int serial, const ::std::string& failure,
                        ::std::function<void()> response,
                        ::std::function<void(::std::exception_ptr)> ex = nullptr,
                        ::std::function<void(bool)> sent = nullptr,
                        const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::ReplicaSessionPrx::_iceI_receivedUpdate, name, serial, failure, context);
    }

    /// \cond INTERNAL
    void _iceI_receivedUpdate(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, TopicName, int, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    /**
     * Destroy the session.
     * @param context The Context map to send with the invocation.
     */
    void destroy(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &ReplicaSessionPrx::_iceI_destroy, context).get();
    }

    /**
     * Destroy the session.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    template<template<typename> class P = ::std::promise>
    auto destroyAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &ReplicaSessionPrx::_iceI_destroy, context);
    }

    /**
     * Destroy the session.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    destroyAsync(::std::function<void()> response,
                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                 ::std::function<void(bool)> sent = nullptr,
                 const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::ReplicaSessionPrx::_iceI_destroy, context);
    }

    /// \cond INTERNAL
    void _iceI_destroy(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    explicit ReplicaSessionPrx(const ::Ice::ObjectPrx& other) : ::Ice::ObjectPrx(other)
    {
    }

    /// \cond INTERNAL
    ReplicaSessionPrx(const ::IceInternal::ReferencePtr& ref) : ::Ice::ObjectPrx(ref)
    {
    }
    /// \endcond

protected:

    /// \cond INTERNAL
    ReplicaSessionPrx() = default;
    /// \endcond
};

class InternalRegistryPrx : public ::Ice::Proxy<InternalRegistryPrx, FileReaderPrx>
{
public:

    /**
     * Register a node with the registry. If a node with the same name is already registered, [registerNode] will
     * overide the previous node only if it's not active.
     * @param info Some information on the node.
     * @param prx The proxy of the node.
     * @param loadInf The load information of the node.
     * @param context The Context map to send with the invocation.
     * @return The node session proxy.
     * @throws IceGrid::NodeActiveException Raised if the node is already registered and currently active.
     */
    ::std::shared_ptr<NodeSessionPrx> registerNode(const ::std::shared_ptr<InternalNodeInfo>& info, const ::std::shared_ptr<NodePrx>& prx, const LoadInfo& loadInf, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::std::shared_ptr<::IceGrid::NodeSessionPrx>>(true, this, &InternalRegistryPrx::_iceI_registerNode, info, prx, loadInf, context).get();
    }

    /**
     * Register a node with the registry. If a node with the same name is already registered, [registerNode] will
     * overide the previous node only if it's not active.
     * @param info Some information on the node.
     * @param prx The proxy of the node.
     * @param loadInf The load information of the node.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    template<template<typename> class P = ::std::promise>
    auto registerNodeAsync(const ::std::shared_ptr<InternalNodeInfo>& info, const ::std::shared_ptr<NodePrx>& prx, const LoadInfo& loadInf, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::shared_ptr<::IceGrid::NodeSessionPrx>>>().get_future())
    {
        return _makePromiseOutgoing<::std::shared_ptr<::IceGrid::NodeSessionPrx>, P>(false, this, &InternalRegistryPrx::_iceI_registerNode, info, prx, loadInf, context);
    }

    /**
     * Register a node with the registry. If a node with the same name is already registered, [registerNode] will
     * overide the previous node only if it's not active.
     * @param info Some information on the node.
     * @param prx The proxy of the node.
     * @param loadInf The load information of the node.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    registerNodeAsync(const ::std::shared_ptr<InternalNodeInfo>& info, const ::std::shared_ptr<NodePrx>& prx, const LoadInfo& loadInf,
                      ::std::function<void(::std::shared_ptr<::IceGrid::NodeSessionPrx>)> response,
                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                      ::std::function<void(bool)> sent = nullptr,
                      const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<::std::shared_ptr<::IceGrid::NodeSessionPrx>>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::InternalRegistryPrx::_iceI_registerNode, info, prx, loadInf, context);
    }

    /// \cond INTERNAL
    void _iceI_registerNode(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::IceGrid::NodeSessionPrx>>>&, const ::std::shared_ptr<InternalNodeInfo>&, const ::std::shared_ptr<NodePrx>&, const LoadInfo&, const ::Ice::Context&);
    /// \endcond

    /**
     * Register a replica with the registry. If a replica with the  same name is already registered, [registerReplica]
     * will overide the previous replica only if it's not active.
     * @param info Some information on the replica.
     * @param prx The proxy of the replica.
     * @param context The Context map to send with the invocation.
     * @return The replica session proxy.
     * @throws IceGrid::ReplicaActiveException Raised if the replica is already registered and currently active.
     */
    ::std::shared_ptr<ReplicaSessionPrx> registerReplica(const ::std::shared_ptr<InternalReplicaInfo>& info, const ::std::shared_ptr<InternalRegistryPrx>& prx, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::std::shared_ptr<::IceGrid::ReplicaSessionPrx>>(true, this, &InternalRegistryPrx::_iceI_registerReplica, info, prx, context).get();
    }

    /**
     * Register a replica with the registry. If a replica with the  same name is already registered, [registerReplica]
     * will overide the previous replica only if it's not active.
     * @param info Some information on the replica.
     * @param prx The proxy of the replica.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    template<template<typename> class P = ::std::promise>
    auto registerReplicaAsync(const ::std::shared_ptr<InternalReplicaInfo>& info, const ::std::shared_ptr<InternalRegistryPrx>& prx, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::shared_ptr<::IceGrid::ReplicaSessionPrx>>>().get_future())
    {
        return _makePromiseOutgoing<::std::shared_ptr<::IceGrid::ReplicaSessionPrx>, P>(false, this, &InternalRegistryPrx::_iceI_registerReplica, info, prx, context);
    }

    /**
     * Register a replica with the registry. If a replica with the  same name is already registered, [registerReplica]
     * will overide the previous replica only if it's not active.
     * @param info Some information on the replica.
     * @param prx The proxy of the replica.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    registerReplicaAsync(const ::std::shared_ptr<InternalReplicaInfo>& info, const ::std::shared_ptr<InternalRegistryPrx>& prx,
                         ::std::function<void(::std::shared_ptr<::IceGrid::ReplicaSessionPrx>)> response,
                         ::std::function<void(::std::exception_ptr)> ex = nullptr,
                         ::std::function<void(bool)> sent = nullptr,
                         const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<::std::shared_ptr<::IceGrid::ReplicaSessionPrx>>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::InternalRegistryPrx::_iceI_registerReplica, info, prx, context);
    }

    /// \cond INTERNAL
    void _iceI_registerReplica(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::IceGrid::ReplicaSessionPrx>>>&, const ::std::shared_ptr<InternalReplicaInfo>&, const ::std::shared_ptr<InternalRegistryPrx>&, const ::Ice::Context&);
    /// \endcond

    /**
     * Create a session with the given registry replica. This method returns only once the session creation has been
     * attempted.
     * @param context The Context map to send with the invocation.
     */
    void registerWithReplica(const ::std::shared_ptr<InternalRegistryPrx>& prx, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &InternalRegistryPrx::_iceI_registerWithReplica, prx, context).get();
    }

    /**
     * Create a session with the given registry replica. This method returns only once the session creation has been
     * attempted.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    template<template<typename> class P = ::std::promise>
    auto registerWithReplicaAsync(const ::std::shared_ptr<InternalRegistryPrx>& prx, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &InternalRegistryPrx::_iceI_registerWithReplica, prx, context);
    }

    /**
     * Create a session with the given registry replica. This method returns only once the session creation has been
     * attempted.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    registerWithReplicaAsync(const ::std::shared_ptr<InternalRegistryPrx>& prx,
                             ::std::function<void()> response,
                             ::std::function<void(::std::exception_ptr)> ex = nullptr,
                             ::std::function<void(bool)> sent = nullptr,
                             const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::InternalRegistryPrx::_iceI_registerWithReplica, prx, context);
    }

    /// \cond INTERNAL
    void _iceI_registerWithReplica(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::shared_ptr<InternalRegistryPrx>&, const ::Ice::Context&);
    /// \endcond

    /**
     * Return the proxies of all the nodes known by this registry.
     * @param context The Context map to send with the invocation.
     */
    NodePrxSeq getNodes(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::IceGrid::NodePrxSeq>(true, this, &InternalRegistryPrx::_iceI_getNodes, context).get();
    }

    /**
     * Return the proxies of all the nodes known by this registry.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    template<template<typename> class P = ::std::promise>
    auto getNodesAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::IceGrid::NodePrxSeq>>().get_future())
    {
        return _makePromiseOutgoing<::IceGrid::NodePrxSeq, P>(false, this, &InternalRegistryPrx::_iceI_getNodes, context);
    }

    /**
     * Return the proxies of all the nodes known by this registry.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    getNodesAsync(::std::function<void(::IceGrid::NodePrxSeq)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<::IceGrid::NodePrxSeq>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::InternalRegistryPrx::_iceI_getNodes, context);
    }

    /// \cond INTERNAL
    void _iceI_getNodes(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::IceGrid::NodePrxSeq>>&, const ::Ice::Context&);
    /// \endcond

    /**
     * Return the proxies of all the registry replicas known by this registry.
     * @param context The Context map to send with the invocation.
     */
    InternalRegistryPrxSeq getReplicas(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::IceGrid::InternalRegistryPrxSeq>(true, this, &InternalRegistryPrx::_iceI_getReplicas, context).get();
    }

    /**
     * Return the proxies of all the registry replicas known by this registry.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    template<template<typename> class P = ::std::promise>
    auto getReplicasAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::IceGrid::InternalRegistryPrxSeq>>().get_future())
    {
        return _makePromiseOutgoing<::IceGrid::InternalRegistryPrxSeq, P>(false, this, &InternalRegistryPrx::_iceI_getReplicas, context);
    }

    /**
     * Return the proxies of all the registry replicas known by this registry.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    getReplicasAsync(::std::function<void(::IceGrid::InternalRegistryPrxSeq)> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<::IceGrid::InternalRegistryPrxSeq>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::InternalRegistryPrx::_iceI_getReplicas, context);
    }

    /// \cond INTERNAL
    void _iceI_getReplicas(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::IceGrid::InternalRegistryPrxSeq>>&, const ::Ice::Context&);
    /// \endcond

    /**
     * Return applications, adapters, objects from this replica.
     * @param context The Context map to send with the invocation.
     */
    ApplicationInfoSeq getApplications(long long int& serial, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<InternalRegistry::GetApplicationsResult>(true, this, &InternalRegistryPrx::_iceI_getApplications, context).get();
        serial = _result.serial;
        return ::std::move(_result.returnValue);
    }

    /**
     * Return applications, adapters, objects from this replica.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    template<template<typename> class P = ::std::promise>
    auto getApplicationsAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<InternalRegistry::GetApplicationsResult>>().get_future())
    {
        return _makePromiseOutgoing<InternalRegistry::GetApplicationsResult, P>(false, this, &InternalRegistryPrx::_iceI_getApplications, context);
    }

    /**
     * Return applications, adapters, objects from this replica.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    getApplicationsAsync(::std::function<void(::IceGrid::ApplicationInfoSeq, long long int)> response,
                         ::std::function<void(::std::exception_ptr)> ex = nullptr,
                         ::std::function<void(bool)> sent = nullptr,
                         const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](InternalRegistry::GetApplicationsResult&& _result)
        {
            response(::std::move(_result.returnValue), _result.serial);
        };
        return _makeLambdaOutgoing<InternalRegistry::GetApplicationsResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &IceGrid::InternalRegistryPrx::_iceI_getApplications, context);
    }

    /// \cond INTERNAL
    void _iceI_getApplications(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<InternalRegistry::GetApplicationsResult>>&, const ::Ice::Context&);
    /// \endcond

    AdapterInfoSeq getAdapters(long long int& serial, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<InternalRegistry::GetAdaptersResult>(true, this, &InternalRegistryPrx::_iceI_getAdapters, context).get();
        serial = _result.serial;
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto getAdaptersAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<InternalRegistry::GetAdaptersResult>>().get_future())
    {
        return _makePromiseOutgoing<InternalRegistry::GetAdaptersResult, P>(false, this, &InternalRegistryPrx::_iceI_getAdapters, context);
    }

    ::std::function<void()>
    getAdaptersAsync(::std::function<void(::IceGrid::AdapterInfoSeq, long long int)> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](InternalRegistry::GetAdaptersResult&& _result)
        {
            response(::std::move(_result.returnValue), _result.serial);
        };
        return _makeLambdaOutgoing<InternalRegistry::GetAdaptersResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &IceGrid::InternalRegistryPrx::_iceI_getAdapters, context);
    }

    /// \cond INTERNAL
    void _iceI_getAdapters(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<InternalRegistry::GetAdaptersResult>>&, const ::Ice::Context&);
    /// \endcond

    ObjectInfoSeq getObjects(long long int& serial, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<InternalRegistry::GetObjectsResult>(true, this, &InternalRegistryPrx::_iceI_getObjects, context).get();
        serial = _result.serial;
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto getObjectsAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<InternalRegistry::GetObjectsResult>>().get_future())
    {
        return _makePromiseOutgoing<InternalRegistry::GetObjectsResult, P>(false, this, &InternalRegistryPrx::_iceI_getObjects, context);
    }

    ::std::function<void()>
    getObjectsAsync(::std::function<void(::IceGrid::ObjectInfoSeq, long long int)> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](InternalRegistry::GetObjectsResult&& _result)
        {
            response(::std::move(_result.returnValue), _result.serial);
        };
        return _makeLambdaOutgoing<InternalRegistry::GetObjectsResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &IceGrid::InternalRegistryPrx::_iceI_getObjects, context);
    }

    /// \cond INTERNAL
    void _iceI_getObjects(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<InternalRegistry::GetObjectsResult>>&, const ::Ice::Context&);
    /// \endcond

    /**
     * Shutdown this registry.
     * @param context The Context map to send with the invocation.
     */
    void shutdown(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &InternalRegistryPrx::_iceI_shutdown, context).get();
    }

    /**
     * Shutdown this registry.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    template<template<typename> class P = ::std::promise>
    auto shutdownAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &InternalRegistryPrx::_iceI_shutdown, context);
    }

    /**
     * Shutdown this registry.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    shutdownAsync(::std::function<void()> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::InternalRegistryPrx::_iceI_shutdown, context);
    }

    /// \cond INTERNAL
    void _iceI_shutdown(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    explicit InternalRegistryPrx(const ::Ice::ObjectPrx& other) : ::Ice::ObjectPrx(other)
    {
    }

    /// \cond INTERNAL
    InternalRegistryPrx(const ::IceInternal::ReferencePtr& ref) : ::Ice::ObjectPrx(ref)
    {
    }
    /// \endcond

protected:

    /// \cond INTERNAL
    InternalRegistryPrx() = default;
    /// \endcond
};

}

/// \cond STREAM
namespace Ice
{

template<typename S>
struct StreamReader<::IceGrid::InternalDbEnvDescriptor, S>
{
    static void read(S* istr, ::IceGrid::InternalDbEnvDescriptor& v)
    {
        istr->readAll(v.name, v.properties);
    }
};

template<typename S>
struct StreamReader<::IceGrid::InternalAdapterDescriptor, S>
{
    static void read(S* istr, ::IceGrid::InternalAdapterDescriptor& v)
    {
        istr->readAll(v.id, v.serverLifetime);
    }
};

template<typename S>
struct StreamReader<::IceGrid::InternalDistributionDescriptor, S>
{
    static void read(S* istr, ::IceGrid::InternalDistributionDescriptor& v)
    {
        istr->readAll(v.icepatch, v.directories);
    }
};

template<typename S>
struct StreamWriter<::IceGrid::InternalServerDescriptor, S>
{
    static void write(S* ostr, const ::IceGrid::InternalServerDescriptor& v)
    {
        ostr->writeAll(v.id, v.application, v.uuid, v.revision, v.sessionId, v.exe, v.pwd, v.user, v.activation, v.activationTimeout, v.deactivationTimeout, v.applicationDistrib, v.distrib, v.processRegistered, v.options, v.envs, v.logs, v.adapters, v.dbEnvs, v.properties);
        ostr->writeAll({1}, v.services);
    }
};

template<typename S>
struct StreamReader<::IceGrid::InternalServerDescriptor, S>
{
    static void read(S* istr, ::IceGrid::InternalServerDescriptor& v)
    {
        istr->readAll(v.id, v.application, v.uuid, v.revision, v.sessionId, v.exe, v.pwd, v.user, v.activation, v.activationTimeout, v.deactivationTimeout, v.applicationDistrib, v.distrib, v.processRegistered, v.options, v.envs, v.logs, v.adapters, v.dbEnvs, v.properties);
        istr->readAll({1}, v.services);
    }
};

template<typename S>
struct StreamReader<::IceGrid::AdapterNotActiveException, S>
{
    static void read(S* istr, ::IceGrid::AdapterNotActiveException& v)
    {
        istr->readAll(v.activatable);
    }
};

template<typename S>
struct StreamReader<::IceGrid::AdapterExistsException, S>
{
    static void read(S* istr, ::IceGrid::AdapterExistsException& v)
    {
        istr->readAll(v.id);
    }
};

template<>
struct StreamableTraits< ::IceGrid::TopicName>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 4;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::IceGrid::InternalNodeInfo, S>
{
    static void read(S* istr, ::IceGrid::InternalNodeInfo& v)
    {
        istr->readAll(v.name, v.os, v.hostname, v.release, v.version, v.machine, v.nProcessors, v.dataDir);
    }
};

template<typename S>
struct StreamReader<::IceGrid::InternalReplicaInfo, S>
{
    static void read(S* istr, ::IceGrid::InternalReplicaInfo& v)
    {
        istr->readAll(v.name, v.hostname);
    }
};

}
/// \endcond

/// \cond INTERNAL
namespace IceGrid
{

using InternalDbEnvDescriptorPtr = ::std::shared_ptr<InternalDbEnvDescriptor>;

using InternalAdapterDescriptorPtr = ::std::shared_ptr<InternalAdapterDescriptor>;

using InternalDistributionDescriptorPtr = ::std::shared_ptr<InternalDistributionDescriptor>;

using InternalServerDescriptorPtr = ::std::shared_ptr<InternalServerDescriptor>;

using AdapterPtr = ::std::shared_ptr<Adapter>;
using AdapterPrxPtr = ::std::shared_ptr<AdapterPrx>;

using FileReaderPtr = ::std::shared_ptr<FileReader>;
using FileReaderPrxPtr = ::std::shared_ptr<FileReaderPrx>;

using ServerPtr = ::std::shared_ptr<Server>;
using ServerPrxPtr = ::std::shared_ptr<ServerPrx>;

using InternalRegistryPtr = ::std::shared_ptr<InternalRegistry>;
using InternalRegistryPrxPtr = ::std::shared_ptr<InternalRegistryPrx>;

using ReplicaObserverPtr = ::std::shared_ptr<ReplicaObserver>;
using ReplicaObserverPrxPtr = ::std::shared_ptr<ReplicaObserverPrx>;

using PatcherFeedbackPtr = ::std::shared_ptr<PatcherFeedback>;
using PatcherFeedbackPrxPtr = ::std::shared_ptr<PatcherFeedbackPrx>;

using NodePtr = ::std::shared_ptr<Node>;
using NodePrxPtr = ::std::shared_ptr<NodePrx>;

using NodeSessionPtr = ::std::shared_ptr<NodeSession>;
using NodeSessionPrxPtr = ::std::shared_ptr<NodeSessionPrx>;

using DatabaseObserverPtr = ::std::shared_ptr<DatabaseObserver>;
using DatabaseObserverPrxPtr = ::std::shared_ptr<DatabaseObserverPrx>;

using ReplicaSessionPtr = ::std::shared_ptr<ReplicaSession>;
using ReplicaSessionPrxPtr = ::std::shared_ptr<ReplicaSessionPrx>;

using InternalNodeInfoPtr = ::std::shared_ptr<InternalNodeInfo>;

using InternalReplicaInfoPtr = ::std::shared_ptr<InternalReplicaInfo>;

}
/// \endcond

#include <IceUtil/PopDisableWarnings.h>
#endif
