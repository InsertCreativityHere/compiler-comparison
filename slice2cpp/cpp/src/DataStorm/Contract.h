//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.8.0-alpha.0
//
// <auto-generated>
//
// Generated from file `Contract.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __Contract_h__
#define __Contract_h__

#include <Ice/PushDisableWarnings.h>
#include <Ice/Ice.h>
#include <Ice/Identity.h>
#include <Ice/BuiltinSequences.h>
#include <DataStorm/Sample.h>
#include <deque>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION  != 30850
#       error Ice version mismatch: an exact match is required for beta generated code
#   endif
#endif

namespace DataStormContract
{
    enum class ClearHistoryPolicy : ::std::uint8_t
    {
        OnAdd,
        OnRemove,
        OnAll,
        OnAllExceptPartialUpdate,
        Never
    };

    using LongLongDict = ::std::map<::std::int64_t, ::std::int64_t>;

    struct DataSample;

    using DataSampleSeq = std::deque<DataSample>;

    struct DataSamples;

    using DataSamplesSeq = ::std::vector<DataSamples>;

    struct ElementInfo;

    using ElementInfoSeq = ::std::vector<ElementInfo>;

    struct TopicInfo;

    using TopicInfoSeq = ::std::vector<TopicInfo>;

    struct TopicSpec;

    struct FilterInfo;

    class ElementConfig;
    using ElementConfigPtr = ::std::shared_ptr<ElementConfig>;

    struct ElementData;

    using ElementDataSeq = ::std::vector<ElementData>;

    struct ElementSpec;

    using ElementSpecSeq = ::std::vector<ElementSpec>;

    struct ElementDataAck;

    using ElementDataAckSeq = ::std::vector<ElementDataAck>;

    struct ElementSpecAck;

    using ElementSpecAckSeq = ::std::vector<ElementSpecAck>;

    class SessionPrx;

    class PublisherSessionPrx;

    class SubscriberSessionPrx;

    class NodePrx;

    class LookupPrx;

}

namespace DataStormContract
{

class SessionPrx : public ::Ice::Proxy<SessionPrx, ::Ice::ObjectPrx>
{
public:

    void announceTopics(const TopicInfoSeq& topics, bool initialize, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    [[nodiscard]] ::std::future<void> announceTopicsAsync(const TopicInfoSeq& topics, bool initialize, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    announceTopicsAsync(const TopicInfoSeq& topics, bool initialize, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_announceTopics(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const TopicInfoSeq&, bool, const ::Ice::Context&) const;
    /// \endcond

    void attachTopic(const TopicSpec& topic, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    [[nodiscard]] ::std::future<void> attachTopicAsync(const TopicSpec& topic, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    attachTopicAsync(const TopicSpec& topic, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_attachTopic(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const TopicSpec&, const ::Ice::Context&) const;
    /// \endcond

    void detachTopic(::std::int64_t topic, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    [[nodiscard]] ::std::future<void> detachTopicAsync(::std::int64_t topic, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    detachTopicAsync(::std::int64_t topic, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_detachTopic(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, ::std::int64_t, const ::Ice::Context&) const;
    /// \endcond

    void attachTags(::std::int64_t topic, const ElementInfoSeq& tags, bool initialize, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    [[nodiscard]] ::std::future<void> attachTagsAsync(::std::int64_t topic, const ElementInfoSeq& tags, bool initialize, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    attachTagsAsync(::std::int64_t topic, const ElementInfoSeq& tags, bool initialize, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_attachTags(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, ::std::int64_t, const ElementInfoSeq&, bool, const ::Ice::Context&) const;
    /// \endcond

    void detachTags(::std::int64_t topic, const ::Ice::LongSeq& tags, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    [[nodiscard]] ::std::future<void> detachTagsAsync(::std::int64_t topic, const ::Ice::LongSeq& tags, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    detachTagsAsync(::std::int64_t topic, const ::Ice::LongSeq& tags, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_detachTags(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, ::std::int64_t, const ::Ice::LongSeq&, const ::Ice::Context&) const;
    /// \endcond

    void announceElements(::std::int64_t topic, const ElementInfoSeq& keys, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    [[nodiscard]] ::std::future<void> announceElementsAsync(::std::int64_t topic, const ElementInfoSeq& keys, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    announceElementsAsync(::std::int64_t topic, const ElementInfoSeq& keys, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_announceElements(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, ::std::int64_t, const ElementInfoSeq&, const ::Ice::Context&) const;
    /// \endcond

    void attachElements(::std::int64_t topic, const ElementSpecSeq& elements, bool initialize, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    [[nodiscard]] ::std::future<void> attachElementsAsync(::std::int64_t topic, const ElementSpecSeq& elements, bool initialize, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    attachElementsAsync(::std::int64_t topic, const ElementSpecSeq& elements, bool initialize, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_attachElements(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, ::std::int64_t, const ElementSpecSeq&, bool, const ::Ice::Context&) const;
    /// \endcond

    void attachElementsAck(::std::int64_t topic, const ElementSpecAckSeq& elements, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    [[nodiscard]] ::std::future<void> attachElementsAckAsync(::std::int64_t topic, const ElementSpecAckSeq& elements, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    attachElementsAckAsync(::std::int64_t topic, const ElementSpecAckSeq& elements, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_attachElementsAck(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, ::std::int64_t, const ElementSpecAckSeq&, const ::Ice::Context&) const;
    /// \endcond

    void detachElements(::std::int64_t topic, const ::Ice::LongSeq& keys, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    [[nodiscard]] ::std::future<void> detachElementsAsync(::std::int64_t topic, const ::Ice::LongSeq& keys, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    detachElementsAsync(::std::int64_t topic, const ::Ice::LongSeq& keys, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_detachElements(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, ::std::int64_t, const ::Ice::LongSeq&, const ::Ice::Context&) const;
    /// \endcond

    void initSamples(::std::int64_t topic, const DataSamplesSeq& samples, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    [[nodiscard]] ::std::future<void> initSamplesAsync(::std::int64_t topic, const DataSamplesSeq& samples, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    initSamplesAsync(::std::int64_t topic, const DataSamplesSeq& samples, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_initSamples(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, ::std::int64_t, const DataSamplesSeq&, const ::Ice::Context&) const;
    /// \endcond

    void disconnected(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    [[nodiscard]] ::std::future<void> disconnectedAsync(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    disconnectedAsync(::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_disconnected(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&) const;
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const char* ice_staticId() noexcept;
    SessionPrx(const SessionPrx& other) noexcept : ::Ice::ObjectPrx(other)
    {
    }

    SessionPrx(SessionPrx&& other) noexcept : ::Ice::ObjectPrx(::std::move(other))
    {
    }

    SessionPrx(const ::Ice::CommunicatorPtr& communicator, std::string_view proxyString) :
        ::Ice::ObjectPrx(communicator, proxyString)
    {
    }

    SessionPrx& operator=(const SessionPrx& rhs) noexcept
    {
        ::Ice::ObjectPrx::operator=(rhs);
        return *this;
    }

    SessionPrx& operator=(SessionPrx&& rhs) noexcept
    {
        ::Ice::ObjectPrx::operator=(::std::move(rhs));
        return *this;
    }

    /// \cond INTERNAL
    static SessionPrx _fromReference(::IceInternal::ReferencePtr ref) { return SessionPrx(::std::move(ref)); }

protected:

    SessionPrx() = default;

    explicit SessionPrx(::IceInternal::ReferencePtr&& ref) : ::Ice::ObjectPrx(::std::move(ref))
    {
    }
    /// \endcond
};

class PublisherSessionPrx : public ::Ice::Proxy<PublisherSessionPrx, SessionPrx>
{
public:

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const char* ice_staticId() noexcept;

#if defined(__GNUC__)
#   pragma GCC diagnostic push
#   pragma GCC diagnostic ignored "-Wextra" // initialize all virtual bases in correct order
#endif
    PublisherSessionPrx(const PublisherSessionPrx& other) noexcept : ::Ice::ObjectPrx(other)
    {
    }

    PublisherSessionPrx(PublisherSessionPrx&& other) noexcept : ::Ice::ObjectPrx(::std::move(other))
    {
    }

    PublisherSessionPrx(const ::Ice::CommunicatorPtr& communicator, std::string_view proxyString) :
        ::Ice::ObjectPrx(communicator, proxyString)
    {
    }

    PublisherSessionPrx& operator=(const PublisherSessionPrx& rhs) noexcept
    {
        ::Ice::ObjectPrx::operator=(rhs);
        return *this;
    }

    PublisherSessionPrx& operator=(PublisherSessionPrx&& rhs) noexcept
    {
        ::Ice::ObjectPrx::operator=(::std::move(rhs));
        return *this;
    }

    /// \cond INTERNAL
    static PublisherSessionPrx _fromReference(::IceInternal::ReferencePtr ref) { return PublisherSessionPrx(::std::move(ref)); }

protected:

    PublisherSessionPrx() = default;

    explicit PublisherSessionPrx(::IceInternal::ReferencePtr&& ref) : ::Ice::ObjectPrx(::std::move(ref))
    {
    }
    /// \endcond

#if defined(__GNUC__)
#   pragma GCC diagnostic pop
#endif
};

class SubscriberSessionPrx : public ::Ice::Proxy<SubscriberSessionPrx, SessionPrx>
{
public:

    void s(::std::int64_t topicId, ::std::int64_t elementId, const DataSample& sample, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    [[nodiscard]] ::std::future<void> sAsync(::std::int64_t topicId, ::std::int64_t elementId, const DataSample& sample, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    sAsync(::std::int64_t topicId, ::std::int64_t elementId, const DataSample& sample, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_s(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, ::std::int64_t, ::std::int64_t, const DataSample&, const ::Ice::Context&) const;
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const char* ice_staticId() noexcept;

#if defined(__GNUC__)
#   pragma GCC diagnostic push
#   pragma GCC diagnostic ignored "-Wextra" // initialize all virtual bases in correct order
#endif
    SubscriberSessionPrx(const SubscriberSessionPrx& other) noexcept : ::Ice::ObjectPrx(other)
    {
    }

    SubscriberSessionPrx(SubscriberSessionPrx&& other) noexcept : ::Ice::ObjectPrx(::std::move(other))
    {
    }

    SubscriberSessionPrx(const ::Ice::CommunicatorPtr& communicator, std::string_view proxyString) :
        ::Ice::ObjectPrx(communicator, proxyString)
    {
    }

    SubscriberSessionPrx& operator=(const SubscriberSessionPrx& rhs) noexcept
    {
        ::Ice::ObjectPrx::operator=(rhs);
        return *this;
    }

    SubscriberSessionPrx& operator=(SubscriberSessionPrx&& rhs) noexcept
    {
        ::Ice::ObjectPrx::operator=(::std::move(rhs));
        return *this;
    }

    /// \cond INTERNAL
    static SubscriberSessionPrx _fromReference(::IceInternal::ReferencePtr ref) { return SubscriberSessionPrx(::std::move(ref)); }

protected:

    SubscriberSessionPrx() = default;

    explicit SubscriberSessionPrx(::IceInternal::ReferencePtr&& ref) : ::Ice::ObjectPrx(::std::move(ref))
    {
    }
    /// \endcond

#if defined(__GNUC__)
#   pragma GCC diagnostic pop
#endif
};

/**
 * The Node interface allows DataStorm nodes to create publisher and subscriber sessions with each other.
 *
 * When a node has a writer for a topic that another node is reading, the node initiates the creation of a
 * publisher session. Likewise, when a node has a reader for a topic that another node is writing, the node
 * initiates the creation of a subscriber session.
 *
 * The publisher node hosts the publisher session servant, which is accessed by the subscriber node through a
 * PublisherSession proxy. The subscriber node hosts the subscriber session servant, which is accessed by the
 * publisher node through a SubscriberSession proxy.
 */
class NodePrx : public ::Ice::Proxy<NodePrx, ::Ice::ObjectPrx>
{
public:

    /**
     * Initiate the creation of a publisher session with a node, after
     * the target node has announced a topic reader for which this node has a corresponding topic writer.
     * @param publisher The publisher node initiating the session. The proxy is never null.
     * @param context The Context map to send with the invocation.
     * @see Lookup::announceTopicReader
     */
    void initiateCreateSession(const ::std::optional<NodePrx>& publisher, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Initiate the creation of a publisher session with a node, after
     * the target node has announced a topic reader for which this node has a corresponding topic writer.
     * @param publisher The publisher node initiating the session. The proxy is never null.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     * @see Lookup::announceTopicReader
     */
    [[nodiscard]] ::std::future<void> initiateCreateSessionAsync(const ::std::optional<NodePrx>& publisher, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Initiate the creation of a publisher session with a node, after
     * the target node has announced a topic reader for which this node has a corresponding topic writer.
     * @param publisher The publisher node initiating the session. The proxy is never null.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     * @see Lookup::announceTopicReader
     */
    ::std::function<void()>
    initiateCreateSessionAsync(const ::std::optional<NodePrx>& publisher, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_initiateCreateSession(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::optional<NodePrx>&, const ::Ice::Context&) const;
    /// \endcond

    /**
     * Initiate the creation of a subscriber session with a node, after
     * the target node has announced a topic writer for which this node has a corresponding topic reader,
     * or after the node has called Node::initiateCreateSession.
     * @param subscriber The subscriber node initiating the session. The proxy is never null.
     * @param session The subscriber session being created. The proxy is never null.
     * @param fromRelay Indicates if the session is being created from a relay node.
     * @param context The Context map to send with the invocation.
     */
    void createSession(const ::std::optional<NodePrx>& subscriber, const ::std::optional<SubscriberSessionPrx>& session, bool fromRelay, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Initiate the creation of a subscriber session with a node, after
     * the target node has announced a topic writer for which this node has a corresponding topic reader,
     * or after the node has called Node::initiateCreateSession.
     * @param subscriber The subscriber node initiating the session. The proxy is never null.
     * @param session The subscriber session being created. The proxy is never null.
     * @param fromRelay Indicates if the session is being created from a relay node.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    [[nodiscard]] ::std::future<void> createSessionAsync(const ::std::optional<NodePrx>& subscriber, const ::std::optional<SubscriberSessionPrx>& session, bool fromRelay, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Initiate the creation of a subscriber session with a node, after
     * the target node has announced a topic writer for which this node has a corresponding topic reader,
     * or after the node has called Node::initiateCreateSession.
     * @param subscriber The subscriber node initiating the session. The proxy is never null.
     * @param session The subscriber session being created. The proxy is never null.
     * @param fromRelay Indicates if the session is being created from a relay node.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    createSessionAsync(const ::std::optional<NodePrx>& subscriber, const ::std::optional<SubscriberSessionPrx>& session, bool fromRelay, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_createSession(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::optional<NodePrx>&, const ::std::optional<SubscriberSessionPrx>&, bool, const ::Ice::Context&) const;
    /// \endcond

    /**
     * Confirm the creation of a publisher session with a node.
     * @param publisher The publisher node confirming the session. The proxy is never null.
     * @param session The publisher session being confirmed. The proxy is never null.
     * @param context The Context map to send with the invocation.
     */
    void confirmCreateSession(const ::std::optional<NodePrx>& publisher, const ::std::optional<PublisherSessionPrx>& session, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Confirm the creation of a publisher session with a node.
     * @param publisher The publisher node confirming the session. The proxy is never null.
     * @param session The publisher session being confirmed. The proxy is never null.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    [[nodiscard]] ::std::future<void> confirmCreateSessionAsync(const ::std::optional<NodePrx>& publisher, const ::std::optional<PublisherSessionPrx>& session, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Confirm the creation of a publisher session with a node.
     * @param publisher The publisher node confirming the session. The proxy is never null.
     * @param session The publisher session being confirmed. The proxy is never null.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    confirmCreateSessionAsync(const ::std::optional<NodePrx>& publisher, const ::std::optional<PublisherSessionPrx>& session, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_confirmCreateSession(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::optional<NodePrx>&, const ::std::optional<PublisherSessionPrx>&, const ::Ice::Context&) const;
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const char* ice_staticId() noexcept;
    NodePrx(const NodePrx& other) noexcept : ::Ice::ObjectPrx(other)
    {
    }

    NodePrx(NodePrx&& other) noexcept : ::Ice::ObjectPrx(::std::move(other))
    {
    }

    NodePrx(const ::Ice::CommunicatorPtr& communicator, std::string_view proxyString) :
        ::Ice::ObjectPrx(communicator, proxyString)
    {
    }

    NodePrx& operator=(const NodePrx& rhs) noexcept
    {
        ::Ice::ObjectPrx::operator=(rhs);
        return *this;
    }

    NodePrx& operator=(NodePrx&& rhs) noexcept
    {
        ::Ice::ObjectPrx::operator=(::std::move(rhs));
        return *this;
    }

    /// \cond INTERNAL
    static NodePrx _fromReference(::IceInternal::ReferencePtr ref) { return NodePrx(::std::move(ref)); }

protected:

    NodePrx() = default;

    explicit NodePrx(::IceInternal::ReferencePtr&& ref) : ::Ice::ObjectPrx(::std::move(ref))
    {
    }
    /// \endcond
};

/**
 * The lookup interface is used by DataStorm nodes to announce their topic readers and writers to other connected
 * nodes. When multicast is enabled, the lookup interface also broadcasts these announcements.
 * Each DataStorm node hosts a lookup servant with the identity "DataStorm/Lookup".
 */
class LookupPrx : public ::Ice::Proxy<LookupPrx, ::Ice::ObjectPrx>
{
public:

    /**
     * Announce a topic reader.
     * @param topic The name of the topic.
     * @param node The node reading the topic. The proxy is never null.
     * @param context The Context map to send with the invocation.
     */
    void announceTopicReader(::std::string_view topic, const ::std::optional<NodePrx>& node, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Announce a topic reader.
     * @param topic The name of the topic.
     * @param node The node reading the topic. The proxy is never null.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    [[nodiscard]] ::std::future<void> announceTopicReaderAsync(::std::string_view topic, const ::std::optional<NodePrx>& node, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Announce a topic reader.
     * @param topic The name of the topic.
     * @param node The node reading the topic. The proxy is never null.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    announceTopicReaderAsync(::std::string_view topic, const ::std::optional<NodePrx>& node, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_announceTopicReader(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, ::std::string_view, const ::std::optional<NodePrx>&, const ::Ice::Context&) const;
    /// \endcond

    /**
     * Announce a topic writer.
     * @param topic The name of the topic.
     * @param node The node writing the topic. The proxy is never null.
     * @param context The Context map to send with the invocation.
     */
    void announceTopicWriter(::std::string_view topic, const ::std::optional<NodePrx>& node, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Announce a topic writer.
     * @param topic The name of the topic.
     * @param node The node writing the topic. The proxy is never null.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    [[nodiscard]] ::std::future<void> announceTopicWriterAsync(::std::string_view topic, const ::std::optional<NodePrx>& node, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Announce a topic writer.
     * @param topic The name of the topic.
     * @param node The node writing the topic. The proxy is never null.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    announceTopicWriterAsync(::std::string_view topic, const ::std::optional<NodePrx>& node, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_announceTopicWriter(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, ::std::string_view, const ::std::optional<NodePrx>&, const ::Ice::Context&) const;
    /// \endcond

    /**
     * Announce a set of topic readers and writers.
     * @param readers A sequence of topic names for readers.
     * @param writers A sequence of topic names for writers.
     * @param node The node reading or writing the topics. The proxy is never null.
     * @param context The Context map to send with the invocation.
     */
    void announceTopics(const ::Ice::StringSeq& readers, const ::Ice::StringSeq& writers, const ::std::optional<NodePrx>& node, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Announce a set of topic readers and writers.
     * @param readers A sequence of topic names for readers.
     * @param writers A sequence of topic names for writers.
     * @param node The node reading or writing the topics. The proxy is never null.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    [[nodiscard]] ::std::future<void> announceTopicsAsync(const ::Ice::StringSeq& readers, const ::Ice::StringSeq& writers, const ::std::optional<NodePrx>& node, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Announce a set of topic readers and writers.
     * @param readers A sequence of topic names for readers.
     * @param writers A sequence of topic names for writers.
     * @param node The node reading or writing the topics. The proxy is never null.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    announceTopicsAsync(const ::Ice::StringSeq& readers, const ::Ice::StringSeq& writers, const ::std::optional<NodePrx>& node, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_announceTopics(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::StringSeq&, const ::Ice::StringSeq&, const ::std::optional<NodePrx>&, const ::Ice::Context&) const;
    /// \endcond

    /**
     * Establish a connection between this node and another node.
     * @param node The node initiating the connection. The proxy is never null.
     * @param context The Context map to send with the invocation.
     * @return A proxy to this node. The proxy is never null.
     */
    ::std::optional<NodePrx> createSession(const ::std::optional<NodePrx>& node, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Establish a connection between this node and another node.
     * @param node The node initiating the connection. The proxy is never null.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    [[nodiscard]] ::std::future<::std::optional<NodePrx>> createSessionAsync(const ::std::optional<NodePrx>& node, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Establish a connection between this node and another node.
     * @param node The node initiating the connection. The proxy is never null.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    createSessionAsync(const ::std::optional<NodePrx>& node, ::std::function<void(::std::optional<::DataStormContract::NodePrx>)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_createSession(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::optional<NodePrx>>>&, const ::std::optional<NodePrx>&, const ::Ice::Context&) const;
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const char* ice_staticId() noexcept;
    LookupPrx(const LookupPrx& other) noexcept : ::Ice::ObjectPrx(other)
    {
    }

    LookupPrx(LookupPrx&& other) noexcept : ::Ice::ObjectPrx(::std::move(other))
    {
    }

    LookupPrx(const ::Ice::CommunicatorPtr& communicator, std::string_view proxyString) :
        ::Ice::ObjectPrx(communicator, proxyString)
    {
    }

    LookupPrx& operator=(const LookupPrx& rhs) noexcept
    {
        ::Ice::ObjectPrx::operator=(rhs);
        return *this;
    }

    LookupPrx& operator=(LookupPrx&& rhs) noexcept
    {
        ::Ice::ObjectPrx::operator=(::std::move(rhs));
        return *this;
    }

    /// \cond INTERNAL
    static LookupPrx _fromReference(::IceInternal::ReferencePtr ref) { return LookupPrx(::std::move(ref)); }

protected:

    LookupPrx() = default;

    explicit LookupPrx(::IceInternal::ReferencePtr&& ref) : ::Ice::ObjectPrx(::std::move(ref))
    {
    }
    /// \endcond
};

}

namespace DataStormContract
{

struct DataSample
{
    /**
     * The sample id.
     */
    ::std::int64_t id;
    /**
     * The key id.
     */
    ::std::int64_t keyId;
    /**
     * The key value if the key ID <= 0.
     */
    ::Ice::ByteSeq keyValue;
    /**
     * The timestamp of the sample (write time).
     */
    ::std::int64_t timestamp;
    /**
     * The update tag if the sample event is PartialUpdate.
     */
    ::std::int64_t tag;
    /**
     * The sample event.
     */
    ::DataStorm::SampleEvent event;
    /**
     * The value of the sample.
     */
    ::Ice::ByteSeq value;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::int64_t&, const ::std::int64_t&, const ::Ice::ByteSeq&, const ::std::int64_t&, const ::std::int64_t&, const ::DataStorm::SampleEvent&, const ::Ice::ByteSeq&> ice_tuple() const
    {
        return std::tie(id, keyId, keyValue, timestamp, tag, event, value);
    }
};

struct DataSamples
{
    /**
     * The id of the writer or reader.
     */
    ::std::int64_t id;
    /**
     * The samples.
     */
    ::DataStormContract::DataSampleSeq samples;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::int64_t&, const ::DataStormContract::DataSampleSeq&> ice_tuple() const
    {
        return std::tie(id, samples);
    }
};

struct ElementInfo
{
    /**
     * The key or filter id.
     */
    ::std::int64_t id;
    /**
     * The filter name.
     */
    ::std::string name;
    /**
     * The key or filter value.
     */
    ::Ice::ByteSeq value;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::int64_t&, const ::std::string&, const ::Ice::ByteSeq&> ice_tuple() const
    {
        return std::tie(id, name, value);
    }
};

struct TopicInfo
{
    /**
     * The topic name.
     */
    ::std::string name;
    /**
     * The id of topic writers or readers.
     */
    ::Ice::LongSeq ids;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::Ice::LongSeq&> ice_tuple() const
    {
        return std::tie(name, ids);
    }
};

struct TopicSpec
{
    /**
     * The id of the topic.
     */
    ::std::int64_t id;
    /**
     * The name of the topic.
     */
    ::std::string name;
    /**
     * The topic keys or filters.
     */
    ::DataStormContract::ElementInfoSeq elements;
    /**
     * The topic update tags.
     */
    ::DataStormContract::ElementInfoSeq tags;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::int64_t&, const ::std::string&, const ::DataStormContract::ElementInfoSeq&, const ::DataStormContract::ElementInfoSeq&> ice_tuple() const
    {
        return std::tie(id, name, elements, tags);
    }
};

struct FilterInfo
{
    ::std::string name;
    ::Ice::ByteSeq criteria;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::Ice::ByteSeq&> ice_tuple() const
    {
        return std::tie(name, criteria);
    }
};

class ElementConfig : public ::Ice::Value
{
public:
    /**
     * Default constructor.
     */
    ElementConfig() noexcept = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    ElementConfig(::std::optional<::std::string> facet, ::std::optional<::DataStormContract::FilterInfo> sampleFilter, ::std::optional<::std::string> name, ::std::optional<::std::int32_t> priority, ::std::optional<::std::int32_t> sampleCount, ::std::optional<::std::int32_t> sampleLifetime, ::std::optional<::DataStormContract::ClearHistoryPolicy> clearHistory) noexcept :
        facet(::std::move(facet)),
        sampleFilter(::std::move(sampleFilter)),
        name(::std::move(name)),
        priority(priority),
        sampleCount(sampleCount),
        sampleLifetime(sampleLifetime),
        clearHistory(clearHistory)
    {
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const char* ice_staticId() noexcept;

    const char* ice_id() const noexcept override;

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::optional<::std::string>&, const ::std::optional<::DataStormContract::FilterInfo>&, const ::std::optional<::std::string>&, const ::std::optional<::std::int32_t>&, const ::std::optional<::std::int32_t>&, const ::std::optional<::std::int32_t>&, const ::std::optional<::DataStormContract::ClearHistoryPolicy>&> ice_tuple() const
    {
        return std::tie(facet, sampleFilter, name, priority, sampleCount, sampleLifetime, clearHistory);
    }

    /**
     * Creates a shallow polymorphic copy of this instance.
     * @return The cloned value.
     */
    ElementConfigPtr ice_clone() const { return ::std::static_pointer_cast<ElementConfig>(_iceCloneImpl()); }

    ::std::optional<::std::string> facet;
    ::std::optional<::DataStormContract::FilterInfo> sampleFilter;
    ::std::optional<::std::string> name;
    ::std::optional<::std::int32_t> priority;
    ::std::optional<::std::int32_t> sampleCount;
    ::std::optional<::std::int32_t> sampleLifetime;
    ::std::optional<::DataStormContract::ClearHistoryPolicy> clearHistory;

protected:
    ElementConfig(const ElementConfig&) = default;

    ::Ice::ValuePtr _iceCloneImpl() const override;
    void _iceWriteImpl(::Ice::OutputStream*) const override;

    void _iceReadImpl(::Ice::InputStream*) override;
};

struct ElementData
{
    /**
     * The id of the writer or reader.
     */
    ::std::int64_t id;
    /**
     * The config of the writer or reader.
     */
    ::DataStormContract::ElementConfigPtr config;
    /**
     * The lastIds received by the reader.
     */
    ::DataStormContract::LongLongDict lastIds;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::int64_t&, const ::DataStormContract::ElementConfigPtr&, const ::DataStormContract::LongLongDict&> ice_tuple() const
    {
        return std::tie(id, config, lastIds);
    }
};

struct ElementSpec
{
    /**
     * The readers and writers associated with the key or filter.
     */
    ::DataStormContract::ElementDataSeq elements;
    /**
     * The id of the key or filter.
     */
    ::std::int64_t id;
    /**
     * The name of the filter.
     */
    ::std::string name;
    /**
     * The value of the key or filter.
     */
    ::Ice::ByteSeq value;
    /**
     * The id of the key or filter from the peer.
     */
    ::std::int64_t peerId;
    /**
     * The name of the filter from the peer.
     */
    ::std::string peerName;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::DataStormContract::ElementDataSeq&, const ::std::int64_t&, const ::std::string&, const ::Ice::ByteSeq&, const ::std::int64_t&, const ::std::string&> ice_tuple() const
    {
        return std::tie(elements, id, name, value, peerId, peerName);
    }
};

struct ElementDataAck
{
    /**
     * The id of the writer or filter.
     */
    ::std::int64_t id;
    /**
     * The config of the writer or reader.
     */
    ::DataStormContract::ElementConfigPtr config;
    /**
     * The lastIds received by the reader.
     */
    ::DataStormContract::LongLongDict lastIds;
    /**
     * The samples of the writer or reader.
     */
    ::DataStormContract::DataSampleSeq samples;
    /**
     * The id of the writer or reader on the peer.
     */
    ::std::int64_t peerId;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::int64_t&, const ::DataStormContract::ElementConfigPtr&, const ::DataStormContract::LongLongDict&, const ::DataStormContract::DataSampleSeq&, const ::std::int64_t&> ice_tuple() const
    {
        return std::tie(id, config, lastIds, samples, peerId);
    }
};

struct ElementSpecAck
{
    /**
     * The readers or writers associated with the key or filter.
     */
    ::DataStormContract::ElementDataAckSeq elements;
    /**
     * The id of the key or filter.
     */
    ::std::int64_t id;
    /**
     * The name of the filter.
     */
    ::std::string name;
    /**
     * The key or filter value.
     */
    ::Ice::ByteSeq value;
    /**
     * The id of the key or filter on the peer.
     */
    ::std::int64_t peerId;
    /**
     * The name of the filter on the peer.
     */
    ::std::string peerName;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::DataStormContract::ElementDataAckSeq&, const ::std::int64_t&, const ::std::string&, const ::Ice::ByteSeq&, const ::std::int64_t&, const ::std::string&> ice_tuple() const
    {
        return std::tie(elements, id, name, value, peerId, peerName);
    }
};

using Ice::Tuple::operator<;
using Ice::Tuple::operator<=;
using Ice::Tuple::operator>;
using Ice::Tuple::operator>=;
using Ice::Tuple::operator==;
using Ice::Tuple::operator!=;

}

namespace DataStormContract
{

class Session : public virtual ::Ice::Object
{
public:

    using ProxyType = SessionPrx;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const char* ice_staticId() noexcept;

    virtual void announceTopics(TopicInfoSeq topics, bool initialize, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_announceTopics(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    virtual void attachTopic(TopicSpec topic, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_attachTopic(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    virtual void detachTopic(::std::int64_t topic, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_detachTopic(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    virtual void attachTags(::std::int64_t topic, ElementInfoSeq tags, bool initialize, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_attachTags(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    virtual void detachTags(::std::int64_t topic, ::Ice::LongSeq tags, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_detachTags(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    virtual void announceElements(::std::int64_t topic, ElementInfoSeq keys, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_announceElements(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    virtual void attachElements(::std::int64_t topic, ElementSpecSeq elements, bool initialize, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_attachElements(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    virtual void attachElementsAck(::std::int64_t topic, ElementSpecAckSeq elements, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_attachElementsAck(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    virtual void detachElements(::std::int64_t topic, ::Ice::LongSeq keys, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_detachElements(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    virtual void initSamples(::std::int64_t topic, DataSamplesSeq samples, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_initSamples(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    virtual void disconnected(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_disconnected(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    /// \cond INTERNAL
    void dispatch(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>) override;
    /// \endcond
};

using SessionPtr = ::std::shared_ptr<Session>;

class PublisherSession : public virtual Session
{
public:

    using ProxyType = PublisherSessionPrx;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const char* ice_staticId() noexcept;

    /// \cond INTERNAL
    void dispatch(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>) override;
    /// \endcond
};

using PublisherSessionPtr = ::std::shared_ptr<PublisherSession>;

class SubscriberSession : public virtual Session
{
public:

    using ProxyType = SubscriberSessionPrx;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const char* ice_staticId() noexcept;

    virtual void s(::std::int64_t topicId, ::std::int64_t elementId, DataSample sample, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_s(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    /// \cond INTERNAL
    void dispatch(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>) override;
    /// \endcond
};

using SubscriberSessionPtr = ::std::shared_ptr<SubscriberSession>;

/**
 * The Node interface allows DataStorm nodes to create publisher and subscriber sessions with each other.
 *
 * When a node has a writer for a topic that another node is reading, the node initiates the creation of a
 * publisher session. Likewise, when a node has a reader for a topic that another node is writing, the node
 * initiates the creation of a subscriber session.
 *
 * The publisher node hosts the publisher session servant, which is accessed by the subscriber node through a
 * PublisherSession proxy. The subscriber node hosts the subscriber session servant, which is accessed by the
 * publisher node through a SubscriberSession proxy.
 */
class Node : public virtual ::Ice::Object
{
public:

    using ProxyType = NodePrx;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const char* ice_staticId() noexcept;

    /**
     * Initiate the creation of a publisher session with a node, after
     * the target node has announced a topic reader for which this node has a corresponding topic writer.
     * @param publisher The publisher node initiating the session. The proxy is never null.
     * @param current The Current object for the invocation.
     * @see Lookup::announceTopicReader
     */
    virtual void initiateCreateSession(::std::optional<NodePrx> publisher, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_initiateCreateSession(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    /**
     * Initiate the creation of a subscriber session with a node, after
     * the target node has announced a topic writer for which this node has a corresponding topic reader,
     * or after the node has called Node::initiateCreateSession.
     * @param subscriber The subscriber node initiating the session. The proxy is never null.
     * @param session The subscriber session being created. The proxy is never null.
     * @param fromRelay Indicates if the session is being created from a relay node.
     * @param current The Current object for the invocation.
     */
    virtual void createSession(::std::optional<NodePrx> subscriber, ::std::optional<SubscriberSessionPrx> session, bool fromRelay, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_createSession(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    /**
     * Confirm the creation of a publisher session with a node.
     * @param publisher The publisher node confirming the session. The proxy is never null.
     * @param session The publisher session being confirmed. The proxy is never null.
     * @param current The Current object for the invocation.
     */
    virtual void confirmCreateSession(::std::optional<NodePrx> publisher, ::std::optional<PublisherSessionPrx> session, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_confirmCreateSession(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    /// \cond INTERNAL
    void dispatch(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>) override;
    /// \endcond
};

using NodePtr = ::std::shared_ptr<Node>;

/**
 * The lookup interface is used by DataStorm nodes to announce their topic readers and writers to other connected
 * nodes. When multicast is enabled, the lookup interface also broadcasts these announcements.
 * Each DataStorm node hosts a lookup servant with the identity "DataStorm/Lookup".
 */
class Lookup : public virtual ::Ice::Object
{
public:

    using ProxyType = LookupPrx;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const char* ice_staticId() noexcept;

    /**
     * Announce a topic reader.
     * @param topic The name of the topic.
     * @param node The node reading the topic. The proxy is never null.
     * @param current The Current object for the invocation.
     */
    virtual void announceTopicReader(::std::string topic, ::std::optional<NodePrx> node, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_announceTopicReader(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    /**
     * Announce a topic writer.
     * @param topic The name of the topic.
     * @param node The node writing the topic. The proxy is never null.
     * @param current The Current object for the invocation.
     */
    virtual void announceTopicWriter(::std::string topic, ::std::optional<NodePrx> node, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_announceTopicWriter(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    /**
     * Announce a set of topic readers and writers.
     * @param readers A sequence of topic names for readers.
     * @param writers A sequence of topic names for writers.
     * @param node The node reading or writing the topics. The proxy is never null.
     * @param current The Current object for the invocation.
     */
    virtual void announceTopics(::Ice::StringSeq readers, ::Ice::StringSeq writers, ::std::optional<NodePrx> node, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_announceTopics(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    /**
     * Establish a connection between this node and another node.
     * @param node The node initiating the connection. The proxy is never null.
     * @param current The Current object for the invocation.
     * @return A proxy to this node. The proxy is never null.
     */
    virtual ::std::optional<NodePrx> createSession(::std::optional<NodePrx> node, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_createSession(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    /// \cond INTERNAL
    void dispatch(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>) override;
    /// \endcond
};

using LookupPtr = ::std::shared_ptr<Lookup>;

}

/// \cond STREAM
namespace Ice
{

template<>
struct StreamableTraits< ::DataStormContract::ClearHistoryPolicy>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 4;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits<::DataStormContract::DataSample>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 35;
    static const bool fixedLength = false;
};

template<>
struct StreamReader<::DataStormContract::DataSample>
{
    static void read(InputStream* istr, ::DataStormContract::DataSample& v)
    {
        istr->readAll(v.id, v.keyId, v.keyValue, v.timestamp, v.tag, v.event, v.value);
    }
};

template<>
struct StreamableTraits<::DataStormContract::DataSamples>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 9;
    static const bool fixedLength = false;
};

template<>
struct StreamReader<::DataStormContract::DataSamples>
{
    static void read(InputStream* istr, ::DataStormContract::DataSamples& v)
    {
        istr->readAll(v.id, v.samples);
    }
};

template<>
struct StreamableTraits<::DataStormContract::ElementInfo>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 10;
    static const bool fixedLength = false;
};

template<>
struct StreamReader<::DataStormContract::ElementInfo>
{
    static void read(InputStream* istr, ::DataStormContract::ElementInfo& v)
    {
        istr->readAll(v.id, v.name, v.value);
    }
};

template<>
struct StreamableTraits<::DataStormContract::TopicInfo>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 2;
    static const bool fixedLength = false;
};

template<>
struct StreamReader<::DataStormContract::TopicInfo>
{
    static void read(InputStream* istr, ::DataStormContract::TopicInfo& v)
    {
        istr->readAll(v.name, v.ids);
    }
};

template<>
struct StreamableTraits<::DataStormContract::TopicSpec>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 11;
    static const bool fixedLength = false;
};

template<>
struct StreamReader<::DataStormContract::TopicSpec>
{
    static void read(InputStream* istr, ::DataStormContract::TopicSpec& v)
    {
        istr->readAll(v.id, v.name, v.elements, v.tags);
    }
};

template<>
struct StreamableTraits<::DataStormContract::FilterInfo>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 2;
    static const bool fixedLength = false;
};

template<>
struct StreamReader<::DataStormContract::FilterInfo>
{
    static void read(InputStream* istr, ::DataStormContract::FilterInfo& v)
    {
        istr->readAll(v.name, v.criteria);
    }
};

template<>
struct StreamableTraits<::DataStormContract::ElementData>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 10;
    static const bool fixedLength = false;
};

template<>
struct StreamReader<::DataStormContract::ElementData>
{
    static void read(InputStream* istr, ::DataStormContract::ElementData& v)
    {
        istr->readAll(v.id, v.config, v.lastIds);
    }
};

template<>
struct StreamableTraits<::DataStormContract::ElementSpec>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 20;
    static const bool fixedLength = false;
};

template<>
struct StreamReader<::DataStormContract::ElementSpec>
{
    static void read(InputStream* istr, ::DataStormContract::ElementSpec& v)
    {
        istr->readAll(v.elements, v.id, v.name, v.value, v.peerId, v.peerName);
    }
};

template<>
struct StreamableTraits<::DataStormContract::ElementDataAck>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 19;
    static const bool fixedLength = false;
};

template<>
struct StreamReader<::DataStormContract::ElementDataAck>
{
    static void read(InputStream* istr, ::DataStormContract::ElementDataAck& v)
    {
        istr->readAll(v.id, v.config, v.lastIds, v.samples, v.peerId);
    }
};

template<>
struct StreamableTraits<::DataStormContract::ElementSpecAck>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 20;
    static const bool fixedLength = false;
};

template<>
struct StreamReader<::DataStormContract::ElementSpecAck>
{
    static void read(InputStream* istr, ::DataStormContract::ElementSpecAck& v)
    {
        istr->readAll(v.elements, v.id, v.name, v.value, v.peerId, v.peerName);
    }
};

}
/// \endcond

#include <Ice/PopDisableWarnings.h>
#endif
