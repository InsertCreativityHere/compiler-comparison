//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.8.0-alpha.0
//
// <auto-generated>
//
// Generated from file `Descriptor.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __Descriptor_h__
#define __Descriptor_h__

#include <Ice/PushDisableWarnings.h>
#include <Ice/Ice.h>
#include "../Ice/Identity.h"
#include "../Ice/BuiltinSequences.h"
#include <IceGrid/Config.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION  != 30850
#       error Ice version mismatch: an exact match is required for beta generated code
#   endif
#endif

#ifndef ICEGRID_API
#   if defined(ICE_STATIC_LIBS)
#       define ICEGRID_API /**/
#   elif defined(ICEGRID_API_EXPORTS)
#       define ICEGRID_API ICE_DECLSPEC_EXPORT
#   else
#       define ICEGRID_API ICE_DECLSPEC_IMPORT
#   endif
#endif

namespace IceGrid
{
    /**
     * A mapping of string to string.
     */
    using StringStringDict = ::std::map<::std::string, ::std::string>;

    struct PropertyDescriptor;

    /**
     * A sequence of property descriptors.
     */
    using PropertyDescriptorSeq = ::std::vector<PropertyDescriptor>;

    struct PropertySetDescriptor;

    /**
     * A mapping of property set name to property set descriptor.
     */
    using PropertySetDescriptorDict = ::std::map<::std::string, PropertySetDescriptor>;

    struct ObjectDescriptor;

    /**
     * A sequence of object descriptors.
     */
    using ObjectDescriptorSeq = ::std::vector<ObjectDescriptor>;

    struct AdapterDescriptor;

    /**
     * A sequence of adapter descriptors.
     */
    using AdapterDescriptorSeq = ::std::vector<AdapterDescriptor>;

    class CommunicatorDescriptor;
    using CommunicatorDescriptorPtr = ::std::shared_ptr<CommunicatorDescriptor>;

    struct DistributionDescriptor;

    class ServerDescriptor;
    using ServerDescriptorPtr = ::std::shared_ptr<ServerDescriptor>;

    /**
     * A sequence of server descriptors.
     */
    using ServerDescriptorSeq = ::std::vector<ServerDescriptorPtr>;

    class ServiceDescriptor;
    using ServiceDescriptorPtr = ::std::shared_ptr<ServiceDescriptor>;

    /**
     * A sequence of service descriptors.
     */
    using ServiceDescriptorSeq = ::std::vector<ServiceDescriptorPtr>;

    struct ServerInstanceDescriptor;

    /**
     * A sequence of server instance descriptors.
     */
    using ServerInstanceDescriptorSeq = ::std::vector<ServerInstanceDescriptor>;

    struct TemplateDescriptor;

    /**
     * A mapping of template identifier to template descriptor.
     */
    using TemplateDescriptorDict = ::std::map<::std::string, TemplateDescriptor>;

    struct ServiceInstanceDescriptor;

    /**
     * A sequence of service instance descriptors.
     */
    using ServiceInstanceDescriptorSeq = ::std::vector<ServiceInstanceDescriptor>;

    class IceBoxDescriptor;
    using IceBoxDescriptorPtr = ::std::shared_ptr<IceBoxDescriptor>;

    struct NodeDescriptor;

    /**
     * Mapping of node name to node descriptor.
     */
    using NodeDescriptorDict = ::std::map<::std::string, NodeDescriptor>;

    class LoadBalancingPolicy;
    using LoadBalancingPolicyPtr = ::std::shared_ptr<LoadBalancingPolicy>;

    class RandomLoadBalancingPolicy;
    using RandomLoadBalancingPolicyPtr = ::std::shared_ptr<RandomLoadBalancingPolicy>;

    class OrderedLoadBalancingPolicy;
    using OrderedLoadBalancingPolicyPtr = ::std::shared_ptr<OrderedLoadBalancingPolicy>;

    class RoundRobinLoadBalancingPolicy;
    using RoundRobinLoadBalancingPolicyPtr = ::std::shared_ptr<RoundRobinLoadBalancingPolicy>;

    class AdaptiveLoadBalancingPolicy;
    using AdaptiveLoadBalancingPolicyPtr = ::std::shared_ptr<AdaptiveLoadBalancingPolicy>;

    struct ReplicaGroupDescriptor;

    /**
     * A sequence of replica groups.
     */
    using ReplicaGroupDescriptorSeq = ::std::vector<ReplicaGroupDescriptor>;

    struct ApplicationDescriptor;

    /**
     * A sequence of application descriptors.
     */
    using ApplicationDescriptorSeq = ::std::vector<ApplicationDescriptor>;

    class BoxedString;
    using BoxedStringPtr = ::std::shared_ptr<BoxedString>;

    struct NodeUpdateDescriptor;

    /**
     * A sequence of node update descriptors.
     */
    using NodeUpdateDescriptorSeq = ::std::vector<NodeUpdateDescriptor>;

    class BoxedDistributionDescriptor;
    using BoxedDistributionDescriptorPtr = ::std::shared_ptr<BoxedDistributionDescriptor>;

    struct ApplicationUpdateDescriptor;

}

namespace IceGrid
{

/**
 * Property descriptor.
 * \headerfile IceGrid/IceGrid.h
 */
struct PropertyDescriptor
{
    /**
     * The name of the property.
     */
    ::std::string name;
    /**
     * The value of the property.
     */
    ::std::string value;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::std::string&> ice_tuple() const
    {
        return std::tie(name, value);
    }
};

/**
 * A property set descriptor.
 * \headerfile IceGrid/IceGrid.h
 */
struct PropertySetDescriptor
{
    /**
     * References to named property sets.
     */
    ::Ice::StringSeq references;
    /**
     * The property set properties.
     */
    ::IceGrid::PropertyDescriptorSeq properties;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::Ice::StringSeq&, const ::IceGrid::PropertyDescriptorSeq&> ice_tuple() const
    {
        return std::tie(references, properties);
    }
};

/**
 * An Ice object descriptor.
 * \headerfile IceGrid/IceGrid.h
 */
struct ObjectDescriptor
{
    /**
     * The identity of the object.
     */
    ::Ice::Identity id;
    /**
     * The object type.
     */
    ::std::string type;
    /**
     * Proxy options to use with the proxy created for this Ice object. If empty, the proxy will be created with
     * the proxy options specified on the object adapter or replica group.
     */
    ::std::string proxyOptions;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::Ice::Identity&, const ::std::string&, const ::std::string&> ice_tuple() const
    {
        return std::tie(id, type, proxyOptions);
    }
};

/**
 * An Ice object adapter descriptor.
 * \headerfile IceGrid/IceGrid.h
 */
struct AdapterDescriptor
{
    /**
     * The object adapter name.
     */
    ::std::string name;
    /**
     * The description of this object adapter.
     */
    ::std::string description;
    /**
     * The object adapter id.
     */
    ::std::string id;
    /**
     * The replica id of this adapter.
     */
    ::std::string replicaGroupId;
    /**
     * The adapter priority. This is eventually used when the adapter is member of a replica group to sort the
     * adapter endpoints by priority.
     */
    ::std::string priority;
    /**
     * Flag to specify if the object adapter will register a process object.
     */
    bool registerProcess;
    /**
     * If true the lifetime of this object adapter is the same of the server lifetime. This information is used by
     * the IceGrid node to figure out the server state: the server is active only if all its "server lifetime"
     * adapters are active.
     */
    bool serverLifetime;
    /**
     * The well-known object descriptors associated with this object adapter.
     */
    ::IceGrid::ObjectDescriptorSeq objects;
    /**
     * The allocatable object descriptors associated with this object adapter.
     */
    ::IceGrid::ObjectDescriptorSeq allocatables;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const bool&, const bool&, const ::IceGrid::ObjectDescriptorSeq&, const ::IceGrid::ObjectDescriptorSeq&> ice_tuple() const
    {
        return std::tie(name, description, id, replicaGroupId, priority, registerProcess, serverLifetime, objects, allocatables);
    }
};

/**
 * A communicator descriptor.
 * \headerfile IceGrid/IceGrid.h
 */
class ICE_CLASS(ICEGRID_API) CommunicatorDescriptor : public ::Ice::Value
{
public:

    CommunicatorDescriptor() = default;

    /**
     * One-shot constructor to initialize all data members.
     * @param adapters The object adapters.
     * @param propertySet The property set.
     * @param logs The path of each log file.
     * @param description A description of this descriptor.
     */
    CommunicatorDescriptor(::IceGrid::AdapterDescriptorSeq adapters, ::IceGrid::PropertySetDescriptor propertySet, ::Ice::StringSeq logs, ::std::string description) :
        adapters(::std::move(adapters)),
        propertySet(::std::move(propertySet)),
        logs(::std::move(logs)),
        description(::std::move(description))
    {
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    ICE_MEMBER(ICEGRID_API) static ::std::string_view ice_staticId() noexcept;

    ICE_MEMBER(ICEGRID_API) ::std::string ice_id() const override;

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::IceGrid::AdapterDescriptorSeq&, const ::IceGrid::PropertySetDescriptor&, const ::Ice::StringSeq&, const ::std::string&> ice_tuple() const
    {
        return std::tie(adapters, propertySet, logs, description);
    }

    /**
     * Creates a shallow polymorphic copy of this instance.
     * @return The cloned value.
     */
    CommunicatorDescriptorPtr ice_clone() const { return ::std::static_pointer_cast <CommunicatorDescriptor>(_iceCloneImpl()); }

    /**
     * The object adapters.
     */
    ::IceGrid::AdapterDescriptorSeq adapters;
    /**
     * The property set.
     */
    ::IceGrid::PropertySetDescriptor propertySet;
    /**
     * The path of each log file.
     */
    ::Ice::StringSeq logs;
    /**
     * A description of this descriptor.
     */
    ::std::string description;

protected:

    CommunicatorDescriptor(const CommunicatorDescriptor&) = default;

    ICE_MEMBER(ICEGRID_API) ::Ice::ValuePtr _iceCloneImpl() const override;
    ICE_MEMBER(ICEGRID_API) void _iceWriteImpl(::Ice::OutputStream*) const override;

    ICE_MEMBER(ICEGRID_API) void _iceReadImpl(::Ice::InputStream*) override;
};

/// \cond INTERNAL
static CommunicatorDescriptor _iceS_CommunicatorDescriptor_init;
/// \endcond

/**
 * A distribution descriptor defines an IcePatch2 server and the directories to retrieve from the patch server.
 * This descriptor is no longer used. It's provided only for schema compatibility with Ice 3.7 and earlier
 * releases.
 * \headerfile IceGrid/IceGrid.h
 */
struct DistributionDescriptor
{
    /**
     * The proxy of the IcePatch2 server.
     */
    ::std::string icepatch;
    /**
     * The source directories.
     */
    ::Ice::StringSeq directories;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::Ice::StringSeq&> ice_tuple() const
    {
        return std::tie(icepatch, directories);
    }
};

/**
 * An Ice server descriptor.
 * \headerfile IceGrid/IceGrid.h
 */
class ICE_CLASS(ICEGRID_API) ServerDescriptor : public CommunicatorDescriptor
{
public:

    ServerDescriptor() = default;

    /**
     * One-shot constructor to initialize all data members.
     * @param adapters The object adapters.
     * @param propertySet The property set.
     * @param logs The path of each log file.
     * @param description A description of this descriptor.
     * @param id The server id.
     * @param exe The path of the server executable.
     * @param iceVersion The Ice version used by this server.
     * @param pwd The path to the server working directory.
     * @param options The command line options to pass to the server executable.
     * @param envs The server environment variables.
     * @param activation / The server activation mode (possible values are "on-demand" or "manual").
     * @param activationTimeout The activation timeout (an integer value representing the number of seconds to wait for activation).
     * @param deactivationTimeout The deactivation timeout (an integer value representing the number of seconds to wait for deactivation).
     * @param applicationDistrib Specifies if the server depends on the application distribution.
     * @param distrib The distribution descriptor.
     * @param allocatable Specifies if the server is allocatable.
     * @param user The user account used to run the server.
     */
    ServerDescriptor(::IceGrid::AdapterDescriptorSeq adapters, ::IceGrid::PropertySetDescriptor propertySet, ::Ice::StringSeq logs, ::std::string description, ::std::string id, ::std::string exe, ::std::string iceVersion, ::std::string pwd, ::Ice::StringSeq options, ::Ice::StringSeq envs, ::std::string activation, ::std::string activationTimeout, ::std::string deactivationTimeout, bool applicationDistrib, ::IceGrid::DistributionDescriptor distrib, bool allocatable, ::std::string user) :
        CommunicatorDescriptor(::std::move(adapters), ::std::move(propertySet), ::std::move(logs), ::std::move(description)),
        id(::std::move(id)),
        exe(::std::move(exe)),
        iceVersion(::std::move(iceVersion)),
        pwd(::std::move(pwd)),
        options(::std::move(options)),
        envs(::std::move(envs)),
        activation(::std::move(activation)),
        activationTimeout(::std::move(activationTimeout)),
        deactivationTimeout(::std::move(deactivationTimeout)),
        applicationDistrib(applicationDistrib),
        distrib(::std::move(distrib)),
        allocatable(allocatable),
        user(::std::move(user))
    {
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    ICE_MEMBER(ICEGRID_API) static ::std::string_view ice_staticId() noexcept;

    ICE_MEMBER(ICEGRID_API) ::std::string ice_id() const override;

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::IceGrid::AdapterDescriptorSeq&, const ::IceGrid::PropertySetDescriptor&, const ::Ice::StringSeq&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::Ice::StringSeq&, const ::Ice::StringSeq&, const ::std::string&, const ::std::string&, const ::std::string&, const bool&, const ::IceGrid::DistributionDescriptor&, const bool&, const ::std::string&> ice_tuple() const
    {
        return std::tie(adapters, propertySet, logs, description, id, exe, iceVersion, pwd, options, envs, activation, activationTimeout, deactivationTimeout, applicationDistrib, distrib, allocatable, user);
    }

    /**
     * Creates a shallow polymorphic copy of this instance.
     * @return The cloned value.
     */
    ServerDescriptorPtr ice_clone() const { return ::std::static_pointer_cast <ServerDescriptor>(_iceCloneImpl()); }

    /**
     * The server id.
     */
    ::std::string id;
    /**
     * The path of the server executable.
     */
    ::std::string exe;
    /**
     * The Ice version used by this server. This is only required if backward compatibility with servers using old
     * Ice versions is needed (otherwise the registry will assume the server is using the same Ice version).
     * For example "3.1.1", "3.2", "3.3.0".
     */
    ::std::string iceVersion;
    /**
     * The path to the server working directory.
     */
    ::std::string pwd;
    /**
     * The command line options to pass to the server executable.
     */
    ::Ice::StringSeq options;
    /**
     * The server environment variables.
     */
    ::Ice::StringSeq envs;
    /**
     * / The server activation mode (possible values are "on-demand" or "manual").
     */
    ::std::string activation;
    /**
     * The activation timeout (an integer value representing the number of seconds to wait for activation).
     */
    ::std::string activationTimeout;
    /**
     * The deactivation timeout (an integer value representing the number of seconds to wait for deactivation).
     */
    ::std::string deactivationTimeout;
    /**
     * Specifies if the server depends on the application distribution.
     */
    bool applicationDistrib;
    /**
     * The distribution descriptor.
     */
    ::IceGrid::DistributionDescriptor distrib;
    /**
     * Specifies if the server is allocatable.
     */
    bool allocatable;
    /**
     * The user account used to run the server.
     */
    ::std::string user;

protected:

    ServerDescriptor(const ServerDescriptor&) = default;

    ICE_MEMBER(ICEGRID_API) ::Ice::ValuePtr _iceCloneImpl() const override;
    ICE_MEMBER(ICEGRID_API) void _iceWriteImpl(::Ice::OutputStream*) const override;

    ICE_MEMBER(ICEGRID_API) void _iceReadImpl(::Ice::InputStream*) override;
};

/**
 * An IceBox service descriptor.
 * \headerfile IceGrid/IceGrid.h
 */
class ICE_CLASS(ICEGRID_API) ServiceDescriptor : public CommunicatorDescriptor
{
public:

    ServiceDescriptor() = default;

    /**
     * One-shot constructor to initialize all data members.
     * @param adapters The object adapters.
     * @param propertySet The property set.
     * @param logs The path of each log file.
     * @param description A description of this descriptor.
     * @param name The service name.
     * @param entry The entry point of the IceBox service.
     */
    ServiceDescriptor(::IceGrid::AdapterDescriptorSeq adapters, ::IceGrid::PropertySetDescriptor propertySet, ::Ice::StringSeq logs, ::std::string description, ::std::string name, ::std::string entry) :
        CommunicatorDescriptor(::std::move(adapters), ::std::move(propertySet), ::std::move(logs), ::std::move(description)),
        name(::std::move(name)),
        entry(::std::move(entry))
    {
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    ICE_MEMBER(ICEGRID_API) static ::std::string_view ice_staticId() noexcept;

    ICE_MEMBER(ICEGRID_API) ::std::string ice_id() const override;

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::IceGrid::AdapterDescriptorSeq&, const ::IceGrid::PropertySetDescriptor&, const ::Ice::StringSeq&, const ::std::string&, const ::std::string&, const ::std::string&> ice_tuple() const
    {
        return std::tie(adapters, propertySet, logs, description, name, entry);
    }

    /**
     * Creates a shallow polymorphic copy of this instance.
     * @return The cloned value.
     */
    ServiceDescriptorPtr ice_clone() const { return ::std::static_pointer_cast <ServiceDescriptor>(_iceCloneImpl()); }

    /**
     * The service name.
     */
    ::std::string name;
    /**
     * The entry point of the IceBox service.
     */
    ::std::string entry;

protected:

    ServiceDescriptor(const ServiceDescriptor&) = default;

    ICE_MEMBER(ICEGRID_API) ::Ice::ValuePtr _iceCloneImpl() const override;
    ICE_MEMBER(ICEGRID_API) void _iceWriteImpl(::Ice::OutputStream*) const override;

    ICE_MEMBER(ICEGRID_API) void _iceReadImpl(::Ice::InputStream*) override;
};

/**
 * A server template instance descriptor.
 * \headerfile IceGrid/IceGrid.h
 */
struct ServerInstanceDescriptor
{
    /**
     * The template used by this instance.
     */
    ::std::string _cpp_template;
    /**
     * The template parameter values.
     */
    ::IceGrid::StringStringDict parameterValues;
    /**
     * The property set.
     */
    ::IceGrid::PropertySetDescriptor propertySet;
    /**
     * The services property sets. It's only valid to set these property sets if the template is an IceBox server
     * template.
     */
    ::IceGrid::PropertySetDescriptorDict servicePropertySets;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::IceGrid::StringStringDict&, const ::IceGrid::PropertySetDescriptor&, const ::IceGrid::PropertySetDescriptorDict&> ice_tuple() const
    {
        return std::tie(_cpp_template, parameterValues, propertySet, servicePropertySets);
    }
};

/**
 * A template descriptor for server or service templates.
 * \headerfile IceGrid/IceGrid.h
 */
struct TemplateDescriptor
{
    /**
     * The template.
     */
    ::IceGrid::CommunicatorDescriptorPtr descriptor;
    /**
     * The parameters required to instantiate the template.
     */
    ::Ice::StringSeq parameters;
    /**
     * The parameters default values.
     */
    ::IceGrid::StringStringDict parameterDefaults;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::IceGrid::CommunicatorDescriptorPtr&, const ::Ice::StringSeq&, const ::IceGrid::StringStringDict&> ice_tuple() const
    {
        return std::tie(descriptor, parameters, parameterDefaults);
    }
};

/**
 * A service template instance descriptor.
 * \headerfile IceGrid/IceGrid.h
 */
struct ServiceInstanceDescriptor
{
    /**
     * The template used by this instance.
     */
    ::std::string _cpp_template;
    /**
     * The template parameter values.
     */
    ::IceGrid::StringStringDict parameterValues;
    /**
     * The service definition if the instance isn't a template instance (i.e.: if the template attribute is empty).
     */
    ::IceGrid::ServiceDescriptorPtr descriptor;
    /**
     * The property set.
     */
    ::IceGrid::PropertySetDescriptor propertySet;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::IceGrid::StringStringDict&, const ::IceGrid::ServiceDescriptorPtr&, const ::IceGrid::PropertySetDescriptor&> ice_tuple() const
    {
        return std::tie(_cpp_template, parameterValues, descriptor, propertySet);
    }
};

/**
 * An IceBox server descriptor.
 * \headerfile IceGrid/IceGrid.h
 */
class ICE_CLASS(ICEGRID_API) IceBoxDescriptor : public ServerDescriptor
{
public:

    IceBoxDescriptor() = default;

    /**
     * One-shot constructor to initialize all data members.
     * @param adapters The object adapters.
     * @param propertySet The property set.
     * @param logs The path of each log file.
     * @param description A description of this descriptor.
     * @param id The server id.
     * @param exe The path of the server executable.
     * @param iceVersion The Ice version used by this server.
     * @param pwd The path to the server working directory.
     * @param options The command line options to pass to the server executable.
     * @param envs The server environment variables.
     * @param activation / The server activation mode (possible values are "on-demand" or "manual").
     * @param activationTimeout The activation timeout (an integer value representing the number of seconds to wait for activation).
     * @param deactivationTimeout The deactivation timeout (an integer value representing the number of seconds to wait for deactivation).
     * @param applicationDistrib Specifies if the server depends on the application distribution.
     * @param distrib The distribution descriptor.
     * @param allocatable Specifies if the server is allocatable.
     * @param user The user account used to run the server.
     * @param services The service instances.
     */
    IceBoxDescriptor(::IceGrid::AdapterDescriptorSeq adapters, ::IceGrid::PropertySetDescriptor propertySet, ::Ice::StringSeq logs, ::std::string description, ::std::string id, ::std::string exe, ::std::string iceVersion, ::std::string pwd, ::Ice::StringSeq options, ::Ice::StringSeq envs, ::std::string activation, ::std::string activationTimeout, ::std::string deactivationTimeout, bool applicationDistrib, ::IceGrid::DistributionDescriptor distrib, bool allocatable, ::std::string user, ::IceGrid::ServiceInstanceDescriptorSeq services) :
        ServerDescriptor(::std::move(adapters), ::std::move(propertySet), ::std::move(logs), ::std::move(description), ::std::move(id), ::std::move(exe), ::std::move(iceVersion), ::std::move(pwd), ::std::move(options), ::std::move(envs), ::std::move(activation), ::std::move(activationTimeout), ::std::move(deactivationTimeout), applicationDistrib, ::std::move(distrib), allocatable, ::std::move(user)),
        services(::std::move(services))
    {
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    ICE_MEMBER(ICEGRID_API) static ::std::string_view ice_staticId() noexcept;

    ICE_MEMBER(ICEGRID_API) ::std::string ice_id() const override;

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::IceGrid::AdapterDescriptorSeq&, const ::IceGrid::PropertySetDescriptor&, const ::Ice::StringSeq&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::Ice::StringSeq&, const ::Ice::StringSeq&, const ::std::string&, const ::std::string&, const ::std::string&, const bool&, const ::IceGrid::DistributionDescriptor&, const bool&, const ::std::string&, const ::IceGrid::ServiceInstanceDescriptorSeq&> ice_tuple() const
    {
        return std::tie(adapters, propertySet, logs, description, id, exe, iceVersion, pwd, options, envs, activation, activationTimeout, deactivationTimeout, applicationDistrib, distrib, allocatable, user, services);
    }

    /**
     * Creates a shallow polymorphic copy of this instance.
     * @return The cloned value.
     */
    IceBoxDescriptorPtr ice_clone() const { return ::std::static_pointer_cast <IceBoxDescriptor>(_iceCloneImpl()); }

    /**
     * The service instances.
     */
    ::IceGrid::ServiceInstanceDescriptorSeq services;

protected:

    IceBoxDescriptor(const IceBoxDescriptor&) = default;

    ICE_MEMBER(ICEGRID_API) ::Ice::ValuePtr _iceCloneImpl() const override;
    ICE_MEMBER(ICEGRID_API) void _iceWriteImpl(::Ice::OutputStream*) const override;

    ICE_MEMBER(ICEGRID_API) void _iceReadImpl(::Ice::InputStream*) override;
};

/**
 * A node descriptor.
 * \headerfile IceGrid/IceGrid.h
 */
struct NodeDescriptor
{
    /**
     * The variables defined for the node.
     */
    ::IceGrid::StringStringDict variables;
    /**
     * The server instances.
     */
    ::IceGrid::ServerInstanceDescriptorSeq serverInstances;
    /**
     * Servers (which are not template instances).
     */
    ::IceGrid::ServerDescriptorSeq servers;
    /**
     * Load factor of the node.
     */
    ::std::string loadFactor;
    /**
     * The description of this node.
     */
    ::std::string description;
    /**
     * Property set descriptors.
     */
    ::IceGrid::PropertySetDescriptorDict propertySets;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::IceGrid::StringStringDict&, const ::IceGrid::ServerInstanceDescriptorSeq&, const ::IceGrid::ServerDescriptorSeq&, const ::std::string&, const ::std::string&, const ::IceGrid::PropertySetDescriptorDict&> ice_tuple() const
    {
        return std::tie(variables, serverInstances, servers, loadFactor, description, propertySets);
    }
};

/**
 * A base class for load balancing policies.
 * \headerfile IceGrid/IceGrid.h
 */
class ICE_CLASS(ICEGRID_API) LoadBalancingPolicy : public ::Ice::Value
{
public:

    LoadBalancingPolicy() = default;

    /**
     * One-shot constructor to initialize all data members.
     * @param nReplicas The number of replicas that will be used to gather the endpoints of a replica group.
     */
    explicit LoadBalancingPolicy(::std::string nReplicas) :
        nReplicas(::std::move(nReplicas))
    {
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    ICE_MEMBER(ICEGRID_API) static ::std::string_view ice_staticId() noexcept;

    ICE_MEMBER(ICEGRID_API) ::std::string ice_id() const override;

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&> ice_tuple() const
    {
        return std::tie(nReplicas);
    }

    /**
     * Creates a shallow polymorphic copy of this instance.
     * @return The cloned value.
     */
    LoadBalancingPolicyPtr ice_clone() const { return ::std::static_pointer_cast <LoadBalancingPolicy>(_iceCloneImpl()); }

    /**
     * The number of replicas that will be used to gather the endpoints of a replica group.
     */
    ::std::string nReplicas;

protected:

    LoadBalancingPolicy(const LoadBalancingPolicy&) = default;

    ICE_MEMBER(ICEGRID_API) ::Ice::ValuePtr _iceCloneImpl() const override;
    ICE_MEMBER(ICEGRID_API) void _iceWriteImpl(::Ice::OutputStream*) const override;

    ICE_MEMBER(ICEGRID_API) void _iceReadImpl(::Ice::InputStream*) override;
};

/**
 * Random load balancing policy.
 * \headerfile IceGrid/IceGrid.h
 */
class ICE_CLASS(ICEGRID_API) RandomLoadBalancingPolicy : public LoadBalancingPolicy
{
public:

    RandomLoadBalancingPolicy() = default;

    /**
     * One-shot constructor to initialize all data members.
     * @param nReplicas The number of replicas that will be used to gather the endpoints of a replica group.
     */
    explicit RandomLoadBalancingPolicy(::std::string nReplicas) :
        LoadBalancingPolicy(::std::move(nReplicas))
    {
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    ICE_MEMBER(ICEGRID_API) static ::std::string_view ice_staticId() noexcept;

    ICE_MEMBER(ICEGRID_API) ::std::string ice_id() const override;

    /**
     * Creates a shallow polymorphic copy of this instance.
     * @return The cloned value.
     */
    RandomLoadBalancingPolicyPtr ice_clone() const { return ::std::static_pointer_cast <RandomLoadBalancingPolicy>(_iceCloneImpl()); }

protected:

    RandomLoadBalancingPolicy(const RandomLoadBalancingPolicy&) = default;

    ICE_MEMBER(ICEGRID_API) ::Ice::ValuePtr _iceCloneImpl() const override;
    ICE_MEMBER(ICEGRID_API) void _iceWriteImpl(::Ice::OutputStream*) const override;

    ICE_MEMBER(ICEGRID_API) void _iceReadImpl(::Ice::InputStream*) override;
};

/**
 * Ordered load balancing policy.
 * \headerfile IceGrid/IceGrid.h
 */
class ICE_CLASS(ICEGRID_API) OrderedLoadBalancingPolicy : public LoadBalancingPolicy
{
public:

    OrderedLoadBalancingPolicy() = default;

    /**
     * One-shot constructor to initialize all data members.
     * @param nReplicas The number of replicas that will be used to gather the endpoints of a replica group.
     */
    explicit OrderedLoadBalancingPolicy(::std::string nReplicas) :
        LoadBalancingPolicy(::std::move(nReplicas))
    {
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    ICE_MEMBER(ICEGRID_API) static ::std::string_view ice_staticId() noexcept;

    ICE_MEMBER(ICEGRID_API) ::std::string ice_id() const override;

    /**
     * Creates a shallow polymorphic copy of this instance.
     * @return The cloned value.
     */
    OrderedLoadBalancingPolicyPtr ice_clone() const { return ::std::static_pointer_cast <OrderedLoadBalancingPolicy>(_iceCloneImpl()); }

protected:

    OrderedLoadBalancingPolicy(const OrderedLoadBalancingPolicy&) = default;

    ICE_MEMBER(ICEGRID_API) ::Ice::ValuePtr _iceCloneImpl() const override;
    ICE_MEMBER(ICEGRID_API) void _iceWriteImpl(::Ice::OutputStream*) const override;

    ICE_MEMBER(ICEGRID_API) void _iceReadImpl(::Ice::InputStream*) override;
};

/**
 * Round robin load balancing policy.
 * \headerfile IceGrid/IceGrid.h
 */
class ICE_CLASS(ICEGRID_API) RoundRobinLoadBalancingPolicy : public LoadBalancingPolicy
{
public:

    RoundRobinLoadBalancingPolicy() = default;

    /**
     * One-shot constructor to initialize all data members.
     * @param nReplicas The number of replicas that will be used to gather the endpoints of a replica group.
     */
    explicit RoundRobinLoadBalancingPolicy(::std::string nReplicas) :
        LoadBalancingPolicy(::std::move(nReplicas))
    {
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    ICE_MEMBER(ICEGRID_API) static ::std::string_view ice_staticId() noexcept;

    ICE_MEMBER(ICEGRID_API) ::std::string ice_id() const override;

    /**
     * Creates a shallow polymorphic copy of this instance.
     * @return The cloned value.
     */
    RoundRobinLoadBalancingPolicyPtr ice_clone() const { return ::std::static_pointer_cast <RoundRobinLoadBalancingPolicy>(_iceCloneImpl()); }

protected:

    RoundRobinLoadBalancingPolicy(const RoundRobinLoadBalancingPolicy&) = default;

    ICE_MEMBER(ICEGRID_API) ::Ice::ValuePtr _iceCloneImpl() const override;
    ICE_MEMBER(ICEGRID_API) void _iceWriteImpl(::Ice::OutputStream*) const override;

    ICE_MEMBER(ICEGRID_API) void _iceReadImpl(::Ice::InputStream*) override;
};

/**
 * Adaptive load balancing policy.
 * \headerfile IceGrid/IceGrid.h
 */
class ICE_CLASS(ICEGRID_API) AdaptiveLoadBalancingPolicy : public LoadBalancingPolicy
{
public:

    AdaptiveLoadBalancingPolicy() = default;

    /**
     * One-shot constructor to initialize all data members.
     * @param nReplicas The number of replicas that will be used to gather the endpoints of a replica group.
     * @param loadSample The load sample to use for the load balancing.
     */
    AdaptiveLoadBalancingPolicy(::std::string nReplicas, ::std::string loadSample) :
        LoadBalancingPolicy(::std::move(nReplicas)),
        loadSample(::std::move(loadSample))
    {
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    ICE_MEMBER(ICEGRID_API) static ::std::string_view ice_staticId() noexcept;

    ICE_MEMBER(ICEGRID_API) ::std::string ice_id() const override;

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::std::string&> ice_tuple() const
    {
        return std::tie(nReplicas, loadSample);
    }

    /**
     * Creates a shallow polymorphic copy of this instance.
     * @return The cloned value.
     */
    AdaptiveLoadBalancingPolicyPtr ice_clone() const { return ::std::static_pointer_cast <AdaptiveLoadBalancingPolicy>(_iceCloneImpl()); }

    /**
     * The load sample to use for the load balancing. The allowed values for this attribute are "1", "5" and "15",
     * representing respectively the load average over the past minute, the past 5 minutes and the past 15 minutes.
     */
    ::std::string loadSample;

protected:

    AdaptiveLoadBalancingPolicy(const AdaptiveLoadBalancingPolicy&) = default;

    ICE_MEMBER(ICEGRID_API) ::Ice::ValuePtr _iceCloneImpl() const override;
    ICE_MEMBER(ICEGRID_API) void _iceWriteImpl(::Ice::OutputStream*) const override;

    ICE_MEMBER(ICEGRID_API) void _iceReadImpl(::Ice::InputStream*) override;
};

/**
 * A replica group descriptor.
 * \headerfile IceGrid/IceGrid.h
 */
struct ReplicaGroupDescriptor
{
    /**
     * The id of the replica group.
     */
    ::std::string id;
    /**
     * The load balancing policy.
     */
    ::IceGrid::LoadBalancingPolicyPtr loadBalancing;
    /**
     * Default options for proxies created for the replica group.
     */
    ::std::string proxyOptions;
    /**
     * The object descriptors associated with this object adapter.
     */
    ::IceGrid::ObjectDescriptorSeq objects;
    /**
     * The description of this replica group.
     */
    ::std::string description;
    /**
     * The filter to use for this replica group.
     */
    ::std::string filter;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::IceGrid::LoadBalancingPolicyPtr&, const ::std::string&, const ::IceGrid::ObjectDescriptorSeq&, const ::std::string&, const ::std::string&> ice_tuple() const
    {
        return std::tie(id, loadBalancing, proxyOptions, objects, description, filter);
    }
};

/**
 * An application descriptor.
 * \headerfile IceGrid/IceGrid.h
 */
struct ApplicationDescriptor
{
    /**
     * The application name.
     */
    ::std::string name;
    /**
     * The variables defined in the application descriptor.
     */
    ::IceGrid::StringStringDict variables;
    /**
     * The replica groups.
     */
    ::IceGrid::ReplicaGroupDescriptorSeq replicaGroups;
    /**
     * The server templates.
     */
    ::IceGrid::TemplateDescriptorDict serverTemplates;
    /**
     * The service templates.
     */
    ::IceGrid::TemplateDescriptorDict serviceTemplates;
    /**
     * The application nodes.
     */
    ::IceGrid::NodeDescriptorDict nodes;
    /**
     * The application distribution.
     */
    ::IceGrid::DistributionDescriptor distrib;
    /**
     * The description of this application.
     */
    ::std::string description;
    /**
     * Property set descriptors.
     */
    ::IceGrid::PropertySetDescriptorDict propertySets;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::IceGrid::StringStringDict&, const ::IceGrid::ReplicaGroupDescriptorSeq&, const ::IceGrid::TemplateDescriptorDict&, const ::IceGrid::TemplateDescriptorDict&, const ::IceGrid::NodeDescriptorDict&, const ::IceGrid::DistributionDescriptor&, const ::std::string&, const ::IceGrid::PropertySetDescriptorDict&> ice_tuple() const
    {
        return std::tie(name, variables, replicaGroups, serverTemplates, serviceTemplates, nodes, distrib, description, propertySets);
    }
};

/**
 * A "boxed" string.
 * \headerfile IceGrid/IceGrid.h
 */
class ICE_CLASS(ICEGRID_API) BoxedString : public ::Ice::Value
{
public:

    BoxedString() = default;

    /**
     * One-shot constructor to initialize all data members.
     * @param value The value of the boxed string.
     */
    explicit BoxedString(::std::string value) :
        value(::std::move(value))
    {
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    ICE_MEMBER(ICEGRID_API) static ::std::string_view ice_staticId() noexcept;

    ICE_MEMBER(ICEGRID_API) ::std::string ice_id() const override;

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&> ice_tuple() const
    {
        return std::tie(value);
    }

    /**
     * Creates a shallow polymorphic copy of this instance.
     * @return The cloned value.
     */
    BoxedStringPtr ice_clone() const { return ::std::static_pointer_cast <BoxedString>(_iceCloneImpl()); }

    /**
     * The value of the boxed string.
     */
    ::std::string value;

protected:

    BoxedString(const BoxedString&) = default;

    ICE_MEMBER(ICEGRID_API) ::Ice::ValuePtr _iceCloneImpl() const override;
    ICE_MEMBER(ICEGRID_API) void _iceWriteImpl(::Ice::OutputStream*) const override;

    ICE_MEMBER(ICEGRID_API) void _iceReadImpl(::Ice::InputStream*) override;
};

/**
 * A node update descriptor to describe the updates to apply to a node of a deployed application.
 * \headerfile IceGrid/IceGrid.h
 */
struct NodeUpdateDescriptor
{
    /**
     * The name of the node to update.
     */
    ::std::string name;
    /**
     * The updated description (or null if the description wasn't updated.)
     */
    ::IceGrid::BoxedStringPtr description;
    /**
     * The variables to update.
     */
    ::IceGrid::StringStringDict variables;
    /**
     * The variables to remove.
     */
    ::Ice::StringSeq removeVariables;
    /**
     * The property sets to update.
     */
    ::IceGrid::PropertySetDescriptorDict propertySets;
    /**
     * The property sets to remove.
     */
    ::Ice::StringSeq removePropertySets;
    /**
     * The server instances to update.
     */
    ::IceGrid::ServerInstanceDescriptorSeq serverInstances;
    /**
     * The servers which are not template instances to update.
     */
    ::IceGrid::ServerDescriptorSeq servers;
    /**
     * The ids of the servers to remove.
     */
    ::Ice::StringSeq removeServers;
    /**
     * The updated load factor of the node (or null if the load factor was not updated).
     */
    ::IceGrid::BoxedStringPtr loadFactor;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::IceGrid::BoxedStringPtr&, const ::IceGrid::StringStringDict&, const ::Ice::StringSeq&, const ::IceGrid::PropertySetDescriptorDict&, const ::Ice::StringSeq&, const ::IceGrid::ServerInstanceDescriptorSeq&, const ::IceGrid::ServerDescriptorSeq&, const ::Ice::StringSeq&, const ::IceGrid::BoxedStringPtr&> ice_tuple() const
    {
        return std::tie(name, description, variables, removeVariables, propertySets, removePropertySets, serverInstances, servers, removeServers, loadFactor);
    }
};

/**
 * A "boxed" distribution descriptor.
 * \headerfile IceGrid/IceGrid.h
 */
class ICE_CLASS(ICEGRID_API) BoxedDistributionDescriptor : public ::Ice::Value
{
public:

    BoxedDistributionDescriptor() = default;

    /**
     * One-shot constructor to initialize all data members.
     * @param value The value of the boxed distribution descriptor.
     */
    explicit BoxedDistributionDescriptor(::IceGrid::DistributionDescriptor value) :
        value(::std::move(value))
    {
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    ICE_MEMBER(ICEGRID_API) static ::std::string_view ice_staticId() noexcept;

    ICE_MEMBER(ICEGRID_API) ::std::string ice_id() const override;

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::IceGrid::DistributionDescriptor&> ice_tuple() const
    {
        return std::tie(value);
    }

    /**
     * Creates a shallow polymorphic copy of this instance.
     * @return The cloned value.
     */
    BoxedDistributionDescriptorPtr ice_clone() const { return ::std::static_pointer_cast <BoxedDistributionDescriptor>(_iceCloneImpl()); }

    /**
     * The value of the boxed distribution descriptor.
     */
    ::IceGrid::DistributionDescriptor value;

protected:

    BoxedDistributionDescriptor(const BoxedDistributionDescriptor&) = default;

    ICE_MEMBER(ICEGRID_API) ::Ice::ValuePtr _iceCloneImpl() const override;
    ICE_MEMBER(ICEGRID_API) void _iceWriteImpl(::Ice::OutputStream*) const override;

    ICE_MEMBER(ICEGRID_API) void _iceReadImpl(::Ice::InputStream*) override;
};

/**
 * An application update descriptor to describe the updates to apply to a deployed application.
 * \headerfile IceGrid/IceGrid.h
 */
struct ApplicationUpdateDescriptor
{
    /**
     * The name of the application to update.
     */
    ::std::string name;
    /**
     * The updated description (or null if the description wasn't updated.)
     */
    ::IceGrid::BoxedStringPtr description;
    /**
     * The updated distribution application descriptor.
     */
    ::IceGrid::BoxedDistributionDescriptorPtr distrib;
    /**
     * The variables to update.
     */
    ::IceGrid::StringStringDict variables;
    /**
     * The variables to remove.
     */
    ::Ice::StringSeq removeVariables;
    /**
     * The property sets to update.
     */
    ::IceGrid::PropertySetDescriptorDict propertySets;
    /**
     * The property sets to remove.
     */
    ::Ice::StringSeq removePropertySets;
    /**
     * The replica groups to update.
     */
    ::IceGrid::ReplicaGroupDescriptorSeq replicaGroups;
    /**
     * The replica groups to remove.
     */
    ::Ice::StringSeq removeReplicaGroups;
    /**
     * The server templates to update.
     */
    ::IceGrid::TemplateDescriptorDict serverTemplates;
    /**
     * The ids of the server template to remove.
     */
    ::Ice::StringSeq removeServerTemplates;
    /**
     * The service templates to update.
     */
    ::IceGrid::TemplateDescriptorDict serviceTemplates;
    /**
     * The ids of the service template to remove.
     */
    ::Ice::StringSeq removeServiceTemplates;
    /**
     * The application nodes to update.
     */
    ::IceGrid::NodeUpdateDescriptorSeq nodes;
    /**
     * The nodes to remove.
     */
    ::Ice::StringSeq removeNodes;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::IceGrid::BoxedStringPtr&, const ::IceGrid::BoxedDistributionDescriptorPtr&, const ::IceGrid::StringStringDict&, const ::Ice::StringSeq&, const ::IceGrid::PropertySetDescriptorDict&, const ::Ice::StringSeq&, const ::IceGrid::ReplicaGroupDescriptorSeq&, const ::Ice::StringSeq&, const ::IceGrid::TemplateDescriptorDict&, const ::Ice::StringSeq&, const ::IceGrid::TemplateDescriptorDict&, const ::Ice::StringSeq&, const ::IceGrid::NodeUpdateDescriptorSeq&, const ::Ice::StringSeq&> ice_tuple() const
    {
        return std::tie(name, description, distrib, variables, removeVariables, propertySets, removePropertySets, replicaGroups, removeReplicaGroups, serverTemplates, removeServerTemplates, serviceTemplates, removeServiceTemplates, nodes, removeNodes);
    }
};

using Ice::operator<;
using Ice::operator<=;
using Ice::operator>;
using Ice::operator>=;
using Ice::operator==;
using Ice::operator!=;

}

/// \cond STREAM
namespace Ice
{

template<>
struct StreamableTraits<::IceGrid::PropertyDescriptor>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 2;
    static const bool fixedLength = false;
};

template<>
struct StreamReader<::IceGrid::PropertyDescriptor>
{
    static void read(InputStream* istr, ::IceGrid::PropertyDescriptor& v)
    {
        istr->readAll(v.name, v.value);
    }
};

template<>
struct StreamableTraits<::IceGrid::PropertySetDescriptor>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 2;
    static const bool fixedLength = false;
};

template<>
struct StreamReader<::IceGrid::PropertySetDescriptor>
{
    static void read(InputStream* istr, ::IceGrid::PropertySetDescriptor& v)
    {
        istr->readAll(v.references, v.properties);
    }
};

template<>
struct StreamableTraits<::IceGrid::ObjectDescriptor>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 4;
    static const bool fixedLength = false;
};

template<>
struct StreamReader<::IceGrid::ObjectDescriptor>
{
    static void read(InputStream* istr, ::IceGrid::ObjectDescriptor& v)
    {
        istr->readAll(v.id, v.type, v.proxyOptions);
    }
};

template<>
struct StreamableTraits<::IceGrid::AdapterDescriptor>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 9;
    static const bool fixedLength = false;
};

template<>
struct StreamReader<::IceGrid::AdapterDescriptor>
{
    static void read(InputStream* istr, ::IceGrid::AdapterDescriptor& v)
    {
        istr->readAll(v.name, v.description, v.id, v.replicaGroupId, v.priority, v.registerProcess, v.serverLifetime, v.objects, v.allocatables);
    }
};

template<>
struct StreamReader<::IceGrid::CommunicatorDescriptor>
{
    static void read(InputStream* istr, ::IceGrid::CommunicatorDescriptor& v)
    {
        istr->readAll(v.adapters, v.propertySet, v.logs, v.description);
    }
};

template<>
struct StreamableTraits<::IceGrid::DistributionDescriptor>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 2;
    static const bool fixedLength = false;
};

template<>
struct StreamReader<::IceGrid::DistributionDescriptor>
{
    static void read(InputStream* istr, ::IceGrid::DistributionDescriptor& v)
    {
        istr->readAll(v.icepatch, v.directories);
    }
};

template<>
struct StreamWriter<::IceGrid::ServerDescriptor>
{
    static void write(OutputStream* ostr, const ::IceGrid::ServerDescriptor& v)
    {
        ostr->writeAll(v.id, v.exe, v.iceVersion, v.pwd, v.options, v.envs, v.activation, v.activationTimeout, v.deactivationTimeout, v.applicationDistrib, v.distrib, v.allocatable, v.user);
    }
};

template<>
struct StreamReader<::IceGrid::ServerDescriptor>
{
    static void read(InputStream* istr, ::IceGrid::ServerDescriptor& v)
    {
        istr->readAll(v.id, v.exe, v.iceVersion, v.pwd, v.options, v.envs, v.activation, v.activationTimeout, v.deactivationTimeout, v.applicationDistrib, v.distrib, v.allocatable, v.user);
    }
};

template<>
struct StreamWriter<::IceGrid::ServiceDescriptor>
{
    static void write(OutputStream* ostr, const ::IceGrid::ServiceDescriptor& v)
    {
        ostr->writeAll(v.name, v.entry);
    }
};

template<>
struct StreamReader<::IceGrid::ServiceDescriptor>
{
    static void read(InputStream* istr, ::IceGrid::ServiceDescriptor& v)
    {
        istr->readAll(v.name, v.entry);
    }
};

template<>
struct StreamableTraits<::IceGrid::ServerInstanceDescriptor>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 5;
    static const bool fixedLength = false;
};

template<>
struct StreamReader<::IceGrid::ServerInstanceDescriptor>
{
    static void read(InputStream* istr, ::IceGrid::ServerInstanceDescriptor& v)
    {
        istr->readAll(v._cpp_template, v.parameterValues, v.propertySet, v.servicePropertySets);
    }
};

template<>
struct StreamableTraits<::IceGrid::TemplateDescriptor>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 3;
    static const bool fixedLength = false;
};

template<>
struct StreamReader<::IceGrid::TemplateDescriptor>
{
    static void read(InputStream* istr, ::IceGrid::TemplateDescriptor& v)
    {
        istr->readAll(v.descriptor, v.parameters, v.parameterDefaults);
    }
};

template<>
struct StreamableTraits<::IceGrid::ServiceInstanceDescriptor>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 5;
    static const bool fixedLength = false;
};

template<>
struct StreamReader<::IceGrid::ServiceInstanceDescriptor>
{
    static void read(InputStream* istr, ::IceGrid::ServiceInstanceDescriptor& v)
    {
        istr->readAll(v._cpp_template, v.parameterValues, v.descriptor, v.propertySet);
    }
};

template<>
struct StreamWriter<::IceGrid::IceBoxDescriptor>
{
    static void write(OutputStream* ostr, const ::IceGrid::IceBoxDescriptor& v)
    {
        ostr->writeAll(v.services);
    }
};

template<>
struct StreamReader<::IceGrid::IceBoxDescriptor>
{
    static void read(InputStream* istr, ::IceGrid::IceBoxDescriptor& v)
    {
        istr->readAll(v.services);
    }
};

template<>
struct StreamableTraits<::IceGrid::NodeDescriptor>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 6;
    static const bool fixedLength = false;
};

template<>
struct StreamReader<::IceGrid::NodeDescriptor>
{
    static void read(InputStream* istr, ::IceGrid::NodeDescriptor& v)
    {
        istr->readAll(v.variables, v.serverInstances, v.servers, v.loadFactor, v.description, v.propertySets);
    }
};

template<>
struct StreamReader<::IceGrid::LoadBalancingPolicy>
{
    static void read(InputStream* istr, ::IceGrid::LoadBalancingPolicy& v)
    {
        istr->readAll(v.nReplicas);
    }
};

template<>
struct StreamWriter<::IceGrid::RandomLoadBalancingPolicy>
{
    static void write(OutputStream*, const ::IceGrid::RandomLoadBalancingPolicy&)
    {
    }
};

template<>
struct StreamReader<::IceGrid::RandomLoadBalancingPolicy>
{
    static void read(InputStream*, ::IceGrid::RandomLoadBalancingPolicy&)
    {
    }
};

template<>
struct StreamWriter<::IceGrid::OrderedLoadBalancingPolicy>
{
    static void write(OutputStream*, const ::IceGrid::OrderedLoadBalancingPolicy&)
    {
    }
};

template<>
struct StreamReader<::IceGrid::OrderedLoadBalancingPolicy>
{
    static void read(InputStream*, ::IceGrid::OrderedLoadBalancingPolicy&)
    {
    }
};

template<>
struct StreamWriter<::IceGrid::RoundRobinLoadBalancingPolicy>
{
    static void write(OutputStream*, const ::IceGrid::RoundRobinLoadBalancingPolicy&)
    {
    }
};

template<>
struct StreamReader<::IceGrid::RoundRobinLoadBalancingPolicy>
{
    static void read(InputStream*, ::IceGrid::RoundRobinLoadBalancingPolicy&)
    {
    }
};

template<>
struct StreamWriter<::IceGrid::AdaptiveLoadBalancingPolicy>
{
    static void write(OutputStream* ostr, const ::IceGrid::AdaptiveLoadBalancingPolicy& v)
    {
        ostr->writeAll(v.loadSample);
    }
};

template<>
struct StreamReader<::IceGrid::AdaptiveLoadBalancingPolicy>
{
    static void read(InputStream* istr, ::IceGrid::AdaptiveLoadBalancingPolicy& v)
    {
        istr->readAll(v.loadSample);
    }
};

template<>
struct StreamableTraits<::IceGrid::ReplicaGroupDescriptor>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 6;
    static const bool fixedLength = false;
};

template<>
struct StreamReader<::IceGrid::ReplicaGroupDescriptor>
{
    static void read(InputStream* istr, ::IceGrid::ReplicaGroupDescriptor& v)
    {
        istr->readAll(v.id, v.loadBalancing, v.proxyOptions, v.objects, v.description, v.filter);
    }
};

template<>
struct StreamableTraits<::IceGrid::ApplicationDescriptor>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 10;
    static const bool fixedLength = false;
};

template<>
struct StreamReader<::IceGrid::ApplicationDescriptor>
{
    static void read(InputStream* istr, ::IceGrid::ApplicationDescriptor& v)
    {
        istr->readAll(v.name, v.variables, v.replicaGroups, v.serverTemplates, v.serviceTemplates, v.nodes, v.distrib, v.description, v.propertySets);
    }
};

template<>
struct StreamReader<::IceGrid::BoxedString>
{
    static void read(InputStream* istr, ::IceGrid::BoxedString& v)
    {
        istr->readAll(v.value);
    }
};

template<>
struct StreamableTraits<::IceGrid::NodeUpdateDescriptor>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 10;
    static const bool fixedLength = false;
};

template<>
struct StreamReader<::IceGrid::NodeUpdateDescriptor>
{
    static void read(InputStream* istr, ::IceGrid::NodeUpdateDescriptor& v)
    {
        istr->readAll(v.name, v.description, v.variables, v.removeVariables, v.propertySets, v.removePropertySets, v.serverInstances, v.servers, v.removeServers, v.loadFactor);
    }
};

template<>
struct StreamReader<::IceGrid::BoxedDistributionDescriptor>
{
    static void read(InputStream* istr, ::IceGrid::BoxedDistributionDescriptor& v)
    {
        istr->readAll(v.value);
    }
};

template<>
struct StreamableTraits<::IceGrid::ApplicationUpdateDescriptor>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 15;
    static const bool fixedLength = false;
};

template<>
struct StreamReader<::IceGrid::ApplicationUpdateDescriptor>
{
    static void read(InputStream* istr, ::IceGrid::ApplicationUpdateDescriptor& v)
    {
        istr->readAll(v.name, v.description, v.distrib, v.variables, v.removeVariables, v.propertySets, v.removePropertySets, v.replicaGroups, v.removeReplicaGroups, v.serverTemplates, v.removeServerTemplates, v.serviceTemplates, v.removeServiceTemplates, v.nodes, v.removeNodes);
    }
};

}
/// \endcond

#include <Ice/PopDisableWarnings.h>
#endif
