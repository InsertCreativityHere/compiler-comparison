//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.8.0-alpha.0
//
// <auto-generated>
//
// Generated from file `Descriptor.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __Descriptor_h__
#define __Descriptor_h__

#include <IceUtil/PushDisableWarnings.h>
#include <Ice/Ice.h>
#include <Ice/Identity.h>
#include <Ice/BuiltinSequences.h>
#include <IceUtil/UndefSysMacros.h>
#include <IceGrid/Config.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION  != 30850
#       error Ice version mismatch: an exact match is required for beta generated code
#   endif
#endif

#ifndef ICEGRID_API
#   if defined(ICE_STATIC_LIBS)
#       define ICEGRID_API /**/
#   elif defined(ICEGRID_API_EXPORTS)
#       define ICEGRID_API ICE_DECLSPEC_EXPORT
#   else
#       define ICEGRID_API ICE_DECLSPEC_IMPORT
#   endif
#endif

namespace IceGrid
{

struct PropertyDescriptor;
struct PropertySetDescriptor;
struct ObjectDescriptor;
struct AdapterDescriptor;
class CommunicatorDescriptor;
struct DistributionDescriptor;
class ServerDescriptor;
class ServiceDescriptor;
struct ServerInstanceDescriptor;
struct TemplateDescriptor;
struct ServiceInstanceDescriptor;
class IceBoxDescriptor;
struct NodeDescriptor;
class LoadBalancingPolicy;
class RandomLoadBalancingPolicy;
class OrderedLoadBalancingPolicy;
class RoundRobinLoadBalancingPolicy;
class AdaptiveLoadBalancingPolicy;
struct ReplicaGroupDescriptor;
struct ApplicationDescriptor;
class BoxedString;
struct NodeUpdateDescriptor;
class BoxedDistributionDescriptor;
struct ApplicationUpdateDescriptor;

}

namespace IceGrid
{

/**
 * A mapping of string to string.
 */
using StringStringDict = ::std::map<::std::string, ::std::string>;

/**
 * A sequence of property descriptors.
 */
using PropertyDescriptorSeq = ::std::vector<PropertyDescriptor>;

/**
 * A mapping of property set name to property set descriptor.
 */
using PropertySetDescriptorDict = ::std::map<::std::string, PropertySetDescriptor>;

/**
 * A sequence of object descriptors.
 */
using ObjectDescriptorSeq = ::std::vector<ObjectDescriptor>;

/**
 * A sequence of adapter descriptors.
 */
using AdapterDescriptorSeq = ::std::vector<AdapterDescriptor>;

/**
 * A sequence of server descriptors.
 */
using ServerDescriptorSeq = ::std::vector<::std::shared_ptr<ServerDescriptor>>;

/**
 * A sequence of service descriptors.
 */
using ServiceDescriptorSeq = ::std::vector<::std::shared_ptr<ServiceDescriptor>>;

/**
 * A sequence of server instance descriptors.
 */
using ServerInstanceDescriptorSeq = ::std::vector<ServerInstanceDescriptor>;

/**
 * A mapping of template identifier to template descriptor.
 */
using TemplateDescriptorDict = ::std::map<::std::string, TemplateDescriptor>;

/**
 * A sequence of service instance descriptors.
 */
using ServiceInstanceDescriptorSeq = ::std::vector<ServiceInstanceDescriptor>;

/**
 * Mapping of node name to node descriptor.
 */
using NodeDescriptorDict = ::std::map<::std::string, NodeDescriptor>;

/**
 * A sequence of replica groups.
 */
using ReplicaGroupDescriptorSeq = ::std::vector<ReplicaGroupDescriptor>;

/**
 * A sequence of application descriptors.
 */
using ApplicationDescriptorSeq = ::std::vector<ApplicationDescriptor>;

/**
 * A sequence of node update descriptors.
 */
using NodeUpdateDescriptorSeq = ::std::vector<NodeUpdateDescriptor>;

}

namespace IceGrid
{

/**
 * Property descriptor.
 * \headerfile IceGrid/IceGrid.h
 */
struct PropertyDescriptor
{
    /**
     * The name of the property.
     */
    ::std::string name;
    /**
     * The value of the property.
     */
    ::std::string value;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::std::string&> ice_tuple() const
    {
        return std::tie(name, value);
    }
};

/**
 * A property set descriptor.
 * \headerfile IceGrid/IceGrid.h
 */
struct PropertySetDescriptor
{
    /**
     * References to named property sets.
     */
    ::Ice::StringSeq references;
    /**
     * The property set properties.
     */
    ::IceGrid::PropertyDescriptorSeq properties;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::Ice::StringSeq&, const ::IceGrid::PropertyDescriptorSeq&> ice_tuple() const
    {
        return std::tie(references, properties);
    }
};

/**
 * An Ice object descriptor.
 * \headerfile IceGrid/IceGrid.h
 */
struct ObjectDescriptor
{
    /**
     * The identity of the object.
     */
    ::Ice::Identity id;
    /**
     * The object type.
     */
    ::std::string type;
    /**
     * Proxy options to use with the proxy created for this Ice object. If empty, the proxy will be created with the
     * proxy options specified on the object adapter or replica group.
     */
    ::std::string proxyOptions;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::Ice::Identity&, const ::std::string&, const ::std::string&> ice_tuple() const
    {
        return std::tie(id, type, proxyOptions);
    }
};

/**
 * An Ice object adapter descriptor.
 * \headerfile IceGrid/IceGrid.h
 */
struct AdapterDescriptor
{
    /**
     * The object adapter name.
     */
    ::std::string name;
    /**
     * The description of this object adapter.
     */
    ::std::string description;
    /**
     * The object adapter id.
     */
    ::std::string id;
    /**
     * The replica id of this adapter.
     */
    ::std::string replicaGroupId;
    /**
     * The adapter priority. This is eventually used when the adapter is member of a replica group to sort the adapter
     * endpoints by priority.
     */
    ::std::string priority;
    /**
     * Flag to specify if the object adapter will register a process object.
     */
    bool registerProcess;
    /**
     * If true the lifetime of this object adapter is the same of the server lifetime. This information is used by the
     * IceGrid node to figure out the server state: the server is active only if all its "server lifetime" adapters
     * are active.
     */
    bool serverLifetime;
    /**
     * The well-known object descriptors associated with this object adapter.
     */
    ::IceGrid::ObjectDescriptorSeq objects;
    /**
     * The allocatable object descriptors associated with this object adapter.
     */
    ::IceGrid::ObjectDescriptorSeq allocatables;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const bool&, const bool&, const ::IceGrid::ObjectDescriptorSeq&, const ::IceGrid::ObjectDescriptorSeq&> ice_tuple() const
    {
        return std::tie(name, description, id, replicaGroupId, priority, registerProcess, serverLifetime, objects, allocatables);
    }
};

/**
 * A distribution descriptor defines an IcePatch2 server and the directories to retrieve from the patch server.
 * \headerfile IceGrid/IceGrid.h
 */
struct DistributionDescriptor
{
    /**
     * The proxy of the IcePatch2 server.
     */
    ::std::string icepatch;
    /**
     * The source directories.
     */
    ::Ice::StringSeq directories;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::Ice::StringSeq&> ice_tuple() const
    {
        return std::tie(icepatch, directories);
    }
};

/**
 * A server template instance descriptor.
 * \headerfile IceGrid/IceGrid.h
 */
struct ServerInstanceDescriptor
{
    /**
     * The template used by this instance.
     */
    ::std::string _cpp_template;
    /**
     * The template parameter values.
     */
    ::IceGrid::StringStringDict parameterValues;
    /**
     * The property set.
     */
    ::IceGrid::PropertySetDescriptor propertySet;
    /**
     * The services property sets. It's only valid to set these property sets if the template is an IceBox server
     * template.
     */
    ::IceGrid::PropertySetDescriptorDict servicePropertySets;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::IceGrid::StringStringDict&, const ::IceGrid::PropertySetDescriptor&, const ::IceGrid::PropertySetDescriptorDict&> ice_tuple() const
    {
        return std::tie(_cpp_template, parameterValues, propertySet, servicePropertySets);
    }
};

/**
 * A template descriptor for server or service templates.
 * \headerfile IceGrid/IceGrid.h
 */
struct TemplateDescriptor
{
    /**
     * The template.
     */
    ::std::shared_ptr<::IceGrid::CommunicatorDescriptor> descriptor;
    /**
     * The parameters required to instantiate the template.
     */
    ::Ice::StringSeq parameters;
    /**
     * The parameters default values.
     */
    ::IceGrid::StringStringDict parameterDefaults;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::shared_ptr<::IceGrid::CommunicatorDescriptor>&, const ::Ice::StringSeq&, const ::IceGrid::StringStringDict&> ice_tuple() const
    {
        return std::tie(descriptor, parameters, parameterDefaults);
    }
};

/**
 * A service template instance descriptor.
 * \headerfile IceGrid/IceGrid.h
 */
struct ServiceInstanceDescriptor
{
    /**
     * The template used by this instance.
     */
    ::std::string _cpp_template;
    /**
     * The template parameter values.
     */
    ::IceGrid::StringStringDict parameterValues;
    /**
     * The service definition if the instance isn't a template instance (i.e.: if the template attribute is empty).
     */
    ::std::shared_ptr<::IceGrid::ServiceDescriptor> descriptor;
    /**
     * The property set.
     */
    ::IceGrid::PropertySetDescriptor propertySet;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::IceGrid::StringStringDict&, const ::std::shared_ptr<::IceGrid::ServiceDescriptor>&, const ::IceGrid::PropertySetDescriptor&> ice_tuple() const
    {
        return std::tie(_cpp_template, parameterValues, descriptor, propertySet);
    }
};

/**
 * A node descriptor.
 * \headerfile IceGrid/IceGrid.h
 */
struct NodeDescriptor
{
    /**
     * The variables defined for the node.
     */
    ::IceGrid::StringStringDict variables;
    /**
     * The server instances.
     */
    ::IceGrid::ServerInstanceDescriptorSeq serverInstances;
    /**
     * Servers (which are not template instances).
     */
    ::IceGrid::ServerDescriptorSeq servers;
    /**
     * Load factor of the node.
     */
    ::std::string loadFactor;
    /**
     * The description of this node.
     */
    ::std::string description;
    /**
     * Property set descriptors.
     */
    ::IceGrid::PropertySetDescriptorDict propertySets;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::IceGrid::StringStringDict&, const ::IceGrid::ServerInstanceDescriptorSeq&, const ::IceGrid::ServerDescriptorSeq&, const ::std::string&, const ::std::string&, const ::IceGrid::PropertySetDescriptorDict&> ice_tuple() const
    {
        return std::tie(variables, serverInstances, servers, loadFactor, description, propertySets);
    }
};

/**
 * A replica group descriptor.
 * \headerfile IceGrid/IceGrid.h
 */
struct ReplicaGroupDescriptor
{
    /**
     * The id of the replica group.
     */
    ::std::string id;
    /**
     * The load balancing policy.
     */
    ::std::shared_ptr<::IceGrid::LoadBalancingPolicy> loadBalancing;
    /**
     * Default options for proxies created for the replica group.
     */
    ::std::string proxyOptions;
    /**
     * The object descriptors associated with this object adapter.
     */
    ::IceGrid::ObjectDescriptorSeq objects;
    /**
     * The description of this replica group.
     */
    ::std::string description;
    /**
     * The filter to use for this replica group.
     */
    ::std::string filter;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::std::shared_ptr<::IceGrid::LoadBalancingPolicy>&, const ::std::string&, const ::IceGrid::ObjectDescriptorSeq&, const ::std::string&, const ::std::string&> ice_tuple() const
    {
        return std::tie(id, loadBalancing, proxyOptions, objects, description, filter);
    }
};

/**
 * An application descriptor.
 * \headerfile IceGrid/IceGrid.h
 */
struct ApplicationDescriptor
{
    /**
     * The application name.
     */
    ::std::string name;
    /**
     * The variables defined in the application descriptor.
     */
    ::IceGrid::StringStringDict variables;
    /**
     * The replica groups.
     */
    ::IceGrid::ReplicaGroupDescriptorSeq replicaGroups;
    /**
     * The server templates.
     */
    ::IceGrid::TemplateDescriptorDict serverTemplates;
    /**
     * The service templates.
     */
    ::IceGrid::TemplateDescriptorDict serviceTemplates;
    /**
     * The application nodes.
     */
    ::IceGrid::NodeDescriptorDict nodes;
    /**
     * The application distribution.
     */
    ::IceGrid::DistributionDescriptor distrib;
    /**
     * The description of this application.
     */
    ::std::string description;
    /**
     * Property set descriptors.
     */
    ::IceGrid::PropertySetDescriptorDict propertySets;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::IceGrid::StringStringDict&, const ::IceGrid::ReplicaGroupDescriptorSeq&, const ::IceGrid::TemplateDescriptorDict&, const ::IceGrid::TemplateDescriptorDict&, const ::IceGrid::NodeDescriptorDict&, const ::IceGrid::DistributionDescriptor&, const ::std::string&, const ::IceGrid::PropertySetDescriptorDict&> ice_tuple() const
    {
        return std::tie(name, variables, replicaGroups, serverTemplates, serviceTemplates, nodes, distrib, description, propertySets);
    }
};

/**
 * A node update descriptor to describe the updates to apply to a node of a deployed application.
 * \headerfile IceGrid/IceGrid.h
 */
struct NodeUpdateDescriptor
{
    /**
     * The name of the node to update.
     */
    ::std::string name;
    /**
     * The updated description (or null if the description wasn't updated.)
     */
    ::std::shared_ptr<::IceGrid::BoxedString> description;
    /**
     * The variables to update.
     */
    ::IceGrid::StringStringDict variables;
    /**
     * The variables to remove.
     */
    ::Ice::StringSeq removeVariables;
    /**
     * The property sets to update.
     */
    ::IceGrid::PropertySetDescriptorDict propertySets;
    /**
     * The property sets to remove.
     */
    ::Ice::StringSeq removePropertySets;
    /**
     * The server instances to update.
     */
    ::IceGrid::ServerInstanceDescriptorSeq serverInstances;
    /**
     * The servers which are not template instances to update.
     */
    ::IceGrid::ServerDescriptorSeq servers;
    /**
     * The ids of the servers to remove.
     */
    ::Ice::StringSeq removeServers;
    /**
     * The updated load factor of the node (or null if the load factor was not updated).
     */
    ::std::shared_ptr<::IceGrid::BoxedString> loadFactor;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::std::shared_ptr<::IceGrid::BoxedString>&, const ::IceGrid::StringStringDict&, const ::Ice::StringSeq&, const ::IceGrid::PropertySetDescriptorDict&, const ::Ice::StringSeq&, const ::IceGrid::ServerInstanceDescriptorSeq&, const ::IceGrid::ServerDescriptorSeq&, const ::Ice::StringSeq&, const ::std::shared_ptr<::IceGrid::BoxedString>&> ice_tuple() const
    {
        return std::tie(name, description, variables, removeVariables, propertySets, removePropertySets, serverInstances, servers, removeServers, loadFactor);
    }
};

/**
 * An application update descriptor to describe the updates to apply to a deployed application.
 * \headerfile IceGrid/IceGrid.h
 */
struct ApplicationUpdateDescriptor
{
    /**
     * The name of the application to update.
     */
    ::std::string name;
    /**
     * The updated description (or null if the description wasn't updated.)
     */
    ::std::shared_ptr<::IceGrid::BoxedString> description;
    /**
     * The updated distribution application descriptor.
     */
    ::std::shared_ptr<::IceGrid::BoxedDistributionDescriptor> distrib;
    /**
     * The variables to update.
     */
    ::IceGrid::StringStringDict variables;
    /**
     * The variables to remove.
     */
    ::Ice::StringSeq removeVariables;
    /**
     * The property sets to update.
     */
    ::IceGrid::PropertySetDescriptorDict propertySets;
    /**
     * The property sets to remove.
     */
    ::Ice::StringSeq removePropertySets;
    /**
     * The replica groups to update.
     */
    ::IceGrid::ReplicaGroupDescriptorSeq replicaGroups;
    /**
     * The replica groups to remove.
     */
    ::Ice::StringSeq removeReplicaGroups;
    /**
     * The server templates to update.
     */
    ::IceGrid::TemplateDescriptorDict serverTemplates;
    /**
     * The ids of the server template to remove.
     */
    ::Ice::StringSeq removeServerTemplates;
    /**
     * The service templates to update.
     */
    ::IceGrid::TemplateDescriptorDict serviceTemplates;
    /**
     * The ids of the service template to remove.
     */
    ::Ice::StringSeq removeServiceTemplates;
    /**
     * The application nodes to update.
     */
    ::IceGrid::NodeUpdateDescriptorSeq nodes;
    /**
     * The nodes to remove.
     */
    ::Ice::StringSeq removeNodes;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::std::shared_ptr<::IceGrid::BoxedString>&, const ::std::shared_ptr<::IceGrid::BoxedDistributionDescriptor>&, const ::IceGrid::StringStringDict&, const ::Ice::StringSeq&, const ::IceGrid::PropertySetDescriptorDict&, const ::Ice::StringSeq&, const ::IceGrid::ReplicaGroupDescriptorSeq&, const ::Ice::StringSeq&, const ::IceGrid::TemplateDescriptorDict&, const ::Ice::StringSeq&, const ::IceGrid::TemplateDescriptorDict&, const ::Ice::StringSeq&, const ::IceGrid::NodeUpdateDescriptorSeq&, const ::Ice::StringSeq&> ice_tuple() const
    {
        return std::tie(name, description, distrib, variables, removeVariables, propertySets, removePropertySets, replicaGroups, removeReplicaGroups, serverTemplates, removeServerTemplates, serviceTemplates, removeServiceTemplates, nodes, removeNodes);
    }
};

using Ice::operator<;
using Ice::operator<=;
using Ice::operator>;
using Ice::operator>=;
using Ice::operator==;
using Ice::operator!=;

}

namespace IceGrid
{

/**
 * A communicator descriptor.
 * \headerfile IceGrid/IceGrid.h
 */
class ICE_CLASS(ICEGRID_API) CommunicatorDescriptor : public ::Ice::ValueHelper<CommunicatorDescriptor, ::Ice::Value>
{
public:

    ICE_MEMBER(ICEGRID_API) virtual ~CommunicatorDescriptor();

    CommunicatorDescriptor() = default;

    CommunicatorDescriptor(const CommunicatorDescriptor&) = default;
    CommunicatorDescriptor(CommunicatorDescriptor&&) = default;
    CommunicatorDescriptor& operator=(const CommunicatorDescriptor&) = default;
    CommunicatorDescriptor& operator=(CommunicatorDescriptor&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     * @param adapters The object adapters.
     * @param propertySet The property set.
     * @param logs The path of each log file.
     * @param description A description of this descriptor.
     */
    CommunicatorDescriptor(const ::IceGrid::AdapterDescriptorSeq& adapters, const ::IceGrid::PropertySetDescriptor& propertySet, const ::Ice::StringSeq& logs, const ::std::string& description) :
        adapters(adapters),
        propertySet(propertySet),
        logs(logs),
        description(description)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::IceGrid::AdapterDescriptorSeq&, const ::IceGrid::PropertySetDescriptor&, const ::Ice::StringSeq&, const ::std::string&> ice_tuple() const
    {
        return std::tie(adapters, propertySet, logs, description);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    ICE_MEMBER(ICEGRID_API) static const ::std::string& ice_staticId();

    /**
     * The object adapters.
     */
    ::IceGrid::AdapterDescriptorSeq adapters;
    /**
     * The property set.
     */
    ::IceGrid::PropertySetDescriptor propertySet;
    /**
     * The path of each log file.
     */
    ::Ice::StringSeq logs;
    /**
     * A description of this descriptor.
     */
    ::std::string description;
};

/// \cond INTERNAL
static CommunicatorDescriptor _iceS_CommunicatorDescriptor_init;
/// \endcond

/**
 * An Ice server descriptor.
 * \headerfile IceGrid/IceGrid.h
 */
class ICE_CLASS(ICEGRID_API) ServerDescriptor : public ::Ice::ValueHelper<ServerDescriptor, CommunicatorDescriptor>
{
public:

    ICE_MEMBER(ICEGRID_API) virtual ~ServerDescriptor();

    ServerDescriptor() = default;

    ServerDescriptor(const ServerDescriptor&) = default;
    ServerDescriptor(ServerDescriptor&&) = default;
    ServerDescriptor& operator=(const ServerDescriptor&) = default;
    ServerDescriptor& operator=(ServerDescriptor&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     * @param adapters The object adapters.
     * @param propertySet The property set.
     * @param logs The path of each log file.
     * @param description A description of this descriptor.
     * @param id The server id.
     * @param exe The path of the server executable.
     * @param iceVersion The Ice version used by this server.
     * @param pwd The path to the server working directory.
     * @param options The command line options to pass to the server executable.
     * @param envs The server environment variables.
     * @param activation / The server activation mode (possible values are "on-demand" or "manual").
     * @param activationTimeout The activation timeout (an integer value representing the number of seconds to wait for activation).
     * @param deactivationTimeout The deactivation timeout (an integer value representing the number of seconds to wait for deactivation).
     * @param applicationDistrib Specifies if the server depends on the application distribution.
     * @param distrib The distribution descriptor.
     * @param allocatable Specifies if the server is allocatable.
     * @param user The user account used to run the server.
     */
    ServerDescriptor(const ::IceGrid::AdapterDescriptorSeq& adapters, const ::IceGrid::PropertySetDescriptor& propertySet, const ::Ice::StringSeq& logs, const ::std::string& description, const ::std::string& id, const ::std::string& exe, const ::std::string& iceVersion, const ::std::string& pwd, const ::Ice::StringSeq& options, const ::Ice::StringSeq& envs, const ::std::string& activation, const ::std::string& activationTimeout, const ::std::string& deactivationTimeout, bool applicationDistrib, const ::IceGrid::DistributionDescriptor& distrib, bool allocatable, const ::std::string& user) :
        Ice::ValueHelper<ServerDescriptor, CommunicatorDescriptor>(adapters, propertySet, logs, description),
        id(id),
        exe(exe),
        iceVersion(iceVersion),
        pwd(pwd),
        options(options),
        envs(envs),
        activation(activation),
        activationTimeout(activationTimeout),
        deactivationTimeout(deactivationTimeout),
        applicationDistrib(applicationDistrib),
        distrib(distrib),
        allocatable(allocatable),
        user(user)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::IceGrid::AdapterDescriptorSeq&, const ::IceGrid::PropertySetDescriptor&, const ::Ice::StringSeq&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::Ice::StringSeq&, const ::Ice::StringSeq&, const ::std::string&, const ::std::string&, const ::std::string&, const bool&, const ::IceGrid::DistributionDescriptor&, const bool&, const ::std::string&> ice_tuple() const
    {
        return std::tie(adapters, propertySet, logs, description, id, exe, iceVersion, pwd, options, envs, activation, activationTimeout, deactivationTimeout, applicationDistrib, distrib, allocatable, user);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    ICE_MEMBER(ICEGRID_API) static const ::std::string& ice_staticId();

    /**
     * The server id.
     */
    ::std::string id;
    /**
     * The path of the server executable.
     */
    ::std::string exe;
    /**
     * The Ice version used by this server. This is only required if backward compatibility with servers using old
     * Ice versions is needed (otherwise the registry will assume the server is using the same Ice version).
     * For example "3.1.1", "3.2", "3.3.0".
     */
    ::std::string iceVersion;
    /**
     * The path to the server working directory.
     */
    ::std::string pwd;
    /**
     * The command line options to pass to the server executable.
     */
    ::Ice::StringSeq options;
    /**
     * The server environment variables.
     */
    ::Ice::StringSeq envs;
    /**
     * / The server activation mode (possible values are "on-demand" or "manual").
     */
    ::std::string activation;
    /**
     * The activation timeout (an integer value representing the number of seconds to wait for activation).
     */
    ::std::string activationTimeout;
    /**
     * The deactivation timeout (an integer value representing the number of seconds to wait for deactivation).
     */
    ::std::string deactivationTimeout;
    /**
     * Specifies if the server depends on the application distribution.
     */
    bool applicationDistrib;
    /**
     * The distribution descriptor.
     */
    ::IceGrid::DistributionDescriptor distrib;
    /**
     * Specifies if the server is allocatable.
     */
    bool allocatable;
    /**
     * The user account used to run the server.
     */
    ::std::string user;
};

/**
 * An IceBox service descriptor.
 * \headerfile IceGrid/IceGrid.h
 */
class ICE_CLASS(ICEGRID_API) ServiceDescriptor : public ::Ice::ValueHelper<ServiceDescriptor, CommunicatorDescriptor>
{
public:

    ICE_MEMBER(ICEGRID_API) virtual ~ServiceDescriptor();

    ServiceDescriptor() = default;

    ServiceDescriptor(const ServiceDescriptor&) = default;
    ServiceDescriptor(ServiceDescriptor&&) = default;
    ServiceDescriptor& operator=(const ServiceDescriptor&) = default;
    ServiceDescriptor& operator=(ServiceDescriptor&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     * @param adapters The object adapters.
     * @param propertySet The property set.
     * @param logs The path of each log file.
     * @param description A description of this descriptor.
     * @param name The service name.
     * @param entry The entry point of the IceBox service.
     */
    ServiceDescriptor(const ::IceGrid::AdapterDescriptorSeq& adapters, const ::IceGrid::PropertySetDescriptor& propertySet, const ::Ice::StringSeq& logs, const ::std::string& description, const ::std::string& name, const ::std::string& entry) :
        Ice::ValueHelper<ServiceDescriptor, CommunicatorDescriptor>(adapters, propertySet, logs, description),
        name(name),
        entry(entry)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::IceGrid::AdapterDescriptorSeq&, const ::IceGrid::PropertySetDescriptor&, const ::Ice::StringSeq&, const ::std::string&, const ::std::string&, const ::std::string&> ice_tuple() const
    {
        return std::tie(adapters, propertySet, logs, description, name, entry);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    ICE_MEMBER(ICEGRID_API) static const ::std::string& ice_staticId();

    /**
     * The service name.
     */
    ::std::string name;
    /**
     * The entry point of the IceBox service.
     */
    ::std::string entry;
};

/**
 * An IceBox server descriptor.
 * \headerfile IceGrid/IceGrid.h
 */
class ICE_CLASS(ICEGRID_API) IceBoxDescriptor : public ::Ice::ValueHelper<IceBoxDescriptor, ServerDescriptor>
{
public:

    ICE_MEMBER(ICEGRID_API) virtual ~IceBoxDescriptor();

    IceBoxDescriptor() = default;

    IceBoxDescriptor(const IceBoxDescriptor&) = default;
    IceBoxDescriptor(IceBoxDescriptor&&) = default;
    IceBoxDescriptor& operator=(const IceBoxDescriptor&) = default;
    IceBoxDescriptor& operator=(IceBoxDescriptor&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     * @param adapters The object adapters.
     * @param propertySet The property set.
     * @param logs The path of each log file.
     * @param description A description of this descriptor.
     * @param id The server id.
     * @param exe The path of the server executable.
     * @param iceVersion The Ice version used by this server.
     * @param pwd The path to the server working directory.
     * @param options The command line options to pass to the server executable.
     * @param envs The server environment variables.
     * @param activation / The server activation mode (possible values are "on-demand" or "manual").
     * @param activationTimeout The activation timeout (an integer value representing the number of seconds to wait for activation).
     * @param deactivationTimeout The deactivation timeout (an integer value representing the number of seconds to wait for deactivation).
     * @param applicationDistrib Specifies if the server depends on the application distribution.
     * @param distrib The distribution descriptor.
     * @param allocatable Specifies if the server is allocatable.
     * @param user The user account used to run the server.
     * @param services The service instances.
     */
    IceBoxDescriptor(const ::IceGrid::AdapterDescriptorSeq& adapters, const ::IceGrid::PropertySetDescriptor& propertySet, const ::Ice::StringSeq& logs, const ::std::string& description, const ::std::string& id, const ::std::string& exe, const ::std::string& iceVersion, const ::std::string& pwd, const ::Ice::StringSeq& options, const ::Ice::StringSeq& envs, const ::std::string& activation, const ::std::string& activationTimeout, const ::std::string& deactivationTimeout, bool applicationDistrib, const ::IceGrid::DistributionDescriptor& distrib, bool allocatable, const ::std::string& user, const ::IceGrid::ServiceInstanceDescriptorSeq& services) :
        Ice::ValueHelper<IceBoxDescriptor, ServerDescriptor>(adapters, propertySet, logs, description, id, exe, iceVersion, pwd, options, envs, activation, activationTimeout, deactivationTimeout, applicationDistrib, distrib, allocatable, user),
        services(services)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::IceGrid::AdapterDescriptorSeq&, const ::IceGrid::PropertySetDescriptor&, const ::Ice::StringSeq&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::Ice::StringSeq&, const ::Ice::StringSeq&, const ::std::string&, const ::std::string&, const ::std::string&, const bool&, const ::IceGrid::DistributionDescriptor&, const bool&, const ::std::string&, const ::IceGrid::ServiceInstanceDescriptorSeq&> ice_tuple() const
    {
        return std::tie(adapters, propertySet, logs, description, id, exe, iceVersion, pwd, options, envs, activation, activationTimeout, deactivationTimeout, applicationDistrib, distrib, allocatable, user, services);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    ICE_MEMBER(ICEGRID_API) static const ::std::string& ice_staticId();

    /**
     * The service instances.
     */
    ::IceGrid::ServiceInstanceDescriptorSeq services;
};

/**
 * A base class for load balancing policies.
 * \headerfile IceGrid/IceGrid.h
 */
class ICE_CLASS(ICEGRID_API) LoadBalancingPolicy : public ::Ice::ValueHelper<LoadBalancingPolicy, ::Ice::Value>
{
public:

    ICE_MEMBER(ICEGRID_API) virtual ~LoadBalancingPolicy();

    LoadBalancingPolicy() = default;

    LoadBalancingPolicy(const LoadBalancingPolicy&) = default;
    LoadBalancingPolicy(LoadBalancingPolicy&&) = default;
    LoadBalancingPolicy& operator=(const LoadBalancingPolicy&) = default;
    LoadBalancingPolicy& operator=(LoadBalancingPolicy&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     * @param nReplicas The number of replicas that will be used to gather the endpoints of a replica group.
     */
    explicit LoadBalancingPolicy(const ::std::string& nReplicas) :
        nReplicas(nReplicas)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&> ice_tuple() const
    {
        return std::tie(nReplicas);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    ICE_MEMBER(ICEGRID_API) static const ::std::string& ice_staticId();

    /**
     * The number of replicas that will be used to gather the endpoints of a replica group.
     */
    ::std::string nReplicas;
};

/**
 * Random load balancing policy.
 * \headerfile IceGrid/IceGrid.h
 */
class ICE_CLASS(ICEGRID_API) RandomLoadBalancingPolicy : public ::Ice::ValueHelper<RandomLoadBalancingPolicy, LoadBalancingPolicy>
{
public:

    ICE_MEMBER(ICEGRID_API) virtual ~RandomLoadBalancingPolicy();

    RandomLoadBalancingPolicy() = default;

    RandomLoadBalancingPolicy(const RandomLoadBalancingPolicy&) = default;
    RandomLoadBalancingPolicy(RandomLoadBalancingPolicy&&) = default;
    RandomLoadBalancingPolicy& operator=(const RandomLoadBalancingPolicy&) = default;
    RandomLoadBalancingPolicy& operator=(RandomLoadBalancingPolicy&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     * @param nReplicas The number of replicas that will be used to gather the endpoints of a replica group.
     */
    explicit RandomLoadBalancingPolicy(const ::std::string& nReplicas) :
        Ice::ValueHelper<RandomLoadBalancingPolicy, LoadBalancingPolicy>(nReplicas)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&> ice_tuple() const
    {
        return std::tie(nReplicas);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    ICE_MEMBER(ICEGRID_API) static const ::std::string& ice_staticId();
};

/**
 * Ordered load balancing policy.
 * \headerfile IceGrid/IceGrid.h
 */
class ICE_CLASS(ICEGRID_API) OrderedLoadBalancingPolicy : public ::Ice::ValueHelper<OrderedLoadBalancingPolicy, LoadBalancingPolicy>
{
public:

    ICE_MEMBER(ICEGRID_API) virtual ~OrderedLoadBalancingPolicy();

    OrderedLoadBalancingPolicy() = default;

    OrderedLoadBalancingPolicy(const OrderedLoadBalancingPolicy&) = default;
    OrderedLoadBalancingPolicy(OrderedLoadBalancingPolicy&&) = default;
    OrderedLoadBalancingPolicy& operator=(const OrderedLoadBalancingPolicy&) = default;
    OrderedLoadBalancingPolicy& operator=(OrderedLoadBalancingPolicy&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     * @param nReplicas The number of replicas that will be used to gather the endpoints of a replica group.
     */
    explicit OrderedLoadBalancingPolicy(const ::std::string& nReplicas) :
        Ice::ValueHelper<OrderedLoadBalancingPolicy, LoadBalancingPolicy>(nReplicas)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&> ice_tuple() const
    {
        return std::tie(nReplicas);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    ICE_MEMBER(ICEGRID_API) static const ::std::string& ice_staticId();
};

/**
 * Round robin load balancing policy.
 * \headerfile IceGrid/IceGrid.h
 */
class ICE_CLASS(ICEGRID_API) RoundRobinLoadBalancingPolicy : public ::Ice::ValueHelper<RoundRobinLoadBalancingPolicy, LoadBalancingPolicy>
{
public:

    ICE_MEMBER(ICEGRID_API) virtual ~RoundRobinLoadBalancingPolicy();

    RoundRobinLoadBalancingPolicy() = default;

    RoundRobinLoadBalancingPolicy(const RoundRobinLoadBalancingPolicy&) = default;
    RoundRobinLoadBalancingPolicy(RoundRobinLoadBalancingPolicy&&) = default;
    RoundRobinLoadBalancingPolicy& operator=(const RoundRobinLoadBalancingPolicy&) = default;
    RoundRobinLoadBalancingPolicy& operator=(RoundRobinLoadBalancingPolicy&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     * @param nReplicas The number of replicas that will be used to gather the endpoints of a replica group.
     */
    explicit RoundRobinLoadBalancingPolicy(const ::std::string& nReplicas) :
        Ice::ValueHelper<RoundRobinLoadBalancingPolicy, LoadBalancingPolicy>(nReplicas)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&> ice_tuple() const
    {
        return std::tie(nReplicas);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    ICE_MEMBER(ICEGRID_API) static const ::std::string& ice_staticId();
};

/**
 * Adaptive load balancing policy.
 * \headerfile IceGrid/IceGrid.h
 */
class ICE_CLASS(ICEGRID_API) AdaptiveLoadBalancingPolicy : public ::Ice::ValueHelper<AdaptiveLoadBalancingPolicy, LoadBalancingPolicy>
{
public:

    ICE_MEMBER(ICEGRID_API) virtual ~AdaptiveLoadBalancingPolicy();

    AdaptiveLoadBalancingPolicy() = default;

    AdaptiveLoadBalancingPolicy(const AdaptiveLoadBalancingPolicy&) = default;
    AdaptiveLoadBalancingPolicy(AdaptiveLoadBalancingPolicy&&) = default;
    AdaptiveLoadBalancingPolicy& operator=(const AdaptiveLoadBalancingPolicy&) = default;
    AdaptiveLoadBalancingPolicy& operator=(AdaptiveLoadBalancingPolicy&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     * @param nReplicas The number of replicas that will be used to gather the endpoints of a replica group.
     * @param loadSample The load sample to use for the load balancing.
     */
    AdaptiveLoadBalancingPolicy(const ::std::string& nReplicas, const ::std::string& loadSample) :
        Ice::ValueHelper<AdaptiveLoadBalancingPolicy, LoadBalancingPolicy>(nReplicas),
        loadSample(loadSample)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::std::string&> ice_tuple() const
    {
        return std::tie(nReplicas, loadSample);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    ICE_MEMBER(ICEGRID_API) static const ::std::string& ice_staticId();

    /**
     * The load sample to use for the load balancing. The allowed values for this attribute are "1", "5" and "15",
     * representing respectively the load average over the past minute, the past 5 minutes and the past 15 minutes.
     */
    ::std::string loadSample;
};

/**
 * A "boxed" string.
 * \headerfile IceGrid/IceGrid.h
 */
class ICE_CLASS(ICEGRID_API) BoxedString : public ::Ice::ValueHelper<BoxedString, ::Ice::Value>
{
public:

    ICE_MEMBER(ICEGRID_API) virtual ~BoxedString();

    BoxedString() = default;

    BoxedString(const BoxedString&) = default;
    BoxedString(BoxedString&&) = default;
    BoxedString& operator=(const BoxedString&) = default;
    BoxedString& operator=(BoxedString&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     * @param value The value of the boxed string.
     */
    explicit BoxedString(const ::std::string& value) :
        value(value)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&> ice_tuple() const
    {
        return std::tie(value);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    ICE_MEMBER(ICEGRID_API) static const ::std::string& ice_staticId();

    /**
     * The value of the boxed string.
     */
    ::std::string value;
};

/**
 * A "boxed" distribution descriptor.
 * \headerfile IceGrid/IceGrid.h
 */
class ICE_CLASS(ICEGRID_API) BoxedDistributionDescriptor : public ::Ice::ValueHelper<BoxedDistributionDescriptor, ::Ice::Value>
{
public:

    ICE_MEMBER(ICEGRID_API) virtual ~BoxedDistributionDescriptor();

    BoxedDistributionDescriptor() = default;

    BoxedDistributionDescriptor(const BoxedDistributionDescriptor&) = default;
    BoxedDistributionDescriptor(BoxedDistributionDescriptor&&) = default;
    BoxedDistributionDescriptor& operator=(const BoxedDistributionDescriptor&) = default;
    BoxedDistributionDescriptor& operator=(BoxedDistributionDescriptor&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     * @param value The value of the boxed distribution descriptor.
     */
    explicit BoxedDistributionDescriptor(const ::IceGrid::DistributionDescriptor& value) :
        value(value)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::IceGrid::DistributionDescriptor&> ice_tuple() const
    {
        return std::tie(value);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    ICE_MEMBER(ICEGRID_API) static const ::std::string& ice_staticId();

    /**
     * The value of the boxed distribution descriptor.
     */
    ::IceGrid::DistributionDescriptor value;
};

}

/// \cond STREAM
namespace Ice
{

template<>
struct StreamableTraits<::IceGrid::PropertyDescriptor>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 2;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::IceGrid::PropertyDescriptor, S>
{
    static void read(S* istr, ::IceGrid::PropertyDescriptor& v)
    {
        istr->readAll(v.name, v.value);
    }
};

template<>
struct StreamableTraits<::IceGrid::PropertySetDescriptor>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 2;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::IceGrid::PropertySetDescriptor, S>
{
    static void read(S* istr, ::IceGrid::PropertySetDescriptor& v)
    {
        istr->readAll(v.references, v.properties);
    }
};

template<>
struct StreamableTraits<::IceGrid::ObjectDescriptor>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 4;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::IceGrid::ObjectDescriptor, S>
{
    static void read(S* istr, ::IceGrid::ObjectDescriptor& v)
    {
        istr->readAll(v.id, v.type, v.proxyOptions);
    }
};

template<>
struct StreamableTraits<::IceGrid::AdapterDescriptor>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 9;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::IceGrid::AdapterDescriptor, S>
{
    static void read(S* istr, ::IceGrid::AdapterDescriptor& v)
    {
        istr->readAll(v.name, v.description, v.id, v.replicaGroupId, v.priority, v.registerProcess, v.serverLifetime, v.objects, v.allocatables);
    }
};

template<typename S>
struct StreamReader<::IceGrid::CommunicatorDescriptor, S>
{
    static void read(S* istr, ::IceGrid::CommunicatorDescriptor& v)
    {
        istr->readAll(v.adapters, v.propertySet, v.logs, v.description);
    }
};

template<>
struct StreamableTraits<::IceGrid::DistributionDescriptor>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 2;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::IceGrid::DistributionDescriptor, S>
{
    static void read(S* istr, ::IceGrid::DistributionDescriptor& v)
    {
        istr->readAll(v.icepatch, v.directories);
    }
};

template<typename S>
struct StreamWriter<::IceGrid::ServerDescriptor, S>
{
    static void write(S* ostr, const ::IceGrid::ServerDescriptor& v)
    {
        ostr->writeAll(v.id, v.exe, v.iceVersion, v.pwd, v.options, v.envs, v.activation, v.activationTimeout, v.deactivationTimeout, v.applicationDistrib, v.distrib, v.allocatable, v.user);
    }
};

template<typename S>
struct StreamReader<::IceGrid::ServerDescriptor, S>
{
    static void read(S* istr, ::IceGrid::ServerDescriptor& v)
    {
        istr->readAll(v.id, v.exe, v.iceVersion, v.pwd, v.options, v.envs, v.activation, v.activationTimeout, v.deactivationTimeout, v.applicationDistrib, v.distrib, v.allocatable, v.user);
    }
};

template<typename S>
struct StreamWriter<::IceGrid::ServiceDescriptor, S>
{
    static void write(S* ostr, const ::IceGrid::ServiceDescriptor& v)
    {
        ostr->writeAll(v.name, v.entry);
    }
};

template<typename S>
struct StreamReader<::IceGrid::ServiceDescriptor, S>
{
    static void read(S* istr, ::IceGrid::ServiceDescriptor& v)
    {
        istr->readAll(v.name, v.entry);
    }
};

template<>
struct StreamableTraits<::IceGrid::ServerInstanceDescriptor>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 5;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::IceGrid::ServerInstanceDescriptor, S>
{
    static void read(S* istr, ::IceGrid::ServerInstanceDescriptor& v)
    {
        istr->readAll(v._cpp_template, v.parameterValues, v.propertySet, v.servicePropertySets);
    }
};

template<>
struct StreamableTraits<::IceGrid::TemplateDescriptor>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 3;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::IceGrid::TemplateDescriptor, S>
{
    static void read(S* istr, ::IceGrid::TemplateDescriptor& v)
    {
        istr->readAll(v.descriptor, v.parameters, v.parameterDefaults);
    }
};

template<>
struct StreamableTraits<::IceGrid::ServiceInstanceDescriptor>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 5;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::IceGrid::ServiceInstanceDescriptor, S>
{
    static void read(S* istr, ::IceGrid::ServiceInstanceDescriptor& v)
    {
        istr->readAll(v._cpp_template, v.parameterValues, v.descriptor, v.propertySet);
    }
};

template<typename S>
struct StreamWriter<::IceGrid::IceBoxDescriptor, S>
{
    static void write(S* ostr, const ::IceGrid::IceBoxDescriptor& v)
    {
        ostr->writeAll(v.services);
    }
};

template<typename S>
struct StreamReader<::IceGrid::IceBoxDescriptor, S>
{
    static void read(S* istr, ::IceGrid::IceBoxDescriptor& v)
    {
        istr->readAll(v.services);
    }
};

template<>
struct StreamableTraits<::IceGrid::NodeDescriptor>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 6;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::IceGrid::NodeDescriptor, S>
{
    static void read(S* istr, ::IceGrid::NodeDescriptor& v)
    {
        istr->readAll(v.variables, v.serverInstances, v.servers, v.loadFactor, v.description, v.propertySets);
    }
};

template<typename S>
struct StreamReader<::IceGrid::LoadBalancingPolicy, S>
{
    static void read(S* istr, ::IceGrid::LoadBalancingPolicy& v)
    {
        istr->readAll(v.nReplicas);
    }
};

template<typename S>
struct StreamWriter<::IceGrid::RandomLoadBalancingPolicy, S>
{
    static void write(S*, const ::IceGrid::RandomLoadBalancingPolicy&)
    {
    }
};

template<typename S>
struct StreamReader<::IceGrid::RandomLoadBalancingPolicy, S>
{
    static void read(S*, ::IceGrid::RandomLoadBalancingPolicy&)
    {
    }
};

template<typename S>
struct StreamWriter<::IceGrid::OrderedLoadBalancingPolicy, S>
{
    static void write(S*, const ::IceGrid::OrderedLoadBalancingPolicy&)
    {
    }
};

template<typename S>
struct StreamReader<::IceGrid::OrderedLoadBalancingPolicy, S>
{
    static void read(S*, ::IceGrid::OrderedLoadBalancingPolicy&)
    {
    }
};

template<typename S>
struct StreamWriter<::IceGrid::RoundRobinLoadBalancingPolicy, S>
{
    static void write(S*, const ::IceGrid::RoundRobinLoadBalancingPolicy&)
    {
    }
};

template<typename S>
struct StreamReader<::IceGrid::RoundRobinLoadBalancingPolicy, S>
{
    static void read(S*, ::IceGrid::RoundRobinLoadBalancingPolicy&)
    {
    }
};

template<typename S>
struct StreamWriter<::IceGrid::AdaptiveLoadBalancingPolicy, S>
{
    static void write(S* ostr, const ::IceGrid::AdaptiveLoadBalancingPolicy& v)
    {
        ostr->writeAll(v.loadSample);
    }
};

template<typename S>
struct StreamReader<::IceGrid::AdaptiveLoadBalancingPolicy, S>
{
    static void read(S* istr, ::IceGrid::AdaptiveLoadBalancingPolicy& v)
    {
        istr->readAll(v.loadSample);
    }
};

template<>
struct StreamableTraits<::IceGrid::ReplicaGroupDescriptor>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 6;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::IceGrid::ReplicaGroupDescriptor, S>
{
    static void read(S* istr, ::IceGrid::ReplicaGroupDescriptor& v)
    {
        istr->readAll(v.id, v.loadBalancing, v.proxyOptions, v.objects, v.description, v.filter);
    }
};

template<>
struct StreamableTraits<::IceGrid::ApplicationDescriptor>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 10;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::IceGrid::ApplicationDescriptor, S>
{
    static void read(S* istr, ::IceGrid::ApplicationDescriptor& v)
    {
        istr->readAll(v.name, v.variables, v.replicaGroups, v.serverTemplates, v.serviceTemplates, v.nodes, v.distrib, v.description, v.propertySets);
    }
};

template<typename S>
struct StreamReader<::IceGrid::BoxedString, S>
{
    static void read(S* istr, ::IceGrid::BoxedString& v)
    {
        istr->readAll(v.value);
    }
};

template<>
struct StreamableTraits<::IceGrid::NodeUpdateDescriptor>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 10;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::IceGrid::NodeUpdateDescriptor, S>
{
    static void read(S* istr, ::IceGrid::NodeUpdateDescriptor& v)
    {
        istr->readAll(v.name, v.description, v.variables, v.removeVariables, v.propertySets, v.removePropertySets, v.serverInstances, v.servers, v.removeServers, v.loadFactor);
    }
};

template<typename S>
struct StreamReader<::IceGrid::BoxedDistributionDescriptor, S>
{
    static void read(S* istr, ::IceGrid::BoxedDistributionDescriptor& v)
    {
        istr->readAll(v.value);
    }
};

template<>
struct StreamableTraits<::IceGrid::ApplicationUpdateDescriptor>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 15;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::IceGrid::ApplicationUpdateDescriptor, S>
{
    static void read(S* istr, ::IceGrid::ApplicationUpdateDescriptor& v)
    {
        istr->readAll(v.name, v.description, v.distrib, v.variables, v.removeVariables, v.propertySets, v.removePropertySets, v.replicaGroups, v.removeReplicaGroups, v.serverTemplates, v.removeServerTemplates, v.serviceTemplates, v.removeServiceTemplates, v.nodes, v.removeNodes);
    }
};

}
/// \endcond

/// \cond INTERNAL
namespace IceGrid
{

using CommunicatorDescriptorPtr = ::std::shared_ptr<CommunicatorDescriptor>;

using ServerDescriptorPtr = ::std::shared_ptr<ServerDescriptor>;

using ServiceDescriptorPtr = ::std::shared_ptr<ServiceDescriptor>;

using IceBoxDescriptorPtr = ::std::shared_ptr<IceBoxDescriptor>;

using LoadBalancingPolicyPtr = ::std::shared_ptr<LoadBalancingPolicy>;

using RandomLoadBalancingPolicyPtr = ::std::shared_ptr<RandomLoadBalancingPolicy>;

using OrderedLoadBalancingPolicyPtr = ::std::shared_ptr<OrderedLoadBalancingPolicy>;

using RoundRobinLoadBalancingPolicyPtr = ::std::shared_ptr<RoundRobinLoadBalancingPolicy>;

using AdaptiveLoadBalancingPolicyPtr = ::std::shared_ptr<AdaptiveLoadBalancingPolicy>;

using BoxedStringPtr = ::std::shared_ptr<BoxedString>;

using BoxedDistributionDescriptorPtr = ::std::shared_ptr<BoxedDistributionDescriptor>;

}
/// \endcond

#include <IceUtil/PopDisableWarnings.h>
#endif
