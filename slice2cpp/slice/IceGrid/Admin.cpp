//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.8.0-alpha.0
//
// <auto-generated>
//
// Generated from file `Admin.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef ICEGRID_API_EXPORTS
#   define ICEGRID_API_EXPORTS
#endif
#define ICE_BUILDING_GENERATED_CODE
#include <Admin.h>
#include <IceUtil/PushDisableWarnings.h>
#include <IceUtil/PopDisableWarnings.h>

#if defined(_MSC_VER)
#   pragma warning(disable:4458) // declaration of ... hides class member
#elif defined(__clang__)
#   pragma clang diagnostic ignored "-Wshadow"
#elif defined(__GNUC__)
#   pragma GCC diagnostic ignored "-Wshadow"
#endif

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION  != 30850
#       error Ice version mismatch: an exact match is required for beta generated code
#   endif
#endif

namespace
{

const ::std::string iceC_IceGrid_Admin_ids[2] =
{
    "::Ice::Object",
    "::IceGrid::Admin"
};
const ::std::string iceC_IceGrid_Admin_ops[] =
{
    "addApplication",
    "addObject",
    "addObjectWithType",
    "enableServer",
    "getAdapterInfo",
    "getAllAdapterIds",
    "getAllApplicationNames",
    "getAllNodeNames",
    "getAllObjectInfos",
    "getAllRegistryNames",
    "getAllServerIds",
    "getApplicationInfo",
    "getDefaultApplicationDescriptor",
    "getNodeAdmin",
    "getNodeHostname",
    "getNodeInfo",
    "getNodeLoad",
    "getNodeProcessorSocketCount",
    "getObjectInfo",
    "getObjectInfosByType",
    "getRegistryAdmin",
    "getRegistryInfo",
    "getServerAdmin",
    "getServerAdminCategory",
    "getServerInfo",
    "getServerPid",
    "getServerState",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "instantiateServer",
    "isServerEnabled",
    "patchApplication",
    "patchServer",
    "pingNode",
    "pingRegistry",
    "removeAdapter",
    "removeApplication",
    "removeObject",
    "sendSignal",
    "shutdown",
    "shutdownNode",
    "shutdownRegistry",
    "startServer",
    "stopServer",
    "syncApplication",
    "syncApplicationWithoutRestart",
    "updateApplication",
    "updateApplicationWithoutRestart",
    "updateObject"
};
const ::std::string iceC_IceGrid_Admin_addApplication_name = "addApplication";
const ::std::string iceC_IceGrid_Admin_syncApplication_name = "syncApplication";
const ::std::string iceC_IceGrid_Admin_updateApplication_name = "updateApplication";
const ::std::string iceC_IceGrid_Admin_syncApplicationWithoutRestart_name = "syncApplicationWithoutRestart";
const ::std::string iceC_IceGrid_Admin_updateApplicationWithoutRestart_name = "updateApplicationWithoutRestart";
const ::std::string iceC_IceGrid_Admin_removeApplication_name = "removeApplication";
const ::std::string iceC_IceGrid_Admin_instantiateServer_name = "instantiateServer";
const ::std::string iceC_IceGrid_Admin_patchApplication_name = "patchApplication";
const ::std::string iceC_IceGrid_Admin_getApplicationInfo_name = "getApplicationInfo";
const ::std::string iceC_IceGrid_Admin_getDefaultApplicationDescriptor_name = "getDefaultApplicationDescriptor";
const ::std::string iceC_IceGrid_Admin_getAllApplicationNames_name = "getAllApplicationNames";
const ::std::string iceC_IceGrid_Admin_getServerInfo_name = "getServerInfo";
const ::std::string iceC_IceGrid_Admin_getServerState_name = "getServerState";
const ::std::string iceC_IceGrid_Admin_getServerPid_name = "getServerPid";
const ::std::string iceC_IceGrid_Admin_getServerAdminCategory_name = "getServerAdminCategory";
const ::std::string iceC_IceGrid_Admin_getServerAdmin_name = "getServerAdmin";
const ::std::string iceC_IceGrid_Admin_enableServer_name = "enableServer";
const ::std::string iceC_IceGrid_Admin_isServerEnabled_name = "isServerEnabled";
const ::std::string iceC_IceGrid_Admin_startServer_name = "startServer";
const ::std::string iceC_IceGrid_Admin_stopServer_name = "stopServer";
const ::std::string iceC_IceGrid_Admin_patchServer_name = "patchServer";
const ::std::string iceC_IceGrid_Admin_sendSignal_name = "sendSignal";
const ::std::string iceC_IceGrid_Admin_getAllServerIds_name = "getAllServerIds";
const ::std::string iceC_IceGrid_Admin_getAdapterInfo_name = "getAdapterInfo";
const ::std::string iceC_IceGrid_Admin_removeAdapter_name = "removeAdapter";
const ::std::string iceC_IceGrid_Admin_getAllAdapterIds_name = "getAllAdapterIds";
const ::std::string iceC_IceGrid_Admin_addObject_name = "addObject";
const ::std::string iceC_IceGrid_Admin_updateObject_name = "updateObject";
const ::std::string iceC_IceGrid_Admin_addObjectWithType_name = "addObjectWithType";
const ::std::string iceC_IceGrid_Admin_removeObject_name = "removeObject";
const ::std::string iceC_IceGrid_Admin_getObjectInfo_name = "getObjectInfo";
const ::std::string iceC_IceGrid_Admin_getObjectInfosByType_name = "getObjectInfosByType";
const ::std::string iceC_IceGrid_Admin_getAllObjectInfos_name = "getAllObjectInfos";
const ::std::string iceC_IceGrid_Admin_pingNode_name = "pingNode";
const ::std::string iceC_IceGrid_Admin_getNodeLoad_name = "getNodeLoad";
const ::std::string iceC_IceGrid_Admin_getNodeInfo_name = "getNodeInfo";
const ::std::string iceC_IceGrid_Admin_getNodeAdmin_name = "getNodeAdmin";
const ::std::string iceC_IceGrid_Admin_getNodeProcessorSocketCount_name = "getNodeProcessorSocketCount";
const ::std::string iceC_IceGrid_Admin_shutdownNode_name = "shutdownNode";
const ::std::string iceC_IceGrid_Admin_getNodeHostname_name = "getNodeHostname";
const ::std::string iceC_IceGrid_Admin_getAllNodeNames_name = "getAllNodeNames";
const ::std::string iceC_IceGrid_Admin_pingRegistry_name = "pingRegistry";
const ::std::string iceC_IceGrid_Admin_getRegistryInfo_name = "getRegistryInfo";
const ::std::string iceC_IceGrid_Admin_getRegistryAdmin_name = "getRegistryAdmin";
const ::std::string iceC_IceGrid_Admin_shutdownRegistry_name = "shutdownRegistry";
const ::std::string iceC_IceGrid_Admin_getAllRegistryNames_name = "getAllRegistryNames";
const ::std::string iceC_IceGrid_Admin_shutdown_name = "shutdown";

const ::std::string iceC_IceGrid_FileIterator_ids[2] =
{
    "::Ice::Object",
    "::IceGrid::FileIterator"
};
const ::std::string iceC_IceGrid_FileIterator_ops[] =
{
    "destroy",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "read"
};
const ::std::string iceC_IceGrid_FileIterator_read_name = "read";
const ::std::string iceC_IceGrid_FileIterator_destroy_name = "destroy";

const ::std::string iceC_IceGrid_RegistryObserver_ids[2] =
{
    "::Ice::Object",
    "::IceGrid::RegistryObserver"
};
const ::std::string iceC_IceGrid_RegistryObserver_ops[] =
{
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "registryDown",
    "registryInit",
    "registryUp"
};
const ::std::string iceC_IceGrid_RegistryObserver_registryInit_name = "registryInit";
const ::std::string iceC_IceGrid_RegistryObserver_registryUp_name = "registryUp";
const ::std::string iceC_IceGrid_RegistryObserver_registryDown_name = "registryDown";

const ::std::string iceC_IceGrid_NodeObserver_ids[2] =
{
    "::Ice::Object",
    "::IceGrid::NodeObserver"
};
const ::std::string iceC_IceGrid_NodeObserver_ops[] =
{
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "nodeDown",
    "nodeInit",
    "nodeUp",
    "updateAdapter",
    "updateServer"
};
const ::std::string iceC_IceGrid_NodeObserver_nodeInit_name = "nodeInit";
const ::std::string iceC_IceGrid_NodeObserver_nodeUp_name = "nodeUp";
const ::std::string iceC_IceGrid_NodeObserver_nodeDown_name = "nodeDown";
const ::std::string iceC_IceGrid_NodeObserver_updateServer_name = "updateServer";
const ::std::string iceC_IceGrid_NodeObserver_updateAdapter_name = "updateAdapter";

const ::std::string iceC_IceGrid_ApplicationObserver_ids[2] =
{
    "::Ice::Object",
    "::IceGrid::ApplicationObserver"
};
const ::std::string iceC_IceGrid_ApplicationObserver_ops[] =
{
    "applicationAdded",
    "applicationInit",
    "applicationRemoved",
    "applicationUpdated",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};
const ::std::string iceC_IceGrid_ApplicationObserver_applicationInit_name = "applicationInit";
const ::std::string iceC_IceGrid_ApplicationObserver_applicationAdded_name = "applicationAdded";
const ::std::string iceC_IceGrid_ApplicationObserver_applicationRemoved_name = "applicationRemoved";
const ::std::string iceC_IceGrid_ApplicationObserver_applicationUpdated_name = "applicationUpdated";

const ::std::string iceC_IceGrid_AdapterObserver_ids[2] =
{
    "::Ice::Object",
    "::IceGrid::AdapterObserver"
};
const ::std::string iceC_IceGrid_AdapterObserver_ops[] =
{
    "adapterAdded",
    "adapterInit",
    "adapterRemoved",
    "adapterUpdated",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};
const ::std::string iceC_IceGrid_AdapterObserver_adapterInit_name = "adapterInit";
const ::std::string iceC_IceGrid_AdapterObserver_adapterAdded_name = "adapterAdded";
const ::std::string iceC_IceGrid_AdapterObserver_adapterUpdated_name = "adapterUpdated";
const ::std::string iceC_IceGrid_AdapterObserver_adapterRemoved_name = "adapterRemoved";

const ::std::string iceC_IceGrid_ObjectObserver_ids[2] =
{
    "::Ice::Object",
    "::IceGrid::ObjectObserver"
};
const ::std::string iceC_IceGrid_ObjectObserver_ops[] =
{
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "objectAdded",
    "objectInit",
    "objectRemoved",
    "objectUpdated"
};
const ::std::string iceC_IceGrid_ObjectObserver_objectInit_name = "objectInit";
const ::std::string iceC_IceGrid_ObjectObserver_objectAdded_name = "objectAdded";
const ::std::string iceC_IceGrid_ObjectObserver_objectUpdated_name = "objectUpdated";
const ::std::string iceC_IceGrid_ObjectObserver_objectRemoved_name = "objectRemoved";

const ::std::string iceC_IceGrid_AdminSession_ids[3] =
{
    "::Glacier2::Session",
    "::Ice::Object",
    "::IceGrid::AdminSession"
};
const ::std::string iceC_IceGrid_AdminSession_ops[] =
{
    "destroy",
    "finishUpdate",
    "getAdmin",
    "getAdminCallbackTemplate",
    "getReplicaName",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "keepAlive",
    "openNodeStdErr",
    "openNodeStdOut",
    "openRegistryStdErr",
    "openRegistryStdOut",
    "openServerLog",
    "openServerStdErr",
    "openServerStdOut",
    "setObservers",
    "setObserversByIdentity",
    "startUpdate"
};
const ::std::string iceC_IceGrid_AdminSession_keepAlive_name = "keepAlive";
const ::std::string iceC_IceGrid_AdminSession_getAdmin_name = "getAdmin";
const ::std::string iceC_IceGrid_AdminSession_getAdminCallbackTemplate_name = "getAdminCallbackTemplate";
const ::std::string iceC_IceGrid_AdminSession_setObservers_name = "setObservers";
const ::std::string iceC_IceGrid_AdminSession_setObserversByIdentity_name = "setObserversByIdentity";
const ::std::string iceC_IceGrid_AdminSession_startUpdate_name = "startUpdate";
const ::std::string iceC_IceGrid_AdminSession_finishUpdate_name = "finishUpdate";
const ::std::string iceC_IceGrid_AdminSession_getReplicaName_name = "getReplicaName";
const ::std::string iceC_IceGrid_AdminSession_openServerLog_name = "openServerLog";
const ::std::string iceC_IceGrid_AdminSession_openServerStdErr_name = "openServerStdErr";
const ::std::string iceC_IceGrid_AdminSession_openServerStdOut_name = "openServerStdOut";
const ::std::string iceC_IceGrid_AdminSession_openNodeStdErr_name = "openNodeStdErr";
const ::std::string iceC_IceGrid_AdminSession_openNodeStdOut_name = "openNodeStdOut";
const ::std::string iceC_IceGrid_AdminSession_openRegistryStdErr_name = "openRegistryStdErr";
const ::std::string iceC_IceGrid_AdminSession_openRegistryStdOut_name = "openRegistryStdOut";

}

void
IceGrid::AdminPrx::addApplication(const ApplicationDescriptor& iceP_descriptor, const ::Ice::Context& context)
{
    _makePromiseOutgoing<void>(true, this, &AdminPrx::_iceI_addApplication, iceP_descriptor, context).get();
}

::std::future<void>
IceGrid::AdminPrx::addApplicationAsync(const ApplicationDescriptor& iceP_descriptor, const ::Ice::Context& context)
{
    return _makePromiseOutgoing<void, ::std::promise>(false, this, &AdminPrx::_iceI_addApplication, iceP_descriptor, context);
}

::std::function<void()>
IceGrid::AdminPrx::addApplicationAsync(const ApplicationDescriptor& iceP_descriptor,
                                       ::std::function<void ()> response,
                                       ::std::function<void(::std::exception_ptr)> ex,
                                       ::std::function<void(bool)> sent,
                                       const ::Ice::Context& context)
{
    return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminPrx::_iceI_addApplication, iceP_descriptor, context);
}

/// \cond INTERNAL
void
IceGrid::AdminPrx::_iceI_addApplication(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ApplicationDescriptor& iceP_descriptor, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_IceGrid_Admin_addApplication_name);
    outAsync->invoke(iceC_IceGrid_Admin_addApplication_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_descriptor);
            ostr->writePendingValues();
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const DeploymentException&)
            {
                throw;
            }
            catch(const AccessDeniedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

void
IceGrid::AdminPrx::syncApplication(const ApplicationDescriptor& iceP_descriptor, const ::Ice::Context& context)
{
    _makePromiseOutgoing<void>(true, this, &AdminPrx::_iceI_syncApplication, iceP_descriptor, context).get();
}

::std::future<void>
IceGrid::AdminPrx::syncApplicationAsync(const ApplicationDescriptor& iceP_descriptor, const ::Ice::Context& context)
{
    return _makePromiseOutgoing<void, ::std::promise>(false, this, &AdminPrx::_iceI_syncApplication, iceP_descriptor, context);
}

::std::function<void()>
IceGrid::AdminPrx::syncApplicationAsync(const ApplicationDescriptor& iceP_descriptor,
                                        ::std::function<void ()> response,
                                        ::std::function<void(::std::exception_ptr)> ex,
                                        ::std::function<void(bool)> sent,
                                        const ::Ice::Context& context)
{
    return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminPrx::_iceI_syncApplication, iceP_descriptor, context);
}

/// \cond INTERNAL
void
IceGrid::AdminPrx::_iceI_syncApplication(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ApplicationDescriptor& iceP_descriptor, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_IceGrid_Admin_syncApplication_name);
    outAsync->invoke(iceC_IceGrid_Admin_syncApplication_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_descriptor);
            ostr->writePendingValues();
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const DeploymentException&)
            {
                throw;
            }
            catch(const AccessDeniedException&)
            {
                throw;
            }
            catch(const ApplicationNotExistException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

void
IceGrid::AdminPrx::updateApplication(const ApplicationUpdateDescriptor& iceP_descriptor, const ::Ice::Context& context)
{
    _makePromiseOutgoing<void>(true, this, &AdminPrx::_iceI_updateApplication, iceP_descriptor, context).get();
}

::std::future<void>
IceGrid::AdminPrx::updateApplicationAsync(const ApplicationUpdateDescriptor& iceP_descriptor, const ::Ice::Context& context)
{
    return _makePromiseOutgoing<void, ::std::promise>(false, this, &AdminPrx::_iceI_updateApplication, iceP_descriptor, context);
}

::std::function<void()>
IceGrid::AdminPrx::updateApplicationAsync(const ApplicationUpdateDescriptor& iceP_descriptor,
                                          ::std::function<void ()> response,
                                          ::std::function<void(::std::exception_ptr)> ex,
                                          ::std::function<void(bool)> sent,
                                          const ::Ice::Context& context)
{
    return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminPrx::_iceI_updateApplication, iceP_descriptor, context);
}

/// \cond INTERNAL
void
IceGrid::AdminPrx::_iceI_updateApplication(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ApplicationUpdateDescriptor& iceP_descriptor, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_IceGrid_Admin_updateApplication_name);
    outAsync->invoke(iceC_IceGrid_Admin_updateApplication_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_descriptor);
            ostr->writePendingValues();
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const DeploymentException&)
            {
                throw;
            }
            catch(const AccessDeniedException&)
            {
                throw;
            }
            catch(const ApplicationNotExistException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

void
IceGrid::AdminPrx::syncApplicationWithoutRestart(const ApplicationDescriptor& iceP_descriptor, const ::Ice::Context& context)
{
    _makePromiseOutgoing<void>(true, this, &AdminPrx::_iceI_syncApplicationWithoutRestart, iceP_descriptor, context).get();
}

::std::future<void>
IceGrid::AdminPrx::syncApplicationWithoutRestartAsync(const ApplicationDescriptor& iceP_descriptor, const ::Ice::Context& context)
{
    return _makePromiseOutgoing<void, ::std::promise>(false, this, &AdminPrx::_iceI_syncApplicationWithoutRestart, iceP_descriptor, context);
}

::std::function<void()>
IceGrid::AdminPrx::syncApplicationWithoutRestartAsync(const ApplicationDescriptor& iceP_descriptor,
                                                      ::std::function<void ()> response,
                                                      ::std::function<void(::std::exception_ptr)> ex,
                                                      ::std::function<void(bool)> sent,
                                                      const ::Ice::Context& context)
{
    return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminPrx::_iceI_syncApplicationWithoutRestart, iceP_descriptor, context);
}

/// \cond INTERNAL
void
IceGrid::AdminPrx::_iceI_syncApplicationWithoutRestart(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ApplicationDescriptor& iceP_descriptor, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_IceGrid_Admin_syncApplicationWithoutRestart_name);
    outAsync->invoke(iceC_IceGrid_Admin_syncApplicationWithoutRestart_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_descriptor);
            ostr->writePendingValues();
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const DeploymentException&)
            {
                throw;
            }
            catch(const AccessDeniedException&)
            {
                throw;
            }
            catch(const ApplicationNotExistException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

void
IceGrid::AdminPrx::updateApplicationWithoutRestart(const ApplicationUpdateDescriptor& iceP_descriptor, const ::Ice::Context& context)
{
    _makePromiseOutgoing<void>(true, this, &AdminPrx::_iceI_updateApplicationWithoutRestart, iceP_descriptor, context).get();
}

::std::future<void>
IceGrid::AdminPrx::updateApplicationWithoutRestartAsync(const ApplicationUpdateDescriptor& iceP_descriptor, const ::Ice::Context& context)
{
    return _makePromiseOutgoing<void, ::std::promise>(false, this, &AdminPrx::_iceI_updateApplicationWithoutRestart, iceP_descriptor, context);
}

::std::function<void()>
IceGrid::AdminPrx::updateApplicationWithoutRestartAsync(const ApplicationUpdateDescriptor& iceP_descriptor,
                                                        ::std::function<void ()> response,
                                                        ::std::function<void(::std::exception_ptr)> ex,
                                                        ::std::function<void(bool)> sent,
                                                        const ::Ice::Context& context)
{
    return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminPrx::_iceI_updateApplicationWithoutRestart, iceP_descriptor, context);
}

/// \cond INTERNAL
void
IceGrid::AdminPrx::_iceI_updateApplicationWithoutRestart(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ApplicationUpdateDescriptor& iceP_descriptor, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_IceGrid_Admin_updateApplicationWithoutRestart_name);
    outAsync->invoke(iceC_IceGrid_Admin_updateApplicationWithoutRestart_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_descriptor);
            ostr->writePendingValues();
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const DeploymentException&)
            {
                throw;
            }
            catch(const AccessDeniedException&)
            {
                throw;
            }
            catch(const ApplicationNotExistException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

void
IceGrid::AdminPrx::removeApplication(const ::std::string& iceP_name, const ::Ice::Context& context)
{
    _makePromiseOutgoing<void>(true, this, &AdminPrx::_iceI_removeApplication, iceP_name, context).get();
}

::std::future<void>
IceGrid::AdminPrx::removeApplicationAsync(const ::std::string& iceP_name, const ::Ice::Context& context)
{
    return _makePromiseOutgoing<void, ::std::promise>(false, this, &AdminPrx::_iceI_removeApplication, iceP_name, context);
}

::std::function<void()>
IceGrid::AdminPrx::removeApplicationAsync(const ::std::string& iceP_name,
                                          ::std::function<void ()> response,
                                          ::std::function<void(::std::exception_ptr)> ex,
                                          ::std::function<void(bool)> sent,
                                          const ::Ice::Context& context)
{
    return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminPrx::_iceI_removeApplication, iceP_name, context);
}

/// \cond INTERNAL
void
IceGrid::AdminPrx::_iceI_removeApplication(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::string& iceP_name, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_IceGrid_Admin_removeApplication_name);
    outAsync->invoke(iceC_IceGrid_Admin_removeApplication_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_name);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const DeploymentException&)
            {
                throw;
            }
            catch(const AccessDeniedException&)
            {
                throw;
            }
            catch(const ApplicationNotExistException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

void
IceGrid::AdminPrx::instantiateServer(const ::std::string& iceP_application, const ::std::string& iceP_node, const ServerInstanceDescriptor& iceP_desc, const ::Ice::Context& context)
{
    _makePromiseOutgoing<void>(true, this, &AdminPrx::_iceI_instantiateServer, iceP_application, iceP_node, iceP_desc, context).get();
}

::std::future<void>
IceGrid::AdminPrx::instantiateServerAsync(const ::std::string& iceP_application, const ::std::string& iceP_node, const ServerInstanceDescriptor& iceP_desc, const ::Ice::Context& context)
{
    return _makePromiseOutgoing<void, ::std::promise>(false, this, &AdminPrx::_iceI_instantiateServer, iceP_application, iceP_node, iceP_desc, context);
}

::std::function<void()>
IceGrid::AdminPrx::instantiateServerAsync(const ::std::string& iceP_application, const ::std::string& iceP_node, const ServerInstanceDescriptor& iceP_desc,
                                          ::std::function<void ()> response,
                                          ::std::function<void(::std::exception_ptr)> ex,
                                          ::std::function<void(bool)> sent,
                                          const ::Ice::Context& context)
{
    return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminPrx::_iceI_instantiateServer, iceP_application, iceP_node, iceP_desc, context);
}

/// \cond INTERNAL
void
IceGrid::AdminPrx::_iceI_instantiateServer(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::string& iceP_application, const ::std::string& iceP_node, const ServerInstanceDescriptor& iceP_desc, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_IceGrid_Admin_instantiateServer_name);
    outAsync->invoke(iceC_IceGrid_Admin_instantiateServer_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_application, iceP_node, iceP_desc);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const DeploymentException&)
            {
                throw;
            }
            catch(const AccessDeniedException&)
            {
                throw;
            }
            catch(const ApplicationNotExistException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

void
IceGrid::AdminPrx::patchApplication(const ::std::string& iceP_name, bool iceP_shutdown, const ::Ice::Context& context)
{
    _makePromiseOutgoing<void>(true, this, &AdminPrx::_iceI_patchApplication, iceP_name, iceP_shutdown, context).get();
}

::std::future<void>
IceGrid::AdminPrx::patchApplicationAsync(const ::std::string& iceP_name, bool iceP_shutdown, const ::Ice::Context& context)
{
    return _makePromiseOutgoing<void, ::std::promise>(false, this, &AdminPrx::_iceI_patchApplication, iceP_name, iceP_shutdown, context);
}

::std::function<void()>
IceGrid::AdminPrx::patchApplicationAsync(const ::std::string& iceP_name, bool iceP_shutdown,
                                         ::std::function<void ()> response,
                                         ::std::function<void(::std::exception_ptr)> ex,
                                         ::std::function<void(bool)> sent,
                                         const ::Ice::Context& context)
{
    return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminPrx::_iceI_patchApplication, iceP_name, iceP_shutdown, context);
}

/// \cond INTERNAL
void
IceGrid::AdminPrx::_iceI_patchApplication(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::string& iceP_name, bool iceP_shutdown, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_IceGrid_Admin_patchApplication_name);
    outAsync->invoke(iceC_IceGrid_Admin_patchApplication_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_name, iceP_shutdown);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const PatchException&)
            {
                throw;
            }
            catch(const ApplicationNotExistException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

::IceGrid::ApplicationInfo
IceGrid::AdminPrx::getApplicationInfo(const ::std::string& iceP_name, const ::Ice::Context& context)
{
    return _makePromiseOutgoing<ApplicationInfo>(true, this, &AdminPrx::_iceI_getApplicationInfo, iceP_name, context).get();
}

::std::future<::IceGrid::ApplicationInfo>
IceGrid::AdminPrx::getApplicationInfoAsync(const ::std::string& iceP_name, const ::Ice::Context& context)
{
    return _makePromiseOutgoing<ApplicationInfo, ::std::promise>(false, this, &AdminPrx::_iceI_getApplicationInfo, iceP_name, context);
}

::std::function<void()>
IceGrid::AdminPrx::getApplicationInfoAsync(const ::std::string& iceP_name,
                                           ::std::function<void (::IceGrid::ApplicationInfo)> response,
                                           ::std::function<void(::std::exception_ptr)> ex,
                                           ::std::function<void(bool)> sent,
                                           const ::Ice::Context& context)
{
    return _makeLambdaOutgoing<ApplicationInfo>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminPrx::_iceI_getApplicationInfo, iceP_name, context);
}

/// \cond INTERNAL
void
IceGrid::AdminPrx::_iceI_getApplicationInfo(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ApplicationInfo>>& outAsync, const ::std::string& iceP_name, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_IceGrid_Admin_getApplicationInfo_name);
    outAsync->invoke(iceC_IceGrid_Admin_getApplicationInfo_name, ::Ice::OperationMode::Nonmutating, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_name);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const ApplicationNotExistException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        },
        [](::Ice::InputStream* istr)
        {
            ApplicationInfo ret;
            istr->readAll(ret);
            istr->readPendingValues();
            return ret;
        });
}
/// \endcond

::IceGrid::ApplicationDescriptor
IceGrid::AdminPrx::getDefaultApplicationDescriptor(const ::Ice::Context& context)
{
    return _makePromiseOutgoing<ApplicationDescriptor>(true, this, &AdminPrx::_iceI_getDefaultApplicationDescriptor, context).get();
}

::std::future<::IceGrid::ApplicationDescriptor>
IceGrid::AdminPrx::getDefaultApplicationDescriptorAsync(const ::Ice::Context& context)
{
    return _makePromiseOutgoing<ApplicationDescriptor, ::std::promise>(false, this, &AdminPrx::_iceI_getDefaultApplicationDescriptor, context);
}

::std::function<void()>
IceGrid::AdminPrx::getDefaultApplicationDescriptorAsync(::std::function<void (::IceGrid::ApplicationDescriptor)> response,
                                                        ::std::function<void(::std::exception_ptr)> ex,
                                                        ::std::function<void(bool)> sent,
                                                        const ::Ice::Context& context)
{
    return _makeLambdaOutgoing<ApplicationDescriptor>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminPrx::_iceI_getDefaultApplicationDescriptor, context);
}

/// \cond INTERNAL
void
IceGrid::AdminPrx::_iceI_getDefaultApplicationDescriptor(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ApplicationDescriptor>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_IceGrid_Admin_getDefaultApplicationDescriptor_name);
    outAsync->invoke(iceC_IceGrid_Admin_getDefaultApplicationDescriptor_name, ::Ice::OperationMode::Nonmutating, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const DeploymentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        },
        [](::Ice::InputStream* istr)
        {
            ApplicationDescriptor ret;
            istr->readAll(ret);
            istr->readPendingValues();
            return ret;
        });
}
/// \endcond

::Ice::StringSeq
IceGrid::AdminPrx::getAllApplicationNames(const ::Ice::Context& context)
{
    return _makePromiseOutgoing<::Ice::StringSeq>(true, this, &AdminPrx::_iceI_getAllApplicationNames, context).get();
}

::std::future<::Ice::StringSeq>
IceGrid::AdminPrx::getAllApplicationNamesAsync(const ::Ice::Context& context)
{
    return _makePromiseOutgoing<::Ice::StringSeq, ::std::promise>(false, this, &AdminPrx::_iceI_getAllApplicationNames, context);
}

::std::function<void()>
IceGrid::AdminPrx::getAllApplicationNamesAsync(::std::function<void (::Ice::StringSeq)> response,
                                               ::std::function<void(::std::exception_ptr)> ex,
                                               ::std::function<void(bool)> sent,
                                               const ::Ice::Context& context)
{
    return _makeLambdaOutgoing<::Ice::StringSeq>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminPrx::_iceI_getAllApplicationNames, context);
}

/// \cond INTERNAL
void
IceGrid::AdminPrx::_iceI_getAllApplicationNames(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::Ice::StringSeq>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_IceGrid_Admin_getAllApplicationNames_name);
    outAsync->invoke(iceC_IceGrid_Admin_getAllApplicationNames_name, ::Ice::OperationMode::Nonmutating, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

::IceGrid::ServerInfo
IceGrid::AdminPrx::getServerInfo(const ::std::string& iceP_id, const ::Ice::Context& context)
{
    return _makePromiseOutgoing<ServerInfo>(true, this, &AdminPrx::_iceI_getServerInfo, iceP_id, context).get();
}

::std::future<::IceGrid::ServerInfo>
IceGrid::AdminPrx::getServerInfoAsync(const ::std::string& iceP_id, const ::Ice::Context& context)
{
    return _makePromiseOutgoing<ServerInfo, ::std::promise>(false, this, &AdminPrx::_iceI_getServerInfo, iceP_id, context);
}

::std::function<void()>
IceGrid::AdminPrx::getServerInfoAsync(const ::std::string& iceP_id,
                                      ::std::function<void (::IceGrid::ServerInfo)> response,
                                      ::std::function<void(::std::exception_ptr)> ex,
                                      ::std::function<void(bool)> sent,
                                      const ::Ice::Context& context)
{
    return _makeLambdaOutgoing<ServerInfo>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminPrx::_iceI_getServerInfo, iceP_id, context);
}

/// \cond INTERNAL
void
IceGrid::AdminPrx::_iceI_getServerInfo(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ServerInfo>>& outAsync, const ::std::string& iceP_id, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_IceGrid_Admin_getServerInfo_name);
    outAsync->invoke(iceC_IceGrid_Admin_getServerInfo_name, ::Ice::OperationMode::Nonmutating, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_id);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const ServerNotExistException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        },
        [](::Ice::InputStream* istr)
        {
            ServerInfo ret;
            istr->readAll(ret);
            istr->readPendingValues();
            return ret;
        });
}
/// \endcond

::IceGrid::ServerState
IceGrid::AdminPrx::getServerState(const ::std::string& iceP_id, const ::Ice::Context& context)
{
    return _makePromiseOutgoing<ServerState>(true, this, &AdminPrx::_iceI_getServerState, iceP_id, context).get();
}

::std::future<::IceGrid::ServerState>
IceGrid::AdminPrx::getServerStateAsync(const ::std::string& iceP_id, const ::Ice::Context& context)
{
    return _makePromiseOutgoing<ServerState, ::std::promise>(false, this, &AdminPrx::_iceI_getServerState, iceP_id, context);
}

::std::function<void()>
IceGrid::AdminPrx::getServerStateAsync(const ::std::string& iceP_id,
                                       ::std::function<void (::IceGrid::ServerState)> response,
                                       ::std::function<void(::std::exception_ptr)> ex,
                                       ::std::function<void(bool)> sent,
                                       const ::Ice::Context& context)
{
    return _makeLambdaOutgoing<ServerState>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminPrx::_iceI_getServerState, iceP_id, context);
}

/// \cond INTERNAL
void
IceGrid::AdminPrx::_iceI_getServerState(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ServerState>>& outAsync, const ::std::string& iceP_id, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_IceGrid_Admin_getServerState_name);
    outAsync->invoke(iceC_IceGrid_Admin_getServerState_name, ::Ice::OperationMode::Nonmutating, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_id);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const DeploymentException&)
            {
                throw;
            }
            catch(const NodeUnreachableException&)
            {
                throw;
            }
            catch(const ServerNotExistException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

int
IceGrid::AdminPrx::getServerPid(const ::std::string& iceP_id, const ::Ice::Context& context)
{
    return _makePromiseOutgoing<int>(true, this, &AdminPrx::_iceI_getServerPid, iceP_id, context).get();
}

::std::future<int>
IceGrid::AdminPrx::getServerPidAsync(const ::std::string& iceP_id, const ::Ice::Context& context)
{
    return _makePromiseOutgoing<int, ::std::promise>(false, this, &AdminPrx::_iceI_getServerPid, iceP_id, context);
}

::std::function<void()>
IceGrid::AdminPrx::getServerPidAsync(const ::std::string& iceP_id,
                                     ::std::function<void (int)> response,
                                     ::std::function<void(::std::exception_ptr)> ex,
                                     ::std::function<void(bool)> sent,
                                     const ::Ice::Context& context)
{
    return _makeLambdaOutgoing<int>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminPrx::_iceI_getServerPid, iceP_id, context);
}

/// \cond INTERNAL
void
IceGrid::AdminPrx::_iceI_getServerPid(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<int>>& outAsync, const ::std::string& iceP_id, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_IceGrid_Admin_getServerPid_name);
    outAsync->invoke(iceC_IceGrid_Admin_getServerPid_name, ::Ice::OperationMode::Nonmutating, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_id);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const DeploymentException&)
            {
                throw;
            }
            catch(const NodeUnreachableException&)
            {
                throw;
            }
            catch(const ServerNotExistException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

::std::string
IceGrid::AdminPrx::getServerAdminCategory(const ::Ice::Context& context)
{
    return _makePromiseOutgoing<::std::string>(true, this, &AdminPrx::_iceI_getServerAdminCategory, context).get();
}

::std::future<::std::string>
IceGrid::AdminPrx::getServerAdminCategoryAsync(const ::Ice::Context& context)
{
    return _makePromiseOutgoing<::std::string, ::std::promise>(false, this, &AdminPrx::_iceI_getServerAdminCategory, context);
}

::std::function<void()>
IceGrid::AdminPrx::getServerAdminCategoryAsync(::std::function<void (::std::string)> response,
                                               ::std::function<void(::std::exception_ptr)> ex,
                                               ::std::function<void(bool)> sent,
                                               const ::Ice::Context& context)
{
    return _makeLambdaOutgoing<::std::string>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminPrx::_iceI_getServerAdminCategory, context);
}

/// \cond INTERNAL
void
IceGrid::AdminPrx::_iceI_getServerAdminCategory(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::string>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_IceGrid_Admin_getServerAdminCategory_name);
    outAsync->invoke(iceC_IceGrid_Admin_getServerAdminCategory_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

::std::shared_ptr<::Ice::ObjectPrx>
IceGrid::AdminPrx::getServerAdmin(const ::std::string& iceP_id, const ::Ice::Context& context)
{
    return _makePromiseOutgoing<::std::shared_ptr<::Ice::ObjectPrx>>(true, this, &AdminPrx::_iceI_getServerAdmin, iceP_id, context).get();
}

::std::future<::std::shared_ptr<::Ice::ObjectPrx>>
IceGrid::AdminPrx::getServerAdminAsync(const ::std::string& iceP_id, const ::Ice::Context& context)
{
    return _makePromiseOutgoing<::std::shared_ptr<::Ice::ObjectPrx>, ::std::promise>(false, this, &AdminPrx::_iceI_getServerAdmin, iceP_id, context);
}

::std::function<void()>
IceGrid::AdminPrx::getServerAdminAsync(const ::std::string& iceP_id,
                                       ::std::function<void (::std::shared_ptr<::Ice::ObjectPrx>)> response,
                                       ::std::function<void(::std::exception_ptr)> ex,
                                       ::std::function<void(bool)> sent,
                                       const ::Ice::Context& context)
{
    return _makeLambdaOutgoing<::std::shared_ptr<::Ice::ObjectPrx>>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminPrx::_iceI_getServerAdmin, iceP_id, context);
}

/// \cond INTERNAL
void
IceGrid::AdminPrx::_iceI_getServerAdmin(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Ice::ObjectPrx>>>& outAsync, const ::std::string& iceP_id, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_IceGrid_Admin_getServerAdmin_name);
    outAsync->invoke(iceC_IceGrid_Admin_getServerAdmin_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_id);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const DeploymentException&)
            {
                throw;
            }
            catch(const NodeUnreachableException&)
            {
                throw;
            }
            catch(const ServerNotExistException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

void
IceGrid::AdminPrx::enableServer(const ::std::string& iceP_id, bool iceP_enabled, const ::Ice::Context& context)
{
    _makePromiseOutgoing<void>(true, this, &AdminPrx::_iceI_enableServer, iceP_id, iceP_enabled, context).get();
}

::std::future<void>
IceGrid::AdminPrx::enableServerAsync(const ::std::string& iceP_id, bool iceP_enabled, const ::Ice::Context& context)
{
    return _makePromiseOutgoing<void, ::std::promise>(false, this, &AdminPrx::_iceI_enableServer, iceP_id, iceP_enabled, context);
}

::std::function<void()>
IceGrid::AdminPrx::enableServerAsync(const ::std::string& iceP_id, bool iceP_enabled,
                                     ::std::function<void ()> response,
                                     ::std::function<void(::std::exception_ptr)> ex,
                                     ::std::function<void(bool)> sent,
                                     const ::Ice::Context& context)
{
    return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminPrx::_iceI_enableServer, iceP_id, iceP_enabled, context);
}

/// \cond INTERNAL
void
IceGrid::AdminPrx::_iceI_enableServer(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::string& iceP_id, bool iceP_enabled, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_IceGrid_Admin_enableServer_name);
    outAsync->invoke(iceC_IceGrid_Admin_enableServer_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_id, iceP_enabled);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const DeploymentException&)
            {
                throw;
            }
            catch(const NodeUnreachableException&)
            {
                throw;
            }
            catch(const ServerNotExistException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

bool
IceGrid::AdminPrx::isServerEnabled(const ::std::string& iceP_id, const ::Ice::Context& context)
{
    return _makePromiseOutgoing<bool>(true, this, &AdminPrx::_iceI_isServerEnabled, iceP_id, context).get();
}

::std::future<bool>
IceGrid::AdminPrx::isServerEnabledAsync(const ::std::string& iceP_id, const ::Ice::Context& context)
{
    return _makePromiseOutgoing<bool, ::std::promise>(false, this, &AdminPrx::_iceI_isServerEnabled, iceP_id, context);
}

::std::function<void()>
IceGrid::AdminPrx::isServerEnabledAsync(const ::std::string& iceP_id,
                                        ::std::function<void (bool)> response,
                                        ::std::function<void(::std::exception_ptr)> ex,
                                        ::std::function<void(bool)> sent,
                                        const ::Ice::Context& context)
{
    return _makeLambdaOutgoing<bool>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminPrx::_iceI_isServerEnabled, iceP_id, context);
}

/// \cond INTERNAL
void
IceGrid::AdminPrx::_iceI_isServerEnabled(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>& outAsync, const ::std::string& iceP_id, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_IceGrid_Admin_isServerEnabled_name);
    outAsync->invoke(iceC_IceGrid_Admin_isServerEnabled_name, ::Ice::OperationMode::Nonmutating, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_id);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const DeploymentException&)
            {
                throw;
            }
            catch(const NodeUnreachableException&)
            {
                throw;
            }
            catch(const ServerNotExistException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

void
IceGrid::AdminPrx::startServer(const ::std::string& iceP_id, const ::Ice::Context& context)
{
    _makePromiseOutgoing<void>(true, this, &AdminPrx::_iceI_startServer, iceP_id, context).get();
}

::std::future<void>
IceGrid::AdminPrx::startServerAsync(const ::std::string& iceP_id, const ::Ice::Context& context)
{
    return _makePromiseOutgoing<void, ::std::promise>(false, this, &AdminPrx::_iceI_startServer, iceP_id, context);
}

::std::function<void()>
IceGrid::AdminPrx::startServerAsync(const ::std::string& iceP_id,
                                    ::std::function<void ()> response,
                                    ::std::function<void(::std::exception_ptr)> ex,
                                    ::std::function<void(bool)> sent,
                                    const ::Ice::Context& context)
{
    return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminPrx::_iceI_startServer, iceP_id, context);
}

/// \cond INTERNAL
void
IceGrid::AdminPrx::_iceI_startServer(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::string& iceP_id, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_IceGrid_Admin_startServer_name);
    outAsync->invoke(iceC_IceGrid_Admin_startServer_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_id);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const DeploymentException&)
            {
                throw;
            }
            catch(const NodeUnreachableException&)
            {
                throw;
            }
            catch(const ServerNotExistException&)
            {
                throw;
            }
            catch(const ServerStartException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

void
IceGrid::AdminPrx::stopServer(const ::std::string& iceP_id, const ::Ice::Context& context)
{
    _makePromiseOutgoing<void>(true, this, &AdminPrx::_iceI_stopServer, iceP_id, context).get();
}

::std::future<void>
IceGrid::AdminPrx::stopServerAsync(const ::std::string& iceP_id, const ::Ice::Context& context)
{
    return _makePromiseOutgoing<void, ::std::promise>(false, this, &AdminPrx::_iceI_stopServer, iceP_id, context);
}

::std::function<void()>
IceGrid::AdminPrx::stopServerAsync(const ::std::string& iceP_id,
                                   ::std::function<void ()> response,
                                   ::std::function<void(::std::exception_ptr)> ex,
                                   ::std::function<void(bool)> sent,
                                   const ::Ice::Context& context)
{
    return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminPrx::_iceI_stopServer, iceP_id, context);
}

/// \cond INTERNAL
void
IceGrid::AdminPrx::_iceI_stopServer(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::string& iceP_id, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_IceGrid_Admin_stopServer_name);
    outAsync->invoke(iceC_IceGrid_Admin_stopServer_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_id);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const DeploymentException&)
            {
                throw;
            }
            catch(const NodeUnreachableException&)
            {
                throw;
            }
            catch(const ServerNotExistException&)
            {
                throw;
            }
            catch(const ServerStopException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

void
IceGrid::AdminPrx::patchServer(const ::std::string& iceP_id, bool iceP_shutdown, const ::Ice::Context& context)
{
    _makePromiseOutgoing<void>(true, this, &AdminPrx::_iceI_patchServer, iceP_id, iceP_shutdown, context).get();
}

::std::future<void>
IceGrid::AdminPrx::patchServerAsync(const ::std::string& iceP_id, bool iceP_shutdown, const ::Ice::Context& context)
{
    return _makePromiseOutgoing<void, ::std::promise>(false, this, &AdminPrx::_iceI_patchServer, iceP_id, iceP_shutdown, context);
}

::std::function<void()>
IceGrid::AdminPrx::patchServerAsync(const ::std::string& iceP_id, bool iceP_shutdown,
                                    ::std::function<void ()> response,
                                    ::std::function<void(::std::exception_ptr)> ex,
                                    ::std::function<void(bool)> sent,
                                    const ::Ice::Context& context)
{
    return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminPrx::_iceI_patchServer, iceP_id, iceP_shutdown, context);
}

/// \cond INTERNAL
void
IceGrid::AdminPrx::_iceI_patchServer(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::string& iceP_id, bool iceP_shutdown, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_IceGrid_Admin_patchServer_name);
    outAsync->invoke(iceC_IceGrid_Admin_patchServer_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_id, iceP_shutdown);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const DeploymentException&)
            {
                throw;
            }
            catch(const NodeUnreachableException&)
            {
                throw;
            }
            catch(const PatchException&)
            {
                throw;
            }
            catch(const ServerNotExistException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

void
IceGrid::AdminPrx::sendSignal(const ::std::string& iceP_id, const ::std::string& iceP_signal, const ::Ice::Context& context)
{
    _makePromiseOutgoing<void>(true, this, &AdminPrx::_iceI_sendSignal, iceP_id, iceP_signal, context).get();
}

::std::future<void>
IceGrid::AdminPrx::sendSignalAsync(const ::std::string& iceP_id, const ::std::string& iceP_signal, const ::Ice::Context& context)
{
    return _makePromiseOutgoing<void, ::std::promise>(false, this, &AdminPrx::_iceI_sendSignal, iceP_id, iceP_signal, context);
}

::std::function<void()>
IceGrid::AdminPrx::sendSignalAsync(const ::std::string& iceP_id, const ::std::string& iceP_signal,
                                   ::std::function<void ()> response,
                                   ::std::function<void(::std::exception_ptr)> ex,
                                   ::std::function<void(bool)> sent,
                                   const ::Ice::Context& context)
{
    return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminPrx::_iceI_sendSignal, iceP_id, iceP_signal, context);
}

/// \cond INTERNAL
void
IceGrid::AdminPrx::_iceI_sendSignal(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::string& iceP_id, const ::std::string& iceP_signal, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_IceGrid_Admin_sendSignal_name);
    outAsync->invoke(iceC_IceGrid_Admin_sendSignal_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_id, iceP_signal);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const DeploymentException&)
            {
                throw;
            }
            catch(const NodeUnreachableException&)
            {
                throw;
            }
            catch(const BadSignalException&)
            {
                throw;
            }
            catch(const ServerNotExistException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

::Ice::StringSeq
IceGrid::AdminPrx::getAllServerIds(const ::Ice::Context& context)
{
    return _makePromiseOutgoing<::Ice::StringSeq>(true, this, &AdminPrx::_iceI_getAllServerIds, context).get();
}

::std::future<::Ice::StringSeq>
IceGrid::AdminPrx::getAllServerIdsAsync(const ::Ice::Context& context)
{
    return _makePromiseOutgoing<::Ice::StringSeq, ::std::promise>(false, this, &AdminPrx::_iceI_getAllServerIds, context);
}

::std::function<void()>
IceGrid::AdminPrx::getAllServerIdsAsync(::std::function<void (::Ice::StringSeq)> response,
                                        ::std::function<void(::std::exception_ptr)> ex,
                                        ::std::function<void(bool)> sent,
                                        const ::Ice::Context& context)
{
    return _makeLambdaOutgoing<::Ice::StringSeq>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminPrx::_iceI_getAllServerIds, context);
}

/// \cond INTERNAL
void
IceGrid::AdminPrx::_iceI_getAllServerIds(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::Ice::StringSeq>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_IceGrid_Admin_getAllServerIds_name);
    outAsync->invoke(iceC_IceGrid_Admin_getAllServerIds_name, ::Ice::OperationMode::Nonmutating, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

::IceGrid::AdapterInfoSeq
IceGrid::AdminPrx::getAdapterInfo(const ::std::string& iceP_id, const ::Ice::Context& context)
{
    return _makePromiseOutgoing<AdapterInfoSeq>(true, this, &AdminPrx::_iceI_getAdapterInfo, iceP_id, context).get();
}

::std::future<::IceGrid::AdapterInfoSeq>
IceGrid::AdminPrx::getAdapterInfoAsync(const ::std::string& iceP_id, const ::Ice::Context& context)
{
    return _makePromiseOutgoing<AdapterInfoSeq, ::std::promise>(false, this, &AdminPrx::_iceI_getAdapterInfo, iceP_id, context);
}

::std::function<void()>
IceGrid::AdminPrx::getAdapterInfoAsync(const ::std::string& iceP_id,
                                       ::std::function<void (::IceGrid::AdapterInfoSeq)> response,
                                       ::std::function<void(::std::exception_ptr)> ex,
                                       ::std::function<void(bool)> sent,
                                       const ::Ice::Context& context)
{
    return _makeLambdaOutgoing<AdapterInfoSeq>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminPrx::_iceI_getAdapterInfo, iceP_id, context);
}

/// \cond INTERNAL
void
IceGrid::AdminPrx::_iceI_getAdapterInfo(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<AdapterInfoSeq>>& outAsync, const ::std::string& iceP_id, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_IceGrid_Admin_getAdapterInfo_name);
    outAsync->invoke(iceC_IceGrid_Admin_getAdapterInfo_name, ::Ice::OperationMode::Nonmutating, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_id);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const AdapterNotExistException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

void
IceGrid::AdminPrx::removeAdapter(const ::std::string& iceP_id, const ::Ice::Context& context)
{
    _makePromiseOutgoing<void>(true, this, &AdminPrx::_iceI_removeAdapter, iceP_id, context).get();
}

::std::future<void>
IceGrid::AdminPrx::removeAdapterAsync(const ::std::string& iceP_id, const ::Ice::Context& context)
{
    return _makePromiseOutgoing<void, ::std::promise>(false, this, &AdminPrx::_iceI_removeAdapter, iceP_id, context);
}

::std::function<void()>
IceGrid::AdminPrx::removeAdapterAsync(const ::std::string& iceP_id,
                                      ::std::function<void ()> response,
                                      ::std::function<void(::std::exception_ptr)> ex,
                                      ::std::function<void(bool)> sent,
                                      const ::Ice::Context& context)
{
    return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminPrx::_iceI_removeAdapter, iceP_id, context);
}

/// \cond INTERNAL
void
IceGrid::AdminPrx::_iceI_removeAdapter(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::string& iceP_id, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_IceGrid_Admin_removeAdapter_name);
    outAsync->invoke(iceC_IceGrid_Admin_removeAdapter_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_id);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const DeploymentException&)
            {
                throw;
            }
            catch(const AdapterNotExistException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

::Ice::StringSeq
IceGrid::AdminPrx::getAllAdapterIds(const ::Ice::Context& context)
{
    return _makePromiseOutgoing<::Ice::StringSeq>(true, this, &AdminPrx::_iceI_getAllAdapterIds, context).get();
}

::std::future<::Ice::StringSeq>
IceGrid::AdminPrx::getAllAdapterIdsAsync(const ::Ice::Context& context)
{
    return _makePromiseOutgoing<::Ice::StringSeq, ::std::promise>(false, this, &AdminPrx::_iceI_getAllAdapterIds, context);
}

::std::function<void()>
IceGrid::AdminPrx::getAllAdapterIdsAsync(::std::function<void (::Ice::StringSeq)> response,
                                         ::std::function<void(::std::exception_ptr)> ex,
                                         ::std::function<void(bool)> sent,
                                         const ::Ice::Context& context)
{
    return _makeLambdaOutgoing<::Ice::StringSeq>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminPrx::_iceI_getAllAdapterIds, context);
}

/// \cond INTERNAL
void
IceGrid::AdminPrx::_iceI_getAllAdapterIds(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::Ice::StringSeq>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_IceGrid_Admin_getAllAdapterIds_name);
    outAsync->invoke(iceC_IceGrid_Admin_getAllAdapterIds_name, ::Ice::OperationMode::Nonmutating, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

void
IceGrid::AdminPrx::addObject(const ::std::shared_ptr<::Ice::ObjectPrx>& iceP_obj, const ::Ice::Context& context)
{
    _makePromiseOutgoing<void>(true, this, &AdminPrx::_iceI_addObject, iceP_obj, context).get();
}

::std::future<void>
IceGrid::AdminPrx::addObjectAsync(const ::std::shared_ptr<::Ice::ObjectPrx>& iceP_obj, const ::Ice::Context& context)
{
    return _makePromiseOutgoing<void, ::std::promise>(false, this, &AdminPrx::_iceI_addObject, iceP_obj, context);
}

::std::function<void()>
IceGrid::AdminPrx::addObjectAsync(const ::std::shared_ptr<::Ice::ObjectPrx>& iceP_obj,
                                  ::std::function<void ()> response,
                                  ::std::function<void(::std::exception_ptr)> ex,
                                  ::std::function<void(bool)> sent,
                                  const ::Ice::Context& context)
{
    return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminPrx::_iceI_addObject, iceP_obj, context);
}

/// \cond INTERNAL
void
IceGrid::AdminPrx::_iceI_addObject(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::shared_ptr<::Ice::ObjectPrx>& iceP_obj, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_IceGrid_Admin_addObject_name);
    outAsync->invoke(iceC_IceGrid_Admin_addObject_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_obj);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const DeploymentException&)
            {
                throw;
            }
            catch(const ObjectExistsException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

void
IceGrid::AdminPrx::updateObject(const ::std::shared_ptr<::Ice::ObjectPrx>& iceP_obj, const ::Ice::Context& context)
{
    _makePromiseOutgoing<void>(true, this, &AdminPrx::_iceI_updateObject, iceP_obj, context).get();
}

::std::future<void>
IceGrid::AdminPrx::updateObjectAsync(const ::std::shared_ptr<::Ice::ObjectPrx>& iceP_obj, const ::Ice::Context& context)
{
    return _makePromiseOutgoing<void, ::std::promise>(false, this, &AdminPrx::_iceI_updateObject, iceP_obj, context);
}

::std::function<void()>
IceGrid::AdminPrx::updateObjectAsync(const ::std::shared_ptr<::Ice::ObjectPrx>& iceP_obj,
                                     ::std::function<void ()> response,
                                     ::std::function<void(::std::exception_ptr)> ex,
                                     ::std::function<void(bool)> sent,
                                     const ::Ice::Context& context)
{
    return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminPrx::_iceI_updateObject, iceP_obj, context);
}

/// \cond INTERNAL
void
IceGrid::AdminPrx::_iceI_updateObject(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::shared_ptr<::Ice::ObjectPrx>& iceP_obj, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_IceGrid_Admin_updateObject_name);
    outAsync->invoke(iceC_IceGrid_Admin_updateObject_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_obj);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const DeploymentException&)
            {
                throw;
            }
            catch(const ObjectNotRegisteredException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

void
IceGrid::AdminPrx::addObjectWithType(const ::std::shared_ptr<::Ice::ObjectPrx>& iceP_obj, const ::std::string& iceP_type, const ::Ice::Context& context)
{
    _makePromiseOutgoing<void>(true, this, &AdminPrx::_iceI_addObjectWithType, iceP_obj, iceP_type, context).get();
}

::std::future<void>
IceGrid::AdminPrx::addObjectWithTypeAsync(const ::std::shared_ptr<::Ice::ObjectPrx>& iceP_obj, const ::std::string& iceP_type, const ::Ice::Context& context)
{
    return _makePromiseOutgoing<void, ::std::promise>(false, this, &AdminPrx::_iceI_addObjectWithType, iceP_obj, iceP_type, context);
}

::std::function<void()>
IceGrid::AdminPrx::addObjectWithTypeAsync(const ::std::shared_ptr<::Ice::ObjectPrx>& iceP_obj, const ::std::string& iceP_type,
                                          ::std::function<void ()> response,
                                          ::std::function<void(::std::exception_ptr)> ex,
                                          ::std::function<void(bool)> sent,
                                          const ::Ice::Context& context)
{
    return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminPrx::_iceI_addObjectWithType, iceP_obj, iceP_type, context);
}

/// \cond INTERNAL
void
IceGrid::AdminPrx::_iceI_addObjectWithType(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::shared_ptr<::Ice::ObjectPrx>& iceP_obj, const ::std::string& iceP_type, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_IceGrid_Admin_addObjectWithType_name);
    outAsync->invoke(iceC_IceGrid_Admin_addObjectWithType_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_obj, iceP_type);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const DeploymentException&)
            {
                throw;
            }
            catch(const ObjectExistsException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

void
IceGrid::AdminPrx::removeObject(const ::Ice::Identity& iceP_id, const ::Ice::Context& context)
{
    _makePromiseOutgoing<void>(true, this, &AdminPrx::_iceI_removeObject, iceP_id, context).get();
}

::std::future<void>
IceGrid::AdminPrx::removeObjectAsync(const ::Ice::Identity& iceP_id, const ::Ice::Context& context)
{
    return _makePromiseOutgoing<void, ::std::promise>(false, this, &AdminPrx::_iceI_removeObject, iceP_id, context);
}

::std::function<void()>
IceGrid::AdminPrx::removeObjectAsync(const ::Ice::Identity& iceP_id,
                                     ::std::function<void ()> response,
                                     ::std::function<void(::std::exception_ptr)> ex,
                                     ::std::function<void(bool)> sent,
                                     const ::Ice::Context& context)
{
    return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminPrx::_iceI_removeObject, iceP_id, context);
}

/// \cond INTERNAL
void
IceGrid::AdminPrx::_iceI_removeObject(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::Ice::Identity& iceP_id, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_IceGrid_Admin_removeObject_name);
    outAsync->invoke(iceC_IceGrid_Admin_removeObject_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_id);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const DeploymentException&)
            {
                throw;
            }
            catch(const ObjectNotRegisteredException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

::IceGrid::ObjectInfo
IceGrid::AdminPrx::getObjectInfo(const ::Ice::Identity& iceP_id, const ::Ice::Context& context)
{
    return _makePromiseOutgoing<ObjectInfo>(true, this, &AdminPrx::_iceI_getObjectInfo, iceP_id, context).get();
}

::std::future<::IceGrid::ObjectInfo>
IceGrid::AdminPrx::getObjectInfoAsync(const ::Ice::Identity& iceP_id, const ::Ice::Context& context)
{
    return _makePromiseOutgoing<ObjectInfo, ::std::promise>(false, this, &AdminPrx::_iceI_getObjectInfo, iceP_id, context);
}

::std::function<void()>
IceGrid::AdminPrx::getObjectInfoAsync(const ::Ice::Identity& iceP_id,
                                      ::std::function<void (::IceGrid::ObjectInfo)> response,
                                      ::std::function<void(::std::exception_ptr)> ex,
                                      ::std::function<void(bool)> sent,
                                      const ::Ice::Context& context)
{
    return _makeLambdaOutgoing<ObjectInfo>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminPrx::_iceI_getObjectInfo, iceP_id, context);
}

/// \cond INTERNAL
void
IceGrid::AdminPrx::_iceI_getObjectInfo(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ObjectInfo>>& outAsync, const ::Ice::Identity& iceP_id, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_IceGrid_Admin_getObjectInfo_name);
    outAsync->invoke(iceC_IceGrid_Admin_getObjectInfo_name, ::Ice::OperationMode::Nonmutating, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_id);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const ObjectNotRegisteredException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

::IceGrid::ObjectInfoSeq
IceGrid::AdminPrx::getObjectInfosByType(const ::std::string& iceP_type, const ::Ice::Context& context)
{
    return _makePromiseOutgoing<ObjectInfoSeq>(true, this, &AdminPrx::_iceI_getObjectInfosByType, iceP_type, context).get();
}

::std::future<::IceGrid::ObjectInfoSeq>
IceGrid::AdminPrx::getObjectInfosByTypeAsync(const ::std::string& iceP_type, const ::Ice::Context& context)
{
    return _makePromiseOutgoing<ObjectInfoSeq, ::std::promise>(false, this, &AdminPrx::_iceI_getObjectInfosByType, iceP_type, context);
}

::std::function<void()>
IceGrid::AdminPrx::getObjectInfosByTypeAsync(const ::std::string& iceP_type,
                                             ::std::function<void (::IceGrid::ObjectInfoSeq)> response,
                                             ::std::function<void(::std::exception_ptr)> ex,
                                             ::std::function<void(bool)> sent,
                                             const ::Ice::Context& context)
{
    return _makeLambdaOutgoing<ObjectInfoSeq>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminPrx::_iceI_getObjectInfosByType, iceP_type, context);
}

/// \cond INTERNAL
void
IceGrid::AdminPrx::_iceI_getObjectInfosByType(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ObjectInfoSeq>>& outAsync, const ::std::string& iceP_type, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_IceGrid_Admin_getObjectInfosByType_name);
    outAsync->invoke(iceC_IceGrid_Admin_getObjectInfosByType_name, ::Ice::OperationMode::Nonmutating, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_type);
        },
        nullptr);
}
/// \endcond

::IceGrid::ObjectInfoSeq
IceGrid::AdminPrx::getAllObjectInfos(const ::std::string& iceP_expr, const ::Ice::Context& context)
{
    return _makePromiseOutgoing<ObjectInfoSeq>(true, this, &AdminPrx::_iceI_getAllObjectInfos, iceP_expr, context).get();
}

::std::future<::IceGrid::ObjectInfoSeq>
IceGrid::AdminPrx::getAllObjectInfosAsync(const ::std::string& iceP_expr, const ::Ice::Context& context)
{
    return _makePromiseOutgoing<ObjectInfoSeq, ::std::promise>(false, this, &AdminPrx::_iceI_getAllObjectInfos, iceP_expr, context);
}

::std::function<void()>
IceGrid::AdminPrx::getAllObjectInfosAsync(const ::std::string& iceP_expr,
                                          ::std::function<void (::IceGrid::ObjectInfoSeq)> response,
                                          ::std::function<void(::std::exception_ptr)> ex,
                                          ::std::function<void(bool)> sent,
                                          const ::Ice::Context& context)
{
    return _makeLambdaOutgoing<ObjectInfoSeq>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminPrx::_iceI_getAllObjectInfos, iceP_expr, context);
}

/// \cond INTERNAL
void
IceGrid::AdminPrx::_iceI_getAllObjectInfos(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ObjectInfoSeq>>& outAsync, const ::std::string& iceP_expr, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_IceGrid_Admin_getAllObjectInfos_name);
    outAsync->invoke(iceC_IceGrid_Admin_getAllObjectInfos_name, ::Ice::OperationMode::Nonmutating, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_expr);
        },
        nullptr);
}
/// \endcond

bool
IceGrid::AdminPrx::pingNode(const ::std::string& iceP_name, const ::Ice::Context& context)
{
    return _makePromiseOutgoing<bool>(true, this, &AdminPrx::_iceI_pingNode, iceP_name, context).get();
}

::std::future<bool>
IceGrid::AdminPrx::pingNodeAsync(const ::std::string& iceP_name, const ::Ice::Context& context)
{
    return _makePromiseOutgoing<bool, ::std::promise>(false, this, &AdminPrx::_iceI_pingNode, iceP_name, context);
}

::std::function<void()>
IceGrid::AdminPrx::pingNodeAsync(const ::std::string& iceP_name,
                                 ::std::function<void (bool)> response,
                                 ::std::function<void(::std::exception_ptr)> ex,
                                 ::std::function<void(bool)> sent,
                                 const ::Ice::Context& context)
{
    return _makeLambdaOutgoing<bool>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminPrx::_iceI_pingNode, iceP_name, context);
}

/// \cond INTERNAL
void
IceGrid::AdminPrx::_iceI_pingNode(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>& outAsync, const ::std::string& iceP_name, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_IceGrid_Admin_pingNode_name);
    outAsync->invoke(iceC_IceGrid_Admin_pingNode_name, ::Ice::OperationMode::Nonmutating, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_name);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const NodeNotExistException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

::IceGrid::LoadInfo
IceGrid::AdminPrx::getNodeLoad(const ::std::string& iceP_name, const ::Ice::Context& context)
{
    return _makePromiseOutgoing<LoadInfo>(true, this, &AdminPrx::_iceI_getNodeLoad, iceP_name, context).get();
}

::std::future<::IceGrid::LoadInfo>
IceGrid::AdminPrx::getNodeLoadAsync(const ::std::string& iceP_name, const ::Ice::Context& context)
{
    return _makePromiseOutgoing<LoadInfo, ::std::promise>(false, this, &AdminPrx::_iceI_getNodeLoad, iceP_name, context);
}

::std::function<void()>
IceGrid::AdminPrx::getNodeLoadAsync(const ::std::string& iceP_name,
                                    ::std::function<void (::IceGrid::LoadInfo)> response,
                                    ::std::function<void(::std::exception_ptr)> ex,
                                    ::std::function<void(bool)> sent,
                                    const ::Ice::Context& context)
{
    return _makeLambdaOutgoing<LoadInfo>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminPrx::_iceI_getNodeLoad, iceP_name, context);
}

/// \cond INTERNAL
void
IceGrid::AdminPrx::_iceI_getNodeLoad(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<LoadInfo>>& outAsync, const ::std::string& iceP_name, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_IceGrid_Admin_getNodeLoad_name);
    outAsync->invoke(iceC_IceGrid_Admin_getNodeLoad_name, ::Ice::OperationMode::Nonmutating, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_name);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const NodeUnreachableException&)
            {
                throw;
            }
            catch(const NodeNotExistException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

::IceGrid::NodeInfo
IceGrid::AdminPrx::getNodeInfo(const ::std::string& iceP_name, const ::Ice::Context& context)
{
    return _makePromiseOutgoing<NodeInfo>(true, this, &AdminPrx::_iceI_getNodeInfo, iceP_name, context).get();
}

::std::future<::IceGrid::NodeInfo>
IceGrid::AdminPrx::getNodeInfoAsync(const ::std::string& iceP_name, const ::Ice::Context& context)
{
    return _makePromiseOutgoing<NodeInfo, ::std::promise>(false, this, &AdminPrx::_iceI_getNodeInfo, iceP_name, context);
}

::std::function<void()>
IceGrid::AdminPrx::getNodeInfoAsync(const ::std::string& iceP_name,
                                    ::std::function<void (::IceGrid::NodeInfo)> response,
                                    ::std::function<void(::std::exception_ptr)> ex,
                                    ::std::function<void(bool)> sent,
                                    const ::Ice::Context& context)
{
    return _makeLambdaOutgoing<NodeInfo>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminPrx::_iceI_getNodeInfo, iceP_name, context);
}

/// \cond INTERNAL
void
IceGrid::AdminPrx::_iceI_getNodeInfo(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<NodeInfo>>& outAsync, const ::std::string& iceP_name, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_IceGrid_Admin_getNodeInfo_name);
    outAsync->invoke(iceC_IceGrid_Admin_getNodeInfo_name, ::Ice::OperationMode::Nonmutating, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_name);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const NodeUnreachableException&)
            {
                throw;
            }
            catch(const NodeNotExistException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

::std::shared_ptr<::Ice::ObjectPrx>
IceGrid::AdminPrx::getNodeAdmin(const ::std::string& iceP_name, const ::Ice::Context& context)
{
    return _makePromiseOutgoing<::std::shared_ptr<::Ice::ObjectPrx>>(true, this, &AdminPrx::_iceI_getNodeAdmin, iceP_name, context).get();
}

::std::future<::std::shared_ptr<::Ice::ObjectPrx>>
IceGrid::AdminPrx::getNodeAdminAsync(const ::std::string& iceP_name, const ::Ice::Context& context)
{
    return _makePromiseOutgoing<::std::shared_ptr<::Ice::ObjectPrx>, ::std::promise>(false, this, &AdminPrx::_iceI_getNodeAdmin, iceP_name, context);
}

::std::function<void()>
IceGrid::AdminPrx::getNodeAdminAsync(const ::std::string& iceP_name,
                                     ::std::function<void (::std::shared_ptr<::Ice::ObjectPrx>)> response,
                                     ::std::function<void(::std::exception_ptr)> ex,
                                     ::std::function<void(bool)> sent,
                                     const ::Ice::Context& context)
{
    return _makeLambdaOutgoing<::std::shared_ptr<::Ice::ObjectPrx>>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminPrx::_iceI_getNodeAdmin, iceP_name, context);
}

/// \cond INTERNAL
void
IceGrid::AdminPrx::_iceI_getNodeAdmin(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Ice::ObjectPrx>>>& outAsync, const ::std::string& iceP_name, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_IceGrid_Admin_getNodeAdmin_name);
    outAsync->invoke(iceC_IceGrid_Admin_getNodeAdmin_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_name);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const NodeUnreachableException&)
            {
                throw;
            }
            catch(const NodeNotExistException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

int
IceGrid::AdminPrx::getNodeProcessorSocketCount(const ::std::string& iceP_name, const ::Ice::Context& context)
{
    return _makePromiseOutgoing<int>(true, this, &AdminPrx::_iceI_getNodeProcessorSocketCount, iceP_name, context).get();
}

::std::future<int>
IceGrid::AdminPrx::getNodeProcessorSocketCountAsync(const ::std::string& iceP_name, const ::Ice::Context& context)
{
    return _makePromiseOutgoing<int, ::std::promise>(false, this, &AdminPrx::_iceI_getNodeProcessorSocketCount, iceP_name, context);
}

::std::function<void()>
IceGrid::AdminPrx::getNodeProcessorSocketCountAsync(const ::std::string& iceP_name,
                                                    ::std::function<void (int)> response,
                                                    ::std::function<void(::std::exception_ptr)> ex,
                                                    ::std::function<void(bool)> sent,
                                                    const ::Ice::Context& context)
{
    return _makeLambdaOutgoing<int>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminPrx::_iceI_getNodeProcessorSocketCount, iceP_name, context);
}

/// \cond INTERNAL
void
IceGrid::AdminPrx::_iceI_getNodeProcessorSocketCount(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<int>>& outAsync, const ::std::string& iceP_name, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_IceGrid_Admin_getNodeProcessorSocketCount_name);
    outAsync->invoke(iceC_IceGrid_Admin_getNodeProcessorSocketCount_name, ::Ice::OperationMode::Nonmutating, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_name);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const NodeUnreachableException&)
            {
                throw;
            }
            catch(const NodeNotExistException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

void
IceGrid::AdminPrx::shutdownNode(const ::std::string& iceP_name, const ::Ice::Context& context)
{
    _makePromiseOutgoing<void>(true, this, &AdminPrx::_iceI_shutdownNode, iceP_name, context).get();
}

::std::future<void>
IceGrid::AdminPrx::shutdownNodeAsync(const ::std::string& iceP_name, const ::Ice::Context& context)
{
    return _makePromiseOutgoing<void, ::std::promise>(false, this, &AdminPrx::_iceI_shutdownNode, iceP_name, context);
}

::std::function<void()>
IceGrid::AdminPrx::shutdownNodeAsync(const ::std::string& iceP_name,
                                     ::std::function<void ()> response,
                                     ::std::function<void(::std::exception_ptr)> ex,
                                     ::std::function<void(bool)> sent,
                                     const ::Ice::Context& context)
{
    return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminPrx::_iceI_shutdownNode, iceP_name, context);
}

/// \cond INTERNAL
void
IceGrid::AdminPrx::_iceI_shutdownNode(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::string& iceP_name, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_IceGrid_Admin_shutdownNode_name);
    outAsync->invoke(iceC_IceGrid_Admin_shutdownNode_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_name);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const NodeUnreachableException&)
            {
                throw;
            }
            catch(const NodeNotExistException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

::std::string
IceGrid::AdminPrx::getNodeHostname(const ::std::string& iceP_name, const ::Ice::Context& context)
{
    return _makePromiseOutgoing<::std::string>(true, this, &AdminPrx::_iceI_getNodeHostname, iceP_name, context).get();
}

::std::future<::std::string>
IceGrid::AdminPrx::getNodeHostnameAsync(const ::std::string& iceP_name, const ::Ice::Context& context)
{
    return _makePromiseOutgoing<::std::string, ::std::promise>(false, this, &AdminPrx::_iceI_getNodeHostname, iceP_name, context);
}

::std::function<void()>
IceGrid::AdminPrx::getNodeHostnameAsync(const ::std::string& iceP_name,
                                        ::std::function<void (::std::string)> response,
                                        ::std::function<void(::std::exception_ptr)> ex,
                                        ::std::function<void(bool)> sent,
                                        const ::Ice::Context& context)
{
    return _makeLambdaOutgoing<::std::string>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminPrx::_iceI_getNodeHostname, iceP_name, context);
}

/// \cond INTERNAL
void
IceGrid::AdminPrx::_iceI_getNodeHostname(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::string>>& outAsync, const ::std::string& iceP_name, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_IceGrid_Admin_getNodeHostname_name);
    outAsync->invoke(iceC_IceGrid_Admin_getNodeHostname_name, ::Ice::OperationMode::Nonmutating, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_name);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const NodeUnreachableException&)
            {
                throw;
            }
            catch(const NodeNotExistException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

::Ice::StringSeq
IceGrid::AdminPrx::getAllNodeNames(const ::Ice::Context& context)
{
    return _makePromiseOutgoing<::Ice::StringSeq>(true, this, &AdminPrx::_iceI_getAllNodeNames, context).get();
}

::std::future<::Ice::StringSeq>
IceGrid::AdminPrx::getAllNodeNamesAsync(const ::Ice::Context& context)
{
    return _makePromiseOutgoing<::Ice::StringSeq, ::std::promise>(false, this, &AdminPrx::_iceI_getAllNodeNames, context);
}

::std::function<void()>
IceGrid::AdminPrx::getAllNodeNamesAsync(::std::function<void (::Ice::StringSeq)> response,
                                        ::std::function<void(::std::exception_ptr)> ex,
                                        ::std::function<void(bool)> sent,
                                        const ::Ice::Context& context)
{
    return _makeLambdaOutgoing<::Ice::StringSeq>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminPrx::_iceI_getAllNodeNames, context);
}

/// \cond INTERNAL
void
IceGrid::AdminPrx::_iceI_getAllNodeNames(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::Ice::StringSeq>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_IceGrid_Admin_getAllNodeNames_name);
    outAsync->invoke(iceC_IceGrid_Admin_getAllNodeNames_name, ::Ice::OperationMode::Nonmutating, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

bool
IceGrid::AdminPrx::pingRegistry(const ::std::string& iceP_name, const ::Ice::Context& context)
{
    return _makePromiseOutgoing<bool>(true, this, &AdminPrx::_iceI_pingRegistry, iceP_name, context).get();
}

::std::future<bool>
IceGrid::AdminPrx::pingRegistryAsync(const ::std::string& iceP_name, const ::Ice::Context& context)
{
    return _makePromiseOutgoing<bool, ::std::promise>(false, this, &AdminPrx::_iceI_pingRegistry, iceP_name, context);
}

::std::function<void()>
IceGrid::AdminPrx::pingRegistryAsync(const ::std::string& iceP_name,
                                     ::std::function<void (bool)> response,
                                     ::std::function<void(::std::exception_ptr)> ex,
                                     ::std::function<void(bool)> sent,
                                     const ::Ice::Context& context)
{
    return _makeLambdaOutgoing<bool>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminPrx::_iceI_pingRegistry, iceP_name, context);
}

/// \cond INTERNAL
void
IceGrid::AdminPrx::_iceI_pingRegistry(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>& outAsync, const ::std::string& iceP_name, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_IceGrid_Admin_pingRegistry_name);
    outAsync->invoke(iceC_IceGrid_Admin_pingRegistry_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_name);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const RegistryNotExistException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

::IceGrid::RegistryInfo
IceGrid::AdminPrx::getRegistryInfo(const ::std::string& iceP_name, const ::Ice::Context& context)
{
    return _makePromiseOutgoing<RegistryInfo>(true, this, &AdminPrx::_iceI_getRegistryInfo, iceP_name, context).get();
}

::std::future<::IceGrid::RegistryInfo>
IceGrid::AdminPrx::getRegistryInfoAsync(const ::std::string& iceP_name, const ::Ice::Context& context)
{
    return _makePromiseOutgoing<RegistryInfo, ::std::promise>(false, this, &AdminPrx::_iceI_getRegistryInfo, iceP_name, context);
}

::std::function<void()>
IceGrid::AdminPrx::getRegistryInfoAsync(const ::std::string& iceP_name,
                                        ::std::function<void (::IceGrid::RegistryInfo)> response,
                                        ::std::function<void(::std::exception_ptr)> ex,
                                        ::std::function<void(bool)> sent,
                                        const ::Ice::Context& context)
{
    return _makeLambdaOutgoing<RegistryInfo>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminPrx::_iceI_getRegistryInfo, iceP_name, context);
}

/// \cond INTERNAL
void
IceGrid::AdminPrx::_iceI_getRegistryInfo(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<RegistryInfo>>& outAsync, const ::std::string& iceP_name, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_IceGrid_Admin_getRegistryInfo_name);
    outAsync->invoke(iceC_IceGrid_Admin_getRegistryInfo_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_name);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const RegistryNotExistException&)
            {
                throw;
            }
            catch(const RegistryUnreachableException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

::std::shared_ptr<::Ice::ObjectPrx>
IceGrid::AdminPrx::getRegistryAdmin(const ::std::string& iceP_name, const ::Ice::Context& context)
{
    return _makePromiseOutgoing<::std::shared_ptr<::Ice::ObjectPrx>>(true, this, &AdminPrx::_iceI_getRegistryAdmin, iceP_name, context).get();
}

::std::future<::std::shared_ptr<::Ice::ObjectPrx>>
IceGrid::AdminPrx::getRegistryAdminAsync(const ::std::string& iceP_name, const ::Ice::Context& context)
{
    return _makePromiseOutgoing<::std::shared_ptr<::Ice::ObjectPrx>, ::std::promise>(false, this, &AdminPrx::_iceI_getRegistryAdmin, iceP_name, context);
}

::std::function<void()>
IceGrid::AdminPrx::getRegistryAdminAsync(const ::std::string& iceP_name,
                                         ::std::function<void (::std::shared_ptr<::Ice::ObjectPrx>)> response,
                                         ::std::function<void(::std::exception_ptr)> ex,
                                         ::std::function<void(bool)> sent,
                                         const ::Ice::Context& context)
{
    return _makeLambdaOutgoing<::std::shared_ptr<::Ice::ObjectPrx>>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminPrx::_iceI_getRegistryAdmin, iceP_name, context);
}

/// \cond INTERNAL
void
IceGrid::AdminPrx::_iceI_getRegistryAdmin(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Ice::ObjectPrx>>>& outAsync, const ::std::string& iceP_name, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_IceGrid_Admin_getRegistryAdmin_name);
    outAsync->invoke(iceC_IceGrid_Admin_getRegistryAdmin_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_name);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const RegistryNotExistException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

void
IceGrid::AdminPrx::shutdownRegistry(const ::std::string& iceP_name, const ::Ice::Context& context)
{
    _makePromiseOutgoing<void>(true, this, &AdminPrx::_iceI_shutdownRegistry, iceP_name, context).get();
}

::std::future<void>
IceGrid::AdminPrx::shutdownRegistryAsync(const ::std::string& iceP_name, const ::Ice::Context& context)
{
    return _makePromiseOutgoing<void, ::std::promise>(false, this, &AdminPrx::_iceI_shutdownRegistry, iceP_name, context);
}

::std::function<void()>
IceGrid::AdminPrx::shutdownRegistryAsync(const ::std::string& iceP_name,
                                         ::std::function<void ()> response,
                                         ::std::function<void(::std::exception_ptr)> ex,
                                         ::std::function<void(bool)> sent,
                                         const ::Ice::Context& context)
{
    return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminPrx::_iceI_shutdownRegistry, iceP_name, context);
}

/// \cond INTERNAL
void
IceGrid::AdminPrx::_iceI_shutdownRegistry(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::string& iceP_name, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_IceGrid_Admin_shutdownRegistry_name);
    outAsync->invoke(iceC_IceGrid_Admin_shutdownRegistry_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_name);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const RegistryNotExistException&)
            {
                throw;
            }
            catch(const RegistryUnreachableException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

::Ice::StringSeq
IceGrid::AdminPrx::getAllRegistryNames(const ::Ice::Context& context)
{
    return _makePromiseOutgoing<::Ice::StringSeq>(true, this, &AdminPrx::_iceI_getAllRegistryNames, context).get();
}

::std::future<::Ice::StringSeq>
IceGrid::AdminPrx::getAllRegistryNamesAsync(const ::Ice::Context& context)
{
    return _makePromiseOutgoing<::Ice::StringSeq, ::std::promise>(false, this, &AdminPrx::_iceI_getAllRegistryNames, context);
}

::std::function<void()>
IceGrid::AdminPrx::getAllRegistryNamesAsync(::std::function<void (::Ice::StringSeq)> response,
                                            ::std::function<void(::std::exception_ptr)> ex,
                                            ::std::function<void(bool)> sent,
                                            const ::Ice::Context& context)
{
    return _makeLambdaOutgoing<::Ice::StringSeq>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminPrx::_iceI_getAllRegistryNames, context);
}

/// \cond INTERNAL
void
IceGrid::AdminPrx::_iceI_getAllRegistryNames(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::Ice::StringSeq>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_IceGrid_Admin_getAllRegistryNames_name);
    outAsync->invoke(iceC_IceGrid_Admin_getAllRegistryNames_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

void
IceGrid::AdminPrx::shutdown(const ::Ice::Context& context)
{
    _makePromiseOutgoing<void>(true, this, &AdminPrx::_iceI_shutdown, context).get();
}

::std::future<void>
IceGrid::AdminPrx::shutdownAsync(const ::Ice::Context& context)
{
    return _makePromiseOutgoing<void, ::std::promise>(false, this, &AdminPrx::_iceI_shutdown, context);
}

::std::function<void()>
IceGrid::AdminPrx::shutdownAsync(::std::function<void ()> response,
                                 ::std::function<void(::std::exception_ptr)> ex,
                                 ::std::function<void(bool)> sent,
                                 const ::Ice::Context& context)
{
    return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminPrx::_iceI_shutdown, context);
}

/// \cond INTERNAL
void
IceGrid::AdminPrx::_iceI_shutdown(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_IceGrid_Admin_shutdown_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

const ::std::string&
IceGrid::AdminPrx::ice_staticId()
{
    return Admin::ice_staticId();
}

bool
IceGrid::FileIteratorPrx::read(int iceP_size, ::Ice::StringSeq& iceP_lines, const ::Ice::Context& context)
{
    auto _result = _makePromiseOutgoing<::std::tuple<bool, ::Ice::StringSeq>>(true, this, &FileIteratorPrx::_iceI_read, iceP_size, context).get();
    iceP_lines = ::std::move(::std::get<1>(_result));
    return ::std::get<0>(_result);
}

::std::future<::std::tuple<bool, ::Ice::StringSeq>>
IceGrid::FileIteratorPrx::readAsync(int iceP_size, const ::Ice::Context& context)
{
    return _makePromiseOutgoing<::std::tuple<bool, ::Ice::StringSeq>, ::std::promise>(false, this, &FileIteratorPrx::_iceI_read, iceP_size, context);
}

::std::function<void()>
IceGrid::FileIteratorPrx::readAsync(int iceP_size,
                                    ::std::function<void (bool, ::Ice::StringSeq)> response,
                                    ::std::function<void(::std::exception_ptr)> ex,
                                    ::std::function<void(bool)> sent,
                                    const ::Ice::Context& context)
{
    auto _responseCb = [response](::std::tuple<bool, ::Ice::StringSeq>&& _result)
    {
        response(::std::get<0>(_result), ::std::move(::std::get<1>(_result)));
    };
    return _makeLambdaOutgoing<::std::tuple<bool, ::Ice::StringSeq>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &IceGrid::FileIteratorPrx::_iceI_read, iceP_size, context);
}

/// \cond INTERNAL
void
IceGrid::FileIteratorPrx::_iceI_read(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<bool, ::Ice::StringSeq>>>& outAsync, int iceP_size, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_IceGrid_FileIterator_read_name);
    outAsync->invoke(iceC_IceGrid_FileIterator_read_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_size);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const FileNotAvailableException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        },
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<bool, ::Ice::StringSeq> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

void
IceGrid::FileIteratorPrx::destroy(const ::Ice::Context& context)
{
    _makePromiseOutgoing<void>(true, this, &FileIteratorPrx::_iceI_destroy, context).get();
}

::std::future<void>
IceGrid::FileIteratorPrx::destroyAsync(const ::Ice::Context& context)
{
    return _makePromiseOutgoing<void, ::std::promise>(false, this, &FileIteratorPrx::_iceI_destroy, context);
}

::std::function<void()>
IceGrid::FileIteratorPrx::destroyAsync(::std::function<void ()> response,
                                       ::std::function<void(::std::exception_ptr)> ex,
                                       ::std::function<void(bool)> sent,
                                       const ::Ice::Context& context)
{
    return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::FileIteratorPrx::_iceI_destroy, context);
}

/// \cond INTERNAL
void
IceGrid::FileIteratorPrx::_iceI_destroy(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_IceGrid_FileIterator_destroy_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

const ::std::string&
IceGrid::FileIteratorPrx::ice_staticId()
{
    return FileIterator::ice_staticId();
}

void
IceGrid::RegistryObserverPrx::registryInit(const RegistryInfoSeq& iceP_registries, const ::Ice::Context& context)
{
    _makePromiseOutgoing<void>(true, this, &RegistryObserverPrx::_iceI_registryInit, iceP_registries, context).get();
}

::std::future<void>
IceGrid::RegistryObserverPrx::registryInitAsync(const RegistryInfoSeq& iceP_registries, const ::Ice::Context& context)
{
    return _makePromiseOutgoing<void, ::std::promise>(false, this, &RegistryObserverPrx::_iceI_registryInit, iceP_registries, context);
}

::std::function<void()>
IceGrid::RegistryObserverPrx::registryInitAsync(const RegistryInfoSeq& iceP_registries,
                                                ::std::function<void ()> response,
                                                ::std::function<void(::std::exception_ptr)> ex,
                                                ::std::function<void(bool)> sent,
                                                const ::Ice::Context& context)
{
    return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::RegistryObserverPrx::_iceI_registryInit, iceP_registries, context);
}

/// \cond INTERNAL
void
IceGrid::RegistryObserverPrx::_iceI_registryInit(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const RegistryInfoSeq& iceP_registries, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_IceGrid_RegistryObserver_registryInit_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_registries);
        },
        nullptr);
}
/// \endcond

void
IceGrid::RegistryObserverPrx::registryUp(const RegistryInfo& iceP_node, const ::Ice::Context& context)
{
    _makePromiseOutgoing<void>(true, this, &RegistryObserverPrx::_iceI_registryUp, iceP_node, context).get();
}

::std::future<void>
IceGrid::RegistryObserverPrx::registryUpAsync(const RegistryInfo& iceP_node, const ::Ice::Context& context)
{
    return _makePromiseOutgoing<void, ::std::promise>(false, this, &RegistryObserverPrx::_iceI_registryUp, iceP_node, context);
}

::std::function<void()>
IceGrid::RegistryObserverPrx::registryUpAsync(const RegistryInfo& iceP_node,
                                              ::std::function<void ()> response,
                                              ::std::function<void(::std::exception_ptr)> ex,
                                              ::std::function<void(bool)> sent,
                                              const ::Ice::Context& context)
{
    return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::RegistryObserverPrx::_iceI_registryUp, iceP_node, context);
}

/// \cond INTERNAL
void
IceGrid::RegistryObserverPrx::_iceI_registryUp(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const RegistryInfo& iceP_node, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_IceGrid_RegistryObserver_registryUp_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_node);
        },
        nullptr);
}
/// \endcond

void
IceGrid::RegistryObserverPrx::registryDown(const ::std::string& iceP_name, const ::Ice::Context& context)
{
    _makePromiseOutgoing<void>(true, this, &RegistryObserverPrx::_iceI_registryDown, iceP_name, context).get();
}

::std::future<void>
IceGrid::RegistryObserverPrx::registryDownAsync(const ::std::string& iceP_name, const ::Ice::Context& context)
{
    return _makePromiseOutgoing<void, ::std::promise>(false, this, &RegistryObserverPrx::_iceI_registryDown, iceP_name, context);
}

::std::function<void()>
IceGrid::RegistryObserverPrx::registryDownAsync(const ::std::string& iceP_name,
                                                ::std::function<void ()> response,
                                                ::std::function<void(::std::exception_ptr)> ex,
                                                ::std::function<void(bool)> sent,
                                                const ::Ice::Context& context)
{
    return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::RegistryObserverPrx::_iceI_registryDown, iceP_name, context);
}

/// \cond INTERNAL
void
IceGrid::RegistryObserverPrx::_iceI_registryDown(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::string& iceP_name, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_IceGrid_RegistryObserver_registryDown_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_name);
        },
        nullptr);
}
/// \endcond

const ::std::string&
IceGrid::RegistryObserverPrx::ice_staticId()
{
    return RegistryObserver::ice_staticId();
}

void
IceGrid::NodeObserverPrx::nodeInit(const NodeDynamicInfoSeq& iceP_nodes, const ::Ice::Context& context)
{
    _makePromiseOutgoing<void>(true, this, &NodeObserverPrx::_iceI_nodeInit, iceP_nodes, context).get();
}

::std::future<void>
IceGrid::NodeObserverPrx::nodeInitAsync(const NodeDynamicInfoSeq& iceP_nodes, const ::Ice::Context& context)
{
    return _makePromiseOutgoing<void, ::std::promise>(false, this, &NodeObserverPrx::_iceI_nodeInit, iceP_nodes, context);
}

::std::function<void()>
IceGrid::NodeObserverPrx::nodeInitAsync(const NodeDynamicInfoSeq& iceP_nodes,
                                        ::std::function<void ()> response,
                                        ::std::function<void(::std::exception_ptr)> ex,
                                        ::std::function<void(bool)> sent,
                                        const ::Ice::Context& context)
{
    return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::NodeObserverPrx::_iceI_nodeInit, iceP_nodes, context);
}

/// \cond INTERNAL
void
IceGrid::NodeObserverPrx::_iceI_nodeInit(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const NodeDynamicInfoSeq& iceP_nodes, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_IceGrid_NodeObserver_nodeInit_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_nodes);
        },
        nullptr);
}
/// \endcond

void
IceGrid::NodeObserverPrx::nodeUp(const NodeDynamicInfo& iceP_node, const ::Ice::Context& context)
{
    _makePromiseOutgoing<void>(true, this, &NodeObserverPrx::_iceI_nodeUp, iceP_node, context).get();
}

::std::future<void>
IceGrid::NodeObserverPrx::nodeUpAsync(const NodeDynamicInfo& iceP_node, const ::Ice::Context& context)
{
    return _makePromiseOutgoing<void, ::std::promise>(false, this, &NodeObserverPrx::_iceI_nodeUp, iceP_node, context);
}

::std::function<void()>
IceGrid::NodeObserverPrx::nodeUpAsync(const NodeDynamicInfo& iceP_node,
                                      ::std::function<void ()> response,
                                      ::std::function<void(::std::exception_ptr)> ex,
                                      ::std::function<void(bool)> sent,
                                      const ::Ice::Context& context)
{
    return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::NodeObserverPrx::_iceI_nodeUp, iceP_node, context);
}

/// \cond INTERNAL
void
IceGrid::NodeObserverPrx::_iceI_nodeUp(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const NodeDynamicInfo& iceP_node, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_IceGrid_NodeObserver_nodeUp_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_node);
        },
        nullptr);
}
/// \endcond

void
IceGrid::NodeObserverPrx::nodeDown(const ::std::string& iceP_name, const ::Ice::Context& context)
{
    _makePromiseOutgoing<void>(true, this, &NodeObserverPrx::_iceI_nodeDown, iceP_name, context).get();
}

::std::future<void>
IceGrid::NodeObserverPrx::nodeDownAsync(const ::std::string& iceP_name, const ::Ice::Context& context)
{
    return _makePromiseOutgoing<void, ::std::promise>(false, this, &NodeObserverPrx::_iceI_nodeDown, iceP_name, context);
}

::std::function<void()>
IceGrid::NodeObserverPrx::nodeDownAsync(const ::std::string& iceP_name,
                                        ::std::function<void ()> response,
                                        ::std::function<void(::std::exception_ptr)> ex,
                                        ::std::function<void(bool)> sent,
                                        const ::Ice::Context& context)
{
    return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::NodeObserverPrx::_iceI_nodeDown, iceP_name, context);
}

/// \cond INTERNAL
void
IceGrid::NodeObserverPrx::_iceI_nodeDown(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::string& iceP_name, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_IceGrid_NodeObserver_nodeDown_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_name);
        },
        nullptr);
}
/// \endcond

void
IceGrid::NodeObserverPrx::updateServer(const ::std::string& iceP_node, const ServerDynamicInfo& iceP_updatedInfo, const ::Ice::Context& context)
{
    _makePromiseOutgoing<void>(true, this, &NodeObserverPrx::_iceI_updateServer, iceP_node, iceP_updatedInfo, context).get();
}

::std::future<void>
IceGrid::NodeObserverPrx::updateServerAsync(const ::std::string& iceP_node, const ServerDynamicInfo& iceP_updatedInfo, const ::Ice::Context& context)
{
    return _makePromiseOutgoing<void, ::std::promise>(false, this, &NodeObserverPrx::_iceI_updateServer, iceP_node, iceP_updatedInfo, context);
}

::std::function<void()>
IceGrid::NodeObserverPrx::updateServerAsync(const ::std::string& iceP_node, const ServerDynamicInfo& iceP_updatedInfo,
                                            ::std::function<void ()> response,
                                            ::std::function<void(::std::exception_ptr)> ex,
                                            ::std::function<void(bool)> sent,
                                            const ::Ice::Context& context)
{
    return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::NodeObserverPrx::_iceI_updateServer, iceP_node, iceP_updatedInfo, context);
}

/// \cond INTERNAL
void
IceGrid::NodeObserverPrx::_iceI_updateServer(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::string& iceP_node, const ServerDynamicInfo& iceP_updatedInfo, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_IceGrid_NodeObserver_updateServer_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_node, iceP_updatedInfo);
        },
        nullptr);
}
/// \endcond

void
IceGrid::NodeObserverPrx::updateAdapter(const ::std::string& iceP_node, const AdapterDynamicInfo& iceP_updatedInfo, const ::Ice::Context& context)
{
    _makePromiseOutgoing<void>(true, this, &NodeObserverPrx::_iceI_updateAdapter, iceP_node, iceP_updatedInfo, context).get();
}

::std::future<void>
IceGrid::NodeObserverPrx::updateAdapterAsync(const ::std::string& iceP_node, const AdapterDynamicInfo& iceP_updatedInfo, const ::Ice::Context& context)
{
    return _makePromiseOutgoing<void, ::std::promise>(false, this, &NodeObserverPrx::_iceI_updateAdapter, iceP_node, iceP_updatedInfo, context);
}

::std::function<void()>
IceGrid::NodeObserverPrx::updateAdapterAsync(const ::std::string& iceP_node, const AdapterDynamicInfo& iceP_updatedInfo,
                                             ::std::function<void ()> response,
                                             ::std::function<void(::std::exception_ptr)> ex,
                                             ::std::function<void(bool)> sent,
                                             const ::Ice::Context& context)
{
    return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::NodeObserverPrx::_iceI_updateAdapter, iceP_node, iceP_updatedInfo, context);
}

/// \cond INTERNAL
void
IceGrid::NodeObserverPrx::_iceI_updateAdapter(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::string& iceP_node, const AdapterDynamicInfo& iceP_updatedInfo, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_IceGrid_NodeObserver_updateAdapter_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_node, iceP_updatedInfo);
        },
        nullptr);
}
/// \endcond

const ::std::string&
IceGrid::NodeObserverPrx::ice_staticId()
{
    return NodeObserver::ice_staticId();
}

void
IceGrid::ApplicationObserverPrx::applicationInit(int iceP_serial, const ApplicationInfoSeq& iceP_applications, const ::Ice::Context& context)
{
    _makePromiseOutgoing<void>(true, this, &ApplicationObserverPrx::_iceI_applicationInit, iceP_serial, iceP_applications, context).get();
}

::std::future<void>
IceGrid::ApplicationObserverPrx::applicationInitAsync(int iceP_serial, const ApplicationInfoSeq& iceP_applications, const ::Ice::Context& context)
{
    return _makePromiseOutgoing<void, ::std::promise>(false, this, &ApplicationObserverPrx::_iceI_applicationInit, iceP_serial, iceP_applications, context);
}

::std::function<void()>
IceGrid::ApplicationObserverPrx::applicationInitAsync(int iceP_serial, const ApplicationInfoSeq& iceP_applications,
                                                      ::std::function<void ()> response,
                                                      ::std::function<void(::std::exception_ptr)> ex,
                                                      ::std::function<void(bool)> sent,
                                                      const ::Ice::Context& context)
{
    return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::ApplicationObserverPrx::_iceI_applicationInit, iceP_serial, iceP_applications, context);
}

/// \cond INTERNAL
void
IceGrid::ApplicationObserverPrx::_iceI_applicationInit(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, int iceP_serial, const ApplicationInfoSeq& iceP_applications, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_IceGrid_ApplicationObserver_applicationInit_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_serial, iceP_applications);
            ostr->writePendingValues();
        },
        nullptr);
}
/// \endcond

void
IceGrid::ApplicationObserverPrx::applicationAdded(int iceP_serial, const ApplicationInfo& iceP_desc, const ::Ice::Context& context)
{
    _makePromiseOutgoing<void>(true, this, &ApplicationObserverPrx::_iceI_applicationAdded, iceP_serial, iceP_desc, context).get();
}

::std::future<void>
IceGrid::ApplicationObserverPrx::applicationAddedAsync(int iceP_serial, const ApplicationInfo& iceP_desc, const ::Ice::Context& context)
{
    return _makePromiseOutgoing<void, ::std::promise>(false, this, &ApplicationObserverPrx::_iceI_applicationAdded, iceP_serial, iceP_desc, context);
}

::std::function<void()>
IceGrid::ApplicationObserverPrx::applicationAddedAsync(int iceP_serial, const ApplicationInfo& iceP_desc,
                                                       ::std::function<void ()> response,
                                                       ::std::function<void(::std::exception_ptr)> ex,
                                                       ::std::function<void(bool)> sent,
                                                       const ::Ice::Context& context)
{
    return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::ApplicationObserverPrx::_iceI_applicationAdded, iceP_serial, iceP_desc, context);
}

/// \cond INTERNAL
void
IceGrid::ApplicationObserverPrx::_iceI_applicationAdded(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, int iceP_serial, const ApplicationInfo& iceP_desc, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_IceGrid_ApplicationObserver_applicationAdded_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_serial, iceP_desc);
            ostr->writePendingValues();
        },
        nullptr);
}
/// \endcond

void
IceGrid::ApplicationObserverPrx::applicationRemoved(int iceP_serial, const ::std::string& iceP_name, const ::Ice::Context& context)
{
    _makePromiseOutgoing<void>(true, this, &ApplicationObserverPrx::_iceI_applicationRemoved, iceP_serial, iceP_name, context).get();
}

::std::future<void>
IceGrid::ApplicationObserverPrx::applicationRemovedAsync(int iceP_serial, const ::std::string& iceP_name, const ::Ice::Context& context)
{
    return _makePromiseOutgoing<void, ::std::promise>(false, this, &ApplicationObserverPrx::_iceI_applicationRemoved, iceP_serial, iceP_name, context);
}

::std::function<void()>
IceGrid::ApplicationObserverPrx::applicationRemovedAsync(int iceP_serial, const ::std::string& iceP_name,
                                                         ::std::function<void ()> response,
                                                         ::std::function<void(::std::exception_ptr)> ex,
                                                         ::std::function<void(bool)> sent,
                                                         const ::Ice::Context& context)
{
    return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::ApplicationObserverPrx::_iceI_applicationRemoved, iceP_serial, iceP_name, context);
}

/// \cond INTERNAL
void
IceGrid::ApplicationObserverPrx::_iceI_applicationRemoved(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, int iceP_serial, const ::std::string& iceP_name, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_IceGrid_ApplicationObserver_applicationRemoved_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_serial, iceP_name);
        },
        nullptr);
}
/// \endcond

void
IceGrid::ApplicationObserverPrx::applicationUpdated(int iceP_serial, const ApplicationUpdateInfo& iceP_desc, const ::Ice::Context& context)
{
    _makePromiseOutgoing<void>(true, this, &ApplicationObserverPrx::_iceI_applicationUpdated, iceP_serial, iceP_desc, context).get();
}

::std::future<void>
IceGrid::ApplicationObserverPrx::applicationUpdatedAsync(int iceP_serial, const ApplicationUpdateInfo& iceP_desc, const ::Ice::Context& context)
{
    return _makePromiseOutgoing<void, ::std::promise>(false, this, &ApplicationObserverPrx::_iceI_applicationUpdated, iceP_serial, iceP_desc, context);
}

::std::function<void()>
IceGrid::ApplicationObserverPrx::applicationUpdatedAsync(int iceP_serial, const ApplicationUpdateInfo& iceP_desc,
                                                         ::std::function<void ()> response,
                                                         ::std::function<void(::std::exception_ptr)> ex,
                                                         ::std::function<void(bool)> sent,
                                                         const ::Ice::Context& context)
{
    return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::ApplicationObserverPrx::_iceI_applicationUpdated, iceP_serial, iceP_desc, context);
}

/// \cond INTERNAL
void
IceGrid::ApplicationObserverPrx::_iceI_applicationUpdated(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, int iceP_serial, const ApplicationUpdateInfo& iceP_desc, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_IceGrid_ApplicationObserver_applicationUpdated_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_serial, iceP_desc);
            ostr->writePendingValues();
        },
        nullptr);
}
/// \endcond

const ::std::string&
IceGrid::ApplicationObserverPrx::ice_staticId()
{
    return ApplicationObserver::ice_staticId();
}

void
IceGrid::AdapterObserverPrx::adapterInit(const AdapterInfoSeq& iceP_adpts, const ::Ice::Context& context)
{
    _makePromiseOutgoing<void>(true, this, &AdapterObserverPrx::_iceI_adapterInit, iceP_adpts, context).get();
}

::std::future<void>
IceGrid::AdapterObserverPrx::adapterInitAsync(const AdapterInfoSeq& iceP_adpts, const ::Ice::Context& context)
{
    return _makePromiseOutgoing<void, ::std::promise>(false, this, &AdapterObserverPrx::_iceI_adapterInit, iceP_adpts, context);
}

::std::function<void()>
IceGrid::AdapterObserverPrx::adapterInitAsync(const AdapterInfoSeq& iceP_adpts,
                                              ::std::function<void ()> response,
                                              ::std::function<void(::std::exception_ptr)> ex,
                                              ::std::function<void(bool)> sent,
                                              const ::Ice::Context& context)
{
    return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdapterObserverPrx::_iceI_adapterInit, iceP_adpts, context);
}

/// \cond INTERNAL
void
IceGrid::AdapterObserverPrx::_iceI_adapterInit(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const AdapterInfoSeq& iceP_adpts, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_IceGrid_AdapterObserver_adapterInit_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_adpts);
        },
        nullptr);
}
/// \endcond

void
IceGrid::AdapterObserverPrx::adapterAdded(const AdapterInfo& iceP_info, const ::Ice::Context& context)
{
    _makePromiseOutgoing<void>(true, this, &AdapterObserverPrx::_iceI_adapterAdded, iceP_info, context).get();
}

::std::future<void>
IceGrid::AdapterObserverPrx::adapterAddedAsync(const AdapterInfo& iceP_info, const ::Ice::Context& context)
{
    return _makePromiseOutgoing<void, ::std::promise>(false, this, &AdapterObserverPrx::_iceI_adapterAdded, iceP_info, context);
}

::std::function<void()>
IceGrid::AdapterObserverPrx::adapterAddedAsync(const AdapterInfo& iceP_info,
                                               ::std::function<void ()> response,
                                               ::std::function<void(::std::exception_ptr)> ex,
                                               ::std::function<void(bool)> sent,
                                               const ::Ice::Context& context)
{
    return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdapterObserverPrx::_iceI_adapterAdded, iceP_info, context);
}

/// \cond INTERNAL
void
IceGrid::AdapterObserverPrx::_iceI_adapterAdded(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const AdapterInfo& iceP_info, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_IceGrid_AdapterObserver_adapterAdded_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_info);
        },
        nullptr);
}
/// \endcond

void
IceGrid::AdapterObserverPrx::adapterUpdated(const AdapterInfo& iceP_info, const ::Ice::Context& context)
{
    _makePromiseOutgoing<void>(true, this, &AdapterObserverPrx::_iceI_adapterUpdated, iceP_info, context).get();
}

::std::future<void>
IceGrid::AdapterObserverPrx::adapterUpdatedAsync(const AdapterInfo& iceP_info, const ::Ice::Context& context)
{
    return _makePromiseOutgoing<void, ::std::promise>(false, this, &AdapterObserverPrx::_iceI_adapterUpdated, iceP_info, context);
}

::std::function<void()>
IceGrid::AdapterObserverPrx::adapterUpdatedAsync(const AdapterInfo& iceP_info,
                                                 ::std::function<void ()> response,
                                                 ::std::function<void(::std::exception_ptr)> ex,
                                                 ::std::function<void(bool)> sent,
                                                 const ::Ice::Context& context)
{
    return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdapterObserverPrx::_iceI_adapterUpdated, iceP_info, context);
}

/// \cond INTERNAL
void
IceGrid::AdapterObserverPrx::_iceI_adapterUpdated(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const AdapterInfo& iceP_info, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_IceGrid_AdapterObserver_adapterUpdated_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_info);
        },
        nullptr);
}
/// \endcond

void
IceGrid::AdapterObserverPrx::adapterRemoved(const ::std::string& iceP_id, const ::Ice::Context& context)
{
    _makePromiseOutgoing<void>(true, this, &AdapterObserverPrx::_iceI_adapterRemoved, iceP_id, context).get();
}

::std::future<void>
IceGrid::AdapterObserverPrx::adapterRemovedAsync(const ::std::string& iceP_id, const ::Ice::Context& context)
{
    return _makePromiseOutgoing<void, ::std::promise>(false, this, &AdapterObserverPrx::_iceI_adapterRemoved, iceP_id, context);
}

::std::function<void()>
IceGrid::AdapterObserverPrx::adapterRemovedAsync(const ::std::string& iceP_id,
                                                 ::std::function<void ()> response,
                                                 ::std::function<void(::std::exception_ptr)> ex,
                                                 ::std::function<void(bool)> sent,
                                                 const ::Ice::Context& context)
{
    return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdapterObserverPrx::_iceI_adapterRemoved, iceP_id, context);
}

/// \cond INTERNAL
void
IceGrid::AdapterObserverPrx::_iceI_adapterRemoved(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::string& iceP_id, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_IceGrid_AdapterObserver_adapterRemoved_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_id);
        },
        nullptr);
}
/// \endcond

const ::std::string&
IceGrid::AdapterObserverPrx::ice_staticId()
{
    return AdapterObserver::ice_staticId();
}

void
IceGrid::ObjectObserverPrx::objectInit(const ObjectInfoSeq& iceP_objects, const ::Ice::Context& context)
{
    _makePromiseOutgoing<void>(true, this, &ObjectObserverPrx::_iceI_objectInit, iceP_objects, context).get();
}

::std::future<void>
IceGrid::ObjectObserverPrx::objectInitAsync(const ObjectInfoSeq& iceP_objects, const ::Ice::Context& context)
{
    return _makePromiseOutgoing<void, ::std::promise>(false, this, &ObjectObserverPrx::_iceI_objectInit, iceP_objects, context);
}

::std::function<void()>
IceGrid::ObjectObserverPrx::objectInitAsync(const ObjectInfoSeq& iceP_objects,
                                            ::std::function<void ()> response,
                                            ::std::function<void(::std::exception_ptr)> ex,
                                            ::std::function<void(bool)> sent,
                                            const ::Ice::Context& context)
{
    return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::ObjectObserverPrx::_iceI_objectInit, iceP_objects, context);
}

/// \cond INTERNAL
void
IceGrid::ObjectObserverPrx::_iceI_objectInit(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ObjectInfoSeq& iceP_objects, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_IceGrid_ObjectObserver_objectInit_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_objects);
        },
        nullptr);
}
/// \endcond

void
IceGrid::ObjectObserverPrx::objectAdded(const ObjectInfo& iceP_info, const ::Ice::Context& context)
{
    _makePromiseOutgoing<void>(true, this, &ObjectObserverPrx::_iceI_objectAdded, iceP_info, context).get();
}

::std::future<void>
IceGrid::ObjectObserverPrx::objectAddedAsync(const ObjectInfo& iceP_info, const ::Ice::Context& context)
{
    return _makePromiseOutgoing<void, ::std::promise>(false, this, &ObjectObserverPrx::_iceI_objectAdded, iceP_info, context);
}

::std::function<void()>
IceGrid::ObjectObserverPrx::objectAddedAsync(const ObjectInfo& iceP_info,
                                             ::std::function<void ()> response,
                                             ::std::function<void(::std::exception_ptr)> ex,
                                             ::std::function<void(bool)> sent,
                                             const ::Ice::Context& context)
{
    return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::ObjectObserverPrx::_iceI_objectAdded, iceP_info, context);
}

/// \cond INTERNAL
void
IceGrid::ObjectObserverPrx::_iceI_objectAdded(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ObjectInfo& iceP_info, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_IceGrid_ObjectObserver_objectAdded_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_info);
        },
        nullptr);
}
/// \endcond

void
IceGrid::ObjectObserverPrx::objectUpdated(const ObjectInfo& iceP_info, const ::Ice::Context& context)
{
    _makePromiseOutgoing<void>(true, this, &ObjectObserverPrx::_iceI_objectUpdated, iceP_info, context).get();
}

::std::future<void>
IceGrid::ObjectObserverPrx::objectUpdatedAsync(const ObjectInfo& iceP_info, const ::Ice::Context& context)
{
    return _makePromiseOutgoing<void, ::std::promise>(false, this, &ObjectObserverPrx::_iceI_objectUpdated, iceP_info, context);
}

::std::function<void()>
IceGrid::ObjectObserverPrx::objectUpdatedAsync(const ObjectInfo& iceP_info,
                                               ::std::function<void ()> response,
                                               ::std::function<void(::std::exception_ptr)> ex,
                                               ::std::function<void(bool)> sent,
                                               const ::Ice::Context& context)
{
    return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::ObjectObserverPrx::_iceI_objectUpdated, iceP_info, context);
}

/// \cond INTERNAL
void
IceGrid::ObjectObserverPrx::_iceI_objectUpdated(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ObjectInfo& iceP_info, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_IceGrid_ObjectObserver_objectUpdated_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_info);
        },
        nullptr);
}
/// \endcond

void
IceGrid::ObjectObserverPrx::objectRemoved(const ::Ice::Identity& iceP_id, const ::Ice::Context& context)
{
    _makePromiseOutgoing<void>(true, this, &ObjectObserverPrx::_iceI_objectRemoved, iceP_id, context).get();
}

::std::future<void>
IceGrid::ObjectObserverPrx::objectRemovedAsync(const ::Ice::Identity& iceP_id, const ::Ice::Context& context)
{
    return _makePromiseOutgoing<void, ::std::promise>(false, this, &ObjectObserverPrx::_iceI_objectRemoved, iceP_id, context);
}

::std::function<void()>
IceGrid::ObjectObserverPrx::objectRemovedAsync(const ::Ice::Identity& iceP_id,
                                               ::std::function<void ()> response,
                                               ::std::function<void(::std::exception_ptr)> ex,
                                               ::std::function<void(bool)> sent,
                                               const ::Ice::Context& context)
{
    return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::ObjectObserverPrx::_iceI_objectRemoved, iceP_id, context);
}

/// \cond INTERNAL
void
IceGrid::ObjectObserverPrx::_iceI_objectRemoved(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::Ice::Identity& iceP_id, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_IceGrid_ObjectObserver_objectRemoved_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_id);
        },
        nullptr);
}
/// \endcond

const ::std::string&
IceGrid::ObjectObserverPrx::ice_staticId()
{
    return ObjectObserver::ice_staticId();
}

void
IceGrid::AdminSessionPrx::keepAlive(const ::Ice::Context& context)
{
    _makePromiseOutgoing<void>(true, this, &AdminSessionPrx::_iceI_keepAlive, context).get();
}

::std::future<void>
IceGrid::AdminSessionPrx::keepAliveAsync(const ::Ice::Context& context)
{
    return _makePromiseOutgoing<void, ::std::promise>(false, this, &AdminSessionPrx::_iceI_keepAlive, context);
}

::std::function<void()>
IceGrid::AdminSessionPrx::keepAliveAsync(::std::function<void ()> response,
                                         ::std::function<void(::std::exception_ptr)> ex,
                                         ::std::function<void(bool)> sent,
                                         const ::Ice::Context& context)
{
    return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminSessionPrx::_iceI_keepAlive, context);
}

/// \cond INTERNAL
void
IceGrid::AdminSessionPrx::_iceI_keepAlive(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_IceGrid_AdminSession_keepAlive_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

::std::shared_ptr<::IceGrid::AdminPrx>
IceGrid::AdminSessionPrx::getAdmin(const ::Ice::Context& context)
{
    return _makePromiseOutgoing<::std::shared_ptr<AdminPrx>>(true, this, &AdminSessionPrx::_iceI_getAdmin, context).get();
}

::std::future<::std::shared_ptr<::IceGrid::AdminPrx>>
IceGrid::AdminSessionPrx::getAdminAsync(const ::Ice::Context& context)
{
    return _makePromiseOutgoing<::std::shared_ptr<AdminPrx>, ::std::promise>(false, this, &AdminSessionPrx::_iceI_getAdmin, context);
}

::std::function<void()>
IceGrid::AdminSessionPrx::getAdminAsync(::std::function<void (::std::shared_ptr<::IceGrid::AdminPrx>)> response,
                                        ::std::function<void(::std::exception_ptr)> ex,
                                        ::std::function<void(bool)> sent,
                                        const ::Ice::Context& context)
{
    return _makeLambdaOutgoing<::std::shared_ptr<AdminPrx>>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminSessionPrx::_iceI_getAdmin, context);
}

/// \cond INTERNAL
void
IceGrid::AdminSessionPrx::_iceI_getAdmin(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<AdminPrx>>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_IceGrid_AdminSession_getAdmin_name);
    outAsync->invoke(iceC_IceGrid_AdminSession_getAdmin_name, ::Ice::OperationMode::Nonmutating, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

::std::shared_ptr<::Ice::ObjectPrx>
IceGrid::AdminSessionPrx::getAdminCallbackTemplate(const ::Ice::Context& context)
{
    return _makePromiseOutgoing<::std::shared_ptr<::Ice::ObjectPrx>>(true, this, &AdminSessionPrx::_iceI_getAdminCallbackTemplate, context).get();
}

::std::future<::std::shared_ptr<::Ice::ObjectPrx>>
IceGrid::AdminSessionPrx::getAdminCallbackTemplateAsync(const ::Ice::Context& context)
{
    return _makePromiseOutgoing<::std::shared_ptr<::Ice::ObjectPrx>, ::std::promise>(false, this, &AdminSessionPrx::_iceI_getAdminCallbackTemplate, context);
}

::std::function<void()>
IceGrid::AdminSessionPrx::getAdminCallbackTemplateAsync(::std::function<void (::std::shared_ptr<::Ice::ObjectPrx>)> response,
                                                        ::std::function<void(::std::exception_ptr)> ex,
                                                        ::std::function<void(bool)> sent,
                                                        const ::Ice::Context& context)
{
    return _makeLambdaOutgoing<::std::shared_ptr<::Ice::ObjectPrx>>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminSessionPrx::_iceI_getAdminCallbackTemplate, context);
}

/// \cond INTERNAL
void
IceGrid::AdminSessionPrx::_iceI_getAdminCallbackTemplate(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Ice::ObjectPrx>>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_IceGrid_AdminSession_getAdminCallbackTemplate_name);
    outAsync->invoke(iceC_IceGrid_AdminSession_getAdminCallbackTemplate_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

void
IceGrid::AdminSessionPrx::setObservers(const ::std::shared_ptr<RegistryObserverPrx>& iceP_registryObs, const ::std::shared_ptr<NodeObserverPrx>& iceP_nodeObs, const ::std::shared_ptr<ApplicationObserverPrx>& iceP_appObs, const ::std::shared_ptr<AdapterObserverPrx>& iceP_adptObs, const ::std::shared_ptr<ObjectObserverPrx>& iceP_objObs, const ::Ice::Context& context)
{
    _makePromiseOutgoing<void>(true, this, &AdminSessionPrx::_iceI_setObservers, iceP_registryObs, iceP_nodeObs, iceP_appObs, iceP_adptObs, iceP_objObs, context).get();
}

::std::future<void>
IceGrid::AdminSessionPrx::setObserversAsync(const ::std::shared_ptr<RegistryObserverPrx>& iceP_registryObs, const ::std::shared_ptr<NodeObserverPrx>& iceP_nodeObs, const ::std::shared_ptr<ApplicationObserverPrx>& iceP_appObs, const ::std::shared_ptr<AdapterObserverPrx>& iceP_adptObs, const ::std::shared_ptr<ObjectObserverPrx>& iceP_objObs, const ::Ice::Context& context)
{
    return _makePromiseOutgoing<void, ::std::promise>(false, this, &AdminSessionPrx::_iceI_setObservers, iceP_registryObs, iceP_nodeObs, iceP_appObs, iceP_adptObs, iceP_objObs, context);
}

::std::function<void()>
IceGrid::AdminSessionPrx::setObserversAsync(const ::std::shared_ptr<RegistryObserverPrx>& iceP_registryObs, const ::std::shared_ptr<NodeObserverPrx>& iceP_nodeObs, const ::std::shared_ptr<ApplicationObserverPrx>& iceP_appObs, const ::std::shared_ptr<AdapterObserverPrx>& iceP_adptObs, const ::std::shared_ptr<ObjectObserverPrx>& iceP_objObs,
                                            ::std::function<void ()> response,
                                            ::std::function<void(::std::exception_ptr)> ex,
                                            ::std::function<void(bool)> sent,
                                            const ::Ice::Context& context)
{
    return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminSessionPrx::_iceI_setObservers, iceP_registryObs, iceP_nodeObs, iceP_appObs, iceP_adptObs, iceP_objObs, context);
}

/// \cond INTERNAL
void
IceGrid::AdminSessionPrx::_iceI_setObservers(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::shared_ptr<RegistryObserverPrx>& iceP_registryObs, const ::std::shared_ptr<NodeObserverPrx>& iceP_nodeObs, const ::std::shared_ptr<ApplicationObserverPrx>& iceP_appObs, const ::std::shared_ptr<AdapterObserverPrx>& iceP_adptObs, const ::std::shared_ptr<ObjectObserverPrx>& iceP_objObs, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_IceGrid_AdminSession_setObservers_name);
    outAsync->invoke(iceC_IceGrid_AdminSession_setObservers_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_registryObs, iceP_nodeObs, iceP_appObs, iceP_adptObs, iceP_objObs);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const ObserverAlreadyRegisteredException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

void
IceGrid::AdminSessionPrx::setObserversByIdentity(const ::Ice::Identity& iceP_registryObs, const ::Ice::Identity& iceP_nodeObs, const ::Ice::Identity& iceP_appObs, const ::Ice::Identity& iceP_adptObs, const ::Ice::Identity& iceP_objObs, const ::Ice::Context& context)
{
    _makePromiseOutgoing<void>(true, this, &AdminSessionPrx::_iceI_setObserversByIdentity, iceP_registryObs, iceP_nodeObs, iceP_appObs, iceP_adptObs, iceP_objObs, context).get();
}

::std::future<void>
IceGrid::AdminSessionPrx::setObserversByIdentityAsync(const ::Ice::Identity& iceP_registryObs, const ::Ice::Identity& iceP_nodeObs, const ::Ice::Identity& iceP_appObs, const ::Ice::Identity& iceP_adptObs, const ::Ice::Identity& iceP_objObs, const ::Ice::Context& context)
{
    return _makePromiseOutgoing<void, ::std::promise>(false, this, &AdminSessionPrx::_iceI_setObserversByIdentity, iceP_registryObs, iceP_nodeObs, iceP_appObs, iceP_adptObs, iceP_objObs, context);
}

::std::function<void()>
IceGrid::AdminSessionPrx::setObserversByIdentityAsync(const ::Ice::Identity& iceP_registryObs, const ::Ice::Identity& iceP_nodeObs, const ::Ice::Identity& iceP_appObs, const ::Ice::Identity& iceP_adptObs, const ::Ice::Identity& iceP_objObs,
                                                      ::std::function<void ()> response,
                                                      ::std::function<void(::std::exception_ptr)> ex,
                                                      ::std::function<void(bool)> sent,
                                                      const ::Ice::Context& context)
{
    return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminSessionPrx::_iceI_setObserversByIdentity, iceP_registryObs, iceP_nodeObs, iceP_appObs, iceP_adptObs, iceP_objObs, context);
}

/// \cond INTERNAL
void
IceGrid::AdminSessionPrx::_iceI_setObserversByIdentity(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::Ice::Identity& iceP_registryObs, const ::Ice::Identity& iceP_nodeObs, const ::Ice::Identity& iceP_appObs, const ::Ice::Identity& iceP_adptObs, const ::Ice::Identity& iceP_objObs, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_IceGrid_AdminSession_setObserversByIdentity_name);
    outAsync->invoke(iceC_IceGrid_AdminSession_setObserversByIdentity_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_registryObs, iceP_nodeObs, iceP_appObs, iceP_adptObs, iceP_objObs);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const ObserverAlreadyRegisteredException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

int
IceGrid::AdminSessionPrx::startUpdate(const ::Ice::Context& context)
{
    return _makePromiseOutgoing<int>(true, this, &AdminSessionPrx::_iceI_startUpdate, context).get();
}

::std::future<int>
IceGrid::AdminSessionPrx::startUpdateAsync(const ::Ice::Context& context)
{
    return _makePromiseOutgoing<int, ::std::promise>(false, this, &AdminSessionPrx::_iceI_startUpdate, context);
}

::std::function<void()>
IceGrid::AdminSessionPrx::startUpdateAsync(::std::function<void (int)> response,
                                           ::std::function<void(::std::exception_ptr)> ex,
                                           ::std::function<void(bool)> sent,
                                           const ::Ice::Context& context)
{
    return _makeLambdaOutgoing<int>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminSessionPrx::_iceI_startUpdate, context);
}

/// \cond INTERNAL
void
IceGrid::AdminSessionPrx::_iceI_startUpdate(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<int>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_IceGrid_AdminSession_startUpdate_name);
    outAsync->invoke(iceC_IceGrid_AdminSession_startUpdate_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const AccessDeniedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

void
IceGrid::AdminSessionPrx::finishUpdate(const ::Ice::Context& context)
{
    _makePromiseOutgoing<void>(true, this, &AdminSessionPrx::_iceI_finishUpdate, context).get();
}

::std::future<void>
IceGrid::AdminSessionPrx::finishUpdateAsync(const ::Ice::Context& context)
{
    return _makePromiseOutgoing<void, ::std::promise>(false, this, &AdminSessionPrx::_iceI_finishUpdate, context);
}

::std::function<void()>
IceGrid::AdminSessionPrx::finishUpdateAsync(::std::function<void ()> response,
                                            ::std::function<void(::std::exception_ptr)> ex,
                                            ::std::function<void(bool)> sent,
                                            const ::Ice::Context& context)
{
    return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminSessionPrx::_iceI_finishUpdate, context);
}

/// \cond INTERNAL
void
IceGrid::AdminSessionPrx::_iceI_finishUpdate(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_IceGrid_AdminSession_finishUpdate_name);
    outAsync->invoke(iceC_IceGrid_AdminSession_finishUpdate_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const AccessDeniedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

::std::string
IceGrid::AdminSessionPrx::getReplicaName(const ::Ice::Context& context)
{
    return _makePromiseOutgoing<::std::string>(true, this, &AdminSessionPrx::_iceI_getReplicaName, context).get();
}

::std::future<::std::string>
IceGrid::AdminSessionPrx::getReplicaNameAsync(const ::Ice::Context& context)
{
    return _makePromiseOutgoing<::std::string, ::std::promise>(false, this, &AdminSessionPrx::_iceI_getReplicaName, context);
}

::std::function<void()>
IceGrid::AdminSessionPrx::getReplicaNameAsync(::std::function<void (::std::string)> response,
                                              ::std::function<void(::std::exception_ptr)> ex,
                                              ::std::function<void(bool)> sent,
                                              const ::Ice::Context& context)
{
    return _makeLambdaOutgoing<::std::string>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminSessionPrx::_iceI_getReplicaName, context);
}

/// \cond INTERNAL
void
IceGrid::AdminSessionPrx::_iceI_getReplicaName(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::string>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_IceGrid_AdminSession_getReplicaName_name);
    outAsync->invoke(iceC_IceGrid_AdminSession_getReplicaName_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

::std::shared_ptr<::IceGrid::FileIteratorPrx>
IceGrid::AdminSessionPrx::openServerLog(const ::std::string& iceP_id, const ::std::string& iceP_path, int iceP_count, const ::Ice::Context& context)
{
    return _makePromiseOutgoing<::std::shared_ptr<FileIteratorPrx>>(true, this, &AdminSessionPrx::_iceI_openServerLog, iceP_id, iceP_path, iceP_count, context).get();
}

::std::future<::std::shared_ptr<::IceGrid::FileIteratorPrx>>
IceGrid::AdminSessionPrx::openServerLogAsync(const ::std::string& iceP_id, const ::std::string& iceP_path, int iceP_count, const ::Ice::Context& context)
{
    return _makePromiseOutgoing<::std::shared_ptr<FileIteratorPrx>, ::std::promise>(false, this, &AdminSessionPrx::_iceI_openServerLog, iceP_id, iceP_path, iceP_count, context);
}

::std::function<void()>
IceGrid::AdminSessionPrx::openServerLogAsync(const ::std::string& iceP_id, const ::std::string& iceP_path, int iceP_count,
                                             ::std::function<void (::std::shared_ptr<::IceGrid::FileIteratorPrx>)> response,
                                             ::std::function<void(::std::exception_ptr)> ex,
                                             ::std::function<void(bool)> sent,
                                             const ::Ice::Context& context)
{
    return _makeLambdaOutgoing<::std::shared_ptr<FileIteratorPrx>>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminSessionPrx::_iceI_openServerLog, iceP_id, iceP_path, iceP_count, context);
}

/// \cond INTERNAL
void
IceGrid::AdminSessionPrx::_iceI_openServerLog(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<FileIteratorPrx>>>& outAsync, const ::std::string& iceP_id, const ::std::string& iceP_path, int iceP_count, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_IceGrid_AdminSession_openServerLog_name);
    outAsync->invoke(iceC_IceGrid_AdminSession_openServerLog_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_id, iceP_path, iceP_count);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const DeploymentException&)
            {
                throw;
            }
            catch(const NodeUnreachableException&)
            {
                throw;
            }
            catch(const FileNotAvailableException&)
            {
                throw;
            }
            catch(const ServerNotExistException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

::std::shared_ptr<::IceGrid::FileIteratorPrx>
IceGrid::AdminSessionPrx::openServerStdErr(const ::std::string& iceP_id, int iceP_count, const ::Ice::Context& context)
{
    return _makePromiseOutgoing<::std::shared_ptr<FileIteratorPrx>>(true, this, &AdminSessionPrx::_iceI_openServerStdErr, iceP_id, iceP_count, context).get();
}

::std::future<::std::shared_ptr<::IceGrid::FileIteratorPrx>>
IceGrid::AdminSessionPrx::openServerStdErrAsync(const ::std::string& iceP_id, int iceP_count, const ::Ice::Context& context)
{
    return _makePromiseOutgoing<::std::shared_ptr<FileIteratorPrx>, ::std::promise>(false, this, &AdminSessionPrx::_iceI_openServerStdErr, iceP_id, iceP_count, context);
}

::std::function<void()>
IceGrid::AdminSessionPrx::openServerStdErrAsync(const ::std::string& iceP_id, int iceP_count,
                                                ::std::function<void (::std::shared_ptr<::IceGrid::FileIteratorPrx>)> response,
                                                ::std::function<void(::std::exception_ptr)> ex,
                                                ::std::function<void(bool)> sent,
                                                const ::Ice::Context& context)
{
    return _makeLambdaOutgoing<::std::shared_ptr<FileIteratorPrx>>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminSessionPrx::_iceI_openServerStdErr, iceP_id, iceP_count, context);
}

/// \cond INTERNAL
void
IceGrid::AdminSessionPrx::_iceI_openServerStdErr(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<FileIteratorPrx>>>& outAsync, const ::std::string& iceP_id, int iceP_count, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_IceGrid_AdminSession_openServerStdErr_name);
    outAsync->invoke(iceC_IceGrid_AdminSession_openServerStdErr_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_id, iceP_count);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const DeploymentException&)
            {
                throw;
            }
            catch(const NodeUnreachableException&)
            {
                throw;
            }
            catch(const FileNotAvailableException&)
            {
                throw;
            }
            catch(const ServerNotExistException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

::std::shared_ptr<::IceGrid::FileIteratorPrx>
IceGrid::AdminSessionPrx::openServerStdOut(const ::std::string& iceP_id, int iceP_count, const ::Ice::Context& context)
{
    return _makePromiseOutgoing<::std::shared_ptr<FileIteratorPrx>>(true, this, &AdminSessionPrx::_iceI_openServerStdOut, iceP_id, iceP_count, context).get();
}

::std::future<::std::shared_ptr<::IceGrid::FileIteratorPrx>>
IceGrid::AdminSessionPrx::openServerStdOutAsync(const ::std::string& iceP_id, int iceP_count, const ::Ice::Context& context)
{
    return _makePromiseOutgoing<::std::shared_ptr<FileIteratorPrx>, ::std::promise>(false, this, &AdminSessionPrx::_iceI_openServerStdOut, iceP_id, iceP_count, context);
}

::std::function<void()>
IceGrid::AdminSessionPrx::openServerStdOutAsync(const ::std::string& iceP_id, int iceP_count,
                                                ::std::function<void (::std::shared_ptr<::IceGrid::FileIteratorPrx>)> response,
                                                ::std::function<void(::std::exception_ptr)> ex,
                                                ::std::function<void(bool)> sent,
                                                const ::Ice::Context& context)
{
    return _makeLambdaOutgoing<::std::shared_ptr<FileIteratorPrx>>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminSessionPrx::_iceI_openServerStdOut, iceP_id, iceP_count, context);
}

/// \cond INTERNAL
void
IceGrid::AdminSessionPrx::_iceI_openServerStdOut(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<FileIteratorPrx>>>& outAsync, const ::std::string& iceP_id, int iceP_count, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_IceGrid_AdminSession_openServerStdOut_name);
    outAsync->invoke(iceC_IceGrid_AdminSession_openServerStdOut_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_id, iceP_count);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const DeploymentException&)
            {
                throw;
            }
            catch(const NodeUnreachableException&)
            {
                throw;
            }
            catch(const FileNotAvailableException&)
            {
                throw;
            }
            catch(const ServerNotExistException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

::std::shared_ptr<::IceGrid::FileIteratorPrx>
IceGrid::AdminSessionPrx::openNodeStdErr(const ::std::string& iceP_name, int iceP_count, const ::Ice::Context& context)
{
    return _makePromiseOutgoing<::std::shared_ptr<FileIteratorPrx>>(true, this, &AdminSessionPrx::_iceI_openNodeStdErr, iceP_name, iceP_count, context).get();
}

::std::future<::std::shared_ptr<::IceGrid::FileIteratorPrx>>
IceGrid::AdminSessionPrx::openNodeStdErrAsync(const ::std::string& iceP_name, int iceP_count, const ::Ice::Context& context)
{
    return _makePromiseOutgoing<::std::shared_ptr<FileIteratorPrx>, ::std::promise>(false, this, &AdminSessionPrx::_iceI_openNodeStdErr, iceP_name, iceP_count, context);
}

::std::function<void()>
IceGrid::AdminSessionPrx::openNodeStdErrAsync(const ::std::string& iceP_name, int iceP_count,
                                              ::std::function<void (::std::shared_ptr<::IceGrid::FileIteratorPrx>)> response,
                                              ::std::function<void(::std::exception_ptr)> ex,
                                              ::std::function<void(bool)> sent,
                                              const ::Ice::Context& context)
{
    return _makeLambdaOutgoing<::std::shared_ptr<FileIteratorPrx>>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminSessionPrx::_iceI_openNodeStdErr, iceP_name, iceP_count, context);
}

/// \cond INTERNAL
void
IceGrid::AdminSessionPrx::_iceI_openNodeStdErr(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<FileIteratorPrx>>>& outAsync, const ::std::string& iceP_name, int iceP_count, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_IceGrid_AdminSession_openNodeStdErr_name);
    outAsync->invoke(iceC_IceGrid_AdminSession_openNodeStdErr_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_name, iceP_count);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const NodeUnreachableException&)
            {
                throw;
            }
            catch(const FileNotAvailableException&)
            {
                throw;
            }
            catch(const NodeNotExistException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

::std::shared_ptr<::IceGrid::FileIteratorPrx>
IceGrid::AdminSessionPrx::openNodeStdOut(const ::std::string& iceP_name, int iceP_count, const ::Ice::Context& context)
{
    return _makePromiseOutgoing<::std::shared_ptr<FileIteratorPrx>>(true, this, &AdminSessionPrx::_iceI_openNodeStdOut, iceP_name, iceP_count, context).get();
}

::std::future<::std::shared_ptr<::IceGrid::FileIteratorPrx>>
IceGrid::AdminSessionPrx::openNodeStdOutAsync(const ::std::string& iceP_name, int iceP_count, const ::Ice::Context& context)
{
    return _makePromiseOutgoing<::std::shared_ptr<FileIteratorPrx>, ::std::promise>(false, this, &AdminSessionPrx::_iceI_openNodeStdOut, iceP_name, iceP_count, context);
}

::std::function<void()>
IceGrid::AdminSessionPrx::openNodeStdOutAsync(const ::std::string& iceP_name, int iceP_count,
                                              ::std::function<void (::std::shared_ptr<::IceGrid::FileIteratorPrx>)> response,
                                              ::std::function<void(::std::exception_ptr)> ex,
                                              ::std::function<void(bool)> sent,
                                              const ::Ice::Context& context)
{
    return _makeLambdaOutgoing<::std::shared_ptr<FileIteratorPrx>>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminSessionPrx::_iceI_openNodeStdOut, iceP_name, iceP_count, context);
}

/// \cond INTERNAL
void
IceGrid::AdminSessionPrx::_iceI_openNodeStdOut(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<FileIteratorPrx>>>& outAsync, const ::std::string& iceP_name, int iceP_count, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_IceGrid_AdminSession_openNodeStdOut_name);
    outAsync->invoke(iceC_IceGrid_AdminSession_openNodeStdOut_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_name, iceP_count);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const NodeUnreachableException&)
            {
                throw;
            }
            catch(const FileNotAvailableException&)
            {
                throw;
            }
            catch(const NodeNotExistException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

::std::shared_ptr<::IceGrid::FileIteratorPrx>
IceGrid::AdminSessionPrx::openRegistryStdErr(const ::std::string& iceP_name, int iceP_count, const ::Ice::Context& context)
{
    return _makePromiseOutgoing<::std::shared_ptr<FileIteratorPrx>>(true, this, &AdminSessionPrx::_iceI_openRegistryStdErr, iceP_name, iceP_count, context).get();
}

::std::future<::std::shared_ptr<::IceGrid::FileIteratorPrx>>
IceGrid::AdminSessionPrx::openRegistryStdErrAsync(const ::std::string& iceP_name, int iceP_count, const ::Ice::Context& context)
{
    return _makePromiseOutgoing<::std::shared_ptr<FileIteratorPrx>, ::std::promise>(false, this, &AdminSessionPrx::_iceI_openRegistryStdErr, iceP_name, iceP_count, context);
}

::std::function<void()>
IceGrid::AdminSessionPrx::openRegistryStdErrAsync(const ::std::string& iceP_name, int iceP_count,
                                                  ::std::function<void (::std::shared_ptr<::IceGrid::FileIteratorPrx>)> response,
                                                  ::std::function<void(::std::exception_ptr)> ex,
                                                  ::std::function<void(bool)> sent,
                                                  const ::Ice::Context& context)
{
    return _makeLambdaOutgoing<::std::shared_ptr<FileIteratorPrx>>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminSessionPrx::_iceI_openRegistryStdErr, iceP_name, iceP_count, context);
}

/// \cond INTERNAL
void
IceGrid::AdminSessionPrx::_iceI_openRegistryStdErr(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<FileIteratorPrx>>>& outAsync, const ::std::string& iceP_name, int iceP_count, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_IceGrid_AdminSession_openRegistryStdErr_name);
    outAsync->invoke(iceC_IceGrid_AdminSession_openRegistryStdErr_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_name, iceP_count);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const RegistryNotExistException&)
            {
                throw;
            }
            catch(const RegistryUnreachableException&)
            {
                throw;
            }
            catch(const FileNotAvailableException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

::std::shared_ptr<::IceGrid::FileIteratorPrx>
IceGrid::AdminSessionPrx::openRegistryStdOut(const ::std::string& iceP_name, int iceP_count, const ::Ice::Context& context)
{
    return _makePromiseOutgoing<::std::shared_ptr<FileIteratorPrx>>(true, this, &AdminSessionPrx::_iceI_openRegistryStdOut, iceP_name, iceP_count, context).get();
}

::std::future<::std::shared_ptr<::IceGrid::FileIteratorPrx>>
IceGrid::AdminSessionPrx::openRegistryStdOutAsync(const ::std::string& iceP_name, int iceP_count, const ::Ice::Context& context)
{
    return _makePromiseOutgoing<::std::shared_ptr<FileIteratorPrx>, ::std::promise>(false, this, &AdminSessionPrx::_iceI_openRegistryStdOut, iceP_name, iceP_count, context);
}

::std::function<void()>
IceGrid::AdminSessionPrx::openRegistryStdOutAsync(const ::std::string& iceP_name, int iceP_count,
                                                  ::std::function<void (::std::shared_ptr<::IceGrid::FileIteratorPrx>)> response,
                                                  ::std::function<void(::std::exception_ptr)> ex,
                                                  ::std::function<void(bool)> sent,
                                                  const ::Ice::Context& context)
{
    return _makeLambdaOutgoing<::std::shared_ptr<FileIteratorPrx>>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminSessionPrx::_iceI_openRegistryStdOut, iceP_name, iceP_count, context);
}

/// \cond INTERNAL
void
IceGrid::AdminSessionPrx::_iceI_openRegistryStdOut(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<FileIteratorPrx>>>& outAsync, const ::std::string& iceP_name, int iceP_count, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_IceGrid_AdminSession_openRegistryStdOut_name);
    outAsync->invoke(iceC_IceGrid_AdminSession_openRegistryStdOut_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_name, iceP_count);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const RegistryNotExistException&)
            {
                throw;
            }
            catch(const RegistryUnreachableException&)
            {
                throw;
            }
            catch(const FileNotAvailableException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

const ::std::string&
IceGrid::AdminSessionPrx::ice_staticId()
{
    return AdminSession::ice_staticId();
}

bool
IceGrid::Admin::ice_isA(::std::string s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_IceGrid_Admin_ids, iceC_IceGrid_Admin_ids + 2, s);
}

::std::vector<::std::string>
IceGrid::Admin::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector<::std::string>(&iceC_IceGrid_Admin_ids[0], &iceC_IceGrid_Admin_ids[2]);
}

::std::string
IceGrid::Admin::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
IceGrid::Admin::ice_staticId()
{
    static const ::std::string typeId = "::IceGrid::Admin";
    return typeId;
}

/// \cond INTERNAL
bool
IceGrid::Admin::_iceD_addApplication(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ApplicationDescriptor iceP_descriptor;
    istr->readAll(iceP_descriptor);
    istr->readPendingValues();
    inS.endReadParams();
    this->addApplication(::std::move(iceP_descriptor), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::Admin::_iceD_syncApplication(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ApplicationDescriptor iceP_descriptor;
    istr->readAll(iceP_descriptor);
    istr->readPendingValues();
    inS.endReadParams();
    this->syncApplication(::std::move(iceP_descriptor), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::Admin::_iceD_updateApplication(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ApplicationUpdateDescriptor iceP_descriptor;
    istr->readAll(iceP_descriptor);
    istr->readPendingValues();
    inS.endReadParams();
    this->updateApplication(::std::move(iceP_descriptor), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::Admin::_iceD_syncApplicationWithoutRestart(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ApplicationDescriptor iceP_descriptor;
    istr->readAll(iceP_descriptor);
    istr->readPendingValues();
    inS.endReadParams();
    this->syncApplicationWithoutRestart(::std::move(iceP_descriptor), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::Admin::_iceD_updateApplicationWithoutRestart(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ApplicationUpdateDescriptor iceP_descriptor;
    istr->readAll(iceP_descriptor);
    istr->readPendingValues();
    inS.endReadParams();
    this->updateApplicationWithoutRestart(::std::move(iceP_descriptor), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::Admin::_iceD_removeApplication(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_name;
    istr->readAll(iceP_name);
    inS.endReadParams();
    this->removeApplication(::std::move(iceP_name), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::Admin::_iceD_instantiateServer(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_application;
    ::std::string iceP_node;
    ServerInstanceDescriptor iceP_desc;
    istr->readAll(iceP_application, iceP_node, iceP_desc);
    inS.endReadParams();
    this->instantiateServer(::std::move(iceP_application), ::std::move(iceP_node), ::std::move(iceP_desc), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::Admin::_iceD_patchApplication(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_name;
    bool iceP_shutdown;
    istr->readAll(iceP_name, iceP_shutdown);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    this->patchApplicationAsync(::std::move(iceP_name), iceP_shutdown, inA->response(), inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::Admin::_iceD_getApplicationInfo(::IceInternal::Incoming& inS, const ::Ice::Current& current) const
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_name;
    istr->readAll(iceP_name);
    inS.endReadParams();
    ApplicationInfo ret = this->getApplicationInfo(::std::move(iceP_name), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::Admin::_iceD_getDefaultApplicationDescriptor(::IceInternal::Incoming& inS, const ::Ice::Current& current) const
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    inS.readEmptyParams();
    ApplicationDescriptor ret = this->getDefaultApplicationDescriptor(current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::Admin::_iceD_getAllApplicationNames(::IceInternal::Incoming& inS, const ::Ice::Current& current) const
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    inS.readEmptyParams();
    ::Ice::StringSeq ret = this->getAllApplicationNames(current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::Admin::_iceD_getServerInfo(::IceInternal::Incoming& inS, const ::Ice::Current& current) const
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_id;
    istr->readAll(iceP_id);
    inS.endReadParams();
    ServerInfo ret = this->getServerInfo(::std::move(iceP_id), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::Admin::_iceD_getServerState(::IceInternal::Incoming& inS, const ::Ice::Current& current) const
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_id;
    istr->readAll(iceP_id);
    inS.endReadParams();
    ServerState ret = this->getServerState(::std::move(iceP_id), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::Admin::_iceD_getServerPid(::IceInternal::Incoming& inS, const ::Ice::Current& current) const
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_id;
    istr->readAll(iceP_id);
    inS.endReadParams();
    int ret = this->getServerPid(::std::move(iceP_id), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::Admin::_iceD_getServerAdminCategory(::IceInternal::Incoming& inS, const ::Ice::Current& current) const
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    inS.readEmptyParams();
    ::std::string ret = this->getServerAdminCategory(current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::Admin::_iceD_getServerAdmin(::IceInternal::Incoming& inS, const ::Ice::Current& current) const
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_id;
    istr->readAll(iceP_id);
    inS.endReadParams();
    ::std::shared_ptr<::Ice::ObjectPrx> ret = this->getServerAdmin(::std::move(iceP_id), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::Admin::_iceD_enableServer(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_id;
    bool iceP_enabled;
    istr->readAll(iceP_id, iceP_enabled);
    inS.endReadParams();
    this->enableServer(::std::move(iceP_id), iceP_enabled, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::Admin::_iceD_isServerEnabled(::IceInternal::Incoming& inS, const ::Ice::Current& current) const
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_id;
    istr->readAll(iceP_id);
    inS.endReadParams();
    bool ret = this->isServerEnabled(::std::move(iceP_id), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::Admin::_iceD_startServer(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_id;
    istr->readAll(iceP_id);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    this->startServerAsync(::std::move(iceP_id), inA->response(), inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::Admin::_iceD_stopServer(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_id;
    istr->readAll(iceP_id);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    this->stopServerAsync(::std::move(iceP_id), inA->response(), inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::Admin::_iceD_patchServer(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_id;
    bool iceP_shutdown;
    istr->readAll(iceP_id, iceP_shutdown);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    this->patchServerAsync(::std::move(iceP_id), iceP_shutdown, inA->response(), inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::Admin::_iceD_sendSignal(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_id;
    ::std::string iceP_signal;
    istr->readAll(iceP_id, iceP_signal);
    inS.endReadParams();
    this->sendSignal(::std::move(iceP_id), ::std::move(iceP_signal), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::Admin::_iceD_getAllServerIds(::IceInternal::Incoming& inS, const ::Ice::Current& current) const
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    inS.readEmptyParams();
    ::Ice::StringSeq ret = this->getAllServerIds(current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::Admin::_iceD_getAdapterInfo(::IceInternal::Incoming& inS, const ::Ice::Current& current) const
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_id;
    istr->readAll(iceP_id);
    inS.endReadParams();
    AdapterInfoSeq ret = this->getAdapterInfo(::std::move(iceP_id), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::Admin::_iceD_removeAdapter(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_id;
    istr->readAll(iceP_id);
    inS.endReadParams();
    this->removeAdapter(::std::move(iceP_id), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::Admin::_iceD_getAllAdapterIds(::IceInternal::Incoming& inS, const ::Ice::Current& current) const
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    inS.readEmptyParams();
    ::Ice::StringSeq ret = this->getAllAdapterIds(current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::Admin::_iceD_addObject(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::shared_ptr<::Ice::ObjectPrx> iceP_obj;
    istr->readAll(iceP_obj);
    inS.endReadParams();
    this->addObject(::std::move(iceP_obj), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::Admin::_iceD_updateObject(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::shared_ptr<::Ice::ObjectPrx> iceP_obj;
    istr->readAll(iceP_obj);
    inS.endReadParams();
    this->updateObject(::std::move(iceP_obj), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::Admin::_iceD_addObjectWithType(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::shared_ptr<::Ice::ObjectPrx> iceP_obj;
    ::std::string iceP_type;
    istr->readAll(iceP_obj, iceP_type);
    inS.endReadParams();
    this->addObjectWithType(::std::move(iceP_obj), ::std::move(iceP_type), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::Admin::_iceD_removeObject(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::Ice::Identity iceP_id;
    istr->readAll(iceP_id);
    inS.endReadParams();
    this->removeObject(::std::move(iceP_id), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::Admin::_iceD_getObjectInfo(::IceInternal::Incoming& inS, const ::Ice::Current& current) const
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    ::Ice::Identity iceP_id;
    istr->readAll(iceP_id);
    inS.endReadParams();
    ObjectInfo ret = this->getObjectInfo(::std::move(iceP_id), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::Admin::_iceD_getObjectInfosByType(::IceInternal::Incoming& inS, const ::Ice::Current& current) const
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_type;
    istr->readAll(iceP_type);
    inS.endReadParams();
    ObjectInfoSeq ret = this->getObjectInfosByType(::std::move(iceP_type), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::Admin::_iceD_getAllObjectInfos(::IceInternal::Incoming& inS, const ::Ice::Current& current) const
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_expr;
    istr->readAll(iceP_expr);
    inS.endReadParams();
    ObjectInfoSeq ret = this->getAllObjectInfos(::std::move(iceP_expr), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::Admin::_iceD_pingNode(::IceInternal::Incoming& inS, const ::Ice::Current& current) const
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_name;
    istr->readAll(iceP_name);
    inS.endReadParams();
    bool ret = this->pingNode(::std::move(iceP_name), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::Admin::_iceD_getNodeLoad(::IceInternal::Incoming& inS, const ::Ice::Current& current) const
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_name;
    istr->readAll(iceP_name);
    inS.endReadParams();
    LoadInfo ret = this->getNodeLoad(::std::move(iceP_name), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::Admin::_iceD_getNodeInfo(::IceInternal::Incoming& inS, const ::Ice::Current& current) const
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_name;
    istr->readAll(iceP_name);
    inS.endReadParams();
    NodeInfo ret = this->getNodeInfo(::std::move(iceP_name), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::Admin::_iceD_getNodeAdmin(::IceInternal::Incoming& inS, const ::Ice::Current& current) const
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_name;
    istr->readAll(iceP_name);
    inS.endReadParams();
    ::std::shared_ptr<::Ice::ObjectPrx> ret = this->getNodeAdmin(::std::move(iceP_name), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::Admin::_iceD_getNodeProcessorSocketCount(::IceInternal::Incoming& inS, const ::Ice::Current& current) const
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_name;
    istr->readAll(iceP_name);
    inS.endReadParams();
    int ret = this->getNodeProcessorSocketCount(::std::move(iceP_name), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::Admin::_iceD_shutdownNode(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_name;
    istr->readAll(iceP_name);
    inS.endReadParams();
    this->shutdownNode(::std::move(iceP_name), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::Admin::_iceD_getNodeHostname(::IceInternal::Incoming& inS, const ::Ice::Current& current) const
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_name;
    istr->readAll(iceP_name);
    inS.endReadParams();
    ::std::string ret = this->getNodeHostname(::std::move(iceP_name), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::Admin::_iceD_getAllNodeNames(::IceInternal::Incoming& inS, const ::Ice::Current& current) const
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    inS.readEmptyParams();
    ::Ice::StringSeq ret = this->getAllNodeNames(current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::Admin::_iceD_pingRegistry(::IceInternal::Incoming& inS, const ::Ice::Current& current) const
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_name;
    istr->readAll(iceP_name);
    inS.endReadParams();
    bool ret = this->pingRegistry(::std::move(iceP_name), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::Admin::_iceD_getRegistryInfo(::IceInternal::Incoming& inS, const ::Ice::Current& current) const
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_name;
    istr->readAll(iceP_name);
    inS.endReadParams();
    RegistryInfo ret = this->getRegistryInfo(::std::move(iceP_name), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::Admin::_iceD_getRegistryAdmin(::IceInternal::Incoming& inS, const ::Ice::Current& current) const
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_name;
    istr->readAll(iceP_name);
    inS.endReadParams();
    ::std::shared_ptr<::Ice::ObjectPrx> ret = this->getRegistryAdmin(::std::move(iceP_name), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::Admin::_iceD_shutdownRegistry(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_name;
    istr->readAll(iceP_name);
    inS.endReadParams();
    this->shutdownRegistry(::std::move(iceP_name), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::Admin::_iceD_getAllRegistryNames(::IceInternal::Incoming& inS, const ::Ice::Current& current) const
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    inS.readEmptyParams();
    ::Ice::StringSeq ret = this->getAllRegistryNames(current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::Admin::_iceD_shutdown(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    this->shutdown(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::Admin::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_IceGrid_Admin_ops, iceC_IceGrid_Admin_ops + 51, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_IceGrid_Admin_ops)
    {
        case 0:
        {
            return _iceD_addApplication(in, current);
        }
        case 1:
        {
            return _iceD_addObject(in, current);
        }
        case 2:
        {
            return _iceD_addObjectWithType(in, current);
        }
        case 3:
        {
            return _iceD_enableServer(in, current);
        }
        case 4:
        {
            return _iceD_getAdapterInfo(in, current);
        }
        case 5:
        {
            return _iceD_getAllAdapterIds(in, current);
        }
        case 6:
        {
            return _iceD_getAllApplicationNames(in, current);
        }
        case 7:
        {
            return _iceD_getAllNodeNames(in, current);
        }
        case 8:
        {
            return _iceD_getAllObjectInfos(in, current);
        }
        case 9:
        {
            return _iceD_getAllRegistryNames(in, current);
        }
        case 10:
        {
            return _iceD_getAllServerIds(in, current);
        }
        case 11:
        {
            return _iceD_getApplicationInfo(in, current);
        }
        case 12:
        {
            return _iceD_getDefaultApplicationDescriptor(in, current);
        }
        case 13:
        {
            return _iceD_getNodeAdmin(in, current);
        }
        case 14:
        {
            return _iceD_getNodeHostname(in, current);
        }
        case 15:
        {
            return _iceD_getNodeInfo(in, current);
        }
        case 16:
        {
            return _iceD_getNodeLoad(in, current);
        }
        case 17:
        {
            return _iceD_getNodeProcessorSocketCount(in, current);
        }
        case 18:
        {
            return _iceD_getObjectInfo(in, current);
        }
        case 19:
        {
            return _iceD_getObjectInfosByType(in, current);
        }
        case 20:
        {
            return _iceD_getRegistryAdmin(in, current);
        }
        case 21:
        {
            return _iceD_getRegistryInfo(in, current);
        }
        case 22:
        {
            return _iceD_getServerAdmin(in, current);
        }
        case 23:
        {
            return _iceD_getServerAdminCategory(in, current);
        }
        case 24:
        {
            return _iceD_getServerInfo(in, current);
        }
        case 25:
        {
            return _iceD_getServerPid(in, current);
        }
        case 26:
        {
            return _iceD_getServerState(in, current);
        }
        case 27:
        {
            return _iceD_ice_id(in, current);
        }
        case 28:
        {
            return _iceD_ice_ids(in, current);
        }
        case 29:
        {
            return _iceD_ice_isA(in, current);
        }
        case 30:
        {
            return _iceD_ice_ping(in, current);
        }
        case 31:
        {
            return _iceD_instantiateServer(in, current);
        }
        case 32:
        {
            return _iceD_isServerEnabled(in, current);
        }
        case 33:
        {
            return _iceD_patchApplication(in, current);
        }
        case 34:
        {
            return _iceD_patchServer(in, current);
        }
        case 35:
        {
            return _iceD_pingNode(in, current);
        }
        case 36:
        {
            return _iceD_pingRegistry(in, current);
        }
        case 37:
        {
            return _iceD_removeAdapter(in, current);
        }
        case 38:
        {
            return _iceD_removeApplication(in, current);
        }
        case 39:
        {
            return _iceD_removeObject(in, current);
        }
        case 40:
        {
            return _iceD_sendSignal(in, current);
        }
        case 41:
        {
            return _iceD_shutdown(in, current);
        }
        case 42:
        {
            return _iceD_shutdownNode(in, current);
        }
        case 43:
        {
            return _iceD_shutdownRegistry(in, current);
        }
        case 44:
        {
            return _iceD_startServer(in, current);
        }
        case 45:
        {
            return _iceD_stopServer(in, current);
        }
        case 46:
        {
            return _iceD_syncApplication(in, current);
        }
        case 47:
        {
            return _iceD_syncApplicationWithoutRestart(in, current);
        }
        case 48:
        {
            return _iceD_updateApplication(in, current);
        }
        case 49:
        {
            return _iceD_updateApplicationWithoutRestart(in, current);
        }
        case 50:
        {
            return _iceD_updateObject(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

bool
IceGrid::FileIterator::ice_isA(::std::string s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_IceGrid_FileIterator_ids, iceC_IceGrid_FileIterator_ids + 2, s);
}

::std::vector<::std::string>
IceGrid::FileIterator::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector<::std::string>(&iceC_IceGrid_FileIterator_ids[0], &iceC_IceGrid_FileIterator_ids[2]);
}

::std::string
IceGrid::FileIterator::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
IceGrid::FileIterator::ice_staticId()
{
    static const ::std::string typeId = "::IceGrid::FileIterator";
    return typeId;
}

/// \cond INTERNAL
bool
IceGrid::FileIterator::_iceD_read(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    int iceP_size;
    istr->readAll(iceP_size);
    inS.endReadParams();
    ::Ice::StringSeq iceP_lines;
    bool ret = this->read(iceP_size, iceP_lines, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_lines, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::FileIterator::_iceD_destroy(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    this->destroy(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::FileIterator::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_IceGrid_FileIterator_ops, iceC_IceGrid_FileIterator_ops + 6, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_IceGrid_FileIterator_ops)
    {
        case 0:
        {
            return _iceD_destroy(in, current);
        }
        case 1:
        {
            return _iceD_ice_id(in, current);
        }
        case 2:
        {
            return _iceD_ice_ids(in, current);
        }
        case 3:
        {
            return _iceD_ice_isA(in, current);
        }
        case 4:
        {
            return _iceD_ice_ping(in, current);
        }
        case 5:
        {
            return _iceD_read(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

bool
IceGrid::RegistryObserver::ice_isA(::std::string s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_IceGrid_RegistryObserver_ids, iceC_IceGrid_RegistryObserver_ids + 2, s);
}

::std::vector<::std::string>
IceGrid::RegistryObserver::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector<::std::string>(&iceC_IceGrid_RegistryObserver_ids[0], &iceC_IceGrid_RegistryObserver_ids[2]);
}

::std::string
IceGrid::RegistryObserver::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
IceGrid::RegistryObserver::ice_staticId()
{
    static const ::std::string typeId = "::IceGrid::RegistryObserver";
    return typeId;
}

/// \cond INTERNAL
bool
IceGrid::RegistryObserver::_iceD_registryInit(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    RegistryInfoSeq iceP_registries;
    istr->readAll(iceP_registries);
    inS.endReadParams();
    this->registryInit(::std::move(iceP_registries), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::RegistryObserver::_iceD_registryUp(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    RegistryInfo iceP_node;
    istr->readAll(iceP_node);
    inS.endReadParams();
    this->registryUp(::std::move(iceP_node), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::RegistryObserver::_iceD_registryDown(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_name;
    istr->readAll(iceP_name);
    inS.endReadParams();
    this->registryDown(::std::move(iceP_name), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::RegistryObserver::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_IceGrid_RegistryObserver_ops, iceC_IceGrid_RegistryObserver_ops + 7, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_IceGrid_RegistryObserver_ops)
    {
        case 0:
        {
            return _iceD_ice_id(in, current);
        }
        case 1:
        {
            return _iceD_ice_ids(in, current);
        }
        case 2:
        {
            return _iceD_ice_isA(in, current);
        }
        case 3:
        {
            return _iceD_ice_ping(in, current);
        }
        case 4:
        {
            return _iceD_registryDown(in, current);
        }
        case 5:
        {
            return _iceD_registryInit(in, current);
        }
        case 6:
        {
            return _iceD_registryUp(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

bool
IceGrid::NodeObserver::ice_isA(::std::string s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_IceGrid_NodeObserver_ids, iceC_IceGrid_NodeObserver_ids + 2, s);
}

::std::vector<::std::string>
IceGrid::NodeObserver::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector<::std::string>(&iceC_IceGrid_NodeObserver_ids[0], &iceC_IceGrid_NodeObserver_ids[2]);
}

::std::string
IceGrid::NodeObserver::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
IceGrid::NodeObserver::ice_staticId()
{
    static const ::std::string typeId = "::IceGrid::NodeObserver";
    return typeId;
}

/// \cond INTERNAL
bool
IceGrid::NodeObserver::_iceD_nodeInit(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    NodeDynamicInfoSeq iceP_nodes;
    istr->readAll(iceP_nodes);
    inS.endReadParams();
    this->nodeInit(::std::move(iceP_nodes), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::NodeObserver::_iceD_nodeUp(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    NodeDynamicInfo iceP_node;
    istr->readAll(iceP_node);
    inS.endReadParams();
    this->nodeUp(::std::move(iceP_node), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::NodeObserver::_iceD_nodeDown(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_name;
    istr->readAll(iceP_name);
    inS.endReadParams();
    this->nodeDown(::std::move(iceP_name), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::NodeObserver::_iceD_updateServer(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_node;
    ServerDynamicInfo iceP_updatedInfo;
    istr->readAll(iceP_node, iceP_updatedInfo);
    inS.endReadParams();
    this->updateServer(::std::move(iceP_node), ::std::move(iceP_updatedInfo), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::NodeObserver::_iceD_updateAdapter(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_node;
    AdapterDynamicInfo iceP_updatedInfo;
    istr->readAll(iceP_node, iceP_updatedInfo);
    inS.endReadParams();
    this->updateAdapter(::std::move(iceP_node), ::std::move(iceP_updatedInfo), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::NodeObserver::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_IceGrid_NodeObserver_ops, iceC_IceGrid_NodeObserver_ops + 9, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_IceGrid_NodeObserver_ops)
    {
        case 0:
        {
            return _iceD_ice_id(in, current);
        }
        case 1:
        {
            return _iceD_ice_ids(in, current);
        }
        case 2:
        {
            return _iceD_ice_isA(in, current);
        }
        case 3:
        {
            return _iceD_ice_ping(in, current);
        }
        case 4:
        {
            return _iceD_nodeDown(in, current);
        }
        case 5:
        {
            return _iceD_nodeInit(in, current);
        }
        case 6:
        {
            return _iceD_nodeUp(in, current);
        }
        case 7:
        {
            return _iceD_updateAdapter(in, current);
        }
        case 8:
        {
            return _iceD_updateServer(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

bool
IceGrid::ApplicationObserver::ice_isA(::std::string s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_IceGrid_ApplicationObserver_ids, iceC_IceGrid_ApplicationObserver_ids + 2, s);
}

::std::vector<::std::string>
IceGrid::ApplicationObserver::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector<::std::string>(&iceC_IceGrid_ApplicationObserver_ids[0], &iceC_IceGrid_ApplicationObserver_ids[2]);
}

::std::string
IceGrid::ApplicationObserver::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
IceGrid::ApplicationObserver::ice_staticId()
{
    static const ::std::string typeId = "::IceGrid::ApplicationObserver";
    return typeId;
}

/// \cond INTERNAL
bool
IceGrid::ApplicationObserver::_iceD_applicationInit(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    int iceP_serial;
    ApplicationInfoSeq iceP_applications;
    istr->readAll(iceP_serial, iceP_applications);
    istr->readPendingValues();
    inS.endReadParams();
    this->applicationInit(iceP_serial, ::std::move(iceP_applications), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::ApplicationObserver::_iceD_applicationAdded(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    int iceP_serial;
    ApplicationInfo iceP_desc;
    istr->readAll(iceP_serial, iceP_desc);
    istr->readPendingValues();
    inS.endReadParams();
    this->applicationAdded(iceP_serial, ::std::move(iceP_desc), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::ApplicationObserver::_iceD_applicationRemoved(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    int iceP_serial;
    ::std::string iceP_name;
    istr->readAll(iceP_serial, iceP_name);
    inS.endReadParams();
    this->applicationRemoved(iceP_serial, ::std::move(iceP_name), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::ApplicationObserver::_iceD_applicationUpdated(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    int iceP_serial;
    ApplicationUpdateInfo iceP_desc;
    istr->readAll(iceP_serial, iceP_desc);
    istr->readPendingValues();
    inS.endReadParams();
    this->applicationUpdated(iceP_serial, ::std::move(iceP_desc), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::ApplicationObserver::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_IceGrid_ApplicationObserver_ops, iceC_IceGrid_ApplicationObserver_ops + 8, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_IceGrid_ApplicationObserver_ops)
    {
        case 0:
        {
            return _iceD_applicationAdded(in, current);
        }
        case 1:
        {
            return _iceD_applicationInit(in, current);
        }
        case 2:
        {
            return _iceD_applicationRemoved(in, current);
        }
        case 3:
        {
            return _iceD_applicationUpdated(in, current);
        }
        case 4:
        {
            return _iceD_ice_id(in, current);
        }
        case 5:
        {
            return _iceD_ice_ids(in, current);
        }
        case 6:
        {
            return _iceD_ice_isA(in, current);
        }
        case 7:
        {
            return _iceD_ice_ping(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

bool
IceGrid::AdapterObserver::ice_isA(::std::string s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_IceGrid_AdapterObserver_ids, iceC_IceGrid_AdapterObserver_ids + 2, s);
}

::std::vector<::std::string>
IceGrid::AdapterObserver::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector<::std::string>(&iceC_IceGrid_AdapterObserver_ids[0], &iceC_IceGrid_AdapterObserver_ids[2]);
}

::std::string
IceGrid::AdapterObserver::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
IceGrid::AdapterObserver::ice_staticId()
{
    static const ::std::string typeId = "::IceGrid::AdapterObserver";
    return typeId;
}

/// \cond INTERNAL
bool
IceGrid::AdapterObserver::_iceD_adapterInit(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    AdapterInfoSeq iceP_adpts;
    istr->readAll(iceP_adpts);
    inS.endReadParams();
    this->adapterInit(::std::move(iceP_adpts), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::AdapterObserver::_iceD_adapterAdded(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    AdapterInfo iceP_info;
    istr->readAll(iceP_info);
    inS.endReadParams();
    this->adapterAdded(::std::move(iceP_info), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::AdapterObserver::_iceD_adapterUpdated(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    AdapterInfo iceP_info;
    istr->readAll(iceP_info);
    inS.endReadParams();
    this->adapterUpdated(::std::move(iceP_info), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::AdapterObserver::_iceD_adapterRemoved(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_id;
    istr->readAll(iceP_id);
    inS.endReadParams();
    this->adapterRemoved(::std::move(iceP_id), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::AdapterObserver::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_IceGrid_AdapterObserver_ops, iceC_IceGrid_AdapterObserver_ops + 8, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_IceGrid_AdapterObserver_ops)
    {
        case 0:
        {
            return _iceD_adapterAdded(in, current);
        }
        case 1:
        {
            return _iceD_adapterInit(in, current);
        }
        case 2:
        {
            return _iceD_adapterRemoved(in, current);
        }
        case 3:
        {
            return _iceD_adapterUpdated(in, current);
        }
        case 4:
        {
            return _iceD_ice_id(in, current);
        }
        case 5:
        {
            return _iceD_ice_ids(in, current);
        }
        case 6:
        {
            return _iceD_ice_isA(in, current);
        }
        case 7:
        {
            return _iceD_ice_ping(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

bool
IceGrid::ObjectObserver::ice_isA(::std::string s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_IceGrid_ObjectObserver_ids, iceC_IceGrid_ObjectObserver_ids + 2, s);
}

::std::vector<::std::string>
IceGrid::ObjectObserver::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector<::std::string>(&iceC_IceGrid_ObjectObserver_ids[0], &iceC_IceGrid_ObjectObserver_ids[2]);
}

::std::string
IceGrid::ObjectObserver::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
IceGrid::ObjectObserver::ice_staticId()
{
    static const ::std::string typeId = "::IceGrid::ObjectObserver";
    return typeId;
}

/// \cond INTERNAL
bool
IceGrid::ObjectObserver::_iceD_objectInit(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ObjectInfoSeq iceP_objects;
    istr->readAll(iceP_objects);
    inS.endReadParams();
    this->objectInit(::std::move(iceP_objects), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::ObjectObserver::_iceD_objectAdded(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ObjectInfo iceP_info;
    istr->readAll(iceP_info);
    inS.endReadParams();
    this->objectAdded(::std::move(iceP_info), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::ObjectObserver::_iceD_objectUpdated(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ObjectInfo iceP_info;
    istr->readAll(iceP_info);
    inS.endReadParams();
    this->objectUpdated(::std::move(iceP_info), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::ObjectObserver::_iceD_objectRemoved(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::Ice::Identity iceP_id;
    istr->readAll(iceP_id);
    inS.endReadParams();
    this->objectRemoved(::std::move(iceP_id), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::ObjectObserver::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_IceGrid_ObjectObserver_ops, iceC_IceGrid_ObjectObserver_ops + 8, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_IceGrid_ObjectObserver_ops)
    {
        case 0:
        {
            return _iceD_ice_id(in, current);
        }
        case 1:
        {
            return _iceD_ice_ids(in, current);
        }
        case 2:
        {
            return _iceD_ice_isA(in, current);
        }
        case 3:
        {
            return _iceD_ice_ping(in, current);
        }
        case 4:
        {
            return _iceD_objectAdded(in, current);
        }
        case 5:
        {
            return _iceD_objectInit(in, current);
        }
        case 6:
        {
            return _iceD_objectRemoved(in, current);
        }
        case 7:
        {
            return _iceD_objectUpdated(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

bool
IceGrid::AdminSession::ice_isA(::std::string s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_IceGrid_AdminSession_ids, iceC_IceGrid_AdminSession_ids + 3, s);
}

::std::vector<::std::string>
IceGrid::AdminSession::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector<::std::string>(&iceC_IceGrid_AdminSession_ids[0], &iceC_IceGrid_AdminSession_ids[3]);
}

::std::string
IceGrid::AdminSession::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
IceGrid::AdminSession::ice_staticId()
{
    static const ::std::string typeId = "::IceGrid::AdminSession";
    return typeId;
}

/// \cond INTERNAL
bool
IceGrid::AdminSession::_iceD_keepAlive(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    inS.readEmptyParams();
    this->keepAlive(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::AdminSession::_iceD_getAdmin(::IceInternal::Incoming& inS, const ::Ice::Current& current) const
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    inS.readEmptyParams();
    ::std::shared_ptr<AdminPrx> ret = this->getAdmin(current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::AdminSession::_iceD_getAdminCallbackTemplate(::IceInternal::Incoming& inS, const ::Ice::Current& current) const
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    inS.readEmptyParams();
    ::std::shared_ptr<::Ice::ObjectPrx> ret = this->getAdminCallbackTemplate(current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::AdminSession::_iceD_setObservers(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    ::std::shared_ptr<RegistryObserverPrx> iceP_registryObs;
    ::std::shared_ptr<NodeObserverPrx> iceP_nodeObs;
    ::std::shared_ptr<ApplicationObserverPrx> iceP_appObs;
    ::std::shared_ptr<AdapterObserverPrx> iceP_adptObs;
    ::std::shared_ptr<ObjectObserverPrx> iceP_objObs;
    istr->readAll(iceP_registryObs, iceP_nodeObs, iceP_appObs, iceP_adptObs, iceP_objObs);
    inS.endReadParams();
    this->setObservers(::std::move(iceP_registryObs), ::std::move(iceP_nodeObs), ::std::move(iceP_appObs), ::std::move(iceP_adptObs), ::std::move(iceP_objObs), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::AdminSession::_iceD_setObserversByIdentity(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    ::Ice::Identity iceP_registryObs;
    ::Ice::Identity iceP_nodeObs;
    ::Ice::Identity iceP_appObs;
    ::Ice::Identity iceP_adptObs;
    ::Ice::Identity iceP_objObs;
    istr->readAll(iceP_registryObs, iceP_nodeObs, iceP_appObs, iceP_adptObs, iceP_objObs);
    inS.endReadParams();
    this->setObserversByIdentity(::std::move(iceP_registryObs), ::std::move(iceP_nodeObs), ::std::move(iceP_appObs), ::std::move(iceP_adptObs), ::std::move(iceP_objObs), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::AdminSession::_iceD_startUpdate(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    int ret = this->startUpdate(current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::AdminSession::_iceD_finishUpdate(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    this->finishUpdate(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::AdminSession::_iceD_getReplicaName(::IceInternal::Incoming& inS, const ::Ice::Current& current) const
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    inS.readEmptyParams();
    ::std::string ret = this->getReplicaName(current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::AdminSession::_iceD_openServerLog(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_id;
    ::std::string iceP_path;
    int iceP_count;
    istr->readAll(iceP_id, iceP_path, iceP_count);
    inS.endReadParams();
    ::std::shared_ptr<FileIteratorPrx> ret = this->openServerLog(::std::move(iceP_id), ::std::move(iceP_path), iceP_count, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::AdminSession::_iceD_openServerStdErr(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_id;
    int iceP_count;
    istr->readAll(iceP_id, iceP_count);
    inS.endReadParams();
    ::std::shared_ptr<FileIteratorPrx> ret = this->openServerStdErr(::std::move(iceP_id), iceP_count, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::AdminSession::_iceD_openServerStdOut(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_id;
    int iceP_count;
    istr->readAll(iceP_id, iceP_count);
    inS.endReadParams();
    ::std::shared_ptr<FileIteratorPrx> ret = this->openServerStdOut(::std::move(iceP_id), iceP_count, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::AdminSession::_iceD_openNodeStdErr(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_name;
    int iceP_count;
    istr->readAll(iceP_name, iceP_count);
    inS.endReadParams();
    ::std::shared_ptr<FileIteratorPrx> ret = this->openNodeStdErr(::std::move(iceP_name), iceP_count, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::AdminSession::_iceD_openNodeStdOut(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_name;
    int iceP_count;
    istr->readAll(iceP_name, iceP_count);
    inS.endReadParams();
    ::std::shared_ptr<FileIteratorPrx> ret = this->openNodeStdOut(::std::move(iceP_name), iceP_count, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::AdminSession::_iceD_openRegistryStdErr(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_name;
    int iceP_count;
    istr->readAll(iceP_name, iceP_count);
    inS.endReadParams();
    ::std::shared_ptr<FileIteratorPrx> ret = this->openRegistryStdErr(::std::move(iceP_name), iceP_count, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::AdminSession::_iceD_openRegistryStdOut(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_name;
    int iceP_count;
    istr->readAll(iceP_name, iceP_count);
    inS.endReadParams();
    ::std::shared_ptr<FileIteratorPrx> ret = this->openRegistryStdOut(::std::move(iceP_name), iceP_count, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::AdminSession::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_IceGrid_AdminSession_ops, iceC_IceGrid_AdminSession_ops + 20, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_IceGrid_AdminSession_ops)
    {
        case 0:
        {
            return _iceD_destroy(in, current);
        }
        case 1:
        {
            return _iceD_finishUpdate(in, current);
        }
        case 2:
        {
            return _iceD_getAdmin(in, current);
        }
        case 3:
        {
            return _iceD_getAdminCallbackTemplate(in, current);
        }
        case 4:
        {
            return _iceD_getReplicaName(in, current);
        }
        case 5:
        {
            return _iceD_ice_id(in, current);
        }
        case 6:
        {
            return _iceD_ice_ids(in, current);
        }
        case 7:
        {
            return _iceD_ice_isA(in, current);
        }
        case 8:
        {
            return _iceD_ice_ping(in, current);
        }
        case 9:
        {
            return _iceD_keepAlive(in, current);
        }
        case 10:
        {
            return _iceD_openNodeStdErr(in, current);
        }
        case 11:
        {
            return _iceD_openNodeStdOut(in, current);
        }
        case 12:
        {
            return _iceD_openRegistryStdErr(in, current);
        }
        case 13:
        {
            return _iceD_openRegistryStdOut(in, current);
        }
        case 14:
        {
            return _iceD_openServerLog(in, current);
        }
        case 15:
        {
            return _iceD_openServerStdErr(in, current);
        }
        case 16:
        {
            return _iceD_openServerStdOut(in, current);
        }
        case 17:
        {
            return _iceD_setObservers(in, current);
        }
        case 18:
        {
            return _iceD_setObserversByIdentity(in, current);
        }
        case 19:
        {
            return _iceD_startUpdate(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

namespace Ice
{
}
