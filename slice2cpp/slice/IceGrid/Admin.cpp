//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.8.0-alpha.0
//
// <auto-generated>
//
// Generated from file `Admin.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef ICEGRID_API_EXPORTS
#   define ICEGRID_API_EXPORTS
#endif
#define ICE_BUILDING_GENERATED_CODE
#include <Admin.h>
#include <Ice/OutgoingAsync.h>

#if defined(_MSC_VER)
#   pragma warning(disable:4458) // declaration of ... hides class member
#elif defined(__clang__)
#   pragma clang diagnostic ignored "-Wshadow"
#elif defined(__GNUC__)
#   pragma GCC diagnostic ignored "-Wshadow"
#endif

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION  != 30850
#       error Ice version mismatch: an exact match is required for beta generated code
#   endif
#endif

namespace
{

}

void
IceGrid::AdminPrx::addApplication(const ApplicationDescriptor& iceP_descriptor, const ::Ice::Context& context) const
{
    ::IceInternal::makePromiseOutgoing<void>(true, this, &AdminPrx::_iceI_addApplication, iceP_descriptor, context).get();
}

::std::future<void>
IceGrid::AdminPrx::addApplicationAsync(const ApplicationDescriptor& iceP_descriptor, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<void>(false, this, &AdminPrx::_iceI_addApplication, iceP_descriptor, context);
}

::std::function<void()>
IceGrid::AdminPrx::addApplicationAsync(const ApplicationDescriptor& iceP_descriptor, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminPrx::_iceI_addApplication, iceP_descriptor, context);
}

void
IceGrid::AdminPrx::_iceI_addApplication(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ApplicationDescriptor& iceP_descriptor, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "addApplication";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_descriptor);
            ostr->writePendingValues();
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const AccessDeniedException&)
            {
                throw;
            }
            catch(const DeploymentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}

void
IceGrid::AdminPrx::syncApplication(const ApplicationDescriptor& iceP_descriptor, const ::Ice::Context& context) const
{
    ::IceInternal::makePromiseOutgoing<void>(true, this, &AdminPrx::_iceI_syncApplication, iceP_descriptor, context).get();
}

::std::future<void>
IceGrid::AdminPrx::syncApplicationAsync(const ApplicationDescriptor& iceP_descriptor, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<void>(false, this, &AdminPrx::_iceI_syncApplication, iceP_descriptor, context);
}

::std::function<void()>
IceGrid::AdminPrx::syncApplicationAsync(const ApplicationDescriptor& iceP_descriptor, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminPrx::_iceI_syncApplication, iceP_descriptor, context);
}

void
IceGrid::AdminPrx::_iceI_syncApplication(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ApplicationDescriptor& iceP_descriptor, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "syncApplication";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_descriptor);
            ostr->writePendingValues();
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const AccessDeniedException&)
            {
                throw;
            }
            catch(const ApplicationNotExistException&)
            {
                throw;
            }
            catch(const DeploymentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}

void
IceGrid::AdminPrx::updateApplication(const ApplicationUpdateDescriptor& iceP_descriptor, const ::Ice::Context& context) const
{
    ::IceInternal::makePromiseOutgoing<void>(true, this, &AdminPrx::_iceI_updateApplication, iceP_descriptor, context).get();
}

::std::future<void>
IceGrid::AdminPrx::updateApplicationAsync(const ApplicationUpdateDescriptor& iceP_descriptor, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<void>(false, this, &AdminPrx::_iceI_updateApplication, iceP_descriptor, context);
}

::std::function<void()>
IceGrid::AdminPrx::updateApplicationAsync(const ApplicationUpdateDescriptor& iceP_descriptor, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminPrx::_iceI_updateApplication, iceP_descriptor, context);
}

void
IceGrid::AdminPrx::_iceI_updateApplication(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ApplicationUpdateDescriptor& iceP_descriptor, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "updateApplication";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_descriptor);
            ostr->writePendingValues();
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const AccessDeniedException&)
            {
                throw;
            }
            catch(const ApplicationNotExistException&)
            {
                throw;
            }
            catch(const DeploymentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}

void
IceGrid::AdminPrx::syncApplicationWithoutRestart(const ApplicationDescriptor& iceP_descriptor, const ::Ice::Context& context) const
{
    ::IceInternal::makePromiseOutgoing<void>(true, this, &AdminPrx::_iceI_syncApplicationWithoutRestart, iceP_descriptor, context).get();
}

::std::future<void>
IceGrid::AdminPrx::syncApplicationWithoutRestartAsync(const ApplicationDescriptor& iceP_descriptor, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<void>(false, this, &AdminPrx::_iceI_syncApplicationWithoutRestart, iceP_descriptor, context);
}

::std::function<void()>
IceGrid::AdminPrx::syncApplicationWithoutRestartAsync(const ApplicationDescriptor& iceP_descriptor, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminPrx::_iceI_syncApplicationWithoutRestart, iceP_descriptor, context);
}

void
IceGrid::AdminPrx::_iceI_syncApplicationWithoutRestart(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ApplicationDescriptor& iceP_descriptor, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "syncApplicationWithoutRestart";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_descriptor);
            ostr->writePendingValues();
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const AccessDeniedException&)
            {
                throw;
            }
            catch(const ApplicationNotExistException&)
            {
                throw;
            }
            catch(const DeploymentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}

void
IceGrid::AdminPrx::updateApplicationWithoutRestart(const ApplicationUpdateDescriptor& iceP_descriptor, const ::Ice::Context& context) const
{
    ::IceInternal::makePromiseOutgoing<void>(true, this, &AdminPrx::_iceI_updateApplicationWithoutRestart, iceP_descriptor, context).get();
}

::std::future<void>
IceGrid::AdminPrx::updateApplicationWithoutRestartAsync(const ApplicationUpdateDescriptor& iceP_descriptor, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<void>(false, this, &AdminPrx::_iceI_updateApplicationWithoutRestart, iceP_descriptor, context);
}

::std::function<void()>
IceGrid::AdminPrx::updateApplicationWithoutRestartAsync(const ApplicationUpdateDescriptor& iceP_descriptor, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminPrx::_iceI_updateApplicationWithoutRestart, iceP_descriptor, context);
}

void
IceGrid::AdminPrx::_iceI_updateApplicationWithoutRestart(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ApplicationUpdateDescriptor& iceP_descriptor, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "updateApplicationWithoutRestart";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_descriptor);
            ostr->writePendingValues();
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const AccessDeniedException&)
            {
                throw;
            }
            catch(const ApplicationNotExistException&)
            {
                throw;
            }
            catch(const DeploymentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}

void
IceGrid::AdminPrx::removeApplication(::std::string_view iceP_name, const ::Ice::Context& context) const
{
    ::IceInternal::makePromiseOutgoing<void>(true, this, &AdminPrx::_iceI_removeApplication, iceP_name, context).get();
}

::std::future<void>
IceGrid::AdminPrx::removeApplicationAsync(::std::string_view iceP_name, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<void>(false, this, &AdminPrx::_iceI_removeApplication, iceP_name, context);
}

::std::function<void()>
IceGrid::AdminPrx::removeApplicationAsync(::std::string_view iceP_name, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminPrx::_iceI_removeApplication, iceP_name, context);
}

void
IceGrid::AdminPrx::_iceI_removeApplication(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, ::std::string_view iceP_name, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "removeApplication";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_name);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const AccessDeniedException&)
            {
                throw;
            }
            catch(const ApplicationNotExistException&)
            {
                throw;
            }
            catch(const DeploymentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}

void
IceGrid::AdminPrx::instantiateServer(::std::string_view iceP_application, ::std::string_view iceP_node, const ServerInstanceDescriptor& iceP_desc, const ::Ice::Context& context) const
{
    ::IceInternal::makePromiseOutgoing<void>(true, this, &AdminPrx::_iceI_instantiateServer, iceP_application, iceP_node, iceP_desc, context).get();
}

::std::future<void>
IceGrid::AdminPrx::instantiateServerAsync(::std::string_view iceP_application, ::std::string_view iceP_node, const ServerInstanceDescriptor& iceP_desc, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<void>(false, this, &AdminPrx::_iceI_instantiateServer, iceP_application, iceP_node, iceP_desc, context);
}

::std::function<void()>
IceGrid::AdminPrx::instantiateServerAsync(::std::string_view iceP_application, ::std::string_view iceP_node, const ServerInstanceDescriptor& iceP_desc, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminPrx::_iceI_instantiateServer, iceP_application, iceP_node, iceP_desc, context);
}

void
IceGrid::AdminPrx::_iceI_instantiateServer(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, ::std::string_view iceP_application, ::std::string_view iceP_node, const ServerInstanceDescriptor& iceP_desc, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "instantiateServer";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_application, iceP_node, iceP_desc);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const AccessDeniedException&)
            {
                throw;
            }
            catch(const ApplicationNotExistException&)
            {
                throw;
            }
            catch(const DeploymentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}

void
IceGrid::AdminPrx::patchApplication(::std::string_view iceP_name, bool iceP_shutdown, const ::Ice::Context& context) const
{
    ::IceInternal::makePromiseOutgoing<void>(true, this, &AdminPrx::_iceI_patchApplication, iceP_name, iceP_shutdown, context).get();
}

::std::future<void>
IceGrid::AdminPrx::patchApplicationAsync(::std::string_view iceP_name, bool iceP_shutdown, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<void>(false, this, &AdminPrx::_iceI_patchApplication, iceP_name, iceP_shutdown, context);
}

::std::function<void()>
IceGrid::AdminPrx::patchApplicationAsync(::std::string_view iceP_name, bool iceP_shutdown, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminPrx::_iceI_patchApplication, iceP_name, iceP_shutdown, context);
}

void
IceGrid::AdminPrx::_iceI_patchApplication(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, ::std::string_view iceP_name, bool iceP_shutdown, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "patchApplication";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_name, iceP_shutdown);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const PatchException&)
            {
                throw;
            }
            catch(const ApplicationNotExistException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}

::IceGrid::ApplicationInfo
IceGrid::AdminPrx::getApplicationInfo(::std::string_view iceP_name, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<ApplicationInfo>(true, this, &AdminPrx::_iceI_getApplicationInfo, iceP_name, context).get();
}

::std::future<::IceGrid::ApplicationInfo>
IceGrid::AdminPrx::getApplicationInfoAsync(::std::string_view iceP_name, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<ApplicationInfo>(false, this, &AdminPrx::_iceI_getApplicationInfo, iceP_name, context);
}

::std::function<void()>
IceGrid::AdminPrx::getApplicationInfoAsync(::std::string_view iceP_name, ::std::function<void(::IceGrid::ApplicationInfo)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<ApplicationInfo>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminPrx::_iceI_getApplicationInfo, iceP_name, context);
}

void
IceGrid::AdminPrx::_iceI_getApplicationInfo(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ApplicationInfo>>& outAsync, ::std::string_view iceP_name, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "getApplicationInfo";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Nonmutating, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_name);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const ApplicationNotExistException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        },
        [](::Ice::InputStream* istr)
        {
            ApplicationInfo ret;
            istr->readAll(ret);
            istr->readPendingValues();
            return ret;
        });
}

::IceGrid::ApplicationDescriptor
IceGrid::AdminPrx::getDefaultApplicationDescriptor(const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<ApplicationDescriptor>(true, this, &AdminPrx::_iceI_getDefaultApplicationDescriptor, context).get();
}

::std::future<::IceGrid::ApplicationDescriptor>
IceGrid::AdminPrx::getDefaultApplicationDescriptorAsync(const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<ApplicationDescriptor>(false, this, &AdminPrx::_iceI_getDefaultApplicationDescriptor, context);
}

::std::function<void()>
IceGrid::AdminPrx::getDefaultApplicationDescriptorAsync(::std::function<void(::IceGrid::ApplicationDescriptor)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<ApplicationDescriptor>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminPrx::_iceI_getDefaultApplicationDescriptor, context);
}

void
IceGrid::AdminPrx::_iceI_getDefaultApplicationDescriptor(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ApplicationDescriptor>>& outAsync, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "getDefaultApplicationDescriptor";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Nonmutating, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const DeploymentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        },
        [](::Ice::InputStream* istr)
        {
            ApplicationDescriptor ret;
            istr->readAll(ret);
            istr->readPendingValues();
            return ret;
        });
}

::Ice::StringSeq
IceGrid::AdminPrx::getAllApplicationNames(const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::Ice::StringSeq>(true, this, &AdminPrx::_iceI_getAllApplicationNames, context).get();
}

::std::future<::Ice::StringSeq>
IceGrid::AdminPrx::getAllApplicationNamesAsync(const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::Ice::StringSeq>(false, this, &AdminPrx::_iceI_getAllApplicationNames, context);
}

::std::function<void()>
IceGrid::AdminPrx::getAllApplicationNamesAsync(::std::function<void(::Ice::StringSeq)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<::Ice::StringSeq>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminPrx::_iceI_getAllApplicationNames, context);
}

void
IceGrid::AdminPrx::_iceI_getAllApplicationNames(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::Ice::StringSeq>>& outAsync, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "getAllApplicationNames";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Nonmutating, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}

::IceGrid::ServerInfo
IceGrid::AdminPrx::getServerInfo(::std::string_view iceP_id, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<ServerInfo>(true, this, &AdminPrx::_iceI_getServerInfo, iceP_id, context).get();
}

::std::future<::IceGrid::ServerInfo>
IceGrid::AdminPrx::getServerInfoAsync(::std::string_view iceP_id, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<ServerInfo>(false, this, &AdminPrx::_iceI_getServerInfo, iceP_id, context);
}

::std::function<void()>
IceGrid::AdminPrx::getServerInfoAsync(::std::string_view iceP_id, ::std::function<void(::IceGrid::ServerInfo)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<ServerInfo>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminPrx::_iceI_getServerInfo, iceP_id, context);
}

void
IceGrid::AdminPrx::_iceI_getServerInfo(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ServerInfo>>& outAsync, ::std::string_view iceP_id, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "getServerInfo";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Nonmutating, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_id);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const ServerNotExistException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        },
        [](::Ice::InputStream* istr)
        {
            ServerInfo ret;
            istr->readAll(ret);
            istr->readPendingValues();
            return ret;
        });
}

::IceGrid::ServerState
IceGrid::AdminPrx::getServerState(::std::string_view iceP_id, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<ServerState>(true, this, &AdminPrx::_iceI_getServerState, iceP_id, context).get();
}

::std::future<::IceGrid::ServerState>
IceGrid::AdminPrx::getServerStateAsync(::std::string_view iceP_id, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<ServerState>(false, this, &AdminPrx::_iceI_getServerState, iceP_id, context);
}

::std::function<void()>
IceGrid::AdminPrx::getServerStateAsync(::std::string_view iceP_id, ::std::function<void(::IceGrid::ServerState)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<ServerState>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminPrx::_iceI_getServerState, iceP_id, context);
}

void
IceGrid::AdminPrx::_iceI_getServerState(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ServerState>>& outAsync, ::std::string_view iceP_id, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "getServerState";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Nonmutating, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_id);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const ServerNotExistException&)
            {
                throw;
            }
            catch(const DeploymentException&)
            {
                throw;
            }
            catch(const NodeUnreachableException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}

::std::int32_t
IceGrid::AdminPrx::getServerPid(::std::string_view iceP_id, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::int32_t>(true, this, &AdminPrx::_iceI_getServerPid, iceP_id, context).get();
}

::std::future<::std::int32_t>
IceGrid::AdminPrx::getServerPidAsync(::std::string_view iceP_id, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::int32_t>(false, this, &AdminPrx::_iceI_getServerPid, iceP_id, context);
}

::std::function<void()>
IceGrid::AdminPrx::getServerPidAsync(::std::string_view iceP_id, ::std::function<void(::std::int32_t)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<::std::int32_t>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminPrx::_iceI_getServerPid, iceP_id, context);
}

void
IceGrid::AdminPrx::_iceI_getServerPid(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::int32_t>>& outAsync, ::std::string_view iceP_id, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "getServerPid";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Nonmutating, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_id);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const ServerNotExistException&)
            {
                throw;
            }
            catch(const DeploymentException&)
            {
                throw;
            }
            catch(const NodeUnreachableException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}

::std::string
IceGrid::AdminPrx::getServerAdminCategory(const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::string>(true, this, &AdminPrx::_iceI_getServerAdminCategory, context).get();
}

::std::future<::std::string>
IceGrid::AdminPrx::getServerAdminCategoryAsync(const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::string>(false, this, &AdminPrx::_iceI_getServerAdminCategory, context);
}

::std::function<void()>
IceGrid::AdminPrx::getServerAdminCategoryAsync(::std::function<void(::std::string)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<::std::string>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminPrx::_iceI_getServerAdminCategory, context);
}

void
IceGrid::AdminPrx::_iceI_getServerAdminCategory(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::string>>& outAsync, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "getServerAdminCategory";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}

::std::optional<::Ice::ObjectPrx>
IceGrid::AdminPrx::getServerAdmin(::std::string_view iceP_id, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::optional<::Ice::ObjectPrx>>(true, this, &AdminPrx::_iceI_getServerAdmin, iceP_id, context).get();
}

::std::future<::std::optional<::Ice::ObjectPrx>>
IceGrid::AdminPrx::getServerAdminAsync(::std::string_view iceP_id, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::optional<::Ice::ObjectPrx>>(false, this, &AdminPrx::_iceI_getServerAdmin, iceP_id, context);
}

::std::function<void()>
IceGrid::AdminPrx::getServerAdminAsync(::std::string_view iceP_id, ::std::function<void(::std::optional<::Ice::ObjectPrx>)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<::std::optional<::Ice::ObjectPrx>>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminPrx::_iceI_getServerAdmin, iceP_id, context);
}

void
IceGrid::AdminPrx::_iceI_getServerAdmin(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::optional<::Ice::ObjectPrx>>>& outAsync, ::std::string_view iceP_id, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "getServerAdmin";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_id);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const ServerNotExistException&)
            {
                throw;
            }
            catch(const DeploymentException&)
            {
                throw;
            }
            catch(const NodeUnreachableException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}

void
IceGrid::AdminPrx::enableServer(::std::string_view iceP_id, bool iceP_enabled, const ::Ice::Context& context) const
{
    ::IceInternal::makePromiseOutgoing<void>(true, this, &AdminPrx::_iceI_enableServer, iceP_id, iceP_enabled, context).get();
}

::std::future<void>
IceGrid::AdminPrx::enableServerAsync(::std::string_view iceP_id, bool iceP_enabled, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<void>(false, this, &AdminPrx::_iceI_enableServer, iceP_id, iceP_enabled, context);
}

::std::function<void()>
IceGrid::AdminPrx::enableServerAsync(::std::string_view iceP_id, bool iceP_enabled, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminPrx::_iceI_enableServer, iceP_id, iceP_enabled, context);
}

void
IceGrid::AdminPrx::_iceI_enableServer(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, ::std::string_view iceP_id, bool iceP_enabled, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "enableServer";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_id, iceP_enabled);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const ServerNotExistException&)
            {
                throw;
            }
            catch(const DeploymentException&)
            {
                throw;
            }
            catch(const NodeUnreachableException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}

bool
IceGrid::AdminPrx::isServerEnabled(::std::string_view iceP_id, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<bool>(true, this, &AdminPrx::_iceI_isServerEnabled, iceP_id, context).get();
}

::std::future<bool>
IceGrid::AdminPrx::isServerEnabledAsync(::std::string_view iceP_id, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<bool>(false, this, &AdminPrx::_iceI_isServerEnabled, iceP_id, context);
}

::std::function<void()>
IceGrid::AdminPrx::isServerEnabledAsync(::std::string_view iceP_id, ::std::function<void(bool)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<bool>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminPrx::_iceI_isServerEnabled, iceP_id, context);
}

void
IceGrid::AdminPrx::_iceI_isServerEnabled(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>& outAsync, ::std::string_view iceP_id, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "isServerEnabled";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Nonmutating, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_id);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const ServerNotExistException&)
            {
                throw;
            }
            catch(const DeploymentException&)
            {
                throw;
            }
            catch(const NodeUnreachableException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}

void
IceGrid::AdminPrx::startServer(::std::string_view iceP_id, const ::Ice::Context& context) const
{
    ::IceInternal::makePromiseOutgoing<void>(true, this, &AdminPrx::_iceI_startServer, iceP_id, context).get();
}

::std::future<void>
IceGrid::AdminPrx::startServerAsync(::std::string_view iceP_id, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<void>(false, this, &AdminPrx::_iceI_startServer, iceP_id, context);
}

::std::function<void()>
IceGrid::AdminPrx::startServerAsync(::std::string_view iceP_id, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminPrx::_iceI_startServer, iceP_id, context);
}

void
IceGrid::AdminPrx::_iceI_startServer(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, ::std::string_view iceP_id, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "startServer";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_id);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const ServerNotExistException&)
            {
                throw;
            }
            catch(const ServerStartException&)
            {
                throw;
            }
            catch(const DeploymentException&)
            {
                throw;
            }
            catch(const NodeUnreachableException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}

void
IceGrid::AdminPrx::stopServer(::std::string_view iceP_id, const ::Ice::Context& context) const
{
    ::IceInternal::makePromiseOutgoing<void>(true, this, &AdminPrx::_iceI_stopServer, iceP_id, context).get();
}

::std::future<void>
IceGrid::AdminPrx::stopServerAsync(::std::string_view iceP_id, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<void>(false, this, &AdminPrx::_iceI_stopServer, iceP_id, context);
}

::std::function<void()>
IceGrid::AdminPrx::stopServerAsync(::std::string_view iceP_id, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminPrx::_iceI_stopServer, iceP_id, context);
}

void
IceGrid::AdminPrx::_iceI_stopServer(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, ::std::string_view iceP_id, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "stopServer";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_id);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const ServerNotExistException&)
            {
                throw;
            }
            catch(const ServerStopException&)
            {
                throw;
            }
            catch(const DeploymentException&)
            {
                throw;
            }
            catch(const NodeUnreachableException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}

void
IceGrid::AdminPrx::patchServer(::std::string_view iceP_id, bool iceP_shutdown, const ::Ice::Context& context) const
{
    ::IceInternal::makePromiseOutgoing<void>(true, this, &AdminPrx::_iceI_patchServer, iceP_id, iceP_shutdown, context).get();
}

::std::future<void>
IceGrid::AdminPrx::patchServerAsync(::std::string_view iceP_id, bool iceP_shutdown, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<void>(false, this, &AdminPrx::_iceI_patchServer, iceP_id, iceP_shutdown, context);
}

::std::function<void()>
IceGrid::AdminPrx::patchServerAsync(::std::string_view iceP_id, bool iceP_shutdown, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminPrx::_iceI_patchServer, iceP_id, iceP_shutdown, context);
}

void
IceGrid::AdminPrx::_iceI_patchServer(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, ::std::string_view iceP_id, bool iceP_shutdown, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "patchServer";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_id, iceP_shutdown);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const PatchException&)
            {
                throw;
            }
            catch(const ServerNotExistException&)
            {
                throw;
            }
            catch(const DeploymentException&)
            {
                throw;
            }
            catch(const NodeUnreachableException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}

void
IceGrid::AdminPrx::sendSignal(::std::string_view iceP_id, ::std::string_view iceP_signal, const ::Ice::Context& context) const
{
    ::IceInternal::makePromiseOutgoing<void>(true, this, &AdminPrx::_iceI_sendSignal, iceP_id, iceP_signal, context).get();
}

::std::future<void>
IceGrid::AdminPrx::sendSignalAsync(::std::string_view iceP_id, ::std::string_view iceP_signal, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<void>(false, this, &AdminPrx::_iceI_sendSignal, iceP_id, iceP_signal, context);
}

::std::function<void()>
IceGrid::AdminPrx::sendSignalAsync(::std::string_view iceP_id, ::std::string_view iceP_signal, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminPrx::_iceI_sendSignal, iceP_id, iceP_signal, context);
}

void
IceGrid::AdminPrx::_iceI_sendSignal(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, ::std::string_view iceP_id, ::std::string_view iceP_signal, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "sendSignal";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_id, iceP_signal);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const BadSignalException&)
            {
                throw;
            }
            catch(const ServerNotExistException&)
            {
                throw;
            }
            catch(const DeploymentException&)
            {
                throw;
            }
            catch(const NodeUnreachableException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}

::Ice::StringSeq
IceGrid::AdminPrx::getAllServerIds(const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::Ice::StringSeq>(true, this, &AdminPrx::_iceI_getAllServerIds, context).get();
}

::std::future<::Ice::StringSeq>
IceGrid::AdminPrx::getAllServerIdsAsync(const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::Ice::StringSeq>(false, this, &AdminPrx::_iceI_getAllServerIds, context);
}

::std::function<void()>
IceGrid::AdminPrx::getAllServerIdsAsync(::std::function<void(::Ice::StringSeq)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<::Ice::StringSeq>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminPrx::_iceI_getAllServerIds, context);
}

void
IceGrid::AdminPrx::_iceI_getAllServerIds(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::Ice::StringSeq>>& outAsync, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "getAllServerIds";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Nonmutating, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}

::IceGrid::AdapterInfoSeq
IceGrid::AdminPrx::getAdapterInfo(::std::string_view iceP_id, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<AdapterInfoSeq>(true, this, &AdminPrx::_iceI_getAdapterInfo, iceP_id, context).get();
}

::std::future<::IceGrid::AdapterInfoSeq>
IceGrid::AdminPrx::getAdapterInfoAsync(::std::string_view iceP_id, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<AdapterInfoSeq>(false, this, &AdminPrx::_iceI_getAdapterInfo, iceP_id, context);
}

::std::function<void()>
IceGrid::AdminPrx::getAdapterInfoAsync(::std::string_view iceP_id, ::std::function<void(::IceGrid::AdapterInfoSeq)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<AdapterInfoSeq>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminPrx::_iceI_getAdapterInfo, iceP_id, context);
}

void
IceGrid::AdminPrx::_iceI_getAdapterInfo(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<AdapterInfoSeq>>& outAsync, ::std::string_view iceP_id, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "getAdapterInfo";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Nonmutating, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_id);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const AdapterNotExistException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}

void
IceGrid::AdminPrx::removeAdapter(::std::string_view iceP_id, const ::Ice::Context& context) const
{
    ::IceInternal::makePromiseOutgoing<void>(true, this, &AdminPrx::_iceI_removeAdapter, iceP_id, context).get();
}

::std::future<void>
IceGrid::AdminPrx::removeAdapterAsync(::std::string_view iceP_id, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<void>(false, this, &AdminPrx::_iceI_removeAdapter, iceP_id, context);
}

::std::function<void()>
IceGrid::AdminPrx::removeAdapterAsync(::std::string_view iceP_id, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminPrx::_iceI_removeAdapter, iceP_id, context);
}

void
IceGrid::AdminPrx::_iceI_removeAdapter(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, ::std::string_view iceP_id, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "removeAdapter";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_id);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const AdapterNotExistException&)
            {
                throw;
            }
            catch(const DeploymentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}

::Ice::StringSeq
IceGrid::AdminPrx::getAllAdapterIds(const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::Ice::StringSeq>(true, this, &AdminPrx::_iceI_getAllAdapterIds, context).get();
}

::std::future<::Ice::StringSeq>
IceGrid::AdminPrx::getAllAdapterIdsAsync(const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::Ice::StringSeq>(false, this, &AdminPrx::_iceI_getAllAdapterIds, context);
}

::std::function<void()>
IceGrid::AdminPrx::getAllAdapterIdsAsync(::std::function<void(::Ice::StringSeq)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<::Ice::StringSeq>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminPrx::_iceI_getAllAdapterIds, context);
}

void
IceGrid::AdminPrx::_iceI_getAllAdapterIds(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::Ice::StringSeq>>& outAsync, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "getAllAdapterIds";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Nonmutating, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}

void
IceGrid::AdminPrx::addObject(const ::std::optional<::Ice::ObjectPrx>& iceP_obj, const ::Ice::Context& context) const
{
    ::IceInternal::makePromiseOutgoing<void>(true, this, &AdminPrx::_iceI_addObject, iceP_obj, context).get();
}

::std::future<void>
IceGrid::AdminPrx::addObjectAsync(const ::std::optional<::Ice::ObjectPrx>& iceP_obj, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<void>(false, this, &AdminPrx::_iceI_addObject, iceP_obj, context);
}

::std::function<void()>
IceGrid::AdminPrx::addObjectAsync(const ::std::optional<::Ice::ObjectPrx>& iceP_obj, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminPrx::_iceI_addObject, iceP_obj, context);
}

void
IceGrid::AdminPrx::_iceI_addObject(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::optional<::Ice::ObjectPrx>& iceP_obj, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "addObject";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_obj);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const ObjectExistsException&)
            {
                throw;
            }
            catch(const DeploymentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}

void
IceGrid::AdminPrx::updateObject(const ::std::optional<::Ice::ObjectPrx>& iceP_obj, const ::Ice::Context& context) const
{
    ::IceInternal::makePromiseOutgoing<void>(true, this, &AdminPrx::_iceI_updateObject, iceP_obj, context).get();
}

::std::future<void>
IceGrid::AdminPrx::updateObjectAsync(const ::std::optional<::Ice::ObjectPrx>& iceP_obj, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<void>(false, this, &AdminPrx::_iceI_updateObject, iceP_obj, context);
}

::std::function<void()>
IceGrid::AdminPrx::updateObjectAsync(const ::std::optional<::Ice::ObjectPrx>& iceP_obj, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminPrx::_iceI_updateObject, iceP_obj, context);
}

void
IceGrid::AdminPrx::_iceI_updateObject(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::optional<::Ice::ObjectPrx>& iceP_obj, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "updateObject";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_obj);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const ObjectNotRegisteredException&)
            {
                throw;
            }
            catch(const DeploymentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}

void
IceGrid::AdminPrx::addObjectWithType(const ::std::optional<::Ice::ObjectPrx>& iceP_obj, ::std::string_view iceP_type, const ::Ice::Context& context) const
{
    ::IceInternal::makePromiseOutgoing<void>(true, this, &AdminPrx::_iceI_addObjectWithType, iceP_obj, iceP_type, context).get();
}

::std::future<void>
IceGrid::AdminPrx::addObjectWithTypeAsync(const ::std::optional<::Ice::ObjectPrx>& iceP_obj, ::std::string_view iceP_type, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<void>(false, this, &AdminPrx::_iceI_addObjectWithType, iceP_obj, iceP_type, context);
}

::std::function<void()>
IceGrid::AdminPrx::addObjectWithTypeAsync(const ::std::optional<::Ice::ObjectPrx>& iceP_obj, ::std::string_view iceP_type, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminPrx::_iceI_addObjectWithType, iceP_obj, iceP_type, context);
}

void
IceGrid::AdminPrx::_iceI_addObjectWithType(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::optional<::Ice::ObjectPrx>& iceP_obj, ::std::string_view iceP_type, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "addObjectWithType";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_obj, iceP_type);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const ObjectExistsException&)
            {
                throw;
            }
            catch(const DeploymentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}

void
IceGrid::AdminPrx::removeObject(const ::Ice::Identity& iceP_id, const ::Ice::Context& context) const
{
    ::IceInternal::makePromiseOutgoing<void>(true, this, &AdminPrx::_iceI_removeObject, iceP_id, context).get();
}

::std::future<void>
IceGrid::AdminPrx::removeObjectAsync(const ::Ice::Identity& iceP_id, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<void>(false, this, &AdminPrx::_iceI_removeObject, iceP_id, context);
}

::std::function<void()>
IceGrid::AdminPrx::removeObjectAsync(const ::Ice::Identity& iceP_id, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminPrx::_iceI_removeObject, iceP_id, context);
}

void
IceGrid::AdminPrx::_iceI_removeObject(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::Ice::Identity& iceP_id, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "removeObject";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_id);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const ObjectNotRegisteredException&)
            {
                throw;
            }
            catch(const DeploymentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}

::IceGrid::ObjectInfo
IceGrid::AdminPrx::getObjectInfo(const ::Ice::Identity& iceP_id, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<ObjectInfo>(true, this, &AdminPrx::_iceI_getObjectInfo, iceP_id, context).get();
}

::std::future<::IceGrid::ObjectInfo>
IceGrid::AdminPrx::getObjectInfoAsync(const ::Ice::Identity& iceP_id, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<ObjectInfo>(false, this, &AdminPrx::_iceI_getObjectInfo, iceP_id, context);
}

::std::function<void()>
IceGrid::AdminPrx::getObjectInfoAsync(const ::Ice::Identity& iceP_id, ::std::function<void(::IceGrid::ObjectInfo)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<ObjectInfo>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminPrx::_iceI_getObjectInfo, iceP_id, context);
}

void
IceGrid::AdminPrx::_iceI_getObjectInfo(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ObjectInfo>>& outAsync, const ::Ice::Identity& iceP_id, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "getObjectInfo";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Nonmutating, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_id);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const ObjectNotRegisteredException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}

::IceGrid::ObjectInfoSeq
IceGrid::AdminPrx::getObjectInfosByType(::std::string_view iceP_type, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<ObjectInfoSeq>(true, this, &AdminPrx::_iceI_getObjectInfosByType, iceP_type, context).get();
}

::std::future<::IceGrid::ObjectInfoSeq>
IceGrid::AdminPrx::getObjectInfosByTypeAsync(::std::string_view iceP_type, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<ObjectInfoSeq>(false, this, &AdminPrx::_iceI_getObjectInfosByType, iceP_type, context);
}

::std::function<void()>
IceGrid::AdminPrx::getObjectInfosByTypeAsync(::std::string_view iceP_type, ::std::function<void(::IceGrid::ObjectInfoSeq)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<ObjectInfoSeq>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminPrx::_iceI_getObjectInfosByType, iceP_type, context);
}

void
IceGrid::AdminPrx::_iceI_getObjectInfosByType(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ObjectInfoSeq>>& outAsync, ::std::string_view iceP_type, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "getObjectInfosByType";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Nonmutating, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_type);
        },
        nullptr);
}

::IceGrid::ObjectInfoSeq
IceGrid::AdminPrx::getAllObjectInfos(::std::string_view iceP_expr, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<ObjectInfoSeq>(true, this, &AdminPrx::_iceI_getAllObjectInfos, iceP_expr, context).get();
}

::std::future<::IceGrid::ObjectInfoSeq>
IceGrid::AdminPrx::getAllObjectInfosAsync(::std::string_view iceP_expr, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<ObjectInfoSeq>(false, this, &AdminPrx::_iceI_getAllObjectInfos, iceP_expr, context);
}

::std::function<void()>
IceGrid::AdminPrx::getAllObjectInfosAsync(::std::string_view iceP_expr, ::std::function<void(::IceGrid::ObjectInfoSeq)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<ObjectInfoSeq>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminPrx::_iceI_getAllObjectInfos, iceP_expr, context);
}

void
IceGrid::AdminPrx::_iceI_getAllObjectInfos(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ObjectInfoSeq>>& outAsync, ::std::string_view iceP_expr, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "getAllObjectInfos";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Nonmutating, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_expr);
        },
        nullptr);
}

bool
IceGrid::AdminPrx::pingNode(::std::string_view iceP_name, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<bool>(true, this, &AdminPrx::_iceI_pingNode, iceP_name, context).get();
}

::std::future<bool>
IceGrid::AdminPrx::pingNodeAsync(::std::string_view iceP_name, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<bool>(false, this, &AdminPrx::_iceI_pingNode, iceP_name, context);
}

::std::function<void()>
IceGrid::AdminPrx::pingNodeAsync(::std::string_view iceP_name, ::std::function<void(bool)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<bool>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminPrx::_iceI_pingNode, iceP_name, context);
}

void
IceGrid::AdminPrx::_iceI_pingNode(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>& outAsync, ::std::string_view iceP_name, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "pingNode";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Nonmutating, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_name);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const NodeNotExistException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}

::IceGrid::LoadInfo
IceGrid::AdminPrx::getNodeLoad(::std::string_view iceP_name, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<LoadInfo>(true, this, &AdminPrx::_iceI_getNodeLoad, iceP_name, context).get();
}

::std::future<::IceGrid::LoadInfo>
IceGrid::AdminPrx::getNodeLoadAsync(::std::string_view iceP_name, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<LoadInfo>(false, this, &AdminPrx::_iceI_getNodeLoad, iceP_name, context);
}

::std::function<void()>
IceGrid::AdminPrx::getNodeLoadAsync(::std::string_view iceP_name, ::std::function<void(::IceGrid::LoadInfo)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<LoadInfo>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminPrx::_iceI_getNodeLoad, iceP_name, context);
}

void
IceGrid::AdminPrx::_iceI_getNodeLoad(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<LoadInfo>>& outAsync, ::std::string_view iceP_name, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "getNodeLoad";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Nonmutating, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_name);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const NodeNotExistException&)
            {
                throw;
            }
            catch(const NodeUnreachableException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}

::IceGrid::NodeInfo
IceGrid::AdminPrx::getNodeInfo(::std::string_view iceP_name, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<NodeInfo>(true, this, &AdminPrx::_iceI_getNodeInfo, iceP_name, context).get();
}

::std::future<::IceGrid::NodeInfo>
IceGrid::AdminPrx::getNodeInfoAsync(::std::string_view iceP_name, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<NodeInfo>(false, this, &AdminPrx::_iceI_getNodeInfo, iceP_name, context);
}

::std::function<void()>
IceGrid::AdminPrx::getNodeInfoAsync(::std::string_view iceP_name, ::std::function<void(::IceGrid::NodeInfo)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<NodeInfo>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminPrx::_iceI_getNodeInfo, iceP_name, context);
}

void
IceGrid::AdminPrx::_iceI_getNodeInfo(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<NodeInfo>>& outAsync, ::std::string_view iceP_name, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "getNodeInfo";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Nonmutating, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_name);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const NodeNotExistException&)
            {
                throw;
            }
            catch(const NodeUnreachableException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}

::std::optional<::Ice::ObjectPrx>
IceGrid::AdminPrx::getNodeAdmin(::std::string_view iceP_name, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::optional<::Ice::ObjectPrx>>(true, this, &AdminPrx::_iceI_getNodeAdmin, iceP_name, context).get();
}

::std::future<::std::optional<::Ice::ObjectPrx>>
IceGrid::AdminPrx::getNodeAdminAsync(::std::string_view iceP_name, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::optional<::Ice::ObjectPrx>>(false, this, &AdminPrx::_iceI_getNodeAdmin, iceP_name, context);
}

::std::function<void()>
IceGrid::AdminPrx::getNodeAdminAsync(::std::string_view iceP_name, ::std::function<void(::std::optional<::Ice::ObjectPrx>)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<::std::optional<::Ice::ObjectPrx>>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminPrx::_iceI_getNodeAdmin, iceP_name, context);
}

void
IceGrid::AdminPrx::_iceI_getNodeAdmin(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::optional<::Ice::ObjectPrx>>>& outAsync, ::std::string_view iceP_name, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "getNodeAdmin";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_name);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const NodeNotExistException&)
            {
                throw;
            }
            catch(const NodeUnreachableException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}

::std::int32_t
IceGrid::AdminPrx::getNodeProcessorSocketCount(::std::string_view iceP_name, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::int32_t>(true, this, &AdminPrx::_iceI_getNodeProcessorSocketCount, iceP_name, context).get();
}

::std::future<::std::int32_t>
IceGrid::AdminPrx::getNodeProcessorSocketCountAsync(::std::string_view iceP_name, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::int32_t>(false, this, &AdminPrx::_iceI_getNodeProcessorSocketCount, iceP_name, context);
}

::std::function<void()>
IceGrid::AdminPrx::getNodeProcessorSocketCountAsync(::std::string_view iceP_name, ::std::function<void(::std::int32_t)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<::std::int32_t>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminPrx::_iceI_getNodeProcessorSocketCount, iceP_name, context);
}

void
IceGrid::AdminPrx::_iceI_getNodeProcessorSocketCount(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::int32_t>>& outAsync, ::std::string_view iceP_name, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "getNodeProcessorSocketCount";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Nonmutating, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_name);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const NodeNotExistException&)
            {
                throw;
            }
            catch(const NodeUnreachableException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}

void
IceGrid::AdminPrx::shutdownNode(::std::string_view iceP_name, const ::Ice::Context& context) const
{
    ::IceInternal::makePromiseOutgoing<void>(true, this, &AdminPrx::_iceI_shutdownNode, iceP_name, context).get();
}

::std::future<void>
IceGrid::AdminPrx::shutdownNodeAsync(::std::string_view iceP_name, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<void>(false, this, &AdminPrx::_iceI_shutdownNode, iceP_name, context);
}

::std::function<void()>
IceGrid::AdminPrx::shutdownNodeAsync(::std::string_view iceP_name, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminPrx::_iceI_shutdownNode, iceP_name, context);
}

void
IceGrid::AdminPrx::_iceI_shutdownNode(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, ::std::string_view iceP_name, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "shutdownNode";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_name);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const NodeNotExistException&)
            {
                throw;
            }
            catch(const NodeUnreachableException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}

::std::string
IceGrid::AdminPrx::getNodeHostname(::std::string_view iceP_name, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::string>(true, this, &AdminPrx::_iceI_getNodeHostname, iceP_name, context).get();
}

::std::future<::std::string>
IceGrid::AdminPrx::getNodeHostnameAsync(::std::string_view iceP_name, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::string>(false, this, &AdminPrx::_iceI_getNodeHostname, iceP_name, context);
}

::std::function<void()>
IceGrid::AdminPrx::getNodeHostnameAsync(::std::string_view iceP_name, ::std::function<void(::std::string)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<::std::string>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminPrx::_iceI_getNodeHostname, iceP_name, context);
}

void
IceGrid::AdminPrx::_iceI_getNodeHostname(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::string>>& outAsync, ::std::string_view iceP_name, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "getNodeHostname";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Nonmutating, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_name);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const NodeNotExistException&)
            {
                throw;
            }
            catch(const NodeUnreachableException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}

::Ice::StringSeq
IceGrid::AdminPrx::getAllNodeNames(const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::Ice::StringSeq>(true, this, &AdminPrx::_iceI_getAllNodeNames, context).get();
}

::std::future<::Ice::StringSeq>
IceGrid::AdminPrx::getAllNodeNamesAsync(const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::Ice::StringSeq>(false, this, &AdminPrx::_iceI_getAllNodeNames, context);
}

::std::function<void()>
IceGrid::AdminPrx::getAllNodeNamesAsync(::std::function<void(::Ice::StringSeq)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<::Ice::StringSeq>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminPrx::_iceI_getAllNodeNames, context);
}

void
IceGrid::AdminPrx::_iceI_getAllNodeNames(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::Ice::StringSeq>>& outAsync, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "getAllNodeNames";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Nonmutating, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}

bool
IceGrid::AdminPrx::pingRegistry(::std::string_view iceP_name, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<bool>(true, this, &AdminPrx::_iceI_pingRegistry, iceP_name, context).get();
}

::std::future<bool>
IceGrid::AdminPrx::pingRegistryAsync(::std::string_view iceP_name, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<bool>(false, this, &AdminPrx::_iceI_pingRegistry, iceP_name, context);
}

::std::function<void()>
IceGrid::AdminPrx::pingRegistryAsync(::std::string_view iceP_name, ::std::function<void(bool)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<bool>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminPrx::_iceI_pingRegistry, iceP_name, context);
}

void
IceGrid::AdminPrx::_iceI_pingRegistry(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>& outAsync, ::std::string_view iceP_name, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "pingRegistry";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_name);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const RegistryNotExistException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}

::IceGrid::RegistryInfo
IceGrid::AdminPrx::getRegistryInfo(::std::string_view iceP_name, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<RegistryInfo>(true, this, &AdminPrx::_iceI_getRegistryInfo, iceP_name, context).get();
}

::std::future<::IceGrid::RegistryInfo>
IceGrid::AdminPrx::getRegistryInfoAsync(::std::string_view iceP_name, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<RegistryInfo>(false, this, &AdminPrx::_iceI_getRegistryInfo, iceP_name, context);
}

::std::function<void()>
IceGrid::AdminPrx::getRegistryInfoAsync(::std::string_view iceP_name, ::std::function<void(::IceGrid::RegistryInfo)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<RegistryInfo>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminPrx::_iceI_getRegistryInfo, iceP_name, context);
}

void
IceGrid::AdminPrx::_iceI_getRegistryInfo(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<RegistryInfo>>& outAsync, ::std::string_view iceP_name, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "getRegistryInfo";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_name);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const RegistryUnreachableException&)
            {
                throw;
            }
            catch(const RegistryNotExistException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}

::std::optional<::Ice::ObjectPrx>
IceGrid::AdminPrx::getRegistryAdmin(::std::string_view iceP_name, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::optional<::Ice::ObjectPrx>>(true, this, &AdminPrx::_iceI_getRegistryAdmin, iceP_name, context).get();
}

::std::future<::std::optional<::Ice::ObjectPrx>>
IceGrid::AdminPrx::getRegistryAdminAsync(::std::string_view iceP_name, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::optional<::Ice::ObjectPrx>>(false, this, &AdminPrx::_iceI_getRegistryAdmin, iceP_name, context);
}

::std::function<void()>
IceGrid::AdminPrx::getRegistryAdminAsync(::std::string_view iceP_name, ::std::function<void(::std::optional<::Ice::ObjectPrx>)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<::std::optional<::Ice::ObjectPrx>>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminPrx::_iceI_getRegistryAdmin, iceP_name, context);
}

void
IceGrid::AdminPrx::_iceI_getRegistryAdmin(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::optional<::Ice::ObjectPrx>>>& outAsync, ::std::string_view iceP_name, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "getRegistryAdmin";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_name);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const RegistryNotExistException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}

void
IceGrid::AdminPrx::shutdownRegistry(::std::string_view iceP_name, const ::Ice::Context& context) const
{
    ::IceInternal::makePromiseOutgoing<void>(true, this, &AdminPrx::_iceI_shutdownRegistry, iceP_name, context).get();
}

::std::future<void>
IceGrid::AdminPrx::shutdownRegistryAsync(::std::string_view iceP_name, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<void>(false, this, &AdminPrx::_iceI_shutdownRegistry, iceP_name, context);
}

::std::function<void()>
IceGrid::AdminPrx::shutdownRegistryAsync(::std::string_view iceP_name, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminPrx::_iceI_shutdownRegistry, iceP_name, context);
}

void
IceGrid::AdminPrx::_iceI_shutdownRegistry(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, ::std::string_view iceP_name, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "shutdownRegistry";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_name);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const RegistryUnreachableException&)
            {
                throw;
            }
            catch(const RegistryNotExistException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}

::Ice::StringSeq
IceGrid::AdminPrx::getAllRegistryNames(const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::Ice::StringSeq>(true, this, &AdminPrx::_iceI_getAllRegistryNames, context).get();
}

::std::future<::Ice::StringSeq>
IceGrid::AdminPrx::getAllRegistryNamesAsync(const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::Ice::StringSeq>(false, this, &AdminPrx::_iceI_getAllRegistryNames, context);
}

::std::function<void()>
IceGrid::AdminPrx::getAllRegistryNamesAsync(::std::function<void(::Ice::StringSeq)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<::Ice::StringSeq>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminPrx::_iceI_getAllRegistryNames, context);
}

void
IceGrid::AdminPrx::_iceI_getAllRegistryNames(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::Ice::StringSeq>>& outAsync, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "getAllRegistryNames";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}

void
IceGrid::AdminPrx::shutdown(const ::Ice::Context& context) const
{
    ::IceInternal::makePromiseOutgoing<void>(true, this, &AdminPrx::_iceI_shutdown, context).get();
}

::std::future<void>
IceGrid::AdminPrx::shutdownAsync(const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<void>(false, this, &AdminPrx::_iceI_shutdown, context);
}

::std::function<void()>
IceGrid::AdminPrx::shutdownAsync(::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminPrx::_iceI_shutdown, context);
}

void
IceGrid::AdminPrx::_iceI_shutdown(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "shutdown";

    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}

::std::string_view
IceGrid::AdminPrx::ice_staticId()
{
    static constexpr ::std::string_view typeId = "::IceGrid::Admin";
    return typeId;
}

bool
IceGrid::FileIteratorPrx::read(::std::int32_t iceP_size, ::Ice::StringSeq& iceP_lines, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<bool, ::Ice::StringSeq>>(true, this, &FileIteratorPrx::_iceI_read, iceP_size, context).get();
    iceP_lines = ::std::move(::std::get<1>(result));
    return ::std::get<0>(result);
}

::std::future<::std::tuple<bool, ::Ice::StringSeq>>
IceGrid::FileIteratorPrx::readAsync(::std::int32_t iceP_size, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<bool, ::Ice::StringSeq>>(false, this, &FileIteratorPrx::_iceI_read, iceP_size, context);
}

::std::function<void()>
IceGrid::FileIteratorPrx::readAsync(::std::int32_t iceP_size, ::std::function<void(bool, ::Ice::StringSeq)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<bool, ::Ice::StringSeq>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<bool, ::Ice::StringSeq>>(std::move(responseCb), std::move(ex), std::move(sent), this, &IceGrid::FileIteratorPrx::_iceI_read, iceP_size, context);
}

void
IceGrid::FileIteratorPrx::_iceI_read(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<bool, ::Ice::StringSeq>>>& outAsync, ::std::int32_t iceP_size, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "read";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_size);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const FileNotAvailableException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        },
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<bool, ::Ice::StringSeq> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

void
IceGrid::FileIteratorPrx::destroy(const ::Ice::Context& context) const
{
    ::IceInternal::makePromiseOutgoing<void>(true, this, &FileIteratorPrx::_iceI_destroy, context).get();
}

::std::future<void>
IceGrid::FileIteratorPrx::destroyAsync(const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<void>(false, this, &FileIteratorPrx::_iceI_destroy, context);
}

::std::function<void()>
IceGrid::FileIteratorPrx::destroyAsync(::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::FileIteratorPrx::_iceI_destroy, context);
}

void
IceGrid::FileIteratorPrx::_iceI_destroy(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "destroy";

    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}

::std::string_view
IceGrid::FileIteratorPrx::ice_staticId()
{
    static constexpr ::std::string_view typeId = "::IceGrid::FileIterator";
    return typeId;
}

void
IceGrid::RegistryObserverPrx::registryInit(const RegistryInfoSeq& iceP_registries, const ::Ice::Context& context) const
{
    ::IceInternal::makePromiseOutgoing<void>(true, this, &RegistryObserverPrx::_iceI_registryInit, iceP_registries, context).get();
}

::std::future<void>
IceGrid::RegistryObserverPrx::registryInitAsync(const RegistryInfoSeq& iceP_registries, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<void>(false, this, &RegistryObserverPrx::_iceI_registryInit, iceP_registries, context);
}

::std::function<void()>
IceGrid::RegistryObserverPrx::registryInitAsync(const RegistryInfoSeq& iceP_registries, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::RegistryObserverPrx::_iceI_registryInit, iceP_registries, context);
}

void
IceGrid::RegistryObserverPrx::_iceI_registryInit(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const RegistryInfoSeq& iceP_registries, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "registryInit";

    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_registries);
        },
        nullptr);
}

void
IceGrid::RegistryObserverPrx::registryUp(const RegistryInfo& iceP_node, const ::Ice::Context& context) const
{
    ::IceInternal::makePromiseOutgoing<void>(true, this, &RegistryObserverPrx::_iceI_registryUp, iceP_node, context).get();
}

::std::future<void>
IceGrid::RegistryObserverPrx::registryUpAsync(const RegistryInfo& iceP_node, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<void>(false, this, &RegistryObserverPrx::_iceI_registryUp, iceP_node, context);
}

::std::function<void()>
IceGrid::RegistryObserverPrx::registryUpAsync(const RegistryInfo& iceP_node, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::RegistryObserverPrx::_iceI_registryUp, iceP_node, context);
}

void
IceGrid::RegistryObserverPrx::_iceI_registryUp(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const RegistryInfo& iceP_node, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "registryUp";

    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_node);
        },
        nullptr);
}

void
IceGrid::RegistryObserverPrx::registryDown(::std::string_view iceP_name, const ::Ice::Context& context) const
{
    ::IceInternal::makePromiseOutgoing<void>(true, this, &RegistryObserverPrx::_iceI_registryDown, iceP_name, context).get();
}

::std::future<void>
IceGrid::RegistryObserverPrx::registryDownAsync(::std::string_view iceP_name, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<void>(false, this, &RegistryObserverPrx::_iceI_registryDown, iceP_name, context);
}

::std::function<void()>
IceGrid::RegistryObserverPrx::registryDownAsync(::std::string_view iceP_name, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::RegistryObserverPrx::_iceI_registryDown, iceP_name, context);
}

void
IceGrid::RegistryObserverPrx::_iceI_registryDown(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, ::std::string_view iceP_name, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "registryDown";

    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_name);
        },
        nullptr);
}

::std::string_view
IceGrid::RegistryObserverPrx::ice_staticId()
{
    static constexpr ::std::string_view typeId = "::IceGrid::RegistryObserver";
    return typeId;
}

void
IceGrid::NodeObserverPrx::nodeInit(const NodeDynamicInfoSeq& iceP_nodes, const ::Ice::Context& context) const
{
    ::IceInternal::makePromiseOutgoing<void>(true, this, &NodeObserverPrx::_iceI_nodeInit, iceP_nodes, context).get();
}

::std::future<void>
IceGrid::NodeObserverPrx::nodeInitAsync(const NodeDynamicInfoSeq& iceP_nodes, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<void>(false, this, &NodeObserverPrx::_iceI_nodeInit, iceP_nodes, context);
}

::std::function<void()>
IceGrid::NodeObserverPrx::nodeInitAsync(const NodeDynamicInfoSeq& iceP_nodes, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::NodeObserverPrx::_iceI_nodeInit, iceP_nodes, context);
}

void
IceGrid::NodeObserverPrx::_iceI_nodeInit(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const NodeDynamicInfoSeq& iceP_nodes, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "nodeInit";

    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_nodes);
        },
        nullptr);
}

void
IceGrid::NodeObserverPrx::nodeUp(const NodeDynamicInfo& iceP_node, const ::Ice::Context& context) const
{
    ::IceInternal::makePromiseOutgoing<void>(true, this, &NodeObserverPrx::_iceI_nodeUp, iceP_node, context).get();
}

::std::future<void>
IceGrid::NodeObserverPrx::nodeUpAsync(const NodeDynamicInfo& iceP_node, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<void>(false, this, &NodeObserverPrx::_iceI_nodeUp, iceP_node, context);
}

::std::function<void()>
IceGrid::NodeObserverPrx::nodeUpAsync(const NodeDynamicInfo& iceP_node, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::NodeObserverPrx::_iceI_nodeUp, iceP_node, context);
}

void
IceGrid::NodeObserverPrx::_iceI_nodeUp(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const NodeDynamicInfo& iceP_node, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "nodeUp";

    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_node);
        },
        nullptr);
}

void
IceGrid::NodeObserverPrx::nodeDown(::std::string_view iceP_name, const ::Ice::Context& context) const
{
    ::IceInternal::makePromiseOutgoing<void>(true, this, &NodeObserverPrx::_iceI_nodeDown, iceP_name, context).get();
}

::std::future<void>
IceGrid::NodeObserverPrx::nodeDownAsync(::std::string_view iceP_name, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<void>(false, this, &NodeObserverPrx::_iceI_nodeDown, iceP_name, context);
}

::std::function<void()>
IceGrid::NodeObserverPrx::nodeDownAsync(::std::string_view iceP_name, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::NodeObserverPrx::_iceI_nodeDown, iceP_name, context);
}

void
IceGrid::NodeObserverPrx::_iceI_nodeDown(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, ::std::string_view iceP_name, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "nodeDown";

    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_name);
        },
        nullptr);
}

void
IceGrid::NodeObserverPrx::updateServer(::std::string_view iceP_node, const ServerDynamicInfo& iceP_updatedInfo, const ::Ice::Context& context) const
{
    ::IceInternal::makePromiseOutgoing<void>(true, this, &NodeObserverPrx::_iceI_updateServer, iceP_node, iceP_updatedInfo, context).get();
}

::std::future<void>
IceGrid::NodeObserverPrx::updateServerAsync(::std::string_view iceP_node, const ServerDynamicInfo& iceP_updatedInfo, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<void>(false, this, &NodeObserverPrx::_iceI_updateServer, iceP_node, iceP_updatedInfo, context);
}

::std::function<void()>
IceGrid::NodeObserverPrx::updateServerAsync(::std::string_view iceP_node, const ServerDynamicInfo& iceP_updatedInfo, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::NodeObserverPrx::_iceI_updateServer, iceP_node, iceP_updatedInfo, context);
}

void
IceGrid::NodeObserverPrx::_iceI_updateServer(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, ::std::string_view iceP_node, const ServerDynamicInfo& iceP_updatedInfo, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "updateServer";

    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_node, iceP_updatedInfo);
        },
        nullptr);
}

void
IceGrid::NodeObserverPrx::updateAdapter(::std::string_view iceP_node, const AdapterDynamicInfo& iceP_updatedInfo, const ::Ice::Context& context) const
{
    ::IceInternal::makePromiseOutgoing<void>(true, this, &NodeObserverPrx::_iceI_updateAdapter, iceP_node, iceP_updatedInfo, context).get();
}

::std::future<void>
IceGrid::NodeObserverPrx::updateAdapterAsync(::std::string_view iceP_node, const AdapterDynamicInfo& iceP_updatedInfo, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<void>(false, this, &NodeObserverPrx::_iceI_updateAdapter, iceP_node, iceP_updatedInfo, context);
}

::std::function<void()>
IceGrid::NodeObserverPrx::updateAdapterAsync(::std::string_view iceP_node, const AdapterDynamicInfo& iceP_updatedInfo, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::NodeObserverPrx::_iceI_updateAdapter, iceP_node, iceP_updatedInfo, context);
}

void
IceGrid::NodeObserverPrx::_iceI_updateAdapter(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, ::std::string_view iceP_node, const AdapterDynamicInfo& iceP_updatedInfo, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "updateAdapter";

    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_node, iceP_updatedInfo);
        },
        nullptr);
}

::std::string_view
IceGrid::NodeObserverPrx::ice_staticId()
{
    static constexpr ::std::string_view typeId = "::IceGrid::NodeObserver";
    return typeId;
}

void
IceGrid::ApplicationObserverPrx::applicationInit(::std::int32_t iceP_serial, const ApplicationInfoSeq& iceP_applications, const ::Ice::Context& context) const
{
    ::IceInternal::makePromiseOutgoing<void>(true, this, &ApplicationObserverPrx::_iceI_applicationInit, iceP_serial, iceP_applications, context).get();
}

::std::future<void>
IceGrid::ApplicationObserverPrx::applicationInitAsync(::std::int32_t iceP_serial, const ApplicationInfoSeq& iceP_applications, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<void>(false, this, &ApplicationObserverPrx::_iceI_applicationInit, iceP_serial, iceP_applications, context);
}

::std::function<void()>
IceGrid::ApplicationObserverPrx::applicationInitAsync(::std::int32_t iceP_serial, const ApplicationInfoSeq& iceP_applications, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::ApplicationObserverPrx::_iceI_applicationInit, iceP_serial, iceP_applications, context);
}

void
IceGrid::ApplicationObserverPrx::_iceI_applicationInit(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, ::std::int32_t iceP_serial, const ApplicationInfoSeq& iceP_applications, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "applicationInit";

    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_serial, iceP_applications);
            ostr->writePendingValues();
        },
        nullptr);
}

void
IceGrid::ApplicationObserverPrx::applicationAdded(::std::int32_t iceP_serial, const ApplicationInfo& iceP_desc, const ::Ice::Context& context) const
{
    ::IceInternal::makePromiseOutgoing<void>(true, this, &ApplicationObserverPrx::_iceI_applicationAdded, iceP_serial, iceP_desc, context).get();
}

::std::future<void>
IceGrid::ApplicationObserverPrx::applicationAddedAsync(::std::int32_t iceP_serial, const ApplicationInfo& iceP_desc, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<void>(false, this, &ApplicationObserverPrx::_iceI_applicationAdded, iceP_serial, iceP_desc, context);
}

::std::function<void()>
IceGrid::ApplicationObserverPrx::applicationAddedAsync(::std::int32_t iceP_serial, const ApplicationInfo& iceP_desc, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::ApplicationObserverPrx::_iceI_applicationAdded, iceP_serial, iceP_desc, context);
}

void
IceGrid::ApplicationObserverPrx::_iceI_applicationAdded(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, ::std::int32_t iceP_serial, const ApplicationInfo& iceP_desc, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "applicationAdded";

    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_serial, iceP_desc);
            ostr->writePendingValues();
        },
        nullptr);
}

void
IceGrid::ApplicationObserverPrx::applicationRemoved(::std::int32_t iceP_serial, ::std::string_view iceP_name, const ::Ice::Context& context) const
{
    ::IceInternal::makePromiseOutgoing<void>(true, this, &ApplicationObserverPrx::_iceI_applicationRemoved, iceP_serial, iceP_name, context).get();
}

::std::future<void>
IceGrid::ApplicationObserverPrx::applicationRemovedAsync(::std::int32_t iceP_serial, ::std::string_view iceP_name, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<void>(false, this, &ApplicationObserverPrx::_iceI_applicationRemoved, iceP_serial, iceP_name, context);
}

::std::function<void()>
IceGrid::ApplicationObserverPrx::applicationRemovedAsync(::std::int32_t iceP_serial, ::std::string_view iceP_name, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::ApplicationObserverPrx::_iceI_applicationRemoved, iceP_serial, iceP_name, context);
}

void
IceGrid::ApplicationObserverPrx::_iceI_applicationRemoved(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, ::std::int32_t iceP_serial, ::std::string_view iceP_name, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "applicationRemoved";

    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_serial, iceP_name);
        },
        nullptr);
}

void
IceGrid::ApplicationObserverPrx::applicationUpdated(::std::int32_t iceP_serial, const ApplicationUpdateInfo& iceP_desc, const ::Ice::Context& context) const
{
    ::IceInternal::makePromiseOutgoing<void>(true, this, &ApplicationObserverPrx::_iceI_applicationUpdated, iceP_serial, iceP_desc, context).get();
}

::std::future<void>
IceGrid::ApplicationObserverPrx::applicationUpdatedAsync(::std::int32_t iceP_serial, const ApplicationUpdateInfo& iceP_desc, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<void>(false, this, &ApplicationObserverPrx::_iceI_applicationUpdated, iceP_serial, iceP_desc, context);
}

::std::function<void()>
IceGrid::ApplicationObserverPrx::applicationUpdatedAsync(::std::int32_t iceP_serial, const ApplicationUpdateInfo& iceP_desc, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::ApplicationObserverPrx::_iceI_applicationUpdated, iceP_serial, iceP_desc, context);
}

void
IceGrid::ApplicationObserverPrx::_iceI_applicationUpdated(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, ::std::int32_t iceP_serial, const ApplicationUpdateInfo& iceP_desc, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "applicationUpdated";

    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_serial, iceP_desc);
            ostr->writePendingValues();
        },
        nullptr);
}

::std::string_view
IceGrid::ApplicationObserverPrx::ice_staticId()
{
    static constexpr ::std::string_view typeId = "::IceGrid::ApplicationObserver";
    return typeId;
}

void
IceGrid::AdapterObserverPrx::adapterInit(const AdapterInfoSeq& iceP_adpts, const ::Ice::Context& context) const
{
    ::IceInternal::makePromiseOutgoing<void>(true, this, &AdapterObserverPrx::_iceI_adapterInit, iceP_adpts, context).get();
}

::std::future<void>
IceGrid::AdapterObserverPrx::adapterInitAsync(const AdapterInfoSeq& iceP_adpts, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<void>(false, this, &AdapterObserverPrx::_iceI_adapterInit, iceP_adpts, context);
}

::std::function<void()>
IceGrid::AdapterObserverPrx::adapterInitAsync(const AdapterInfoSeq& iceP_adpts, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdapterObserverPrx::_iceI_adapterInit, iceP_adpts, context);
}

void
IceGrid::AdapterObserverPrx::_iceI_adapterInit(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const AdapterInfoSeq& iceP_adpts, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "adapterInit";

    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_adpts);
        },
        nullptr);
}

void
IceGrid::AdapterObserverPrx::adapterAdded(const AdapterInfo& iceP_info, const ::Ice::Context& context) const
{
    ::IceInternal::makePromiseOutgoing<void>(true, this, &AdapterObserverPrx::_iceI_adapterAdded, iceP_info, context).get();
}

::std::future<void>
IceGrid::AdapterObserverPrx::adapterAddedAsync(const AdapterInfo& iceP_info, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<void>(false, this, &AdapterObserverPrx::_iceI_adapterAdded, iceP_info, context);
}

::std::function<void()>
IceGrid::AdapterObserverPrx::adapterAddedAsync(const AdapterInfo& iceP_info, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdapterObserverPrx::_iceI_adapterAdded, iceP_info, context);
}

void
IceGrid::AdapterObserverPrx::_iceI_adapterAdded(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const AdapterInfo& iceP_info, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "adapterAdded";

    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_info);
        },
        nullptr);
}

void
IceGrid::AdapterObserverPrx::adapterUpdated(const AdapterInfo& iceP_info, const ::Ice::Context& context) const
{
    ::IceInternal::makePromiseOutgoing<void>(true, this, &AdapterObserverPrx::_iceI_adapterUpdated, iceP_info, context).get();
}

::std::future<void>
IceGrid::AdapterObserverPrx::adapterUpdatedAsync(const AdapterInfo& iceP_info, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<void>(false, this, &AdapterObserverPrx::_iceI_adapterUpdated, iceP_info, context);
}

::std::function<void()>
IceGrid::AdapterObserverPrx::adapterUpdatedAsync(const AdapterInfo& iceP_info, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdapterObserverPrx::_iceI_adapterUpdated, iceP_info, context);
}

void
IceGrid::AdapterObserverPrx::_iceI_adapterUpdated(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const AdapterInfo& iceP_info, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "adapterUpdated";

    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_info);
        },
        nullptr);
}

void
IceGrid::AdapterObserverPrx::adapterRemoved(::std::string_view iceP_id, const ::Ice::Context& context) const
{
    ::IceInternal::makePromiseOutgoing<void>(true, this, &AdapterObserverPrx::_iceI_adapterRemoved, iceP_id, context).get();
}

::std::future<void>
IceGrid::AdapterObserverPrx::adapterRemovedAsync(::std::string_view iceP_id, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<void>(false, this, &AdapterObserverPrx::_iceI_adapterRemoved, iceP_id, context);
}

::std::function<void()>
IceGrid::AdapterObserverPrx::adapterRemovedAsync(::std::string_view iceP_id, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdapterObserverPrx::_iceI_adapterRemoved, iceP_id, context);
}

void
IceGrid::AdapterObserverPrx::_iceI_adapterRemoved(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, ::std::string_view iceP_id, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "adapterRemoved";

    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_id);
        },
        nullptr);
}

::std::string_view
IceGrid::AdapterObserverPrx::ice_staticId()
{
    static constexpr ::std::string_view typeId = "::IceGrid::AdapterObserver";
    return typeId;
}

void
IceGrid::ObjectObserverPrx::objectInit(const ObjectInfoSeq& iceP_objects, const ::Ice::Context& context) const
{
    ::IceInternal::makePromiseOutgoing<void>(true, this, &ObjectObserverPrx::_iceI_objectInit, iceP_objects, context).get();
}

::std::future<void>
IceGrid::ObjectObserverPrx::objectInitAsync(const ObjectInfoSeq& iceP_objects, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<void>(false, this, &ObjectObserverPrx::_iceI_objectInit, iceP_objects, context);
}

::std::function<void()>
IceGrid::ObjectObserverPrx::objectInitAsync(const ObjectInfoSeq& iceP_objects, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::ObjectObserverPrx::_iceI_objectInit, iceP_objects, context);
}

void
IceGrid::ObjectObserverPrx::_iceI_objectInit(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ObjectInfoSeq& iceP_objects, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "objectInit";

    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_objects);
        },
        nullptr);
}

void
IceGrid::ObjectObserverPrx::objectAdded(const ObjectInfo& iceP_info, const ::Ice::Context& context) const
{
    ::IceInternal::makePromiseOutgoing<void>(true, this, &ObjectObserverPrx::_iceI_objectAdded, iceP_info, context).get();
}

::std::future<void>
IceGrid::ObjectObserverPrx::objectAddedAsync(const ObjectInfo& iceP_info, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<void>(false, this, &ObjectObserverPrx::_iceI_objectAdded, iceP_info, context);
}

::std::function<void()>
IceGrid::ObjectObserverPrx::objectAddedAsync(const ObjectInfo& iceP_info, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::ObjectObserverPrx::_iceI_objectAdded, iceP_info, context);
}

void
IceGrid::ObjectObserverPrx::_iceI_objectAdded(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ObjectInfo& iceP_info, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "objectAdded";

    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_info);
        },
        nullptr);
}

void
IceGrid::ObjectObserverPrx::objectUpdated(const ObjectInfo& iceP_info, const ::Ice::Context& context) const
{
    ::IceInternal::makePromiseOutgoing<void>(true, this, &ObjectObserverPrx::_iceI_objectUpdated, iceP_info, context).get();
}

::std::future<void>
IceGrid::ObjectObserverPrx::objectUpdatedAsync(const ObjectInfo& iceP_info, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<void>(false, this, &ObjectObserverPrx::_iceI_objectUpdated, iceP_info, context);
}

::std::function<void()>
IceGrid::ObjectObserverPrx::objectUpdatedAsync(const ObjectInfo& iceP_info, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::ObjectObserverPrx::_iceI_objectUpdated, iceP_info, context);
}

void
IceGrid::ObjectObserverPrx::_iceI_objectUpdated(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ObjectInfo& iceP_info, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "objectUpdated";

    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_info);
        },
        nullptr);
}

void
IceGrid::ObjectObserverPrx::objectRemoved(const ::Ice::Identity& iceP_id, const ::Ice::Context& context) const
{
    ::IceInternal::makePromiseOutgoing<void>(true, this, &ObjectObserverPrx::_iceI_objectRemoved, iceP_id, context).get();
}

::std::future<void>
IceGrid::ObjectObserverPrx::objectRemovedAsync(const ::Ice::Identity& iceP_id, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<void>(false, this, &ObjectObserverPrx::_iceI_objectRemoved, iceP_id, context);
}

::std::function<void()>
IceGrid::ObjectObserverPrx::objectRemovedAsync(const ::Ice::Identity& iceP_id, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::ObjectObserverPrx::_iceI_objectRemoved, iceP_id, context);
}

void
IceGrid::ObjectObserverPrx::_iceI_objectRemoved(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::Ice::Identity& iceP_id, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "objectRemoved";

    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_id);
        },
        nullptr);
}

::std::string_view
IceGrid::ObjectObserverPrx::ice_staticId()
{
    static constexpr ::std::string_view typeId = "::IceGrid::ObjectObserver";
    return typeId;
}

void
IceGrid::AdminSessionPrx::keepAlive(const ::Ice::Context& context) const
{
    ::IceInternal::makePromiseOutgoing<void>(true, this, &AdminSessionPrx::_iceI_keepAlive, context).get();
}

::std::future<void>
IceGrid::AdminSessionPrx::keepAliveAsync(const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<void>(false, this, &AdminSessionPrx::_iceI_keepAlive, context);
}

::std::function<void()>
IceGrid::AdminSessionPrx::keepAliveAsync(::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminSessionPrx::_iceI_keepAlive, context);
}

void
IceGrid::AdminSessionPrx::_iceI_keepAlive(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "keepAlive";

    outAsync->invoke(operationName, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}

::std::optional<::IceGrid::AdminPrx>
IceGrid::AdminSessionPrx::getAdmin(const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::optional<AdminPrx>>(true, this, &AdminSessionPrx::_iceI_getAdmin, context).get();
}

::std::future<::std::optional<::IceGrid::AdminPrx>>
IceGrid::AdminSessionPrx::getAdminAsync(const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::optional<AdminPrx>>(false, this, &AdminSessionPrx::_iceI_getAdmin, context);
}

::std::function<void()>
IceGrid::AdminSessionPrx::getAdminAsync(::std::function<void(::std::optional<::IceGrid::AdminPrx>)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<::std::optional<AdminPrx>>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminSessionPrx::_iceI_getAdmin, context);
}

void
IceGrid::AdminSessionPrx::_iceI_getAdmin(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::optional<AdminPrx>>>& outAsync, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "getAdmin";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Nonmutating, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}

::std::optional<::Ice::ObjectPrx>
IceGrid::AdminSessionPrx::getAdminCallbackTemplate(const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::optional<::Ice::ObjectPrx>>(true, this, &AdminSessionPrx::_iceI_getAdminCallbackTemplate, context).get();
}

::std::future<::std::optional<::Ice::ObjectPrx>>
IceGrid::AdminSessionPrx::getAdminCallbackTemplateAsync(const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::optional<::Ice::ObjectPrx>>(false, this, &AdminSessionPrx::_iceI_getAdminCallbackTemplate, context);
}

::std::function<void()>
IceGrid::AdminSessionPrx::getAdminCallbackTemplateAsync(::std::function<void(::std::optional<::Ice::ObjectPrx>)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<::std::optional<::Ice::ObjectPrx>>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminSessionPrx::_iceI_getAdminCallbackTemplate, context);
}

void
IceGrid::AdminSessionPrx::_iceI_getAdminCallbackTemplate(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::optional<::Ice::ObjectPrx>>>& outAsync, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "getAdminCallbackTemplate";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}

void
IceGrid::AdminSessionPrx::setObservers(const ::std::optional<RegistryObserverPrx>& iceP_registryObs, const ::std::optional<NodeObserverPrx>& iceP_nodeObs, const ::std::optional<ApplicationObserverPrx>& iceP_appObs, const ::std::optional<AdapterObserverPrx>& iceP_adptObs, const ::std::optional<ObjectObserverPrx>& iceP_objObs, const ::Ice::Context& context) const
{
    ::IceInternal::makePromiseOutgoing<void>(true, this, &AdminSessionPrx::_iceI_setObservers, iceP_registryObs, iceP_nodeObs, iceP_appObs, iceP_adptObs, iceP_objObs, context).get();
}

::std::future<void>
IceGrid::AdminSessionPrx::setObserversAsync(const ::std::optional<RegistryObserverPrx>& iceP_registryObs, const ::std::optional<NodeObserverPrx>& iceP_nodeObs, const ::std::optional<ApplicationObserverPrx>& iceP_appObs, const ::std::optional<AdapterObserverPrx>& iceP_adptObs, const ::std::optional<ObjectObserverPrx>& iceP_objObs, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<void>(false, this, &AdminSessionPrx::_iceI_setObservers, iceP_registryObs, iceP_nodeObs, iceP_appObs, iceP_adptObs, iceP_objObs, context);
}

::std::function<void()>
IceGrid::AdminSessionPrx::setObserversAsync(const ::std::optional<RegistryObserverPrx>& iceP_registryObs, const ::std::optional<NodeObserverPrx>& iceP_nodeObs, const ::std::optional<ApplicationObserverPrx>& iceP_appObs, const ::std::optional<AdapterObserverPrx>& iceP_adptObs, const ::std::optional<ObjectObserverPrx>& iceP_objObs, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminSessionPrx::_iceI_setObservers, iceP_registryObs, iceP_nodeObs, iceP_appObs, iceP_adptObs, iceP_objObs, context);
}

void
IceGrid::AdminSessionPrx::_iceI_setObservers(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::optional<RegistryObserverPrx>& iceP_registryObs, const ::std::optional<NodeObserverPrx>& iceP_nodeObs, const ::std::optional<ApplicationObserverPrx>& iceP_appObs, const ::std::optional<AdapterObserverPrx>& iceP_adptObs, const ::std::optional<ObjectObserverPrx>& iceP_objObs, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "setObservers";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_registryObs, iceP_nodeObs, iceP_appObs, iceP_adptObs, iceP_objObs);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const ObserverAlreadyRegisteredException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}

void
IceGrid::AdminSessionPrx::setObserversByIdentity(const ::Ice::Identity& iceP_registryObs, const ::Ice::Identity& iceP_nodeObs, const ::Ice::Identity& iceP_appObs, const ::Ice::Identity& iceP_adptObs, const ::Ice::Identity& iceP_objObs, const ::Ice::Context& context) const
{
    ::IceInternal::makePromiseOutgoing<void>(true, this, &AdminSessionPrx::_iceI_setObserversByIdentity, iceP_registryObs, iceP_nodeObs, iceP_appObs, iceP_adptObs, iceP_objObs, context).get();
}

::std::future<void>
IceGrid::AdminSessionPrx::setObserversByIdentityAsync(const ::Ice::Identity& iceP_registryObs, const ::Ice::Identity& iceP_nodeObs, const ::Ice::Identity& iceP_appObs, const ::Ice::Identity& iceP_adptObs, const ::Ice::Identity& iceP_objObs, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<void>(false, this, &AdminSessionPrx::_iceI_setObserversByIdentity, iceP_registryObs, iceP_nodeObs, iceP_appObs, iceP_adptObs, iceP_objObs, context);
}

::std::function<void()>
IceGrid::AdminSessionPrx::setObserversByIdentityAsync(const ::Ice::Identity& iceP_registryObs, const ::Ice::Identity& iceP_nodeObs, const ::Ice::Identity& iceP_appObs, const ::Ice::Identity& iceP_adptObs, const ::Ice::Identity& iceP_objObs, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminSessionPrx::_iceI_setObserversByIdentity, iceP_registryObs, iceP_nodeObs, iceP_appObs, iceP_adptObs, iceP_objObs, context);
}

void
IceGrid::AdminSessionPrx::_iceI_setObserversByIdentity(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::Ice::Identity& iceP_registryObs, const ::Ice::Identity& iceP_nodeObs, const ::Ice::Identity& iceP_appObs, const ::Ice::Identity& iceP_adptObs, const ::Ice::Identity& iceP_objObs, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "setObserversByIdentity";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_registryObs, iceP_nodeObs, iceP_appObs, iceP_adptObs, iceP_objObs);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const ObserverAlreadyRegisteredException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}

::std::int32_t
IceGrid::AdminSessionPrx::startUpdate(const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::int32_t>(true, this, &AdminSessionPrx::_iceI_startUpdate, context).get();
}

::std::future<::std::int32_t>
IceGrid::AdminSessionPrx::startUpdateAsync(const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::int32_t>(false, this, &AdminSessionPrx::_iceI_startUpdate, context);
}

::std::function<void()>
IceGrid::AdminSessionPrx::startUpdateAsync(::std::function<void(::std::int32_t)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<::std::int32_t>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminSessionPrx::_iceI_startUpdate, context);
}

void
IceGrid::AdminSessionPrx::_iceI_startUpdate(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::int32_t>>& outAsync, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "startUpdate";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const AccessDeniedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}

void
IceGrid::AdminSessionPrx::finishUpdate(const ::Ice::Context& context) const
{
    ::IceInternal::makePromiseOutgoing<void>(true, this, &AdminSessionPrx::_iceI_finishUpdate, context).get();
}

::std::future<void>
IceGrid::AdminSessionPrx::finishUpdateAsync(const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<void>(false, this, &AdminSessionPrx::_iceI_finishUpdate, context);
}

::std::function<void()>
IceGrid::AdminSessionPrx::finishUpdateAsync(::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminSessionPrx::_iceI_finishUpdate, context);
}

void
IceGrid::AdminSessionPrx::_iceI_finishUpdate(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "finishUpdate";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const AccessDeniedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}

::std::string
IceGrid::AdminSessionPrx::getReplicaName(const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::string>(true, this, &AdminSessionPrx::_iceI_getReplicaName, context).get();
}

::std::future<::std::string>
IceGrid::AdminSessionPrx::getReplicaNameAsync(const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::string>(false, this, &AdminSessionPrx::_iceI_getReplicaName, context);
}

::std::function<void()>
IceGrid::AdminSessionPrx::getReplicaNameAsync(::std::function<void(::std::string)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<::std::string>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminSessionPrx::_iceI_getReplicaName, context);
}

void
IceGrid::AdminSessionPrx::_iceI_getReplicaName(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::string>>& outAsync, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "getReplicaName";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}

::std::optional<::IceGrid::FileIteratorPrx>
IceGrid::AdminSessionPrx::openServerLog(::std::string_view iceP_id, ::std::string_view iceP_path, ::std::int32_t iceP_count, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::optional<FileIteratorPrx>>(true, this, &AdminSessionPrx::_iceI_openServerLog, iceP_id, iceP_path, iceP_count, context).get();
}

::std::future<::std::optional<::IceGrid::FileIteratorPrx>>
IceGrid::AdminSessionPrx::openServerLogAsync(::std::string_view iceP_id, ::std::string_view iceP_path, ::std::int32_t iceP_count, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::optional<FileIteratorPrx>>(false, this, &AdminSessionPrx::_iceI_openServerLog, iceP_id, iceP_path, iceP_count, context);
}

::std::function<void()>
IceGrid::AdminSessionPrx::openServerLogAsync(::std::string_view iceP_id, ::std::string_view iceP_path, ::std::int32_t iceP_count, ::std::function<void(::std::optional<::IceGrid::FileIteratorPrx>)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<::std::optional<FileIteratorPrx>>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminSessionPrx::_iceI_openServerLog, iceP_id, iceP_path, iceP_count, context);
}

void
IceGrid::AdminSessionPrx::_iceI_openServerLog(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::optional<FileIteratorPrx>>>& outAsync, ::std::string_view iceP_id, ::std::string_view iceP_path, ::std::int32_t iceP_count, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "openServerLog";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_id, iceP_path, iceP_count);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const ServerNotExistException&)
            {
                throw;
            }
            catch(const DeploymentException&)
            {
                throw;
            }
            catch(const NodeUnreachableException&)
            {
                throw;
            }
            catch(const FileNotAvailableException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}

::std::optional<::IceGrid::FileIteratorPrx>
IceGrid::AdminSessionPrx::openServerStdErr(::std::string_view iceP_id, ::std::int32_t iceP_count, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::optional<FileIteratorPrx>>(true, this, &AdminSessionPrx::_iceI_openServerStdErr, iceP_id, iceP_count, context).get();
}

::std::future<::std::optional<::IceGrid::FileIteratorPrx>>
IceGrid::AdminSessionPrx::openServerStdErrAsync(::std::string_view iceP_id, ::std::int32_t iceP_count, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::optional<FileIteratorPrx>>(false, this, &AdminSessionPrx::_iceI_openServerStdErr, iceP_id, iceP_count, context);
}

::std::function<void()>
IceGrid::AdminSessionPrx::openServerStdErrAsync(::std::string_view iceP_id, ::std::int32_t iceP_count, ::std::function<void(::std::optional<::IceGrid::FileIteratorPrx>)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<::std::optional<FileIteratorPrx>>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminSessionPrx::_iceI_openServerStdErr, iceP_id, iceP_count, context);
}

void
IceGrid::AdminSessionPrx::_iceI_openServerStdErr(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::optional<FileIteratorPrx>>>& outAsync, ::std::string_view iceP_id, ::std::int32_t iceP_count, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "openServerStdErr";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_id, iceP_count);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const ServerNotExistException&)
            {
                throw;
            }
            catch(const DeploymentException&)
            {
                throw;
            }
            catch(const NodeUnreachableException&)
            {
                throw;
            }
            catch(const FileNotAvailableException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}

::std::optional<::IceGrid::FileIteratorPrx>
IceGrid::AdminSessionPrx::openServerStdOut(::std::string_view iceP_id, ::std::int32_t iceP_count, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::optional<FileIteratorPrx>>(true, this, &AdminSessionPrx::_iceI_openServerStdOut, iceP_id, iceP_count, context).get();
}

::std::future<::std::optional<::IceGrid::FileIteratorPrx>>
IceGrid::AdminSessionPrx::openServerStdOutAsync(::std::string_view iceP_id, ::std::int32_t iceP_count, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::optional<FileIteratorPrx>>(false, this, &AdminSessionPrx::_iceI_openServerStdOut, iceP_id, iceP_count, context);
}

::std::function<void()>
IceGrid::AdminSessionPrx::openServerStdOutAsync(::std::string_view iceP_id, ::std::int32_t iceP_count, ::std::function<void(::std::optional<::IceGrid::FileIteratorPrx>)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<::std::optional<FileIteratorPrx>>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminSessionPrx::_iceI_openServerStdOut, iceP_id, iceP_count, context);
}

void
IceGrid::AdminSessionPrx::_iceI_openServerStdOut(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::optional<FileIteratorPrx>>>& outAsync, ::std::string_view iceP_id, ::std::int32_t iceP_count, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "openServerStdOut";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_id, iceP_count);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const ServerNotExistException&)
            {
                throw;
            }
            catch(const DeploymentException&)
            {
                throw;
            }
            catch(const NodeUnreachableException&)
            {
                throw;
            }
            catch(const FileNotAvailableException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}

::std::optional<::IceGrid::FileIteratorPrx>
IceGrid::AdminSessionPrx::openNodeStdErr(::std::string_view iceP_name, ::std::int32_t iceP_count, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::optional<FileIteratorPrx>>(true, this, &AdminSessionPrx::_iceI_openNodeStdErr, iceP_name, iceP_count, context).get();
}

::std::future<::std::optional<::IceGrid::FileIteratorPrx>>
IceGrid::AdminSessionPrx::openNodeStdErrAsync(::std::string_view iceP_name, ::std::int32_t iceP_count, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::optional<FileIteratorPrx>>(false, this, &AdminSessionPrx::_iceI_openNodeStdErr, iceP_name, iceP_count, context);
}

::std::function<void()>
IceGrid::AdminSessionPrx::openNodeStdErrAsync(::std::string_view iceP_name, ::std::int32_t iceP_count, ::std::function<void(::std::optional<::IceGrid::FileIteratorPrx>)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<::std::optional<FileIteratorPrx>>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminSessionPrx::_iceI_openNodeStdErr, iceP_name, iceP_count, context);
}

void
IceGrid::AdminSessionPrx::_iceI_openNodeStdErr(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::optional<FileIteratorPrx>>>& outAsync, ::std::string_view iceP_name, ::std::int32_t iceP_count, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "openNodeStdErr";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_name, iceP_count);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const NodeNotExistException&)
            {
                throw;
            }
            catch(const NodeUnreachableException&)
            {
                throw;
            }
            catch(const FileNotAvailableException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}

::std::optional<::IceGrid::FileIteratorPrx>
IceGrid::AdminSessionPrx::openNodeStdOut(::std::string_view iceP_name, ::std::int32_t iceP_count, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::optional<FileIteratorPrx>>(true, this, &AdminSessionPrx::_iceI_openNodeStdOut, iceP_name, iceP_count, context).get();
}

::std::future<::std::optional<::IceGrid::FileIteratorPrx>>
IceGrid::AdminSessionPrx::openNodeStdOutAsync(::std::string_view iceP_name, ::std::int32_t iceP_count, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::optional<FileIteratorPrx>>(false, this, &AdminSessionPrx::_iceI_openNodeStdOut, iceP_name, iceP_count, context);
}

::std::function<void()>
IceGrid::AdminSessionPrx::openNodeStdOutAsync(::std::string_view iceP_name, ::std::int32_t iceP_count, ::std::function<void(::std::optional<::IceGrid::FileIteratorPrx>)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<::std::optional<FileIteratorPrx>>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminSessionPrx::_iceI_openNodeStdOut, iceP_name, iceP_count, context);
}

void
IceGrid::AdminSessionPrx::_iceI_openNodeStdOut(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::optional<FileIteratorPrx>>>& outAsync, ::std::string_view iceP_name, ::std::int32_t iceP_count, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "openNodeStdOut";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_name, iceP_count);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const NodeNotExistException&)
            {
                throw;
            }
            catch(const NodeUnreachableException&)
            {
                throw;
            }
            catch(const FileNotAvailableException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}

::std::optional<::IceGrid::FileIteratorPrx>
IceGrid::AdminSessionPrx::openRegistryStdErr(::std::string_view iceP_name, ::std::int32_t iceP_count, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::optional<FileIteratorPrx>>(true, this, &AdminSessionPrx::_iceI_openRegistryStdErr, iceP_name, iceP_count, context).get();
}

::std::future<::std::optional<::IceGrid::FileIteratorPrx>>
IceGrid::AdminSessionPrx::openRegistryStdErrAsync(::std::string_view iceP_name, ::std::int32_t iceP_count, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::optional<FileIteratorPrx>>(false, this, &AdminSessionPrx::_iceI_openRegistryStdErr, iceP_name, iceP_count, context);
}

::std::function<void()>
IceGrid::AdminSessionPrx::openRegistryStdErrAsync(::std::string_view iceP_name, ::std::int32_t iceP_count, ::std::function<void(::std::optional<::IceGrid::FileIteratorPrx>)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<::std::optional<FileIteratorPrx>>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminSessionPrx::_iceI_openRegistryStdErr, iceP_name, iceP_count, context);
}

void
IceGrid::AdminSessionPrx::_iceI_openRegistryStdErr(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::optional<FileIteratorPrx>>>& outAsync, ::std::string_view iceP_name, ::std::int32_t iceP_count, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "openRegistryStdErr";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_name, iceP_count);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const RegistryUnreachableException&)
            {
                throw;
            }
            catch(const RegistryNotExistException&)
            {
                throw;
            }
            catch(const FileNotAvailableException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}

::std::optional<::IceGrid::FileIteratorPrx>
IceGrid::AdminSessionPrx::openRegistryStdOut(::std::string_view iceP_name, ::std::int32_t iceP_count, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::optional<FileIteratorPrx>>(true, this, &AdminSessionPrx::_iceI_openRegistryStdOut, iceP_name, iceP_count, context).get();
}

::std::future<::std::optional<::IceGrid::FileIteratorPrx>>
IceGrid::AdminSessionPrx::openRegistryStdOutAsync(::std::string_view iceP_name, ::std::int32_t iceP_count, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::optional<FileIteratorPrx>>(false, this, &AdminSessionPrx::_iceI_openRegistryStdOut, iceP_name, iceP_count, context);
}

::std::function<void()>
IceGrid::AdminSessionPrx::openRegistryStdOutAsync(::std::string_view iceP_name, ::std::int32_t iceP_count, ::std::function<void(::std::optional<::IceGrid::FileIteratorPrx>)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<::std::optional<FileIteratorPrx>>(std::move(response), std::move(ex), std::move(sent), this, &IceGrid::AdminSessionPrx::_iceI_openRegistryStdOut, iceP_name, iceP_count, context);
}

void
IceGrid::AdminSessionPrx::_iceI_openRegistryStdOut(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::optional<FileIteratorPrx>>>& outAsync, ::std::string_view iceP_name, ::std::int32_t iceP_count, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "openRegistryStdOut";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_name, iceP_count);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const RegistryUnreachableException&)
            {
                throw;
            }
            catch(const RegistryNotExistException&)
            {
                throw;
            }
            catch(const FileNotAvailableException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}

::std::string_view
IceGrid::AdminSessionPrx::ice_staticId()
{
    static constexpr ::std::string_view typeId = "::IceGrid::AdminSession";
    return typeId;
}

::std::vector<::std::string>
IceGrid::Admin::ice_ids(const ::Ice::Current&) const
{
    static const ::std::vector<::std::string> allTypeIds = { "::Ice::Object", "::IceGrid::Admin" };
    return allTypeIds;
}

::std::string
IceGrid::Admin::ice_id(const ::Ice::Current&) const
{
    return ::std::string{ice_staticId()};
}

::std::string_view
IceGrid::Admin::ice_staticId()
{
    static constexpr ::std::string_view typeId = "::IceGrid::Admin";
    return typeId;
}

/// \cond INTERNAL
bool
IceGrid::Admin::_iceD_addApplication(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ApplicationDescriptor iceP_descriptor;
    istr->readAll(iceP_descriptor);
    istr->readPendingValues();
    inS.endReadParams();
    this->addApplication(::std::move(iceP_descriptor), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::Admin::_iceD_syncApplication(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ApplicationDescriptor iceP_descriptor;
    istr->readAll(iceP_descriptor);
    istr->readPendingValues();
    inS.endReadParams();
    this->syncApplication(::std::move(iceP_descriptor), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::Admin::_iceD_updateApplication(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ApplicationUpdateDescriptor iceP_descriptor;
    istr->readAll(iceP_descriptor);
    istr->readPendingValues();
    inS.endReadParams();
    this->updateApplication(::std::move(iceP_descriptor), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::Admin::_iceD_syncApplicationWithoutRestart(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ApplicationDescriptor iceP_descriptor;
    istr->readAll(iceP_descriptor);
    istr->readPendingValues();
    inS.endReadParams();
    this->syncApplicationWithoutRestart(::std::move(iceP_descriptor), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::Admin::_iceD_updateApplicationWithoutRestart(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ApplicationUpdateDescriptor iceP_descriptor;
    istr->readAll(iceP_descriptor);
    istr->readPendingValues();
    inS.endReadParams();
    this->updateApplicationWithoutRestart(::std::move(iceP_descriptor), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::Admin::_iceD_removeApplication(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_name;
    istr->readAll(iceP_name);
    inS.endReadParams();
    this->removeApplication(::std::move(iceP_name), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::Admin::_iceD_instantiateServer(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_application;
    ::std::string iceP_node;
    ServerInstanceDescriptor iceP_desc;
    istr->readAll(iceP_application, iceP_node, iceP_desc);
    inS.endReadParams();
    this->instantiateServer(::std::move(iceP_application), ::std::move(iceP_node), ::std::move(iceP_desc), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::Admin::_iceD_patchApplication(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_name;
    bool iceP_shutdown;
    istr->readAll(iceP_name, iceP_shutdown);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    this->patchApplicationAsync(::std::move(iceP_name), iceP_shutdown, inA->response(), inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::Admin::_iceD_getApplicationInfo(::IceInternal::Incoming& inS, const ::Ice::Current& current) const
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_name;
    istr->readAll(iceP_name);
    inS.endReadParams();
    ApplicationInfo ret = this->getApplicationInfo(::std::move(iceP_name), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::Admin::_iceD_getDefaultApplicationDescriptor(::IceInternal::Incoming& inS, const ::Ice::Current& current) const
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    inS.readEmptyParams();
    ApplicationDescriptor ret = this->getDefaultApplicationDescriptor(current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::Admin::_iceD_getAllApplicationNames(::IceInternal::Incoming& inS, const ::Ice::Current& current) const
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    inS.readEmptyParams();
    ::Ice::StringSeq ret = this->getAllApplicationNames(current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::Admin::_iceD_getServerInfo(::IceInternal::Incoming& inS, const ::Ice::Current& current) const
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_id;
    istr->readAll(iceP_id);
    inS.endReadParams();
    ServerInfo ret = this->getServerInfo(::std::move(iceP_id), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::Admin::_iceD_getServerState(::IceInternal::Incoming& inS, const ::Ice::Current& current) const
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_id;
    istr->readAll(iceP_id);
    inS.endReadParams();
    ServerState ret = this->getServerState(::std::move(iceP_id), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::Admin::_iceD_getServerPid(::IceInternal::Incoming& inS, const ::Ice::Current& current) const
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_id;
    istr->readAll(iceP_id);
    inS.endReadParams();
    ::std::int32_t ret = this->getServerPid(::std::move(iceP_id), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::Admin::_iceD_getServerAdminCategory(::IceInternal::Incoming& inS, const ::Ice::Current& current) const
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    inS.readEmptyParams();
    ::std::string ret = this->getServerAdminCategory(current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::Admin::_iceD_getServerAdmin(::IceInternal::Incoming& inS, const ::Ice::Current& current) const
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_id;
    istr->readAll(iceP_id);
    inS.endReadParams();
    ::std::optional<::Ice::ObjectPrx> ret = this->getServerAdmin(::std::move(iceP_id), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::Admin::_iceD_enableServer(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_id;
    bool iceP_enabled;
    istr->readAll(iceP_id, iceP_enabled);
    inS.endReadParams();
    this->enableServer(::std::move(iceP_id), iceP_enabled, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::Admin::_iceD_isServerEnabled(::IceInternal::Incoming& inS, const ::Ice::Current& current) const
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_id;
    istr->readAll(iceP_id);
    inS.endReadParams();
    bool ret = this->isServerEnabled(::std::move(iceP_id), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::Admin::_iceD_startServer(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_id;
    istr->readAll(iceP_id);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    this->startServerAsync(::std::move(iceP_id), inA->response(), inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::Admin::_iceD_stopServer(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_id;
    istr->readAll(iceP_id);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    this->stopServerAsync(::std::move(iceP_id), inA->response(), inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::Admin::_iceD_patchServer(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_id;
    bool iceP_shutdown;
    istr->readAll(iceP_id, iceP_shutdown);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    this->patchServerAsync(::std::move(iceP_id), iceP_shutdown, inA->response(), inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::Admin::_iceD_sendSignal(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_id;
    ::std::string iceP_signal;
    istr->readAll(iceP_id, iceP_signal);
    inS.endReadParams();
    this->sendSignal(::std::move(iceP_id), ::std::move(iceP_signal), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::Admin::_iceD_getAllServerIds(::IceInternal::Incoming& inS, const ::Ice::Current& current) const
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    inS.readEmptyParams();
    ::Ice::StringSeq ret = this->getAllServerIds(current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::Admin::_iceD_getAdapterInfo(::IceInternal::Incoming& inS, const ::Ice::Current& current) const
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_id;
    istr->readAll(iceP_id);
    inS.endReadParams();
    AdapterInfoSeq ret = this->getAdapterInfo(::std::move(iceP_id), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::Admin::_iceD_removeAdapter(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_id;
    istr->readAll(iceP_id);
    inS.endReadParams();
    this->removeAdapter(::std::move(iceP_id), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::Admin::_iceD_getAllAdapterIds(::IceInternal::Incoming& inS, const ::Ice::Current& current) const
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    inS.readEmptyParams();
    ::Ice::StringSeq ret = this->getAllAdapterIds(current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::Admin::_iceD_addObject(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::optional<::Ice::ObjectPrx> iceP_obj;
    istr->readAll(iceP_obj);
    inS.endReadParams();
    this->addObject(::std::move(iceP_obj), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::Admin::_iceD_updateObject(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::optional<::Ice::ObjectPrx> iceP_obj;
    istr->readAll(iceP_obj);
    inS.endReadParams();
    this->updateObject(::std::move(iceP_obj), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::Admin::_iceD_addObjectWithType(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::optional<::Ice::ObjectPrx> iceP_obj;
    ::std::string iceP_type;
    istr->readAll(iceP_obj, iceP_type);
    inS.endReadParams();
    this->addObjectWithType(::std::move(iceP_obj), ::std::move(iceP_type), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::Admin::_iceD_removeObject(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::Ice::Identity iceP_id;
    istr->readAll(iceP_id);
    inS.endReadParams();
    this->removeObject(::std::move(iceP_id), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::Admin::_iceD_getObjectInfo(::IceInternal::Incoming& inS, const ::Ice::Current& current) const
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    ::Ice::Identity iceP_id;
    istr->readAll(iceP_id);
    inS.endReadParams();
    ObjectInfo ret = this->getObjectInfo(::std::move(iceP_id), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::Admin::_iceD_getObjectInfosByType(::IceInternal::Incoming& inS, const ::Ice::Current& current) const
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_type;
    istr->readAll(iceP_type);
    inS.endReadParams();
    ObjectInfoSeq ret = this->getObjectInfosByType(::std::move(iceP_type), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::Admin::_iceD_getAllObjectInfos(::IceInternal::Incoming& inS, const ::Ice::Current& current) const
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_expr;
    istr->readAll(iceP_expr);
    inS.endReadParams();
    ObjectInfoSeq ret = this->getAllObjectInfos(::std::move(iceP_expr), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::Admin::_iceD_pingNode(::IceInternal::Incoming& inS, const ::Ice::Current& current) const
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_name;
    istr->readAll(iceP_name);
    inS.endReadParams();
    bool ret = this->pingNode(::std::move(iceP_name), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::Admin::_iceD_getNodeLoad(::IceInternal::Incoming& inS, const ::Ice::Current& current) const
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_name;
    istr->readAll(iceP_name);
    inS.endReadParams();
    LoadInfo ret = this->getNodeLoad(::std::move(iceP_name), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::Admin::_iceD_getNodeInfo(::IceInternal::Incoming& inS, const ::Ice::Current& current) const
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_name;
    istr->readAll(iceP_name);
    inS.endReadParams();
    NodeInfo ret = this->getNodeInfo(::std::move(iceP_name), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::Admin::_iceD_getNodeAdmin(::IceInternal::Incoming& inS, const ::Ice::Current& current) const
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_name;
    istr->readAll(iceP_name);
    inS.endReadParams();
    ::std::optional<::Ice::ObjectPrx> ret = this->getNodeAdmin(::std::move(iceP_name), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::Admin::_iceD_getNodeProcessorSocketCount(::IceInternal::Incoming& inS, const ::Ice::Current& current) const
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_name;
    istr->readAll(iceP_name);
    inS.endReadParams();
    ::std::int32_t ret = this->getNodeProcessorSocketCount(::std::move(iceP_name), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::Admin::_iceD_shutdownNode(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_name;
    istr->readAll(iceP_name);
    inS.endReadParams();
    this->shutdownNode(::std::move(iceP_name), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::Admin::_iceD_getNodeHostname(::IceInternal::Incoming& inS, const ::Ice::Current& current) const
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_name;
    istr->readAll(iceP_name);
    inS.endReadParams();
    ::std::string ret = this->getNodeHostname(::std::move(iceP_name), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::Admin::_iceD_getAllNodeNames(::IceInternal::Incoming& inS, const ::Ice::Current& current) const
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    inS.readEmptyParams();
    ::Ice::StringSeq ret = this->getAllNodeNames(current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::Admin::_iceD_pingRegistry(::IceInternal::Incoming& inS, const ::Ice::Current& current) const
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_name;
    istr->readAll(iceP_name);
    inS.endReadParams();
    bool ret = this->pingRegistry(::std::move(iceP_name), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::Admin::_iceD_getRegistryInfo(::IceInternal::Incoming& inS, const ::Ice::Current& current) const
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_name;
    istr->readAll(iceP_name);
    inS.endReadParams();
    RegistryInfo ret = this->getRegistryInfo(::std::move(iceP_name), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::Admin::_iceD_getRegistryAdmin(::IceInternal::Incoming& inS, const ::Ice::Current& current) const
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_name;
    istr->readAll(iceP_name);
    inS.endReadParams();
    ::std::optional<::Ice::ObjectPrx> ret = this->getRegistryAdmin(::std::move(iceP_name), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::Admin::_iceD_shutdownRegistry(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_name;
    istr->readAll(iceP_name);
    inS.endReadParams();
    this->shutdownRegistry(::std::move(iceP_name), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::Admin::_iceD_getAllRegistryNames(::IceInternal::Incoming& inS, const ::Ice::Current& current) const
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    inS.readEmptyParams();
    ::Ice::StringSeq ret = this->getAllRegistryNames(current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::Admin::_iceD_shutdown(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    this->shutdown(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::Admin::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    static constexpr ::std::string_view allOperations[] = { "addApplication", "addObject", "addObjectWithType", "enableServer", "getAdapterInfo", "getAllAdapterIds", "getAllApplicationNames", "getAllNodeNames", "getAllObjectInfos", "getAllRegistryNames", "getAllServerIds", "getApplicationInfo", "getDefaultApplicationDescriptor", "getNodeAdmin", "getNodeHostname", "getNodeInfo", "getNodeLoad", "getNodeProcessorSocketCount", "getObjectInfo", "getObjectInfosByType", "getRegistryAdmin", "getRegistryInfo", "getServerAdmin", "getServerAdminCategory", "getServerInfo", "getServerPid", "getServerState", "ice_id", "ice_ids", "ice_isA", "ice_ping", "instantiateServer", "isServerEnabled", "patchApplication", "patchServer", "pingNode", "pingRegistry", "removeAdapter", "removeApplication", "removeObject", "sendSignal", "shutdown", "shutdownNode", "shutdownRegistry", "startServer", "stopServer", "syncApplication", "syncApplicationWithoutRestart", "updateApplication", "updateApplicationWithoutRestart", "updateObject" };

    ::std::pair<const ::std::string_view*, const ::std::string_view*> r = ::std::equal_range(allOperations, allOperations + 51, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - allOperations)
    {
        case 0:
        {
            return _iceD_addApplication(in, current);
        }
        case 1:
        {
            return _iceD_addObject(in, current);
        }
        case 2:
        {
            return _iceD_addObjectWithType(in, current);
        }
        case 3:
        {
            return _iceD_enableServer(in, current);
        }
        case 4:
        {
            return _iceD_getAdapterInfo(in, current);
        }
        case 5:
        {
            return _iceD_getAllAdapterIds(in, current);
        }
        case 6:
        {
            return _iceD_getAllApplicationNames(in, current);
        }
        case 7:
        {
            return _iceD_getAllNodeNames(in, current);
        }
        case 8:
        {
            return _iceD_getAllObjectInfos(in, current);
        }
        case 9:
        {
            return _iceD_getAllRegistryNames(in, current);
        }
        case 10:
        {
            return _iceD_getAllServerIds(in, current);
        }
        case 11:
        {
            return _iceD_getApplicationInfo(in, current);
        }
        case 12:
        {
            return _iceD_getDefaultApplicationDescriptor(in, current);
        }
        case 13:
        {
            return _iceD_getNodeAdmin(in, current);
        }
        case 14:
        {
            return _iceD_getNodeHostname(in, current);
        }
        case 15:
        {
            return _iceD_getNodeInfo(in, current);
        }
        case 16:
        {
            return _iceD_getNodeLoad(in, current);
        }
        case 17:
        {
            return _iceD_getNodeProcessorSocketCount(in, current);
        }
        case 18:
        {
            return _iceD_getObjectInfo(in, current);
        }
        case 19:
        {
            return _iceD_getObjectInfosByType(in, current);
        }
        case 20:
        {
            return _iceD_getRegistryAdmin(in, current);
        }
        case 21:
        {
            return _iceD_getRegistryInfo(in, current);
        }
        case 22:
        {
            return _iceD_getServerAdmin(in, current);
        }
        case 23:
        {
            return _iceD_getServerAdminCategory(in, current);
        }
        case 24:
        {
            return _iceD_getServerInfo(in, current);
        }
        case 25:
        {
            return _iceD_getServerPid(in, current);
        }
        case 26:
        {
            return _iceD_getServerState(in, current);
        }
        case 27:
        {
            return _iceD_ice_id(in, current);
        }
        case 28:
        {
            return _iceD_ice_ids(in, current);
        }
        case 29:
        {
            return _iceD_ice_isA(in, current);
        }
        case 30:
        {
            return _iceD_ice_ping(in, current);
        }
        case 31:
        {
            return _iceD_instantiateServer(in, current);
        }
        case 32:
        {
            return _iceD_isServerEnabled(in, current);
        }
        case 33:
        {
            return _iceD_patchApplication(in, current);
        }
        case 34:
        {
            return _iceD_patchServer(in, current);
        }
        case 35:
        {
            return _iceD_pingNode(in, current);
        }
        case 36:
        {
            return _iceD_pingRegistry(in, current);
        }
        case 37:
        {
            return _iceD_removeAdapter(in, current);
        }
        case 38:
        {
            return _iceD_removeApplication(in, current);
        }
        case 39:
        {
            return _iceD_removeObject(in, current);
        }
        case 40:
        {
            return _iceD_sendSignal(in, current);
        }
        case 41:
        {
            return _iceD_shutdown(in, current);
        }
        case 42:
        {
            return _iceD_shutdownNode(in, current);
        }
        case 43:
        {
            return _iceD_shutdownRegistry(in, current);
        }
        case 44:
        {
            return _iceD_startServer(in, current);
        }
        case 45:
        {
            return _iceD_stopServer(in, current);
        }
        case 46:
        {
            return _iceD_syncApplication(in, current);
        }
        case 47:
        {
            return _iceD_syncApplicationWithoutRestart(in, current);
        }
        case 48:
        {
            return _iceD_updateApplication(in, current);
        }
        case 49:
        {
            return _iceD_updateApplicationWithoutRestart(in, current);
        }
        case 50:
        {
            return _iceD_updateObject(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

::std::vector<::std::string>
IceGrid::FileIterator::ice_ids(const ::Ice::Current&) const
{
    static const ::std::vector<::std::string> allTypeIds = { "::Ice::Object", "::IceGrid::FileIterator" };
    return allTypeIds;
}

::std::string
IceGrid::FileIterator::ice_id(const ::Ice::Current&) const
{
    return ::std::string{ice_staticId()};
}

::std::string_view
IceGrid::FileIterator::ice_staticId()
{
    static constexpr ::std::string_view typeId = "::IceGrid::FileIterator";
    return typeId;
}

/// \cond INTERNAL
bool
IceGrid::FileIterator::_iceD_read(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::int32_t iceP_size;
    istr->readAll(iceP_size);
    inS.endReadParams();
    ::Ice::StringSeq iceP_lines;
    bool ret = this->read(iceP_size, iceP_lines, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_lines, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::FileIterator::_iceD_destroy(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    this->destroy(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::FileIterator::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    static constexpr ::std::string_view allOperations[] = { "destroy", "ice_id", "ice_ids", "ice_isA", "ice_ping", "read" };

    ::std::pair<const ::std::string_view*, const ::std::string_view*> r = ::std::equal_range(allOperations, allOperations + 6, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - allOperations)
    {
        case 0:
        {
            return _iceD_destroy(in, current);
        }
        case 1:
        {
            return _iceD_ice_id(in, current);
        }
        case 2:
        {
            return _iceD_ice_ids(in, current);
        }
        case 3:
        {
            return _iceD_ice_isA(in, current);
        }
        case 4:
        {
            return _iceD_ice_ping(in, current);
        }
        case 5:
        {
            return _iceD_read(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

::std::vector<::std::string>
IceGrid::RegistryObserver::ice_ids(const ::Ice::Current&) const
{
    static const ::std::vector<::std::string> allTypeIds = { "::Ice::Object", "::IceGrid::RegistryObserver" };
    return allTypeIds;
}

::std::string
IceGrid::RegistryObserver::ice_id(const ::Ice::Current&) const
{
    return ::std::string{ice_staticId()};
}

::std::string_view
IceGrid::RegistryObserver::ice_staticId()
{
    static constexpr ::std::string_view typeId = "::IceGrid::RegistryObserver";
    return typeId;
}

/// \cond INTERNAL
bool
IceGrid::RegistryObserver::_iceD_registryInit(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    RegistryInfoSeq iceP_registries;
    istr->readAll(iceP_registries);
    inS.endReadParams();
    this->registryInit(::std::move(iceP_registries), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::RegistryObserver::_iceD_registryUp(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    RegistryInfo iceP_node;
    istr->readAll(iceP_node);
    inS.endReadParams();
    this->registryUp(::std::move(iceP_node), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::RegistryObserver::_iceD_registryDown(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_name;
    istr->readAll(iceP_name);
    inS.endReadParams();
    this->registryDown(::std::move(iceP_name), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::RegistryObserver::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    static constexpr ::std::string_view allOperations[] = { "ice_id", "ice_ids", "ice_isA", "ice_ping", "registryDown", "registryInit", "registryUp" };

    ::std::pair<const ::std::string_view*, const ::std::string_view*> r = ::std::equal_range(allOperations, allOperations + 7, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - allOperations)
    {
        case 0:
        {
            return _iceD_ice_id(in, current);
        }
        case 1:
        {
            return _iceD_ice_ids(in, current);
        }
        case 2:
        {
            return _iceD_ice_isA(in, current);
        }
        case 3:
        {
            return _iceD_ice_ping(in, current);
        }
        case 4:
        {
            return _iceD_registryDown(in, current);
        }
        case 5:
        {
            return _iceD_registryInit(in, current);
        }
        case 6:
        {
            return _iceD_registryUp(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

::std::vector<::std::string>
IceGrid::NodeObserver::ice_ids(const ::Ice::Current&) const
{
    static const ::std::vector<::std::string> allTypeIds = { "::Ice::Object", "::IceGrid::NodeObserver" };
    return allTypeIds;
}

::std::string
IceGrid::NodeObserver::ice_id(const ::Ice::Current&) const
{
    return ::std::string{ice_staticId()};
}

::std::string_view
IceGrid::NodeObserver::ice_staticId()
{
    static constexpr ::std::string_view typeId = "::IceGrid::NodeObserver";
    return typeId;
}

/// \cond INTERNAL
bool
IceGrid::NodeObserver::_iceD_nodeInit(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    NodeDynamicInfoSeq iceP_nodes;
    istr->readAll(iceP_nodes);
    inS.endReadParams();
    this->nodeInit(::std::move(iceP_nodes), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::NodeObserver::_iceD_nodeUp(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    NodeDynamicInfo iceP_node;
    istr->readAll(iceP_node);
    inS.endReadParams();
    this->nodeUp(::std::move(iceP_node), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::NodeObserver::_iceD_nodeDown(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_name;
    istr->readAll(iceP_name);
    inS.endReadParams();
    this->nodeDown(::std::move(iceP_name), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::NodeObserver::_iceD_updateServer(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_node;
    ServerDynamicInfo iceP_updatedInfo;
    istr->readAll(iceP_node, iceP_updatedInfo);
    inS.endReadParams();
    this->updateServer(::std::move(iceP_node), ::std::move(iceP_updatedInfo), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::NodeObserver::_iceD_updateAdapter(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_node;
    AdapterDynamicInfo iceP_updatedInfo;
    istr->readAll(iceP_node, iceP_updatedInfo);
    inS.endReadParams();
    this->updateAdapter(::std::move(iceP_node), ::std::move(iceP_updatedInfo), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::NodeObserver::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    static constexpr ::std::string_view allOperations[] = { "ice_id", "ice_ids", "ice_isA", "ice_ping", "nodeDown", "nodeInit", "nodeUp", "updateAdapter", "updateServer" };

    ::std::pair<const ::std::string_view*, const ::std::string_view*> r = ::std::equal_range(allOperations, allOperations + 9, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - allOperations)
    {
        case 0:
        {
            return _iceD_ice_id(in, current);
        }
        case 1:
        {
            return _iceD_ice_ids(in, current);
        }
        case 2:
        {
            return _iceD_ice_isA(in, current);
        }
        case 3:
        {
            return _iceD_ice_ping(in, current);
        }
        case 4:
        {
            return _iceD_nodeDown(in, current);
        }
        case 5:
        {
            return _iceD_nodeInit(in, current);
        }
        case 6:
        {
            return _iceD_nodeUp(in, current);
        }
        case 7:
        {
            return _iceD_updateAdapter(in, current);
        }
        case 8:
        {
            return _iceD_updateServer(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

::std::vector<::std::string>
IceGrid::ApplicationObserver::ice_ids(const ::Ice::Current&) const
{
    static const ::std::vector<::std::string> allTypeIds = { "::Ice::Object", "::IceGrid::ApplicationObserver" };
    return allTypeIds;
}

::std::string
IceGrid::ApplicationObserver::ice_id(const ::Ice::Current&) const
{
    return ::std::string{ice_staticId()};
}

::std::string_view
IceGrid::ApplicationObserver::ice_staticId()
{
    static constexpr ::std::string_view typeId = "::IceGrid::ApplicationObserver";
    return typeId;
}

/// \cond INTERNAL
bool
IceGrid::ApplicationObserver::_iceD_applicationInit(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::int32_t iceP_serial;
    ApplicationInfoSeq iceP_applications;
    istr->readAll(iceP_serial, iceP_applications);
    istr->readPendingValues();
    inS.endReadParams();
    this->applicationInit(iceP_serial, ::std::move(iceP_applications), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::ApplicationObserver::_iceD_applicationAdded(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::int32_t iceP_serial;
    ApplicationInfo iceP_desc;
    istr->readAll(iceP_serial, iceP_desc);
    istr->readPendingValues();
    inS.endReadParams();
    this->applicationAdded(iceP_serial, ::std::move(iceP_desc), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::ApplicationObserver::_iceD_applicationRemoved(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::int32_t iceP_serial;
    ::std::string iceP_name;
    istr->readAll(iceP_serial, iceP_name);
    inS.endReadParams();
    this->applicationRemoved(iceP_serial, ::std::move(iceP_name), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::ApplicationObserver::_iceD_applicationUpdated(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::int32_t iceP_serial;
    ApplicationUpdateInfo iceP_desc;
    istr->readAll(iceP_serial, iceP_desc);
    istr->readPendingValues();
    inS.endReadParams();
    this->applicationUpdated(iceP_serial, ::std::move(iceP_desc), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::ApplicationObserver::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    static constexpr ::std::string_view allOperations[] = { "applicationAdded", "applicationInit", "applicationRemoved", "applicationUpdated", "ice_id", "ice_ids", "ice_isA", "ice_ping" };

    ::std::pair<const ::std::string_view*, const ::std::string_view*> r = ::std::equal_range(allOperations, allOperations + 8, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - allOperations)
    {
        case 0:
        {
            return _iceD_applicationAdded(in, current);
        }
        case 1:
        {
            return _iceD_applicationInit(in, current);
        }
        case 2:
        {
            return _iceD_applicationRemoved(in, current);
        }
        case 3:
        {
            return _iceD_applicationUpdated(in, current);
        }
        case 4:
        {
            return _iceD_ice_id(in, current);
        }
        case 5:
        {
            return _iceD_ice_ids(in, current);
        }
        case 6:
        {
            return _iceD_ice_isA(in, current);
        }
        case 7:
        {
            return _iceD_ice_ping(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

::std::vector<::std::string>
IceGrid::AdapterObserver::ice_ids(const ::Ice::Current&) const
{
    static const ::std::vector<::std::string> allTypeIds = { "::Ice::Object", "::IceGrid::AdapterObserver" };
    return allTypeIds;
}

::std::string
IceGrid::AdapterObserver::ice_id(const ::Ice::Current&) const
{
    return ::std::string{ice_staticId()};
}

::std::string_view
IceGrid::AdapterObserver::ice_staticId()
{
    static constexpr ::std::string_view typeId = "::IceGrid::AdapterObserver";
    return typeId;
}

/// \cond INTERNAL
bool
IceGrid::AdapterObserver::_iceD_adapterInit(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    AdapterInfoSeq iceP_adpts;
    istr->readAll(iceP_adpts);
    inS.endReadParams();
    this->adapterInit(::std::move(iceP_adpts), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::AdapterObserver::_iceD_adapterAdded(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    AdapterInfo iceP_info;
    istr->readAll(iceP_info);
    inS.endReadParams();
    this->adapterAdded(::std::move(iceP_info), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::AdapterObserver::_iceD_adapterUpdated(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    AdapterInfo iceP_info;
    istr->readAll(iceP_info);
    inS.endReadParams();
    this->adapterUpdated(::std::move(iceP_info), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::AdapterObserver::_iceD_adapterRemoved(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_id;
    istr->readAll(iceP_id);
    inS.endReadParams();
    this->adapterRemoved(::std::move(iceP_id), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::AdapterObserver::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    static constexpr ::std::string_view allOperations[] = { "adapterAdded", "adapterInit", "adapterRemoved", "adapterUpdated", "ice_id", "ice_ids", "ice_isA", "ice_ping" };

    ::std::pair<const ::std::string_view*, const ::std::string_view*> r = ::std::equal_range(allOperations, allOperations + 8, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - allOperations)
    {
        case 0:
        {
            return _iceD_adapterAdded(in, current);
        }
        case 1:
        {
            return _iceD_adapterInit(in, current);
        }
        case 2:
        {
            return _iceD_adapterRemoved(in, current);
        }
        case 3:
        {
            return _iceD_adapterUpdated(in, current);
        }
        case 4:
        {
            return _iceD_ice_id(in, current);
        }
        case 5:
        {
            return _iceD_ice_ids(in, current);
        }
        case 6:
        {
            return _iceD_ice_isA(in, current);
        }
        case 7:
        {
            return _iceD_ice_ping(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

::std::vector<::std::string>
IceGrid::ObjectObserver::ice_ids(const ::Ice::Current&) const
{
    static const ::std::vector<::std::string> allTypeIds = { "::Ice::Object", "::IceGrid::ObjectObserver" };
    return allTypeIds;
}

::std::string
IceGrid::ObjectObserver::ice_id(const ::Ice::Current&) const
{
    return ::std::string{ice_staticId()};
}

::std::string_view
IceGrid::ObjectObserver::ice_staticId()
{
    static constexpr ::std::string_view typeId = "::IceGrid::ObjectObserver";
    return typeId;
}

/// \cond INTERNAL
bool
IceGrid::ObjectObserver::_iceD_objectInit(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ObjectInfoSeq iceP_objects;
    istr->readAll(iceP_objects);
    inS.endReadParams();
    this->objectInit(::std::move(iceP_objects), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::ObjectObserver::_iceD_objectAdded(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ObjectInfo iceP_info;
    istr->readAll(iceP_info);
    inS.endReadParams();
    this->objectAdded(::std::move(iceP_info), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::ObjectObserver::_iceD_objectUpdated(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ObjectInfo iceP_info;
    istr->readAll(iceP_info);
    inS.endReadParams();
    this->objectUpdated(::std::move(iceP_info), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::ObjectObserver::_iceD_objectRemoved(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::Ice::Identity iceP_id;
    istr->readAll(iceP_id);
    inS.endReadParams();
    this->objectRemoved(::std::move(iceP_id), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::ObjectObserver::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    static constexpr ::std::string_view allOperations[] = { "ice_id", "ice_ids", "ice_isA", "ice_ping", "objectAdded", "objectInit", "objectRemoved", "objectUpdated" };

    ::std::pair<const ::std::string_view*, const ::std::string_view*> r = ::std::equal_range(allOperations, allOperations + 8, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - allOperations)
    {
        case 0:
        {
            return _iceD_ice_id(in, current);
        }
        case 1:
        {
            return _iceD_ice_ids(in, current);
        }
        case 2:
        {
            return _iceD_ice_isA(in, current);
        }
        case 3:
        {
            return _iceD_ice_ping(in, current);
        }
        case 4:
        {
            return _iceD_objectAdded(in, current);
        }
        case 5:
        {
            return _iceD_objectInit(in, current);
        }
        case 6:
        {
            return _iceD_objectRemoved(in, current);
        }
        case 7:
        {
            return _iceD_objectUpdated(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

::std::vector<::std::string>
IceGrid::AdminSession::ice_ids(const ::Ice::Current&) const
{
    static const ::std::vector<::std::string> allTypeIds = { "::Glacier2::Session", "::Ice::Object", "::IceGrid::AdminSession" };
    return allTypeIds;
}

::std::string
IceGrid::AdminSession::ice_id(const ::Ice::Current&) const
{
    return ::std::string{ice_staticId()};
}

::std::string_view
IceGrid::AdminSession::ice_staticId()
{
    static constexpr ::std::string_view typeId = "::IceGrid::AdminSession";
    return typeId;
}

/// \cond INTERNAL
bool
IceGrid::AdminSession::_iceD_keepAlive(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    inS.readEmptyParams();
    this->keepAlive(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::AdminSession::_iceD_getAdmin(::IceInternal::Incoming& inS, const ::Ice::Current& current) const
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    inS.readEmptyParams();
    ::std::optional<AdminPrx> ret = this->getAdmin(current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::AdminSession::_iceD_getAdminCallbackTemplate(::IceInternal::Incoming& inS, const ::Ice::Current& current) const
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    inS.readEmptyParams();
    ::std::optional<::Ice::ObjectPrx> ret = this->getAdminCallbackTemplate(current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::AdminSession::_iceD_setObservers(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    ::std::optional<RegistryObserverPrx> iceP_registryObs;
    ::std::optional<NodeObserverPrx> iceP_nodeObs;
    ::std::optional<ApplicationObserverPrx> iceP_appObs;
    ::std::optional<AdapterObserverPrx> iceP_adptObs;
    ::std::optional<ObjectObserverPrx> iceP_objObs;
    istr->readAll(iceP_registryObs, iceP_nodeObs, iceP_appObs, iceP_adptObs, iceP_objObs);
    inS.endReadParams();
    this->setObservers(::std::move(iceP_registryObs), ::std::move(iceP_nodeObs), ::std::move(iceP_appObs), ::std::move(iceP_adptObs), ::std::move(iceP_objObs), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::AdminSession::_iceD_setObserversByIdentity(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    auto istr = inS.startReadParams();
    ::Ice::Identity iceP_registryObs;
    ::Ice::Identity iceP_nodeObs;
    ::Ice::Identity iceP_appObs;
    ::Ice::Identity iceP_adptObs;
    ::Ice::Identity iceP_objObs;
    istr->readAll(iceP_registryObs, iceP_nodeObs, iceP_appObs, iceP_adptObs, iceP_objObs);
    inS.endReadParams();
    this->setObserversByIdentity(::std::move(iceP_registryObs), ::std::move(iceP_nodeObs), ::std::move(iceP_appObs), ::std::move(iceP_adptObs), ::std::move(iceP_objObs), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::AdminSession::_iceD_startUpdate(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    ::std::int32_t ret = this->startUpdate(current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::AdminSession::_iceD_finishUpdate(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    this->finishUpdate(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::AdminSession::_iceD_getReplicaName(::IceInternal::Incoming& inS, const ::Ice::Current& current) const
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    inS.readEmptyParams();
    ::std::string ret = this->getReplicaName(current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::AdminSession::_iceD_openServerLog(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_id;
    ::std::string iceP_path;
    ::std::int32_t iceP_count;
    istr->readAll(iceP_id, iceP_path, iceP_count);
    inS.endReadParams();
    ::std::optional<FileIteratorPrx> ret = this->openServerLog(::std::move(iceP_id), ::std::move(iceP_path), iceP_count, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::AdminSession::_iceD_openServerStdErr(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_id;
    ::std::int32_t iceP_count;
    istr->readAll(iceP_id, iceP_count);
    inS.endReadParams();
    ::std::optional<FileIteratorPrx> ret = this->openServerStdErr(::std::move(iceP_id), iceP_count, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::AdminSession::_iceD_openServerStdOut(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_id;
    ::std::int32_t iceP_count;
    istr->readAll(iceP_id, iceP_count);
    inS.endReadParams();
    ::std::optional<FileIteratorPrx> ret = this->openServerStdOut(::std::move(iceP_id), iceP_count, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::AdminSession::_iceD_openNodeStdErr(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_name;
    ::std::int32_t iceP_count;
    istr->readAll(iceP_name, iceP_count);
    inS.endReadParams();
    ::std::optional<FileIteratorPrx> ret = this->openNodeStdErr(::std::move(iceP_name), iceP_count, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::AdminSession::_iceD_openNodeStdOut(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_name;
    ::std::int32_t iceP_count;
    istr->readAll(iceP_name, iceP_count);
    inS.endReadParams();
    ::std::optional<FileIteratorPrx> ret = this->openNodeStdOut(::std::move(iceP_name), iceP_count, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::AdminSession::_iceD_openRegistryStdErr(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_name;
    ::std::int32_t iceP_count;
    istr->readAll(iceP_name, iceP_count);
    inS.endReadParams();
    ::std::optional<FileIteratorPrx> ret = this->openRegistryStdErr(::std::move(iceP_name), iceP_count, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::AdminSession::_iceD_openRegistryStdOut(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_name;
    ::std::int32_t iceP_count;
    istr->readAll(iceP_name, iceP_count);
    inS.endReadParams();
    ::std::optional<FileIteratorPrx> ret = this->openRegistryStdOut(::std::move(iceP_name), iceP_count, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
IceGrid::AdminSession::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    static constexpr ::std::string_view allOperations[] = { "destroy", "finishUpdate", "getAdmin", "getAdminCallbackTemplate", "getReplicaName", "ice_id", "ice_ids", "ice_isA", "ice_ping", "keepAlive", "openNodeStdErr", "openNodeStdOut", "openRegistryStdErr", "openRegistryStdOut", "openServerLog", "openServerStdErr", "openServerStdOut", "setObservers", "setObserversByIdentity", "startUpdate" };

    ::std::pair<const ::std::string_view*, const ::std::string_view*> r = ::std::equal_range(allOperations, allOperations + 20, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - allOperations)
    {
        case 0:
        {
            return _iceD_destroy(in, current);
        }
        case 1:
        {
            return _iceD_finishUpdate(in, current);
        }
        case 2:
        {
            return _iceD_getAdmin(in, current);
        }
        case 3:
        {
            return _iceD_getAdminCallbackTemplate(in, current);
        }
        case 4:
        {
            return _iceD_getReplicaName(in, current);
        }
        case 5:
        {
            return _iceD_ice_id(in, current);
        }
        case 6:
        {
            return _iceD_ice_ids(in, current);
        }
        case 7:
        {
            return _iceD_ice_isA(in, current);
        }
        case 8:
        {
            return _iceD_ice_ping(in, current);
        }
        case 9:
        {
            return _iceD_keepAlive(in, current);
        }
        case 10:
        {
            return _iceD_openNodeStdErr(in, current);
        }
        case 11:
        {
            return _iceD_openNodeStdOut(in, current);
        }
        case 12:
        {
            return _iceD_openRegistryStdErr(in, current);
        }
        case 13:
        {
            return _iceD_openRegistryStdOut(in, current);
        }
        case 14:
        {
            return _iceD_openServerLog(in, current);
        }
        case 15:
        {
            return _iceD_openServerStdErr(in, current);
        }
        case 16:
        {
            return _iceD_openServerStdOut(in, current);
        }
        case 17:
        {
            return _iceD_setObservers(in, current);
        }
        case 18:
        {
            return _iceD_setObserversByIdentity(in, current);
        }
        case 19:
        {
            return _iceD_startUpdate(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond
