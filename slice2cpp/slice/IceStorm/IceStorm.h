//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.8.0-alpha.0
//
// <auto-generated>
//
// Generated from file `IceStorm.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __IceStorm_h__
#define __IceStorm_h__

#include <IceUtil/PushDisableWarnings.h>
#include <Ice/Ice.h>
#include <Ice/Identity.h>
#include <Metrics.h>
#include <IceUtil/UndefSysMacros.h>
#include <IceStorm/Config.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION  != 30850
#       error Ice version mismatch: an exact match is required for beta generated code
#   endif
#endif

#ifndef ICESTORM_API
#   if defined(ICE_STATIC_LIBS)
#       define ICESTORM_API /**/
#   elif defined(ICESTORM_API_EXPORTS)
#       define ICESTORM_API ICE_DECLSPEC_EXPORT
#   else
#       define ICESTORM_API ICE_DECLSPEC_IMPORT
#   endif
#endif

namespace IceStorm
{

class TopicPrx;
struct LinkInfo;

/**
 * A sequence of {@link LinkInfo} objects.
 */
using LinkInfoSeq = ::std::vector<LinkInfo>;

/**
 * This dictionary represents quality of service parameters.
 * @see Topic#subscribeAndGetPublisher
 */
using QoS = ::std::map<::std::string, ::std::string>;

/**
 * Mapping of topic name to topic proxy.
 */
using TopicDict = ::std::map<::std::string, ::std::optional<TopicPrx>>;
class TopicManagerPrx;
class FinderPrx;

}

namespace IceStorm
{

/**
 * Publishers publish information on a particular topic. A topic logically represents a type. A
 * @see TopicManager
 */
class ICESTORM_API TopicPrx : public ::Ice::Proxy<TopicPrx, ::Ice::ObjectPrx>
{
public:

    /**
     * Get the name of this topic.
     * @param context The Context map to send with the invocation.
     * @return The name of the topic.
     * @see TopicManager#create
     */
    ::std::string getName(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Get the name of this topic.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     * @see TopicManager#create
     */
    ::std::future<::std::string> getNameAsync(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Get the name of this topic.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     * @see TopicManager#create
     */
    ::std::function<void()>
    getNameAsync(::std::function<void(::std::string)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_getName(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::string>>&, const ::Ice::Context&) const;
    /// \endcond

    /**
     * Get a proxy to a publisher object for this topic. To publish data to a topic, the publisher calls getPublisher
     * and then creates a proxy with the publisher type from this proxy. If a replicated IceStorm
     * deployment is used this call may return a replicated proxy. The returned proxy is never null.
     * @param context The Context map to send with the invocation.
     * @return A proxy to publish data on this topic.
     */
    ::std::optional<::Ice::ObjectPrx> getPublisher(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Get a proxy to a publisher object for this topic. To publish data to a topic, the publisher calls getPublisher
     * and then creates a proxy with the publisher type from this proxy. If a replicated IceStorm
     * deployment is used this call may return a replicated proxy. The returned proxy is never null.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    ::std::future<::std::optional<::Ice::ObjectPrx>> getPublisherAsync(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Get a proxy to a publisher object for this topic. To publish data to a topic, the publisher calls getPublisher
     * and then creates a proxy with the publisher type from this proxy. If a replicated IceStorm
     * deployment is used this call may return a replicated proxy. The returned proxy is never null.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    getPublisherAsync(::std::function<void(::std::optional<::Ice::ObjectPrx>)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_getPublisher(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::optional<::Ice::ObjectPrx>>>&, const ::Ice::Context&) const;
    /// \endcond

    /**
     * Get a non-replicated proxy to a publisher object for this topic. To publish data to a topic, the publisher
     * calls getPublisher and then creates a proxy with the publisher type from this proxy. The returned proxy is
     * never null.
     * @param context The Context map to send with the invocation.
     * @return A proxy to publish data on this topic.
     */
    ::std::optional<::Ice::ObjectPrx> getNonReplicatedPublisher(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Get a non-replicated proxy to a publisher object for this topic. To publish data to a topic, the publisher
     * calls getPublisher and then creates a proxy with the publisher type from this proxy. The returned proxy is
     * never null.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    ::std::future<::std::optional<::Ice::ObjectPrx>> getNonReplicatedPublisherAsync(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Get a non-replicated proxy to a publisher object for this topic. To publish data to a topic, the publisher
     * calls getPublisher and then creates a proxy with the publisher type from this proxy. The returned proxy is
     * never null.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    getNonReplicatedPublisherAsync(::std::function<void(::std::optional<::Ice::ObjectPrx>)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_getNonReplicatedPublisher(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::optional<::Ice::ObjectPrx>>>&, const ::Ice::Context&) const;
    /// \endcond

    /**
     * Subscribe with the given <code>qos</code> to this topic.  A per-subscriber publisher object is returned.
     * @param theQoS The quality of service parameters for this subscription.
     * @param subscriber The subscriber's proxy. This proxy is never null.
     * @param context The Context map to send with the invocation.
     * @return The per-subscriber publisher object. The returned object is never null.
     * @throws IceStorm::AlreadySubscribed Raised if the subscriber object is already subscribed.
     * @throws IceStorm::BadQoS Raised if the requested quality of service is unavailable or invalid.
     * @throws IceStorm::InvalidSubscriber Raised if the subscriber object is null.
     * @see #unsubscribe
     */
    ::std::optional<::Ice::ObjectPrx> subscribeAndGetPublisher(const QoS& theQoS, const ::std::optional<::Ice::ObjectPrx>& subscriber, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Subscribe with the given <code>qos</code> to this topic.  A per-subscriber publisher object is returned.
     * @param theQoS The quality of service parameters for this subscription.
     * @param subscriber The subscriber's proxy. This proxy is never null.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     * @see #unsubscribe
     */
    ::std::future<::std::optional<::Ice::ObjectPrx>> subscribeAndGetPublisherAsync(const QoS& theQoS, const ::std::optional<::Ice::ObjectPrx>& subscriber, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Subscribe with the given <code>qos</code> to this topic.  A per-subscriber publisher object is returned.
     * @param theQoS The quality of service parameters for this subscription.
     * @param subscriber The subscriber's proxy. This proxy is never null.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     * @see #unsubscribe
     */
    ::std::function<void()>
    subscribeAndGetPublisherAsync(const QoS& theQoS, const ::std::optional<::Ice::ObjectPrx>& subscriber, ::std::function<void(::std::optional<::Ice::ObjectPrx>)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_subscribeAndGetPublisher(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::optional<::Ice::ObjectPrx>>>&, const QoS&, const ::std::optional<::Ice::ObjectPrx>&, const ::Ice::Context&) const;
    /// \endcond

    /**
     * Unsubscribe the given <code>subscriber</code>.
     * @param subscriber The proxy of an existing subscriber. This proxy is never null.
     * @param context The Context map to send with the invocation.
     * @see #subscribeAndGetPublisher
     */
    void unsubscribe(const ::std::optional<::Ice::ObjectPrx>& subscriber, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Unsubscribe the given <code>subscriber</code>.
     * @param subscriber The proxy of an existing subscriber. This proxy is never null.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     * @see #subscribeAndGetPublisher
     */
    ::std::future<void> unsubscribeAsync(const ::std::optional<::Ice::ObjectPrx>& subscriber, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Unsubscribe the given <code>subscriber</code>.
     * @param subscriber The proxy of an existing subscriber. This proxy is never null.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     * @see #subscribeAndGetPublisher
     */
    ::std::function<void()>
    unsubscribeAsync(const ::std::optional<::Ice::ObjectPrx>& subscriber, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_unsubscribe(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::optional<::Ice::ObjectPrx>&, const ::Ice::Context&) const;
    /// \endcond

    /**
     * Create a link to the given topic. All events originating on this topic will also be sent to
     * <code>linkTo</code>.
     * @param linkTo The topic to link to. This proxy is never null.
     * @param cost The cost to the linked topic.
     * @param context The Context map to send with the invocation.
     * @throws IceStorm::LinkExists Raised if a link to the same topic already exists.
     */
    void link(const ::std::optional<TopicPrx>& linkTo, ::std::int32_t cost, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Create a link to the given topic. All events originating on this topic will also be sent to
     * <code>linkTo</code>.
     * @param linkTo The topic to link to. This proxy is never null.
     * @param cost The cost to the linked topic.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    ::std::future<void> linkAsync(const ::std::optional<TopicPrx>& linkTo, ::std::int32_t cost, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Create a link to the given topic. All events originating on this topic will also be sent to
     * <code>linkTo</code>.
     * @param linkTo The topic to link to. This proxy is never null.
     * @param cost The cost to the linked topic.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    linkAsync(const ::std::optional<TopicPrx>& linkTo, ::std::int32_t cost, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_link(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::optional<TopicPrx>&, ::std::int32_t, const ::Ice::Context&) const;
    /// \endcond

    /**
     * Destroy the link from this topic to the given topic <code>linkTo</code>.
     * @param linkTo The topic to destroy the link to. This proxy is never null.
     * @param context The Context map to send with the invocation.
     * @throws IceStorm::NoSuchLink Raised if a link to the topic does not exist.
     */
    void unlink(const ::std::optional<TopicPrx>& linkTo, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Destroy the link from this topic to the given topic <code>linkTo</code>.
     * @param linkTo The topic to destroy the link to. This proxy is never null.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    ::std::future<void> unlinkAsync(const ::std::optional<TopicPrx>& linkTo, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Destroy the link from this topic to the given topic <code>linkTo</code>.
     * @param linkTo The topic to destroy the link to. This proxy is never null.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    unlinkAsync(const ::std::optional<TopicPrx>& linkTo, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_unlink(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::optional<TopicPrx>&, const ::Ice::Context&) const;
    /// \endcond

    /**
     * Retrieve information on the current links.
     * @param context The Context map to send with the invocation.
     * @return A sequence of LinkInfo objects.
     */
    LinkInfoSeq getLinkInfoSeq(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Retrieve information on the current links.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    ::std::future<LinkInfoSeq> getLinkInfoSeqAsync(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Retrieve information on the current links.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    getLinkInfoSeqAsync(::std::function<void(::IceStorm::LinkInfoSeq)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_getLinkInfoSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<LinkInfoSeq>>&, const ::Ice::Context&) const;
    /// \endcond

    /**
     * Retrieve the list of subscribers for this topic.
     * @param context The Context map to send with the invocation.
     * @return The sequence of Ice identities for the subscriber objects.
     */
    ::Ice::IdentitySeq getSubscribers(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Retrieve the list of subscribers for this topic.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    ::std::future<::Ice::IdentitySeq> getSubscribersAsync(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Retrieve the list of subscribers for this topic.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    getSubscribersAsync(::std::function<void(::Ice::IdentitySeq)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_getSubscribers(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::Ice::IdentitySeq>>&, const ::Ice::Context&) const;
    /// \endcond

    /**
     * Destroy the topic.
     * @param context The Context map to send with the invocation.
     */
    void destroy(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Destroy the topic.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    ::std::future<void> destroyAsync(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Destroy the topic.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    destroyAsync(::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_destroy(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&) const;
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId() noexcept;

    explicit TopicPrx(const ::Ice::ObjectPrx& other) : ::Ice::ObjectPrx(other)
    {
    }

    TopicPrx(const TopicPrx& other) noexcept : ::Ice::ObjectPrx(other)
    {
    }

    TopicPrx(TopicPrx&& other) noexcept : ::Ice::ObjectPrx(::std::move(other))
    {
    }

    TopicPrx(const ::std::shared_ptr<::Ice::Communicator>& communicator, std::string_view proxyString) :
        ::Ice::ObjectPrx(communicator, proxyString)
    {
    }

    TopicPrx& operator=(const TopicPrx& rhs) noexcept
    {
        ::Ice::ObjectPrx::operator=(rhs);
        return *this;
    }

    TopicPrx& operator=(TopicPrx&& rhs) noexcept
    {
        ::Ice::ObjectPrx::operator=(::std::move(rhs));
        return *this;
    }

    /// \cond INTERNAL
    static TopicPrx _fromReference(::IceInternal::ReferencePtr ref) { return TopicPrx(::std::move(ref)); }

protected:

    TopicPrx() = default;

    explicit TopicPrx(::IceInternal::ReferencePtr&& ref) : ::Ice::ObjectPrx(::std::move(ref))
    {
    }
    /// \endcond
};

/**
 * A topic manager manages topics, and subscribers to topics.
 * @see Topic
 */
class ICESTORM_API TopicManagerPrx : public ::Ice::Proxy<TopicManagerPrx, ::Ice::ObjectPrx>
{
public:

    /**
     * Create a new topic. The topic name must be unique.
     * @param name The name of the topic.
     * @param context The Context map to send with the invocation.
     * @return A proxy to the topic instance. The returned proxy is never null.
     * @throws IceStorm::TopicExists Raised if a topic with the same name already exists.
     */
    ::std::optional<TopicPrx> create(::std::string_view name, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Create a new topic. The topic name must be unique.
     * @param name The name of the topic.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    ::std::future<::std::optional<TopicPrx>> createAsync(::std::string_view name, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Create a new topic. The topic name must be unique.
     * @param name The name of the topic.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    createAsync(::std::string_view name, ::std::function<void(::std::optional<::IceStorm::TopicPrx>)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_create(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::optional<TopicPrx>>>&, ::std::string_view, const ::Ice::Context&) const;
    /// \endcond

    /**
     * Retrieve a topic by name.
     * @param name The name of the topic.
     * @param context The Context map to send with the invocation.
     * @return A proxy to the topic instance. The returned proxy is never null.
     * @throws IceStorm::NoSuchTopic Raised if the topic does not exist.
     */
    ::std::optional<TopicPrx> retrieve(::std::string_view name, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Retrieve a topic by name.
     * @param name The name of the topic.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    ::std::future<::std::optional<TopicPrx>> retrieveAsync(::std::string_view name, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Retrieve a topic by name.
     * @param name The name of the topic.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    retrieveAsync(::std::string_view name, ::std::function<void(::std::optional<::IceStorm::TopicPrx>)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_retrieve(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::optional<TopicPrx>>>&, ::std::string_view, const ::Ice::Context&) const;
    /// \endcond

    /**
     * Retrieve all topics managed by this topic manager.
     * @param context The Context map to send with the invocation.
     * @return A dictionary of string, topic proxy pairs.
     */
    TopicDict retrieveAll(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Retrieve all topics managed by this topic manager.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    ::std::future<TopicDict> retrieveAllAsync(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Retrieve all topics managed by this topic manager.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    retrieveAllAsync(::std::function<void(::IceStorm::TopicDict)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_retrieveAll(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TopicDict>>&, const ::Ice::Context&) const;
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId() noexcept;

    explicit TopicManagerPrx(const ::Ice::ObjectPrx& other) : ::Ice::ObjectPrx(other)
    {
    }

    TopicManagerPrx(const TopicManagerPrx& other) noexcept : ::Ice::ObjectPrx(other)
    {
    }

    TopicManagerPrx(TopicManagerPrx&& other) noexcept : ::Ice::ObjectPrx(::std::move(other))
    {
    }

    TopicManagerPrx(const ::std::shared_ptr<::Ice::Communicator>& communicator, std::string_view proxyString) :
        ::Ice::ObjectPrx(communicator, proxyString)
    {
    }

    TopicManagerPrx& operator=(const TopicManagerPrx& rhs) noexcept
    {
        ::Ice::ObjectPrx::operator=(rhs);
        return *this;
    }

    TopicManagerPrx& operator=(TopicManagerPrx&& rhs) noexcept
    {
        ::Ice::ObjectPrx::operator=(::std::move(rhs));
        return *this;
    }

    /// \cond INTERNAL
    static TopicManagerPrx _fromReference(::IceInternal::ReferencePtr ref) { return TopicManagerPrx(::std::move(ref)); }

protected:

    TopicManagerPrx() = default;

    explicit TopicManagerPrx(::IceInternal::ReferencePtr&& ref) : ::Ice::ObjectPrx(::std::move(ref))
    {
    }
    /// \endcond
};

/**
 * This interface is advertised by the IceStorm service through the Ice object with the identity `IceStorm/Finder'.
 * This allows clients to retrieve the topic manager with just the endpoint information of the IceStorm service.
 */
class ICESTORM_API FinderPrx : public ::Ice::Proxy<FinderPrx, ::Ice::ObjectPrx>
{
public:

    /**
     * Get the topic manager proxy. The proxy might point to several replicas.
     * @param context The Context map to send with the invocation.
     * @return The topic manager proxy. The returned proxy is never null.
     */
    ::std::optional<TopicManagerPrx> getTopicManager(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Get the topic manager proxy. The proxy might point to several replicas.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    ::std::future<::std::optional<TopicManagerPrx>> getTopicManagerAsync(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Get the topic manager proxy. The proxy might point to several replicas.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    getTopicManagerAsync(::std::function<void(::std::optional<::IceStorm::TopicManagerPrx>)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_getTopicManager(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::optional<TopicManagerPrx>>>&, const ::Ice::Context&) const;
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId() noexcept;

    explicit FinderPrx(const ::Ice::ObjectPrx& other) : ::Ice::ObjectPrx(other)
    {
    }

    FinderPrx(const FinderPrx& other) noexcept : ::Ice::ObjectPrx(other)
    {
    }

    FinderPrx(FinderPrx&& other) noexcept : ::Ice::ObjectPrx(::std::move(other))
    {
    }

    FinderPrx(const ::std::shared_ptr<::Ice::Communicator>& communicator, std::string_view proxyString) :
        ::Ice::ObjectPrx(communicator, proxyString)
    {
    }

    FinderPrx& operator=(const FinderPrx& rhs) noexcept
    {
        ::Ice::ObjectPrx::operator=(rhs);
        return *this;
    }

    FinderPrx& operator=(FinderPrx&& rhs) noexcept
    {
        ::Ice::ObjectPrx::operator=(::std::move(rhs));
        return *this;
    }

    /// \cond INTERNAL
    static FinderPrx _fromReference(::IceInternal::ReferencePtr ref) { return FinderPrx(::std::move(ref)); }

protected:

    FinderPrx() = default;

    explicit FinderPrx(::IceInternal::ReferencePtr&& ref) : ::Ice::ObjectPrx(::std::move(ref))
    {
    }
    /// \endcond
};

}

namespace IceStorm
{

/**
 * Information on the topic links.
 * \headerfile IceStorm/IceStorm.h
 */
struct LinkInfo
{
    /**
     * The linked topic. It is never null.
     */
    ::std::optional<::IceStorm::TopicPrx> theTopic;
    /**
     * The name of the linked topic.
     */
    ::std::string name;
    /**
     * The cost of traversing this link.
     */
    ::std::int32_t cost;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::optional<::IceStorm::TopicPrx>&, const ::std::string&, const ::std::int32_t&> ice_tuple() const
    {
        return std::tie(theTopic, name, cost);
    }
};

/**
 * This exception indicates that an attempt was made to create a link that already exists.
 * \headerfile IceStorm/IceStorm.h
 */
class ICE_CLASS(ICESTORM_API) LinkExists : public ::Ice::UserExceptionHelper<LinkExists, ::Ice::UserException>
{
public:

    LinkExists() noexcept = default;

    LinkExists(const LinkExists&) = default;

    /**
     * One-shot constructor to initialize all data members.
     * @param name The name of the linked topic.
     */
    LinkExists(::std::string name) noexcept :
        name(::std::move(name))
    {
    }

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&> ice_tuple() const
    {
        return std::tie(name);
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    ICE_MEMBER(ICESTORM_API) static ::std::string_view ice_staticId() noexcept;

    /**
     * The name of the linked topic.
     */
    ::std::string name;
};

/// \cond INTERNAL
static LinkExists _iceS_LinkExists_init;
/// \endcond

/**
 * This exception indicates that an attempt was made to remove a link that does not exist.
 * \headerfile IceStorm/IceStorm.h
 */
class ICE_CLASS(ICESTORM_API) NoSuchLink : public ::Ice::UserExceptionHelper<NoSuchLink, ::Ice::UserException>
{
public:

    NoSuchLink() noexcept = default;

    NoSuchLink(const NoSuchLink&) = default;

    /**
     * One-shot constructor to initialize all data members.
     * @param name The name of the link that does not exist.
     */
    NoSuchLink(::std::string name) noexcept :
        name(::std::move(name))
    {
    }

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&> ice_tuple() const
    {
        return std::tie(name);
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    ICE_MEMBER(ICESTORM_API) static ::std::string_view ice_staticId() noexcept;

    /**
     * The name of the link that does not exist.
     */
    ::std::string name;
};

/**
 * This exception indicates that an attempt was made to subscribe a proxy for which a subscription already exists.
 * \headerfile IceStorm/IceStorm.h
 */
class ICE_CLASS(ICESTORM_API) AlreadySubscribed : public ::Ice::UserExceptionHelper<AlreadySubscribed, ::Ice::UserException>
{
public:

    AlreadySubscribed() noexcept = default;

    AlreadySubscribed(const AlreadySubscribed&) = default;

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<> ice_tuple() const
    {
        return std::tie();
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    ICE_MEMBER(ICESTORM_API) static ::std::string_view ice_staticId() noexcept;
};

/**
 * This exception indicates that an attempt was made to subscribe a proxy that is null.
 * \headerfile IceStorm/IceStorm.h
 */
class ICE_CLASS(ICESTORM_API) InvalidSubscriber : public ::Ice::UserExceptionHelper<InvalidSubscriber, ::Ice::UserException>
{
public:

    InvalidSubscriber() noexcept = default;

    InvalidSubscriber(const InvalidSubscriber&) = default;

    /**
     * One-shot constructor to initialize all data members.
     * @param reason The reason for the failure.
     */
    InvalidSubscriber(::std::string reason) noexcept :
        reason(::std::move(reason))
    {
    }

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&> ice_tuple() const
    {
        return std::tie(reason);
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    ICE_MEMBER(ICESTORM_API) static ::std::string_view ice_staticId() noexcept;

    /**
     * The reason for the failure.
     */
    ::std::string reason;
};

/**
 * This exception indicates that a subscription failed due to an invalid QoS.
 * \headerfile IceStorm/IceStorm.h
 */
class ICE_CLASS(ICESTORM_API) BadQoS : public ::Ice::UserExceptionHelper<BadQoS, ::Ice::UserException>
{
public:

    BadQoS() noexcept = default;

    BadQoS(const BadQoS&) = default;

    /**
     * One-shot constructor to initialize all data members.
     * @param reason The reason for the failure.
     */
    BadQoS(::std::string reason) noexcept :
        reason(::std::move(reason))
    {
    }

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&> ice_tuple() const
    {
        return std::tie(reason);
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    ICE_MEMBER(ICESTORM_API) static ::std::string_view ice_staticId() noexcept;

    /**
     * The reason for the failure.
     */
    ::std::string reason;
};

/**
 * This exception indicates that an attempt was made to create a topic that already exists.
 * \headerfile IceStorm/IceStorm.h
 */
class ICE_CLASS(ICESTORM_API) TopicExists : public ::Ice::UserExceptionHelper<TopicExists, ::Ice::UserException>
{
public:

    TopicExists() noexcept = default;

    TopicExists(const TopicExists&) = default;

    /**
     * One-shot constructor to initialize all data members.
     * @param name The name of the topic that already exists.
     */
    TopicExists(::std::string name) noexcept :
        name(::std::move(name))
    {
    }

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&> ice_tuple() const
    {
        return std::tie(name);
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    ICE_MEMBER(ICESTORM_API) static ::std::string_view ice_staticId() noexcept;

    /**
     * The name of the topic that already exists.
     */
    ::std::string name;
};

/**
 * This exception indicates that an attempt was made to retrieve a topic that does not exist.
 * \headerfile IceStorm/IceStorm.h
 */
class ICE_CLASS(ICESTORM_API) NoSuchTopic : public ::Ice::UserExceptionHelper<NoSuchTopic, ::Ice::UserException>
{
public:

    NoSuchTopic() noexcept = default;

    NoSuchTopic(const NoSuchTopic&) = default;

    /**
     * One-shot constructor to initialize all data members.
     * @param name The name of the topic that does not exist.
     */
    NoSuchTopic(::std::string name) noexcept :
        name(::std::move(name))
    {
    }

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&> ice_tuple() const
    {
        return std::tie(name);
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    ICE_MEMBER(ICESTORM_API) static ::std::string_view ice_staticId() noexcept;

    /**
     * The name of the topic that does not exist.
     */
    ::std::string name;
};

using Ice::operator<;
using Ice::operator<=;
using Ice::operator>;
using Ice::operator>=;
using Ice::operator==;
using Ice::operator!=;

}

namespace IceStorm
{

/**
 * Publishers publish information on a particular topic. A topic logically represents a type. A
 * @see TopicManager
 */
class ICESTORM_API Topic : public virtual ::Ice::Object
{
public:

    using ProxyType = TopicPrx;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static ::std::string_view ice_staticId() noexcept;

    /**
     * Get the name of this topic.
     * @param current The Current object for the invocation.
     * @return The name of the topic.
     * @see TopicManager#create
     */
    virtual ::std::string getName(const ::Ice::Current& current) const = 0;
    /// \cond INTERNAL
    void _iceD_getName(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>) const;
    /// \endcond

    /**
     * Get a proxy to a publisher object for this topic. To publish data to a topic, the publisher calls getPublisher
     * and then creates a proxy with the publisher type from this proxy. If a replicated IceStorm
     * deployment is used this call may return a replicated proxy. The returned proxy is never null.
     * @param current The Current object for the invocation.
     * @return A proxy to publish data on this topic.
     */
    virtual ::std::optional<::Ice::ObjectPrx> getPublisher(const ::Ice::Current& current) const = 0;
    /// \cond INTERNAL
    void _iceD_getPublisher(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>) const;
    /// \endcond

    /**
     * Get a non-replicated proxy to a publisher object for this topic. To publish data to a topic, the publisher
     * calls getPublisher and then creates a proxy with the publisher type from this proxy. The returned proxy is
     * never null.
     * @param current The Current object for the invocation.
     * @return A proxy to publish data on this topic.
     */
    virtual ::std::optional<::Ice::ObjectPrx> getNonReplicatedPublisher(const ::Ice::Current& current) const = 0;
    /// \cond INTERNAL
    void _iceD_getNonReplicatedPublisher(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>) const;
    /// \endcond

    /**
     * Subscribe with the given <code>qos</code> to this topic.  A per-subscriber publisher object is returned.
     * @param theQoS The quality of service parameters for this subscription.
     * @param subscriber The subscriber's proxy. This proxy is never null.
     * @param current The Current object for the invocation.
     * @return The per-subscriber publisher object. The returned object is never null.
     * @throws IceStorm::AlreadySubscribed Raised if the subscriber object is already subscribed.
     * @throws IceStorm::BadQoS Raised if the requested quality of service is unavailable or invalid.
     * @throws IceStorm::InvalidSubscriber Raised if the subscriber object is null.
     * @see #unsubscribe
     */
    virtual ::std::optional<::Ice::ObjectPrx> subscribeAndGetPublisher(QoS theQoS, ::std::optional<::Ice::ObjectPrx> subscriber, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_subscribeAndGetPublisher(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    /**
     * Unsubscribe the given <code>subscriber</code>.
     * @param subscriber The proxy of an existing subscriber. This proxy is never null.
     * @param current The Current object for the invocation.
     * @see #subscribeAndGetPublisher
     */
    virtual void unsubscribe(::std::optional<::Ice::ObjectPrx> subscriber, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_unsubscribe(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    /**
     * Create a link to the given topic. All events originating on this topic will also be sent to
     * <code>linkTo</code>.
     * @param linkTo The topic to link to. This proxy is never null.
     * @param cost The cost to the linked topic.
     * @param current The Current object for the invocation.
     * @throws IceStorm::LinkExists Raised if a link to the same topic already exists.
     */
    virtual void link(::std::optional<TopicPrx> linkTo, ::std::int32_t cost, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_link(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    /**
     * Destroy the link from this topic to the given topic <code>linkTo</code>.
     * @param linkTo The topic to destroy the link to. This proxy is never null.
     * @param current The Current object for the invocation.
     * @throws IceStorm::NoSuchLink Raised if a link to the topic does not exist.
     */
    virtual void unlink(::std::optional<TopicPrx> linkTo, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_unlink(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    /**
     * Retrieve information on the current links.
     * @param current The Current object for the invocation.
     * @return A sequence of LinkInfo objects.
     */
    virtual LinkInfoSeq getLinkInfoSeq(const ::Ice::Current& current) const = 0;
    /// \cond INTERNAL
    void _iceD_getLinkInfoSeq(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>) const;
    /// \endcond

    /**
     * Retrieve the list of subscribers for this topic.
     * @param current The Current object for the invocation.
     * @return The sequence of Ice identities for the subscriber objects.
     */
    virtual ::Ice::IdentitySeq getSubscribers(const ::Ice::Current& current) const = 0;
    /// \cond INTERNAL
    void _iceD_getSubscribers(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>) const;
    /// \endcond

    /**
     * Destroy the topic.
     * @param current The Current object for the invocation.
     */
    virtual void destroy(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_destroy(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    /// \cond INTERNAL
    void dispatch(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>) override;
    /// \endcond
};

using TopicPtr = ::std::shared_ptr<Topic>;

/**
 * A topic manager manages topics, and subscribers to topics.
 * @see Topic
 */
class ICESTORM_API TopicManager : public virtual ::Ice::Object
{
public:

    using ProxyType = TopicManagerPrx;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static ::std::string_view ice_staticId() noexcept;

    /**
     * Create a new topic. The topic name must be unique.
     * @param name The name of the topic.
     * @param current The Current object for the invocation.
     * @return A proxy to the topic instance. The returned proxy is never null.
     * @throws IceStorm::TopicExists Raised if a topic with the same name already exists.
     */
    virtual ::std::optional<TopicPrx> create(::std::string name, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_create(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    /**
     * Retrieve a topic by name.
     * @param name The name of the topic.
     * @param current The Current object for the invocation.
     * @return A proxy to the topic instance. The returned proxy is never null.
     * @throws IceStorm::NoSuchTopic Raised if the topic does not exist.
     */
    virtual ::std::optional<TopicPrx> retrieve(::std::string name, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_retrieve(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    /**
     * Retrieve all topics managed by this topic manager.
     * @param current The Current object for the invocation.
     * @return A dictionary of string, topic proxy pairs.
     */
    virtual TopicDict retrieveAll(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_retrieveAll(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    /// \cond INTERNAL
    void dispatch(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>) override;
    /// \endcond
};

using TopicManagerPtr = ::std::shared_ptr<TopicManager>;

/**
 * This interface is advertised by the IceStorm service through the Ice object with the identity `IceStorm/Finder'.
 * This allows clients to retrieve the topic manager with just the endpoint information of the IceStorm service.
 */
class ICESTORM_API Finder : public virtual ::Ice::Object
{
public:

    using ProxyType = FinderPrx;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static ::std::string_view ice_staticId() noexcept;

    /**
     * Get the topic manager proxy. The proxy might point to several replicas.
     * @param current The Current object for the invocation.
     * @return The topic manager proxy. The returned proxy is never null.
     */
    virtual ::std::optional<TopicManagerPrx> getTopicManager(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_getTopicManager(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    /// \cond INTERNAL
    void dispatch(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>) override;
    /// \endcond
};

using FinderPtr = ::std::shared_ptr<Finder>;

}

/// \cond STREAM
namespace Ice
{

template<>
struct StreamableTraits<::IceStorm::LinkInfo>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 7;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::IceStorm::LinkInfo, S>
{
    static void read(S* istr, ::IceStorm::LinkInfo& v)
    {
        istr->readAll(v.theTopic, v.name, v.cost);
    }
};

template<typename S>
struct StreamReader<::IceStorm::LinkExists, S>
{
    static void read(S* istr, ::IceStorm::LinkExists& v)
    {
        istr->readAll(v.name);
    }
};

template<typename S>
struct StreamReader<::IceStorm::NoSuchLink, S>
{
    static void read(S* istr, ::IceStorm::NoSuchLink& v)
    {
        istr->readAll(v.name);
    }
};

template<typename S>
struct StreamReader<::IceStorm::InvalidSubscriber, S>
{
    static void read(S* istr, ::IceStorm::InvalidSubscriber& v)
    {
        istr->readAll(v.reason);
    }
};

template<typename S>
struct StreamReader<::IceStorm::BadQoS, S>
{
    static void read(S* istr, ::IceStorm::BadQoS& v)
    {
        istr->readAll(v.reason);
    }
};

template<typename S>
struct StreamReader<::IceStorm::TopicExists, S>
{
    static void read(S* istr, ::IceStorm::TopicExists& v)
    {
        istr->readAll(v.name);
    }
};

template<typename S>
struct StreamReader<::IceStorm::NoSuchTopic, S>
{
    static void read(S* istr, ::IceStorm::NoSuchTopic& v)
    {
        istr->readAll(v.name);
    }
};

}
/// \endcond

#include <IceUtil/PopDisableWarnings.h>
#endif
