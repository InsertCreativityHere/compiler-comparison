//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.8.0-alpha.0
//
// <auto-generated>
//
// Generated from file `IceStorm.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __IceStorm_h__
#define __IceStorm_h__

#include <IceUtil/PushDisableWarnings.h>
#include <Ice/Ice.h>
#include <Ice/Identity.h>
#include <Metrics.h>
#include <IceUtil/UndefSysMacros.h>
#include <IceStorm/Config.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION  != 30850
#       error Ice version mismatch: an exact match is required for beta generated code
#   endif
#endif

#ifndef ICESTORM_API
#   if defined(ICE_STATIC_LIBS)
#       define ICESTORM_API /**/
#   elif defined(ICESTORM_API_EXPORTS)
#       define ICESTORM_API ICE_DECLSPEC_EXPORT
#   else
#       define ICESTORM_API ICE_DECLSPEC_IMPORT
#   endif
#endif

namespace IceStorm
{

class Topic;
class TopicPrx;
class TopicManager;
class TopicManagerPrx;
class Finder;
class FinderPrx;

}

namespace IceStorm
{

/**
 * Information on the topic links.
 * \headerfile IceStorm/IceStorm.h
 */
struct LinkInfo
{
    /**
     * The linked topic.
     */
    ::std::shared_ptr<::IceStorm::TopicPrx> theTopic;
    /**
     * The name of the linked topic.
     */
    ::std::string name;
    /**
     * The cost of traversing this link.
     */
    int cost;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::shared_ptr<::IceStorm::TopicPrx>&, const ::std::string&, const int&> ice_tuple() const
    {
        return std::tie(theTopic, name, cost);
    }
};

/**
 * A sequence of {@link LinkInfo} objects.
 */
using LinkInfoSeq = ::std::vector<LinkInfo>;

/**
 * This dictionary represents quality of service parameters.
 * @see Topic#subscribeAndGetPublisher
 */
using QoS = ::std::map<::std::string, ::std::string>;

/**
 * This exception indicates that an attempt was made to create a link that already exists.
 * \headerfile IceStorm/IceStorm.h
 */
class ICE_CLASS(ICESTORM_API) LinkExists : public ::Ice::UserExceptionHelper<LinkExists, ::Ice::UserException>
{
public:

    ICE_MEMBER(ICESTORM_API) virtual ~LinkExists();

    LinkExists(const LinkExists&) = default;

    LinkExists() = default;

    /**
     * One-shot constructor to initialize all data members.
     * @param name The name of the linked topic.
     */
    LinkExists(const ::std::string& name) :
        name(name)
    {
    }

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&> ice_tuple() const
    {
        return std::tie(name);
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    ICE_MEMBER(ICESTORM_API) static const ::std::string& ice_staticId();

    /**
     * The name of the linked topic.
     */
    ::std::string name;
};

/// \cond INTERNAL
static LinkExists _iceS_LinkExists_init;
/// \endcond

/**
 * This exception indicates that an attempt was made to remove a link that does not exist.
 * \headerfile IceStorm/IceStorm.h
 */
class ICE_CLASS(ICESTORM_API) NoSuchLink : public ::Ice::UserExceptionHelper<NoSuchLink, ::Ice::UserException>
{
public:

    ICE_MEMBER(ICESTORM_API) virtual ~NoSuchLink();

    NoSuchLink(const NoSuchLink&) = default;

    NoSuchLink() = default;

    /**
     * One-shot constructor to initialize all data members.
     * @param name The name of the link that does not exist.
     */
    NoSuchLink(const ::std::string& name) :
        name(name)
    {
    }

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&> ice_tuple() const
    {
        return std::tie(name);
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    ICE_MEMBER(ICESTORM_API) static const ::std::string& ice_staticId();

    /**
     * The name of the link that does not exist.
     */
    ::std::string name;
};

/**
 * This exception indicates that an attempt was made to subscribe a proxy for which a subscription already exists.
 * \headerfile IceStorm/IceStorm.h
 */
class ICE_CLASS(ICESTORM_API) AlreadySubscribed : public ::Ice::UserExceptionHelper<AlreadySubscribed, ::Ice::UserException>
{
public:

    ICE_MEMBER(ICESTORM_API) virtual ~AlreadySubscribed();

    AlreadySubscribed(const AlreadySubscribed&) = default;

    AlreadySubscribed() = default;

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<> ice_tuple() const
    {
        return std::tie();
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    ICE_MEMBER(ICESTORM_API) static const ::std::string& ice_staticId();
};

/**
 * This exception indicates that an attempt was made to subscribe a proxy that is null.
 * \headerfile IceStorm/IceStorm.h
 */
class ICE_CLASS(ICESTORM_API) InvalidSubscriber : public ::Ice::UserExceptionHelper<InvalidSubscriber, ::Ice::UserException>
{
public:

    ICE_MEMBER(ICESTORM_API) virtual ~InvalidSubscriber();

    InvalidSubscriber(const InvalidSubscriber&) = default;

    InvalidSubscriber() = default;

    /**
     * One-shot constructor to initialize all data members.
     * @param reason The reason for the failure.
     */
    InvalidSubscriber(const ::std::string& reason) :
        reason(reason)
    {
    }

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&> ice_tuple() const
    {
        return std::tie(reason);
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    ICE_MEMBER(ICESTORM_API) static const ::std::string& ice_staticId();

    /**
     * The reason for the failure.
     */
    ::std::string reason;
};

/**
 * This exception indicates that a subscription failed due to an invalid QoS.
 * \headerfile IceStorm/IceStorm.h
 */
class ICE_CLASS(ICESTORM_API) BadQoS : public ::Ice::UserExceptionHelper<BadQoS, ::Ice::UserException>
{
public:

    ICE_MEMBER(ICESTORM_API) virtual ~BadQoS();

    BadQoS(const BadQoS&) = default;

    BadQoS() = default;

    /**
     * One-shot constructor to initialize all data members.
     * @param reason The reason for the failure.
     */
    BadQoS(const ::std::string& reason) :
        reason(reason)
    {
    }

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&> ice_tuple() const
    {
        return std::tie(reason);
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    ICE_MEMBER(ICESTORM_API) static const ::std::string& ice_staticId();

    /**
     * The reason for the failure.
     */
    ::std::string reason;
};

/**
 * Mapping of topic name to topic proxy.
 */
using TopicDict = ::std::map<::std::string, ::std::shared_ptr<TopicPrx>>;

/**
 * This exception indicates that an attempt was made to create a topic that already exists.
 * \headerfile IceStorm/IceStorm.h
 */
class ICE_CLASS(ICESTORM_API) TopicExists : public ::Ice::UserExceptionHelper<TopicExists, ::Ice::UserException>
{
public:

    ICE_MEMBER(ICESTORM_API) virtual ~TopicExists();

    TopicExists(const TopicExists&) = default;

    TopicExists() = default;

    /**
     * One-shot constructor to initialize all data members.
     * @param name The name of the topic that already exists.
     */
    TopicExists(const ::std::string& name) :
        name(name)
    {
    }

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&> ice_tuple() const
    {
        return std::tie(name);
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    ICE_MEMBER(ICESTORM_API) static const ::std::string& ice_staticId();

    /**
     * The name of the topic that already exists.
     */
    ::std::string name;
};

/**
 * This exception indicates that an attempt was made to retrieve a topic that does not exist.
 * \headerfile IceStorm/IceStorm.h
 */
class ICE_CLASS(ICESTORM_API) NoSuchTopic : public ::Ice::UserExceptionHelper<NoSuchTopic, ::Ice::UserException>
{
public:

    ICE_MEMBER(ICESTORM_API) virtual ~NoSuchTopic();

    NoSuchTopic(const NoSuchTopic&) = default;

    NoSuchTopic() = default;

    /**
     * One-shot constructor to initialize all data members.
     * @param name The name of the topic that does not exist.
     */
    NoSuchTopic(const ::std::string& name) :
        name(name)
    {
    }

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&> ice_tuple() const
    {
        return std::tie(name);
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    ICE_MEMBER(ICESTORM_API) static const ::std::string& ice_staticId();

    /**
     * The name of the topic that does not exist.
     */
    ::std::string name;
};

using Ice::operator<;
using Ice::operator<=;
using Ice::operator>;
using Ice::operator>=;
using Ice::operator==;
using Ice::operator!=;

}

namespace IceStorm
{

/**
 * Publishers publish information on a particular topic. A topic logically represents a type. A
 * @see TopicManager
 */
class ICESTORM_API Topic : public virtual ::Ice::Object
{
public:

    using ProxyType = TopicPrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /**
     * Get the name of this topic.
     * @param current The Current object for the invocation.
     * @return The name of the topic.
     * @see TopicManager#create
     */
    virtual ::std::string getName(const ::Ice::Current& current) const = 0;
    /// \cond INTERNAL
    bool _iceD_getName(::IceInternal::Incoming&, const ::Ice::Current&) const;
    /// \endcond

    /**
     * Get a proxy to a publisher object for this topic. To publish data to a topic, the publisher calls getPublisher
     * and then casts to the topic type. An unchecked cast must be used on this proxy. If a replicated IceStorm
     * deployment is used this call may return a replicated proxy.
     * @param current The Current object for the invocation.
     * @return A proxy to publish data on this topic.
     */
    virtual ::std::shared_ptr<::Ice::ObjectPrx> getPublisher(const ::Ice::Current& current) const = 0;
    /// \cond INTERNAL
    bool _iceD_getPublisher(::IceInternal::Incoming&, const ::Ice::Current&) const;
    /// \endcond

    /**
     * Get a non-replicated proxy to a publisher object for this topic. To publish data to a topic, the publisher
     * calls getPublisher and then casts to the topic type. An unchecked cast must be used on this proxy.
     * @param current The Current object for the invocation.
     * @return A proxy to publish data on this topic.
     */
    virtual ::std::shared_ptr<::Ice::ObjectPrx> getNonReplicatedPublisher(const ::Ice::Current& current) const = 0;
    /// \cond INTERNAL
    bool _iceD_getNonReplicatedPublisher(::IceInternal::Incoming&, const ::Ice::Current&) const;
    /// \endcond

    /**
     * Subscribe with the given <code>qos</code> to this topic.  A per-subscriber publisher object is returned.
     * @param theQoS The quality of service parameters for this subscription.
     * @param subscriber The subscriber's proxy.
     * @param current The Current object for the invocation.
     * @return The per-subscriber publisher object.
     * @throws IceStorm::AlreadySubscribed Raised if the subscriber object is already subscribed.
     * @throws IceStorm::BadQoS Raised if the requested quality of service is unavailable or invalid.
     * @throws IceStorm::InvalidSubscriber Raised if the subscriber object is null.
     * @see #unsubscribe
     */
    virtual ::std::shared_ptr<::Ice::ObjectPrx> subscribeAndGetPublisher(QoS theQoS, ::std::shared_ptr<::Ice::ObjectPrx> subscriber, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_subscribeAndGetPublisher(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Unsubscribe the given <code>subscriber</code>.
     * @param subscriber The proxy of an existing subscriber.
     * @param current The Current object for the invocation.
     * @see #subscribeAndGetPublisher
     */
    virtual void unsubscribe(::std::shared_ptr<::Ice::ObjectPrx> subscriber, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_unsubscribe(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Create a link to the given topic. All events originating on this topic will also be sent to
     * <code>linkTo</code>.
     * @param linkTo The topic to link to.
     * @param cost The cost to the linked topic.
     * @param current The Current object for the invocation.
     * @throws IceStorm::LinkExists Raised if a link to the same topic already exists.
     */
    virtual void link(::std::shared_ptr<TopicPrx> linkTo, int cost, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_link(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Destroy the link from this topic to the given topic <code>linkTo</code>.
     * @param linkTo The topic to destroy the link to.
     * @param current The Current object for the invocation.
     * @throws IceStorm::NoSuchLink Raised if a link to the topic does not exist.
     */
    virtual void unlink(::std::shared_ptr<TopicPrx> linkTo, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_unlink(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Retrieve information on the current links.
     * @param current The Current object for the invocation.
     * @return A sequence of LinkInfo objects.
     */
    virtual LinkInfoSeq getLinkInfoSeq(const ::Ice::Current& current) const = 0;
    /// \cond INTERNAL
    bool _iceD_getLinkInfoSeq(::IceInternal::Incoming&, const ::Ice::Current&) const;
    /// \endcond

    /**
     * Retrieve the list of subscribers for this topic.
     * @param current The Current object for the invocation.
     * @return The sequence of Ice identities for the subscriber objects.
     */
    virtual ::Ice::IdentitySeq getSubscribers(const ::Ice::Current& current) const = 0;
    /// \cond INTERNAL
    bool _iceD_getSubscribers(::IceInternal::Incoming&, const ::Ice::Current&) const;
    /// \endcond

    /**
     * Destroy the topic.
     * @param current The Current object for the invocation.
     */
    virtual void destroy(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_destroy(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

/**
 * A topic manager manages topics, and subscribers to topics.
 * @see Topic
 */
class ICESTORM_API TopicManager : public virtual ::Ice::Object
{
public:

    using ProxyType = TopicManagerPrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /**
     * Create a new topic. The topic name must be unique.
     * @param name The name of the topic.
     * @param current The Current object for the invocation.
     * @return A proxy to the topic instance.
     * @throws IceStorm::TopicExists Raised if a topic with the same name already exists.
     */
    virtual ::std::shared_ptr<TopicPrx> create(::std::string name, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_create(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Retrieve a topic by name.
     * @param name The name of the topic.
     * @param current The Current object for the invocation.
     * @return A proxy to the topic instance.
     * @throws IceStorm::NoSuchTopic Raised if the topic does not exist.
     */
    virtual ::std::shared_ptr<TopicPrx> retrieve(::std::string name, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_retrieve(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Retrieve all topics managed by this topic manager.
     * @param current The Current object for the invocation.
     * @return A dictionary of string, topic proxy pairs.
     */
    virtual TopicDict retrieveAll(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_retrieveAll(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

/**
 * This interface is advertised by the IceStorm service through the Ice object with the identity `IceStorm/Finder'.
 * This allows clients to retrieve the topic manager with just the endpoint information of the IceStorm service.
 */
class ICESTORM_API Finder : public virtual ::Ice::Object
{
public:

    using ProxyType = FinderPrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /**
     * Get the topic manager proxy. The proxy might point to several replicas.
     * @param current The Current object for the invocation.
     * @return The topic manager proxy.
     */
    virtual ::std::shared_ptr<TopicManagerPrx> getTopicManager(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getTopicManager(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

}

namespace IceStorm
{

/**
 * Publishers publish information on a particular topic. A topic logically represents a type. A
 * @see TopicManager
 */
class ICE_CLASS(ICESTORM_API) TopicPrx : public virtual ::Ice::Proxy<TopicPrx, ::Ice::ObjectPrx>
{
public:

    /**
     * Get the name of this topic.
     * @param context The Context map to send with the invocation.
     * @return The name of the topic.
     * @see TopicManager#create
     */
    ::std::string getName(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::std::string>(true, this, &TopicPrx::_iceI_getName, context).get();
    }

    /**
     * Get the name of this topic.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     * @see TopicManager#create
     */
    template<template<typename> class P = ::std::promise>
    auto getNameAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::string>>().get_future())
    {
        return _makePromiseOutgoing<::std::string, P>(false, this, &TopicPrx::_iceI_getName, context);
    }

    /**
     * Get the name of this topic.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     * @see TopicManager#create
     */
    ::std::function<void()>
    getNameAsync(::std::function<void(::std::string)> response,
                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                 ::std::function<void(bool)> sent = nullptr,
                 const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<::std::string>(std::move(response), std::move(ex), std::move(sent), this, &IceStorm::TopicPrx::_iceI_getName, context);
    }

    /// \cond INTERNAL
    ICE_MEMBER(ICESTORM_API) void _iceI_getName(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::string>>&, const ::Ice::Context&);
    /// \endcond

    /**
     * Get a proxy to a publisher object for this topic. To publish data to a topic, the publisher calls getPublisher
     * and then casts to the topic type. An unchecked cast must be used on this proxy. If a replicated IceStorm
     * deployment is used this call may return a replicated proxy.
     * @param context The Context map to send with the invocation.
     * @return A proxy to publish data on this topic.
     */
    ::std::shared_ptr<::Ice::ObjectPrx> getPublisher(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Ice::ObjectPrx>>(true, this, &TopicPrx::_iceI_getPublisher, context).get();
    }

    /**
     * Get a proxy to a publisher object for this topic. To publish data to a topic, the publisher calls getPublisher
     * and then casts to the topic type. An unchecked cast must be used on this proxy. If a replicated IceStorm
     * deployment is used this call may return a replicated proxy.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    template<template<typename> class P = ::std::promise>
    auto getPublisherAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::shared_ptr<::Ice::ObjectPrx>>>().get_future())
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Ice::ObjectPrx>, P>(false, this, &TopicPrx::_iceI_getPublisher, context);
    }

    /**
     * Get a proxy to a publisher object for this topic. To publish data to a topic, the publisher calls getPublisher
     * and then casts to the topic type. An unchecked cast must be used on this proxy. If a replicated IceStorm
     * deployment is used this call may return a replicated proxy.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    getPublisherAsync(::std::function<void(::std::shared_ptr<::Ice::ObjectPrx>)> response,
                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                      ::std::function<void(bool)> sent = nullptr,
                      const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<::std::shared_ptr<::Ice::ObjectPrx>>(std::move(response), std::move(ex), std::move(sent), this, &IceStorm::TopicPrx::_iceI_getPublisher, context);
    }

    /// \cond INTERNAL
    ICE_MEMBER(ICESTORM_API) void _iceI_getPublisher(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Ice::ObjectPrx>>>&, const ::Ice::Context&);
    /// \endcond

    /**
     * Get a non-replicated proxy to a publisher object for this topic. To publish data to a topic, the publisher
     * calls getPublisher and then casts to the topic type. An unchecked cast must be used on this proxy.
     * @param context The Context map to send with the invocation.
     * @return A proxy to publish data on this topic.
     */
    ::std::shared_ptr<::Ice::ObjectPrx> getNonReplicatedPublisher(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Ice::ObjectPrx>>(true, this, &TopicPrx::_iceI_getNonReplicatedPublisher, context).get();
    }

    /**
     * Get a non-replicated proxy to a publisher object for this topic. To publish data to a topic, the publisher
     * calls getPublisher and then casts to the topic type. An unchecked cast must be used on this proxy.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    template<template<typename> class P = ::std::promise>
    auto getNonReplicatedPublisherAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::shared_ptr<::Ice::ObjectPrx>>>().get_future())
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Ice::ObjectPrx>, P>(false, this, &TopicPrx::_iceI_getNonReplicatedPublisher, context);
    }

    /**
     * Get a non-replicated proxy to a publisher object for this topic. To publish data to a topic, the publisher
     * calls getPublisher and then casts to the topic type. An unchecked cast must be used on this proxy.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    getNonReplicatedPublisherAsync(::std::function<void(::std::shared_ptr<::Ice::ObjectPrx>)> response,
                                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                                   ::std::function<void(bool)> sent = nullptr,
                                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<::std::shared_ptr<::Ice::ObjectPrx>>(std::move(response), std::move(ex), std::move(sent), this, &IceStorm::TopicPrx::_iceI_getNonReplicatedPublisher, context);
    }

    /// \cond INTERNAL
    ICE_MEMBER(ICESTORM_API) void _iceI_getNonReplicatedPublisher(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Ice::ObjectPrx>>>&, const ::Ice::Context&);
    /// \endcond

    /**
     * Subscribe with the given <code>qos</code> to this topic.  A per-subscriber publisher object is returned.
     * @param theQoS The quality of service parameters for this subscription.
     * @param subscriber The subscriber's proxy.
     * @param context The Context map to send with the invocation.
     * @return The per-subscriber publisher object.
     * @throws IceStorm::AlreadySubscribed Raised if the subscriber object is already subscribed.
     * @throws IceStorm::BadQoS Raised if the requested quality of service is unavailable or invalid.
     * @throws IceStorm::InvalidSubscriber Raised if the subscriber object is null.
     * @see #unsubscribe
     */
    ::std::shared_ptr<::Ice::ObjectPrx> subscribeAndGetPublisher(const QoS& theQoS, const ::std::shared_ptr<::Ice::ObjectPrx>& subscriber, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Ice::ObjectPrx>>(true, this, &TopicPrx::_iceI_subscribeAndGetPublisher, theQoS, subscriber, context).get();
    }

    /**
     * Subscribe with the given <code>qos</code> to this topic.  A per-subscriber publisher object is returned.
     * @param theQoS The quality of service parameters for this subscription.
     * @param subscriber The subscriber's proxy.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     * @see #unsubscribe
     */
    template<template<typename> class P = ::std::promise>
    auto subscribeAndGetPublisherAsync(const QoS& theQoS, const ::std::shared_ptr<::Ice::ObjectPrx>& subscriber, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::shared_ptr<::Ice::ObjectPrx>>>().get_future())
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Ice::ObjectPrx>, P>(false, this, &TopicPrx::_iceI_subscribeAndGetPublisher, theQoS, subscriber, context);
    }

    /**
     * Subscribe with the given <code>qos</code> to this topic.  A per-subscriber publisher object is returned.
     * @param theQoS The quality of service parameters for this subscription.
     * @param subscriber The subscriber's proxy.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     * @see #unsubscribe
     */
    ::std::function<void()>
    subscribeAndGetPublisherAsync(const QoS& theQoS, const ::std::shared_ptr<::Ice::ObjectPrx>& subscriber,
                                  ::std::function<void(::std::shared_ptr<::Ice::ObjectPrx>)> response,
                                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                                  ::std::function<void(bool)> sent = nullptr,
                                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<::std::shared_ptr<::Ice::ObjectPrx>>(std::move(response), std::move(ex), std::move(sent), this, &IceStorm::TopicPrx::_iceI_subscribeAndGetPublisher, theQoS, subscriber, context);
    }

    /// \cond INTERNAL
    ICE_MEMBER(ICESTORM_API) void _iceI_subscribeAndGetPublisher(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Ice::ObjectPrx>>>&, const QoS&, const ::std::shared_ptr<::Ice::ObjectPrx>&, const ::Ice::Context&);
    /// \endcond

    /**
     * Unsubscribe the given <code>subscriber</code>.
     * @param subscriber The proxy of an existing subscriber.
     * @param context The Context map to send with the invocation.
     * @see #subscribeAndGetPublisher
     */
    void unsubscribe(const ::std::shared_ptr<::Ice::ObjectPrx>& subscriber, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &TopicPrx::_iceI_unsubscribe, subscriber, context).get();
    }

    /**
     * Unsubscribe the given <code>subscriber</code>.
     * @param subscriber The proxy of an existing subscriber.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     * @see #subscribeAndGetPublisher
     */
    template<template<typename> class P = ::std::promise>
    auto unsubscribeAsync(const ::std::shared_ptr<::Ice::ObjectPrx>& subscriber, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &TopicPrx::_iceI_unsubscribe, subscriber, context);
    }

    /**
     * Unsubscribe the given <code>subscriber</code>.
     * @param subscriber The proxy of an existing subscriber.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     * @see #subscribeAndGetPublisher
     */
    ::std::function<void()>
    unsubscribeAsync(const ::std::shared_ptr<::Ice::ObjectPrx>& subscriber,
                     ::std::function<void()> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceStorm::TopicPrx::_iceI_unsubscribe, subscriber, context);
    }

    /// \cond INTERNAL
    ICE_MEMBER(ICESTORM_API) void _iceI_unsubscribe(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::shared_ptr<::Ice::ObjectPrx>&, const ::Ice::Context&);
    /// \endcond

    /**
     * Create a link to the given topic. All events originating on this topic will also be sent to
     * <code>linkTo</code>.
     * @param linkTo The topic to link to.
     * @param cost The cost to the linked topic.
     * @param context The Context map to send with the invocation.
     * @throws IceStorm::LinkExists Raised if a link to the same topic already exists.
     */
    void link(const ::std::shared_ptr<TopicPrx>& linkTo, int cost, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &TopicPrx::_iceI_link, linkTo, cost, context).get();
    }

    /**
     * Create a link to the given topic. All events originating on this topic will also be sent to
     * <code>linkTo</code>.
     * @param linkTo The topic to link to.
     * @param cost The cost to the linked topic.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    template<template<typename> class P = ::std::promise>
    auto linkAsync(const ::std::shared_ptr<TopicPrx>& linkTo, int cost, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &TopicPrx::_iceI_link, linkTo, cost, context);
    }

    /**
     * Create a link to the given topic. All events originating on this topic will also be sent to
     * <code>linkTo</code>.
     * @param linkTo The topic to link to.
     * @param cost The cost to the linked topic.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    linkAsync(const ::std::shared_ptr<TopicPrx>& linkTo, int cost,
              ::std::function<void()> response,
              ::std::function<void(::std::exception_ptr)> ex = nullptr,
              ::std::function<void(bool)> sent = nullptr,
              const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceStorm::TopicPrx::_iceI_link, linkTo, cost, context);
    }

    /// \cond INTERNAL
    ICE_MEMBER(ICESTORM_API) void _iceI_link(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::shared_ptr<TopicPrx>&, int, const ::Ice::Context&);
    /// \endcond

    /**
     * Destroy the link from this topic to the given topic <code>linkTo</code>.
     * @param linkTo The topic to destroy the link to.
     * @param context The Context map to send with the invocation.
     * @throws IceStorm::NoSuchLink Raised if a link to the topic does not exist.
     */
    void unlink(const ::std::shared_ptr<TopicPrx>& linkTo, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &TopicPrx::_iceI_unlink, linkTo, context).get();
    }

    /**
     * Destroy the link from this topic to the given topic <code>linkTo</code>.
     * @param linkTo The topic to destroy the link to.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    template<template<typename> class P = ::std::promise>
    auto unlinkAsync(const ::std::shared_ptr<TopicPrx>& linkTo, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &TopicPrx::_iceI_unlink, linkTo, context);
    }

    /**
     * Destroy the link from this topic to the given topic <code>linkTo</code>.
     * @param linkTo The topic to destroy the link to.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    unlinkAsync(const ::std::shared_ptr<TopicPrx>& linkTo,
                ::std::function<void()> response,
                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                ::std::function<void(bool)> sent = nullptr,
                const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceStorm::TopicPrx::_iceI_unlink, linkTo, context);
    }

    /// \cond INTERNAL
    ICE_MEMBER(ICESTORM_API) void _iceI_unlink(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::shared_ptr<TopicPrx>&, const ::Ice::Context&);
    /// \endcond

    /**
     * Retrieve information on the current links.
     * @param context The Context map to send with the invocation.
     * @return A sequence of LinkInfo objects.
     */
    LinkInfoSeq getLinkInfoSeq(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::IceStorm::LinkInfoSeq>(true, this, &TopicPrx::_iceI_getLinkInfoSeq, context).get();
    }

    /**
     * Retrieve information on the current links.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    template<template<typename> class P = ::std::promise>
    auto getLinkInfoSeqAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::IceStorm::LinkInfoSeq>>().get_future())
    {
        return _makePromiseOutgoing<::IceStorm::LinkInfoSeq, P>(false, this, &TopicPrx::_iceI_getLinkInfoSeq, context);
    }

    /**
     * Retrieve information on the current links.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    getLinkInfoSeqAsync(::std::function<void(::IceStorm::LinkInfoSeq)> response,
                        ::std::function<void(::std::exception_ptr)> ex = nullptr,
                        ::std::function<void(bool)> sent = nullptr,
                        const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<::IceStorm::LinkInfoSeq>(std::move(response), std::move(ex), std::move(sent), this, &IceStorm::TopicPrx::_iceI_getLinkInfoSeq, context);
    }

    /// \cond INTERNAL
    ICE_MEMBER(ICESTORM_API) void _iceI_getLinkInfoSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::IceStorm::LinkInfoSeq>>&, const ::Ice::Context&);
    /// \endcond

    /**
     * Retrieve the list of subscribers for this topic.
     * @param context The Context map to send with the invocation.
     * @return The sequence of Ice identities for the subscriber objects.
     */
    ::Ice::IdentitySeq getSubscribers(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::Ice::IdentitySeq>(true, this, &TopicPrx::_iceI_getSubscribers, context).get();
    }

    /**
     * Retrieve the list of subscribers for this topic.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    template<template<typename> class P = ::std::promise>
    auto getSubscribersAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::Ice::IdentitySeq>>().get_future())
    {
        return _makePromiseOutgoing<::Ice::IdentitySeq, P>(false, this, &TopicPrx::_iceI_getSubscribers, context);
    }

    /**
     * Retrieve the list of subscribers for this topic.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    getSubscribersAsync(::std::function<void(::Ice::IdentitySeq)> response,
                        ::std::function<void(::std::exception_ptr)> ex = nullptr,
                        ::std::function<void(bool)> sent = nullptr,
                        const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<::Ice::IdentitySeq>(std::move(response), std::move(ex), std::move(sent), this, &IceStorm::TopicPrx::_iceI_getSubscribers, context);
    }

    /// \cond INTERNAL
    ICE_MEMBER(ICESTORM_API) void _iceI_getSubscribers(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::Ice::IdentitySeq>>&, const ::Ice::Context&);
    /// \endcond

    /**
     * Destroy the topic.
     * @param context The Context map to send with the invocation.
     */
    void destroy(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &TopicPrx::_iceI_destroy, context).get();
    }

    /**
     * Destroy the topic.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    template<template<typename> class P = ::std::promise>
    auto destroyAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &TopicPrx::_iceI_destroy, context);
    }

    /**
     * Destroy the topic.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    destroyAsync(::std::function<void()> response,
                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                 ::std::function<void(bool)> sent = nullptr,
                 const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &IceStorm::TopicPrx::_iceI_destroy, context);
    }

    /// \cond INTERNAL
    ICE_MEMBER(ICESTORM_API) void _iceI_destroy(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    ICE_MEMBER(ICESTORM_API) static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    TopicPrx() = default;
    friend ::std::shared_ptr<TopicPrx> IceInternal::createProxy<TopicPrx>();

    ICE_MEMBER(ICESTORM_API) virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

/**
 * A topic manager manages topics, and subscribers to topics.
 * @see Topic
 */
class ICE_CLASS(ICESTORM_API) TopicManagerPrx : public virtual ::Ice::Proxy<TopicManagerPrx, ::Ice::ObjectPrx>
{
public:

    /**
     * Create a new topic. The topic name must be unique.
     * @param name The name of the topic.
     * @param context The Context map to send with the invocation.
     * @return A proxy to the topic instance.
     * @throws IceStorm::TopicExists Raised if a topic with the same name already exists.
     */
    ::std::shared_ptr<TopicPrx> create(const ::std::string& name, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::std::shared_ptr<::IceStorm::TopicPrx>>(true, this, &TopicManagerPrx::_iceI_create, name, context).get();
    }

    /**
     * Create a new topic. The topic name must be unique.
     * @param name The name of the topic.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    template<template<typename> class P = ::std::promise>
    auto createAsync(const ::std::string& name, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::shared_ptr<::IceStorm::TopicPrx>>>().get_future())
    {
        return _makePromiseOutgoing<::std::shared_ptr<::IceStorm::TopicPrx>, P>(false, this, &TopicManagerPrx::_iceI_create, name, context);
    }

    /**
     * Create a new topic. The topic name must be unique.
     * @param name The name of the topic.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    createAsync(const ::std::string& name,
                ::std::function<void(::std::shared_ptr<::IceStorm::TopicPrx>)> response,
                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                ::std::function<void(bool)> sent = nullptr,
                const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<::std::shared_ptr<::IceStorm::TopicPrx>>(std::move(response), std::move(ex), std::move(sent), this, &IceStorm::TopicManagerPrx::_iceI_create, name, context);
    }

    /// \cond INTERNAL
    ICE_MEMBER(ICESTORM_API) void _iceI_create(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::IceStorm::TopicPrx>>>&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    /**
     * Retrieve a topic by name.
     * @param name The name of the topic.
     * @param context The Context map to send with the invocation.
     * @return A proxy to the topic instance.
     * @throws IceStorm::NoSuchTopic Raised if the topic does not exist.
     */
    ::std::shared_ptr<TopicPrx> retrieve(const ::std::string& name, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::std::shared_ptr<::IceStorm::TopicPrx>>(true, this, &TopicManagerPrx::_iceI_retrieve, name, context).get();
    }

    /**
     * Retrieve a topic by name.
     * @param name The name of the topic.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    template<template<typename> class P = ::std::promise>
    auto retrieveAsync(const ::std::string& name, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::shared_ptr<::IceStorm::TopicPrx>>>().get_future())
    {
        return _makePromiseOutgoing<::std::shared_ptr<::IceStorm::TopicPrx>, P>(false, this, &TopicManagerPrx::_iceI_retrieve, name, context);
    }

    /**
     * Retrieve a topic by name.
     * @param name The name of the topic.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    retrieveAsync(const ::std::string& name,
                  ::std::function<void(::std::shared_ptr<::IceStorm::TopicPrx>)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<::std::shared_ptr<::IceStorm::TopicPrx>>(std::move(response), std::move(ex), std::move(sent), this, &IceStorm::TopicManagerPrx::_iceI_retrieve, name, context);
    }

    /// \cond INTERNAL
    ICE_MEMBER(ICESTORM_API) void _iceI_retrieve(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::IceStorm::TopicPrx>>>&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    /**
     * Retrieve all topics managed by this topic manager.
     * @param context The Context map to send with the invocation.
     * @return A dictionary of string, topic proxy pairs.
     */
    TopicDict retrieveAll(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::IceStorm::TopicDict>(true, this, &TopicManagerPrx::_iceI_retrieveAll, context).get();
    }

    /**
     * Retrieve all topics managed by this topic manager.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    template<template<typename> class P = ::std::promise>
    auto retrieveAllAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::IceStorm::TopicDict>>().get_future())
    {
        return _makePromiseOutgoing<::IceStorm::TopicDict, P>(false, this, &TopicManagerPrx::_iceI_retrieveAll, context);
    }

    /**
     * Retrieve all topics managed by this topic manager.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    retrieveAllAsync(::std::function<void(::IceStorm::TopicDict)> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<::IceStorm::TopicDict>(std::move(response), std::move(ex), std::move(sent), this, &IceStorm::TopicManagerPrx::_iceI_retrieveAll, context);
    }

    /// \cond INTERNAL
    ICE_MEMBER(ICESTORM_API) void _iceI_retrieveAll(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::IceStorm::TopicDict>>&, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    ICE_MEMBER(ICESTORM_API) static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    TopicManagerPrx() = default;
    friend ::std::shared_ptr<TopicManagerPrx> IceInternal::createProxy<TopicManagerPrx>();

    ICE_MEMBER(ICESTORM_API) virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

/**
 * This interface is advertised by the IceStorm service through the Ice object with the identity `IceStorm/Finder'.
 * This allows clients to retrieve the topic manager with just the endpoint information of the IceStorm service.
 */
class ICE_CLASS(ICESTORM_API) FinderPrx : public virtual ::Ice::Proxy<FinderPrx, ::Ice::ObjectPrx>
{
public:

    /**
     * Get the topic manager proxy. The proxy might point to several replicas.
     * @param context The Context map to send with the invocation.
     * @return The topic manager proxy.
     */
    ::std::shared_ptr<TopicManagerPrx> getTopicManager(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::std::shared_ptr<::IceStorm::TopicManagerPrx>>(true, this, &FinderPrx::_iceI_getTopicManager, context).get();
    }

    /**
     * Get the topic manager proxy. The proxy might point to several replicas.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    template<template<typename> class P = ::std::promise>
    auto getTopicManagerAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::shared_ptr<::IceStorm::TopicManagerPrx>>>().get_future())
    {
        return _makePromiseOutgoing<::std::shared_ptr<::IceStorm::TopicManagerPrx>, P>(false, this, &FinderPrx::_iceI_getTopicManager, context);
    }

    /**
     * Get the topic manager proxy. The proxy might point to several replicas.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    getTopicManagerAsync(::std::function<void(::std::shared_ptr<::IceStorm::TopicManagerPrx>)> response,
                         ::std::function<void(::std::exception_ptr)> ex = nullptr,
                         ::std::function<void(bool)> sent = nullptr,
                         const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<::std::shared_ptr<::IceStorm::TopicManagerPrx>>(std::move(response), std::move(ex), std::move(sent), this, &IceStorm::FinderPrx::_iceI_getTopicManager, context);
    }

    /// \cond INTERNAL
    ICE_MEMBER(ICESTORM_API) void _iceI_getTopicManager(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::IceStorm::TopicManagerPrx>>>&, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    ICE_MEMBER(ICESTORM_API) static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    FinderPrx() = default;
    friend ::std::shared_ptr<FinderPrx> IceInternal::createProxy<FinderPrx>();

    ICE_MEMBER(ICESTORM_API) virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

}

/// \cond STREAM
namespace Ice
{

template<>
struct StreamableTraits<::IceStorm::LinkInfo>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 7;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::IceStorm::LinkInfo, S>
{
    static void read(S* istr, ::IceStorm::LinkInfo& v)
    {
        istr->readAll(v.theTopic, v.name, v.cost);
    }
};

template<typename S>
struct StreamReader<::IceStorm::LinkExists, S>
{
    static void read(S* istr, ::IceStorm::LinkExists& v)
    {
        istr->readAll(v.name);
    }
};

template<typename S>
struct StreamReader<::IceStorm::NoSuchLink, S>
{
    static void read(S* istr, ::IceStorm::NoSuchLink& v)
    {
        istr->readAll(v.name);
    }
};

template<typename S>
struct StreamReader<::IceStorm::InvalidSubscriber, S>
{
    static void read(S* istr, ::IceStorm::InvalidSubscriber& v)
    {
        istr->readAll(v.reason);
    }
};

template<typename S>
struct StreamReader<::IceStorm::BadQoS, S>
{
    static void read(S* istr, ::IceStorm::BadQoS& v)
    {
        istr->readAll(v.reason);
    }
};

template<typename S>
struct StreamReader<::IceStorm::TopicExists, S>
{
    static void read(S* istr, ::IceStorm::TopicExists& v)
    {
        istr->readAll(v.name);
    }
};

template<typename S>
struct StreamReader<::IceStorm::NoSuchTopic, S>
{
    static void read(S* istr, ::IceStorm::NoSuchTopic& v)
    {
        istr->readAll(v.name);
    }
};

}
/// \endcond

/// \cond INTERNAL
namespace IceStorm
{

using TopicPtr = ::std::shared_ptr<Topic>;
using TopicPrxPtr = ::std::shared_ptr<TopicPrx>;

using TopicManagerPtr = ::std::shared_ptr<TopicManager>;
using TopicManagerPrxPtr = ::std::shared_ptr<TopicManagerPrx>;

using FinderPtr = ::std::shared_ptr<Finder>;
using FinderPrxPtr = ::std::shared_ptr<FinderPrx>;

}
/// \endcond

#include <IceUtil/PopDisableWarnings.h>
#endif
