//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.7.10
//
// <auto-generated>
//
// Generated from file `Inherit.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __Inherit_h__
#define __Inherit_h__

#include <IceUtil/PushDisableWarnings.h>
#include <Ice/Ice.h>
#include <IceUtil/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 307
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 >= 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 10
#       error Ice patch level mismatch!
#   endif
#endif

#ifdef ICE_CPP11_MAPPING // C++11 mapping

namespace Test
{

class Class1;
class Intf1;
class Intf1Prx;
class Intf2;
class Intf2Prx;

}

namespace Test
{

struct Struct1
{
    int isa;
    int retainCount;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const int&, const int&> ice_tuple() const
    {
        return std::tie(isa, retainCount);
    }
};

class Exception1 : public ::Ice::UserExceptionHelper<Exception1, ::Ice::UserException>
{
public:

    virtual ~Exception1();

    Exception1(const Exception1&) = default;

    Exception1() = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    Exception1(int isa, int reason, int raise, int name, int callStackReturnAddresses, int userInfo, int reserved) :
        isa(isa),
        reason(reason),
        raise(raise),
        name(name),
        callStackReturnAddresses(callStackReturnAddresses),
        userInfo(userInfo),
        reserved(reserved)
    {
    }

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const int&, const int&, const int&, const int&, const int&, const int&, const int&> ice_tuple() const
    {
        return std::tie(isa, reason, raise, name, callStackReturnAddresses, userInfo, reserved);
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    int isa;
    int reason;
    int raise;
    int name;
    int callStackReturnAddresses;
    int userInfo;
    int reserved;
};

/// \cond INTERNAL
static Exception1 _iceS_Exception1_init;
/// \endcond

using Ice::operator<;
using Ice::operator<=;
using Ice::operator>;
using Ice::operator>=;
using Ice::operator==;
using Ice::operator!=;

}

namespace Test
{

class Intf1 : public virtual ::Ice::Object
{
public:

    using ProxyType = Intf1Prx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void isa(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_isa(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void reason(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_reason(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void autorelease(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_autorelease(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void classForCoder(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_classForCoder(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void copy(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_copy(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void dealloc(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_dealloc(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void description(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_description(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void hash(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_hash(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void init(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_init(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void isProxy(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_isProxy(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void mutableCopy(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_mutableCopy(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void release(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_release(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void retain(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_retain(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void retainCount(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_retainCount(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void self(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_self(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void superclass(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_superclass(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void zone(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_zone(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

class Intf2 : public virtual ::Ice::Object
{
public:

    using ProxyType = Intf2Prx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void isa(int a, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_isa(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void reason(int a, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_reason(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void autorelease(int a, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_autorelease(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void classForCoder(int a, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_classForCoder(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void copy(int a, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_copy(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void dealloc(int a, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_dealloc(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void description(int a, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_description(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void hash(int a, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_hash(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void init(int a, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_init(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void isProxy(int a, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_isProxy(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void mutableCopy(int a, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_mutableCopy(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void release(int a, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_release(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void retain(int a, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_retain(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void retainCount(int a, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_retainCount(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void self(int a, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_self(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void superclass(int a, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_superclass(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void zone(int a, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_zone(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

}

namespace Test
{

class Class1 : public ::Ice::ValueHelper<Class1, ::Ice::Value>
{
public:

    virtual ~Class1();

    Class1() = default;

    Class1(const Class1&) = default;
    Class1(Class1&&) = default;
    Class1& operator=(const Class1&) = default;
    Class1& operator=(Class1&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    Class1(int reason, int isa, int autorelease, int classForCoder, int copy, int dealloc, int description, int hash, int init, int isProxy, int mutableCopy, int release, int retain, int retainCount, int self, int superclass, int zone) :
        reason(reason),
        isa(isa),
        autorelease(autorelease),
        classForCoder(classForCoder),
        copy(copy),
        dealloc(dealloc),
        description(description),
        hash(hash),
        init(init),
        isProxy(isProxy),
        mutableCopy(mutableCopy),
        release(release),
        retain(retain),
        retainCount(retainCount),
        self(self),
        superclass(superclass),
        zone(zone)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const int&, const int&, const int&, const int&, const int&, const int&, const int&, const int&, const int&, const int&, const int&, const int&, const int&, const int&, const int&, const int&, const int&> ice_tuple() const
    {
        return std::tie(reason, isa, autorelease, classForCoder, copy, dealloc, description, hash, init, isProxy, mutableCopy, release, retain, retainCount, self, superclass, zone);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    int reason;
    int isa;
    int autorelease;
    int classForCoder;
    int copy;
    int dealloc;
    int description;
    int hash;
    int init;
    int isProxy;
    int mutableCopy;
    int release;
    int retain;
    int retainCount;
    int self;
    int superclass;
    int zone;
};

/// \cond INTERNAL
static Class1 _iceS_Class1_init;
/// \endcond

}

namespace Test
{

class Intf1Prx : public virtual ::Ice::Proxy<Intf1Prx, ::Ice::ObjectPrx>
{
public:

    void isa(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &Intf1Prx::_iceI_isa, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto isaAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &Intf1Prx::_iceI_isa, context);
    }

    ::std::function<void()>
    isaAsync(::std::function<void()> response,
             ::std::function<void(::std::exception_ptr)> ex = nullptr,
             ::std::function<void(bool)> sent = nullptr,
             const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::Intf1Prx::_iceI_isa, context);
    }

    /// \cond INTERNAL
    void _iceI_isa(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    void reason(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &Intf1Prx::_iceI_reason, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto reasonAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &Intf1Prx::_iceI_reason, context);
    }

    ::std::function<void()>
    reasonAsync(::std::function<void()> response,
                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                ::std::function<void(bool)> sent = nullptr,
                const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::Intf1Prx::_iceI_reason, context);
    }

    /// \cond INTERNAL
    void _iceI_reason(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    void autorelease(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &Intf1Prx::_iceI_autorelease, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto autoreleaseAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &Intf1Prx::_iceI_autorelease, context);
    }

    ::std::function<void()>
    autoreleaseAsync(::std::function<void()> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::Intf1Prx::_iceI_autorelease, context);
    }

    /// \cond INTERNAL
    void _iceI_autorelease(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    void classForCoder(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &Intf1Prx::_iceI_classForCoder, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto classForCoderAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &Intf1Prx::_iceI_classForCoder, context);
    }

    ::std::function<void()>
    classForCoderAsync(::std::function<void()> response,
                       ::std::function<void(::std::exception_ptr)> ex = nullptr,
                       ::std::function<void(bool)> sent = nullptr,
                       const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::Intf1Prx::_iceI_classForCoder, context);
    }

    /// \cond INTERNAL
    void _iceI_classForCoder(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    void copy(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &Intf1Prx::_iceI_copy, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto copyAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &Intf1Prx::_iceI_copy, context);
    }

    ::std::function<void()>
    copyAsync(::std::function<void()> response,
              ::std::function<void(::std::exception_ptr)> ex = nullptr,
              ::std::function<void(bool)> sent = nullptr,
              const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::Intf1Prx::_iceI_copy, context);
    }

    /// \cond INTERNAL
    void _iceI_copy(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    void dealloc(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &Intf1Prx::_iceI_dealloc, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto deallocAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &Intf1Prx::_iceI_dealloc, context);
    }

    ::std::function<void()>
    deallocAsync(::std::function<void()> response,
                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                 ::std::function<void(bool)> sent = nullptr,
                 const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::Intf1Prx::_iceI_dealloc, context);
    }

    /// \cond INTERNAL
    void _iceI_dealloc(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    void description(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &Intf1Prx::_iceI_description, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto descriptionAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &Intf1Prx::_iceI_description, context);
    }

    ::std::function<void()>
    descriptionAsync(::std::function<void()> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::Intf1Prx::_iceI_description, context);
    }

    /// \cond INTERNAL
    void _iceI_description(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    void hash(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &Intf1Prx::_iceI_hash, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto hashAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &Intf1Prx::_iceI_hash, context);
    }

    ::std::function<void()>
    hashAsync(::std::function<void()> response,
              ::std::function<void(::std::exception_ptr)> ex = nullptr,
              ::std::function<void(bool)> sent = nullptr,
              const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::Intf1Prx::_iceI_hash, context);
    }

    /// \cond INTERNAL
    void _iceI_hash(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    void init(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &Intf1Prx::_iceI_init, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto initAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &Intf1Prx::_iceI_init, context);
    }

    ::std::function<void()>
    initAsync(::std::function<void()> response,
              ::std::function<void(::std::exception_ptr)> ex = nullptr,
              ::std::function<void(bool)> sent = nullptr,
              const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::Intf1Prx::_iceI_init, context);
    }

    /// \cond INTERNAL
    void _iceI_init(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    void isProxy(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &Intf1Prx::_iceI_isProxy, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto isProxyAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &Intf1Prx::_iceI_isProxy, context);
    }

    ::std::function<void()>
    isProxyAsync(::std::function<void()> response,
                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                 ::std::function<void(bool)> sent = nullptr,
                 const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::Intf1Prx::_iceI_isProxy, context);
    }

    /// \cond INTERNAL
    void _iceI_isProxy(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    void mutableCopy(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &Intf1Prx::_iceI_mutableCopy, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto mutableCopyAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &Intf1Prx::_iceI_mutableCopy, context);
    }

    ::std::function<void()>
    mutableCopyAsync(::std::function<void()> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::Intf1Prx::_iceI_mutableCopy, context);
    }

    /// \cond INTERNAL
    void _iceI_mutableCopy(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    void release(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &Intf1Prx::_iceI_release, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto releaseAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &Intf1Prx::_iceI_release, context);
    }

    ::std::function<void()>
    releaseAsync(::std::function<void()> response,
                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                 ::std::function<void(bool)> sent = nullptr,
                 const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::Intf1Prx::_iceI_release, context);
    }

    /// \cond INTERNAL
    void _iceI_release(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    void retain(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &Intf1Prx::_iceI_retain, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto retainAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &Intf1Prx::_iceI_retain, context);
    }

    ::std::function<void()>
    retainAsync(::std::function<void()> response,
                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                ::std::function<void(bool)> sent = nullptr,
                const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::Intf1Prx::_iceI_retain, context);
    }

    /// \cond INTERNAL
    void _iceI_retain(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    void retainCount(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &Intf1Prx::_iceI_retainCount, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto retainCountAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &Intf1Prx::_iceI_retainCount, context);
    }

    ::std::function<void()>
    retainCountAsync(::std::function<void()> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::Intf1Prx::_iceI_retainCount, context);
    }

    /// \cond INTERNAL
    void _iceI_retainCount(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    void self(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &Intf1Prx::_iceI_self, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto selfAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &Intf1Prx::_iceI_self, context);
    }

    ::std::function<void()>
    selfAsync(::std::function<void()> response,
              ::std::function<void(::std::exception_ptr)> ex = nullptr,
              ::std::function<void(bool)> sent = nullptr,
              const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::Intf1Prx::_iceI_self, context);
    }

    /// \cond INTERNAL
    void _iceI_self(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    void superclass(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &Intf1Prx::_iceI_superclass, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto superclassAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &Intf1Prx::_iceI_superclass, context);
    }

    ::std::function<void()>
    superclassAsync(::std::function<void()> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::Intf1Prx::_iceI_superclass, context);
    }

    /// \cond INTERNAL
    void _iceI_superclass(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    void zone(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &Intf1Prx::_iceI_zone, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto zoneAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &Intf1Prx::_iceI_zone, context);
    }

    ::std::function<void()>
    zoneAsync(::std::function<void()> response,
              ::std::function<void(::std::exception_ptr)> ex = nullptr,
              ::std::function<void(bool)> sent = nullptr,
              const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::Intf1Prx::_iceI_zone, context);
    }

    /// \cond INTERNAL
    void _iceI_zone(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    Intf1Prx() = default;
    friend ::std::shared_ptr<Intf1Prx> IceInternal::createProxy<Intf1Prx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

class Intf2Prx : public virtual ::Ice::Proxy<Intf2Prx, ::Ice::ObjectPrx>
{
public:

    void isa(int a, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &Intf2Prx::_iceI_isa, a, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto isaAsync(int a, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &Intf2Prx::_iceI_isa, a, context);
    }

    ::std::function<void()>
    isaAsync(int a,
             ::std::function<void()> response,
             ::std::function<void(::std::exception_ptr)> ex = nullptr,
             ::std::function<void(bool)> sent = nullptr,
             const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::Intf2Prx::_iceI_isa, a, context);
    }

    /// \cond INTERNAL
    void _iceI_isa(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, int, const ::Ice::Context&);
    /// \endcond

    void reason(int a, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &Intf2Prx::_iceI_reason, a, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto reasonAsync(int a, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &Intf2Prx::_iceI_reason, a, context);
    }

    ::std::function<void()>
    reasonAsync(int a,
                ::std::function<void()> response,
                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                ::std::function<void(bool)> sent = nullptr,
                const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::Intf2Prx::_iceI_reason, a, context);
    }

    /// \cond INTERNAL
    void _iceI_reason(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, int, const ::Ice::Context&);
    /// \endcond

    void autorelease(int a, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &Intf2Prx::_iceI_autorelease, a, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto autoreleaseAsync(int a, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &Intf2Prx::_iceI_autorelease, a, context);
    }

    ::std::function<void()>
    autoreleaseAsync(int a,
                     ::std::function<void()> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::Intf2Prx::_iceI_autorelease, a, context);
    }

    /// \cond INTERNAL
    void _iceI_autorelease(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, int, const ::Ice::Context&);
    /// \endcond

    void classForCoder(int a, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &Intf2Prx::_iceI_classForCoder, a, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto classForCoderAsync(int a, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &Intf2Prx::_iceI_classForCoder, a, context);
    }

    ::std::function<void()>
    classForCoderAsync(int a,
                       ::std::function<void()> response,
                       ::std::function<void(::std::exception_ptr)> ex = nullptr,
                       ::std::function<void(bool)> sent = nullptr,
                       const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::Intf2Prx::_iceI_classForCoder, a, context);
    }

    /// \cond INTERNAL
    void _iceI_classForCoder(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, int, const ::Ice::Context&);
    /// \endcond

    void copy(int a, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &Intf2Prx::_iceI_copy, a, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto copyAsync(int a, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &Intf2Prx::_iceI_copy, a, context);
    }

    ::std::function<void()>
    copyAsync(int a,
              ::std::function<void()> response,
              ::std::function<void(::std::exception_ptr)> ex = nullptr,
              ::std::function<void(bool)> sent = nullptr,
              const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::Intf2Prx::_iceI_copy, a, context);
    }

    /// \cond INTERNAL
    void _iceI_copy(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, int, const ::Ice::Context&);
    /// \endcond

    void dealloc(int a, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &Intf2Prx::_iceI_dealloc, a, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto deallocAsync(int a, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &Intf2Prx::_iceI_dealloc, a, context);
    }

    ::std::function<void()>
    deallocAsync(int a,
                 ::std::function<void()> response,
                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                 ::std::function<void(bool)> sent = nullptr,
                 const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::Intf2Prx::_iceI_dealloc, a, context);
    }

    /// \cond INTERNAL
    void _iceI_dealloc(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, int, const ::Ice::Context&);
    /// \endcond

    void description(int a, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &Intf2Prx::_iceI_description, a, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto descriptionAsync(int a, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &Intf2Prx::_iceI_description, a, context);
    }

    ::std::function<void()>
    descriptionAsync(int a,
                     ::std::function<void()> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::Intf2Prx::_iceI_description, a, context);
    }

    /// \cond INTERNAL
    void _iceI_description(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, int, const ::Ice::Context&);
    /// \endcond

    void hash(int a, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &Intf2Prx::_iceI_hash, a, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto hashAsync(int a, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &Intf2Prx::_iceI_hash, a, context);
    }

    ::std::function<void()>
    hashAsync(int a,
              ::std::function<void()> response,
              ::std::function<void(::std::exception_ptr)> ex = nullptr,
              ::std::function<void(bool)> sent = nullptr,
              const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::Intf2Prx::_iceI_hash, a, context);
    }

    /// \cond INTERNAL
    void _iceI_hash(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, int, const ::Ice::Context&);
    /// \endcond

    void init(int a, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &Intf2Prx::_iceI_init, a, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto initAsync(int a, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &Intf2Prx::_iceI_init, a, context);
    }

    ::std::function<void()>
    initAsync(int a,
              ::std::function<void()> response,
              ::std::function<void(::std::exception_ptr)> ex = nullptr,
              ::std::function<void(bool)> sent = nullptr,
              const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::Intf2Prx::_iceI_init, a, context);
    }

    /// \cond INTERNAL
    void _iceI_init(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, int, const ::Ice::Context&);
    /// \endcond

    void isProxy(int a, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &Intf2Prx::_iceI_isProxy, a, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto isProxyAsync(int a, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &Intf2Prx::_iceI_isProxy, a, context);
    }

    ::std::function<void()>
    isProxyAsync(int a,
                 ::std::function<void()> response,
                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                 ::std::function<void(bool)> sent = nullptr,
                 const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::Intf2Prx::_iceI_isProxy, a, context);
    }

    /// \cond INTERNAL
    void _iceI_isProxy(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, int, const ::Ice::Context&);
    /// \endcond

    void mutableCopy(int a, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &Intf2Prx::_iceI_mutableCopy, a, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto mutableCopyAsync(int a, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &Intf2Prx::_iceI_mutableCopy, a, context);
    }

    ::std::function<void()>
    mutableCopyAsync(int a,
                     ::std::function<void()> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::Intf2Prx::_iceI_mutableCopy, a, context);
    }

    /// \cond INTERNAL
    void _iceI_mutableCopy(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, int, const ::Ice::Context&);
    /// \endcond

    void release(int a, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &Intf2Prx::_iceI_release, a, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto releaseAsync(int a, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &Intf2Prx::_iceI_release, a, context);
    }

    ::std::function<void()>
    releaseAsync(int a,
                 ::std::function<void()> response,
                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                 ::std::function<void(bool)> sent = nullptr,
                 const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::Intf2Prx::_iceI_release, a, context);
    }

    /// \cond INTERNAL
    void _iceI_release(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, int, const ::Ice::Context&);
    /// \endcond

    void retain(int a, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &Intf2Prx::_iceI_retain, a, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto retainAsync(int a, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &Intf2Prx::_iceI_retain, a, context);
    }

    ::std::function<void()>
    retainAsync(int a,
                ::std::function<void()> response,
                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                ::std::function<void(bool)> sent = nullptr,
                const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::Intf2Prx::_iceI_retain, a, context);
    }

    /// \cond INTERNAL
    void _iceI_retain(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, int, const ::Ice::Context&);
    /// \endcond

    void retainCount(int a, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &Intf2Prx::_iceI_retainCount, a, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto retainCountAsync(int a, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &Intf2Prx::_iceI_retainCount, a, context);
    }

    ::std::function<void()>
    retainCountAsync(int a,
                     ::std::function<void()> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::Intf2Prx::_iceI_retainCount, a, context);
    }

    /// \cond INTERNAL
    void _iceI_retainCount(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, int, const ::Ice::Context&);
    /// \endcond

    void self(int a, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &Intf2Prx::_iceI_self, a, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto selfAsync(int a, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &Intf2Prx::_iceI_self, a, context);
    }

    ::std::function<void()>
    selfAsync(int a,
              ::std::function<void()> response,
              ::std::function<void(::std::exception_ptr)> ex = nullptr,
              ::std::function<void(bool)> sent = nullptr,
              const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::Intf2Prx::_iceI_self, a, context);
    }

    /// \cond INTERNAL
    void _iceI_self(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, int, const ::Ice::Context&);
    /// \endcond

    void superclass(int a, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &Intf2Prx::_iceI_superclass, a, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto superclassAsync(int a, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &Intf2Prx::_iceI_superclass, a, context);
    }

    ::std::function<void()>
    superclassAsync(int a,
                    ::std::function<void()> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::Intf2Prx::_iceI_superclass, a, context);
    }

    /// \cond INTERNAL
    void _iceI_superclass(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, int, const ::Ice::Context&);
    /// \endcond

    void zone(int a, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &Intf2Prx::_iceI_zone, a, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto zoneAsync(int a, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &Intf2Prx::_iceI_zone, a, context);
    }

    ::std::function<void()>
    zoneAsync(int a,
              ::std::function<void()> response,
              ::std::function<void(::std::exception_ptr)> ex = nullptr,
              ::std::function<void(bool)> sent = nullptr,
              const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::Intf2Prx::_iceI_zone, a, context);
    }

    /// \cond INTERNAL
    void _iceI_zone(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, int, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    Intf2Prx() = default;
    friend ::std::shared_ptr<Intf2Prx> IceInternal::createProxy<Intf2Prx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

}

/// \cond STREAM
namespace Ice
{

template<>
struct StreamableTraits<::Test::Struct1>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 8;
    static const bool fixedLength = true;
};

template<typename S>
struct StreamReader<::Test::Struct1, S>
{
    static void read(S* istr, ::Test::Struct1& v)
    {
        istr->readAll(v.isa, v.retainCount);
    }
};

template<typename S>
struct StreamReader<::Test::Exception1, S>
{
    static void read(S* istr, ::Test::Exception1& v)
    {
        istr->readAll(v.isa, v.reason, v.raise, v.name, v.callStackReturnAddresses, v.userInfo, v.reserved);
    }
};

template<typename S>
struct StreamReader<::Test::Class1, S>
{
    static void read(S* istr, ::Test::Class1& v)
    {
        istr->readAll(v.reason, v.isa, v.autorelease, v.classForCoder, v.copy, v.dealloc, v.description, v.hash, v.init, v.isProxy, v.mutableCopy, v.release, v.retain, v.retainCount, v.self, v.superclass, v.zone);
    }
};

}
/// \endcond

/// \cond INTERNAL
namespace Test
{

using Class1Ptr = ::std::shared_ptr<Class1>;

using Intf1Ptr = ::std::shared_ptr<Intf1>;
using Intf1PrxPtr = ::std::shared_ptr<Intf1Prx>;

using Intf2Ptr = ::std::shared_ptr<Intf2>;
using Intf2PrxPtr = ::std::shared_ptr<Intf2Prx>;

}
/// \endcond

#else // C++98 mapping

namespace IceProxy
{

namespace Test
{

class Intf1;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< Intf1>&);
::IceProxy::Ice::Object* upCast(Intf1*);
/// \endcond

class Intf2;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< Intf2>&);
::IceProxy::Ice::Object* upCast(Intf2*);
/// \endcond

}

}

namespace Test
{

class Class1;
using Class1Ptr = ::Ice::SharedPtr<Class1>;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::Intf1> Intf1Prx;
typedef Intf1Prx Intf1PrxPtr;

class Intf1;
using Intf1Ptr = ::Ice::SharedPtr< Intf1>;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::Intf2> Intf2Prx;
typedef Intf2Prx Intf2PrxPtr;

class Intf2;
using Intf2Ptr = ::Ice::SharedPtr< Intf2>;

}

namespace Test
{

struct Struct1
{
    ::Ice::Int isa;
    ::Ice::Int retainCount;

    bool operator==(const Struct1& rhs_) const
    {
        if(this == &rhs_)
        {
            return true;
        }
        if(isa != rhs_.isa)
        {
            return false;
        }
        if(retainCount != rhs_.retainCount)
        {
            return false;
        }
        return true;
    }

    bool operator<(const Struct1& rhs_) const
    {
        if(this == &rhs_)
        {
            return false;
        }
        if(isa < rhs_.isa)
        {
            return true;
        }
        else if(rhs_.isa < isa)
        {
            return false;
        }
        if(retainCount < rhs_.retainCount)
        {
            return true;
        }
        else if(rhs_.retainCount < retainCount)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const Struct1& rhs_) const
    {
        return !operator==(rhs_);
    }
    bool operator<=(const Struct1& rhs_) const
    {
        return operator<(rhs_) || operator==(rhs_);
    }
    bool operator>(const Struct1& rhs_) const
    {
        return !operator<(rhs_) && !operator==(rhs_);
    }
    bool operator>=(const Struct1& rhs_) const
    {
        return !operator<(rhs_);
    }
};

class Exception1 : public ::Ice::UserException
{
public:

    Exception1() {}
    /**
     * One-shot constructor to initialize all data members.
     */
    Exception1(::Ice::Int isa, ::Ice::Int reason, ::Ice::Int raise, ::Ice::Int name, ::Ice::Int callStackReturnAddresses, ::Ice::Int userInfo, ::Ice::Int reserved);
    Exception1(const Exception1&) = default;
    virtual ~Exception1();

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    virtual ::std::string ice_id() const;
    /**
     * Polymorphically clones this exception.
     * @return A shallow copy of this exception.
     */
    virtual Exception1* ice_clone() const;
    /**
     * Throws this exception.
     */
    virtual void ice_throw() const;

    ::Ice::Int isa;
    ::Ice::Int reason;
    ::Ice::Int raise;
    ::Ice::Int name;
    ::Ice::Int callStackReturnAddresses;
    ::Ice::Int userInfo;
    ::Ice::Int reserved;

protected:

    /// \cond STREAM
    virtual void _writeImpl(::Ice::OutputStream*) const;
    virtual void _readImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
static Exception1 _iceS_Exception1_init;
/// \endcond

}

namespace Test
{

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Intf1::begin_isa.
 * Create a wrapper instance by calling ::Test::newCallback_Intf1_isa.
 */
class Callback_Intf1_isa_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Intf1_isa_Base> Callback_Intf1_isaPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Intf1::begin_reason.
 * Create a wrapper instance by calling ::Test::newCallback_Intf1_reason.
 */
class Callback_Intf1_reason_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Intf1_reason_Base> Callback_Intf1_reasonPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Intf1::begin_autorelease.
 * Create a wrapper instance by calling ::Test::newCallback_Intf1_autorelease.
 */
class Callback_Intf1_autorelease_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Intf1_autorelease_Base> Callback_Intf1_autoreleasePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Intf1::begin_classForCoder.
 * Create a wrapper instance by calling ::Test::newCallback_Intf1_classForCoder.
 */
class Callback_Intf1_classForCoder_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Intf1_classForCoder_Base> Callback_Intf1_classForCoderPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Intf1::begin_copy.
 * Create a wrapper instance by calling ::Test::newCallback_Intf1_copy.
 */
class Callback_Intf1_copy_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Intf1_copy_Base> Callback_Intf1_copyPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Intf1::begin_dealloc.
 * Create a wrapper instance by calling ::Test::newCallback_Intf1_dealloc.
 */
class Callback_Intf1_dealloc_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Intf1_dealloc_Base> Callback_Intf1_deallocPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Intf1::begin_description.
 * Create a wrapper instance by calling ::Test::newCallback_Intf1_description.
 */
class Callback_Intf1_description_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Intf1_description_Base> Callback_Intf1_descriptionPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Intf1::begin_hash.
 * Create a wrapper instance by calling ::Test::newCallback_Intf1_hash.
 */
class Callback_Intf1_hash_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Intf1_hash_Base> Callback_Intf1_hashPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Intf1::begin_init.
 * Create a wrapper instance by calling ::Test::newCallback_Intf1_init.
 */
class Callback_Intf1_init_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Intf1_init_Base> Callback_Intf1_initPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Intf1::begin_isProxy.
 * Create a wrapper instance by calling ::Test::newCallback_Intf1_isProxy.
 */
class Callback_Intf1_isProxy_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Intf1_isProxy_Base> Callback_Intf1_isProxyPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Intf1::begin_mutableCopy.
 * Create a wrapper instance by calling ::Test::newCallback_Intf1_mutableCopy.
 */
class Callback_Intf1_mutableCopy_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Intf1_mutableCopy_Base> Callback_Intf1_mutableCopyPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Intf1::begin_release.
 * Create a wrapper instance by calling ::Test::newCallback_Intf1_release.
 */
class Callback_Intf1_release_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Intf1_release_Base> Callback_Intf1_releasePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Intf1::begin_retain.
 * Create a wrapper instance by calling ::Test::newCallback_Intf1_retain.
 */
class Callback_Intf1_retain_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Intf1_retain_Base> Callback_Intf1_retainPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Intf1::begin_retainCount.
 * Create a wrapper instance by calling ::Test::newCallback_Intf1_retainCount.
 */
class Callback_Intf1_retainCount_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Intf1_retainCount_Base> Callback_Intf1_retainCountPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Intf1::begin_self.
 * Create a wrapper instance by calling ::Test::newCallback_Intf1_self.
 */
class Callback_Intf1_self_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Intf1_self_Base> Callback_Intf1_selfPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Intf1::begin_superclass.
 * Create a wrapper instance by calling ::Test::newCallback_Intf1_superclass.
 */
class Callback_Intf1_superclass_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Intf1_superclass_Base> Callback_Intf1_superclassPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Intf1::begin_zone.
 * Create a wrapper instance by calling ::Test::newCallback_Intf1_zone.
 */
class Callback_Intf1_zone_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Intf1_zone_Base> Callback_Intf1_zonePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Intf2::begin_isa.
 * Create a wrapper instance by calling ::Test::newCallback_Intf2_isa.
 */
class Callback_Intf2_isa_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Intf2_isa_Base> Callback_Intf2_isaPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Intf2::begin_reason.
 * Create a wrapper instance by calling ::Test::newCallback_Intf2_reason.
 */
class Callback_Intf2_reason_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Intf2_reason_Base> Callback_Intf2_reasonPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Intf2::begin_autorelease.
 * Create a wrapper instance by calling ::Test::newCallback_Intf2_autorelease.
 */
class Callback_Intf2_autorelease_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Intf2_autorelease_Base> Callback_Intf2_autoreleasePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Intf2::begin_classForCoder.
 * Create a wrapper instance by calling ::Test::newCallback_Intf2_classForCoder.
 */
class Callback_Intf2_classForCoder_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Intf2_classForCoder_Base> Callback_Intf2_classForCoderPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Intf2::begin_copy.
 * Create a wrapper instance by calling ::Test::newCallback_Intf2_copy.
 */
class Callback_Intf2_copy_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Intf2_copy_Base> Callback_Intf2_copyPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Intf2::begin_dealloc.
 * Create a wrapper instance by calling ::Test::newCallback_Intf2_dealloc.
 */
class Callback_Intf2_dealloc_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Intf2_dealloc_Base> Callback_Intf2_deallocPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Intf2::begin_description.
 * Create a wrapper instance by calling ::Test::newCallback_Intf2_description.
 */
class Callback_Intf2_description_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Intf2_description_Base> Callback_Intf2_descriptionPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Intf2::begin_hash.
 * Create a wrapper instance by calling ::Test::newCallback_Intf2_hash.
 */
class Callback_Intf2_hash_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Intf2_hash_Base> Callback_Intf2_hashPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Intf2::begin_init.
 * Create a wrapper instance by calling ::Test::newCallback_Intf2_init.
 */
class Callback_Intf2_init_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Intf2_init_Base> Callback_Intf2_initPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Intf2::begin_isProxy.
 * Create a wrapper instance by calling ::Test::newCallback_Intf2_isProxy.
 */
class Callback_Intf2_isProxy_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Intf2_isProxy_Base> Callback_Intf2_isProxyPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Intf2::begin_mutableCopy.
 * Create a wrapper instance by calling ::Test::newCallback_Intf2_mutableCopy.
 */
class Callback_Intf2_mutableCopy_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Intf2_mutableCopy_Base> Callback_Intf2_mutableCopyPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Intf2::begin_release.
 * Create a wrapper instance by calling ::Test::newCallback_Intf2_release.
 */
class Callback_Intf2_release_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Intf2_release_Base> Callback_Intf2_releasePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Intf2::begin_retain.
 * Create a wrapper instance by calling ::Test::newCallback_Intf2_retain.
 */
class Callback_Intf2_retain_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Intf2_retain_Base> Callback_Intf2_retainPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Intf2::begin_retainCount.
 * Create a wrapper instance by calling ::Test::newCallback_Intf2_retainCount.
 */
class Callback_Intf2_retainCount_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Intf2_retainCount_Base> Callback_Intf2_retainCountPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Intf2::begin_self.
 * Create a wrapper instance by calling ::Test::newCallback_Intf2_self.
 */
class Callback_Intf2_self_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Intf2_self_Base> Callback_Intf2_selfPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Intf2::begin_superclass.
 * Create a wrapper instance by calling ::Test::newCallback_Intf2_superclass.
 */
class Callback_Intf2_superclass_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Intf2_superclass_Base> Callback_Intf2_superclassPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Intf2::begin_zone.
 * Create a wrapper instance by calling ::Test::newCallback_Intf2_zone.
 */
class Callback_Intf2_zone_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Intf2_zone_Base> Callback_Intf2_zonePtr;

}

namespace IceProxy
{

namespace Test
{

class Intf1 : public virtual ::Ice::Proxy<Intf1, ::IceProxy::Ice::Object>
{
public:

    void isa(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_isa(_iceI_begin_isa(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_isa(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_isa(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_isa(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_isa(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_isa(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_isa(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_isa(const ::Test::Callback_Intf1_isaPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_isa(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_isa(const ::Ice::Context& context, const ::Test::Callback_Intf1_isaPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_isa(context, cb, cookie);
    }

    void end_isa(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_isa(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void reason(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_reason(_iceI_begin_reason(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_reason(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_reason(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_reason(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_reason(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_reason(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_reason(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_reason(const ::Test::Callback_Intf1_reasonPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_reason(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_reason(const ::Ice::Context& context, const ::Test::Callback_Intf1_reasonPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_reason(context, cb, cookie);
    }

    void end_reason(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_reason(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void autorelease(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_autorelease(_iceI_begin_autorelease(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_autorelease(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_autorelease(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_autorelease(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_autorelease(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_autorelease(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_autorelease(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_autorelease(const ::Test::Callback_Intf1_autoreleasePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_autorelease(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_autorelease(const ::Ice::Context& context, const ::Test::Callback_Intf1_autoreleasePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_autorelease(context, cb, cookie);
    }

    void end_autorelease(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_autorelease(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void classForCoder(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_classForCoder(_iceI_begin_classForCoder(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_classForCoder(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_classForCoder(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_classForCoder(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_classForCoder(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_classForCoder(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_classForCoder(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_classForCoder(const ::Test::Callback_Intf1_classForCoderPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_classForCoder(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_classForCoder(const ::Ice::Context& context, const ::Test::Callback_Intf1_classForCoderPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_classForCoder(context, cb, cookie);
    }

    void end_classForCoder(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_classForCoder(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void copy(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_copy(_iceI_begin_copy(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_copy(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_copy(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_copy(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_copy(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_copy(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_copy(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_copy(const ::Test::Callback_Intf1_copyPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_copy(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_copy(const ::Ice::Context& context, const ::Test::Callback_Intf1_copyPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_copy(context, cb, cookie);
    }

    void end_copy(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_copy(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void dealloc(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_dealloc(_iceI_begin_dealloc(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_dealloc(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_dealloc(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_dealloc(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_dealloc(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_dealloc(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_dealloc(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_dealloc(const ::Test::Callback_Intf1_deallocPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_dealloc(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_dealloc(const ::Ice::Context& context, const ::Test::Callback_Intf1_deallocPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_dealloc(context, cb, cookie);
    }

    void end_dealloc(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_dealloc(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void description(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_description(_iceI_begin_description(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_description(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_description(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_description(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_description(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_description(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_description(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_description(const ::Test::Callback_Intf1_descriptionPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_description(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_description(const ::Ice::Context& context, const ::Test::Callback_Intf1_descriptionPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_description(context, cb, cookie);
    }

    void end_description(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_description(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void hash(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_hash(_iceI_begin_hash(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_hash(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_hash(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_hash(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_hash(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_hash(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_hash(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_hash(const ::Test::Callback_Intf1_hashPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_hash(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_hash(const ::Ice::Context& context, const ::Test::Callback_Intf1_hashPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_hash(context, cb, cookie);
    }

    void end_hash(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_hash(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void init(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_init(_iceI_begin_init(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_init(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_init(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_init(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_init(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_init(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_init(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_init(const ::Test::Callback_Intf1_initPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_init(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_init(const ::Ice::Context& context, const ::Test::Callback_Intf1_initPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_init(context, cb, cookie);
    }

    void end_init(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_init(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void isProxy(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_isProxy(_iceI_begin_isProxy(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_isProxy(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_isProxy(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_isProxy(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_isProxy(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_isProxy(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_isProxy(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_isProxy(const ::Test::Callback_Intf1_isProxyPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_isProxy(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_isProxy(const ::Ice::Context& context, const ::Test::Callback_Intf1_isProxyPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_isProxy(context, cb, cookie);
    }

    void end_isProxy(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_isProxy(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void mutableCopy(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_mutableCopy(_iceI_begin_mutableCopy(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_mutableCopy(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_mutableCopy(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_mutableCopy(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_mutableCopy(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_mutableCopy(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_mutableCopy(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_mutableCopy(const ::Test::Callback_Intf1_mutableCopyPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_mutableCopy(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_mutableCopy(const ::Ice::Context& context, const ::Test::Callback_Intf1_mutableCopyPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_mutableCopy(context, cb, cookie);
    }

    void end_mutableCopy(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_mutableCopy(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void release(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_release(_iceI_begin_release(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_release(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_release(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_release(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_release(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_release(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_release(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_release(const ::Test::Callback_Intf1_releasePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_release(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_release(const ::Ice::Context& context, const ::Test::Callback_Intf1_releasePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_release(context, cb, cookie);
    }

    void end_release(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_release(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void retain(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_retain(_iceI_begin_retain(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_retain(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_retain(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_retain(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_retain(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_retain(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_retain(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_retain(const ::Test::Callback_Intf1_retainPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_retain(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_retain(const ::Ice::Context& context, const ::Test::Callback_Intf1_retainPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_retain(context, cb, cookie);
    }

    void end_retain(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_retain(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void retainCount(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_retainCount(_iceI_begin_retainCount(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_retainCount(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_retainCount(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_retainCount(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_retainCount(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_retainCount(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_retainCount(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_retainCount(const ::Test::Callback_Intf1_retainCountPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_retainCount(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_retainCount(const ::Ice::Context& context, const ::Test::Callback_Intf1_retainCountPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_retainCount(context, cb, cookie);
    }

    void end_retainCount(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_retainCount(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void self(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_self(_iceI_begin_self(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_self(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_self(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_self(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_self(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_self(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_self(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_self(const ::Test::Callback_Intf1_selfPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_self(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_self(const ::Ice::Context& context, const ::Test::Callback_Intf1_selfPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_self(context, cb, cookie);
    }

    void end_self(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_self(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void superclass(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_superclass(_iceI_begin_superclass(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_superclass(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_superclass(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_superclass(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_superclass(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_superclass(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_superclass(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_superclass(const ::Test::Callback_Intf1_superclassPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_superclass(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_superclass(const ::Ice::Context& context, const ::Test::Callback_Intf1_superclassPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_superclass(context, cb, cookie);
    }

    void end_superclass(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_superclass(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void zone(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_zone(_iceI_begin_zone(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_zone(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_zone(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_zone(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_zone(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_zone(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_zone(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_zone(const ::Test::Callback_Intf1_zonePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_zone(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_zone(const ::Ice::Context& context, const ::Test::Callback_Intf1_zonePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_zone(context, cb, cookie);
    }

    void end_zone(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_zone(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class Intf2 : public virtual ::Ice::Proxy<Intf2, ::IceProxy::Ice::Object>
{
public:

    void isa(::Ice::Int a, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_isa(_iceI_begin_isa(a, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_isa(::Ice::Int a, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_isa(a, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_isa(::Ice::Int a, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_isa(a, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_isa(::Ice::Int a, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_isa(a, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_isa(::Ice::Int a, const ::Test::Callback_Intf2_isaPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_isa(a, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_isa(::Ice::Int a, const ::Ice::Context& context, const ::Test::Callback_Intf2_isaPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_isa(a, context, cb, cookie);
    }

    void end_isa(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_isa(::Ice::Int, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void reason(::Ice::Int a, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_reason(_iceI_begin_reason(a, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_reason(::Ice::Int a, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_reason(a, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_reason(::Ice::Int a, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_reason(a, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_reason(::Ice::Int a, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_reason(a, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_reason(::Ice::Int a, const ::Test::Callback_Intf2_reasonPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_reason(a, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_reason(::Ice::Int a, const ::Ice::Context& context, const ::Test::Callback_Intf2_reasonPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_reason(a, context, cb, cookie);
    }

    void end_reason(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_reason(::Ice::Int, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void autorelease(::Ice::Int a, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_autorelease(_iceI_begin_autorelease(a, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_autorelease(::Ice::Int a, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_autorelease(a, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_autorelease(::Ice::Int a, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_autorelease(a, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_autorelease(::Ice::Int a, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_autorelease(a, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_autorelease(::Ice::Int a, const ::Test::Callback_Intf2_autoreleasePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_autorelease(a, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_autorelease(::Ice::Int a, const ::Ice::Context& context, const ::Test::Callback_Intf2_autoreleasePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_autorelease(a, context, cb, cookie);
    }

    void end_autorelease(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_autorelease(::Ice::Int, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void classForCoder(::Ice::Int a, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_classForCoder(_iceI_begin_classForCoder(a, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_classForCoder(::Ice::Int a, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_classForCoder(a, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_classForCoder(::Ice::Int a, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_classForCoder(a, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_classForCoder(::Ice::Int a, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_classForCoder(a, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_classForCoder(::Ice::Int a, const ::Test::Callback_Intf2_classForCoderPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_classForCoder(a, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_classForCoder(::Ice::Int a, const ::Ice::Context& context, const ::Test::Callback_Intf2_classForCoderPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_classForCoder(a, context, cb, cookie);
    }

    void end_classForCoder(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_classForCoder(::Ice::Int, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void copy(::Ice::Int a, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_copy(_iceI_begin_copy(a, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_copy(::Ice::Int a, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_copy(a, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_copy(::Ice::Int a, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_copy(a, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_copy(::Ice::Int a, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_copy(a, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_copy(::Ice::Int a, const ::Test::Callback_Intf2_copyPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_copy(a, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_copy(::Ice::Int a, const ::Ice::Context& context, const ::Test::Callback_Intf2_copyPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_copy(a, context, cb, cookie);
    }

    void end_copy(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_copy(::Ice::Int, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void dealloc(::Ice::Int a, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_dealloc(_iceI_begin_dealloc(a, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_dealloc(::Ice::Int a, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_dealloc(a, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_dealloc(::Ice::Int a, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_dealloc(a, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_dealloc(::Ice::Int a, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_dealloc(a, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_dealloc(::Ice::Int a, const ::Test::Callback_Intf2_deallocPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_dealloc(a, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_dealloc(::Ice::Int a, const ::Ice::Context& context, const ::Test::Callback_Intf2_deallocPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_dealloc(a, context, cb, cookie);
    }

    void end_dealloc(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_dealloc(::Ice::Int, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void description(::Ice::Int a, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_description(_iceI_begin_description(a, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_description(::Ice::Int a, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_description(a, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_description(::Ice::Int a, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_description(a, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_description(::Ice::Int a, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_description(a, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_description(::Ice::Int a, const ::Test::Callback_Intf2_descriptionPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_description(a, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_description(::Ice::Int a, const ::Ice::Context& context, const ::Test::Callback_Intf2_descriptionPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_description(a, context, cb, cookie);
    }

    void end_description(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_description(::Ice::Int, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void hash(::Ice::Int a, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_hash(_iceI_begin_hash(a, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_hash(::Ice::Int a, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_hash(a, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_hash(::Ice::Int a, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_hash(a, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_hash(::Ice::Int a, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_hash(a, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_hash(::Ice::Int a, const ::Test::Callback_Intf2_hashPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_hash(a, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_hash(::Ice::Int a, const ::Ice::Context& context, const ::Test::Callback_Intf2_hashPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_hash(a, context, cb, cookie);
    }

    void end_hash(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_hash(::Ice::Int, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void init(::Ice::Int a, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_init(_iceI_begin_init(a, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_init(::Ice::Int a, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_init(a, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_init(::Ice::Int a, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_init(a, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_init(::Ice::Int a, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_init(a, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_init(::Ice::Int a, const ::Test::Callback_Intf2_initPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_init(a, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_init(::Ice::Int a, const ::Ice::Context& context, const ::Test::Callback_Intf2_initPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_init(a, context, cb, cookie);
    }

    void end_init(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_init(::Ice::Int, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void isProxy(::Ice::Int a, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_isProxy(_iceI_begin_isProxy(a, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_isProxy(::Ice::Int a, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_isProxy(a, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_isProxy(::Ice::Int a, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_isProxy(a, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_isProxy(::Ice::Int a, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_isProxy(a, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_isProxy(::Ice::Int a, const ::Test::Callback_Intf2_isProxyPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_isProxy(a, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_isProxy(::Ice::Int a, const ::Ice::Context& context, const ::Test::Callback_Intf2_isProxyPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_isProxy(a, context, cb, cookie);
    }

    void end_isProxy(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_isProxy(::Ice::Int, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void mutableCopy(::Ice::Int a, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_mutableCopy(_iceI_begin_mutableCopy(a, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_mutableCopy(::Ice::Int a, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_mutableCopy(a, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_mutableCopy(::Ice::Int a, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_mutableCopy(a, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_mutableCopy(::Ice::Int a, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_mutableCopy(a, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_mutableCopy(::Ice::Int a, const ::Test::Callback_Intf2_mutableCopyPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_mutableCopy(a, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_mutableCopy(::Ice::Int a, const ::Ice::Context& context, const ::Test::Callback_Intf2_mutableCopyPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_mutableCopy(a, context, cb, cookie);
    }

    void end_mutableCopy(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_mutableCopy(::Ice::Int, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void release(::Ice::Int a, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_release(_iceI_begin_release(a, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_release(::Ice::Int a, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_release(a, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_release(::Ice::Int a, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_release(a, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_release(::Ice::Int a, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_release(a, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_release(::Ice::Int a, const ::Test::Callback_Intf2_releasePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_release(a, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_release(::Ice::Int a, const ::Ice::Context& context, const ::Test::Callback_Intf2_releasePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_release(a, context, cb, cookie);
    }

    void end_release(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_release(::Ice::Int, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void retain(::Ice::Int a, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_retain(_iceI_begin_retain(a, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_retain(::Ice::Int a, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_retain(a, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_retain(::Ice::Int a, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_retain(a, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_retain(::Ice::Int a, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_retain(a, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_retain(::Ice::Int a, const ::Test::Callback_Intf2_retainPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_retain(a, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_retain(::Ice::Int a, const ::Ice::Context& context, const ::Test::Callback_Intf2_retainPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_retain(a, context, cb, cookie);
    }

    void end_retain(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_retain(::Ice::Int, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void retainCount(::Ice::Int a, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_retainCount(_iceI_begin_retainCount(a, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_retainCount(::Ice::Int a, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_retainCount(a, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_retainCount(::Ice::Int a, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_retainCount(a, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_retainCount(::Ice::Int a, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_retainCount(a, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_retainCount(::Ice::Int a, const ::Test::Callback_Intf2_retainCountPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_retainCount(a, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_retainCount(::Ice::Int a, const ::Ice::Context& context, const ::Test::Callback_Intf2_retainCountPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_retainCount(a, context, cb, cookie);
    }

    void end_retainCount(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_retainCount(::Ice::Int, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void self(::Ice::Int a, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_self(_iceI_begin_self(a, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_self(::Ice::Int a, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_self(a, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_self(::Ice::Int a, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_self(a, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_self(::Ice::Int a, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_self(a, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_self(::Ice::Int a, const ::Test::Callback_Intf2_selfPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_self(a, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_self(::Ice::Int a, const ::Ice::Context& context, const ::Test::Callback_Intf2_selfPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_self(a, context, cb, cookie);
    }

    void end_self(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_self(::Ice::Int, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void superclass(::Ice::Int a, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_superclass(_iceI_begin_superclass(a, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_superclass(::Ice::Int a, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_superclass(a, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_superclass(::Ice::Int a, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_superclass(a, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_superclass(::Ice::Int a, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_superclass(a, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_superclass(::Ice::Int a, const ::Test::Callback_Intf2_superclassPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_superclass(a, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_superclass(::Ice::Int a, const ::Ice::Context& context, const ::Test::Callback_Intf2_superclassPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_superclass(a, context, cb, cookie);
    }

    void end_superclass(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_superclass(::Ice::Int, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void zone(::Ice::Int a, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_zone(_iceI_begin_zone(a, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_zone(::Ice::Int a, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_zone(a, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_zone(::Ice::Int a, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_zone(a, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_zone(::Ice::Int a, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_zone(a, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_zone(::Ice::Int a, const ::Test::Callback_Intf2_zonePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_zone(a, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_zone(::Ice::Int a, const ::Ice::Context& context, const ::Test::Callback_Intf2_zonePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_zone(a, context, cb, cookie);
    }

    void end_zone(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_zone(::Ice::Int, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

}

}

namespace Test
{

class Intf1 : public virtual ::Ice::Object
{
public:

    typedef Intf1Prx ProxyType;

    virtual ~Intf1();
    Intf1() = default;
    Intf1(const Intf1&) = default;
    Intf1& operator=(const Intf1&) = default;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void isa(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_isa(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void reason(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_reason(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void autorelease(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_autorelease(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void classForCoder(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_classForCoder(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void copy(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_copy(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void dealloc(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_dealloc(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void description(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_description(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void hash(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_hash(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void init(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_init(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void isProxy(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_isProxy(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void mutableCopy(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_mutableCopy(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void release(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_release(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void retain(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_retain(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void retainCount(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_retainCount(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void self(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_self(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void superclass(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_superclass(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void zone(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_zone(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond
};

class Intf2 : public virtual ::Ice::Object
{
public:

    typedef Intf2Prx ProxyType;

    virtual ~Intf2();
    Intf2() = default;
    Intf2(const Intf2&) = default;
    Intf2& operator=(const Intf2&) = default;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void isa(::Ice::Int a, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_isa(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void reason(::Ice::Int a, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_reason(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void autorelease(::Ice::Int a, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_autorelease(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void classForCoder(::Ice::Int a, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_classForCoder(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void copy(::Ice::Int a, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_copy(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void dealloc(::Ice::Int a, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_dealloc(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void description(::Ice::Int a, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_description(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void hash(::Ice::Int a, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_hash(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void init(::Ice::Int a, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_init(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void isProxy(::Ice::Int a, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_isProxy(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void mutableCopy(::Ice::Int a, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_mutableCopy(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void release(::Ice::Int a, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_release(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void retain(::Ice::Int a, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_retain(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void retainCount(::Ice::Int a, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_retainCount(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void self(::Ice::Int a, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_self(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void superclass(::Ice::Int a, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_superclass(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void zone(::Ice::Int a, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_zone(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond
};

}

namespace Test
{

class Class1 : public ::Ice::ValueHelper<Class1, ::Ice::Value>
{
public:

    virtual ~Class1();

    Class1() = default;

    Class1(const Class1&) = default;
    Class1(Class1&&) = default;
    Class1& operator=(const Class1&) = default;
    Class1& operator=(Class1&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    Class1(::Ice::Int reason, ::Ice::Int isa, ::Ice::Int autorelease, ::Ice::Int classForCoder, ::Ice::Int copy, ::Ice::Int dealloc, ::Ice::Int description, ::Ice::Int hash, ::Ice::Int init, ::Ice::Int isProxy, ::Ice::Int mutableCopy, ::Ice::Int release, ::Ice::Int retain, ::Ice::Int retainCount, ::Ice::Int self, ::Ice::Int superclass, ::Ice::Int zone) :
        reason(reason),
        isa(isa),
        autorelease(autorelease),
        classForCoder(classForCoder),
        copy(copy),
        dealloc(dealloc),
        description(description),
        hash(hash),
        init(init),
        isProxy(isProxy),
        mutableCopy(mutableCopy),
        release(release),
        retain(retain),
        retainCount(retainCount),
        self(self),
        superclass(superclass),
        zone(zone)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::Ice::Int&, const ::Ice::Int&, const ::Ice::Int&, const ::Ice::Int&, const ::Ice::Int&, const ::Ice::Int&, const ::Ice::Int&, const ::Ice::Int&, const ::Ice::Int&, const ::Ice::Int&, const ::Ice::Int&, const ::Ice::Int&, const ::Ice::Int&, const ::Ice::Int&, const ::Ice::Int&, const ::Ice::Int&, const ::Ice::Int&> ice_tuple() const
    {
        return std::tie(reason, isa, autorelease, classForCoder, copy, dealloc, description, hash, init, isProxy, mutableCopy, release, retain, retainCount, self, superclass, zone);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::Ice::Int reason;
    ::Ice::Int isa;
    ::Ice::Int autorelease;
    ::Ice::Int classForCoder;
    ::Ice::Int copy;
    ::Ice::Int dealloc;
    ::Ice::Int description;
    ::Ice::Int hash;
    ::Ice::Int init;
    ::Ice::Int isProxy;
    ::Ice::Int mutableCopy;
    ::Ice::Int release;
    ::Ice::Int retain;
    ::Ice::Int retainCount;
    ::Ice::Int self;
    ::Ice::Int superclass;
    ::Ice::Int zone;
};

/// \cond INTERNAL
static Class1 _iceS_Class1_init;
/// \endcond

}

/// \cond STREAM
namespace Ice
{

template<>
struct StreamableTraits< ::Test::Struct1>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 8;
    static const bool fixedLength = true;
};

template<typename S>
struct StreamWriter< ::Test::Struct1, S>
{
    static void write(S* ostr, const ::Test::Struct1& v)
    {
        ostr->write(v.isa);
        ostr->write(v.retainCount);
    }
};

template<typename S>
struct StreamReader< ::Test::Struct1, S>
{
    static void read(S* istr, ::Test::Struct1& v)
    {
        istr->read(v.isa);
        istr->read(v.retainCount);
    }
};

template<>
struct StreamableTraits< ::Test::Exception1>
{
    static const StreamHelperCategory helper = StreamHelperCategoryUserException;
};

template<typename S>
struct StreamWriter< ::Test::Exception1, S>
{
    static void write(S* ostr, const ::Test::Exception1& v)
    {
        ostr->write(v.isa);
        ostr->write(v.reason);
        ostr->write(v.raise);
        ostr->write(v.name);
        ostr->write(v.callStackReturnAddresses);
        ostr->write(v.userInfo);
        ostr->write(v.reserved);
    }
};

template<typename S>
struct StreamReader< ::Test::Exception1, S>
{
    static void read(S* istr, ::Test::Exception1& v)
    {
        istr->read(v.isa);
        istr->read(v.reason);
        istr->read(v.raise);
        istr->read(v.name);
        istr->read(v.callStackReturnAddresses);
        istr->read(v.userInfo);
        istr->read(v.reserved);
    }
};

template<typename S>
struct StreamWriter< ::Test::Class1, S>
{
    static void write(S* ostr, const ::Test::Class1& v)
    {
        ostr->write(v.reason);
        ostr->write(v.isa);
        ostr->write(v.autorelease);
        ostr->write(v.classForCoder);
        ostr->write(v.copy);
        ostr->write(v.dealloc);
        ostr->write(v.description);
        ostr->write(v.hash);
        ostr->write(v.init);
        ostr->write(v.isProxy);
        ostr->write(v.mutableCopy);
        ostr->write(v.release);
        ostr->write(v.retain);
        ostr->write(v.retainCount);
        ostr->write(v.self);
        ostr->write(v.superclass);
        ostr->write(v.zone);
    }
};

template<typename S>
struct StreamReader< ::Test::Class1, S>
{
    static void read(S* istr, ::Test::Class1& v)
    {
        istr->read(v.reason);
        istr->read(v.isa);
        istr->read(v.autorelease);
        istr->read(v.classForCoder);
        istr->read(v.copy);
        istr->read(v.dealloc);
        istr->read(v.description);
        istr->read(v.hash);
        istr->read(v.init);
        istr->read(v.isProxy);
        istr->read(v.mutableCopy);
        istr->read(v.release);
        istr->read(v.retain);
        istr->read(v.retainCount);
        istr->read(v.self);
        istr->read(v.superclass);
        istr->read(v.zone);
    }
};

}
/// \endcond

namespace Test
{

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Intf1::begin_isa.
 * Create a wrapper instance by calling ::Test::newCallback_Intf1_isa.
 */
template<class T>
class CallbackNC_Intf1_isa : public Callback_Intf1_isa_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Intf1_isa(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_isa.
 */
template<class T> Callback_Intf1_isaPtr
newCallback_Intf1_isa(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf1_isa<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_isa.
 */
template<class T> Callback_Intf1_isaPtr
newCallback_Intf1_isa(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf1_isa<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_isa.
 */
template<class T> Callback_Intf1_isaPtr
newCallback_Intf1_isa(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf1_isa<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_isa.
 */
template<class T> Callback_Intf1_isaPtr
newCallback_Intf1_isa(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf1_isa<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Intf1::begin_isa.
 * Create a wrapper instance by calling ::Test::newCallback_Intf1_isa.
 */
template<class T, typename CT>
class Callback_Intf1_isa : public Callback_Intf1_isa_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Intf1_isa(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_isa.
 */
template<class T, typename CT> Callback_Intf1_isaPtr
newCallback_Intf1_isa(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf1_isa<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_isa.
 */
template<class T, typename CT> Callback_Intf1_isaPtr
newCallback_Intf1_isa(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf1_isa<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_isa.
 */
template<class T, typename CT> Callback_Intf1_isaPtr
newCallback_Intf1_isa(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf1_isa<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_isa.
 */
template<class T, typename CT> Callback_Intf1_isaPtr
newCallback_Intf1_isa(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf1_isa<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Intf1::begin_reason.
 * Create a wrapper instance by calling ::Test::newCallback_Intf1_reason.
 */
template<class T>
class CallbackNC_Intf1_reason : public Callback_Intf1_reason_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Intf1_reason(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_reason.
 */
template<class T> Callback_Intf1_reasonPtr
newCallback_Intf1_reason(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf1_reason<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_reason.
 */
template<class T> Callback_Intf1_reasonPtr
newCallback_Intf1_reason(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf1_reason<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_reason.
 */
template<class T> Callback_Intf1_reasonPtr
newCallback_Intf1_reason(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf1_reason<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_reason.
 */
template<class T> Callback_Intf1_reasonPtr
newCallback_Intf1_reason(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf1_reason<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Intf1::begin_reason.
 * Create a wrapper instance by calling ::Test::newCallback_Intf1_reason.
 */
template<class T, typename CT>
class Callback_Intf1_reason : public Callback_Intf1_reason_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Intf1_reason(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_reason.
 */
template<class T, typename CT> Callback_Intf1_reasonPtr
newCallback_Intf1_reason(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf1_reason<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_reason.
 */
template<class T, typename CT> Callback_Intf1_reasonPtr
newCallback_Intf1_reason(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf1_reason<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_reason.
 */
template<class T, typename CT> Callback_Intf1_reasonPtr
newCallback_Intf1_reason(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf1_reason<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_reason.
 */
template<class T, typename CT> Callback_Intf1_reasonPtr
newCallback_Intf1_reason(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf1_reason<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Intf1::begin_autorelease.
 * Create a wrapper instance by calling ::Test::newCallback_Intf1_autorelease.
 */
template<class T>
class CallbackNC_Intf1_autorelease : public Callback_Intf1_autorelease_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Intf1_autorelease(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_autorelease.
 */
template<class T> Callback_Intf1_autoreleasePtr
newCallback_Intf1_autorelease(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf1_autorelease<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_autorelease.
 */
template<class T> Callback_Intf1_autoreleasePtr
newCallback_Intf1_autorelease(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf1_autorelease<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_autorelease.
 */
template<class T> Callback_Intf1_autoreleasePtr
newCallback_Intf1_autorelease(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf1_autorelease<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_autorelease.
 */
template<class T> Callback_Intf1_autoreleasePtr
newCallback_Intf1_autorelease(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf1_autorelease<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Intf1::begin_autorelease.
 * Create a wrapper instance by calling ::Test::newCallback_Intf1_autorelease.
 */
template<class T, typename CT>
class Callback_Intf1_autorelease : public Callback_Intf1_autorelease_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Intf1_autorelease(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_autorelease.
 */
template<class T, typename CT> Callback_Intf1_autoreleasePtr
newCallback_Intf1_autorelease(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf1_autorelease<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_autorelease.
 */
template<class T, typename CT> Callback_Intf1_autoreleasePtr
newCallback_Intf1_autorelease(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf1_autorelease<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_autorelease.
 */
template<class T, typename CT> Callback_Intf1_autoreleasePtr
newCallback_Intf1_autorelease(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf1_autorelease<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_autorelease.
 */
template<class T, typename CT> Callback_Intf1_autoreleasePtr
newCallback_Intf1_autorelease(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf1_autorelease<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Intf1::begin_classForCoder.
 * Create a wrapper instance by calling ::Test::newCallback_Intf1_classForCoder.
 */
template<class T>
class CallbackNC_Intf1_classForCoder : public Callback_Intf1_classForCoder_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Intf1_classForCoder(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_classForCoder.
 */
template<class T> Callback_Intf1_classForCoderPtr
newCallback_Intf1_classForCoder(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf1_classForCoder<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_classForCoder.
 */
template<class T> Callback_Intf1_classForCoderPtr
newCallback_Intf1_classForCoder(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf1_classForCoder<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_classForCoder.
 */
template<class T> Callback_Intf1_classForCoderPtr
newCallback_Intf1_classForCoder(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf1_classForCoder<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_classForCoder.
 */
template<class T> Callback_Intf1_classForCoderPtr
newCallback_Intf1_classForCoder(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf1_classForCoder<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Intf1::begin_classForCoder.
 * Create a wrapper instance by calling ::Test::newCallback_Intf1_classForCoder.
 */
template<class T, typename CT>
class Callback_Intf1_classForCoder : public Callback_Intf1_classForCoder_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Intf1_classForCoder(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_classForCoder.
 */
template<class T, typename CT> Callback_Intf1_classForCoderPtr
newCallback_Intf1_classForCoder(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf1_classForCoder<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_classForCoder.
 */
template<class T, typename CT> Callback_Intf1_classForCoderPtr
newCallback_Intf1_classForCoder(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf1_classForCoder<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_classForCoder.
 */
template<class T, typename CT> Callback_Intf1_classForCoderPtr
newCallback_Intf1_classForCoder(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf1_classForCoder<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_classForCoder.
 */
template<class T, typename CT> Callback_Intf1_classForCoderPtr
newCallback_Intf1_classForCoder(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf1_classForCoder<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Intf1::begin_copy.
 * Create a wrapper instance by calling ::Test::newCallback_Intf1_copy.
 */
template<class T>
class CallbackNC_Intf1_copy : public Callback_Intf1_copy_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Intf1_copy(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_copy.
 */
template<class T> Callback_Intf1_copyPtr
newCallback_Intf1_copy(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf1_copy<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_copy.
 */
template<class T> Callback_Intf1_copyPtr
newCallback_Intf1_copy(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf1_copy<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_copy.
 */
template<class T> Callback_Intf1_copyPtr
newCallback_Intf1_copy(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf1_copy<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_copy.
 */
template<class T> Callback_Intf1_copyPtr
newCallback_Intf1_copy(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf1_copy<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Intf1::begin_copy.
 * Create a wrapper instance by calling ::Test::newCallback_Intf1_copy.
 */
template<class T, typename CT>
class Callback_Intf1_copy : public Callback_Intf1_copy_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Intf1_copy(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_copy.
 */
template<class T, typename CT> Callback_Intf1_copyPtr
newCallback_Intf1_copy(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf1_copy<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_copy.
 */
template<class T, typename CT> Callback_Intf1_copyPtr
newCallback_Intf1_copy(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf1_copy<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_copy.
 */
template<class T, typename CT> Callback_Intf1_copyPtr
newCallback_Intf1_copy(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf1_copy<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_copy.
 */
template<class T, typename CT> Callback_Intf1_copyPtr
newCallback_Intf1_copy(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf1_copy<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Intf1::begin_dealloc.
 * Create a wrapper instance by calling ::Test::newCallback_Intf1_dealloc.
 */
template<class T>
class CallbackNC_Intf1_dealloc : public Callback_Intf1_dealloc_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Intf1_dealloc(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_dealloc.
 */
template<class T> Callback_Intf1_deallocPtr
newCallback_Intf1_dealloc(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf1_dealloc<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_dealloc.
 */
template<class T> Callback_Intf1_deallocPtr
newCallback_Intf1_dealloc(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf1_dealloc<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_dealloc.
 */
template<class T> Callback_Intf1_deallocPtr
newCallback_Intf1_dealloc(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf1_dealloc<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_dealloc.
 */
template<class T> Callback_Intf1_deallocPtr
newCallback_Intf1_dealloc(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf1_dealloc<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Intf1::begin_dealloc.
 * Create a wrapper instance by calling ::Test::newCallback_Intf1_dealloc.
 */
template<class T, typename CT>
class Callback_Intf1_dealloc : public Callback_Intf1_dealloc_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Intf1_dealloc(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_dealloc.
 */
template<class T, typename CT> Callback_Intf1_deallocPtr
newCallback_Intf1_dealloc(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf1_dealloc<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_dealloc.
 */
template<class T, typename CT> Callback_Intf1_deallocPtr
newCallback_Intf1_dealloc(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf1_dealloc<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_dealloc.
 */
template<class T, typename CT> Callback_Intf1_deallocPtr
newCallback_Intf1_dealloc(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf1_dealloc<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_dealloc.
 */
template<class T, typename CT> Callback_Intf1_deallocPtr
newCallback_Intf1_dealloc(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf1_dealloc<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Intf1::begin_description.
 * Create a wrapper instance by calling ::Test::newCallback_Intf1_description.
 */
template<class T>
class CallbackNC_Intf1_description : public Callback_Intf1_description_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Intf1_description(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_description.
 */
template<class T> Callback_Intf1_descriptionPtr
newCallback_Intf1_description(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf1_description<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_description.
 */
template<class T> Callback_Intf1_descriptionPtr
newCallback_Intf1_description(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf1_description<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_description.
 */
template<class T> Callback_Intf1_descriptionPtr
newCallback_Intf1_description(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf1_description<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_description.
 */
template<class T> Callback_Intf1_descriptionPtr
newCallback_Intf1_description(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf1_description<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Intf1::begin_description.
 * Create a wrapper instance by calling ::Test::newCallback_Intf1_description.
 */
template<class T, typename CT>
class Callback_Intf1_description : public Callback_Intf1_description_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Intf1_description(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_description.
 */
template<class T, typename CT> Callback_Intf1_descriptionPtr
newCallback_Intf1_description(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf1_description<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_description.
 */
template<class T, typename CT> Callback_Intf1_descriptionPtr
newCallback_Intf1_description(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf1_description<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_description.
 */
template<class T, typename CT> Callback_Intf1_descriptionPtr
newCallback_Intf1_description(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf1_description<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_description.
 */
template<class T, typename CT> Callback_Intf1_descriptionPtr
newCallback_Intf1_description(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf1_description<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Intf1::begin_hash.
 * Create a wrapper instance by calling ::Test::newCallback_Intf1_hash.
 */
template<class T>
class CallbackNC_Intf1_hash : public Callback_Intf1_hash_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Intf1_hash(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_hash.
 */
template<class T> Callback_Intf1_hashPtr
newCallback_Intf1_hash(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf1_hash<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_hash.
 */
template<class T> Callback_Intf1_hashPtr
newCallback_Intf1_hash(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf1_hash<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_hash.
 */
template<class T> Callback_Intf1_hashPtr
newCallback_Intf1_hash(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf1_hash<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_hash.
 */
template<class T> Callback_Intf1_hashPtr
newCallback_Intf1_hash(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf1_hash<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Intf1::begin_hash.
 * Create a wrapper instance by calling ::Test::newCallback_Intf1_hash.
 */
template<class T, typename CT>
class Callback_Intf1_hash : public Callback_Intf1_hash_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Intf1_hash(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_hash.
 */
template<class T, typename CT> Callback_Intf1_hashPtr
newCallback_Intf1_hash(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf1_hash<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_hash.
 */
template<class T, typename CT> Callback_Intf1_hashPtr
newCallback_Intf1_hash(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf1_hash<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_hash.
 */
template<class T, typename CT> Callback_Intf1_hashPtr
newCallback_Intf1_hash(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf1_hash<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_hash.
 */
template<class T, typename CT> Callback_Intf1_hashPtr
newCallback_Intf1_hash(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf1_hash<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Intf1::begin_init.
 * Create a wrapper instance by calling ::Test::newCallback_Intf1_init.
 */
template<class T>
class CallbackNC_Intf1_init : public Callback_Intf1_init_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Intf1_init(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_init.
 */
template<class T> Callback_Intf1_initPtr
newCallback_Intf1_init(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf1_init<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_init.
 */
template<class T> Callback_Intf1_initPtr
newCallback_Intf1_init(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf1_init<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_init.
 */
template<class T> Callback_Intf1_initPtr
newCallback_Intf1_init(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf1_init<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_init.
 */
template<class T> Callback_Intf1_initPtr
newCallback_Intf1_init(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf1_init<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Intf1::begin_init.
 * Create a wrapper instance by calling ::Test::newCallback_Intf1_init.
 */
template<class T, typename CT>
class Callback_Intf1_init : public Callback_Intf1_init_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Intf1_init(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_init.
 */
template<class T, typename CT> Callback_Intf1_initPtr
newCallback_Intf1_init(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf1_init<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_init.
 */
template<class T, typename CT> Callback_Intf1_initPtr
newCallback_Intf1_init(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf1_init<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_init.
 */
template<class T, typename CT> Callback_Intf1_initPtr
newCallback_Intf1_init(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf1_init<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_init.
 */
template<class T, typename CT> Callback_Intf1_initPtr
newCallback_Intf1_init(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf1_init<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Intf1::begin_isProxy.
 * Create a wrapper instance by calling ::Test::newCallback_Intf1_isProxy.
 */
template<class T>
class CallbackNC_Intf1_isProxy : public Callback_Intf1_isProxy_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Intf1_isProxy(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_isProxy.
 */
template<class T> Callback_Intf1_isProxyPtr
newCallback_Intf1_isProxy(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf1_isProxy<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_isProxy.
 */
template<class T> Callback_Intf1_isProxyPtr
newCallback_Intf1_isProxy(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf1_isProxy<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_isProxy.
 */
template<class T> Callback_Intf1_isProxyPtr
newCallback_Intf1_isProxy(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf1_isProxy<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_isProxy.
 */
template<class T> Callback_Intf1_isProxyPtr
newCallback_Intf1_isProxy(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf1_isProxy<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Intf1::begin_isProxy.
 * Create a wrapper instance by calling ::Test::newCallback_Intf1_isProxy.
 */
template<class T, typename CT>
class Callback_Intf1_isProxy : public Callback_Intf1_isProxy_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Intf1_isProxy(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_isProxy.
 */
template<class T, typename CT> Callback_Intf1_isProxyPtr
newCallback_Intf1_isProxy(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf1_isProxy<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_isProxy.
 */
template<class T, typename CT> Callback_Intf1_isProxyPtr
newCallback_Intf1_isProxy(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf1_isProxy<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_isProxy.
 */
template<class T, typename CT> Callback_Intf1_isProxyPtr
newCallback_Intf1_isProxy(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf1_isProxy<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_isProxy.
 */
template<class T, typename CT> Callback_Intf1_isProxyPtr
newCallback_Intf1_isProxy(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf1_isProxy<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Intf1::begin_mutableCopy.
 * Create a wrapper instance by calling ::Test::newCallback_Intf1_mutableCopy.
 */
template<class T>
class CallbackNC_Intf1_mutableCopy : public Callback_Intf1_mutableCopy_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Intf1_mutableCopy(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_mutableCopy.
 */
template<class T> Callback_Intf1_mutableCopyPtr
newCallback_Intf1_mutableCopy(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf1_mutableCopy<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_mutableCopy.
 */
template<class T> Callback_Intf1_mutableCopyPtr
newCallback_Intf1_mutableCopy(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf1_mutableCopy<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_mutableCopy.
 */
template<class T> Callback_Intf1_mutableCopyPtr
newCallback_Intf1_mutableCopy(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf1_mutableCopy<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_mutableCopy.
 */
template<class T> Callback_Intf1_mutableCopyPtr
newCallback_Intf1_mutableCopy(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf1_mutableCopy<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Intf1::begin_mutableCopy.
 * Create a wrapper instance by calling ::Test::newCallback_Intf1_mutableCopy.
 */
template<class T, typename CT>
class Callback_Intf1_mutableCopy : public Callback_Intf1_mutableCopy_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Intf1_mutableCopy(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_mutableCopy.
 */
template<class T, typename CT> Callback_Intf1_mutableCopyPtr
newCallback_Intf1_mutableCopy(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf1_mutableCopy<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_mutableCopy.
 */
template<class T, typename CT> Callback_Intf1_mutableCopyPtr
newCallback_Intf1_mutableCopy(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf1_mutableCopy<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_mutableCopy.
 */
template<class T, typename CT> Callback_Intf1_mutableCopyPtr
newCallback_Intf1_mutableCopy(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf1_mutableCopy<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_mutableCopy.
 */
template<class T, typename CT> Callback_Intf1_mutableCopyPtr
newCallback_Intf1_mutableCopy(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf1_mutableCopy<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Intf1::begin_release.
 * Create a wrapper instance by calling ::Test::newCallback_Intf1_release.
 */
template<class T>
class CallbackNC_Intf1_release : public Callback_Intf1_release_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Intf1_release(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_release.
 */
template<class T> Callback_Intf1_releasePtr
newCallback_Intf1_release(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf1_release<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_release.
 */
template<class T> Callback_Intf1_releasePtr
newCallback_Intf1_release(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf1_release<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_release.
 */
template<class T> Callback_Intf1_releasePtr
newCallback_Intf1_release(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf1_release<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_release.
 */
template<class T> Callback_Intf1_releasePtr
newCallback_Intf1_release(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf1_release<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Intf1::begin_release.
 * Create a wrapper instance by calling ::Test::newCallback_Intf1_release.
 */
template<class T, typename CT>
class Callback_Intf1_release : public Callback_Intf1_release_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Intf1_release(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_release.
 */
template<class T, typename CT> Callback_Intf1_releasePtr
newCallback_Intf1_release(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf1_release<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_release.
 */
template<class T, typename CT> Callback_Intf1_releasePtr
newCallback_Intf1_release(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf1_release<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_release.
 */
template<class T, typename CT> Callback_Intf1_releasePtr
newCallback_Intf1_release(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf1_release<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_release.
 */
template<class T, typename CT> Callback_Intf1_releasePtr
newCallback_Intf1_release(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf1_release<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Intf1::begin_retain.
 * Create a wrapper instance by calling ::Test::newCallback_Intf1_retain.
 */
template<class T>
class CallbackNC_Intf1_retain : public Callback_Intf1_retain_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Intf1_retain(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_retain.
 */
template<class T> Callback_Intf1_retainPtr
newCallback_Intf1_retain(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf1_retain<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_retain.
 */
template<class T> Callback_Intf1_retainPtr
newCallback_Intf1_retain(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf1_retain<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_retain.
 */
template<class T> Callback_Intf1_retainPtr
newCallback_Intf1_retain(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf1_retain<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_retain.
 */
template<class T> Callback_Intf1_retainPtr
newCallback_Intf1_retain(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf1_retain<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Intf1::begin_retain.
 * Create a wrapper instance by calling ::Test::newCallback_Intf1_retain.
 */
template<class T, typename CT>
class Callback_Intf1_retain : public Callback_Intf1_retain_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Intf1_retain(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_retain.
 */
template<class T, typename CT> Callback_Intf1_retainPtr
newCallback_Intf1_retain(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf1_retain<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_retain.
 */
template<class T, typename CT> Callback_Intf1_retainPtr
newCallback_Intf1_retain(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf1_retain<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_retain.
 */
template<class T, typename CT> Callback_Intf1_retainPtr
newCallback_Intf1_retain(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf1_retain<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_retain.
 */
template<class T, typename CT> Callback_Intf1_retainPtr
newCallback_Intf1_retain(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf1_retain<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Intf1::begin_retainCount.
 * Create a wrapper instance by calling ::Test::newCallback_Intf1_retainCount.
 */
template<class T>
class CallbackNC_Intf1_retainCount : public Callback_Intf1_retainCount_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Intf1_retainCount(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_retainCount.
 */
template<class T> Callback_Intf1_retainCountPtr
newCallback_Intf1_retainCount(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf1_retainCount<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_retainCount.
 */
template<class T> Callback_Intf1_retainCountPtr
newCallback_Intf1_retainCount(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf1_retainCount<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_retainCount.
 */
template<class T> Callback_Intf1_retainCountPtr
newCallback_Intf1_retainCount(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf1_retainCount<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_retainCount.
 */
template<class T> Callback_Intf1_retainCountPtr
newCallback_Intf1_retainCount(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf1_retainCount<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Intf1::begin_retainCount.
 * Create a wrapper instance by calling ::Test::newCallback_Intf1_retainCount.
 */
template<class T, typename CT>
class Callback_Intf1_retainCount : public Callback_Intf1_retainCount_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Intf1_retainCount(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_retainCount.
 */
template<class T, typename CT> Callback_Intf1_retainCountPtr
newCallback_Intf1_retainCount(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf1_retainCount<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_retainCount.
 */
template<class T, typename CT> Callback_Intf1_retainCountPtr
newCallback_Intf1_retainCount(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf1_retainCount<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_retainCount.
 */
template<class T, typename CT> Callback_Intf1_retainCountPtr
newCallback_Intf1_retainCount(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf1_retainCount<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_retainCount.
 */
template<class T, typename CT> Callback_Intf1_retainCountPtr
newCallback_Intf1_retainCount(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf1_retainCount<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Intf1::begin_self.
 * Create a wrapper instance by calling ::Test::newCallback_Intf1_self.
 */
template<class T>
class CallbackNC_Intf1_self : public Callback_Intf1_self_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Intf1_self(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_self.
 */
template<class T> Callback_Intf1_selfPtr
newCallback_Intf1_self(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf1_self<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_self.
 */
template<class T> Callback_Intf1_selfPtr
newCallback_Intf1_self(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf1_self<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_self.
 */
template<class T> Callback_Intf1_selfPtr
newCallback_Intf1_self(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf1_self<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_self.
 */
template<class T> Callback_Intf1_selfPtr
newCallback_Intf1_self(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf1_self<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Intf1::begin_self.
 * Create a wrapper instance by calling ::Test::newCallback_Intf1_self.
 */
template<class T, typename CT>
class Callback_Intf1_self : public Callback_Intf1_self_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Intf1_self(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_self.
 */
template<class T, typename CT> Callback_Intf1_selfPtr
newCallback_Intf1_self(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf1_self<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_self.
 */
template<class T, typename CT> Callback_Intf1_selfPtr
newCallback_Intf1_self(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf1_self<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_self.
 */
template<class T, typename CT> Callback_Intf1_selfPtr
newCallback_Intf1_self(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf1_self<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_self.
 */
template<class T, typename CT> Callback_Intf1_selfPtr
newCallback_Intf1_self(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf1_self<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Intf1::begin_superclass.
 * Create a wrapper instance by calling ::Test::newCallback_Intf1_superclass.
 */
template<class T>
class CallbackNC_Intf1_superclass : public Callback_Intf1_superclass_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Intf1_superclass(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_superclass.
 */
template<class T> Callback_Intf1_superclassPtr
newCallback_Intf1_superclass(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf1_superclass<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_superclass.
 */
template<class T> Callback_Intf1_superclassPtr
newCallback_Intf1_superclass(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf1_superclass<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_superclass.
 */
template<class T> Callback_Intf1_superclassPtr
newCallback_Intf1_superclass(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf1_superclass<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_superclass.
 */
template<class T> Callback_Intf1_superclassPtr
newCallback_Intf1_superclass(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf1_superclass<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Intf1::begin_superclass.
 * Create a wrapper instance by calling ::Test::newCallback_Intf1_superclass.
 */
template<class T, typename CT>
class Callback_Intf1_superclass : public Callback_Intf1_superclass_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Intf1_superclass(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_superclass.
 */
template<class T, typename CT> Callback_Intf1_superclassPtr
newCallback_Intf1_superclass(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf1_superclass<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_superclass.
 */
template<class T, typename CT> Callback_Intf1_superclassPtr
newCallback_Intf1_superclass(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf1_superclass<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_superclass.
 */
template<class T, typename CT> Callback_Intf1_superclassPtr
newCallback_Intf1_superclass(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf1_superclass<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_superclass.
 */
template<class T, typename CT> Callback_Intf1_superclassPtr
newCallback_Intf1_superclass(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf1_superclass<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Intf1::begin_zone.
 * Create a wrapper instance by calling ::Test::newCallback_Intf1_zone.
 */
template<class T>
class CallbackNC_Intf1_zone : public Callback_Intf1_zone_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Intf1_zone(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_zone.
 */
template<class T> Callback_Intf1_zonePtr
newCallback_Intf1_zone(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf1_zone<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_zone.
 */
template<class T> Callback_Intf1_zonePtr
newCallback_Intf1_zone(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf1_zone<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_zone.
 */
template<class T> Callback_Intf1_zonePtr
newCallback_Intf1_zone(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf1_zone<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_zone.
 */
template<class T> Callback_Intf1_zonePtr
newCallback_Intf1_zone(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf1_zone<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Intf1::begin_zone.
 * Create a wrapper instance by calling ::Test::newCallback_Intf1_zone.
 */
template<class T, typename CT>
class Callback_Intf1_zone : public Callback_Intf1_zone_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Intf1_zone(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_zone.
 */
template<class T, typename CT> Callback_Intf1_zonePtr
newCallback_Intf1_zone(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf1_zone<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_zone.
 */
template<class T, typename CT> Callback_Intf1_zonePtr
newCallback_Intf1_zone(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf1_zone<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_zone.
 */
template<class T, typename CT> Callback_Intf1_zonePtr
newCallback_Intf1_zone(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf1_zone<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf1::begin_zone.
 */
template<class T, typename CT> Callback_Intf1_zonePtr
newCallback_Intf1_zone(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf1_zone<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Intf2::begin_isa.
 * Create a wrapper instance by calling ::Test::newCallback_Intf2_isa.
 */
template<class T>
class CallbackNC_Intf2_isa : public Callback_Intf2_isa_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Intf2_isa(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_isa.
 */
template<class T> Callback_Intf2_isaPtr
newCallback_Intf2_isa(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf2_isa<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_isa.
 */
template<class T> Callback_Intf2_isaPtr
newCallback_Intf2_isa(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf2_isa<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_isa.
 */
template<class T> Callback_Intf2_isaPtr
newCallback_Intf2_isa(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf2_isa<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_isa.
 */
template<class T> Callback_Intf2_isaPtr
newCallback_Intf2_isa(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf2_isa<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Intf2::begin_isa.
 * Create a wrapper instance by calling ::Test::newCallback_Intf2_isa.
 */
template<class T, typename CT>
class Callback_Intf2_isa : public Callback_Intf2_isa_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Intf2_isa(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_isa.
 */
template<class T, typename CT> Callback_Intf2_isaPtr
newCallback_Intf2_isa(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf2_isa<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_isa.
 */
template<class T, typename CT> Callback_Intf2_isaPtr
newCallback_Intf2_isa(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf2_isa<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_isa.
 */
template<class T, typename CT> Callback_Intf2_isaPtr
newCallback_Intf2_isa(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf2_isa<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_isa.
 */
template<class T, typename CT> Callback_Intf2_isaPtr
newCallback_Intf2_isa(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf2_isa<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Intf2::begin_reason.
 * Create a wrapper instance by calling ::Test::newCallback_Intf2_reason.
 */
template<class T>
class CallbackNC_Intf2_reason : public Callback_Intf2_reason_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Intf2_reason(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_reason.
 */
template<class T> Callback_Intf2_reasonPtr
newCallback_Intf2_reason(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf2_reason<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_reason.
 */
template<class T> Callback_Intf2_reasonPtr
newCallback_Intf2_reason(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf2_reason<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_reason.
 */
template<class T> Callback_Intf2_reasonPtr
newCallback_Intf2_reason(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf2_reason<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_reason.
 */
template<class T> Callback_Intf2_reasonPtr
newCallback_Intf2_reason(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf2_reason<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Intf2::begin_reason.
 * Create a wrapper instance by calling ::Test::newCallback_Intf2_reason.
 */
template<class T, typename CT>
class Callback_Intf2_reason : public Callback_Intf2_reason_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Intf2_reason(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_reason.
 */
template<class T, typename CT> Callback_Intf2_reasonPtr
newCallback_Intf2_reason(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf2_reason<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_reason.
 */
template<class T, typename CT> Callback_Intf2_reasonPtr
newCallback_Intf2_reason(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf2_reason<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_reason.
 */
template<class T, typename CT> Callback_Intf2_reasonPtr
newCallback_Intf2_reason(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf2_reason<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_reason.
 */
template<class T, typename CT> Callback_Intf2_reasonPtr
newCallback_Intf2_reason(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf2_reason<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Intf2::begin_autorelease.
 * Create a wrapper instance by calling ::Test::newCallback_Intf2_autorelease.
 */
template<class T>
class CallbackNC_Intf2_autorelease : public Callback_Intf2_autorelease_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Intf2_autorelease(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_autorelease.
 */
template<class T> Callback_Intf2_autoreleasePtr
newCallback_Intf2_autorelease(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf2_autorelease<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_autorelease.
 */
template<class T> Callback_Intf2_autoreleasePtr
newCallback_Intf2_autorelease(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf2_autorelease<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_autorelease.
 */
template<class T> Callback_Intf2_autoreleasePtr
newCallback_Intf2_autorelease(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf2_autorelease<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_autorelease.
 */
template<class T> Callback_Intf2_autoreleasePtr
newCallback_Intf2_autorelease(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf2_autorelease<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Intf2::begin_autorelease.
 * Create a wrapper instance by calling ::Test::newCallback_Intf2_autorelease.
 */
template<class T, typename CT>
class Callback_Intf2_autorelease : public Callback_Intf2_autorelease_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Intf2_autorelease(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_autorelease.
 */
template<class T, typename CT> Callback_Intf2_autoreleasePtr
newCallback_Intf2_autorelease(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf2_autorelease<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_autorelease.
 */
template<class T, typename CT> Callback_Intf2_autoreleasePtr
newCallback_Intf2_autorelease(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf2_autorelease<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_autorelease.
 */
template<class T, typename CT> Callback_Intf2_autoreleasePtr
newCallback_Intf2_autorelease(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf2_autorelease<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_autorelease.
 */
template<class T, typename CT> Callback_Intf2_autoreleasePtr
newCallback_Intf2_autorelease(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf2_autorelease<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Intf2::begin_classForCoder.
 * Create a wrapper instance by calling ::Test::newCallback_Intf2_classForCoder.
 */
template<class T>
class CallbackNC_Intf2_classForCoder : public Callback_Intf2_classForCoder_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Intf2_classForCoder(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_classForCoder.
 */
template<class T> Callback_Intf2_classForCoderPtr
newCallback_Intf2_classForCoder(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf2_classForCoder<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_classForCoder.
 */
template<class T> Callback_Intf2_classForCoderPtr
newCallback_Intf2_classForCoder(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf2_classForCoder<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_classForCoder.
 */
template<class T> Callback_Intf2_classForCoderPtr
newCallback_Intf2_classForCoder(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf2_classForCoder<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_classForCoder.
 */
template<class T> Callback_Intf2_classForCoderPtr
newCallback_Intf2_classForCoder(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf2_classForCoder<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Intf2::begin_classForCoder.
 * Create a wrapper instance by calling ::Test::newCallback_Intf2_classForCoder.
 */
template<class T, typename CT>
class Callback_Intf2_classForCoder : public Callback_Intf2_classForCoder_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Intf2_classForCoder(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_classForCoder.
 */
template<class T, typename CT> Callback_Intf2_classForCoderPtr
newCallback_Intf2_classForCoder(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf2_classForCoder<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_classForCoder.
 */
template<class T, typename CT> Callback_Intf2_classForCoderPtr
newCallback_Intf2_classForCoder(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf2_classForCoder<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_classForCoder.
 */
template<class T, typename CT> Callback_Intf2_classForCoderPtr
newCallback_Intf2_classForCoder(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf2_classForCoder<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_classForCoder.
 */
template<class T, typename CT> Callback_Intf2_classForCoderPtr
newCallback_Intf2_classForCoder(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf2_classForCoder<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Intf2::begin_copy.
 * Create a wrapper instance by calling ::Test::newCallback_Intf2_copy.
 */
template<class T>
class CallbackNC_Intf2_copy : public Callback_Intf2_copy_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Intf2_copy(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_copy.
 */
template<class T> Callback_Intf2_copyPtr
newCallback_Intf2_copy(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf2_copy<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_copy.
 */
template<class T> Callback_Intf2_copyPtr
newCallback_Intf2_copy(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf2_copy<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_copy.
 */
template<class T> Callback_Intf2_copyPtr
newCallback_Intf2_copy(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf2_copy<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_copy.
 */
template<class T> Callback_Intf2_copyPtr
newCallback_Intf2_copy(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf2_copy<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Intf2::begin_copy.
 * Create a wrapper instance by calling ::Test::newCallback_Intf2_copy.
 */
template<class T, typename CT>
class Callback_Intf2_copy : public Callback_Intf2_copy_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Intf2_copy(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_copy.
 */
template<class T, typename CT> Callback_Intf2_copyPtr
newCallback_Intf2_copy(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf2_copy<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_copy.
 */
template<class T, typename CT> Callback_Intf2_copyPtr
newCallback_Intf2_copy(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf2_copy<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_copy.
 */
template<class T, typename CT> Callback_Intf2_copyPtr
newCallback_Intf2_copy(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf2_copy<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_copy.
 */
template<class T, typename CT> Callback_Intf2_copyPtr
newCallback_Intf2_copy(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf2_copy<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Intf2::begin_dealloc.
 * Create a wrapper instance by calling ::Test::newCallback_Intf2_dealloc.
 */
template<class T>
class CallbackNC_Intf2_dealloc : public Callback_Intf2_dealloc_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Intf2_dealloc(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_dealloc.
 */
template<class T> Callback_Intf2_deallocPtr
newCallback_Intf2_dealloc(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf2_dealloc<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_dealloc.
 */
template<class T> Callback_Intf2_deallocPtr
newCallback_Intf2_dealloc(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf2_dealloc<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_dealloc.
 */
template<class T> Callback_Intf2_deallocPtr
newCallback_Intf2_dealloc(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf2_dealloc<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_dealloc.
 */
template<class T> Callback_Intf2_deallocPtr
newCallback_Intf2_dealloc(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf2_dealloc<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Intf2::begin_dealloc.
 * Create a wrapper instance by calling ::Test::newCallback_Intf2_dealloc.
 */
template<class T, typename CT>
class Callback_Intf2_dealloc : public Callback_Intf2_dealloc_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Intf2_dealloc(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_dealloc.
 */
template<class T, typename CT> Callback_Intf2_deallocPtr
newCallback_Intf2_dealloc(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf2_dealloc<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_dealloc.
 */
template<class T, typename CT> Callback_Intf2_deallocPtr
newCallback_Intf2_dealloc(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf2_dealloc<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_dealloc.
 */
template<class T, typename CT> Callback_Intf2_deallocPtr
newCallback_Intf2_dealloc(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf2_dealloc<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_dealloc.
 */
template<class T, typename CT> Callback_Intf2_deallocPtr
newCallback_Intf2_dealloc(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf2_dealloc<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Intf2::begin_description.
 * Create a wrapper instance by calling ::Test::newCallback_Intf2_description.
 */
template<class T>
class CallbackNC_Intf2_description : public Callback_Intf2_description_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Intf2_description(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_description.
 */
template<class T> Callback_Intf2_descriptionPtr
newCallback_Intf2_description(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf2_description<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_description.
 */
template<class T> Callback_Intf2_descriptionPtr
newCallback_Intf2_description(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf2_description<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_description.
 */
template<class T> Callback_Intf2_descriptionPtr
newCallback_Intf2_description(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf2_description<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_description.
 */
template<class T> Callback_Intf2_descriptionPtr
newCallback_Intf2_description(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf2_description<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Intf2::begin_description.
 * Create a wrapper instance by calling ::Test::newCallback_Intf2_description.
 */
template<class T, typename CT>
class Callback_Intf2_description : public Callback_Intf2_description_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Intf2_description(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_description.
 */
template<class T, typename CT> Callback_Intf2_descriptionPtr
newCallback_Intf2_description(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf2_description<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_description.
 */
template<class T, typename CT> Callback_Intf2_descriptionPtr
newCallback_Intf2_description(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf2_description<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_description.
 */
template<class T, typename CT> Callback_Intf2_descriptionPtr
newCallback_Intf2_description(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf2_description<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_description.
 */
template<class T, typename CT> Callback_Intf2_descriptionPtr
newCallback_Intf2_description(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf2_description<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Intf2::begin_hash.
 * Create a wrapper instance by calling ::Test::newCallback_Intf2_hash.
 */
template<class T>
class CallbackNC_Intf2_hash : public Callback_Intf2_hash_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Intf2_hash(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_hash.
 */
template<class T> Callback_Intf2_hashPtr
newCallback_Intf2_hash(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf2_hash<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_hash.
 */
template<class T> Callback_Intf2_hashPtr
newCallback_Intf2_hash(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf2_hash<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_hash.
 */
template<class T> Callback_Intf2_hashPtr
newCallback_Intf2_hash(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf2_hash<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_hash.
 */
template<class T> Callback_Intf2_hashPtr
newCallback_Intf2_hash(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf2_hash<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Intf2::begin_hash.
 * Create a wrapper instance by calling ::Test::newCallback_Intf2_hash.
 */
template<class T, typename CT>
class Callback_Intf2_hash : public Callback_Intf2_hash_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Intf2_hash(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_hash.
 */
template<class T, typename CT> Callback_Intf2_hashPtr
newCallback_Intf2_hash(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf2_hash<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_hash.
 */
template<class T, typename CT> Callback_Intf2_hashPtr
newCallback_Intf2_hash(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf2_hash<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_hash.
 */
template<class T, typename CT> Callback_Intf2_hashPtr
newCallback_Intf2_hash(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf2_hash<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_hash.
 */
template<class T, typename CT> Callback_Intf2_hashPtr
newCallback_Intf2_hash(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf2_hash<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Intf2::begin_init.
 * Create a wrapper instance by calling ::Test::newCallback_Intf2_init.
 */
template<class T>
class CallbackNC_Intf2_init : public Callback_Intf2_init_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Intf2_init(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_init.
 */
template<class T> Callback_Intf2_initPtr
newCallback_Intf2_init(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf2_init<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_init.
 */
template<class T> Callback_Intf2_initPtr
newCallback_Intf2_init(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf2_init<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_init.
 */
template<class T> Callback_Intf2_initPtr
newCallback_Intf2_init(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf2_init<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_init.
 */
template<class T> Callback_Intf2_initPtr
newCallback_Intf2_init(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf2_init<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Intf2::begin_init.
 * Create a wrapper instance by calling ::Test::newCallback_Intf2_init.
 */
template<class T, typename CT>
class Callback_Intf2_init : public Callback_Intf2_init_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Intf2_init(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_init.
 */
template<class T, typename CT> Callback_Intf2_initPtr
newCallback_Intf2_init(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf2_init<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_init.
 */
template<class T, typename CT> Callback_Intf2_initPtr
newCallback_Intf2_init(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf2_init<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_init.
 */
template<class T, typename CT> Callback_Intf2_initPtr
newCallback_Intf2_init(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf2_init<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_init.
 */
template<class T, typename CT> Callback_Intf2_initPtr
newCallback_Intf2_init(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf2_init<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Intf2::begin_isProxy.
 * Create a wrapper instance by calling ::Test::newCallback_Intf2_isProxy.
 */
template<class T>
class CallbackNC_Intf2_isProxy : public Callback_Intf2_isProxy_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Intf2_isProxy(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_isProxy.
 */
template<class T> Callback_Intf2_isProxyPtr
newCallback_Intf2_isProxy(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf2_isProxy<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_isProxy.
 */
template<class T> Callback_Intf2_isProxyPtr
newCallback_Intf2_isProxy(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf2_isProxy<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_isProxy.
 */
template<class T> Callback_Intf2_isProxyPtr
newCallback_Intf2_isProxy(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf2_isProxy<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_isProxy.
 */
template<class T> Callback_Intf2_isProxyPtr
newCallback_Intf2_isProxy(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf2_isProxy<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Intf2::begin_isProxy.
 * Create a wrapper instance by calling ::Test::newCallback_Intf2_isProxy.
 */
template<class T, typename CT>
class Callback_Intf2_isProxy : public Callback_Intf2_isProxy_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Intf2_isProxy(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_isProxy.
 */
template<class T, typename CT> Callback_Intf2_isProxyPtr
newCallback_Intf2_isProxy(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf2_isProxy<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_isProxy.
 */
template<class T, typename CT> Callback_Intf2_isProxyPtr
newCallback_Intf2_isProxy(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf2_isProxy<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_isProxy.
 */
template<class T, typename CT> Callback_Intf2_isProxyPtr
newCallback_Intf2_isProxy(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf2_isProxy<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_isProxy.
 */
template<class T, typename CT> Callback_Intf2_isProxyPtr
newCallback_Intf2_isProxy(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf2_isProxy<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Intf2::begin_mutableCopy.
 * Create a wrapper instance by calling ::Test::newCallback_Intf2_mutableCopy.
 */
template<class T>
class CallbackNC_Intf2_mutableCopy : public Callback_Intf2_mutableCopy_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Intf2_mutableCopy(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_mutableCopy.
 */
template<class T> Callback_Intf2_mutableCopyPtr
newCallback_Intf2_mutableCopy(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf2_mutableCopy<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_mutableCopy.
 */
template<class T> Callback_Intf2_mutableCopyPtr
newCallback_Intf2_mutableCopy(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf2_mutableCopy<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_mutableCopy.
 */
template<class T> Callback_Intf2_mutableCopyPtr
newCallback_Intf2_mutableCopy(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf2_mutableCopy<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_mutableCopy.
 */
template<class T> Callback_Intf2_mutableCopyPtr
newCallback_Intf2_mutableCopy(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf2_mutableCopy<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Intf2::begin_mutableCopy.
 * Create a wrapper instance by calling ::Test::newCallback_Intf2_mutableCopy.
 */
template<class T, typename CT>
class Callback_Intf2_mutableCopy : public Callback_Intf2_mutableCopy_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Intf2_mutableCopy(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_mutableCopy.
 */
template<class T, typename CT> Callback_Intf2_mutableCopyPtr
newCallback_Intf2_mutableCopy(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf2_mutableCopy<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_mutableCopy.
 */
template<class T, typename CT> Callback_Intf2_mutableCopyPtr
newCallback_Intf2_mutableCopy(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf2_mutableCopy<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_mutableCopy.
 */
template<class T, typename CT> Callback_Intf2_mutableCopyPtr
newCallback_Intf2_mutableCopy(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf2_mutableCopy<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_mutableCopy.
 */
template<class T, typename CT> Callback_Intf2_mutableCopyPtr
newCallback_Intf2_mutableCopy(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf2_mutableCopy<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Intf2::begin_release.
 * Create a wrapper instance by calling ::Test::newCallback_Intf2_release.
 */
template<class T>
class CallbackNC_Intf2_release : public Callback_Intf2_release_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Intf2_release(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_release.
 */
template<class T> Callback_Intf2_releasePtr
newCallback_Intf2_release(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf2_release<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_release.
 */
template<class T> Callback_Intf2_releasePtr
newCallback_Intf2_release(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf2_release<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_release.
 */
template<class T> Callback_Intf2_releasePtr
newCallback_Intf2_release(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf2_release<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_release.
 */
template<class T> Callback_Intf2_releasePtr
newCallback_Intf2_release(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf2_release<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Intf2::begin_release.
 * Create a wrapper instance by calling ::Test::newCallback_Intf2_release.
 */
template<class T, typename CT>
class Callback_Intf2_release : public Callback_Intf2_release_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Intf2_release(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_release.
 */
template<class T, typename CT> Callback_Intf2_releasePtr
newCallback_Intf2_release(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf2_release<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_release.
 */
template<class T, typename CT> Callback_Intf2_releasePtr
newCallback_Intf2_release(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf2_release<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_release.
 */
template<class T, typename CT> Callback_Intf2_releasePtr
newCallback_Intf2_release(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf2_release<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_release.
 */
template<class T, typename CT> Callback_Intf2_releasePtr
newCallback_Intf2_release(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf2_release<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Intf2::begin_retain.
 * Create a wrapper instance by calling ::Test::newCallback_Intf2_retain.
 */
template<class T>
class CallbackNC_Intf2_retain : public Callback_Intf2_retain_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Intf2_retain(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_retain.
 */
template<class T> Callback_Intf2_retainPtr
newCallback_Intf2_retain(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf2_retain<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_retain.
 */
template<class T> Callback_Intf2_retainPtr
newCallback_Intf2_retain(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf2_retain<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_retain.
 */
template<class T> Callback_Intf2_retainPtr
newCallback_Intf2_retain(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf2_retain<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_retain.
 */
template<class T> Callback_Intf2_retainPtr
newCallback_Intf2_retain(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf2_retain<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Intf2::begin_retain.
 * Create a wrapper instance by calling ::Test::newCallback_Intf2_retain.
 */
template<class T, typename CT>
class Callback_Intf2_retain : public Callback_Intf2_retain_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Intf2_retain(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_retain.
 */
template<class T, typename CT> Callback_Intf2_retainPtr
newCallback_Intf2_retain(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf2_retain<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_retain.
 */
template<class T, typename CT> Callback_Intf2_retainPtr
newCallback_Intf2_retain(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf2_retain<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_retain.
 */
template<class T, typename CT> Callback_Intf2_retainPtr
newCallback_Intf2_retain(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf2_retain<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_retain.
 */
template<class T, typename CT> Callback_Intf2_retainPtr
newCallback_Intf2_retain(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf2_retain<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Intf2::begin_retainCount.
 * Create a wrapper instance by calling ::Test::newCallback_Intf2_retainCount.
 */
template<class T>
class CallbackNC_Intf2_retainCount : public Callback_Intf2_retainCount_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Intf2_retainCount(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_retainCount.
 */
template<class T> Callback_Intf2_retainCountPtr
newCallback_Intf2_retainCount(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf2_retainCount<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_retainCount.
 */
template<class T> Callback_Intf2_retainCountPtr
newCallback_Intf2_retainCount(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf2_retainCount<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_retainCount.
 */
template<class T> Callback_Intf2_retainCountPtr
newCallback_Intf2_retainCount(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf2_retainCount<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_retainCount.
 */
template<class T> Callback_Intf2_retainCountPtr
newCallback_Intf2_retainCount(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf2_retainCount<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Intf2::begin_retainCount.
 * Create a wrapper instance by calling ::Test::newCallback_Intf2_retainCount.
 */
template<class T, typename CT>
class Callback_Intf2_retainCount : public Callback_Intf2_retainCount_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Intf2_retainCount(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_retainCount.
 */
template<class T, typename CT> Callback_Intf2_retainCountPtr
newCallback_Intf2_retainCount(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf2_retainCount<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_retainCount.
 */
template<class T, typename CT> Callback_Intf2_retainCountPtr
newCallback_Intf2_retainCount(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf2_retainCount<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_retainCount.
 */
template<class T, typename CT> Callback_Intf2_retainCountPtr
newCallback_Intf2_retainCount(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf2_retainCount<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_retainCount.
 */
template<class T, typename CT> Callback_Intf2_retainCountPtr
newCallback_Intf2_retainCount(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf2_retainCount<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Intf2::begin_self.
 * Create a wrapper instance by calling ::Test::newCallback_Intf2_self.
 */
template<class T>
class CallbackNC_Intf2_self : public Callback_Intf2_self_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Intf2_self(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_self.
 */
template<class T> Callback_Intf2_selfPtr
newCallback_Intf2_self(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf2_self<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_self.
 */
template<class T> Callback_Intf2_selfPtr
newCallback_Intf2_self(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf2_self<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_self.
 */
template<class T> Callback_Intf2_selfPtr
newCallback_Intf2_self(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf2_self<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_self.
 */
template<class T> Callback_Intf2_selfPtr
newCallback_Intf2_self(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf2_self<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Intf2::begin_self.
 * Create a wrapper instance by calling ::Test::newCallback_Intf2_self.
 */
template<class T, typename CT>
class Callback_Intf2_self : public Callback_Intf2_self_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Intf2_self(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_self.
 */
template<class T, typename CT> Callback_Intf2_selfPtr
newCallback_Intf2_self(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf2_self<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_self.
 */
template<class T, typename CT> Callback_Intf2_selfPtr
newCallback_Intf2_self(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf2_self<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_self.
 */
template<class T, typename CT> Callback_Intf2_selfPtr
newCallback_Intf2_self(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf2_self<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_self.
 */
template<class T, typename CT> Callback_Intf2_selfPtr
newCallback_Intf2_self(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf2_self<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Intf2::begin_superclass.
 * Create a wrapper instance by calling ::Test::newCallback_Intf2_superclass.
 */
template<class T>
class CallbackNC_Intf2_superclass : public Callback_Intf2_superclass_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Intf2_superclass(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_superclass.
 */
template<class T> Callback_Intf2_superclassPtr
newCallback_Intf2_superclass(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf2_superclass<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_superclass.
 */
template<class T> Callback_Intf2_superclassPtr
newCallback_Intf2_superclass(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf2_superclass<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_superclass.
 */
template<class T> Callback_Intf2_superclassPtr
newCallback_Intf2_superclass(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf2_superclass<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_superclass.
 */
template<class T> Callback_Intf2_superclassPtr
newCallback_Intf2_superclass(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf2_superclass<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Intf2::begin_superclass.
 * Create a wrapper instance by calling ::Test::newCallback_Intf2_superclass.
 */
template<class T, typename CT>
class Callback_Intf2_superclass : public Callback_Intf2_superclass_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Intf2_superclass(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_superclass.
 */
template<class T, typename CT> Callback_Intf2_superclassPtr
newCallback_Intf2_superclass(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf2_superclass<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_superclass.
 */
template<class T, typename CT> Callback_Intf2_superclassPtr
newCallback_Intf2_superclass(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf2_superclass<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_superclass.
 */
template<class T, typename CT> Callback_Intf2_superclassPtr
newCallback_Intf2_superclass(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf2_superclass<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_superclass.
 */
template<class T, typename CT> Callback_Intf2_superclassPtr
newCallback_Intf2_superclass(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf2_superclass<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Intf2::begin_zone.
 * Create a wrapper instance by calling ::Test::newCallback_Intf2_zone.
 */
template<class T>
class CallbackNC_Intf2_zone : public Callback_Intf2_zone_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Intf2_zone(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_zone.
 */
template<class T> Callback_Intf2_zonePtr
newCallback_Intf2_zone(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf2_zone<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_zone.
 */
template<class T> Callback_Intf2_zonePtr
newCallback_Intf2_zone(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf2_zone<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_zone.
 */
template<class T> Callback_Intf2_zonePtr
newCallback_Intf2_zone(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf2_zone<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_zone.
 */
template<class T> Callback_Intf2_zonePtr
newCallback_Intf2_zone(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Intf2_zone<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Intf2::begin_zone.
 * Create a wrapper instance by calling ::Test::newCallback_Intf2_zone.
 */
template<class T, typename CT>
class Callback_Intf2_zone : public Callback_Intf2_zone_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Intf2_zone(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_zone.
 */
template<class T, typename CT> Callback_Intf2_zonePtr
newCallback_Intf2_zone(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf2_zone<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_zone.
 */
template<class T, typename CT> Callback_Intf2_zonePtr
newCallback_Intf2_zone(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf2_zone<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_zone.
 */
template<class T, typename CT> Callback_Intf2_zonePtr
newCallback_Intf2_zone(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf2_zone<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Intf2::begin_zone.
 */
template<class T, typename CT> Callback_Intf2_zonePtr
newCallback_Intf2_zone(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Intf2_zone<T, CT>(instance, 0, excb, sentcb);
}

}

#endif

#include <IceUtil/PopDisableWarnings.h>
#endif
