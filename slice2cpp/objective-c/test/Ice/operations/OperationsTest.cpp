//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.7.9
//
// <auto-generated>
//
// Generated from file `OperationsTest.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#include <OperationsTest.h>
#include <IceUtil/PushDisableWarnings.h>
#include <Ice/LocalException.h>
#include <Ice/ValueFactory.h>
#include <Ice/OutgoingAsync.h>
#include <Ice/InputStream.h>
#include <Ice/OutputStream.h>
#include <IceUtil/PopDisableWarnings.h>

#if defined(_MSC_VER)
#   pragma warning(disable:4458) // declaration of ... hides class member
#elif defined(__clang__)
#   pragma clang diagnostic ignored "-Wshadow"
#elif defined(__GNUC__)
#   pragma GCC diagnostic ignored "-Wshadow"
#endif

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 307
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 >= 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 9
#       error Ice patch level mismatch!
#   endif
#endif

#ifdef ICE_CPP11_MAPPING // C++11 mapping

namespace
{

const ::IceInternal::DefaultValueFactoryInit<::Test::A> iceC_Test_A_init("::Test::A");

const ::std::string iceC_Test_MyClass_ids[2] =
{
    "::Ice::Object",
    "::Test::MyClass"
};
const ::std::string iceC_Test_MyClass_ops[] =
{
    "getNSNullASeq",
    "getNSNullStringSeq",
    "getNSNullStringSeqSeq",
    "getNSNullStringStringDict",
    "getNSNullStructSeq",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "opBool",
    "opBoolBoolSD",
    "opBoolS",
    "opBoolSS",
    "opByte",
    "opByte1",
    "opByteBoolD",
    "opByteBoolD1",
    "opByteBoolD2",
    "opByteBoolDS",
    "opByteByteSD",
    "opByteS",
    "opByteSOneway",
    "opByteSOnewayCallCount",
    "opByteSS",
    "opContext",
    "opDouble1",
    "opDoubleMarshaling",
    "opFloat1",
    "opFloatDouble",
    "opFloatDoubleS",
    "opFloatDoubleSS",
    "opIdempotent",
    "opInt1",
    "opIntIntSD",
    "opIntS",
    "opLong1",
    "opLongFloatD",
    "opLongFloatDS",
    "opLongLongSD",
    "opMDict1",
    "opMDict2",
    "opMSeq1",
    "opMSeq2",
    "opMStruct1",
    "opMStruct2",
    "opMyClass",
    "opMyClassS",
    "opMyEnum",
    "opMyEnumMyEnumSD",
    "opMyEnumS",
    "opMyEnumStringD",
    "opMyEnumStringDS",
    "opMyStructMyEnumD",
    "opMyStructMyEnumDS",
    "opNonmutating",
    "opShort1",
    "opShortIntD",
    "opShortIntDS",
    "opShortIntLong",
    "opShortIntLongS",
    "opShortIntLongSS",
    "opShortShortSD",
    "opString",
    "opString1",
    "opStringDoubleSD",
    "opStringFloatSD",
    "opStringLiterals",
    "opStringMyEnumD",
    "opStringMyEnumDS",
    "opStringS",
    "opStringS1",
    "opStringS2",
    "opStringSS",
    "opStringSSS",
    "opStringStringD",
    "opStringStringDS",
    "opStringStringSD",
    "opStruct",
    "opVoid",
    "opWStringLiterals",
    "putNSNullShortIntDict",
    "putNSNullStringMyEnumDict",
    "putNSNullStringStringDict",
    "shutdown",
    "supportsCompress"
};
const ::std::string iceC_Test_MyClass_shutdown_name = "shutdown";
const ::std::string iceC_Test_MyClass_supportsCompress_name = "supportsCompress";
const ::std::string iceC_Test_MyClass_opVoid_name = "opVoid";
const ::std::string iceC_Test_MyClass_opByte_name = "opByte";
const ::std::string iceC_Test_MyClass_opBool_name = "opBool";
const ::std::string iceC_Test_MyClass_opShortIntLong_name = "opShortIntLong";
const ::std::string iceC_Test_MyClass_opFloatDouble_name = "opFloatDouble";
const ::std::string iceC_Test_MyClass_opString_name = "opString";
const ::std::string iceC_Test_MyClass_opMyEnum_name = "opMyEnum";
const ::std::string iceC_Test_MyClass_opMyClass_name = "opMyClass";
const ::std::string iceC_Test_MyClass_opStruct_name = "opStruct";
const ::std::string iceC_Test_MyClass_opByteS_name = "opByteS";
const ::std::string iceC_Test_MyClass_opBoolS_name = "opBoolS";
const ::std::string iceC_Test_MyClass_opShortIntLongS_name = "opShortIntLongS";
const ::std::string iceC_Test_MyClass_opFloatDoubleS_name = "opFloatDoubleS";
const ::std::string iceC_Test_MyClass_opStringS_name = "opStringS";
const ::std::string iceC_Test_MyClass_opMyEnumS_name = "opMyEnumS";
const ::std::string iceC_Test_MyClass_opMyClassS_name = "opMyClassS";
const ::std::string iceC_Test_MyClass_opByteSS_name = "opByteSS";
const ::std::string iceC_Test_MyClass_opBoolSS_name = "opBoolSS";
const ::std::string iceC_Test_MyClass_opShortIntLongSS_name = "opShortIntLongSS";
const ::std::string iceC_Test_MyClass_opFloatDoubleSS_name = "opFloatDoubleSS";
const ::std::string iceC_Test_MyClass_opStringSS_name = "opStringSS";
const ::std::string iceC_Test_MyClass_opStringSSS_name = "opStringSSS";
const ::std::string iceC_Test_MyClass_opByteBoolD_name = "opByteBoolD";
const ::std::string iceC_Test_MyClass_opShortIntD_name = "opShortIntD";
const ::std::string iceC_Test_MyClass_opLongFloatD_name = "opLongFloatD";
const ::std::string iceC_Test_MyClass_opStringStringD_name = "opStringStringD";
const ::std::string iceC_Test_MyClass_opStringMyEnumD_name = "opStringMyEnumD";
const ::std::string iceC_Test_MyClass_opMyEnumStringD_name = "opMyEnumStringD";
const ::std::string iceC_Test_MyClass_opMyStructMyEnumD_name = "opMyStructMyEnumD";
const ::std::string iceC_Test_MyClass_opByteBoolDS_name = "opByteBoolDS";
const ::std::string iceC_Test_MyClass_opShortIntDS_name = "opShortIntDS";
const ::std::string iceC_Test_MyClass_opLongFloatDS_name = "opLongFloatDS";
const ::std::string iceC_Test_MyClass_opStringStringDS_name = "opStringStringDS";
const ::std::string iceC_Test_MyClass_opStringMyEnumDS_name = "opStringMyEnumDS";
const ::std::string iceC_Test_MyClass_opMyEnumStringDS_name = "opMyEnumStringDS";
const ::std::string iceC_Test_MyClass_opMyStructMyEnumDS_name = "opMyStructMyEnumDS";
const ::std::string iceC_Test_MyClass_opByteByteSD_name = "opByteByteSD";
const ::std::string iceC_Test_MyClass_opBoolBoolSD_name = "opBoolBoolSD";
const ::std::string iceC_Test_MyClass_opShortShortSD_name = "opShortShortSD";
const ::std::string iceC_Test_MyClass_opIntIntSD_name = "opIntIntSD";
const ::std::string iceC_Test_MyClass_opLongLongSD_name = "opLongLongSD";
const ::std::string iceC_Test_MyClass_opStringFloatSD_name = "opStringFloatSD";
const ::std::string iceC_Test_MyClass_opStringDoubleSD_name = "opStringDoubleSD";
const ::std::string iceC_Test_MyClass_opStringStringSD_name = "opStringStringSD";
const ::std::string iceC_Test_MyClass_opMyEnumMyEnumSD_name = "opMyEnumMyEnumSD";
const ::std::string iceC_Test_MyClass_opIntS_name = "opIntS";
const ::std::string iceC_Test_MyClass_opByteSOneway_name = "opByteSOneway";
const ::std::string iceC_Test_MyClass_opByteSOnewayCallCount_name = "opByteSOnewayCallCount";
const ::std::string iceC_Test_MyClass_opContext_name = "opContext";
const ::std::string iceC_Test_MyClass_opDoubleMarshaling_name = "opDoubleMarshaling";
const ::std::string iceC_Test_MyClass_opIdempotent_name = "opIdempotent";
const ::std::string iceC_Test_MyClass_opNonmutating_name = "opNonmutating";
const ::std::string iceC_Test_MyClass_opByte1_name = "opByte1";
const ::std::string iceC_Test_MyClass_opShort1_name = "opShort1";
const ::std::string iceC_Test_MyClass_opInt1_name = "opInt1";
const ::std::string iceC_Test_MyClass_opLong1_name = "opLong1";
const ::std::string iceC_Test_MyClass_opFloat1_name = "opFloat1";
const ::std::string iceC_Test_MyClass_opDouble1_name = "opDouble1";
const ::std::string iceC_Test_MyClass_opString1_name = "opString1";
const ::std::string iceC_Test_MyClass_opStringS1_name = "opStringS1";
const ::std::string iceC_Test_MyClass_opByteBoolD1_name = "opByteBoolD1";
const ::std::string iceC_Test_MyClass_opStringS2_name = "opStringS2";
const ::std::string iceC_Test_MyClass_opByteBoolD2_name = "opByteBoolD2";
const ::std::string iceC_Test_MyClass_opStringLiterals_name = "opStringLiterals";
const ::std::string iceC_Test_MyClass_opWStringLiterals_name = "opWStringLiterals";
const ::std::string iceC_Test_MyClass_opMStruct1_name = "opMStruct1";
const ::std::string iceC_Test_MyClass_opMStruct2_name = "opMStruct2";
const ::std::string iceC_Test_MyClass_opMSeq1_name = "opMSeq1";
const ::std::string iceC_Test_MyClass_opMSeq2_name = "opMSeq2";
const ::std::string iceC_Test_MyClass_opMDict1_name = "opMDict1";
const ::std::string iceC_Test_MyClass_opMDict2_name = "opMDict2";
const ::std::string iceC_Test_MyClass_getNSNullStringSeq_name = "getNSNullStringSeq";
const ::std::string iceC_Test_MyClass_getNSNullASeq_name = "getNSNullASeq";
const ::std::string iceC_Test_MyClass_getNSNullStructSeq_name = "getNSNullStructSeq";
const ::std::string iceC_Test_MyClass_getNSNullStringSeqSeq_name = "getNSNullStringSeqSeq";
const ::std::string iceC_Test_MyClass_getNSNullStringStringDict_name = "getNSNullStringStringDict";
const ::std::string iceC_Test_MyClass_putNSNullStringStringDict_name = "putNSNullStringStringDict";
const ::std::string iceC_Test_MyClass_putNSNullShortIntDict_name = "putNSNullShortIntDict";
const ::std::string iceC_Test_MyClass_putNSNullStringMyEnumDict_name = "putNSNullStringMyEnumDict";

const ::IceInternal::DefaultValueFactoryInit<::Test::MyClass1> iceC_Test_MyClass1_init("::Test::MyClass1");

const ::std::string iceC_Test_MyDerivedClass_ids[3] =
{
    "::Ice::Object",
    "::Test::MyClass",
    "::Test::MyDerivedClass"
};
const ::std::string iceC_Test_MyDerivedClass_ops[] =
{
    "getNSNullASeq",
    "getNSNullStringSeq",
    "getNSNullStringSeqSeq",
    "getNSNullStringStringDict",
    "getNSNullStructSeq",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "opBool",
    "opBoolBoolSD",
    "opBoolS",
    "opBoolSS",
    "opByte",
    "opByte1",
    "opByteBoolD",
    "opByteBoolD1",
    "opByteBoolD2",
    "opByteBoolDS",
    "opByteByteSD",
    "opByteS",
    "opByteSOneway",
    "opByteSOnewayCallCount",
    "opByteSS",
    "opContext",
    "opDerived",
    "opDouble1",
    "opDoubleMarshaling",
    "opFloat1",
    "opFloatDouble",
    "opFloatDoubleS",
    "opFloatDoubleSS",
    "opIdempotent",
    "opInt1",
    "opIntIntSD",
    "opIntS",
    "opLong1",
    "opLongFloatD",
    "opLongFloatDS",
    "opLongLongSD",
    "opMDict1",
    "opMDict2",
    "opMSeq1",
    "opMSeq2",
    "opMStruct1",
    "opMStruct2",
    "opMyClass",
    "opMyClass1",
    "opMyClassS",
    "opMyEnum",
    "opMyEnumMyEnumSD",
    "opMyEnumS",
    "opMyEnumStringD",
    "opMyEnumStringDS",
    "opMyStruct1",
    "opMyStructMyEnumD",
    "opMyStructMyEnumDS",
    "opNonmutating",
    "opShort1",
    "opShortIntD",
    "opShortIntDS",
    "opShortIntLong",
    "opShortIntLongS",
    "opShortIntLongSS",
    "opShortShortSD",
    "opString",
    "opString1",
    "opStringDoubleSD",
    "opStringFloatSD",
    "opStringLiterals",
    "opStringMyEnumD",
    "opStringMyEnumDS",
    "opStringS",
    "opStringS1",
    "opStringS2",
    "opStringSS",
    "opStringSSS",
    "opStringStringD",
    "opStringStringDS",
    "opStringStringSD",
    "opStruct",
    "opVoid",
    "opWStringLiterals",
    "putNSNullShortIntDict",
    "putNSNullStringMyEnumDict",
    "putNSNullStringStringDict",
    "shutdown",
    "supportsCompress"
};
const ::std::string iceC_Test_MyDerivedClass_opDerived_name = "opDerived";
const ::std::string iceC_Test_MyDerivedClass_opMyClass1_name = "opMyClass1";
const ::std::string iceC_Test_MyDerivedClass_opMyStruct1_name = "opMyStruct1";

const ::std::string iceC_Test2_MyDerivedClass_ids[3] =
{
    "::Ice::Object",
    "::Test2::MyDerivedClass",
    "::Test::MyClass"
};
const ::std::string iceC_Test2_MyDerivedClass_ops[] =
{
    "getNSNullASeq",
    "getNSNullStringSeq",
    "getNSNullStringSeqSeq",
    "getNSNullStringStringDict",
    "getNSNullStructSeq",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "opBool",
    "opBoolBoolSD",
    "opBoolS",
    "opBoolSS",
    "opByte",
    "opByte1",
    "opByteBoolD",
    "opByteBoolD1",
    "opByteBoolD2",
    "opByteBoolDS",
    "opByteByteSD",
    "opByteS",
    "opByteSOneway",
    "opByteSOnewayCallCount",
    "opByteSS",
    "opContext",
    "opDouble1",
    "opDoubleMarshaling",
    "opFloat1",
    "opFloatDouble",
    "opFloatDoubleS",
    "opFloatDoubleSS",
    "opIdempotent",
    "opInt1",
    "opIntIntSD",
    "opIntS",
    "opLong1",
    "opLongFloatD",
    "opLongFloatDS",
    "opLongLongSD",
    "opMDict1",
    "opMDict2",
    "opMSeq1",
    "opMSeq2",
    "opMStruct1",
    "opMStruct2",
    "opMyClass",
    "opMyClassS",
    "opMyEnum",
    "opMyEnumMyEnumSD",
    "opMyEnumS",
    "opMyEnumStringD",
    "opMyEnumStringDS",
    "opMyStructMyEnumD",
    "opMyStructMyEnumDS",
    "opNonmutating",
    "opShort1",
    "opShortIntD",
    "opShortIntDS",
    "opShortIntLong",
    "opShortIntLongS",
    "opShortIntLongSS",
    "opShortShortSD",
    "opString",
    "opString1",
    "opStringDoubleSD",
    "opStringFloatSD",
    "opStringLiterals",
    "opStringMyEnumD",
    "opStringMyEnumDS",
    "opStringS",
    "opStringS1",
    "opStringS2",
    "opStringSS",
    "opStringSSS",
    "opStringStringD",
    "opStringStringDS",
    "opStringStringSD",
    "opStruct",
    "opVoid",
    "opWStringLiterals",
    "putNSNullShortIntDict",
    "putNSNullStringMyEnumDict",
    "putNSNullStringStringDict",
    "shutdown",
    "supportsCompress"
};

const ::IceInternal::DefaultValueFactoryInit<::M::A> iceC_M_A_init("::M::A");

const ::std::string iceC_M_Intf_ids[2] =
{
    "::Ice::Object",
    "::M::Intf"
};
const ::std::string iceC_M_Intf_ops[] =
{
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "opIntf"
};
const ::std::string iceC_M_Intf_opIntf_name = "opIntf";

const ::IceInternal::DefaultValueFactoryInit<::M::B> iceC_M_B_init("::M::B");

const ::std::string iceC_M_B_ids[4] =
{
    "::Ice::Object",
    "::M::A",
    "::M::B",
    "::M::Intf"
};
const ::std::string iceC_M_B_ops[] =
{
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "opB",
    "opIntf"
};
const ::std::string iceC_M_B_opB_name = "opB";

}

bool
Test::MyClass::ice_isA(::std::string s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_MyClass_ids, iceC_Test_MyClass_ids + 2, s);
}

::std::vector<::std::string>
Test::MyClass::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector<::std::string>(&iceC_Test_MyClass_ids[0], &iceC_Test_MyClass_ids[2]);
}

::std::string
Test::MyClass::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::MyClass::ice_staticId()
{
    static const ::std::string typeId = "::Test::MyClass";
    return typeId;
}

/// \cond INTERNAL
bool
Test::MyClass::_iceD_shutdown(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    this->shutdown(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_supportsCompress(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    bool ret = this->supportsCompress(current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opVoid(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    this->opVoid(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opByte(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::Ice::Byte iceP_p1;
    ::Ice::Byte iceP_p2;
    istr->readAll(iceP_p1, iceP_p2);
    inS.endReadParams();
    ::Ice::Byte iceP_p3;
    ::Ice::Byte ret = this->opByte(iceP_p1, iceP_p2, iceP_p3, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_p3, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opBool(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    bool iceP_p1;
    bool iceP_p2;
    istr->readAll(iceP_p1, iceP_p2);
    inS.endReadParams();
    bool iceP_p3;
    bool ret = this->opBool(iceP_p1, iceP_p2, iceP_p3, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_p3, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opShortIntLong(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    short iceP_p1;
    int iceP_p2;
    long long int iceP_p3;
    istr->readAll(iceP_p1, iceP_p2, iceP_p3);
    inS.endReadParams();
    short iceP_p4;
    int iceP_p5;
    long long int iceP_p6;
    long long int ret = this->opShortIntLong(iceP_p1, iceP_p2, iceP_p3, iceP_p4, iceP_p5, iceP_p6, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_p4, iceP_p5, iceP_p6, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opFloatDouble(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    float iceP_p1;
    double iceP_p2;
    istr->readAll(iceP_p1, iceP_p2);
    inS.endReadParams();
    float iceP_p3;
    double iceP_p4;
    double ret = this->opFloatDouble(iceP_p1, iceP_p2, iceP_p3, iceP_p4, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_p3, iceP_p4, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opString(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_p1;
    ::std::string iceP_p2;
    istr->readAll(iceP_p1, iceP_p2);
    inS.endReadParams();
    ::std::string iceP_p3;
    ::std::string ret = this->opString(::std::move(iceP_p1), ::std::move(iceP_p2), iceP_p3, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_p3, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opMyEnum(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    MyEnum iceP_p1;
    istr->readAll(iceP_p1);
    inS.endReadParams();
    MyEnum iceP_p2;
    MyEnum ret = this->opMyEnum(iceP_p1, iceP_p2, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_p2, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opMyClass(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::shared_ptr<MyClassPrx> iceP_p1;
    istr->readAll(iceP_p1);
    inS.endReadParams();
    ::std::shared_ptr<MyClassPrx> iceP_p2;
    ::std::shared_ptr<MyClassPrx> iceP_p3;
    ::std::shared_ptr<MyClassPrx> ret = this->opMyClass(::std::move(iceP_p1), iceP_p2, iceP_p3, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_p2, iceP_p3, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opStruct(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    Structure iceP_p1;
    Structure iceP_p2;
    istr->readAll(iceP_p1, iceP_p2);
    inS.endReadParams();
    Structure iceP_p3;
    Structure ret = this->opStruct(::std::move(iceP_p1), ::std::move(iceP_p2), iceP_p3, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_p3, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opByteS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ByteS iceP_p1;
    ByteS iceP_p2;
    istr->readAll(iceP_p1, iceP_p2);
    inS.endReadParams();
    ByteS iceP_p3;
    ByteS ret = this->opByteS(::std::move(iceP_p1), ::std::move(iceP_p2), iceP_p3, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_p3, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opBoolS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    BoolS iceP_p1;
    BoolS iceP_p2;
    istr->readAll(iceP_p1, iceP_p2);
    inS.endReadParams();
    BoolS iceP_p3;
    BoolS ret = this->opBoolS(::std::move(iceP_p1), ::std::move(iceP_p2), iceP_p3, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_p3, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opShortIntLongS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ShortS iceP_p1;
    IntS iceP_p2;
    LongS iceP_p3;
    istr->readAll(iceP_p1, iceP_p2, iceP_p3);
    inS.endReadParams();
    ShortS iceP_p4;
    IntS iceP_p5;
    LongS iceP_p6;
    LongS ret = this->opShortIntLongS(::std::move(iceP_p1), ::std::move(iceP_p2), ::std::move(iceP_p3), iceP_p4, iceP_p5, iceP_p6, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_p4, iceP_p5, iceP_p6, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opFloatDoubleS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    FloatS iceP_p1;
    DoubleS iceP_p2;
    istr->readAll(iceP_p1, iceP_p2);
    inS.endReadParams();
    FloatS iceP_p3;
    DoubleS iceP_p4;
    DoubleS ret = this->opFloatDoubleS(::std::move(iceP_p1), ::std::move(iceP_p2), iceP_p3, iceP_p4, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_p3, iceP_p4, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opStringS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    StringS iceP_p1;
    StringS iceP_p2;
    istr->readAll(iceP_p1, iceP_p2);
    inS.endReadParams();
    StringS iceP_p3;
    StringS ret = this->opStringS(::std::move(iceP_p1), ::std::move(iceP_p2), iceP_p3, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_p3, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opMyEnumS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    MyEnumS iceP_p1;
    MyEnumS iceP_p2;
    istr->readAll(iceP_p1, iceP_p2);
    inS.endReadParams();
    MyEnumS iceP_p3;
    MyEnumS ret = this->opMyEnumS(::std::move(iceP_p1), ::std::move(iceP_p2), iceP_p3, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_p3, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opMyClassS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    MyClassS iceP_p1;
    MyClassS iceP_p2;
    istr->readAll(iceP_p1, iceP_p2);
    inS.endReadParams();
    MyClassS iceP_p3;
    MyClassS ret = this->opMyClassS(::std::move(iceP_p1), ::std::move(iceP_p2), iceP_p3, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_p3, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opByteSS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ByteSS iceP_p1;
    ByteSS iceP_p2;
    istr->readAll(iceP_p1, iceP_p2);
    inS.endReadParams();
    ByteSS iceP_p3;
    ByteSS ret = this->opByteSS(::std::move(iceP_p1), ::std::move(iceP_p2), iceP_p3, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_p3, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opBoolSS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    BoolSS iceP_p1;
    BoolSS iceP_p2;
    istr->readAll(iceP_p1, iceP_p2);
    inS.endReadParams();
    BoolSS iceP_p3;
    BoolSS ret = this->opBoolSS(::std::move(iceP_p1), ::std::move(iceP_p2), iceP_p3, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_p3, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opShortIntLongSS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ShortSS iceP_p1;
    IntSS iceP_p2;
    LongSS iceP_p3;
    istr->readAll(iceP_p1, iceP_p2, iceP_p3);
    inS.endReadParams();
    ShortSS iceP_p4;
    IntSS iceP_p5;
    LongSS iceP_p6;
    LongSS ret = this->opShortIntLongSS(::std::move(iceP_p1), ::std::move(iceP_p2), ::std::move(iceP_p3), iceP_p4, iceP_p5, iceP_p6, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_p4, iceP_p5, iceP_p6, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opFloatDoubleSS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    FloatSS iceP_p1;
    DoubleSS iceP_p2;
    istr->readAll(iceP_p1, iceP_p2);
    inS.endReadParams();
    FloatSS iceP_p3;
    DoubleSS iceP_p4;
    DoubleSS ret = this->opFloatDoubleSS(::std::move(iceP_p1), ::std::move(iceP_p2), iceP_p3, iceP_p4, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_p3, iceP_p4, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opStringSS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    StringSS iceP_p1;
    StringSS iceP_p2;
    istr->readAll(iceP_p1, iceP_p2);
    inS.endReadParams();
    StringSS iceP_p3;
    StringSS ret = this->opStringSS(::std::move(iceP_p1), ::std::move(iceP_p2), iceP_p3, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_p3, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opStringSSS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    StringSSS iceP_p1;
    StringSSS iceP_p2;
    istr->readAll(iceP_p1, iceP_p2);
    inS.endReadParams();
    StringSSS iceP_p3;
    StringSSS ret = this->opStringSSS(::std::move(iceP_p1), ::std::move(iceP_p2), iceP_p3, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_p3, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opByteBoolD(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ByteBoolD iceP_p1;
    ByteBoolD iceP_p2;
    istr->readAll(iceP_p1, iceP_p2);
    inS.endReadParams();
    ByteBoolD iceP_p3;
    ByteBoolD ret = this->opByteBoolD(::std::move(iceP_p1), ::std::move(iceP_p2), iceP_p3, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_p3, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opShortIntD(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ShortIntD iceP_p1;
    ShortIntD iceP_p2;
    istr->readAll(iceP_p1, iceP_p2);
    inS.endReadParams();
    ShortIntD iceP_p3;
    ShortIntD ret = this->opShortIntD(::std::move(iceP_p1), ::std::move(iceP_p2), iceP_p3, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_p3, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opLongFloatD(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    LongFloatD iceP_p1;
    LongFloatD iceP_p2;
    istr->readAll(iceP_p1, iceP_p2);
    inS.endReadParams();
    LongFloatD iceP_p3;
    LongFloatD ret = this->opLongFloatD(::std::move(iceP_p1), ::std::move(iceP_p2), iceP_p3, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_p3, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opStringStringD(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    StringStringD iceP_p1;
    StringStringD iceP_p2;
    istr->readAll(iceP_p1, iceP_p2);
    inS.endReadParams();
    StringStringD iceP_p3;
    StringStringD ret = this->opStringStringD(::std::move(iceP_p1), ::std::move(iceP_p2), iceP_p3, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_p3, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opStringMyEnumD(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    StringMyEnumD iceP_p1;
    StringMyEnumD iceP_p2;
    istr->readAll(iceP_p1, iceP_p2);
    inS.endReadParams();
    StringMyEnumD iceP_p3;
    StringMyEnumD ret = this->opStringMyEnumD(::std::move(iceP_p1), ::std::move(iceP_p2), iceP_p3, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_p3, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opMyEnumStringD(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    MyEnumStringD iceP_p1;
    MyEnumStringD iceP_p2;
    istr->readAll(iceP_p1, iceP_p2);
    inS.endReadParams();
    MyEnumStringD iceP_p3;
    MyEnumStringD ret = this->opMyEnumStringD(::std::move(iceP_p1), ::std::move(iceP_p2), iceP_p3, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_p3, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opMyStructMyEnumD(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    MyStructMyEnumD iceP_p1;
    MyStructMyEnumD iceP_p2;
    istr->readAll(iceP_p1, iceP_p2);
    inS.endReadParams();
    MyStructMyEnumD iceP_p3;
    MyStructMyEnumD ret = this->opMyStructMyEnumD(::std::move(iceP_p1), ::std::move(iceP_p2), iceP_p3, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_p3, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opByteBoolDS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ByteBoolDS iceP_p1;
    ByteBoolDS iceP_p2;
    istr->readAll(iceP_p1, iceP_p2);
    inS.endReadParams();
    ByteBoolDS iceP_p3;
    ByteBoolDS ret = this->opByteBoolDS(::std::move(iceP_p1), ::std::move(iceP_p2), iceP_p3, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_p3, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opShortIntDS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ShortIntDS iceP_p1;
    ShortIntDS iceP_p2;
    istr->readAll(iceP_p1, iceP_p2);
    inS.endReadParams();
    ShortIntDS iceP_p3;
    ShortIntDS ret = this->opShortIntDS(::std::move(iceP_p1), ::std::move(iceP_p2), iceP_p3, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_p3, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opLongFloatDS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    LongFloatDS iceP_p1;
    LongFloatDS iceP_p2;
    istr->readAll(iceP_p1, iceP_p2);
    inS.endReadParams();
    LongFloatDS iceP_p3;
    LongFloatDS ret = this->opLongFloatDS(::std::move(iceP_p1), ::std::move(iceP_p2), iceP_p3, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_p3, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opStringStringDS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    StringStringDS iceP_p1;
    StringStringDS iceP_p2;
    istr->readAll(iceP_p1, iceP_p2);
    inS.endReadParams();
    StringStringDS iceP_p3;
    StringStringDS ret = this->opStringStringDS(::std::move(iceP_p1), ::std::move(iceP_p2), iceP_p3, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_p3, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opStringMyEnumDS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    StringMyEnumDS iceP_p1;
    StringMyEnumDS iceP_p2;
    istr->readAll(iceP_p1, iceP_p2);
    inS.endReadParams();
    StringMyEnumDS iceP_p3;
    StringMyEnumDS ret = this->opStringMyEnumDS(::std::move(iceP_p1), ::std::move(iceP_p2), iceP_p3, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_p3, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opMyEnumStringDS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    MyEnumStringDS iceP_p1;
    MyEnumStringDS iceP_p2;
    istr->readAll(iceP_p1, iceP_p2);
    inS.endReadParams();
    MyEnumStringDS iceP_p3;
    MyEnumStringDS ret = this->opMyEnumStringDS(::std::move(iceP_p1), ::std::move(iceP_p2), iceP_p3, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_p3, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opMyStructMyEnumDS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    MyStructMyEnumDS iceP_p1;
    MyStructMyEnumDS iceP_p2;
    istr->readAll(iceP_p1, iceP_p2);
    inS.endReadParams();
    MyStructMyEnumDS iceP_p3;
    MyStructMyEnumDS ret = this->opMyStructMyEnumDS(::std::move(iceP_p1), ::std::move(iceP_p2), iceP_p3, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_p3, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opByteByteSD(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ByteByteSD iceP_p1;
    ByteByteSD iceP_p2;
    istr->readAll(iceP_p1, iceP_p2);
    inS.endReadParams();
    ByteByteSD iceP_p3;
    ByteByteSD ret = this->opByteByteSD(::std::move(iceP_p1), ::std::move(iceP_p2), iceP_p3, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_p3, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opBoolBoolSD(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    BoolBoolSD iceP_p1;
    BoolBoolSD iceP_p2;
    istr->readAll(iceP_p1, iceP_p2);
    inS.endReadParams();
    BoolBoolSD iceP_p3;
    BoolBoolSD ret = this->opBoolBoolSD(::std::move(iceP_p1), ::std::move(iceP_p2), iceP_p3, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_p3, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opShortShortSD(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ShortShortSD iceP_p1;
    ShortShortSD iceP_p2;
    istr->readAll(iceP_p1, iceP_p2);
    inS.endReadParams();
    ShortShortSD iceP_p3;
    ShortShortSD ret = this->opShortShortSD(::std::move(iceP_p1), ::std::move(iceP_p2), iceP_p3, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_p3, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opIntIntSD(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    IntIntSD iceP_p1;
    IntIntSD iceP_p2;
    istr->readAll(iceP_p1, iceP_p2);
    inS.endReadParams();
    IntIntSD iceP_p3;
    IntIntSD ret = this->opIntIntSD(::std::move(iceP_p1), ::std::move(iceP_p2), iceP_p3, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_p3, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opLongLongSD(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    LongLongSD iceP_p1;
    LongLongSD iceP_p2;
    istr->readAll(iceP_p1, iceP_p2);
    inS.endReadParams();
    LongLongSD iceP_p3;
    LongLongSD ret = this->opLongLongSD(::std::move(iceP_p1), ::std::move(iceP_p2), iceP_p3, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_p3, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opStringFloatSD(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    StringFloatSD iceP_p1;
    StringFloatSD iceP_p2;
    istr->readAll(iceP_p1, iceP_p2);
    inS.endReadParams();
    StringFloatSD iceP_p3;
    StringFloatSD ret = this->opStringFloatSD(::std::move(iceP_p1), ::std::move(iceP_p2), iceP_p3, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_p3, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opStringDoubleSD(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    StringDoubleSD iceP_p1;
    StringDoubleSD iceP_p2;
    istr->readAll(iceP_p1, iceP_p2);
    inS.endReadParams();
    StringDoubleSD iceP_p3;
    StringDoubleSD ret = this->opStringDoubleSD(::std::move(iceP_p1), ::std::move(iceP_p2), iceP_p3, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_p3, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opStringStringSD(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    StringStringSD iceP_p1;
    StringStringSD iceP_p2;
    istr->readAll(iceP_p1, iceP_p2);
    inS.endReadParams();
    StringStringSD iceP_p3;
    StringStringSD ret = this->opStringStringSD(::std::move(iceP_p1), ::std::move(iceP_p2), iceP_p3, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_p3, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opMyEnumMyEnumSD(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    MyEnumMyEnumSD iceP_p1;
    MyEnumMyEnumSD iceP_p2;
    istr->readAll(iceP_p1, iceP_p2);
    inS.endReadParams();
    MyEnumMyEnumSD iceP_p3;
    MyEnumMyEnumSD ret = this->opMyEnumMyEnumSD(::std::move(iceP_p1), ::std::move(iceP_p2), iceP_p3, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_p3, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opIntS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    IntS iceP_s;
    istr->readAll(iceP_s);
    inS.endReadParams();
    IntS ret = this->opIntS(::std::move(iceP_s), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opByteSOneway(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ByteS iceP_s;
    istr->readAll(iceP_s);
    inS.endReadParams();
    this->opByteSOneway(::std::move(iceP_s), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opByteSOnewayCallCount(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    int ret = this->opByteSOnewayCallCount(current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opContext(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    ::Ice::Context ret = this->opContext(current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opDoubleMarshaling(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    double iceP_p1;
    DoubleS iceP_p2;
    istr->readAll(iceP_p1, iceP_p2);
    inS.endReadParams();
    this->opDoubleMarshaling(iceP_p1, ::std::move(iceP_p2), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opIdempotent(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    inS.readEmptyParams();
    this->opIdempotent(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opNonmutating(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Idempotent, current.mode);
    inS.readEmptyParams();
    this->opNonmutating(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opByte1(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::Ice::Byte iceP_opByte1;
    istr->readAll(iceP_opByte1);
    inS.endReadParams();
    ::Ice::Byte ret = this->opByte1(iceP_opByte1, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opShort1(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    short iceP_opShort1;
    istr->readAll(iceP_opShort1);
    inS.endReadParams();
    short ret = this->opShort1(iceP_opShort1, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opInt1(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    int iceP_opInt1;
    istr->readAll(iceP_opInt1);
    inS.endReadParams();
    int ret = this->opInt1(iceP_opInt1, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opLong1(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    long long int iceP_opLong1;
    istr->readAll(iceP_opLong1);
    inS.endReadParams();
    long long int ret = this->opLong1(iceP_opLong1, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opFloat1(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    float iceP_opFloat1;
    istr->readAll(iceP_opFloat1);
    inS.endReadParams();
    float ret = this->opFloat1(iceP_opFloat1, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opDouble1(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    double iceP_opDouble1;
    istr->readAll(iceP_opDouble1);
    inS.endReadParams();
    double ret = this->opDouble1(iceP_opDouble1, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opString1(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_opString1;
    istr->readAll(iceP_opString1);
    inS.endReadParams();
    ::std::string ret = this->opString1(::std::move(iceP_opString1), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opStringS1(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    StringS iceP_opStringS1;
    istr->readAll(iceP_opStringS1);
    inS.endReadParams();
    StringS ret = this->opStringS1(::std::move(iceP_opStringS1), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opByteBoolD1(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ByteBoolD iceP_opByteBoolD1;
    istr->readAll(iceP_opByteBoolD1);
    inS.endReadParams();
    ByteBoolD ret = this->opByteBoolD1(::std::move(iceP_opByteBoolD1), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opStringS2(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    StringS iceP_stringS;
    istr->readAll(iceP_stringS);
    inS.endReadParams();
    StringS ret = this->opStringS2(::std::move(iceP_stringS), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opByteBoolD2(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ByteBoolD iceP_byteBoolD;
    istr->readAll(iceP_byteBoolD);
    inS.endReadParams();
    ByteBoolD ret = this->opByteBoolD2(::std::move(iceP_byteBoolD), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opStringLiterals(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    StringS ret = this->opStringLiterals(current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opWStringLiterals(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    StringS ret = this->opWStringLiterals(current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

Test::MyClass::OpMStruct1MarshaledResult::OpMStruct1MarshaledResult(const Structure& ret, const ::Ice::Current& current):
    MarshaledResult(current)
{
    ostr->startEncapsulation(current.encoding, ::Ice::FormatType::DefaultFormat);
    ostr->writeAll(ret);
    ostr->endEncapsulation();
}

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opMStruct1(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    inS.setMarshaledResult(this->opMStruct1(current));
    return true;
}
/// \endcond

Test::MyClass::OpMStruct2MarshaledResult::OpMStruct2MarshaledResult(const Structure& ret, const Structure& iceP_p2, const ::Ice::Current& current):
    MarshaledResult(current)
{
    ostr->startEncapsulation(current.encoding, ::Ice::FormatType::DefaultFormat);
    ostr->writeAll(iceP_p2, ret);
    ostr->endEncapsulation();
}

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opMStruct2(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    Structure iceP_p1;
    istr->readAll(iceP_p1);
    inS.endReadParams();
    inS.setMarshaledResult(this->opMStruct2(::std::move(iceP_p1), current));
    return true;
}
/// \endcond

Test::MyClass::OpMSeq1MarshaledResult::OpMSeq1MarshaledResult(const StringS& ret, const ::Ice::Current& current):
    MarshaledResult(current)
{
    ostr->startEncapsulation(current.encoding, ::Ice::FormatType::DefaultFormat);
    ostr->writeAll(ret);
    ostr->endEncapsulation();
}

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opMSeq1(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    inS.setMarshaledResult(this->opMSeq1(current));
    return true;
}
/// \endcond

Test::MyClass::OpMSeq2MarshaledResult::OpMSeq2MarshaledResult(const StringS& ret, const StringS& iceP_p2, const ::Ice::Current& current):
    MarshaledResult(current)
{
    ostr->startEncapsulation(current.encoding, ::Ice::FormatType::DefaultFormat);
    ostr->writeAll(iceP_p2, ret);
    ostr->endEncapsulation();
}

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opMSeq2(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    StringS iceP_p1;
    istr->readAll(iceP_p1);
    inS.endReadParams();
    inS.setMarshaledResult(this->opMSeq2(::std::move(iceP_p1), current));
    return true;
}
/// \endcond

Test::MyClass::OpMDict1MarshaledResult::OpMDict1MarshaledResult(const StringStringD& ret, const ::Ice::Current& current):
    MarshaledResult(current)
{
    ostr->startEncapsulation(current.encoding, ::Ice::FormatType::DefaultFormat);
    ostr->writeAll(ret);
    ostr->endEncapsulation();
}

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opMDict1(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    inS.setMarshaledResult(this->opMDict1(current));
    return true;
}
/// \endcond

Test::MyClass::OpMDict2MarshaledResult::OpMDict2MarshaledResult(const StringStringD& ret, const StringStringD& iceP_p2, const ::Ice::Current& current):
    MarshaledResult(current)
{
    ostr->startEncapsulation(current.encoding, ::Ice::FormatType::DefaultFormat);
    ostr->writeAll(iceP_p2, ret);
    ostr->endEncapsulation();
}

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opMDict2(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    StringStringD iceP_p1;
    istr->readAll(iceP_p1);
    inS.endReadParams();
    inS.setMarshaledResult(this->opMDict2(::std::move(iceP_p1), current));
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_getNSNullStringSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    StringS ret = this->getNSNullStringSeq(current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_getNSNullASeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    AS ret = this->getNSNullASeq(current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_getNSNullStructSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    StructS ret = this->getNSNullStructSeq(current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_getNSNullStringSeqSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    StringSS ret = this->getNSNullStringSeqSeq(current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_getNSNullStringStringDict(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    StringStringD ret = this->getNSNullStringStringDict(current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_putNSNullStringStringDict(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    StringStringD iceP_d;
    istr->readAll(iceP_d);
    inS.endReadParams();
    this->putNSNullStringStringDict(::std::move(iceP_d), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_putNSNullShortIntDict(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ShortIntD iceP_d;
    istr->readAll(iceP_d);
    inS.endReadParams();
    this->putNSNullShortIntDict(::std::move(iceP_d), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_putNSNullStringMyEnumDict(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    StringMyEnumD iceP_d;
    istr->readAll(iceP_d);
    inS.endReadParams();
    this->putNSNullStringMyEnumDict(::std::move(iceP_d), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_Test_MyClass_ops, iceC_Test_MyClass_ops + 85, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_Test_MyClass_ops)
    {
        case 0:
        {
            return _iceD_getNSNullASeq(in, current);
        }
        case 1:
        {
            return _iceD_getNSNullStringSeq(in, current);
        }
        case 2:
        {
            return _iceD_getNSNullStringSeqSeq(in, current);
        }
        case 3:
        {
            return _iceD_getNSNullStringStringDict(in, current);
        }
        case 4:
        {
            return _iceD_getNSNullStructSeq(in, current);
        }
        case 5:
        {
            return _iceD_ice_id(in, current);
        }
        case 6:
        {
            return _iceD_ice_ids(in, current);
        }
        case 7:
        {
            return _iceD_ice_isA(in, current);
        }
        case 8:
        {
            return _iceD_ice_ping(in, current);
        }
        case 9:
        {
            return _iceD_opBool(in, current);
        }
        case 10:
        {
            return _iceD_opBoolBoolSD(in, current);
        }
        case 11:
        {
            return _iceD_opBoolS(in, current);
        }
        case 12:
        {
            return _iceD_opBoolSS(in, current);
        }
        case 13:
        {
            return _iceD_opByte(in, current);
        }
        case 14:
        {
            return _iceD_opByte1(in, current);
        }
        case 15:
        {
            return _iceD_opByteBoolD(in, current);
        }
        case 16:
        {
            return _iceD_opByteBoolD1(in, current);
        }
        case 17:
        {
            return _iceD_opByteBoolD2(in, current);
        }
        case 18:
        {
            return _iceD_opByteBoolDS(in, current);
        }
        case 19:
        {
            return _iceD_opByteByteSD(in, current);
        }
        case 20:
        {
            return _iceD_opByteS(in, current);
        }
        case 21:
        {
            return _iceD_opByteSOneway(in, current);
        }
        case 22:
        {
            return _iceD_opByteSOnewayCallCount(in, current);
        }
        case 23:
        {
            return _iceD_opByteSS(in, current);
        }
        case 24:
        {
            return _iceD_opContext(in, current);
        }
        case 25:
        {
            return _iceD_opDouble1(in, current);
        }
        case 26:
        {
            return _iceD_opDoubleMarshaling(in, current);
        }
        case 27:
        {
            return _iceD_opFloat1(in, current);
        }
        case 28:
        {
            return _iceD_opFloatDouble(in, current);
        }
        case 29:
        {
            return _iceD_opFloatDoubleS(in, current);
        }
        case 30:
        {
            return _iceD_opFloatDoubleSS(in, current);
        }
        case 31:
        {
            return _iceD_opIdempotent(in, current);
        }
        case 32:
        {
            return _iceD_opInt1(in, current);
        }
        case 33:
        {
            return _iceD_opIntIntSD(in, current);
        }
        case 34:
        {
            return _iceD_opIntS(in, current);
        }
        case 35:
        {
            return _iceD_opLong1(in, current);
        }
        case 36:
        {
            return _iceD_opLongFloatD(in, current);
        }
        case 37:
        {
            return _iceD_opLongFloatDS(in, current);
        }
        case 38:
        {
            return _iceD_opLongLongSD(in, current);
        }
        case 39:
        {
            return _iceD_opMDict1(in, current);
        }
        case 40:
        {
            return _iceD_opMDict2(in, current);
        }
        case 41:
        {
            return _iceD_opMSeq1(in, current);
        }
        case 42:
        {
            return _iceD_opMSeq2(in, current);
        }
        case 43:
        {
            return _iceD_opMStruct1(in, current);
        }
        case 44:
        {
            return _iceD_opMStruct2(in, current);
        }
        case 45:
        {
            return _iceD_opMyClass(in, current);
        }
        case 46:
        {
            return _iceD_opMyClassS(in, current);
        }
        case 47:
        {
            return _iceD_opMyEnum(in, current);
        }
        case 48:
        {
            return _iceD_opMyEnumMyEnumSD(in, current);
        }
        case 49:
        {
            return _iceD_opMyEnumS(in, current);
        }
        case 50:
        {
            return _iceD_opMyEnumStringD(in, current);
        }
        case 51:
        {
            return _iceD_opMyEnumStringDS(in, current);
        }
        case 52:
        {
            return _iceD_opMyStructMyEnumD(in, current);
        }
        case 53:
        {
            return _iceD_opMyStructMyEnumDS(in, current);
        }
        case 54:
        {
            return _iceD_opNonmutating(in, current);
        }
        case 55:
        {
            return _iceD_opShort1(in, current);
        }
        case 56:
        {
            return _iceD_opShortIntD(in, current);
        }
        case 57:
        {
            return _iceD_opShortIntDS(in, current);
        }
        case 58:
        {
            return _iceD_opShortIntLong(in, current);
        }
        case 59:
        {
            return _iceD_opShortIntLongS(in, current);
        }
        case 60:
        {
            return _iceD_opShortIntLongSS(in, current);
        }
        case 61:
        {
            return _iceD_opShortShortSD(in, current);
        }
        case 62:
        {
            return _iceD_opString(in, current);
        }
        case 63:
        {
            return _iceD_opString1(in, current);
        }
        case 64:
        {
            return _iceD_opStringDoubleSD(in, current);
        }
        case 65:
        {
            return _iceD_opStringFloatSD(in, current);
        }
        case 66:
        {
            return _iceD_opStringLiterals(in, current);
        }
        case 67:
        {
            return _iceD_opStringMyEnumD(in, current);
        }
        case 68:
        {
            return _iceD_opStringMyEnumDS(in, current);
        }
        case 69:
        {
            return _iceD_opStringS(in, current);
        }
        case 70:
        {
            return _iceD_opStringS1(in, current);
        }
        case 71:
        {
            return _iceD_opStringS2(in, current);
        }
        case 72:
        {
            return _iceD_opStringSS(in, current);
        }
        case 73:
        {
            return _iceD_opStringSSS(in, current);
        }
        case 74:
        {
            return _iceD_opStringStringD(in, current);
        }
        case 75:
        {
            return _iceD_opStringStringDS(in, current);
        }
        case 76:
        {
            return _iceD_opStringStringSD(in, current);
        }
        case 77:
        {
            return _iceD_opStruct(in, current);
        }
        case 78:
        {
            return _iceD_opVoid(in, current);
        }
        case 79:
        {
            return _iceD_opWStringLiterals(in, current);
        }
        case 80:
        {
            return _iceD_putNSNullShortIntDict(in, current);
        }
        case 81:
        {
            return _iceD_putNSNullStringMyEnumDict(in, current);
        }
        case 82:
        {
            return _iceD_putNSNullStringStringDict(in, current);
        }
        case 83:
        {
            return _iceD_shutdown(in, current);
        }
        case 84:
        {
            return _iceD_supportsCompress(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

bool
Test::MyDerivedClass::ice_isA(::std::string s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_MyDerivedClass_ids, iceC_Test_MyDerivedClass_ids + 3, s);
}

::std::vector<::std::string>
Test::MyDerivedClass::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector<::std::string>(&iceC_Test_MyDerivedClass_ids[0], &iceC_Test_MyDerivedClass_ids[3]);
}

::std::string
Test::MyDerivedClass::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::MyDerivedClass::ice_staticId()
{
    static const ::std::string typeId = "::Test::MyDerivedClass";
    return typeId;
}

/// \cond INTERNAL
bool
Test::MyDerivedClass::_iceD_opDerived(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    this->opDerived(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyDerivedClass::_iceD_opMyClass1(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::shared_ptr<MyClass1> iceP_c;
    istr->readAll(iceP_c);
    istr->readPendingValues();
    inS.endReadParams();
    ::std::shared_ptr<MyClass1> ret = this->opMyClass1(::std::move(iceP_c), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyDerivedClass::_iceD_opMyStruct1(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    MyStruct1 iceP_c;
    istr->readAll(iceP_c);
    inS.endReadParams();
    MyStruct1 ret = this->opMyStruct1(::std::move(iceP_c), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyDerivedClass::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_Test_MyDerivedClass_ops, iceC_Test_MyDerivedClass_ops + 88, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_Test_MyDerivedClass_ops)
    {
        case 0:
        {
            return _iceD_getNSNullASeq(in, current);
        }
        case 1:
        {
            return _iceD_getNSNullStringSeq(in, current);
        }
        case 2:
        {
            return _iceD_getNSNullStringSeqSeq(in, current);
        }
        case 3:
        {
            return _iceD_getNSNullStringStringDict(in, current);
        }
        case 4:
        {
            return _iceD_getNSNullStructSeq(in, current);
        }
        case 5:
        {
            return _iceD_ice_id(in, current);
        }
        case 6:
        {
            return _iceD_ice_ids(in, current);
        }
        case 7:
        {
            return _iceD_ice_isA(in, current);
        }
        case 8:
        {
            return _iceD_ice_ping(in, current);
        }
        case 9:
        {
            return _iceD_opBool(in, current);
        }
        case 10:
        {
            return _iceD_opBoolBoolSD(in, current);
        }
        case 11:
        {
            return _iceD_opBoolS(in, current);
        }
        case 12:
        {
            return _iceD_opBoolSS(in, current);
        }
        case 13:
        {
            return _iceD_opByte(in, current);
        }
        case 14:
        {
            return _iceD_opByte1(in, current);
        }
        case 15:
        {
            return _iceD_opByteBoolD(in, current);
        }
        case 16:
        {
            return _iceD_opByteBoolD1(in, current);
        }
        case 17:
        {
            return _iceD_opByteBoolD2(in, current);
        }
        case 18:
        {
            return _iceD_opByteBoolDS(in, current);
        }
        case 19:
        {
            return _iceD_opByteByteSD(in, current);
        }
        case 20:
        {
            return _iceD_opByteS(in, current);
        }
        case 21:
        {
            return _iceD_opByteSOneway(in, current);
        }
        case 22:
        {
            return _iceD_opByteSOnewayCallCount(in, current);
        }
        case 23:
        {
            return _iceD_opByteSS(in, current);
        }
        case 24:
        {
            return _iceD_opContext(in, current);
        }
        case 25:
        {
            return _iceD_opDerived(in, current);
        }
        case 26:
        {
            return _iceD_opDouble1(in, current);
        }
        case 27:
        {
            return _iceD_opDoubleMarshaling(in, current);
        }
        case 28:
        {
            return _iceD_opFloat1(in, current);
        }
        case 29:
        {
            return _iceD_opFloatDouble(in, current);
        }
        case 30:
        {
            return _iceD_opFloatDoubleS(in, current);
        }
        case 31:
        {
            return _iceD_opFloatDoubleSS(in, current);
        }
        case 32:
        {
            return _iceD_opIdempotent(in, current);
        }
        case 33:
        {
            return _iceD_opInt1(in, current);
        }
        case 34:
        {
            return _iceD_opIntIntSD(in, current);
        }
        case 35:
        {
            return _iceD_opIntS(in, current);
        }
        case 36:
        {
            return _iceD_opLong1(in, current);
        }
        case 37:
        {
            return _iceD_opLongFloatD(in, current);
        }
        case 38:
        {
            return _iceD_opLongFloatDS(in, current);
        }
        case 39:
        {
            return _iceD_opLongLongSD(in, current);
        }
        case 40:
        {
            return _iceD_opMDict1(in, current);
        }
        case 41:
        {
            return _iceD_opMDict2(in, current);
        }
        case 42:
        {
            return _iceD_opMSeq1(in, current);
        }
        case 43:
        {
            return _iceD_opMSeq2(in, current);
        }
        case 44:
        {
            return _iceD_opMStruct1(in, current);
        }
        case 45:
        {
            return _iceD_opMStruct2(in, current);
        }
        case 46:
        {
            return _iceD_opMyClass(in, current);
        }
        case 47:
        {
            return _iceD_opMyClass1(in, current);
        }
        case 48:
        {
            return _iceD_opMyClassS(in, current);
        }
        case 49:
        {
            return _iceD_opMyEnum(in, current);
        }
        case 50:
        {
            return _iceD_opMyEnumMyEnumSD(in, current);
        }
        case 51:
        {
            return _iceD_opMyEnumS(in, current);
        }
        case 52:
        {
            return _iceD_opMyEnumStringD(in, current);
        }
        case 53:
        {
            return _iceD_opMyEnumStringDS(in, current);
        }
        case 54:
        {
            return _iceD_opMyStruct1(in, current);
        }
        case 55:
        {
            return _iceD_opMyStructMyEnumD(in, current);
        }
        case 56:
        {
            return _iceD_opMyStructMyEnumDS(in, current);
        }
        case 57:
        {
            return _iceD_opNonmutating(in, current);
        }
        case 58:
        {
            return _iceD_opShort1(in, current);
        }
        case 59:
        {
            return _iceD_opShortIntD(in, current);
        }
        case 60:
        {
            return _iceD_opShortIntDS(in, current);
        }
        case 61:
        {
            return _iceD_opShortIntLong(in, current);
        }
        case 62:
        {
            return _iceD_opShortIntLongS(in, current);
        }
        case 63:
        {
            return _iceD_opShortIntLongSS(in, current);
        }
        case 64:
        {
            return _iceD_opShortShortSD(in, current);
        }
        case 65:
        {
            return _iceD_opString(in, current);
        }
        case 66:
        {
            return _iceD_opString1(in, current);
        }
        case 67:
        {
            return _iceD_opStringDoubleSD(in, current);
        }
        case 68:
        {
            return _iceD_opStringFloatSD(in, current);
        }
        case 69:
        {
            return _iceD_opStringLiterals(in, current);
        }
        case 70:
        {
            return _iceD_opStringMyEnumD(in, current);
        }
        case 71:
        {
            return _iceD_opStringMyEnumDS(in, current);
        }
        case 72:
        {
            return _iceD_opStringS(in, current);
        }
        case 73:
        {
            return _iceD_opStringS1(in, current);
        }
        case 74:
        {
            return _iceD_opStringS2(in, current);
        }
        case 75:
        {
            return _iceD_opStringSS(in, current);
        }
        case 76:
        {
            return _iceD_opStringSSS(in, current);
        }
        case 77:
        {
            return _iceD_opStringStringD(in, current);
        }
        case 78:
        {
            return _iceD_opStringStringDS(in, current);
        }
        case 79:
        {
            return _iceD_opStringStringSD(in, current);
        }
        case 80:
        {
            return _iceD_opStruct(in, current);
        }
        case 81:
        {
            return _iceD_opVoid(in, current);
        }
        case 82:
        {
            return _iceD_opWStringLiterals(in, current);
        }
        case 83:
        {
            return _iceD_putNSNullShortIntDict(in, current);
        }
        case 84:
        {
            return _iceD_putNSNullStringMyEnumDict(in, current);
        }
        case 85:
        {
            return _iceD_putNSNullStringStringDict(in, current);
        }
        case 86:
        {
            return _iceD_shutdown(in, current);
        }
        case 87:
        {
            return _iceD_supportsCompress(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

bool
Test2::MyDerivedClass::ice_isA(::std::string s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test2_MyDerivedClass_ids, iceC_Test2_MyDerivedClass_ids + 3, s);
}

::std::vector<::std::string>
Test2::MyDerivedClass::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector<::std::string>(&iceC_Test2_MyDerivedClass_ids[0], &iceC_Test2_MyDerivedClass_ids[3]);
}

::std::string
Test2::MyDerivedClass::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test2::MyDerivedClass::ice_staticId()
{
    static const ::std::string typeId = "::Test2::MyDerivedClass";
    return typeId;
}

/// \cond INTERNAL
bool
Test2::MyDerivedClass::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_Test2_MyDerivedClass_ops, iceC_Test2_MyDerivedClass_ops + 85, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_Test2_MyDerivedClass_ops)
    {
        case 0:
        {
            return _iceD_getNSNullASeq(in, current);
        }
        case 1:
        {
            return _iceD_getNSNullStringSeq(in, current);
        }
        case 2:
        {
            return _iceD_getNSNullStringSeqSeq(in, current);
        }
        case 3:
        {
            return _iceD_getNSNullStringStringDict(in, current);
        }
        case 4:
        {
            return _iceD_getNSNullStructSeq(in, current);
        }
        case 5:
        {
            return _iceD_ice_id(in, current);
        }
        case 6:
        {
            return _iceD_ice_ids(in, current);
        }
        case 7:
        {
            return _iceD_ice_isA(in, current);
        }
        case 8:
        {
            return _iceD_ice_ping(in, current);
        }
        case 9:
        {
            return _iceD_opBool(in, current);
        }
        case 10:
        {
            return _iceD_opBoolBoolSD(in, current);
        }
        case 11:
        {
            return _iceD_opBoolS(in, current);
        }
        case 12:
        {
            return _iceD_opBoolSS(in, current);
        }
        case 13:
        {
            return _iceD_opByte(in, current);
        }
        case 14:
        {
            return _iceD_opByte1(in, current);
        }
        case 15:
        {
            return _iceD_opByteBoolD(in, current);
        }
        case 16:
        {
            return _iceD_opByteBoolD1(in, current);
        }
        case 17:
        {
            return _iceD_opByteBoolD2(in, current);
        }
        case 18:
        {
            return _iceD_opByteBoolDS(in, current);
        }
        case 19:
        {
            return _iceD_opByteByteSD(in, current);
        }
        case 20:
        {
            return _iceD_opByteS(in, current);
        }
        case 21:
        {
            return _iceD_opByteSOneway(in, current);
        }
        case 22:
        {
            return _iceD_opByteSOnewayCallCount(in, current);
        }
        case 23:
        {
            return _iceD_opByteSS(in, current);
        }
        case 24:
        {
            return _iceD_opContext(in, current);
        }
        case 25:
        {
            return _iceD_opDouble1(in, current);
        }
        case 26:
        {
            return _iceD_opDoubleMarshaling(in, current);
        }
        case 27:
        {
            return _iceD_opFloat1(in, current);
        }
        case 28:
        {
            return _iceD_opFloatDouble(in, current);
        }
        case 29:
        {
            return _iceD_opFloatDoubleS(in, current);
        }
        case 30:
        {
            return _iceD_opFloatDoubleSS(in, current);
        }
        case 31:
        {
            return _iceD_opIdempotent(in, current);
        }
        case 32:
        {
            return _iceD_opInt1(in, current);
        }
        case 33:
        {
            return _iceD_opIntIntSD(in, current);
        }
        case 34:
        {
            return _iceD_opIntS(in, current);
        }
        case 35:
        {
            return _iceD_opLong1(in, current);
        }
        case 36:
        {
            return _iceD_opLongFloatD(in, current);
        }
        case 37:
        {
            return _iceD_opLongFloatDS(in, current);
        }
        case 38:
        {
            return _iceD_opLongLongSD(in, current);
        }
        case 39:
        {
            return _iceD_opMDict1(in, current);
        }
        case 40:
        {
            return _iceD_opMDict2(in, current);
        }
        case 41:
        {
            return _iceD_opMSeq1(in, current);
        }
        case 42:
        {
            return _iceD_opMSeq2(in, current);
        }
        case 43:
        {
            return _iceD_opMStruct1(in, current);
        }
        case 44:
        {
            return _iceD_opMStruct2(in, current);
        }
        case 45:
        {
            return _iceD_opMyClass(in, current);
        }
        case 46:
        {
            return _iceD_opMyClassS(in, current);
        }
        case 47:
        {
            return _iceD_opMyEnum(in, current);
        }
        case 48:
        {
            return _iceD_opMyEnumMyEnumSD(in, current);
        }
        case 49:
        {
            return _iceD_opMyEnumS(in, current);
        }
        case 50:
        {
            return _iceD_opMyEnumStringD(in, current);
        }
        case 51:
        {
            return _iceD_opMyEnumStringDS(in, current);
        }
        case 52:
        {
            return _iceD_opMyStructMyEnumD(in, current);
        }
        case 53:
        {
            return _iceD_opMyStructMyEnumDS(in, current);
        }
        case 54:
        {
            return _iceD_opNonmutating(in, current);
        }
        case 55:
        {
            return _iceD_opShort1(in, current);
        }
        case 56:
        {
            return _iceD_opShortIntD(in, current);
        }
        case 57:
        {
            return _iceD_opShortIntDS(in, current);
        }
        case 58:
        {
            return _iceD_opShortIntLong(in, current);
        }
        case 59:
        {
            return _iceD_opShortIntLongS(in, current);
        }
        case 60:
        {
            return _iceD_opShortIntLongSS(in, current);
        }
        case 61:
        {
            return _iceD_opShortShortSD(in, current);
        }
        case 62:
        {
            return _iceD_opString(in, current);
        }
        case 63:
        {
            return _iceD_opString1(in, current);
        }
        case 64:
        {
            return _iceD_opStringDoubleSD(in, current);
        }
        case 65:
        {
            return _iceD_opStringFloatSD(in, current);
        }
        case 66:
        {
            return _iceD_opStringLiterals(in, current);
        }
        case 67:
        {
            return _iceD_opStringMyEnumD(in, current);
        }
        case 68:
        {
            return _iceD_opStringMyEnumDS(in, current);
        }
        case 69:
        {
            return _iceD_opStringS(in, current);
        }
        case 70:
        {
            return _iceD_opStringS1(in, current);
        }
        case 71:
        {
            return _iceD_opStringS2(in, current);
        }
        case 72:
        {
            return _iceD_opStringSS(in, current);
        }
        case 73:
        {
            return _iceD_opStringSSS(in, current);
        }
        case 74:
        {
            return _iceD_opStringStringD(in, current);
        }
        case 75:
        {
            return _iceD_opStringStringDS(in, current);
        }
        case 76:
        {
            return _iceD_opStringStringSD(in, current);
        }
        case 77:
        {
            return _iceD_opStruct(in, current);
        }
        case 78:
        {
            return _iceD_opVoid(in, current);
        }
        case 79:
        {
            return _iceD_opWStringLiterals(in, current);
        }
        case 80:
        {
            return _iceD_putNSNullShortIntDict(in, current);
        }
        case 81:
        {
            return _iceD_putNSNullStringMyEnumDict(in, current);
        }
        case 82:
        {
            return _iceD_putNSNullStringStringDict(in, current);
        }
        case 83:
        {
            return _iceD_shutdown(in, current);
        }
        case 84:
        {
            return _iceD_supportsCompress(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

bool
M::Intf::ice_isA(::std::string s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_M_Intf_ids, iceC_M_Intf_ids + 2, s);
}

::std::vector<::std::string>
M::Intf::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector<::std::string>(&iceC_M_Intf_ids[0], &iceC_M_Intf_ids[2]);
}

::std::string
M::Intf::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
M::Intf::ice_staticId()
{
    static const ::std::string typeId = "::M::Intf";
    return typeId;
}

/// \cond INTERNAL
bool
M::Intf::_iceD_opIntf(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    this->opIntf(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
M::Intf::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_M_Intf_ops, iceC_M_Intf_ops + 5, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_M_Intf_ops)
    {
        case 0:
        {
            return _iceD_ice_id(in, current);
        }
        case 1:
        {
            return _iceD_ice_ids(in, current);
        }
        case 2:
        {
            return _iceD_ice_isA(in, current);
        }
        case 3:
        {
            return _iceD_ice_ping(in, current);
        }
        case 4:
        {
            return _iceD_opIntf(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

bool
M::BDisp::ice_isA(::std::string s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_M_B_ids, iceC_M_B_ids + 4, s);
}

::std::vector<::std::string>
M::BDisp::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector<::std::string>(&iceC_M_B_ids[0], &iceC_M_B_ids[4]);
}

::std::string
M::BDisp::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
M::BDisp::ice_staticId()
{
    static const ::std::string typeId = "::M::B";
    return typeId;
}

/// \cond INTERNAL
bool
M::BDisp::_iceD_opB(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    this->opB(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
M::BDisp::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_M_B_ops, iceC_M_B_ops + 6, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_M_B_ops)
    {
        case 0:
        {
            return _iceD_ice_id(in, current);
        }
        case 1:
        {
            return _iceD_ice_ids(in, current);
        }
        case 2:
        {
            return _iceD_ice_isA(in, current);
        }
        case 3:
        {
            return _iceD_ice_ping(in, current);
        }
        case 4:
        {
            return _iceD_opB(in, current);
        }
        case 5:
        {
            return _iceD_opIntf(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

Test::A::~A()
{
}

const ::std::string&
Test::A::ice_staticId()
{
    static const ::std::string typeId = "::Test::A";
    return typeId;
}

Test::MyClass1::~MyClass1()
{
}

const ::std::string&
Test::MyClass1::ice_staticId()
{
    static const ::std::string typeId = "::Test::MyClass1";
    return typeId;
}

M::A::~A()
{
}

const ::std::string&
M::A::ice_staticId()
{
    static const ::std::string typeId = "::M::A";
    return typeId;
}

M::B::~B()
{
}

const ::std::string&
M::B::ice_staticId()
{
    static const ::std::string typeId = "::M::B";
    return typeId;
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_shutdown(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_Test_MyClass_shutdown_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_supportsCompress(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_supportsCompress_name);
    outAsync->invoke(iceC_Test_MyClass_supportsCompress_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opVoid(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_Test_MyClass_opVoid_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opByte(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpByteResult>>& outAsync, ::Ice::Byte iceP_p1, ::Ice::Byte iceP_p2, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opByte_name);
    outAsync->invoke(iceC_Test_MyClass_opByte_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p1, iceP_p2);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpByteResult v;
            istr->readAll(v.p3, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opBool(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpBoolResult>>& outAsync, bool iceP_p1, bool iceP_p2, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opBool_name);
    outAsync->invoke(iceC_Test_MyClass_opBool_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p1, iceP_p2);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpBoolResult v;
            istr->readAll(v.p3, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opShortIntLong(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpShortIntLongResult>>& outAsync, short iceP_p1, int iceP_p2, long long int iceP_p3, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opShortIntLong_name);
    outAsync->invoke(iceC_Test_MyClass_opShortIntLong_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p1, iceP_p2, iceP_p3);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpShortIntLongResult v;
            istr->readAll(v.p4, v.p5, v.p6, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opFloatDouble(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpFloatDoubleResult>>& outAsync, float iceP_p1, double iceP_p2, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opFloatDouble_name);
    outAsync->invoke(iceC_Test_MyClass_opFloatDouble_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p1, iceP_p2);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpFloatDoubleResult v;
            istr->readAll(v.p3, v.p4, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opString(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpStringResult>>& outAsync, const ::std::string& iceP_p1, const ::std::string& iceP_p2, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opString_name);
    outAsync->invoke(iceC_Test_MyClass_opString_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p1, iceP_p2);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpStringResult v;
            istr->readAll(v.p3, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opMyEnum(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpMyEnumResult>>& outAsync, MyEnum iceP_p1, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opMyEnum_name);
    outAsync->invoke(iceC_Test_MyClass_opMyEnum_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p1);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpMyEnumResult v;
            istr->readAll(v.p2, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opMyClass(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpMyClassResult>>& outAsync, const ::std::shared_ptr<MyClassPrx>& iceP_p1, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opMyClass_name);
    outAsync->invoke(iceC_Test_MyClass_opMyClass_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p1);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpMyClassResult v;
            istr->readAll(v.p2, v.p3, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opStruct(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpStructResult>>& outAsync, const Structure& iceP_p1, const Structure& iceP_p2, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opStruct_name);
    outAsync->invoke(iceC_Test_MyClass_opStruct_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p1, iceP_p2);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpStructResult v;
            istr->readAll(v.p3, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opByteS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpByteSResult>>& outAsync, const ByteS& iceP_p1, const ByteS& iceP_p2, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opByteS_name);
    outAsync->invoke(iceC_Test_MyClass_opByteS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p1, iceP_p2);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpByteSResult v;
            istr->readAll(v.p3, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opBoolS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpBoolSResult>>& outAsync, const BoolS& iceP_p1, const BoolS& iceP_p2, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opBoolS_name);
    outAsync->invoke(iceC_Test_MyClass_opBoolS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p1, iceP_p2);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpBoolSResult v;
            istr->readAll(v.p3, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opShortIntLongS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpShortIntLongSResult>>& outAsync, const ShortS& iceP_p1, const IntS& iceP_p2, const LongS& iceP_p3, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opShortIntLongS_name);
    outAsync->invoke(iceC_Test_MyClass_opShortIntLongS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p1, iceP_p2, iceP_p3);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpShortIntLongSResult v;
            istr->readAll(v.p4, v.p5, v.p6, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opFloatDoubleS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpFloatDoubleSResult>>& outAsync, const FloatS& iceP_p1, const DoubleS& iceP_p2, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opFloatDoubleS_name);
    outAsync->invoke(iceC_Test_MyClass_opFloatDoubleS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p1, iceP_p2);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpFloatDoubleSResult v;
            istr->readAll(v.p3, v.p4, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opStringS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpStringSResult>>& outAsync, const StringS& iceP_p1, const StringS& iceP_p2, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opStringS_name);
    outAsync->invoke(iceC_Test_MyClass_opStringS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p1, iceP_p2);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpStringSResult v;
            istr->readAll(v.p3, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opMyEnumS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpMyEnumSResult>>& outAsync, const MyEnumS& iceP_p1, const MyEnumS& iceP_p2, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opMyEnumS_name);
    outAsync->invoke(iceC_Test_MyClass_opMyEnumS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p1, iceP_p2);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpMyEnumSResult v;
            istr->readAll(v.p3, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opMyClassS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpMyClassSResult>>& outAsync, const MyClassS& iceP_p1, const MyClassS& iceP_p2, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opMyClassS_name);
    outAsync->invoke(iceC_Test_MyClass_opMyClassS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p1, iceP_p2);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpMyClassSResult v;
            istr->readAll(v.p3, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opByteSS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpByteSSResult>>& outAsync, const ByteSS& iceP_p1, const ByteSS& iceP_p2, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opByteSS_name);
    outAsync->invoke(iceC_Test_MyClass_opByteSS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p1, iceP_p2);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpByteSSResult v;
            istr->readAll(v.p3, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opBoolSS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpBoolSSResult>>& outAsync, const BoolSS& iceP_p1, const BoolSS& iceP_p2, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opBoolSS_name);
    outAsync->invoke(iceC_Test_MyClass_opBoolSS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p1, iceP_p2);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpBoolSSResult v;
            istr->readAll(v.p3, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opShortIntLongSS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpShortIntLongSSResult>>& outAsync, const ShortSS& iceP_p1, const IntSS& iceP_p2, const LongSS& iceP_p3, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opShortIntLongSS_name);
    outAsync->invoke(iceC_Test_MyClass_opShortIntLongSS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p1, iceP_p2, iceP_p3);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpShortIntLongSSResult v;
            istr->readAll(v.p4, v.p5, v.p6, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opFloatDoubleSS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpFloatDoubleSSResult>>& outAsync, const FloatSS& iceP_p1, const DoubleSS& iceP_p2, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opFloatDoubleSS_name);
    outAsync->invoke(iceC_Test_MyClass_opFloatDoubleSS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p1, iceP_p2);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpFloatDoubleSSResult v;
            istr->readAll(v.p3, v.p4, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opStringSS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpStringSSResult>>& outAsync, const StringSS& iceP_p1, const StringSS& iceP_p2, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opStringSS_name);
    outAsync->invoke(iceC_Test_MyClass_opStringSS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p1, iceP_p2);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpStringSSResult v;
            istr->readAll(v.p3, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opStringSSS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpStringSSSResult>>& outAsync, const StringSSS& iceP_p1, const StringSSS& iceP_p2, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opStringSSS_name);
    outAsync->invoke(iceC_Test_MyClass_opStringSSS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p1, iceP_p2);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpStringSSSResult v;
            istr->readAll(v.p3, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opByteBoolD(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpByteBoolDResult>>& outAsync, const ByteBoolD& iceP_p1, const ByteBoolD& iceP_p2, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opByteBoolD_name);
    outAsync->invoke(iceC_Test_MyClass_opByteBoolD_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p1, iceP_p2);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpByteBoolDResult v;
            istr->readAll(v.p3, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opShortIntD(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpShortIntDResult>>& outAsync, const ShortIntD& iceP_p1, const ShortIntD& iceP_p2, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opShortIntD_name);
    outAsync->invoke(iceC_Test_MyClass_opShortIntD_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p1, iceP_p2);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpShortIntDResult v;
            istr->readAll(v.p3, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opLongFloatD(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpLongFloatDResult>>& outAsync, const LongFloatD& iceP_p1, const LongFloatD& iceP_p2, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opLongFloatD_name);
    outAsync->invoke(iceC_Test_MyClass_opLongFloatD_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p1, iceP_p2);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpLongFloatDResult v;
            istr->readAll(v.p3, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opStringStringD(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpStringStringDResult>>& outAsync, const StringStringD& iceP_p1, const StringStringD& iceP_p2, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opStringStringD_name);
    outAsync->invoke(iceC_Test_MyClass_opStringStringD_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p1, iceP_p2);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpStringStringDResult v;
            istr->readAll(v.p3, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opStringMyEnumD(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpStringMyEnumDResult>>& outAsync, const StringMyEnumD& iceP_p1, const StringMyEnumD& iceP_p2, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opStringMyEnumD_name);
    outAsync->invoke(iceC_Test_MyClass_opStringMyEnumD_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p1, iceP_p2);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpStringMyEnumDResult v;
            istr->readAll(v.p3, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opMyEnumStringD(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpMyEnumStringDResult>>& outAsync, const MyEnumStringD& iceP_p1, const MyEnumStringD& iceP_p2, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opMyEnumStringD_name);
    outAsync->invoke(iceC_Test_MyClass_opMyEnumStringD_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p1, iceP_p2);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpMyEnumStringDResult v;
            istr->readAll(v.p3, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opMyStructMyEnumD(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpMyStructMyEnumDResult>>& outAsync, const MyStructMyEnumD& iceP_p1, const MyStructMyEnumD& iceP_p2, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opMyStructMyEnumD_name);
    outAsync->invoke(iceC_Test_MyClass_opMyStructMyEnumD_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p1, iceP_p2);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpMyStructMyEnumDResult v;
            istr->readAll(v.p3, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opByteBoolDS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpByteBoolDSResult>>& outAsync, const ByteBoolDS& iceP_p1, const ByteBoolDS& iceP_p2, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opByteBoolDS_name);
    outAsync->invoke(iceC_Test_MyClass_opByteBoolDS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p1, iceP_p2);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpByteBoolDSResult v;
            istr->readAll(v.p3, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opShortIntDS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpShortIntDSResult>>& outAsync, const ShortIntDS& iceP_p1, const ShortIntDS& iceP_p2, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opShortIntDS_name);
    outAsync->invoke(iceC_Test_MyClass_opShortIntDS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p1, iceP_p2);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpShortIntDSResult v;
            istr->readAll(v.p3, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opLongFloatDS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpLongFloatDSResult>>& outAsync, const LongFloatDS& iceP_p1, const LongFloatDS& iceP_p2, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opLongFloatDS_name);
    outAsync->invoke(iceC_Test_MyClass_opLongFloatDS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p1, iceP_p2);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpLongFloatDSResult v;
            istr->readAll(v.p3, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opStringStringDS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpStringStringDSResult>>& outAsync, const StringStringDS& iceP_p1, const StringStringDS& iceP_p2, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opStringStringDS_name);
    outAsync->invoke(iceC_Test_MyClass_opStringStringDS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p1, iceP_p2);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpStringStringDSResult v;
            istr->readAll(v.p3, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opStringMyEnumDS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpStringMyEnumDSResult>>& outAsync, const StringMyEnumDS& iceP_p1, const StringMyEnumDS& iceP_p2, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opStringMyEnumDS_name);
    outAsync->invoke(iceC_Test_MyClass_opStringMyEnumDS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p1, iceP_p2);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpStringMyEnumDSResult v;
            istr->readAll(v.p3, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opMyEnumStringDS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpMyEnumStringDSResult>>& outAsync, const MyEnumStringDS& iceP_p1, const MyEnumStringDS& iceP_p2, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opMyEnumStringDS_name);
    outAsync->invoke(iceC_Test_MyClass_opMyEnumStringDS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p1, iceP_p2);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpMyEnumStringDSResult v;
            istr->readAll(v.p3, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opMyStructMyEnumDS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpMyStructMyEnumDSResult>>& outAsync, const MyStructMyEnumDS& iceP_p1, const MyStructMyEnumDS& iceP_p2, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opMyStructMyEnumDS_name);
    outAsync->invoke(iceC_Test_MyClass_opMyStructMyEnumDS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p1, iceP_p2);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpMyStructMyEnumDSResult v;
            istr->readAll(v.p3, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opByteByteSD(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpByteByteSDResult>>& outAsync, const ByteByteSD& iceP_p1, const ByteByteSD& iceP_p2, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opByteByteSD_name);
    outAsync->invoke(iceC_Test_MyClass_opByteByteSD_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p1, iceP_p2);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpByteByteSDResult v;
            istr->readAll(v.p3, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opBoolBoolSD(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpBoolBoolSDResult>>& outAsync, const BoolBoolSD& iceP_p1, const BoolBoolSD& iceP_p2, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opBoolBoolSD_name);
    outAsync->invoke(iceC_Test_MyClass_opBoolBoolSD_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p1, iceP_p2);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpBoolBoolSDResult v;
            istr->readAll(v.p3, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opShortShortSD(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpShortShortSDResult>>& outAsync, const ShortShortSD& iceP_p1, const ShortShortSD& iceP_p2, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opShortShortSD_name);
    outAsync->invoke(iceC_Test_MyClass_opShortShortSD_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p1, iceP_p2);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpShortShortSDResult v;
            istr->readAll(v.p3, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opIntIntSD(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpIntIntSDResult>>& outAsync, const IntIntSD& iceP_p1, const IntIntSD& iceP_p2, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opIntIntSD_name);
    outAsync->invoke(iceC_Test_MyClass_opIntIntSD_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p1, iceP_p2);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpIntIntSDResult v;
            istr->readAll(v.p3, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opLongLongSD(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpLongLongSDResult>>& outAsync, const LongLongSD& iceP_p1, const LongLongSD& iceP_p2, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opLongLongSD_name);
    outAsync->invoke(iceC_Test_MyClass_opLongLongSD_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p1, iceP_p2);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpLongLongSDResult v;
            istr->readAll(v.p3, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opStringFloatSD(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpStringFloatSDResult>>& outAsync, const StringFloatSD& iceP_p1, const StringFloatSD& iceP_p2, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opStringFloatSD_name);
    outAsync->invoke(iceC_Test_MyClass_opStringFloatSD_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p1, iceP_p2);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpStringFloatSDResult v;
            istr->readAll(v.p3, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opStringDoubleSD(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpStringDoubleSDResult>>& outAsync, const StringDoubleSD& iceP_p1, const StringDoubleSD& iceP_p2, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opStringDoubleSD_name);
    outAsync->invoke(iceC_Test_MyClass_opStringDoubleSD_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p1, iceP_p2);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpStringDoubleSDResult v;
            istr->readAll(v.p3, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opStringStringSD(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpStringStringSDResult>>& outAsync, const StringStringSD& iceP_p1, const StringStringSD& iceP_p2, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opStringStringSD_name);
    outAsync->invoke(iceC_Test_MyClass_opStringStringSD_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p1, iceP_p2);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpStringStringSDResult v;
            istr->readAll(v.p3, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opMyEnumMyEnumSD(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpMyEnumMyEnumSDResult>>& outAsync, const MyEnumMyEnumSD& iceP_p1, const MyEnumMyEnumSD& iceP_p2, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opMyEnumMyEnumSD_name);
    outAsync->invoke(iceC_Test_MyClass_opMyEnumMyEnumSD_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p1, iceP_p2);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpMyEnumMyEnumSDResult v;
            istr->readAll(v.p3, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opIntS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::Test::IntS>>& outAsync, const IntS& iceP_s, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opIntS_name);
    outAsync->invoke(iceC_Test_MyClass_opIntS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_s);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opByteSOneway(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ByteS& iceP_s, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_Test_MyClass_opByteSOneway_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_s);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opByteSOnewayCallCount(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<int>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opByteSOnewayCallCount_name);
    outAsync->invoke(iceC_Test_MyClass_opByteSOnewayCallCount_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opContext(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::Ice::Context>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opContext_name);
    outAsync->invoke(iceC_Test_MyClass_opContext_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opDoubleMarshaling(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, double iceP_p1, const DoubleS& iceP_p2, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_Test_MyClass_opDoubleMarshaling_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p1, iceP_p2);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opIdempotent(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_Test_MyClass_opIdempotent_name, ::Ice::OperationMode::Idempotent, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opNonmutating(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_Test_MyClass_opNonmutating_name, ::Ice::OperationMode::Nonmutating, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opByte1(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::Ice::Byte>>& outAsync, ::Ice::Byte iceP_opByte1, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opByte1_name);
    outAsync->invoke(iceC_Test_MyClass_opByte1_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_opByte1);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opShort1(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<short>>& outAsync, short iceP_opShort1, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opShort1_name);
    outAsync->invoke(iceC_Test_MyClass_opShort1_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_opShort1);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opInt1(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<int>>& outAsync, int iceP_opInt1, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opInt1_name);
    outAsync->invoke(iceC_Test_MyClass_opInt1_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_opInt1);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opLong1(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<long long int>>& outAsync, long long int iceP_opLong1, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opLong1_name);
    outAsync->invoke(iceC_Test_MyClass_opLong1_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_opLong1);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opFloat1(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<float>>& outAsync, float iceP_opFloat1, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opFloat1_name);
    outAsync->invoke(iceC_Test_MyClass_opFloat1_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_opFloat1);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opDouble1(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<double>>& outAsync, double iceP_opDouble1, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opDouble1_name);
    outAsync->invoke(iceC_Test_MyClass_opDouble1_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_opDouble1);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opString1(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::string>>& outAsync, const ::std::string& iceP_opString1, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opString1_name);
    outAsync->invoke(iceC_Test_MyClass_opString1_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_opString1);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opStringS1(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::Test::StringS>>& outAsync, const StringS& iceP_opStringS1, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opStringS1_name);
    outAsync->invoke(iceC_Test_MyClass_opStringS1_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_opStringS1);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opByteBoolD1(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::Test::ByteBoolD>>& outAsync, const ByteBoolD& iceP_opByteBoolD1, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opByteBoolD1_name);
    outAsync->invoke(iceC_Test_MyClass_opByteBoolD1_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_opByteBoolD1);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opStringS2(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::Test::StringS>>& outAsync, const StringS& iceP_stringS, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opStringS2_name);
    outAsync->invoke(iceC_Test_MyClass_opStringS2_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_stringS);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opByteBoolD2(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::Test::ByteBoolD>>& outAsync, const ByteBoolD& iceP_byteBoolD, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opByteBoolD2_name);
    outAsync->invoke(iceC_Test_MyClass_opByteBoolD2_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_byteBoolD);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opStringLiterals(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::Test::StringS>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opStringLiterals_name);
    outAsync->invoke(iceC_Test_MyClass_opStringLiterals_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opWStringLiterals(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::Test::StringS>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opWStringLiterals_name);
    outAsync->invoke(iceC_Test_MyClass_opWStringLiterals_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opMStruct1(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::Test::Structure>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opMStruct1_name);
    outAsync->invoke(iceC_Test_MyClass_opMStruct1_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opMStruct2(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpMStruct2Result>>& outAsync, const Structure& iceP_p1, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opMStruct2_name);
    outAsync->invoke(iceC_Test_MyClass_opMStruct2_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p1);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpMStruct2Result v;
            istr->readAll(v.p2, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opMSeq1(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::Test::StringS>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opMSeq1_name);
    outAsync->invoke(iceC_Test_MyClass_opMSeq1_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opMSeq2(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpMSeq2Result>>& outAsync, const StringS& iceP_p1, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opMSeq2_name);
    outAsync->invoke(iceC_Test_MyClass_opMSeq2_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p1);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpMSeq2Result v;
            istr->readAll(v.p2, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opMDict1(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::Test::StringStringD>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opMDict1_name);
    outAsync->invoke(iceC_Test_MyClass_opMDict1_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opMDict2(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpMDict2Result>>& outAsync, const StringStringD& iceP_p1, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opMDict2_name);
    outAsync->invoke(iceC_Test_MyClass_opMDict2_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p1);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpMDict2Result v;
            istr->readAll(v.p2, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_getNSNullStringSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::Test::StringS>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_getNSNullStringSeq_name);
    outAsync->invoke(iceC_Test_MyClass_getNSNullStringSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_getNSNullASeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::Test::AS>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_getNSNullASeq_name);
    outAsync->invoke(iceC_Test_MyClass_getNSNullASeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr,
        [](::Ice::InputStream* istr)
        {
            AS ret;
            istr->readAll(ret);
            istr->readPendingValues();
            return ret;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_getNSNullStructSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::Test::StructS>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_getNSNullStructSeq_name);
    outAsync->invoke(iceC_Test_MyClass_getNSNullStructSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_getNSNullStringSeqSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::Test::StringSS>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_getNSNullStringSeqSeq_name);
    outAsync->invoke(iceC_Test_MyClass_getNSNullStringSeqSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_getNSNullStringStringDict(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::Test::StringStringD>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_getNSNullStringStringDict_name);
    outAsync->invoke(iceC_Test_MyClass_getNSNullStringStringDict_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_putNSNullStringStringDict(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const StringStringD& iceP_d, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_Test_MyClass_putNSNullStringStringDict_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_d);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_putNSNullShortIntDict(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ShortIntD& iceP_d, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_Test_MyClass_putNSNullShortIntDict_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_d);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_putNSNullStringMyEnumDict(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const StringMyEnumD& iceP_d, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_Test_MyClass_putNSNullStringMyEnumDict_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_d);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
::std::shared_ptr<::Ice::ObjectPrx>
Test::MyClassPrx::_newInstance() const
{
    return ::IceInternal::createProxy<MyClassPrx>();
}
/// \endcond

const ::std::string&
Test::MyClassPrx::ice_staticId()
{
    return MyClass::ice_staticId();
}

/// \cond INTERNAL
void
Test::MyDerivedClassPrx::_iceI_opDerived(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_Test_MyDerivedClass_opDerived_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Test::MyDerivedClassPrx::_iceI_opMyClass1(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Test::MyClass1>>>& outAsync, const ::std::shared_ptr<MyClass1>& iceP_c, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyDerivedClass_opMyClass1_name);
    outAsync->invoke(iceC_Test_MyDerivedClass_opMyClass1_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_c);
            ostr->writePendingValues();
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::shared_ptr<MyClass1> ret;
            istr->readAll(ret);
            istr->readPendingValues();
            return ret;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyDerivedClassPrx::_iceI_opMyStruct1(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::Test::MyStruct1>>& outAsync, const MyStruct1& iceP_c, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyDerivedClass_opMyStruct1_name);
    outAsync->invoke(iceC_Test_MyDerivedClass_opMyStruct1_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_c);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
::std::shared_ptr<::Ice::ObjectPrx>
Test::MyDerivedClassPrx::_newInstance() const
{
    return ::IceInternal::createProxy<MyDerivedClassPrx>();
}
/// \endcond

const ::std::string&
Test::MyDerivedClassPrx::ice_staticId()
{
    return MyDerivedClass::ice_staticId();
}

/// \cond INTERNAL
::std::shared_ptr<::Ice::ObjectPrx>
Test2::MyDerivedClassPrx::_newInstance() const
{
    return ::IceInternal::createProxy<MyDerivedClassPrx>();
}
/// \endcond

const ::std::string&
Test2::MyDerivedClassPrx::ice_staticId()
{
    return MyDerivedClass::ice_staticId();
}

/// \cond INTERNAL
void
M::IntfPrx::_iceI_opIntf(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_M_Intf_opIntf_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

/// \cond INTERNAL
::std::shared_ptr<::Ice::ObjectPrx>
M::IntfPrx::_newInstance() const
{
    return ::IceInternal::createProxy<IntfPrx>();
}
/// \endcond

const ::std::string&
M::IntfPrx::ice_staticId()
{
    return Intf::ice_staticId();
}

/// \cond INTERNAL
void
M::BPrx::_iceI_opB(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_M_B_opB_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

/// \cond INTERNAL
::std::shared_ptr<::Ice::ObjectPrx>
M::BPrx::_newInstance() const
{
    return ::IceInternal::createProxy<BPrx>();
}
/// \endcond

const ::std::string&
M::BPrx::ice_staticId()
{
    return BDisp::ice_staticId();
}

namespace Ice
{
}

#else // C++98 mapping

namespace
{

const ::std::string iceC_Test_MyClass_shutdown_name = "shutdown";

const ::std::string iceC_Test_MyClass_supportsCompress_name = "supportsCompress";

const ::std::string iceC_Test_MyClass_opVoid_name = "opVoid";

const ::std::string iceC_Test_MyClass_opByte_name = "opByte";

const ::std::string iceC_Test_MyClass_opBool_name = "opBool";

const ::std::string iceC_Test_MyClass_opShortIntLong_name = "opShortIntLong";

const ::std::string iceC_Test_MyClass_opFloatDouble_name = "opFloatDouble";

const ::std::string iceC_Test_MyClass_opString_name = "opString";

const ::std::string iceC_Test_MyClass_opMyEnum_name = "opMyEnum";

const ::std::string iceC_Test_MyClass_opMyClass_name = "opMyClass";

const ::std::string iceC_Test_MyClass_opStruct_name = "opStruct";

const ::std::string iceC_Test_MyClass_opByteS_name = "opByteS";

const ::std::string iceC_Test_MyClass_opBoolS_name = "opBoolS";

const ::std::string iceC_Test_MyClass_opShortIntLongS_name = "opShortIntLongS";

const ::std::string iceC_Test_MyClass_opFloatDoubleS_name = "opFloatDoubleS";

const ::std::string iceC_Test_MyClass_opStringS_name = "opStringS";

const ::std::string iceC_Test_MyClass_opMyEnumS_name = "opMyEnumS";

const ::std::string iceC_Test_MyClass_opMyClassS_name = "opMyClassS";

const ::std::string iceC_Test_MyClass_opByteSS_name = "opByteSS";

const ::std::string iceC_Test_MyClass_opBoolSS_name = "opBoolSS";

const ::std::string iceC_Test_MyClass_opShortIntLongSS_name = "opShortIntLongSS";

const ::std::string iceC_Test_MyClass_opFloatDoubleSS_name = "opFloatDoubleSS";

const ::std::string iceC_Test_MyClass_opStringSS_name = "opStringSS";

const ::std::string iceC_Test_MyClass_opStringSSS_name = "opStringSSS";

const ::std::string iceC_Test_MyClass_opByteBoolD_name = "opByteBoolD";

const ::std::string iceC_Test_MyClass_opShortIntD_name = "opShortIntD";

const ::std::string iceC_Test_MyClass_opLongFloatD_name = "opLongFloatD";

const ::std::string iceC_Test_MyClass_opStringStringD_name = "opStringStringD";

const ::std::string iceC_Test_MyClass_opStringMyEnumD_name = "opStringMyEnumD";

const ::std::string iceC_Test_MyClass_opMyEnumStringD_name = "opMyEnumStringD";

const ::std::string iceC_Test_MyClass_opMyStructMyEnumD_name = "opMyStructMyEnumD";

const ::std::string iceC_Test_MyClass_opByteBoolDS_name = "opByteBoolDS";

const ::std::string iceC_Test_MyClass_opShortIntDS_name = "opShortIntDS";

const ::std::string iceC_Test_MyClass_opLongFloatDS_name = "opLongFloatDS";

const ::std::string iceC_Test_MyClass_opStringStringDS_name = "opStringStringDS";

const ::std::string iceC_Test_MyClass_opStringMyEnumDS_name = "opStringMyEnumDS";

const ::std::string iceC_Test_MyClass_opMyEnumStringDS_name = "opMyEnumStringDS";

const ::std::string iceC_Test_MyClass_opMyStructMyEnumDS_name = "opMyStructMyEnumDS";

const ::std::string iceC_Test_MyClass_opByteByteSD_name = "opByteByteSD";

const ::std::string iceC_Test_MyClass_opBoolBoolSD_name = "opBoolBoolSD";

const ::std::string iceC_Test_MyClass_opShortShortSD_name = "opShortShortSD";

const ::std::string iceC_Test_MyClass_opIntIntSD_name = "opIntIntSD";

const ::std::string iceC_Test_MyClass_opLongLongSD_name = "opLongLongSD";

const ::std::string iceC_Test_MyClass_opStringFloatSD_name = "opStringFloatSD";

const ::std::string iceC_Test_MyClass_opStringDoubleSD_name = "opStringDoubleSD";

const ::std::string iceC_Test_MyClass_opStringStringSD_name = "opStringStringSD";

const ::std::string iceC_Test_MyClass_opMyEnumMyEnumSD_name = "opMyEnumMyEnumSD";

const ::std::string iceC_Test_MyClass_opIntS_name = "opIntS";

const ::std::string iceC_Test_MyClass_opByteSOneway_name = "opByteSOneway";

const ::std::string iceC_Test_MyClass_opByteSOnewayCallCount_name = "opByteSOnewayCallCount";

const ::std::string iceC_Test_MyClass_opContext_name = "opContext";

const ::std::string iceC_Test_MyClass_opDoubleMarshaling_name = "opDoubleMarshaling";

const ::std::string iceC_Test_MyClass_opIdempotent_name = "opIdempotent";

const ::std::string iceC_Test_MyClass_opNonmutating_name = "opNonmutating";

const ::std::string iceC_Test_MyClass_opByte1_name = "opByte1";

const ::std::string iceC_Test_MyClass_opShort1_name = "opShort1";

const ::std::string iceC_Test_MyClass_opInt1_name = "opInt1";

const ::std::string iceC_Test_MyClass_opLong1_name = "opLong1";

const ::std::string iceC_Test_MyClass_opFloat1_name = "opFloat1";

const ::std::string iceC_Test_MyClass_opDouble1_name = "opDouble1";

const ::std::string iceC_Test_MyClass_opString1_name = "opString1";

const ::std::string iceC_Test_MyClass_opStringS1_name = "opStringS1";

const ::std::string iceC_Test_MyClass_opByteBoolD1_name = "opByteBoolD1";

const ::std::string iceC_Test_MyClass_opStringS2_name = "opStringS2";

const ::std::string iceC_Test_MyClass_opByteBoolD2_name = "opByteBoolD2";

const ::std::string iceC_Test_MyClass_opStringLiterals_name = "opStringLiterals";

const ::std::string iceC_Test_MyClass_opWStringLiterals_name = "opWStringLiterals";

const ::std::string iceC_Test_MyClass_opMStruct1_name = "opMStruct1";

const ::std::string iceC_Test_MyClass_opMStruct2_name = "opMStruct2";

const ::std::string iceC_Test_MyClass_opMSeq1_name = "opMSeq1";

const ::std::string iceC_Test_MyClass_opMSeq2_name = "opMSeq2";

const ::std::string iceC_Test_MyClass_opMDict1_name = "opMDict1";

const ::std::string iceC_Test_MyClass_opMDict2_name = "opMDict2";

const ::std::string iceC_Test_MyClass_getNSNullStringSeq_name = "getNSNullStringSeq";

const ::std::string iceC_Test_MyClass_getNSNullASeq_name = "getNSNullASeq";

const ::std::string iceC_Test_MyClass_getNSNullStructSeq_name = "getNSNullStructSeq";

const ::std::string iceC_Test_MyClass_getNSNullStringSeqSeq_name = "getNSNullStringSeqSeq";

const ::std::string iceC_Test_MyClass_getNSNullStringStringDict_name = "getNSNullStringStringDict";

const ::std::string iceC_Test_MyClass_putNSNullStringStringDict_name = "putNSNullStringStringDict";

const ::std::string iceC_Test_MyClass_putNSNullShortIntDict_name = "putNSNullShortIntDict";

const ::std::string iceC_Test_MyClass_putNSNullStringMyEnumDict_name = "putNSNullStringMyEnumDict";

const ::std::string iceC_Test_MyDerivedClass_opDerived_name = "opDerived";

const ::std::string iceC_Test_MyDerivedClass_opMyClass1_name = "opMyClass1";

const ::std::string iceC_Test_MyDerivedClass_opMyStruct1_name = "opMyStruct1";

}

namespace
{

}

namespace
{

const ::std::string iceC_M_Intf_opIntf_name = "opIntf";

const ::std::string iceC_M_B_opB_name = "opB";

}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(A* p) { return p; }

void
::IceProxy::Test::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< A>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new A;
        v->_copyFrom(proxy);
    }
}
/// \endcond

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::Test::A::_newInstance() const
{
    return new A;
}
/// \endcond

const ::std::string&
IceProxy::Test::A::ice_staticId()
{
    return ::Test::A::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(MyClass* p) { return p; }

void
::IceProxy::Test::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< MyClass>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new MyClass;
        v->_copyFrom(proxy);
    }
}
/// \endcond

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_shutdown(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_shutdown_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_shutdown_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Test_MyClass_shutdown_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Test::MyClass::end_shutdown(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_Test_MyClass_shutdown_name);
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_supportsCompress(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_supportsCompress_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_supportsCompress_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_supportsCompress_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Test_MyClass_supportsCompress_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

bool
IceProxy::Test::MyClass::end_supportsCompress(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_supportsCompress_name);
    bool ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opVoid(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opVoid_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opVoid_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Test_MyClass_opVoid_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Test::MyClass::end_opVoid(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_Test_MyClass_opVoid_name);
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opByte(::Ice::Byte iceP_p1, ::Ice::Byte iceP_p2, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opByte_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opByte_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opByte_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_p1);
        ostr->write(iceP_p2);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opByte_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Ice::Byte
IceProxy::Test::MyClass::end_opByte(::Ice::Byte& iceP_p3, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opByte_name);
    ::Ice::Byte ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p3);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opByte(::Ice::Byte& iceP_p3, ::Ice::Byte& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opByte_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p3);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opBool(bool iceP_p1, bool iceP_p2, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opBool_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opBool_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opBool_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_p1);
        ostr->write(iceP_p2);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opBool_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

bool
IceProxy::Test::MyClass::end_opBool(bool& iceP_p3, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opBool_name);
    bool ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p3);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opBool(bool& iceP_p3, bool& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opBool_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p3);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opShortIntLong(::Ice::Short iceP_p1, ::Ice::Int iceP_p2, ::Ice::Long iceP_p3, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opShortIntLong_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opShortIntLong_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opShortIntLong_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_p1);
        ostr->write(iceP_p2);
        ostr->write(iceP_p3);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opShortIntLong_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Ice::Long
IceProxy::Test::MyClass::end_opShortIntLong(::Ice::Short& iceP_p4, ::Ice::Int& iceP_p5, ::Ice::Long& iceP_p6, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opShortIntLong_name);
    ::Ice::Long ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p4);
    istr->read(iceP_p5);
    istr->read(iceP_p6);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opShortIntLong(::Ice::Short& iceP_p4, ::Ice::Int& iceP_p5, ::Ice::Long& iceP_p6, ::Ice::Long& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opShortIntLong_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p4);
    istr->read(iceP_p5);
    istr->read(iceP_p6);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opFloatDouble(::Ice::Float iceP_p1, ::Ice::Double iceP_p2, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opFloatDouble_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opFloatDouble_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opFloatDouble_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_p1);
        ostr->write(iceP_p2);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opFloatDouble_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Ice::Double
IceProxy::Test::MyClass::end_opFloatDouble(::Ice::Float& iceP_p3, ::Ice::Double& iceP_p4, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opFloatDouble_name);
    ::Ice::Double ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p3);
    istr->read(iceP_p4);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opFloatDouble(::Ice::Float& iceP_p3, ::Ice::Double& iceP_p4, ::Ice::Double& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opFloatDouble_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p3);
    istr->read(iceP_p4);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opString(const ::std::string& iceP_p1, const ::std::string& iceP_p2, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opString_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opString_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opString_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_p1);
        ostr->write(iceP_p2);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opString_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::std::string
IceProxy::Test::MyClass::end_opString(::std::string& iceP_p3, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opString_name);
    ::std::string ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p3);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opString(::std::string& iceP_p3, ::std::string& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opString_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p3);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opMyEnum(::Test::MyEnum iceP_p1, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opMyEnum_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opMyEnum_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opMyEnum_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_p1);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opMyEnum_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::MyEnum
IceProxy::Test::MyClass::end_opMyEnum(::Test::MyEnum& iceP_p2, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opMyEnum_name);
    ::Test::MyEnum ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p2);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opMyEnum(::Test::MyEnum& iceP_p2, ::Test::MyEnum& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opMyEnum_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p2);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opMyClass(const ::Test::MyClassPrx& iceP_p1, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opMyClass_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opMyClass_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opMyClass_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_p1);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opMyClass_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::MyClassPrx
IceProxy::Test::MyClass::end_opMyClass(::Test::MyClassPrx& iceP_p2, ::Test::MyClassPrx& iceP_p3, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opMyClass_name);
    ::Test::MyClassPrx ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p2);
    istr->read(iceP_p3);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opMyClass(::Test::MyClassPrx& iceP_p2, ::Test::MyClassPrx& iceP_p3, ::Test::MyClassPrx& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opMyClass_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p2);
    istr->read(iceP_p3);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opStruct(const ::Test::Structure& iceP_p1, const ::Test::Structure& iceP_p2, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opStruct_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opStruct_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opStruct_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_p1);
        ostr->write(iceP_p2);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opStruct_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::Structure
IceProxy::Test::MyClass::end_opStruct(::Test::Structure& iceP_p3, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opStruct_name);
    ::Test::Structure ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p3);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opStruct(::Test::Structure& iceP_p3, ::Test::Structure& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opStruct_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p3);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opByteS(const ::Test::ByteS& iceP_p1, const ::Test::ByteS& iceP_p2, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opByteS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opByteS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opByteS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_p1);
        ostr->write(iceP_p2);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opByteS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::ByteS
IceProxy::Test::MyClass::end_opByteS(::Test::ByteS& iceP_p3, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opByteS_name);
    ::Test::ByteS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p3);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opByteS(::Test::ByteS& iceP_p3, ::Test::ByteS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opByteS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p3);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opBoolS(const ::Test::BoolS& iceP_p1, const ::Test::BoolS& iceP_p2, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opBoolS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opBoolS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opBoolS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_p1);
        ostr->write(iceP_p2);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opBoolS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::BoolS
IceProxy::Test::MyClass::end_opBoolS(::Test::BoolS& iceP_p3, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opBoolS_name);
    ::Test::BoolS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p3);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opBoolS(::Test::BoolS& iceP_p3, ::Test::BoolS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opBoolS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p3);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opShortIntLongS(const ::Test::ShortS& iceP_p1, const ::Test::IntS& iceP_p2, const ::Test::LongS& iceP_p3, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opShortIntLongS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opShortIntLongS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opShortIntLongS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_p1);
        ostr->write(iceP_p2);
        ostr->write(iceP_p3);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opShortIntLongS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::LongS
IceProxy::Test::MyClass::end_opShortIntLongS(::Test::ShortS& iceP_p4, ::Test::IntS& iceP_p5, ::Test::LongS& iceP_p6, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opShortIntLongS_name);
    ::Test::LongS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p4);
    istr->read(iceP_p5);
    istr->read(iceP_p6);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opShortIntLongS(::Test::ShortS& iceP_p4, ::Test::IntS& iceP_p5, ::Test::LongS& iceP_p6, ::Test::LongS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opShortIntLongS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p4);
    istr->read(iceP_p5);
    istr->read(iceP_p6);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opFloatDoubleS(const ::Test::FloatS& iceP_p1, const ::Test::DoubleS& iceP_p2, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opFloatDoubleS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opFloatDoubleS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opFloatDoubleS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_p1);
        ostr->write(iceP_p2);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opFloatDoubleS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::DoubleS
IceProxy::Test::MyClass::end_opFloatDoubleS(::Test::FloatS& iceP_p3, ::Test::DoubleS& iceP_p4, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opFloatDoubleS_name);
    ::Test::DoubleS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p3);
    istr->read(iceP_p4);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opFloatDoubleS(::Test::FloatS& iceP_p3, ::Test::DoubleS& iceP_p4, ::Test::DoubleS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opFloatDoubleS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p3);
    istr->read(iceP_p4);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opStringS(const ::Test::StringS& iceP_p1, const ::Test::StringS& iceP_p2, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opStringS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opStringS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opStringS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_p1);
        ostr->write(iceP_p2);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opStringS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::StringS
IceProxy::Test::MyClass::end_opStringS(::Test::StringS& iceP_p3, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opStringS_name);
    ::Test::StringS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p3);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opStringS(::Test::StringS& iceP_p3, ::Test::StringS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opStringS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p3);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opMyEnumS(const ::Test::MyEnumS& iceP_p1, const ::Test::MyEnumS& iceP_p2, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opMyEnumS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opMyEnumS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opMyEnumS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_p1);
        ostr->write(iceP_p2);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opMyEnumS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::MyEnumS
IceProxy::Test::MyClass::end_opMyEnumS(::Test::MyEnumS& iceP_p3, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opMyEnumS_name);
    ::Test::MyEnumS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p3);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opMyEnumS(::Test::MyEnumS& iceP_p3, ::Test::MyEnumS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opMyEnumS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p3);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opMyClassS(const ::Test::MyClassS& iceP_p1, const ::Test::MyClassS& iceP_p2, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opMyClassS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opMyClassS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opMyClassS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_p1);
        ostr->write(iceP_p2);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opMyClassS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::MyClassS
IceProxy::Test::MyClass::end_opMyClassS(::Test::MyClassS& iceP_p3, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opMyClassS_name);
    ::Test::MyClassS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p3);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opMyClassS(::Test::MyClassS& iceP_p3, ::Test::MyClassS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opMyClassS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p3);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opByteSS(const ::Test::ByteSS& iceP_p1, const ::Test::ByteSS& iceP_p2, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opByteSS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opByteSS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opByteSS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_p1);
        ostr->write(iceP_p2);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opByteSS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::ByteSS
IceProxy::Test::MyClass::end_opByteSS(::Test::ByteSS& iceP_p3, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opByteSS_name);
    ::Test::ByteSS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p3);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opByteSS(::Test::ByteSS& iceP_p3, ::Test::ByteSS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opByteSS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p3);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opBoolSS(const ::Test::BoolSS& iceP_p1, const ::Test::BoolSS& iceP_p2, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opBoolSS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opBoolSS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opBoolSS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_p1);
        ostr->write(iceP_p2);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opBoolSS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::BoolSS
IceProxy::Test::MyClass::end_opBoolSS(::Test::BoolSS& iceP_p3, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opBoolSS_name);
    ::Test::BoolSS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p3);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opBoolSS(::Test::BoolSS& iceP_p3, ::Test::BoolSS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opBoolSS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p3);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opShortIntLongSS(const ::Test::ShortSS& iceP_p1, const ::Test::IntSS& iceP_p2, const ::Test::LongSS& iceP_p3, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opShortIntLongSS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opShortIntLongSS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opShortIntLongSS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_p1);
        ostr->write(iceP_p2);
        ostr->write(iceP_p3);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opShortIntLongSS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::LongSS
IceProxy::Test::MyClass::end_opShortIntLongSS(::Test::ShortSS& iceP_p4, ::Test::IntSS& iceP_p5, ::Test::LongSS& iceP_p6, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opShortIntLongSS_name);
    ::Test::LongSS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p4);
    istr->read(iceP_p5);
    istr->read(iceP_p6);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opShortIntLongSS(::Test::ShortSS& iceP_p4, ::Test::IntSS& iceP_p5, ::Test::LongSS& iceP_p6, ::Test::LongSS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opShortIntLongSS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p4);
    istr->read(iceP_p5);
    istr->read(iceP_p6);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opFloatDoubleSS(const ::Test::FloatSS& iceP_p1, const ::Test::DoubleSS& iceP_p2, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opFloatDoubleSS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opFloatDoubleSS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opFloatDoubleSS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_p1);
        ostr->write(iceP_p2);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opFloatDoubleSS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::DoubleSS
IceProxy::Test::MyClass::end_opFloatDoubleSS(::Test::FloatSS& iceP_p3, ::Test::DoubleSS& iceP_p4, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opFloatDoubleSS_name);
    ::Test::DoubleSS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p3);
    istr->read(iceP_p4);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opFloatDoubleSS(::Test::FloatSS& iceP_p3, ::Test::DoubleSS& iceP_p4, ::Test::DoubleSS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opFloatDoubleSS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p3);
    istr->read(iceP_p4);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opStringSS(const ::Test::StringSS& iceP_p1, const ::Test::StringSS& iceP_p2, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opStringSS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opStringSS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opStringSS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_p1);
        ostr->write(iceP_p2);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opStringSS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::StringSS
IceProxy::Test::MyClass::end_opStringSS(::Test::StringSS& iceP_p3, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opStringSS_name);
    ::Test::StringSS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p3);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opStringSS(::Test::StringSS& iceP_p3, ::Test::StringSS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opStringSS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p3);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opStringSSS(const ::Test::StringSSS& iceP_p1, const ::Test::StringSSS& iceP_p2, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opStringSSS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opStringSSS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opStringSSS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_p1);
        ostr->write(iceP_p2);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opStringSSS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::StringSSS
IceProxy::Test::MyClass::end_opStringSSS(::Test::StringSSS& iceP_p3, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opStringSSS_name);
    ::Test::StringSSS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p3);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opStringSSS(::Test::StringSSS& iceP_p3, ::Test::StringSSS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opStringSSS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p3);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opByteBoolD(const ::Test::ByteBoolD& iceP_p1, const ::Test::ByteBoolD& iceP_p2, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opByteBoolD_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opByteBoolD_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opByteBoolD_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_p1);
        ostr->write(iceP_p2);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opByteBoolD_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::ByteBoolD
IceProxy::Test::MyClass::end_opByteBoolD(::Test::ByteBoolD& iceP_p3, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opByteBoolD_name);
    ::Test::ByteBoolD ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p3);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opByteBoolD(::Test::ByteBoolD& iceP_p3, ::Test::ByteBoolD& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opByteBoolD_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p3);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opShortIntD(const ::Test::ShortIntD& iceP_p1, const ::Test::ShortIntD& iceP_p2, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opShortIntD_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opShortIntD_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opShortIntD_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_p1);
        ostr->write(iceP_p2);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opShortIntD_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::ShortIntD
IceProxy::Test::MyClass::end_opShortIntD(::Test::ShortIntD& iceP_p3, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opShortIntD_name);
    ::Test::ShortIntD ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p3);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opShortIntD(::Test::ShortIntD& iceP_p3, ::Test::ShortIntD& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opShortIntD_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p3);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opLongFloatD(const ::Test::LongFloatD& iceP_p1, const ::Test::LongFloatD& iceP_p2, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opLongFloatD_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opLongFloatD_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opLongFloatD_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_p1);
        ostr->write(iceP_p2);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opLongFloatD_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::LongFloatD
IceProxy::Test::MyClass::end_opLongFloatD(::Test::LongFloatD& iceP_p3, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opLongFloatD_name);
    ::Test::LongFloatD ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p3);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opLongFloatD(::Test::LongFloatD& iceP_p3, ::Test::LongFloatD& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opLongFloatD_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p3);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opStringStringD(const ::Test::StringStringD& iceP_p1, const ::Test::StringStringD& iceP_p2, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opStringStringD_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opStringStringD_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opStringStringD_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_p1);
        ostr->write(iceP_p2);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opStringStringD_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::StringStringD
IceProxy::Test::MyClass::end_opStringStringD(::Test::StringStringD& iceP_p3, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opStringStringD_name);
    ::Test::StringStringD ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p3);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opStringStringD(::Test::StringStringD& iceP_p3, ::Test::StringStringD& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opStringStringD_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p3);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opStringMyEnumD(const ::Test::StringMyEnumD& iceP_p1, const ::Test::StringMyEnumD& iceP_p2, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opStringMyEnumD_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opStringMyEnumD_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opStringMyEnumD_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_p1);
        ostr->write(iceP_p2);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opStringMyEnumD_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::StringMyEnumD
IceProxy::Test::MyClass::end_opStringMyEnumD(::Test::StringMyEnumD& iceP_p3, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opStringMyEnumD_name);
    ::Test::StringMyEnumD ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p3);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opStringMyEnumD(::Test::StringMyEnumD& iceP_p3, ::Test::StringMyEnumD& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opStringMyEnumD_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p3);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opMyEnumStringD(const ::Test::MyEnumStringD& iceP_p1, const ::Test::MyEnumStringD& iceP_p2, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opMyEnumStringD_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opMyEnumStringD_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opMyEnumStringD_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_p1);
        ostr->write(iceP_p2);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opMyEnumStringD_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::MyEnumStringD
IceProxy::Test::MyClass::end_opMyEnumStringD(::Test::MyEnumStringD& iceP_p3, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opMyEnumStringD_name);
    ::Test::MyEnumStringD ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p3);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opMyEnumStringD(::Test::MyEnumStringD& iceP_p3, ::Test::MyEnumStringD& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opMyEnumStringD_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p3);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opMyStructMyEnumD(const ::Test::MyStructMyEnumD& iceP_p1, const ::Test::MyStructMyEnumD& iceP_p2, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opMyStructMyEnumD_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opMyStructMyEnumD_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opMyStructMyEnumD_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_p1);
        ostr->write(iceP_p2);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opMyStructMyEnumD_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::MyStructMyEnumD
IceProxy::Test::MyClass::end_opMyStructMyEnumD(::Test::MyStructMyEnumD& iceP_p3, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opMyStructMyEnumD_name);
    ::Test::MyStructMyEnumD ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p3);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opMyStructMyEnumD(::Test::MyStructMyEnumD& iceP_p3, ::Test::MyStructMyEnumD& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opMyStructMyEnumD_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p3);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opByteBoolDS(const ::Test::ByteBoolDS& iceP_p1, const ::Test::ByteBoolDS& iceP_p2, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opByteBoolDS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opByteBoolDS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opByteBoolDS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_p1);
        ostr->write(iceP_p2);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opByteBoolDS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::ByteBoolDS
IceProxy::Test::MyClass::end_opByteBoolDS(::Test::ByteBoolDS& iceP_p3, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opByteBoolDS_name);
    ::Test::ByteBoolDS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p3);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opByteBoolDS(::Test::ByteBoolDS& iceP_p3, ::Test::ByteBoolDS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opByteBoolDS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p3);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opShortIntDS(const ::Test::ShortIntDS& iceP_p1, const ::Test::ShortIntDS& iceP_p2, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opShortIntDS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opShortIntDS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opShortIntDS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_p1);
        ostr->write(iceP_p2);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opShortIntDS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::ShortIntDS
IceProxy::Test::MyClass::end_opShortIntDS(::Test::ShortIntDS& iceP_p3, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opShortIntDS_name);
    ::Test::ShortIntDS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p3);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opShortIntDS(::Test::ShortIntDS& iceP_p3, ::Test::ShortIntDS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opShortIntDS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p3);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opLongFloatDS(const ::Test::LongFloatDS& iceP_p1, const ::Test::LongFloatDS& iceP_p2, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opLongFloatDS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opLongFloatDS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opLongFloatDS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_p1);
        ostr->write(iceP_p2);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opLongFloatDS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::LongFloatDS
IceProxy::Test::MyClass::end_opLongFloatDS(::Test::LongFloatDS& iceP_p3, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opLongFloatDS_name);
    ::Test::LongFloatDS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p3);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opLongFloatDS(::Test::LongFloatDS& iceP_p3, ::Test::LongFloatDS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opLongFloatDS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p3);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opStringStringDS(const ::Test::StringStringDS& iceP_p1, const ::Test::StringStringDS& iceP_p2, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opStringStringDS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opStringStringDS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opStringStringDS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_p1);
        ostr->write(iceP_p2);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opStringStringDS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::StringStringDS
IceProxy::Test::MyClass::end_opStringStringDS(::Test::StringStringDS& iceP_p3, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opStringStringDS_name);
    ::Test::StringStringDS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p3);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opStringStringDS(::Test::StringStringDS& iceP_p3, ::Test::StringStringDS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opStringStringDS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p3);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opStringMyEnumDS(const ::Test::StringMyEnumDS& iceP_p1, const ::Test::StringMyEnumDS& iceP_p2, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opStringMyEnumDS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opStringMyEnumDS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opStringMyEnumDS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_p1);
        ostr->write(iceP_p2);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opStringMyEnumDS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::StringMyEnumDS
IceProxy::Test::MyClass::end_opStringMyEnumDS(::Test::StringMyEnumDS& iceP_p3, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opStringMyEnumDS_name);
    ::Test::StringMyEnumDS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p3);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opStringMyEnumDS(::Test::StringMyEnumDS& iceP_p3, ::Test::StringMyEnumDS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opStringMyEnumDS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p3);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opMyEnumStringDS(const ::Test::MyEnumStringDS& iceP_p1, const ::Test::MyEnumStringDS& iceP_p2, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opMyEnumStringDS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opMyEnumStringDS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opMyEnumStringDS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_p1);
        ostr->write(iceP_p2);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opMyEnumStringDS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::MyEnumStringDS
IceProxy::Test::MyClass::end_opMyEnumStringDS(::Test::MyEnumStringDS& iceP_p3, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opMyEnumStringDS_name);
    ::Test::MyEnumStringDS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p3);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opMyEnumStringDS(::Test::MyEnumStringDS& iceP_p3, ::Test::MyEnumStringDS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opMyEnumStringDS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p3);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opMyStructMyEnumDS(const ::Test::MyStructMyEnumDS& iceP_p1, const ::Test::MyStructMyEnumDS& iceP_p2, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opMyStructMyEnumDS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opMyStructMyEnumDS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opMyStructMyEnumDS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_p1);
        ostr->write(iceP_p2);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opMyStructMyEnumDS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::MyStructMyEnumDS
IceProxy::Test::MyClass::end_opMyStructMyEnumDS(::Test::MyStructMyEnumDS& iceP_p3, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opMyStructMyEnumDS_name);
    ::Test::MyStructMyEnumDS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p3);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opMyStructMyEnumDS(::Test::MyStructMyEnumDS& iceP_p3, ::Test::MyStructMyEnumDS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opMyStructMyEnumDS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p3);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opByteByteSD(const ::Test::ByteByteSD& iceP_p1, const ::Test::ByteByteSD& iceP_p2, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opByteByteSD_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opByteByteSD_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opByteByteSD_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_p1);
        ostr->write(iceP_p2);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opByteByteSD_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::ByteByteSD
IceProxy::Test::MyClass::end_opByteByteSD(::Test::ByteByteSD& iceP_p3, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opByteByteSD_name);
    ::Test::ByteByteSD ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p3);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opByteByteSD(::Test::ByteByteSD& iceP_p3, ::Test::ByteByteSD& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opByteByteSD_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p3);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opBoolBoolSD(const ::Test::BoolBoolSD& iceP_p1, const ::Test::BoolBoolSD& iceP_p2, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opBoolBoolSD_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opBoolBoolSD_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opBoolBoolSD_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_p1);
        ostr->write(iceP_p2);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opBoolBoolSD_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::BoolBoolSD
IceProxy::Test::MyClass::end_opBoolBoolSD(::Test::BoolBoolSD& iceP_p3, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opBoolBoolSD_name);
    ::Test::BoolBoolSD ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p3);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opBoolBoolSD(::Test::BoolBoolSD& iceP_p3, ::Test::BoolBoolSD& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opBoolBoolSD_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p3);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opShortShortSD(const ::Test::ShortShortSD& iceP_p1, const ::Test::ShortShortSD& iceP_p2, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opShortShortSD_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opShortShortSD_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opShortShortSD_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_p1);
        ostr->write(iceP_p2);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opShortShortSD_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::ShortShortSD
IceProxy::Test::MyClass::end_opShortShortSD(::Test::ShortShortSD& iceP_p3, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opShortShortSD_name);
    ::Test::ShortShortSD ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p3);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opShortShortSD(::Test::ShortShortSD& iceP_p3, ::Test::ShortShortSD& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opShortShortSD_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p3);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opIntIntSD(const ::Test::IntIntSD& iceP_p1, const ::Test::IntIntSD& iceP_p2, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opIntIntSD_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opIntIntSD_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opIntIntSD_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_p1);
        ostr->write(iceP_p2);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opIntIntSD_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::IntIntSD
IceProxy::Test::MyClass::end_opIntIntSD(::Test::IntIntSD& iceP_p3, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opIntIntSD_name);
    ::Test::IntIntSD ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p3);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opIntIntSD(::Test::IntIntSD& iceP_p3, ::Test::IntIntSD& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opIntIntSD_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p3);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opLongLongSD(const ::Test::LongLongSD& iceP_p1, const ::Test::LongLongSD& iceP_p2, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opLongLongSD_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opLongLongSD_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opLongLongSD_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_p1);
        ostr->write(iceP_p2);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opLongLongSD_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::LongLongSD
IceProxy::Test::MyClass::end_opLongLongSD(::Test::LongLongSD& iceP_p3, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opLongLongSD_name);
    ::Test::LongLongSD ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p3);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opLongLongSD(::Test::LongLongSD& iceP_p3, ::Test::LongLongSD& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opLongLongSD_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p3);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opStringFloatSD(const ::Test::StringFloatSD& iceP_p1, const ::Test::StringFloatSD& iceP_p2, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opStringFloatSD_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opStringFloatSD_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opStringFloatSD_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_p1);
        ostr->write(iceP_p2);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opStringFloatSD_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::StringFloatSD
IceProxy::Test::MyClass::end_opStringFloatSD(::Test::StringFloatSD& iceP_p3, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opStringFloatSD_name);
    ::Test::StringFloatSD ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p3);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opStringFloatSD(::Test::StringFloatSD& iceP_p3, ::Test::StringFloatSD& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opStringFloatSD_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p3);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opStringDoubleSD(const ::Test::StringDoubleSD& iceP_p1, const ::Test::StringDoubleSD& iceP_p2, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opStringDoubleSD_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opStringDoubleSD_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opStringDoubleSD_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_p1);
        ostr->write(iceP_p2);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opStringDoubleSD_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::StringDoubleSD
IceProxy::Test::MyClass::end_opStringDoubleSD(::Test::StringDoubleSD& iceP_p3, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opStringDoubleSD_name);
    ::Test::StringDoubleSD ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p3);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opStringDoubleSD(::Test::StringDoubleSD& iceP_p3, ::Test::StringDoubleSD& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opStringDoubleSD_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p3);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opStringStringSD(const ::Test::StringStringSD& iceP_p1, const ::Test::StringStringSD& iceP_p2, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opStringStringSD_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opStringStringSD_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opStringStringSD_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_p1);
        ostr->write(iceP_p2);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opStringStringSD_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::StringStringSD
IceProxy::Test::MyClass::end_opStringStringSD(::Test::StringStringSD& iceP_p3, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opStringStringSD_name);
    ::Test::StringStringSD ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p3);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opStringStringSD(::Test::StringStringSD& iceP_p3, ::Test::StringStringSD& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opStringStringSD_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p3);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opMyEnumMyEnumSD(const ::Test::MyEnumMyEnumSD& iceP_p1, const ::Test::MyEnumMyEnumSD& iceP_p2, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opMyEnumMyEnumSD_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opMyEnumMyEnumSD_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opMyEnumMyEnumSD_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_p1);
        ostr->write(iceP_p2);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opMyEnumMyEnumSD_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::MyEnumMyEnumSD
IceProxy::Test::MyClass::end_opMyEnumMyEnumSD(::Test::MyEnumMyEnumSD& iceP_p3, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opMyEnumMyEnumSD_name);
    ::Test::MyEnumMyEnumSD ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p3);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opMyEnumMyEnumSD(::Test::MyEnumMyEnumSD& iceP_p3, ::Test::MyEnumMyEnumSD& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opMyEnumMyEnumSD_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p3);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opIntS(const ::Test::IntS& iceP_s, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opIntS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opIntS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opIntS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_s);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opIntS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::IntS
IceProxy::Test::MyClass::end_opIntS(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opIntS_name);
    ::Test::IntS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opByteSOneway(const ::Test::ByteS& iceP_s, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opByteSOneway_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opByteSOneway_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_s);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opByteSOneway_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Test::MyClass::end_opByteSOneway(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_Test_MyClass_opByteSOneway_name);
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opByteSOnewayCallCount(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opByteSOnewayCallCount_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opByteSOnewayCallCount_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opByteSOnewayCallCount_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Test_MyClass_opByteSOnewayCallCount_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Ice::Int
IceProxy::Test::MyClass::end_opByteSOnewayCallCount(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opByteSOnewayCallCount_name);
    ::Ice::Int ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opContext(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opContext_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opContext_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opContext_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Test_MyClass_opContext_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Ice::Context
IceProxy::Test::MyClass::end_opContext(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opContext_name);
    ::Ice::Context ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opDoubleMarshaling(::Ice::Double iceP_p1, const ::Test::DoubleS& iceP_p2, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opDoubleMarshaling_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opDoubleMarshaling_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_p1);
        ostr->write(iceP_p2);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opDoubleMarshaling_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Test::MyClass::end_opDoubleMarshaling(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_Test_MyClass_opDoubleMarshaling_name);
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opIdempotent(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opIdempotent_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opIdempotent_name, ::Ice::Idempotent, context);
        result->writeEmptyParams();
        result->invoke(iceC_Test_MyClass_opIdempotent_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Test::MyClass::end_opIdempotent(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_Test_MyClass_opIdempotent_name);
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opNonmutating(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opNonmutating_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opNonmutating_name, ::Ice::Nonmutating, context);
        result->writeEmptyParams();
        result->invoke(iceC_Test_MyClass_opNonmutating_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Test::MyClass::end_opNonmutating(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_Test_MyClass_opNonmutating_name);
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opByte1(::Ice::Byte iceP_opByte1, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opByte1_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opByte1_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opByte1_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_opByte1);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opByte1_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Ice::Byte
IceProxy::Test::MyClass::end_opByte1(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opByte1_name);
    ::Ice::Byte ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opShort1(::Ice::Short iceP_opShort1, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opShort1_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opShort1_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opShort1_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_opShort1);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opShort1_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Ice::Short
IceProxy::Test::MyClass::end_opShort1(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opShort1_name);
    ::Ice::Short ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opInt1(::Ice::Int iceP_opInt1, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opInt1_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opInt1_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opInt1_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_opInt1);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opInt1_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Ice::Int
IceProxy::Test::MyClass::end_opInt1(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opInt1_name);
    ::Ice::Int ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opLong1(::Ice::Long iceP_opLong1, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opLong1_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opLong1_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opLong1_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_opLong1);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opLong1_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Ice::Long
IceProxy::Test::MyClass::end_opLong1(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opLong1_name);
    ::Ice::Long ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opFloat1(::Ice::Float iceP_opFloat1, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opFloat1_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opFloat1_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opFloat1_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_opFloat1);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opFloat1_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Ice::Float
IceProxy::Test::MyClass::end_opFloat1(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opFloat1_name);
    ::Ice::Float ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opDouble1(::Ice::Double iceP_opDouble1, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opDouble1_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opDouble1_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opDouble1_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_opDouble1);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opDouble1_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Ice::Double
IceProxy::Test::MyClass::end_opDouble1(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opDouble1_name);
    ::Ice::Double ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opString1(const ::std::string& iceP_opString1, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opString1_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opString1_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opString1_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_opString1);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opString1_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::std::string
IceProxy::Test::MyClass::end_opString1(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opString1_name);
    ::std::string ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opStringS1(const ::Test::StringS& iceP_opStringS1, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opStringS1_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opStringS1_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opStringS1_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_opStringS1);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opStringS1_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::StringS
IceProxy::Test::MyClass::end_opStringS1(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opStringS1_name);
    ::Test::StringS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opByteBoolD1(const ::Test::ByteBoolD& iceP_opByteBoolD1, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opByteBoolD1_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opByteBoolD1_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opByteBoolD1_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_opByteBoolD1);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opByteBoolD1_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::ByteBoolD
IceProxy::Test::MyClass::end_opByteBoolD1(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opByteBoolD1_name);
    ::Test::ByteBoolD ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opStringS2(const ::Test::StringS& iceP_stringS, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opStringS2_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opStringS2_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opStringS2_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_stringS);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opStringS2_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::StringS
IceProxy::Test::MyClass::end_opStringS2(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opStringS2_name);
    ::Test::StringS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opByteBoolD2(const ::Test::ByteBoolD& iceP_byteBoolD, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opByteBoolD2_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opByteBoolD2_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opByteBoolD2_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_byteBoolD);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opByteBoolD2_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::ByteBoolD
IceProxy::Test::MyClass::end_opByteBoolD2(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opByteBoolD2_name);
    ::Test::ByteBoolD ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opStringLiterals(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opStringLiterals_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opStringLiterals_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opStringLiterals_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Test_MyClass_opStringLiterals_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::StringS
IceProxy::Test::MyClass::end_opStringLiterals(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opStringLiterals_name);
    ::Test::StringS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opWStringLiterals(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opWStringLiterals_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opWStringLiterals_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opWStringLiterals_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Test_MyClass_opWStringLiterals_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::StringS
IceProxy::Test::MyClass::end_opWStringLiterals(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opWStringLiterals_name);
    ::Test::StringS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opMStruct1(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opMStruct1_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opMStruct1_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opMStruct1_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Test_MyClass_opMStruct1_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::Structure
IceProxy::Test::MyClass::end_opMStruct1(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opMStruct1_name);
    ::Test::Structure ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opMStruct2(const ::Test::Structure& iceP_p1, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opMStruct2_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opMStruct2_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opMStruct2_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_p1);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opMStruct2_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::Structure
IceProxy::Test::MyClass::end_opMStruct2(::Test::Structure& iceP_p2, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opMStruct2_name);
    ::Test::Structure ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p2);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opMStruct2(::Test::Structure& iceP_p2, ::Test::Structure& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opMStruct2_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p2);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opMSeq1(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opMSeq1_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opMSeq1_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opMSeq1_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Test_MyClass_opMSeq1_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::StringS
IceProxy::Test::MyClass::end_opMSeq1(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opMSeq1_name);
    ::Test::StringS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opMSeq2(const ::Test::StringS& iceP_p1, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opMSeq2_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opMSeq2_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opMSeq2_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_p1);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opMSeq2_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::StringS
IceProxy::Test::MyClass::end_opMSeq2(::Test::StringS& iceP_p2, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opMSeq2_name);
    ::Test::StringS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p2);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opMSeq2(::Test::StringS& iceP_p2, ::Test::StringS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opMSeq2_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p2);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opMDict1(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opMDict1_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opMDict1_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opMDict1_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Test_MyClass_opMDict1_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::StringStringD
IceProxy::Test::MyClass::end_opMDict1(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opMDict1_name);
    ::Test::StringStringD ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opMDict2(const ::Test::StringStringD& iceP_p1, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opMDict2_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opMDict2_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opMDict2_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_p1);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opMDict2_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::StringStringD
IceProxy::Test::MyClass::end_opMDict2(::Test::StringStringD& iceP_p2, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opMDict2_name);
    ::Test::StringStringD ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p2);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opMDict2(::Test::StringStringD& iceP_p2, ::Test::StringStringD& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opMDict2_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p2);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_getNSNullStringSeq(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_getNSNullStringSeq_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_getNSNullStringSeq_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_getNSNullStringSeq_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Test_MyClass_getNSNullStringSeq_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::StringS
IceProxy::Test::MyClass::end_getNSNullStringSeq(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_getNSNullStringSeq_name);
    ::Test::StringS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_getNSNullASeq(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_getNSNullASeq_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_getNSNullASeq_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_getNSNullASeq_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Test_MyClass_getNSNullASeq_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::AS
IceProxy::Test::MyClass::end_getNSNullASeq(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_getNSNullASeq_name);
    ::Test::AS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    istr->readPendingValues();
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_getNSNullStructSeq(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_getNSNullStructSeq_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_getNSNullStructSeq_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_getNSNullStructSeq_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Test_MyClass_getNSNullStructSeq_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::StructS
IceProxy::Test::MyClass::end_getNSNullStructSeq(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_getNSNullStructSeq_name);
    ::Test::StructS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_getNSNullStringSeqSeq(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_getNSNullStringSeqSeq_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_getNSNullStringSeqSeq_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_getNSNullStringSeqSeq_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Test_MyClass_getNSNullStringSeqSeq_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::StringSS
IceProxy::Test::MyClass::end_getNSNullStringSeqSeq(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_getNSNullStringSeqSeq_name);
    ::Test::StringSS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_getNSNullStringStringDict(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_getNSNullStringStringDict_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_getNSNullStringStringDict_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_getNSNullStringStringDict_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Test_MyClass_getNSNullStringStringDict_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::StringStringD
IceProxy::Test::MyClass::end_getNSNullStringStringDict(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_getNSNullStringStringDict_name);
    ::Test::StringStringD ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_putNSNullStringStringDict(const ::Test::StringStringD& iceP_d, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_putNSNullStringStringDict_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_putNSNullStringStringDict_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_d);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_putNSNullStringStringDict_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Test::MyClass::end_putNSNullStringStringDict(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_Test_MyClass_putNSNullStringStringDict_name);
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_putNSNullShortIntDict(const ::Test::ShortIntD& iceP_d, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_putNSNullShortIntDict_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_putNSNullShortIntDict_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_d);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_putNSNullShortIntDict_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Test::MyClass::end_putNSNullShortIntDict(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_Test_MyClass_putNSNullShortIntDict_name);
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_putNSNullStringMyEnumDict(const ::Test::StringMyEnumD& iceP_d, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_putNSNullStringMyEnumDict_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_putNSNullStringMyEnumDict_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_d);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_putNSNullStringMyEnumDict_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Test::MyClass::end_putNSNullStringMyEnumDict(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_Test_MyClass_putNSNullStringMyEnumDict_name);
}

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::Test::MyClass::_newInstance() const
{
    return new MyClass;
}
/// \endcond

const ::std::string&
IceProxy::Test::MyClass::ice_staticId()
{
    return ::Test::MyClass::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(MyClass1* p) { return p; }

void
::IceProxy::Test::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< MyClass1>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new MyClass1;
        v->_copyFrom(proxy);
    }
}
/// \endcond

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::Test::MyClass1::_newInstance() const
{
    return new MyClass1;
}
/// \endcond

const ::std::string&
IceProxy::Test::MyClass1::ice_staticId()
{
    return ::Test::MyClass1::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(MyDerivedClass* p) { return p; }

void
::IceProxy::Test::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< MyDerivedClass>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new MyDerivedClass;
        v->_copyFrom(proxy);
    }
}
/// \endcond

::Ice::AsyncResultPtr
IceProxy::Test::MyDerivedClass::_iceI_begin_opDerived(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyDerivedClass_opDerived_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyDerivedClass_opDerived_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Test_MyDerivedClass_opDerived_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Test::MyDerivedClass::end_opDerived(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_Test_MyDerivedClass_opDerived_name);
}

::Ice::AsyncResultPtr
IceProxy::Test::MyDerivedClass::_iceI_begin_opMyClass1(const ::Test::MyClass1Ptr& iceP_c, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyDerivedClass_opMyClass1_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyDerivedClass_opMyClass1_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyDerivedClass_opMyClass1_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_c);
        ostr->writePendingValues();
        result->endWriteParams();
        result->invoke(iceC_Test_MyDerivedClass_opMyClass1_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::MyClass1Ptr
IceProxy::Test::MyDerivedClass::end_opMyClass1(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyDerivedClass_opMyClass1_name);
    ::Test::MyClass1Ptr ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    istr->readPendingValues();
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Test::MyDerivedClass::_iceI_begin_opMyStruct1(const ::Test::MyStruct1& iceP_c, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyDerivedClass_opMyStruct1_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyDerivedClass_opMyStruct1_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyDerivedClass_opMyStruct1_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_c);
        result->endWriteParams();
        result->invoke(iceC_Test_MyDerivedClass_opMyStruct1_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::MyStruct1
IceProxy::Test::MyDerivedClass::end_opMyStruct1(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyDerivedClass_opMyStruct1_name);
    ::Test::MyStruct1 ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::Test::MyDerivedClass::_newInstance() const
{
    return new MyDerivedClass;
}
/// \endcond

const ::std::string&
IceProxy::Test::MyDerivedClass::ice_staticId()
{
    return ::Test::MyDerivedClass::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::Test2::upCast(MyDerivedClass* p) { return p; }

void
::IceProxy::Test2::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< MyDerivedClass>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new MyDerivedClass;
        v->_copyFrom(proxy);
    }
}
/// \endcond

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::Test2::MyDerivedClass::_newInstance() const
{
    return new MyDerivedClass;
}
/// \endcond

const ::std::string&
IceProxy::Test2::MyDerivedClass::ice_staticId()
{
    return ::Test2::MyDerivedClass::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::M::upCast(A* p) { return p; }

void
::IceProxy::M::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< A>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new A;
        v->_copyFrom(proxy);
    }
}
/// \endcond

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::M::A::_newInstance() const
{
    return new A;
}
/// \endcond

const ::std::string&
IceProxy::M::A::ice_staticId()
{
    return ::M::A::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::M::upCast(Intf* p) { return p; }

void
::IceProxy::M::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< Intf>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new Intf;
        v->_copyFrom(proxy);
    }
}
/// \endcond

::Ice::AsyncResultPtr
IceProxy::M::Intf::_iceI_begin_opIntf(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_M_Intf_opIntf_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_M_Intf_opIntf_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_M_Intf_opIntf_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::M::Intf::end_opIntf(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_M_Intf_opIntf_name);
}

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::M::Intf::_newInstance() const
{
    return new Intf;
}
/// \endcond

const ::std::string&
IceProxy::M::Intf::ice_staticId()
{
    return ::M::Intf::ice_staticId();
}

::IceProxy::M::_BBase::~_BBase()
{
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::M::upCast(B* p) { return p; }

void
::IceProxy::M::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< B>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new B;
        v->_copyFrom(proxy);
    }
}
/// \endcond

::Ice::AsyncResultPtr
IceProxy::M::B::_iceI_begin_opB(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_M_B_opB_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_M_B_opB_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_M_B_opB_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::M::B::end_opB(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_M_B_opB_name);
}

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::M::B::_newInstance() const
{
    return new B;
}
/// \endcond

const ::std::string&
IceProxy::M::B::ice_staticId()
{
    return ::M::B::ice_staticId();
}

Test::A::~A()
{
}

/// \cond INTERNAL
::Ice::Object* Test::upCast(A* p) { return p; }

/// \endcond
::Ice::ObjectPtr
Test::A::ice_clone() const
{
    ::Ice::Object* p = new A(*this);
    return p;
}

namespace
{
const ::std::string iceC_Test_A_ids[2] =
{
    "::Ice::Object",
    "::Test::A"
};

}

bool
Test::A::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_A_ids, iceC_Test_A_ids + 2, s);
}

::std::vector< ::std::string>
Test::A::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Test_A_ids[0], &iceC_Test_A_ids[2]);
}

const ::std::string&
Test::A::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::A::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::Test::A";
    return typeId;
#else
    return iceC_Test_A_ids[1];
#endif
}

/// \cond STREAM
void
Test::A::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< A, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Test::A::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< A, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

namespace
{
const ::IceInternal::DefaultValueFactoryInit< ::Test::A> iceC_Test_A_init("::Test::A");
}

::Ice::ValueFactoryPtr
Test::A::ice_factory()
{
    return ::IceInternal::factoryTable->getValueFactory(::Test::A::ice_staticId());
}

/// \cond INTERNAL
void
Test::_icePatchObjectPtr(APtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = APtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(A::ice_staticId(), v);
    }
}
/// \endcond

Test::MyClass::~MyClass()
{
}

/// \cond INTERNAL
::Ice::Object* Test::upCast(MyClass* p) { return p; }

/// \endcond

namespace
{
const ::std::string iceC_Test_MyClass_ids[2] =
{
    "::Ice::Object",
    "::Test::MyClass"
};

}

bool
Test::MyClass::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_MyClass_ids, iceC_Test_MyClass_ids + 2, s);
}

::std::vector< ::std::string>
Test::MyClass::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Test_MyClass_ids[0], &iceC_Test_MyClass_ids[2]);
}

const ::std::string&
Test::MyClass::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::MyClass::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::Test::MyClass";
    return typeId;
#else
    return iceC_Test_MyClass_ids[1];
#endif
}

/// \cond INTERNAL
bool
Test::MyClass::_iceD_shutdown(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    this->shutdown(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_supportsCompress(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    bool ret = this->supportsCompress(current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opVoid(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    this->opVoid(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opByte(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Byte iceP_p1;
    ::Ice::Byte iceP_p2;
    istr->read(iceP_p1);
    istr->read(iceP_p2);
    inS.endReadParams();
    ::Ice::Byte iceP_p3;
    ::Ice::Byte ret = this->opByte(iceP_p1, iceP_p2, iceP_p3, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_p3);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opBool(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    bool iceP_p1;
    bool iceP_p2;
    istr->read(iceP_p1);
    istr->read(iceP_p2);
    inS.endReadParams();
    bool iceP_p3;
    bool ret = this->opBool(iceP_p1, iceP_p2, iceP_p3, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_p3);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opShortIntLong(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Short iceP_p1;
    ::Ice::Int iceP_p2;
    ::Ice::Long iceP_p3;
    istr->read(iceP_p1);
    istr->read(iceP_p2);
    istr->read(iceP_p3);
    inS.endReadParams();
    ::Ice::Short iceP_p4;
    ::Ice::Int iceP_p5;
    ::Ice::Long iceP_p6;
    ::Ice::Long ret = this->opShortIntLong(iceP_p1, iceP_p2, iceP_p3, iceP_p4, iceP_p5, iceP_p6, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_p4);
    ostr->write(iceP_p5);
    ostr->write(iceP_p6);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opFloatDouble(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Float iceP_p1;
    ::Ice::Double iceP_p2;
    istr->read(iceP_p1);
    istr->read(iceP_p2);
    inS.endReadParams();
    ::Ice::Float iceP_p3;
    ::Ice::Double iceP_p4;
    ::Ice::Double ret = this->opFloatDouble(iceP_p1, iceP_p2, iceP_p3, iceP_p4, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_p3);
    ostr->write(iceP_p4);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opString(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_p1;
    ::std::string iceP_p2;
    istr->read(iceP_p1);
    istr->read(iceP_p2);
    inS.endReadParams();
    ::std::string iceP_p3;
    ::std::string ret = this->opString(iceP_p1, iceP_p2, iceP_p3, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_p3);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opMyEnum(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    MyEnum iceP_p1;
    istr->read(iceP_p1);
    inS.endReadParams();
    MyEnum iceP_p2;
    MyEnum ret = this->opMyEnum(iceP_p1, iceP_p2, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_p2);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opMyClass(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    MyClassPrx iceP_p1;
    istr->read(iceP_p1);
    inS.endReadParams();
    MyClassPrx iceP_p2;
    MyClassPrx iceP_p3;
    MyClassPrx ret = this->opMyClass(iceP_p1, iceP_p2, iceP_p3, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_p2);
    ostr->write(iceP_p3);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opStruct(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    Structure iceP_p1;
    Structure iceP_p2;
    istr->read(iceP_p1);
    istr->read(iceP_p2);
    inS.endReadParams();
    Structure iceP_p3;
    Structure ret = this->opStruct(iceP_p1, iceP_p2, iceP_p3, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_p3);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opByteS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ByteS iceP_p1;
    ByteS iceP_p2;
    istr->read(iceP_p1);
    istr->read(iceP_p2);
    inS.endReadParams();
    ByteS iceP_p3;
    ByteS ret = this->opByteS(iceP_p1, iceP_p2, iceP_p3, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_p3);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opBoolS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    BoolS iceP_p1;
    BoolS iceP_p2;
    istr->read(iceP_p1);
    istr->read(iceP_p2);
    inS.endReadParams();
    BoolS iceP_p3;
    BoolS ret = this->opBoolS(iceP_p1, iceP_p2, iceP_p3, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_p3);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opShortIntLongS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ShortS iceP_p1;
    IntS iceP_p2;
    LongS iceP_p3;
    istr->read(iceP_p1);
    istr->read(iceP_p2);
    istr->read(iceP_p3);
    inS.endReadParams();
    ShortS iceP_p4;
    IntS iceP_p5;
    LongS iceP_p6;
    LongS ret = this->opShortIntLongS(iceP_p1, iceP_p2, iceP_p3, iceP_p4, iceP_p5, iceP_p6, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_p4);
    ostr->write(iceP_p5);
    ostr->write(iceP_p6);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opFloatDoubleS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    FloatS iceP_p1;
    DoubleS iceP_p2;
    istr->read(iceP_p1);
    istr->read(iceP_p2);
    inS.endReadParams();
    FloatS iceP_p3;
    DoubleS iceP_p4;
    DoubleS ret = this->opFloatDoubleS(iceP_p1, iceP_p2, iceP_p3, iceP_p4, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_p3);
    ostr->write(iceP_p4);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opStringS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    StringS iceP_p1;
    StringS iceP_p2;
    istr->read(iceP_p1);
    istr->read(iceP_p2);
    inS.endReadParams();
    StringS iceP_p3;
    StringS ret = this->opStringS(iceP_p1, iceP_p2, iceP_p3, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_p3);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opMyEnumS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    MyEnumS iceP_p1;
    MyEnumS iceP_p2;
    istr->read(iceP_p1);
    istr->read(iceP_p2);
    inS.endReadParams();
    MyEnumS iceP_p3;
    MyEnumS ret = this->opMyEnumS(iceP_p1, iceP_p2, iceP_p3, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_p3);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opMyClassS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    MyClassS iceP_p1;
    MyClassS iceP_p2;
    istr->read(iceP_p1);
    istr->read(iceP_p2);
    inS.endReadParams();
    MyClassS iceP_p3;
    MyClassS ret = this->opMyClassS(iceP_p1, iceP_p2, iceP_p3, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_p3);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opByteSS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ByteSS iceP_p1;
    ByteSS iceP_p2;
    istr->read(iceP_p1);
    istr->read(iceP_p2);
    inS.endReadParams();
    ByteSS iceP_p3;
    ByteSS ret = this->opByteSS(iceP_p1, iceP_p2, iceP_p3, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_p3);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opBoolSS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    BoolSS iceP_p1;
    BoolSS iceP_p2;
    istr->read(iceP_p1);
    istr->read(iceP_p2);
    inS.endReadParams();
    BoolSS iceP_p3;
    BoolSS ret = this->opBoolSS(iceP_p1, iceP_p2, iceP_p3, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_p3);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opShortIntLongSS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ShortSS iceP_p1;
    IntSS iceP_p2;
    LongSS iceP_p3;
    istr->read(iceP_p1);
    istr->read(iceP_p2);
    istr->read(iceP_p3);
    inS.endReadParams();
    ShortSS iceP_p4;
    IntSS iceP_p5;
    LongSS iceP_p6;
    LongSS ret = this->opShortIntLongSS(iceP_p1, iceP_p2, iceP_p3, iceP_p4, iceP_p5, iceP_p6, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_p4);
    ostr->write(iceP_p5);
    ostr->write(iceP_p6);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opFloatDoubleSS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    FloatSS iceP_p1;
    DoubleSS iceP_p2;
    istr->read(iceP_p1);
    istr->read(iceP_p2);
    inS.endReadParams();
    FloatSS iceP_p3;
    DoubleSS iceP_p4;
    DoubleSS ret = this->opFloatDoubleSS(iceP_p1, iceP_p2, iceP_p3, iceP_p4, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_p3);
    ostr->write(iceP_p4);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opStringSS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    StringSS iceP_p1;
    StringSS iceP_p2;
    istr->read(iceP_p1);
    istr->read(iceP_p2);
    inS.endReadParams();
    StringSS iceP_p3;
    StringSS ret = this->opStringSS(iceP_p1, iceP_p2, iceP_p3, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_p3);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opStringSSS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    StringSSS iceP_p1;
    StringSSS iceP_p2;
    istr->read(iceP_p1);
    istr->read(iceP_p2);
    inS.endReadParams();
    StringSSS iceP_p3;
    StringSSS ret = this->opStringSSS(iceP_p1, iceP_p2, iceP_p3, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_p3);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opByteBoolD(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ByteBoolD iceP_p1;
    ByteBoolD iceP_p2;
    istr->read(iceP_p1);
    istr->read(iceP_p2);
    inS.endReadParams();
    ByteBoolD iceP_p3;
    ByteBoolD ret = this->opByteBoolD(iceP_p1, iceP_p2, iceP_p3, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_p3);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opShortIntD(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ShortIntD iceP_p1;
    ShortIntD iceP_p2;
    istr->read(iceP_p1);
    istr->read(iceP_p2);
    inS.endReadParams();
    ShortIntD iceP_p3;
    ShortIntD ret = this->opShortIntD(iceP_p1, iceP_p2, iceP_p3, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_p3);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opLongFloatD(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    LongFloatD iceP_p1;
    LongFloatD iceP_p2;
    istr->read(iceP_p1);
    istr->read(iceP_p2);
    inS.endReadParams();
    LongFloatD iceP_p3;
    LongFloatD ret = this->opLongFloatD(iceP_p1, iceP_p2, iceP_p3, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_p3);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opStringStringD(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    StringStringD iceP_p1;
    StringStringD iceP_p2;
    istr->read(iceP_p1);
    istr->read(iceP_p2);
    inS.endReadParams();
    StringStringD iceP_p3;
    StringStringD ret = this->opStringStringD(iceP_p1, iceP_p2, iceP_p3, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_p3);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opStringMyEnumD(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    StringMyEnumD iceP_p1;
    StringMyEnumD iceP_p2;
    istr->read(iceP_p1);
    istr->read(iceP_p2);
    inS.endReadParams();
    StringMyEnumD iceP_p3;
    StringMyEnumD ret = this->opStringMyEnumD(iceP_p1, iceP_p2, iceP_p3, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_p3);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opMyEnumStringD(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    MyEnumStringD iceP_p1;
    MyEnumStringD iceP_p2;
    istr->read(iceP_p1);
    istr->read(iceP_p2);
    inS.endReadParams();
    MyEnumStringD iceP_p3;
    MyEnumStringD ret = this->opMyEnumStringD(iceP_p1, iceP_p2, iceP_p3, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_p3);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opMyStructMyEnumD(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    MyStructMyEnumD iceP_p1;
    MyStructMyEnumD iceP_p2;
    istr->read(iceP_p1);
    istr->read(iceP_p2);
    inS.endReadParams();
    MyStructMyEnumD iceP_p3;
    MyStructMyEnumD ret = this->opMyStructMyEnumD(iceP_p1, iceP_p2, iceP_p3, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_p3);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opByteBoolDS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ByteBoolDS iceP_p1;
    ByteBoolDS iceP_p2;
    istr->read(iceP_p1);
    istr->read(iceP_p2);
    inS.endReadParams();
    ByteBoolDS iceP_p3;
    ByteBoolDS ret = this->opByteBoolDS(iceP_p1, iceP_p2, iceP_p3, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_p3);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opShortIntDS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ShortIntDS iceP_p1;
    ShortIntDS iceP_p2;
    istr->read(iceP_p1);
    istr->read(iceP_p2);
    inS.endReadParams();
    ShortIntDS iceP_p3;
    ShortIntDS ret = this->opShortIntDS(iceP_p1, iceP_p2, iceP_p3, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_p3);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opLongFloatDS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    LongFloatDS iceP_p1;
    LongFloatDS iceP_p2;
    istr->read(iceP_p1);
    istr->read(iceP_p2);
    inS.endReadParams();
    LongFloatDS iceP_p3;
    LongFloatDS ret = this->opLongFloatDS(iceP_p1, iceP_p2, iceP_p3, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_p3);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opStringStringDS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    StringStringDS iceP_p1;
    StringStringDS iceP_p2;
    istr->read(iceP_p1);
    istr->read(iceP_p2);
    inS.endReadParams();
    StringStringDS iceP_p3;
    StringStringDS ret = this->opStringStringDS(iceP_p1, iceP_p2, iceP_p3, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_p3);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opStringMyEnumDS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    StringMyEnumDS iceP_p1;
    StringMyEnumDS iceP_p2;
    istr->read(iceP_p1);
    istr->read(iceP_p2);
    inS.endReadParams();
    StringMyEnumDS iceP_p3;
    StringMyEnumDS ret = this->opStringMyEnumDS(iceP_p1, iceP_p2, iceP_p3, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_p3);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opMyEnumStringDS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    MyEnumStringDS iceP_p1;
    MyEnumStringDS iceP_p2;
    istr->read(iceP_p1);
    istr->read(iceP_p2);
    inS.endReadParams();
    MyEnumStringDS iceP_p3;
    MyEnumStringDS ret = this->opMyEnumStringDS(iceP_p1, iceP_p2, iceP_p3, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_p3);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opMyStructMyEnumDS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    MyStructMyEnumDS iceP_p1;
    MyStructMyEnumDS iceP_p2;
    istr->read(iceP_p1);
    istr->read(iceP_p2);
    inS.endReadParams();
    MyStructMyEnumDS iceP_p3;
    MyStructMyEnumDS ret = this->opMyStructMyEnumDS(iceP_p1, iceP_p2, iceP_p3, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_p3);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opByteByteSD(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ByteByteSD iceP_p1;
    ByteByteSD iceP_p2;
    istr->read(iceP_p1);
    istr->read(iceP_p2);
    inS.endReadParams();
    ByteByteSD iceP_p3;
    ByteByteSD ret = this->opByteByteSD(iceP_p1, iceP_p2, iceP_p3, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_p3);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opBoolBoolSD(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    BoolBoolSD iceP_p1;
    BoolBoolSD iceP_p2;
    istr->read(iceP_p1);
    istr->read(iceP_p2);
    inS.endReadParams();
    BoolBoolSD iceP_p3;
    BoolBoolSD ret = this->opBoolBoolSD(iceP_p1, iceP_p2, iceP_p3, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_p3);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opShortShortSD(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ShortShortSD iceP_p1;
    ShortShortSD iceP_p2;
    istr->read(iceP_p1);
    istr->read(iceP_p2);
    inS.endReadParams();
    ShortShortSD iceP_p3;
    ShortShortSD ret = this->opShortShortSD(iceP_p1, iceP_p2, iceP_p3, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_p3);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opIntIntSD(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    IntIntSD iceP_p1;
    IntIntSD iceP_p2;
    istr->read(iceP_p1);
    istr->read(iceP_p2);
    inS.endReadParams();
    IntIntSD iceP_p3;
    IntIntSD ret = this->opIntIntSD(iceP_p1, iceP_p2, iceP_p3, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_p3);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opLongLongSD(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    LongLongSD iceP_p1;
    LongLongSD iceP_p2;
    istr->read(iceP_p1);
    istr->read(iceP_p2);
    inS.endReadParams();
    LongLongSD iceP_p3;
    LongLongSD ret = this->opLongLongSD(iceP_p1, iceP_p2, iceP_p3, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_p3);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opStringFloatSD(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    StringFloatSD iceP_p1;
    StringFloatSD iceP_p2;
    istr->read(iceP_p1);
    istr->read(iceP_p2);
    inS.endReadParams();
    StringFloatSD iceP_p3;
    StringFloatSD ret = this->opStringFloatSD(iceP_p1, iceP_p2, iceP_p3, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_p3);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opStringDoubleSD(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    StringDoubleSD iceP_p1;
    StringDoubleSD iceP_p2;
    istr->read(iceP_p1);
    istr->read(iceP_p2);
    inS.endReadParams();
    StringDoubleSD iceP_p3;
    StringDoubleSD ret = this->opStringDoubleSD(iceP_p1, iceP_p2, iceP_p3, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_p3);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opStringStringSD(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    StringStringSD iceP_p1;
    StringStringSD iceP_p2;
    istr->read(iceP_p1);
    istr->read(iceP_p2);
    inS.endReadParams();
    StringStringSD iceP_p3;
    StringStringSD ret = this->opStringStringSD(iceP_p1, iceP_p2, iceP_p3, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_p3);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opMyEnumMyEnumSD(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    MyEnumMyEnumSD iceP_p1;
    MyEnumMyEnumSD iceP_p2;
    istr->read(iceP_p1);
    istr->read(iceP_p2);
    inS.endReadParams();
    MyEnumMyEnumSD iceP_p3;
    MyEnumMyEnumSD ret = this->opMyEnumMyEnumSD(iceP_p1, iceP_p2, iceP_p3, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_p3);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opIntS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    IntS iceP_s;
    istr->read(iceP_s);
    inS.endReadParams();
    IntS ret = this->opIntS(iceP_s, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opByteSOneway(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ByteS iceP_s;
    istr->read(iceP_s);
    inS.endReadParams();
    this->opByteSOneway(iceP_s, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opByteSOnewayCallCount(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    ::Ice::Int ret = this->opByteSOnewayCallCount(current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opContext(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    ::Ice::Context ret = this->opContext(current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opDoubleMarshaling(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Double iceP_p1;
    DoubleS iceP_p2;
    istr->read(iceP_p1);
    istr->read(iceP_p2);
    inS.endReadParams();
    this->opDoubleMarshaling(iceP_p1, iceP_p2, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opIdempotent(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    inS.readEmptyParams();
    this->opIdempotent(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opNonmutating(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Idempotent, current.mode);
    inS.readEmptyParams();
    this->opNonmutating(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opByte1(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Byte iceP_opByte1;
    istr->read(iceP_opByte1);
    inS.endReadParams();
    ::Ice::Byte ret = this->opByte1(iceP_opByte1, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opShort1(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Short iceP_opShort1;
    istr->read(iceP_opShort1);
    inS.endReadParams();
    ::Ice::Short ret = this->opShort1(iceP_opShort1, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opInt1(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Int iceP_opInt1;
    istr->read(iceP_opInt1);
    inS.endReadParams();
    ::Ice::Int ret = this->opInt1(iceP_opInt1, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opLong1(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Long iceP_opLong1;
    istr->read(iceP_opLong1);
    inS.endReadParams();
    ::Ice::Long ret = this->opLong1(iceP_opLong1, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opFloat1(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Float iceP_opFloat1;
    istr->read(iceP_opFloat1);
    inS.endReadParams();
    ::Ice::Float ret = this->opFloat1(iceP_opFloat1, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opDouble1(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Double iceP_opDouble1;
    istr->read(iceP_opDouble1);
    inS.endReadParams();
    ::Ice::Double ret = this->opDouble1(iceP_opDouble1, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opString1(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_opString1;
    istr->read(iceP_opString1);
    inS.endReadParams();
    ::std::string ret = this->opString1(iceP_opString1, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opStringS1(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    StringS iceP_opStringS1;
    istr->read(iceP_opStringS1);
    inS.endReadParams();
    StringS ret = this->opStringS1(iceP_opStringS1, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opByteBoolD1(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ByteBoolD iceP_opByteBoolD1;
    istr->read(iceP_opByteBoolD1);
    inS.endReadParams();
    ByteBoolD ret = this->opByteBoolD1(iceP_opByteBoolD1, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opStringS2(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    StringS iceP_stringS;
    istr->read(iceP_stringS);
    inS.endReadParams();
    StringS ret = this->opStringS2(iceP_stringS, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opByteBoolD2(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ByteBoolD iceP_byteBoolD;
    istr->read(iceP_byteBoolD);
    inS.endReadParams();
    ByteBoolD ret = this->opByteBoolD2(iceP_byteBoolD, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opStringLiterals(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    StringS ret = this->opStringLiterals(current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opWStringLiterals(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    StringS ret = this->opWStringLiterals(current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opMStruct1(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    Structure ret = this->opMStruct1(current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opMStruct2(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    Structure iceP_p1;
    istr->read(iceP_p1);
    inS.endReadParams();
    Structure iceP_p2;
    Structure ret = this->opMStruct2(iceP_p1, iceP_p2, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_p2);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opMSeq1(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    StringS ret = this->opMSeq1(current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opMSeq2(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    StringS iceP_p1;
    istr->read(iceP_p1);
    inS.endReadParams();
    StringS iceP_p2;
    StringS ret = this->opMSeq2(iceP_p1, iceP_p2, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_p2);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opMDict1(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    StringStringD ret = this->opMDict1(current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opMDict2(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    StringStringD iceP_p1;
    istr->read(iceP_p1);
    inS.endReadParams();
    StringStringD iceP_p2;
    StringStringD ret = this->opMDict2(iceP_p1, iceP_p2, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_p2);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_getNSNullStringSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    StringS ret = this->getNSNullStringSeq(current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_getNSNullASeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    AS ret = this->getNSNullASeq(current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_getNSNullStructSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    StructS ret = this->getNSNullStructSeq(current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_getNSNullStringSeqSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    StringSS ret = this->getNSNullStringSeqSeq(current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_getNSNullStringStringDict(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    StringStringD ret = this->getNSNullStringStringDict(current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_putNSNullStringStringDict(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    StringStringD iceP_d;
    istr->read(iceP_d);
    inS.endReadParams();
    this->putNSNullStringStringDict(iceP_d, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_putNSNullShortIntDict(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ShortIntD iceP_d;
    istr->read(iceP_d);
    inS.endReadParams();
    this->putNSNullShortIntDict(iceP_d, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_putNSNullStringMyEnumDict(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    StringMyEnumD iceP_d;
    istr->read(iceP_d);
    inS.endReadParams();
    this->putNSNullStringMyEnumDict(iceP_d, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

namespace
{
const ::std::string iceC_Test_MyClass_all[] =
{
    "getNSNullASeq",
    "getNSNullStringSeq",
    "getNSNullStringSeqSeq",
    "getNSNullStringStringDict",
    "getNSNullStructSeq",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "opBool",
    "opBoolBoolSD",
    "opBoolS",
    "opBoolSS",
    "opByte",
    "opByte1",
    "opByteBoolD",
    "opByteBoolD1",
    "opByteBoolD2",
    "opByteBoolDS",
    "opByteByteSD",
    "opByteS",
    "opByteSOneway",
    "opByteSOnewayCallCount",
    "opByteSS",
    "opContext",
    "opDouble1",
    "opDoubleMarshaling",
    "opFloat1",
    "opFloatDouble",
    "opFloatDoubleS",
    "opFloatDoubleSS",
    "opIdempotent",
    "opInt1",
    "opIntIntSD",
    "opIntS",
    "opLong1",
    "opLongFloatD",
    "opLongFloatDS",
    "opLongLongSD",
    "opMDict1",
    "opMDict2",
    "opMSeq1",
    "opMSeq2",
    "opMStruct1",
    "opMStruct2",
    "opMyClass",
    "opMyClassS",
    "opMyEnum",
    "opMyEnumMyEnumSD",
    "opMyEnumS",
    "opMyEnumStringD",
    "opMyEnumStringDS",
    "opMyStructMyEnumD",
    "opMyStructMyEnumDS",
    "opNonmutating",
    "opShort1",
    "opShortIntD",
    "opShortIntDS",
    "opShortIntLong",
    "opShortIntLongS",
    "opShortIntLongSS",
    "opShortShortSD",
    "opString",
    "opString1",
    "opStringDoubleSD",
    "opStringFloatSD",
    "opStringLiterals",
    "opStringMyEnumD",
    "opStringMyEnumDS",
    "opStringS",
    "opStringS1",
    "opStringS2",
    "opStringSS",
    "opStringSSS",
    "opStringStringD",
    "opStringStringDS",
    "opStringStringSD",
    "opStruct",
    "opVoid",
    "opWStringLiterals",
    "putNSNullShortIntDict",
    "putNSNullStringMyEnumDict",
    "putNSNullStringStringDict",
    "shutdown",
    "supportsCompress"
};

}

/// \cond INTERNAL
bool
Test::MyClass::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_Test_MyClass_all, iceC_Test_MyClass_all + 85, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_Test_MyClass_all)
    {
        case 0:
        {
            return _iceD_getNSNullASeq(in, current);
        }
        case 1:
        {
            return _iceD_getNSNullStringSeq(in, current);
        }
        case 2:
        {
            return _iceD_getNSNullStringSeqSeq(in, current);
        }
        case 3:
        {
            return _iceD_getNSNullStringStringDict(in, current);
        }
        case 4:
        {
            return _iceD_getNSNullStructSeq(in, current);
        }
        case 5:
        {
            return _iceD_ice_id(in, current);
        }
        case 6:
        {
            return _iceD_ice_ids(in, current);
        }
        case 7:
        {
            return _iceD_ice_isA(in, current);
        }
        case 8:
        {
            return _iceD_ice_ping(in, current);
        }
        case 9:
        {
            return _iceD_opBool(in, current);
        }
        case 10:
        {
            return _iceD_opBoolBoolSD(in, current);
        }
        case 11:
        {
            return _iceD_opBoolS(in, current);
        }
        case 12:
        {
            return _iceD_opBoolSS(in, current);
        }
        case 13:
        {
            return _iceD_opByte(in, current);
        }
        case 14:
        {
            return _iceD_opByte1(in, current);
        }
        case 15:
        {
            return _iceD_opByteBoolD(in, current);
        }
        case 16:
        {
            return _iceD_opByteBoolD1(in, current);
        }
        case 17:
        {
            return _iceD_opByteBoolD2(in, current);
        }
        case 18:
        {
            return _iceD_opByteBoolDS(in, current);
        }
        case 19:
        {
            return _iceD_opByteByteSD(in, current);
        }
        case 20:
        {
            return _iceD_opByteS(in, current);
        }
        case 21:
        {
            return _iceD_opByteSOneway(in, current);
        }
        case 22:
        {
            return _iceD_opByteSOnewayCallCount(in, current);
        }
        case 23:
        {
            return _iceD_opByteSS(in, current);
        }
        case 24:
        {
            return _iceD_opContext(in, current);
        }
        case 25:
        {
            return _iceD_opDouble1(in, current);
        }
        case 26:
        {
            return _iceD_opDoubleMarshaling(in, current);
        }
        case 27:
        {
            return _iceD_opFloat1(in, current);
        }
        case 28:
        {
            return _iceD_opFloatDouble(in, current);
        }
        case 29:
        {
            return _iceD_opFloatDoubleS(in, current);
        }
        case 30:
        {
            return _iceD_opFloatDoubleSS(in, current);
        }
        case 31:
        {
            return _iceD_opIdempotent(in, current);
        }
        case 32:
        {
            return _iceD_opInt1(in, current);
        }
        case 33:
        {
            return _iceD_opIntIntSD(in, current);
        }
        case 34:
        {
            return _iceD_opIntS(in, current);
        }
        case 35:
        {
            return _iceD_opLong1(in, current);
        }
        case 36:
        {
            return _iceD_opLongFloatD(in, current);
        }
        case 37:
        {
            return _iceD_opLongFloatDS(in, current);
        }
        case 38:
        {
            return _iceD_opLongLongSD(in, current);
        }
        case 39:
        {
            return _iceD_opMDict1(in, current);
        }
        case 40:
        {
            return _iceD_opMDict2(in, current);
        }
        case 41:
        {
            return _iceD_opMSeq1(in, current);
        }
        case 42:
        {
            return _iceD_opMSeq2(in, current);
        }
        case 43:
        {
            return _iceD_opMStruct1(in, current);
        }
        case 44:
        {
            return _iceD_opMStruct2(in, current);
        }
        case 45:
        {
            return _iceD_opMyClass(in, current);
        }
        case 46:
        {
            return _iceD_opMyClassS(in, current);
        }
        case 47:
        {
            return _iceD_opMyEnum(in, current);
        }
        case 48:
        {
            return _iceD_opMyEnumMyEnumSD(in, current);
        }
        case 49:
        {
            return _iceD_opMyEnumS(in, current);
        }
        case 50:
        {
            return _iceD_opMyEnumStringD(in, current);
        }
        case 51:
        {
            return _iceD_opMyEnumStringDS(in, current);
        }
        case 52:
        {
            return _iceD_opMyStructMyEnumD(in, current);
        }
        case 53:
        {
            return _iceD_opMyStructMyEnumDS(in, current);
        }
        case 54:
        {
            return _iceD_opNonmutating(in, current);
        }
        case 55:
        {
            return _iceD_opShort1(in, current);
        }
        case 56:
        {
            return _iceD_opShortIntD(in, current);
        }
        case 57:
        {
            return _iceD_opShortIntDS(in, current);
        }
        case 58:
        {
            return _iceD_opShortIntLong(in, current);
        }
        case 59:
        {
            return _iceD_opShortIntLongS(in, current);
        }
        case 60:
        {
            return _iceD_opShortIntLongSS(in, current);
        }
        case 61:
        {
            return _iceD_opShortShortSD(in, current);
        }
        case 62:
        {
            return _iceD_opString(in, current);
        }
        case 63:
        {
            return _iceD_opString1(in, current);
        }
        case 64:
        {
            return _iceD_opStringDoubleSD(in, current);
        }
        case 65:
        {
            return _iceD_opStringFloatSD(in, current);
        }
        case 66:
        {
            return _iceD_opStringLiterals(in, current);
        }
        case 67:
        {
            return _iceD_opStringMyEnumD(in, current);
        }
        case 68:
        {
            return _iceD_opStringMyEnumDS(in, current);
        }
        case 69:
        {
            return _iceD_opStringS(in, current);
        }
        case 70:
        {
            return _iceD_opStringS1(in, current);
        }
        case 71:
        {
            return _iceD_opStringS2(in, current);
        }
        case 72:
        {
            return _iceD_opStringSS(in, current);
        }
        case 73:
        {
            return _iceD_opStringSSS(in, current);
        }
        case 74:
        {
            return _iceD_opStringStringD(in, current);
        }
        case 75:
        {
            return _iceD_opStringStringDS(in, current);
        }
        case 76:
        {
            return _iceD_opStringStringSD(in, current);
        }
        case 77:
        {
            return _iceD_opStruct(in, current);
        }
        case 78:
        {
            return _iceD_opVoid(in, current);
        }
        case 79:
        {
            return _iceD_opWStringLiterals(in, current);
        }
        case 80:
        {
            return _iceD_putNSNullShortIntDict(in, current);
        }
        case 81:
        {
            return _iceD_putNSNullStringMyEnumDict(in, current);
        }
        case 82:
        {
            return _iceD_putNSNullStringStringDict(in, current);
        }
        case 83:
        {
            return _iceD_shutdown(in, current);
        }
        case 84:
        {
            return _iceD_supportsCompress(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

/// \cond STREAM
void
Test::MyClass::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< MyClass, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Test::MyClass::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< MyClass, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

/// \cond INTERNAL
void
Test::_icePatchObjectPtr(MyClassPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = MyClassPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(MyClass::ice_staticId(), v);
    }
}
/// \endcond

Test::MyClass1::~MyClass1()
{
}

/// \cond INTERNAL
::Ice::Object* Test::upCast(MyClass1* p) { return p; }

/// \endcond
::Ice::ObjectPtr
Test::MyClass1::ice_clone() const
{
    ::Ice::Object* p = new MyClass1(*this);
    return p;
}

namespace
{
const ::std::string iceC_Test_MyClass1_ids[2] =
{
    "::Ice::Object",
    "::Test::MyClass1"
};

}

bool
Test::MyClass1::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_MyClass1_ids, iceC_Test_MyClass1_ids + 2, s);
}

::std::vector< ::std::string>
Test::MyClass1::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Test_MyClass1_ids[0], &iceC_Test_MyClass1_ids[2]);
}

const ::std::string&
Test::MyClass1::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::MyClass1::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::Test::MyClass1";
    return typeId;
#else
    return iceC_Test_MyClass1_ids[1];
#endif
}

/// \cond STREAM
void
Test::MyClass1::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< MyClass1, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Test::MyClass1::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< MyClass1, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

namespace
{
const ::IceInternal::DefaultValueFactoryInit< ::Test::MyClass1> iceC_Test_MyClass1_init("::Test::MyClass1");
}

::Ice::ValueFactoryPtr
Test::MyClass1::ice_factory()
{
    return ::IceInternal::factoryTable->getValueFactory(::Test::MyClass1::ice_staticId());
}

/// \cond INTERNAL
void
Test::_icePatchObjectPtr(MyClass1Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = MyClass1Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(MyClass1::ice_staticId(), v);
    }
}
/// \endcond

Test::MyDerivedClass::~MyDerivedClass()
{
}

/// \cond INTERNAL
::Ice::Object* Test::upCast(MyDerivedClass* p) { return p; }

/// \endcond

namespace
{
const ::std::string iceC_Test_MyDerivedClass_ids[3] =
{
    "::Ice::Object",
    "::Test::MyClass",
    "::Test::MyDerivedClass"
};

}

bool
Test::MyDerivedClass::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_MyDerivedClass_ids, iceC_Test_MyDerivedClass_ids + 3, s);
}

::std::vector< ::std::string>
Test::MyDerivedClass::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Test_MyDerivedClass_ids[0], &iceC_Test_MyDerivedClass_ids[3]);
}

const ::std::string&
Test::MyDerivedClass::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::MyDerivedClass::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::Test::MyDerivedClass";
    return typeId;
#else
    return iceC_Test_MyDerivedClass_ids[2];
#endif
}

/// \cond INTERNAL
bool
Test::MyDerivedClass::_iceD_opDerived(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    this->opDerived(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyDerivedClass::_iceD_opMyClass1(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    MyClass1Ptr iceP_c;
    istr->read(iceP_c);
    istr->readPendingValues();
    inS.endReadParams();
    MyClass1Ptr ret = this->opMyClass1(iceP_c, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyDerivedClass::_iceD_opMyStruct1(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    MyStruct1 iceP_c;
    istr->read(iceP_c);
    inS.endReadParams();
    MyStruct1 ret = this->opMyStruct1(iceP_c, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

namespace
{
const ::std::string iceC_Test_MyDerivedClass_all[] =
{
    "getNSNullASeq",
    "getNSNullStringSeq",
    "getNSNullStringSeqSeq",
    "getNSNullStringStringDict",
    "getNSNullStructSeq",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "opBool",
    "opBoolBoolSD",
    "opBoolS",
    "opBoolSS",
    "opByte",
    "opByte1",
    "opByteBoolD",
    "opByteBoolD1",
    "opByteBoolD2",
    "opByteBoolDS",
    "opByteByteSD",
    "opByteS",
    "opByteSOneway",
    "opByteSOnewayCallCount",
    "opByteSS",
    "opContext",
    "opDerived",
    "opDouble1",
    "opDoubleMarshaling",
    "opFloat1",
    "opFloatDouble",
    "opFloatDoubleS",
    "opFloatDoubleSS",
    "opIdempotent",
    "opInt1",
    "opIntIntSD",
    "opIntS",
    "opLong1",
    "opLongFloatD",
    "opLongFloatDS",
    "opLongLongSD",
    "opMDict1",
    "opMDict2",
    "opMSeq1",
    "opMSeq2",
    "opMStruct1",
    "opMStruct2",
    "opMyClass",
    "opMyClass1",
    "opMyClassS",
    "opMyEnum",
    "opMyEnumMyEnumSD",
    "opMyEnumS",
    "opMyEnumStringD",
    "opMyEnumStringDS",
    "opMyStruct1",
    "opMyStructMyEnumD",
    "opMyStructMyEnumDS",
    "opNonmutating",
    "opShort1",
    "opShortIntD",
    "opShortIntDS",
    "opShortIntLong",
    "opShortIntLongS",
    "opShortIntLongSS",
    "opShortShortSD",
    "opString",
    "opString1",
    "opStringDoubleSD",
    "opStringFloatSD",
    "opStringLiterals",
    "opStringMyEnumD",
    "opStringMyEnumDS",
    "opStringS",
    "opStringS1",
    "opStringS2",
    "opStringSS",
    "opStringSSS",
    "opStringStringD",
    "opStringStringDS",
    "opStringStringSD",
    "opStruct",
    "opVoid",
    "opWStringLiterals",
    "putNSNullShortIntDict",
    "putNSNullStringMyEnumDict",
    "putNSNullStringStringDict",
    "shutdown",
    "supportsCompress"
};

}

/// \cond INTERNAL
bool
Test::MyDerivedClass::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_Test_MyDerivedClass_all, iceC_Test_MyDerivedClass_all + 88, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_Test_MyDerivedClass_all)
    {
        case 0:
        {
            return _iceD_getNSNullASeq(in, current);
        }
        case 1:
        {
            return _iceD_getNSNullStringSeq(in, current);
        }
        case 2:
        {
            return _iceD_getNSNullStringSeqSeq(in, current);
        }
        case 3:
        {
            return _iceD_getNSNullStringStringDict(in, current);
        }
        case 4:
        {
            return _iceD_getNSNullStructSeq(in, current);
        }
        case 5:
        {
            return _iceD_ice_id(in, current);
        }
        case 6:
        {
            return _iceD_ice_ids(in, current);
        }
        case 7:
        {
            return _iceD_ice_isA(in, current);
        }
        case 8:
        {
            return _iceD_ice_ping(in, current);
        }
        case 9:
        {
            return _iceD_opBool(in, current);
        }
        case 10:
        {
            return _iceD_opBoolBoolSD(in, current);
        }
        case 11:
        {
            return _iceD_opBoolS(in, current);
        }
        case 12:
        {
            return _iceD_opBoolSS(in, current);
        }
        case 13:
        {
            return _iceD_opByte(in, current);
        }
        case 14:
        {
            return _iceD_opByte1(in, current);
        }
        case 15:
        {
            return _iceD_opByteBoolD(in, current);
        }
        case 16:
        {
            return _iceD_opByteBoolD1(in, current);
        }
        case 17:
        {
            return _iceD_opByteBoolD2(in, current);
        }
        case 18:
        {
            return _iceD_opByteBoolDS(in, current);
        }
        case 19:
        {
            return _iceD_opByteByteSD(in, current);
        }
        case 20:
        {
            return _iceD_opByteS(in, current);
        }
        case 21:
        {
            return _iceD_opByteSOneway(in, current);
        }
        case 22:
        {
            return _iceD_opByteSOnewayCallCount(in, current);
        }
        case 23:
        {
            return _iceD_opByteSS(in, current);
        }
        case 24:
        {
            return _iceD_opContext(in, current);
        }
        case 25:
        {
            return _iceD_opDerived(in, current);
        }
        case 26:
        {
            return _iceD_opDouble1(in, current);
        }
        case 27:
        {
            return _iceD_opDoubleMarshaling(in, current);
        }
        case 28:
        {
            return _iceD_opFloat1(in, current);
        }
        case 29:
        {
            return _iceD_opFloatDouble(in, current);
        }
        case 30:
        {
            return _iceD_opFloatDoubleS(in, current);
        }
        case 31:
        {
            return _iceD_opFloatDoubleSS(in, current);
        }
        case 32:
        {
            return _iceD_opIdempotent(in, current);
        }
        case 33:
        {
            return _iceD_opInt1(in, current);
        }
        case 34:
        {
            return _iceD_opIntIntSD(in, current);
        }
        case 35:
        {
            return _iceD_opIntS(in, current);
        }
        case 36:
        {
            return _iceD_opLong1(in, current);
        }
        case 37:
        {
            return _iceD_opLongFloatD(in, current);
        }
        case 38:
        {
            return _iceD_opLongFloatDS(in, current);
        }
        case 39:
        {
            return _iceD_opLongLongSD(in, current);
        }
        case 40:
        {
            return _iceD_opMDict1(in, current);
        }
        case 41:
        {
            return _iceD_opMDict2(in, current);
        }
        case 42:
        {
            return _iceD_opMSeq1(in, current);
        }
        case 43:
        {
            return _iceD_opMSeq2(in, current);
        }
        case 44:
        {
            return _iceD_opMStruct1(in, current);
        }
        case 45:
        {
            return _iceD_opMStruct2(in, current);
        }
        case 46:
        {
            return _iceD_opMyClass(in, current);
        }
        case 47:
        {
            return _iceD_opMyClass1(in, current);
        }
        case 48:
        {
            return _iceD_opMyClassS(in, current);
        }
        case 49:
        {
            return _iceD_opMyEnum(in, current);
        }
        case 50:
        {
            return _iceD_opMyEnumMyEnumSD(in, current);
        }
        case 51:
        {
            return _iceD_opMyEnumS(in, current);
        }
        case 52:
        {
            return _iceD_opMyEnumStringD(in, current);
        }
        case 53:
        {
            return _iceD_opMyEnumStringDS(in, current);
        }
        case 54:
        {
            return _iceD_opMyStruct1(in, current);
        }
        case 55:
        {
            return _iceD_opMyStructMyEnumD(in, current);
        }
        case 56:
        {
            return _iceD_opMyStructMyEnumDS(in, current);
        }
        case 57:
        {
            return _iceD_opNonmutating(in, current);
        }
        case 58:
        {
            return _iceD_opShort1(in, current);
        }
        case 59:
        {
            return _iceD_opShortIntD(in, current);
        }
        case 60:
        {
            return _iceD_opShortIntDS(in, current);
        }
        case 61:
        {
            return _iceD_opShortIntLong(in, current);
        }
        case 62:
        {
            return _iceD_opShortIntLongS(in, current);
        }
        case 63:
        {
            return _iceD_opShortIntLongSS(in, current);
        }
        case 64:
        {
            return _iceD_opShortShortSD(in, current);
        }
        case 65:
        {
            return _iceD_opString(in, current);
        }
        case 66:
        {
            return _iceD_opString1(in, current);
        }
        case 67:
        {
            return _iceD_opStringDoubleSD(in, current);
        }
        case 68:
        {
            return _iceD_opStringFloatSD(in, current);
        }
        case 69:
        {
            return _iceD_opStringLiterals(in, current);
        }
        case 70:
        {
            return _iceD_opStringMyEnumD(in, current);
        }
        case 71:
        {
            return _iceD_opStringMyEnumDS(in, current);
        }
        case 72:
        {
            return _iceD_opStringS(in, current);
        }
        case 73:
        {
            return _iceD_opStringS1(in, current);
        }
        case 74:
        {
            return _iceD_opStringS2(in, current);
        }
        case 75:
        {
            return _iceD_opStringSS(in, current);
        }
        case 76:
        {
            return _iceD_opStringSSS(in, current);
        }
        case 77:
        {
            return _iceD_opStringStringD(in, current);
        }
        case 78:
        {
            return _iceD_opStringStringDS(in, current);
        }
        case 79:
        {
            return _iceD_opStringStringSD(in, current);
        }
        case 80:
        {
            return _iceD_opStruct(in, current);
        }
        case 81:
        {
            return _iceD_opVoid(in, current);
        }
        case 82:
        {
            return _iceD_opWStringLiterals(in, current);
        }
        case 83:
        {
            return _iceD_putNSNullShortIntDict(in, current);
        }
        case 84:
        {
            return _iceD_putNSNullStringMyEnumDict(in, current);
        }
        case 85:
        {
            return _iceD_putNSNullStringStringDict(in, current);
        }
        case 86:
        {
            return _iceD_shutdown(in, current);
        }
        case 87:
        {
            return _iceD_supportsCompress(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

/// \cond STREAM
void
Test::MyDerivedClass::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< MyDerivedClass, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Test::MyDerivedClass::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< MyDerivedClass, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

/// \cond INTERNAL
void
Test::_icePatchObjectPtr(MyDerivedClassPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = MyDerivedClassPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(MyDerivedClass::ice_staticId(), v);
    }
}
/// \endcond

Test2::MyDerivedClass::~MyDerivedClass()
{
}

/// \cond INTERNAL
::Ice::Object* Test2::upCast(MyDerivedClass* p) { return p; }

/// \endcond

namespace
{
const ::std::string iceC_Test2_MyDerivedClass_ids[3] =
{
    "::Ice::Object",
    "::Test2::MyDerivedClass",
    "::Test::MyClass"
};

}

bool
Test2::MyDerivedClass::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test2_MyDerivedClass_ids, iceC_Test2_MyDerivedClass_ids + 3, s);
}

::std::vector< ::std::string>
Test2::MyDerivedClass::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Test2_MyDerivedClass_ids[0], &iceC_Test2_MyDerivedClass_ids[3]);
}

const ::std::string&
Test2::MyDerivedClass::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test2::MyDerivedClass::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::Test2::MyDerivedClass";
    return typeId;
#else
    return iceC_Test2_MyDerivedClass_ids[1];
#endif
}

namespace
{
const ::std::string iceC_Test2_MyDerivedClass_all[] =
{
    "getNSNullASeq",
    "getNSNullStringSeq",
    "getNSNullStringSeqSeq",
    "getNSNullStringStringDict",
    "getNSNullStructSeq",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "opBool",
    "opBoolBoolSD",
    "opBoolS",
    "opBoolSS",
    "opByte",
    "opByte1",
    "opByteBoolD",
    "opByteBoolD1",
    "opByteBoolD2",
    "opByteBoolDS",
    "opByteByteSD",
    "opByteS",
    "opByteSOneway",
    "opByteSOnewayCallCount",
    "opByteSS",
    "opContext",
    "opDouble1",
    "opDoubleMarshaling",
    "opFloat1",
    "opFloatDouble",
    "opFloatDoubleS",
    "opFloatDoubleSS",
    "opIdempotent",
    "opInt1",
    "opIntIntSD",
    "opIntS",
    "opLong1",
    "opLongFloatD",
    "opLongFloatDS",
    "opLongLongSD",
    "opMDict1",
    "opMDict2",
    "opMSeq1",
    "opMSeq2",
    "opMStruct1",
    "opMStruct2",
    "opMyClass",
    "opMyClassS",
    "opMyEnum",
    "opMyEnumMyEnumSD",
    "opMyEnumS",
    "opMyEnumStringD",
    "opMyEnumStringDS",
    "opMyStructMyEnumD",
    "opMyStructMyEnumDS",
    "opNonmutating",
    "opShort1",
    "opShortIntD",
    "opShortIntDS",
    "opShortIntLong",
    "opShortIntLongS",
    "opShortIntLongSS",
    "opShortShortSD",
    "opString",
    "opString1",
    "opStringDoubleSD",
    "opStringFloatSD",
    "opStringLiterals",
    "opStringMyEnumD",
    "opStringMyEnumDS",
    "opStringS",
    "opStringS1",
    "opStringS2",
    "opStringSS",
    "opStringSSS",
    "opStringStringD",
    "opStringStringDS",
    "opStringStringSD",
    "opStruct",
    "opVoid",
    "opWStringLiterals",
    "putNSNullShortIntDict",
    "putNSNullStringMyEnumDict",
    "putNSNullStringStringDict",
    "shutdown",
    "supportsCompress"
};

}

/// \cond INTERNAL
bool
Test2::MyDerivedClass::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_Test2_MyDerivedClass_all, iceC_Test2_MyDerivedClass_all + 85, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_Test2_MyDerivedClass_all)
    {
        case 0:
        {
            return _iceD_getNSNullASeq(in, current);
        }
        case 1:
        {
            return _iceD_getNSNullStringSeq(in, current);
        }
        case 2:
        {
            return _iceD_getNSNullStringSeqSeq(in, current);
        }
        case 3:
        {
            return _iceD_getNSNullStringStringDict(in, current);
        }
        case 4:
        {
            return _iceD_getNSNullStructSeq(in, current);
        }
        case 5:
        {
            return _iceD_ice_id(in, current);
        }
        case 6:
        {
            return _iceD_ice_ids(in, current);
        }
        case 7:
        {
            return _iceD_ice_isA(in, current);
        }
        case 8:
        {
            return _iceD_ice_ping(in, current);
        }
        case 9:
        {
            return _iceD_opBool(in, current);
        }
        case 10:
        {
            return _iceD_opBoolBoolSD(in, current);
        }
        case 11:
        {
            return _iceD_opBoolS(in, current);
        }
        case 12:
        {
            return _iceD_opBoolSS(in, current);
        }
        case 13:
        {
            return _iceD_opByte(in, current);
        }
        case 14:
        {
            return _iceD_opByte1(in, current);
        }
        case 15:
        {
            return _iceD_opByteBoolD(in, current);
        }
        case 16:
        {
            return _iceD_opByteBoolD1(in, current);
        }
        case 17:
        {
            return _iceD_opByteBoolD2(in, current);
        }
        case 18:
        {
            return _iceD_opByteBoolDS(in, current);
        }
        case 19:
        {
            return _iceD_opByteByteSD(in, current);
        }
        case 20:
        {
            return _iceD_opByteS(in, current);
        }
        case 21:
        {
            return _iceD_opByteSOneway(in, current);
        }
        case 22:
        {
            return _iceD_opByteSOnewayCallCount(in, current);
        }
        case 23:
        {
            return _iceD_opByteSS(in, current);
        }
        case 24:
        {
            return _iceD_opContext(in, current);
        }
        case 25:
        {
            return _iceD_opDouble1(in, current);
        }
        case 26:
        {
            return _iceD_opDoubleMarshaling(in, current);
        }
        case 27:
        {
            return _iceD_opFloat1(in, current);
        }
        case 28:
        {
            return _iceD_opFloatDouble(in, current);
        }
        case 29:
        {
            return _iceD_opFloatDoubleS(in, current);
        }
        case 30:
        {
            return _iceD_opFloatDoubleSS(in, current);
        }
        case 31:
        {
            return _iceD_opIdempotent(in, current);
        }
        case 32:
        {
            return _iceD_opInt1(in, current);
        }
        case 33:
        {
            return _iceD_opIntIntSD(in, current);
        }
        case 34:
        {
            return _iceD_opIntS(in, current);
        }
        case 35:
        {
            return _iceD_opLong1(in, current);
        }
        case 36:
        {
            return _iceD_opLongFloatD(in, current);
        }
        case 37:
        {
            return _iceD_opLongFloatDS(in, current);
        }
        case 38:
        {
            return _iceD_opLongLongSD(in, current);
        }
        case 39:
        {
            return _iceD_opMDict1(in, current);
        }
        case 40:
        {
            return _iceD_opMDict2(in, current);
        }
        case 41:
        {
            return _iceD_opMSeq1(in, current);
        }
        case 42:
        {
            return _iceD_opMSeq2(in, current);
        }
        case 43:
        {
            return _iceD_opMStruct1(in, current);
        }
        case 44:
        {
            return _iceD_opMStruct2(in, current);
        }
        case 45:
        {
            return _iceD_opMyClass(in, current);
        }
        case 46:
        {
            return _iceD_opMyClassS(in, current);
        }
        case 47:
        {
            return _iceD_opMyEnum(in, current);
        }
        case 48:
        {
            return _iceD_opMyEnumMyEnumSD(in, current);
        }
        case 49:
        {
            return _iceD_opMyEnumS(in, current);
        }
        case 50:
        {
            return _iceD_opMyEnumStringD(in, current);
        }
        case 51:
        {
            return _iceD_opMyEnumStringDS(in, current);
        }
        case 52:
        {
            return _iceD_opMyStructMyEnumD(in, current);
        }
        case 53:
        {
            return _iceD_opMyStructMyEnumDS(in, current);
        }
        case 54:
        {
            return _iceD_opNonmutating(in, current);
        }
        case 55:
        {
            return _iceD_opShort1(in, current);
        }
        case 56:
        {
            return _iceD_opShortIntD(in, current);
        }
        case 57:
        {
            return _iceD_opShortIntDS(in, current);
        }
        case 58:
        {
            return _iceD_opShortIntLong(in, current);
        }
        case 59:
        {
            return _iceD_opShortIntLongS(in, current);
        }
        case 60:
        {
            return _iceD_opShortIntLongSS(in, current);
        }
        case 61:
        {
            return _iceD_opShortShortSD(in, current);
        }
        case 62:
        {
            return _iceD_opString(in, current);
        }
        case 63:
        {
            return _iceD_opString1(in, current);
        }
        case 64:
        {
            return _iceD_opStringDoubleSD(in, current);
        }
        case 65:
        {
            return _iceD_opStringFloatSD(in, current);
        }
        case 66:
        {
            return _iceD_opStringLiterals(in, current);
        }
        case 67:
        {
            return _iceD_opStringMyEnumD(in, current);
        }
        case 68:
        {
            return _iceD_opStringMyEnumDS(in, current);
        }
        case 69:
        {
            return _iceD_opStringS(in, current);
        }
        case 70:
        {
            return _iceD_opStringS1(in, current);
        }
        case 71:
        {
            return _iceD_opStringS2(in, current);
        }
        case 72:
        {
            return _iceD_opStringSS(in, current);
        }
        case 73:
        {
            return _iceD_opStringSSS(in, current);
        }
        case 74:
        {
            return _iceD_opStringStringD(in, current);
        }
        case 75:
        {
            return _iceD_opStringStringDS(in, current);
        }
        case 76:
        {
            return _iceD_opStringStringSD(in, current);
        }
        case 77:
        {
            return _iceD_opStruct(in, current);
        }
        case 78:
        {
            return _iceD_opVoid(in, current);
        }
        case 79:
        {
            return _iceD_opWStringLiterals(in, current);
        }
        case 80:
        {
            return _iceD_putNSNullShortIntDict(in, current);
        }
        case 81:
        {
            return _iceD_putNSNullStringMyEnumDict(in, current);
        }
        case 82:
        {
            return _iceD_putNSNullStringStringDict(in, current);
        }
        case 83:
        {
            return _iceD_shutdown(in, current);
        }
        case 84:
        {
            return _iceD_supportsCompress(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

/// \cond STREAM
void
Test2::MyDerivedClass::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< MyDerivedClass, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Test2::MyDerivedClass::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< MyDerivedClass, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

/// \cond INTERNAL
void
Test2::_icePatchObjectPtr(MyDerivedClassPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = MyDerivedClassPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(MyDerivedClass::ice_staticId(), v);
    }
}
/// \endcond

M::A::~A()
{
}

/// \cond INTERNAL
::Ice::Object* M::upCast(A* p) { return p; }

/// \endcond
::Ice::ObjectPtr
M::A::ice_clone() const
{
    ::Ice::Object* p = new A(*this);
    return p;
}

namespace
{
const ::std::string iceC_M_A_ids[2] =
{
    "::Ice::Object",
    "::M::A"
};

}

bool
M::A::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_M_A_ids, iceC_M_A_ids + 2, s);
}

::std::vector< ::std::string>
M::A::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_M_A_ids[0], &iceC_M_A_ids[2]);
}

const ::std::string&
M::A::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
M::A::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::M::A";
    return typeId;
#else
    return iceC_M_A_ids[1];
#endif
}

/// \cond STREAM
void
M::A::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< A, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
M::A::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< A, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

namespace
{
const ::IceInternal::DefaultValueFactoryInit< ::M::A> iceC_M_A_init("::M::A");
}

::Ice::ValueFactoryPtr
M::A::ice_factory()
{
    return ::IceInternal::factoryTable->getValueFactory(::M::A::ice_staticId());
}

/// \cond INTERNAL
void
M::_icePatchObjectPtr(APtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = APtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(A::ice_staticId(), v);
    }
}
/// \endcond

M::Intf::~Intf()
{
}

/// \cond INTERNAL
::Ice::Object* M::upCast(Intf* p) { return p; }

/// \endcond

namespace
{
const ::std::string iceC_M_Intf_ids[2] =
{
    "::Ice::Object",
    "::M::Intf"
};

}

bool
M::Intf::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_M_Intf_ids, iceC_M_Intf_ids + 2, s);
}

::std::vector< ::std::string>
M::Intf::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_M_Intf_ids[0], &iceC_M_Intf_ids[2]);
}

const ::std::string&
M::Intf::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
M::Intf::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::M::Intf";
    return typeId;
#else
    return iceC_M_Intf_ids[1];
#endif
}

/// \cond INTERNAL
bool
M::Intf::_iceD_opIntf(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    this->opIntf(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

namespace
{
const ::std::string iceC_M_Intf_all[] =
{
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "opIntf"
};

}

/// \cond INTERNAL
bool
M::Intf::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_M_Intf_all, iceC_M_Intf_all + 5, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_M_Intf_all)
    {
        case 0:
        {
            return _iceD_ice_id(in, current);
        }
        case 1:
        {
            return _iceD_ice_ids(in, current);
        }
        case 2:
        {
            return _iceD_ice_isA(in, current);
        }
        case 3:
        {
            return _iceD_ice_ping(in, current);
        }
        case 4:
        {
            return _iceD_opIntf(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

/// \cond STREAM
void
M::Intf::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< Intf, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
M::Intf::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< Intf, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

/// \cond INTERNAL
void
M::_icePatchObjectPtr(IntfPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = IntfPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(Intf::ice_staticId(), v);
    }
}
/// \endcond

M::B::~B()
{
}

/// \cond INTERNAL
::Ice::Object* M::upCast(B* p) { return p; }

/// \endcond
::Ice::ObjectPtr
M::B::ice_clone() const
{
    throw ::Ice::CloneNotImplementedException(__FILE__, __LINE__);
}

namespace
{
const ::std::string iceC_M_B_ids[4] =
{
    "::Ice::Object",
    "::M::A",
    "::M::B",
    "::M::Intf"
};

}

bool
M::B::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_M_B_ids, iceC_M_B_ids + 4, s);
}

::std::vector< ::std::string>
M::B::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_M_B_ids[0], &iceC_M_B_ids[4]);
}

const ::std::string&
M::B::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
M::B::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::M::B";
    return typeId;
#else
    return iceC_M_B_ids[2];
#endif
}

/// \cond INTERNAL
bool
M::B::_iceD_opB(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    this->opB(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

namespace
{
const ::std::string iceC_M_B_all[] =
{
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "opB",
    "opIntf"
};

}

/// \cond INTERNAL
bool
M::B::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_M_B_all, iceC_M_B_all + 6, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_M_B_all)
    {
        case 0:
        {
            return _iceD_ice_id(in, current);
        }
        case 1:
        {
            return _iceD_ice_ids(in, current);
        }
        case 2:
        {
            return _iceD_ice_isA(in, current);
        }
        case 3:
        {
            return _iceD_ice_ping(in, current);
        }
        case 4:
        {
            return _iceD_opB(in, current);
        }
        case 5:
        {
            return _iceD_opIntf(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

/// \cond STREAM
void
M::B::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, false);
    ::Ice::StreamWriter< B, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
    A::_iceWriteImpl(ostr);
}

void
M::B::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< B, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
    A::_iceReadImpl(istr);
}
/// \endcond

/// \cond INTERNAL
void
M::_icePatchObjectPtr(BPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = BPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(B::ice_staticId(), v);
    }
}
/// \endcond

namespace Ice
{
}

namespace Ice
{
}

namespace Ice
{
}

#endif
