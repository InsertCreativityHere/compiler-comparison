//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.7.10
//
// <auto-generated>
//
// Generated from file `SlicingObjectsTestClient.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#include <SlicingObjectsTestClient.h>
#include <IceUtil/PushDisableWarnings.h>
#include <Ice/LocalException.h>
#include <Ice/ValueFactory.h>
#include <Ice/OutgoingAsync.h>
#include <Ice/InputStream.h>
#include <Ice/OutputStream.h>
#include <Ice/LocalException.h>
#include <Ice/SlicedData.h>
#include <IceUtil/PopDisableWarnings.h>

#if defined(_MSC_VER)
#   pragma warning(disable:4458) // declaration of ... hides class member
#elif defined(__clang__)
#   pragma clang diagnostic ignored "-Wshadow"
#elif defined(__GNUC__)
#   pragma GCC diagnostic ignored "-Wshadow"
#endif

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 307
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 >= 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 10
#       error Ice patch level mismatch!
#   endif
#endif

#ifdef ICE_CPP11_MAPPING // C++11 mapping

namespace
{

const ::IceInternal::DefaultValueFactoryInit<::Test::SBase> iceC_Test_SBase_init("::Test::SBase");

const ::IceInternal::DefaultValueFactoryInit<::Test::SBSKnownDerived> iceC_Test_SBSKnownDerived_init("::Test::SBSKnownDerived");

const ::IceInternal::DefaultValueFactoryInit<::Test::B> iceC_Test_B_init("::Test::B");

const ::IceInternal::DefaultValueFactoryInit<::Test::D1> iceC_Test_D1_init("::Test::D1");

const ::IceInternal::DefaultValueFactoryInit<::Test::SS1> iceC_Test_SS1_init("::Test::SS1");

const ::IceInternal::DefaultValueFactoryInit<::Test::SS2> iceC_Test_SS2_init("::Test::SS2");

const ::IceInternal::DefaultUserExceptionFactoryInit<::Test::BaseException> iceC_Test_BaseException_init("::Test::BaseException");

const ::IceInternal::DefaultUserExceptionFactoryInit<::Test::DerivedException> iceC_Test_DerivedException_init("::Test::DerivedException");

const ::IceInternal::DefaultValueFactoryInit<::Test::PBase> iceC_Test_PBase_init("::Test::PBase");

const ::IceInternal::DefaultValueFactoryInit<::Test::Preserved> iceC_Test_Preserved_init("::Test::Preserved");

const ::IceInternal::DefaultValueFactoryInit<::Test::PDerived> iceC_Test_PDerived_init("::Test::PDerived");

const ::IceInternal::DefaultValueFactoryInit<::Test::CompactPDerived> iceC_Test_CompactPDerived_init("::Test::CompactPDerived");
const ::IceInternal::CompactIdInit iceC_Test_CompactPDerived_compactIdInit ("::Test::CompactPDerived", 56);

const ::IceInternal::DefaultValueFactoryInit<::Test::PNode> iceC_Test_PNode_init("::Test::PNode");

const ::IceInternal::DefaultUserExceptionFactoryInit<::Test::PreservedException> iceC_Test_PreservedException_init("::Test::PreservedException");

const ::IceInternal::DefaultValueFactoryInit<::Test::PCUnknown> iceC_Test_PCUnknown_init("::Test::PCUnknown");

const ::IceInternal::DefaultValueFactoryInit<::Test::PCDerived> iceC_Test_PCDerived_init("::Test::PCDerived");

const ::IceInternal::DefaultValueFactoryInit<::Test::PCDerived2> iceC_Test_PCDerived2_init("::Test::PCDerived2");

const ::IceInternal::DefaultValueFactoryInit<::Test::PCDerived3> iceC_Test_PCDerived3_init("::Test::PCDerived3");

const ::IceInternal::DefaultValueFactoryInit<::Test::CompactPCDerived> iceC_Test_CompactPCDerived_init("::Test::CompactPCDerived");
const ::IceInternal::CompactIdInit iceC_Test_CompactPCDerived_compactIdInit ("::Test::CompactPCDerived", 57);

const ::std::string iceC_Test_TestIntf_ids[2] =
{
    "::Ice::Object",
    "::Test::TestIntf"
};
const ::std::string iceC_Test_TestIntf_ops[] =
{
    "D1AsB",
    "D1AsD1",
    "D2AsB",
    "PBSUnknown2AsPreservedWithGraph",
    "PBSUnknownAsPreserved",
    "PBSUnknownAsPreservedWithGraph",
    "SBSKnownDerivedAsSBSKnownDerived",
    "SBSKnownDerivedAsSBase",
    "SBSUnknownDerivedAsSBase",
    "SBSUnknownDerivedAsSBaseCompact",
    "SBaseAsObject",
    "SBaseAsSBase",
    "SUnknownAsObject",
    "checkPBSUnknown",
    "checkPBSUnknown2WithGraph",
    "checkPBSUnknownWithGraph",
    "checkSUnknown",
    "dictionaryTest",
    "exchangePBase",
    "exchangePNode",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "oneElementCycle",
    "paramTest1",
    "paramTest2",
    "paramTest3",
    "paramTest4",
    "returnTest1",
    "returnTest2",
    "returnTest3",
    "sequenceTest",
    "shutdown",
    "throwBaseAsBase",
    "throwDerivedAsBase",
    "throwDerivedAsDerived",
    "throwPreservedException",
    "throwUnknownDerivedAsBase",
    "twoElementCycle",
    "useForward"
};
const ::std::string iceC_Test_TestIntf_SBaseAsObject_name = "SBaseAsObject";
const ::std::string iceC_Test_TestIntf_SBaseAsSBase_name = "SBaseAsSBase";
const ::std::string iceC_Test_TestIntf_SBSKnownDerivedAsSBase_name = "SBSKnownDerivedAsSBase";
const ::std::string iceC_Test_TestIntf_SBSKnownDerivedAsSBSKnownDerived_name = "SBSKnownDerivedAsSBSKnownDerived";
const ::std::string iceC_Test_TestIntf_SBSUnknownDerivedAsSBase_name = "SBSUnknownDerivedAsSBase";
const ::std::string iceC_Test_TestIntf_SBSUnknownDerivedAsSBaseCompact_name = "SBSUnknownDerivedAsSBaseCompact";
const ::std::string iceC_Test_TestIntf_SUnknownAsObject_name = "SUnknownAsObject";
const ::std::string iceC_Test_TestIntf_checkSUnknown_name = "checkSUnknown";
const ::std::string iceC_Test_TestIntf_oneElementCycle_name = "oneElementCycle";
const ::std::string iceC_Test_TestIntf_twoElementCycle_name = "twoElementCycle";
const ::std::string iceC_Test_TestIntf_D1AsB_name = "D1AsB";
const ::std::string iceC_Test_TestIntf_D1AsD1_name = "D1AsD1";
const ::std::string iceC_Test_TestIntf_D2AsB_name = "D2AsB";
const ::std::string iceC_Test_TestIntf_paramTest1_name = "paramTest1";
const ::std::string iceC_Test_TestIntf_paramTest2_name = "paramTest2";
const ::std::string iceC_Test_TestIntf_paramTest3_name = "paramTest3";
const ::std::string iceC_Test_TestIntf_paramTest4_name = "paramTest4";
const ::std::string iceC_Test_TestIntf_returnTest1_name = "returnTest1";
const ::std::string iceC_Test_TestIntf_returnTest2_name = "returnTest2";
const ::std::string iceC_Test_TestIntf_returnTest3_name = "returnTest3";
const ::std::string iceC_Test_TestIntf_sequenceTest_name = "sequenceTest";
const ::std::string iceC_Test_TestIntf_dictionaryTest_name = "dictionaryTest";
const ::std::string iceC_Test_TestIntf_exchangePBase_name = "exchangePBase";
const ::std::string iceC_Test_TestIntf_PBSUnknownAsPreserved_name = "PBSUnknownAsPreserved";
const ::std::string iceC_Test_TestIntf_checkPBSUnknown_name = "checkPBSUnknown";
const ::std::string iceC_Test_TestIntf_PBSUnknownAsPreservedWithGraph_name = "PBSUnknownAsPreservedWithGraph";
const ::std::string iceC_Test_TestIntf_checkPBSUnknownWithGraph_name = "checkPBSUnknownWithGraph";
const ::std::string iceC_Test_TestIntf_PBSUnknown2AsPreservedWithGraph_name = "PBSUnknown2AsPreservedWithGraph";
const ::std::string iceC_Test_TestIntf_checkPBSUnknown2WithGraph_name = "checkPBSUnknown2WithGraph";
const ::std::string iceC_Test_TestIntf_exchangePNode_name = "exchangePNode";
const ::std::string iceC_Test_TestIntf_throwBaseAsBase_name = "throwBaseAsBase";
const ::std::string iceC_Test_TestIntf_throwDerivedAsBase_name = "throwDerivedAsBase";
const ::std::string iceC_Test_TestIntf_throwDerivedAsDerived_name = "throwDerivedAsDerived";
const ::std::string iceC_Test_TestIntf_throwUnknownDerivedAsBase_name = "throwUnknownDerivedAsBase";
const ::std::string iceC_Test_TestIntf_throwPreservedException_name = "throwPreservedException";
const ::std::string iceC_Test_TestIntf_useForward_name = "useForward";
const ::std::string iceC_Test_TestIntf_shutdown_name = "shutdown";

const ::IceInternal::DefaultValueFactoryInit<::Test::Hidden> iceC_Test_Hidden_init("::Test::Hidden");

const ::IceInternal::DefaultValueFactoryInit<::Test::Forward> iceC_Test_Forward_init("::Test::Forward");

const ::IceInternal::DefaultValueFactoryInit<::Test::D3> iceC_Test_D3_init("::Test::D3");

}

Test::BaseException::~BaseException()
{
}

const ::std::string&
Test::BaseException::ice_staticId()
{
    static const ::std::string typeId = "::Test::BaseException";
    return typeId;
}

/// \cond STREAM
bool
Test::BaseException::_usesClasses() const
{
    return true;
}
/// \endcond

Test::DerivedException::~DerivedException()
{
}

const ::std::string&
Test::DerivedException::ice_staticId()
{
    static const ::std::string typeId = "::Test::DerivedException";
    return typeId;
}

Test::PreservedException::~PreservedException()
{
}

const ::std::string&
Test::PreservedException::ice_staticId()
{
    static const ::std::string typeId = "::Test::PreservedException";
    return typeId;
}

::std::shared_ptr<::Ice::SlicedData>
Test::PreservedException::ice_getSlicedData() const
{
    return _slicedData;
}

/// \cond STREAM
void
Test::PreservedException::_write(::Ice::OutputStream* ostr) const
{
    ostr->startException(_slicedData);
    _writeImpl(ostr);
    ostr->endException();
}

void
Test::PreservedException::_read(::Ice::InputStream* istr)
{
    istr->startException();
    _readImpl(istr);
    _slicedData = istr->endException(true);
}
/// \endcond

bool
Test::TestIntf::ice_isA(::std::string s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_TestIntf_ids, iceC_Test_TestIntf_ids + 2, s);
}

::std::vector<::std::string>
Test::TestIntf::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector<::std::string>(&iceC_Test_TestIntf_ids[0], &iceC_Test_TestIntf_ids[2]);
}

::std::string
Test::TestIntf::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::TestIntf::ice_staticId()
{
    static const ::std::string typeId = "::Test::TestIntf";
    return typeId;
}

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_SBaseAsObject(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    ::std::shared_ptr<::Ice::Value> ret = this->SBaseAsObject(current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_SBaseAsSBase(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    ::std::shared_ptr<SBase> ret = this->SBaseAsSBase(current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_SBSKnownDerivedAsSBase(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    ::std::shared_ptr<SBase> ret = this->SBSKnownDerivedAsSBase(current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_SBSKnownDerivedAsSBSKnownDerived(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    ::std::shared_ptr<SBSKnownDerived> ret = this->SBSKnownDerivedAsSBSKnownDerived(current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_SBSUnknownDerivedAsSBase(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    ::std::shared_ptr<SBase> ret = this->SBSUnknownDerivedAsSBase(current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_SBSUnknownDerivedAsSBaseCompact(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::FormatType::CompactFormat);
    ::std::shared_ptr<SBase> ret = this->SBSUnknownDerivedAsSBaseCompact(current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_SUnknownAsObject(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    ::std::shared_ptr<::Ice::Value> ret = this->SUnknownAsObject(current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_checkSUnknown(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::shared_ptr<::Ice::Value> iceP_o;
    istr->readAll(iceP_o);
    istr->readPendingValues();
    inS.endReadParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    this->checkSUnknown(::std::move(iceP_o), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_oneElementCycle(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    ::std::shared_ptr<B> ret = this->oneElementCycle(current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_twoElementCycle(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    ::std::shared_ptr<B> ret = this->twoElementCycle(current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_D1AsB(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    ::std::shared_ptr<B> ret = this->D1AsB(current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_D1AsD1(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    ::std::shared_ptr<D1> ret = this->D1AsD1(current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_D2AsB(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    ::std::shared_ptr<B> ret = this->D2AsB(current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_paramTest1(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    ::std::shared_ptr<B> iceP_p1;
    ::std::shared_ptr<B> iceP_p2;
    this->paramTest1(iceP_p1, iceP_p2, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_p1, iceP_p2);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_paramTest2(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    ::std::shared_ptr<B> iceP_p2;
    ::std::shared_ptr<B> iceP_p1;
    this->paramTest2(iceP_p2, iceP_p1, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_p2, iceP_p1);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_paramTest3(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    ::std::shared_ptr<B> iceP_p1;
    ::std::shared_ptr<B> iceP_p2;
    ::std::shared_ptr<B> ret = this->paramTest3(iceP_p1, iceP_p2, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_p1, iceP_p2, ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_paramTest4(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    ::std::shared_ptr<B> iceP_p;
    ::std::shared_ptr<B> ret = this->paramTest4(iceP_p, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_p, ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_returnTest1(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    ::std::shared_ptr<B> iceP_p1;
    ::std::shared_ptr<B> iceP_p2;
    ::std::shared_ptr<B> ret = this->returnTest1(iceP_p1, iceP_p2, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_p1, iceP_p2, ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_returnTest2(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    ::std::shared_ptr<B> iceP_p2;
    ::std::shared_ptr<B> iceP_p1;
    ::std::shared_ptr<B> ret = this->returnTest2(iceP_p2, iceP_p1, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_p2, iceP_p1, ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_returnTest3(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::shared_ptr<B> iceP_p1;
    ::std::shared_ptr<B> iceP_p2;
    istr->readAll(iceP_p1, iceP_p2);
    istr->readPendingValues();
    inS.endReadParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    ::std::shared_ptr<B> ret = this->returnTest3(::std::move(iceP_p1), ::std::move(iceP_p2), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_sequenceTest(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::shared_ptr<SS1> iceP_p1;
    ::std::shared_ptr<SS2> iceP_p2;
    istr->readAll(iceP_p1, iceP_p2);
    istr->readPendingValues();
    inS.endReadParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    SS ret = this->sequenceTest(::std::move(iceP_p1), ::std::move(iceP_p2), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_dictionaryTest(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    BDict iceP_bin;
    istr->readAll(iceP_bin);
    istr->readPendingValues();
    inS.endReadParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    BDict iceP_bout;
    BDict ret = this->dictionaryTest(::std::move(iceP_bin), iceP_bout, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_bout, ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_exchangePBase(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::shared_ptr<PBase> iceP_pb;
    istr->readAll(iceP_pb);
    istr->readPendingValues();
    inS.endReadParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    ::std::shared_ptr<PBase> ret = this->exchangePBase(::std::move(iceP_pb), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_PBSUnknownAsPreserved(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    ::std::shared_ptr<Preserved> ret = this->PBSUnknownAsPreserved(current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_checkPBSUnknown(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::shared_ptr<Preserved> iceP_p;
    istr->readAll(iceP_p);
    istr->readPendingValues();
    inS.endReadParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    this->checkPBSUnknown(::std::move(iceP_p), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_PBSUnknownAsPreservedWithGraph(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    ::std::shared_ptr<Preserved> ret = this->PBSUnknownAsPreservedWithGraph(current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_checkPBSUnknownWithGraph(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::shared_ptr<Preserved> iceP_p;
    istr->readAll(iceP_p);
    istr->readPendingValues();
    inS.endReadParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    this->checkPBSUnknownWithGraph(::std::move(iceP_p), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_PBSUnknown2AsPreservedWithGraph(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    ::std::shared_ptr<Preserved> ret = this->PBSUnknown2AsPreservedWithGraph(current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_checkPBSUnknown2WithGraph(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::shared_ptr<Preserved> iceP_p;
    istr->readAll(iceP_p);
    istr->readPendingValues();
    inS.endReadParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    this->checkPBSUnknown2WithGraph(::std::move(iceP_p), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_exchangePNode(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::shared_ptr<PNode> iceP_pn;
    istr->readAll(iceP_pn);
    istr->readPendingValues();
    inS.endReadParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    ::std::shared_ptr<PNode> ret = this->exchangePNode(::std::move(iceP_pn), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_throwBaseAsBase(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    this->throwBaseAsBase(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_throwDerivedAsBase(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    this->throwDerivedAsBase(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_throwDerivedAsDerived(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    this->throwDerivedAsDerived(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_throwUnknownDerivedAsBase(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    this->throwUnknownDerivedAsBase(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_throwPreservedException(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    this->throwPreservedExceptionAsync(inA->response(), inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_useForward(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    ::std::shared_ptr<Forward> iceP_f;
    this->useForward(iceP_f, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_f);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_shutdown(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    this->shutdown(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_Test_TestIntf_ops, iceC_Test_TestIntf_ops + 41, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_Test_TestIntf_ops)
    {
        case 0:
        {
            return _iceD_D1AsB(in, current);
        }
        case 1:
        {
            return _iceD_D1AsD1(in, current);
        }
        case 2:
        {
            return _iceD_D2AsB(in, current);
        }
        case 3:
        {
            return _iceD_PBSUnknown2AsPreservedWithGraph(in, current);
        }
        case 4:
        {
            return _iceD_PBSUnknownAsPreserved(in, current);
        }
        case 5:
        {
            return _iceD_PBSUnknownAsPreservedWithGraph(in, current);
        }
        case 6:
        {
            return _iceD_SBSKnownDerivedAsSBSKnownDerived(in, current);
        }
        case 7:
        {
            return _iceD_SBSKnownDerivedAsSBase(in, current);
        }
        case 8:
        {
            return _iceD_SBSUnknownDerivedAsSBase(in, current);
        }
        case 9:
        {
            return _iceD_SBSUnknownDerivedAsSBaseCompact(in, current);
        }
        case 10:
        {
            return _iceD_SBaseAsObject(in, current);
        }
        case 11:
        {
            return _iceD_SBaseAsSBase(in, current);
        }
        case 12:
        {
            return _iceD_SUnknownAsObject(in, current);
        }
        case 13:
        {
            return _iceD_checkPBSUnknown(in, current);
        }
        case 14:
        {
            return _iceD_checkPBSUnknown2WithGraph(in, current);
        }
        case 15:
        {
            return _iceD_checkPBSUnknownWithGraph(in, current);
        }
        case 16:
        {
            return _iceD_checkSUnknown(in, current);
        }
        case 17:
        {
            return _iceD_dictionaryTest(in, current);
        }
        case 18:
        {
            return _iceD_exchangePBase(in, current);
        }
        case 19:
        {
            return _iceD_exchangePNode(in, current);
        }
        case 20:
        {
            return _iceD_ice_id(in, current);
        }
        case 21:
        {
            return _iceD_ice_ids(in, current);
        }
        case 22:
        {
            return _iceD_ice_isA(in, current);
        }
        case 23:
        {
            return _iceD_ice_ping(in, current);
        }
        case 24:
        {
            return _iceD_oneElementCycle(in, current);
        }
        case 25:
        {
            return _iceD_paramTest1(in, current);
        }
        case 26:
        {
            return _iceD_paramTest2(in, current);
        }
        case 27:
        {
            return _iceD_paramTest3(in, current);
        }
        case 28:
        {
            return _iceD_paramTest4(in, current);
        }
        case 29:
        {
            return _iceD_returnTest1(in, current);
        }
        case 30:
        {
            return _iceD_returnTest2(in, current);
        }
        case 31:
        {
            return _iceD_returnTest3(in, current);
        }
        case 32:
        {
            return _iceD_sequenceTest(in, current);
        }
        case 33:
        {
            return _iceD_shutdown(in, current);
        }
        case 34:
        {
            return _iceD_throwBaseAsBase(in, current);
        }
        case 35:
        {
            return _iceD_throwDerivedAsBase(in, current);
        }
        case 36:
        {
            return _iceD_throwDerivedAsDerived(in, current);
        }
        case 37:
        {
            return _iceD_throwPreservedException(in, current);
        }
        case 38:
        {
            return _iceD_throwUnknownDerivedAsBase(in, current);
        }
        case 39:
        {
            return _iceD_twoElementCycle(in, current);
        }
        case 40:
        {
            return _iceD_useForward(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

Test::SBase::~SBase()
{
}

const ::std::string&
Test::SBase::ice_staticId()
{
    static const ::std::string typeId = "::Test::SBase";
    return typeId;
}

Test::SBSKnownDerived::~SBSKnownDerived()
{
}

const ::std::string&
Test::SBSKnownDerived::ice_staticId()
{
    static const ::std::string typeId = "::Test::SBSKnownDerived";
    return typeId;
}

Test::B::~B()
{
}

const ::std::string&
Test::B::ice_staticId()
{
    static const ::std::string typeId = "::Test::B";
    return typeId;
}

Test::D1::~D1()
{
}

const ::std::string&
Test::D1::ice_staticId()
{
    static const ::std::string typeId = "::Test::D1";
    return typeId;
}

Test::SS1::~SS1()
{
}

const ::std::string&
Test::SS1::ice_staticId()
{
    static const ::std::string typeId = "::Test::SS1";
    return typeId;
}

Test::SS2::~SS2()
{
}

const ::std::string&
Test::SS2::ice_staticId()
{
    static const ::std::string typeId = "::Test::SS2";
    return typeId;
}

Test::PBase::~PBase()
{
}

const ::std::string&
Test::PBase::ice_staticId()
{
    static const ::std::string typeId = "::Test::PBase";
    return typeId;
}

Test::Preserved::~Preserved()
{
}

::std::shared_ptr<::Ice::SlicedData>
Test::Preserved::ice_getSlicedData() const
{
    return _iceSlicedData;
}

/// \cond STREAM
void
Test::Preserved::_iceWrite(::Ice::OutputStream* ostr) const
{
    ostr->startValue(_iceSlicedData);
    _iceWriteImpl(ostr);
    ostr->endValue();
}

void
Test::Preserved::_iceRead(::Ice::InputStream* istr)
{
    istr->startValue();
    _iceReadImpl(istr);
    _iceSlicedData = istr->endValue(true);
}
/// \endcond

const ::std::string&
Test::Preserved::ice_staticId()
{
    static const ::std::string typeId = "::Test::Preserved";
    return typeId;
}

Test::PDerived::~PDerived()
{
}

const ::std::string&
Test::PDerived::ice_staticId()
{
    static const ::std::string typeId = "::Test::PDerived";
    return typeId;
}

Test::CompactPDerived::~CompactPDerived()
{
}

const ::std::string&
Test::CompactPDerived::ice_staticId()
{
    static const ::std::string typeId = "::Test::CompactPDerived";
    return typeId;
}

Test::PNode::~PNode()
{
}

::std::shared_ptr<::Ice::SlicedData>
Test::PNode::ice_getSlicedData() const
{
    return _iceSlicedData;
}

/// \cond STREAM
void
Test::PNode::_iceWrite(::Ice::OutputStream* ostr) const
{
    ostr->startValue(_iceSlicedData);
    _iceWriteImpl(ostr);
    ostr->endValue();
}

void
Test::PNode::_iceRead(::Ice::InputStream* istr)
{
    istr->startValue();
    _iceReadImpl(istr);
    _iceSlicedData = istr->endValue(true);
}
/// \endcond

const ::std::string&
Test::PNode::ice_staticId()
{
    static const ::std::string typeId = "::Test::PNode";
    return typeId;
}

Test::PCUnknown::~PCUnknown()
{
}

::std::shared_ptr<::Ice::SlicedData>
Test::PCUnknown::ice_getSlicedData() const
{
    return _iceSlicedData;
}

/// \cond STREAM
void
Test::PCUnknown::_iceWrite(::Ice::OutputStream* ostr) const
{
    ostr->startValue(_iceSlicedData);
    _iceWriteImpl(ostr);
    ostr->endValue();
}

void
Test::PCUnknown::_iceRead(::Ice::InputStream* istr)
{
    istr->startValue();
    _iceReadImpl(istr);
    _iceSlicedData = istr->endValue(true);
}
/// \endcond

const ::std::string&
Test::PCUnknown::ice_staticId()
{
    static const ::std::string typeId = "::Test::PCUnknown";
    return typeId;
}

Test::PCDerived::~PCDerived()
{
}

const ::std::string&
Test::PCDerived::ice_staticId()
{
    static const ::std::string typeId = "::Test::PCDerived";
    return typeId;
}

Test::PCDerived2::~PCDerived2()
{
}

const ::std::string&
Test::PCDerived2::ice_staticId()
{
    static const ::std::string typeId = "::Test::PCDerived2";
    return typeId;
}

Test::PCDerived3::~PCDerived3()
{
}

const ::std::string&
Test::PCDerived3::ice_staticId()
{
    static const ::std::string typeId = "::Test::PCDerived3";
    return typeId;
}

Test::CompactPCDerived::~CompactPCDerived()
{
}

const ::std::string&
Test::CompactPCDerived::ice_staticId()
{
    static const ::std::string typeId = "::Test::CompactPCDerived";
    return typeId;
}

Test::Hidden::~Hidden()
{
}

const ::std::string&
Test::Hidden::ice_staticId()
{
    static const ::std::string typeId = "::Test::Hidden";
    return typeId;
}

Test::Forward::~Forward()
{
}

const ::std::string&
Test::Forward::ice_staticId()
{
    static const ::std::string typeId = "::Test::Forward";
    return typeId;
}

Test::D3::~D3()
{
}

const ::std::string&
Test::D3::ice_staticId()
{
    static const ::std::string typeId = "::Test::D3";
    return typeId;
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_SBaseAsObject(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Ice::Value>>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_SBaseAsObject_name);
    outAsync->invoke(iceC_Test_TestIntf_SBaseAsObject_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        nullptr,
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::shared_ptr<::Ice::Value> ret;
            istr->readAll(ret);
            istr->readPendingValues();
            return ret;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_SBaseAsSBase(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Test::SBase>>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_SBaseAsSBase_name);
    outAsync->invoke(iceC_Test_TestIntf_SBaseAsSBase_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        nullptr,
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::shared_ptr<SBase> ret;
            istr->readAll(ret);
            istr->readPendingValues();
            return ret;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_SBSKnownDerivedAsSBase(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Test::SBase>>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_SBSKnownDerivedAsSBase_name);
    outAsync->invoke(iceC_Test_TestIntf_SBSKnownDerivedAsSBase_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        nullptr,
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::shared_ptr<SBase> ret;
            istr->readAll(ret);
            istr->readPendingValues();
            return ret;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_SBSKnownDerivedAsSBSKnownDerived(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Test::SBSKnownDerived>>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_SBSKnownDerivedAsSBSKnownDerived_name);
    outAsync->invoke(iceC_Test_TestIntf_SBSKnownDerivedAsSBSKnownDerived_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        nullptr,
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::shared_ptr<SBSKnownDerived> ret;
            istr->readAll(ret);
            istr->readPendingValues();
            return ret;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_SBSUnknownDerivedAsSBase(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Test::SBase>>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_SBSUnknownDerivedAsSBase_name);
    outAsync->invoke(iceC_Test_TestIntf_SBSUnknownDerivedAsSBase_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        nullptr,
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::shared_ptr<SBase> ret;
            istr->readAll(ret);
            istr->readPendingValues();
            return ret;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_SBSUnknownDerivedAsSBaseCompact(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Test::SBase>>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_SBSUnknownDerivedAsSBaseCompact_name);
    outAsync->invoke(iceC_Test_TestIntf_SBSUnknownDerivedAsSBaseCompact_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::CompactFormat, context,
        nullptr,
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::shared_ptr<SBase> ret;
            istr->readAll(ret);
            istr->readPendingValues();
            return ret;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_SUnknownAsObject(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Ice::Value>>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_SUnknownAsObject_name);
    outAsync->invoke(iceC_Test_TestIntf_SUnknownAsObject_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        nullptr,
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::shared_ptr<::Ice::Value> ret;
            istr->readAll(ret);
            istr->readPendingValues();
            return ret;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_checkSUnknown(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::shared_ptr<::Ice::Value>& iceP_o, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_Test_TestIntf_checkSUnknown_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_o);
            ostr->writePendingValues();
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_oneElementCycle(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Test::B>>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_oneElementCycle_name);
    outAsync->invoke(iceC_Test_TestIntf_oneElementCycle_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        nullptr,
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::shared_ptr<B> ret;
            istr->readAll(ret);
            istr->readPendingValues();
            return ret;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_twoElementCycle(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Test::B>>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_twoElementCycle_name);
    outAsync->invoke(iceC_Test_TestIntf_twoElementCycle_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        nullptr,
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::shared_ptr<B> ret;
            istr->readAll(ret);
            istr->readPendingValues();
            return ret;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_D1AsB(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Test::B>>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_D1AsB_name);
    outAsync->invoke(iceC_Test_TestIntf_D1AsB_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        nullptr,
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::shared_ptr<B> ret;
            istr->readAll(ret);
            istr->readPendingValues();
            return ret;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_D1AsD1(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Test::D1>>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_D1AsD1_name);
    outAsync->invoke(iceC_Test_TestIntf_D1AsD1_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        nullptr,
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::shared_ptr<D1> ret;
            istr->readAll(ret);
            istr->readPendingValues();
            return ret;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_D2AsB(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Test::B>>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_D2AsB_name);
    outAsync->invoke(iceC_Test_TestIntf_D2AsB_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        nullptr,
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::shared_ptr<B> ret;
            istr->readAll(ret);
            istr->readPendingValues();
            return ret;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_paramTest1(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::ParamTest1Result>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_paramTest1_name);
    outAsync->invoke(iceC_Test_TestIntf_paramTest1_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        nullptr,
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::ParamTest1Result v;
            istr->readAll(v.p1, v.p2);
            istr->readPendingValues();
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_paramTest2(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::ParamTest2Result>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_paramTest2_name);
    outAsync->invoke(iceC_Test_TestIntf_paramTest2_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        nullptr,
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::ParamTest2Result v;
            istr->readAll(v.p2, v.p1);
            istr->readPendingValues();
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_paramTest3(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::ParamTest3Result>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_paramTest3_name);
    outAsync->invoke(iceC_Test_TestIntf_paramTest3_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        nullptr,
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::ParamTest3Result v;
            istr->readAll(v.p1, v.p2, v.returnValue);
            istr->readPendingValues();
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_paramTest4(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::ParamTest4Result>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_paramTest4_name);
    outAsync->invoke(iceC_Test_TestIntf_paramTest4_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        nullptr,
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::ParamTest4Result v;
            istr->readAll(v.p, v.returnValue);
            istr->readPendingValues();
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_returnTest1(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::ReturnTest1Result>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_returnTest1_name);
    outAsync->invoke(iceC_Test_TestIntf_returnTest1_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        nullptr,
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::ReturnTest1Result v;
            istr->readAll(v.p1, v.p2, v.returnValue);
            istr->readPendingValues();
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_returnTest2(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::ReturnTest2Result>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_returnTest2_name);
    outAsync->invoke(iceC_Test_TestIntf_returnTest2_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        nullptr,
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::ReturnTest2Result v;
            istr->readAll(v.p2, v.p1, v.returnValue);
            istr->readPendingValues();
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_returnTest3(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Test::B>>>& outAsync, const ::std::shared_ptr<B>& iceP_p1, const ::std::shared_ptr<B>& iceP_p2, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_returnTest3_name);
    outAsync->invoke(iceC_Test_TestIntf_returnTest3_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p1, iceP_p2);
            ostr->writePendingValues();
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::shared_ptr<B> ret;
            istr->readAll(ret);
            istr->readPendingValues();
            return ret;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_sequenceTest(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::Test::SS>>& outAsync, const ::std::shared_ptr<SS1>& iceP_p1, const ::std::shared_ptr<SS2>& iceP_p2, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_sequenceTest_name);
    outAsync->invoke(iceC_Test_TestIntf_sequenceTest_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p1, iceP_p2);
            ostr->writePendingValues();
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            SS ret;
            istr->readAll(ret);
            istr->readPendingValues();
            return ret;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_dictionaryTest(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::DictionaryTestResult>>& outAsync, const BDict& iceP_bin, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_dictionaryTest_name);
    outAsync->invoke(iceC_Test_TestIntf_dictionaryTest_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_bin);
            ostr->writePendingValues();
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::DictionaryTestResult v;
            istr->readAll(v.bout, v.returnValue);
            istr->readPendingValues();
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_exchangePBase(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Test::PBase>>>& outAsync, const ::std::shared_ptr<PBase>& iceP_pb, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_exchangePBase_name);
    outAsync->invoke(iceC_Test_TestIntf_exchangePBase_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_pb);
            ostr->writePendingValues();
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::shared_ptr<PBase> ret;
            istr->readAll(ret);
            istr->readPendingValues();
            return ret;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_PBSUnknownAsPreserved(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Test::Preserved>>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_PBSUnknownAsPreserved_name);
    outAsync->invoke(iceC_Test_TestIntf_PBSUnknownAsPreserved_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        nullptr,
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::shared_ptr<Preserved> ret;
            istr->readAll(ret);
            istr->readPendingValues();
            return ret;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_checkPBSUnknown(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::shared_ptr<Preserved>& iceP_p, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_Test_TestIntf_checkPBSUnknown_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p);
            ostr->writePendingValues();
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_PBSUnknownAsPreservedWithGraph(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Test::Preserved>>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_PBSUnknownAsPreservedWithGraph_name);
    outAsync->invoke(iceC_Test_TestIntf_PBSUnknownAsPreservedWithGraph_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        nullptr,
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::shared_ptr<Preserved> ret;
            istr->readAll(ret);
            istr->readPendingValues();
            return ret;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_checkPBSUnknownWithGraph(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::shared_ptr<Preserved>& iceP_p, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_Test_TestIntf_checkPBSUnknownWithGraph_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p);
            ostr->writePendingValues();
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_PBSUnknown2AsPreservedWithGraph(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Test::Preserved>>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_PBSUnknown2AsPreservedWithGraph_name);
    outAsync->invoke(iceC_Test_TestIntf_PBSUnknown2AsPreservedWithGraph_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        nullptr,
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::shared_ptr<Preserved> ret;
            istr->readAll(ret);
            istr->readPendingValues();
            return ret;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_checkPBSUnknown2WithGraph(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::shared_ptr<Preserved>& iceP_p, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_Test_TestIntf_checkPBSUnknown2WithGraph_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p);
            ostr->writePendingValues();
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_exchangePNode(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Test::PNode>>>& outAsync, const ::std::shared_ptr<PNode>& iceP_pn, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_exchangePNode_name);
    outAsync->invoke(iceC_Test_TestIntf_exchangePNode_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_pn);
            ostr->writePendingValues();
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::shared_ptr<PNode> ret;
            istr->readAll(ret);
            istr->readPendingValues();
            return ret;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_throwBaseAsBase(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_throwBaseAsBase_name);
    outAsync->invoke(iceC_Test_TestIntf_throwBaseAsBase_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        nullptr,
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const BaseException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_throwDerivedAsBase(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_throwDerivedAsBase_name);
    outAsync->invoke(iceC_Test_TestIntf_throwDerivedAsBase_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        nullptr,
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const BaseException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_throwDerivedAsDerived(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_throwDerivedAsDerived_name);
    outAsync->invoke(iceC_Test_TestIntf_throwDerivedAsDerived_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        nullptr,
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const DerivedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_throwUnknownDerivedAsBase(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_throwUnknownDerivedAsBase_name);
    outAsync->invoke(iceC_Test_TestIntf_throwUnknownDerivedAsBase_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        nullptr,
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const BaseException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_throwPreservedException(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_throwPreservedException_name);
    outAsync->invoke(iceC_Test_TestIntf_throwPreservedException_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        nullptr,
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const PreservedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_useForward(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Test::Forward>>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_useForward_name);
    outAsync->invoke(iceC_Test_TestIntf_useForward_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        nullptr,
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::shared_ptr<Forward> iceP_f;
            istr->readAll(iceP_f);
            istr->readPendingValues();
            return iceP_f;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_shutdown(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_Test_TestIntf_shutdown_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

/// \cond INTERNAL
::std::shared_ptr<::Ice::ObjectPrx>
Test::TestIntfPrx::_newInstance() const
{
    return ::IceInternal::createProxy<TestIntfPrx>();
}
/// \endcond

const ::std::string&
Test::TestIntfPrx::ice_staticId()
{
    return TestIntf::ice_staticId();
}

namespace Ice
{
}

#else // C++98 mapping

namespace
{

const ::std::string iceC_Test_TestIntf_SBaseAsObject_name = "SBaseAsObject";

const ::std::string iceC_Test_TestIntf_SBaseAsSBase_name = "SBaseAsSBase";

const ::std::string iceC_Test_TestIntf_SBSKnownDerivedAsSBase_name = "SBSKnownDerivedAsSBase";

const ::std::string iceC_Test_TestIntf_SBSKnownDerivedAsSBSKnownDerived_name = "SBSKnownDerivedAsSBSKnownDerived";

const ::std::string iceC_Test_TestIntf_SBSUnknownDerivedAsSBase_name = "SBSUnknownDerivedAsSBase";

const ::std::string iceC_Test_TestIntf_SBSUnknownDerivedAsSBaseCompact_name = "SBSUnknownDerivedAsSBaseCompact";

const ::std::string iceC_Test_TestIntf_SUnknownAsObject_name = "SUnknownAsObject";

const ::std::string iceC_Test_TestIntf_checkSUnknown_name = "checkSUnknown";

const ::std::string iceC_Test_TestIntf_oneElementCycle_name = "oneElementCycle";

const ::std::string iceC_Test_TestIntf_twoElementCycle_name = "twoElementCycle";

const ::std::string iceC_Test_TestIntf_D1AsB_name = "D1AsB";

const ::std::string iceC_Test_TestIntf_D1AsD1_name = "D1AsD1";

const ::std::string iceC_Test_TestIntf_D2AsB_name = "D2AsB";

const ::std::string iceC_Test_TestIntf_paramTest1_name = "paramTest1";

const ::std::string iceC_Test_TestIntf_paramTest2_name = "paramTest2";

const ::std::string iceC_Test_TestIntf_paramTest3_name = "paramTest3";

const ::std::string iceC_Test_TestIntf_paramTest4_name = "paramTest4";

const ::std::string iceC_Test_TestIntf_returnTest1_name = "returnTest1";

const ::std::string iceC_Test_TestIntf_returnTest2_name = "returnTest2";

const ::std::string iceC_Test_TestIntf_returnTest3_name = "returnTest3";

const ::std::string iceC_Test_TestIntf_sequenceTest_name = "sequenceTest";

const ::std::string iceC_Test_TestIntf_dictionaryTest_name = "dictionaryTest";

const ::std::string iceC_Test_TestIntf_exchangePBase_name = "exchangePBase";

const ::std::string iceC_Test_TestIntf_PBSUnknownAsPreserved_name = "PBSUnknownAsPreserved";

const ::std::string iceC_Test_TestIntf_checkPBSUnknown_name = "checkPBSUnknown";

const ::std::string iceC_Test_TestIntf_PBSUnknownAsPreservedWithGraph_name = "PBSUnknownAsPreservedWithGraph";

const ::std::string iceC_Test_TestIntf_checkPBSUnknownWithGraph_name = "checkPBSUnknownWithGraph";

const ::std::string iceC_Test_TestIntf_PBSUnknown2AsPreservedWithGraph_name = "PBSUnknown2AsPreservedWithGraph";

const ::std::string iceC_Test_TestIntf_checkPBSUnknown2WithGraph_name = "checkPBSUnknown2WithGraph";

const ::std::string iceC_Test_TestIntf_exchangePNode_name = "exchangePNode";

const ::std::string iceC_Test_TestIntf_throwBaseAsBase_name = "throwBaseAsBase";

const ::std::string iceC_Test_TestIntf_throwDerivedAsBase_name = "throwDerivedAsBase";

const ::std::string iceC_Test_TestIntf_throwDerivedAsDerived_name = "throwDerivedAsDerived";

const ::std::string iceC_Test_TestIntf_throwUnknownDerivedAsBase_name = "throwUnknownDerivedAsBase";

const ::std::string iceC_Test_TestIntf_throwPreservedException_name = "throwPreservedException";

const ::std::string iceC_Test_TestIntf_useForward_name = "useForward";

const ::std::string iceC_Test_TestIntf_shutdown_name = "shutdown";

}

namespace
{

const ::IceInternal::DefaultUserExceptionFactoryInit< ::Test::BaseException> iceC_Test_BaseException_init("::Test::BaseException");

}

Test::BaseException::BaseException(const ::std::string& sbe, const BPtr& pb) :
    ::Ice::UserException(),
    sbe(sbe),
    pb(pb)
{
}

#ifdef ICE_CPP11_COMPILER
Test::BaseException::~BaseException()
{
}
#else
Test::BaseException::~BaseException() throw()
{
}
#endif

::std::string
Test::BaseException::ice_id() const
{
    return "::Test::BaseException";
}

Test::BaseException*
Test::BaseException::ice_clone() const
{
    return new BaseException(*this);
}

void
Test::BaseException::ice_throw() const
{
    throw *this;
}

bool
Test::BaseException::_usesClasses() const
{
    return true;
}

/// \cond STREAM
void
Test::BaseException::_writeImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice("::Test::BaseException", -1, true);
    ::Ice::StreamWriter< BaseException, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Test::BaseException::_readImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< BaseException, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

namespace
{

const ::IceInternal::DefaultUserExceptionFactoryInit< ::Test::DerivedException> iceC_Test_DerivedException_init("::Test::DerivedException");

}

Test::DerivedException::DerivedException(const ::std::string& sbe, const BPtr& pb, const ::std::string& sde, const D1Ptr& pd1) :
    BaseException(sbe, pb),
    sde(sde),
    pd1(pd1)
{
}

#ifdef ICE_CPP11_COMPILER
Test::DerivedException::~DerivedException()
{
}
#else
Test::DerivedException::~DerivedException() throw()
{
}
#endif

::std::string
Test::DerivedException::ice_id() const
{
    return "::Test::DerivedException";
}

Test::DerivedException*
Test::DerivedException::ice_clone() const
{
    return new DerivedException(*this);
}

void
Test::DerivedException::ice_throw() const
{
    throw *this;
}

/// \cond STREAM
void
Test::DerivedException::_writeImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice("::Test::DerivedException", -1, false);
    ::Ice::StreamWriter< DerivedException, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
    BaseException::_writeImpl(ostr);
}

void
Test::DerivedException::_readImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< DerivedException, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
    BaseException::_readImpl(istr);
}
/// \endcond

namespace
{

const ::IceInternal::DefaultUserExceptionFactoryInit< ::Test::PreservedException> iceC_Test_PreservedException_init("::Test::PreservedException");

}

#ifdef ICE_CPP11_COMPILER
Test::PreservedException::~PreservedException()
{
}
#else
Test::PreservedException::~PreservedException() throw()
{
}
#endif

::std::string
Test::PreservedException::ice_id() const
{
    return "::Test::PreservedException";
}

Test::PreservedException*
Test::PreservedException::ice_clone() const
{
    return new PreservedException(*this);
}

void
Test::PreservedException::ice_throw() const
{
    throw *this;
}

::Ice::SlicedDataPtr
Test::PreservedException::ice_getSlicedData() const
{
    return _slicedData;
}

void
Test::PreservedException::_write(::Ice::OutputStream* ostr) const
{
    ostr->startException(_slicedData);
    _writeImpl(ostr);
    ostr->endException();
}

void
Test::PreservedException::_read(::Ice::InputStream* istr)
{
    istr->startException();
    _readImpl(istr);
    _slicedData = istr->endException(true);
}

/// \cond STREAM
void
Test::PreservedException::_writeImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice("::Test::PreservedException", -1, true);
    ::Ice::StreamWriter< PreservedException, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Test::PreservedException::_readImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< PreservedException, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

Test::AMD_TestIntf_throwPreservedException::~AMD_TestIntf_throwPreservedException()
{
}

/// \cond INTERNAL
IceAsync::Test::AMD_TestIntf_throwPreservedException::AMD_TestIntf_throwPreservedException(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_TestIntf_throwPreservedException::ice_response()
{
    writeEmptyParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(SBase* p) { return p; }

void
::IceProxy::Test::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< SBase>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new SBase;
        v->_copyFrom(proxy);
    }
}
/// \endcond

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::Test::SBase::_newInstance() const
{
    return new SBase;
}
/// \endcond

const ::std::string&
IceProxy::Test::SBase::ice_staticId()
{
    return ::Test::SBase::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(SBSKnownDerived* p) { return p; }

void
::IceProxy::Test::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< SBSKnownDerived>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new SBSKnownDerived;
        v->_copyFrom(proxy);
    }
}
/// \endcond

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::Test::SBSKnownDerived::_newInstance() const
{
    return new SBSKnownDerived;
}
/// \endcond

const ::std::string&
IceProxy::Test::SBSKnownDerived::ice_staticId()
{
    return ::Test::SBSKnownDerived::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(B* p) { return p; }

void
::IceProxy::Test::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< B>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new B;
        v->_copyFrom(proxy);
    }
}
/// \endcond

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::Test::B::_newInstance() const
{
    return new B;
}
/// \endcond

const ::std::string&
IceProxy::Test::B::ice_staticId()
{
    return ::Test::B::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(D1* p) { return p; }

void
::IceProxy::Test::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< D1>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new D1;
        v->_copyFrom(proxy);
    }
}
/// \endcond

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::Test::D1::_newInstance() const
{
    return new D1;
}
/// \endcond

const ::std::string&
IceProxy::Test::D1::ice_staticId()
{
    return ::Test::D1::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(SS1* p) { return p; }

void
::IceProxy::Test::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< SS1>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new SS1;
        v->_copyFrom(proxy);
    }
}
/// \endcond

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::Test::SS1::_newInstance() const
{
    return new SS1;
}
/// \endcond

const ::std::string&
IceProxy::Test::SS1::ice_staticId()
{
    return ::Test::SS1::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(SS2* p) { return p; }

void
::IceProxy::Test::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< SS2>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new SS2;
        v->_copyFrom(proxy);
    }
}
/// \endcond

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::Test::SS2::_newInstance() const
{
    return new SS2;
}
/// \endcond

const ::std::string&
IceProxy::Test::SS2::ice_staticId()
{
    return ::Test::SS2::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(PBase* p) { return p; }

void
::IceProxy::Test::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< PBase>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new PBase;
        v->_copyFrom(proxy);
    }
}
/// \endcond

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::Test::PBase::_newInstance() const
{
    return new PBase;
}
/// \endcond

const ::std::string&
IceProxy::Test::PBase::ice_staticId()
{
    return ::Test::PBase::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(Preserved* p) { return p; }

void
::IceProxy::Test::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< Preserved>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new Preserved;
        v->_copyFrom(proxy);
    }
}
/// \endcond

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::Test::Preserved::_newInstance() const
{
    return new Preserved;
}
/// \endcond

const ::std::string&
IceProxy::Test::Preserved::ice_staticId()
{
    return ::Test::Preserved::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(PDerived* p) { return p; }

void
::IceProxy::Test::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< PDerived>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new PDerived;
        v->_copyFrom(proxy);
    }
}
/// \endcond

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::Test::PDerived::_newInstance() const
{
    return new PDerived;
}
/// \endcond

const ::std::string&
IceProxy::Test::PDerived::ice_staticId()
{
    return ::Test::PDerived::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(CompactPDerived* p) { return p; }

void
::IceProxy::Test::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< CompactPDerived>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new CompactPDerived;
        v->_copyFrom(proxy);
    }
}
/// \endcond

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::Test::CompactPDerived::_newInstance() const
{
    return new CompactPDerived;
}
/// \endcond

const ::std::string&
IceProxy::Test::CompactPDerived::ice_staticId()
{
    return ::Test::CompactPDerived::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(PNode* p) { return p; }

void
::IceProxy::Test::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< PNode>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new PNode;
        v->_copyFrom(proxy);
    }
}
/// \endcond

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::Test::PNode::_newInstance() const
{
    return new PNode;
}
/// \endcond

const ::std::string&
IceProxy::Test::PNode::ice_staticId()
{
    return ::Test::PNode::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(PCUnknown* p) { return p; }

void
::IceProxy::Test::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< PCUnknown>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new PCUnknown;
        v->_copyFrom(proxy);
    }
}
/// \endcond

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::Test::PCUnknown::_newInstance() const
{
    return new PCUnknown;
}
/// \endcond

const ::std::string&
IceProxy::Test::PCUnknown::ice_staticId()
{
    return ::Test::PCUnknown::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(PCDerived* p) { return p; }

void
::IceProxy::Test::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< PCDerived>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new PCDerived;
        v->_copyFrom(proxy);
    }
}
/// \endcond

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::Test::PCDerived::_newInstance() const
{
    return new PCDerived;
}
/// \endcond

const ::std::string&
IceProxy::Test::PCDerived::ice_staticId()
{
    return ::Test::PCDerived::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(PCDerived2* p) { return p; }

void
::IceProxy::Test::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< PCDerived2>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new PCDerived2;
        v->_copyFrom(proxy);
    }
}
/// \endcond

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::Test::PCDerived2::_newInstance() const
{
    return new PCDerived2;
}
/// \endcond

const ::std::string&
IceProxy::Test::PCDerived2::ice_staticId()
{
    return ::Test::PCDerived2::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(PCDerived3* p) { return p; }

void
::IceProxy::Test::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< PCDerived3>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new PCDerived3;
        v->_copyFrom(proxy);
    }
}
/// \endcond

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::Test::PCDerived3::_newInstance() const
{
    return new PCDerived3;
}
/// \endcond

const ::std::string&
IceProxy::Test::PCDerived3::ice_staticId()
{
    return ::Test::PCDerived3::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(CompactPCDerived* p) { return p; }

void
::IceProxy::Test::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< CompactPCDerived>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new CompactPCDerived;
        v->_copyFrom(proxy);
    }
}
/// \endcond

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::Test::CompactPCDerived::_newInstance() const
{
    return new CompactPCDerived;
}
/// \endcond

const ::std::string&
IceProxy::Test::CompactPCDerived::ice_staticId()
{
    return ::Test::CompactPCDerived::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(TestIntf* p) { return p; }

void
::IceProxy::Test::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< TestIntf>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new TestIntf;
        v->_copyFrom(proxy);
    }
}
/// \endcond

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_SBaseAsObject(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_SBaseAsObject_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_SBaseAsObject_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_SBaseAsObject_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Test_TestIntf_SBaseAsObject_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Ice::ObjectPtr
IceProxy::Test::TestIntf::end_SBaseAsObject(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_SBaseAsObject_name);
    ::Ice::ObjectPtr ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    istr->readPendingValues();
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_SBaseAsSBase(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_SBaseAsSBase_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_SBaseAsSBase_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_SBaseAsSBase_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Test_TestIntf_SBaseAsSBase_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::SBasePtr
IceProxy::Test::TestIntf::end_SBaseAsSBase(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_SBaseAsSBase_name);
    ::Test::SBasePtr ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    istr->readPendingValues();
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_SBSKnownDerivedAsSBase(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_SBSKnownDerivedAsSBase_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_SBSKnownDerivedAsSBase_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_SBSKnownDerivedAsSBase_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Test_TestIntf_SBSKnownDerivedAsSBase_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::SBasePtr
IceProxy::Test::TestIntf::end_SBSKnownDerivedAsSBase(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_SBSKnownDerivedAsSBase_name);
    ::Test::SBasePtr ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    istr->readPendingValues();
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_SBSKnownDerivedAsSBSKnownDerived(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_SBSKnownDerivedAsSBSKnownDerived_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_SBSKnownDerivedAsSBSKnownDerived_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_SBSKnownDerivedAsSBSKnownDerived_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Test_TestIntf_SBSKnownDerivedAsSBSKnownDerived_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::SBSKnownDerivedPtr
IceProxy::Test::TestIntf::end_SBSKnownDerivedAsSBSKnownDerived(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_SBSKnownDerivedAsSBSKnownDerived_name);
    ::Test::SBSKnownDerivedPtr ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    istr->readPendingValues();
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_SBSUnknownDerivedAsSBase(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_SBSUnknownDerivedAsSBase_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_SBSUnknownDerivedAsSBase_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_SBSUnknownDerivedAsSBase_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Test_TestIntf_SBSUnknownDerivedAsSBase_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::SBasePtr
IceProxy::Test::TestIntf::end_SBSUnknownDerivedAsSBase(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_SBSUnknownDerivedAsSBase_name);
    ::Test::SBasePtr ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    istr->readPendingValues();
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_SBSUnknownDerivedAsSBaseCompact(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_SBSUnknownDerivedAsSBaseCompact_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_SBSUnknownDerivedAsSBaseCompact_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_SBSUnknownDerivedAsSBaseCompact_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Test_TestIntf_SBSUnknownDerivedAsSBaseCompact_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::SBasePtr
IceProxy::Test::TestIntf::end_SBSUnknownDerivedAsSBaseCompact(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_SBSUnknownDerivedAsSBaseCompact_name);
    ::Test::SBasePtr ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    istr->readPendingValues();
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_SUnknownAsObject(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_SUnknownAsObject_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_SUnknownAsObject_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_SUnknownAsObject_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Test_TestIntf_SUnknownAsObject_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Ice::ObjectPtr
IceProxy::Test::TestIntf::end_SUnknownAsObject(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_SUnknownAsObject_name);
    ::Ice::ObjectPtr ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    istr->readPendingValues();
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_checkSUnknown(const ::Ice::ObjectPtr& iceP_o, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_checkSUnknown_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_checkSUnknown_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::SlicedFormat);
        ostr->write(iceP_o);
        ostr->writePendingValues();
        result->endWriteParams();
        result->invoke(iceC_Test_TestIntf_checkSUnknown_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Test::TestIntf::end_checkSUnknown(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_Test_TestIntf_checkSUnknown_name);
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_oneElementCycle(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_oneElementCycle_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_oneElementCycle_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_oneElementCycle_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Test_TestIntf_oneElementCycle_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::BPtr
IceProxy::Test::TestIntf::end_oneElementCycle(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_oneElementCycle_name);
    ::Test::BPtr ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    istr->readPendingValues();
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_twoElementCycle(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_twoElementCycle_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_twoElementCycle_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_twoElementCycle_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Test_TestIntf_twoElementCycle_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::BPtr
IceProxy::Test::TestIntf::end_twoElementCycle(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_twoElementCycle_name);
    ::Test::BPtr ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    istr->readPendingValues();
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_D1AsB(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_D1AsB_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_D1AsB_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_D1AsB_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Test_TestIntf_D1AsB_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::BPtr
IceProxy::Test::TestIntf::end_D1AsB(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_D1AsB_name);
    ::Test::BPtr ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    istr->readPendingValues();
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_D1AsD1(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_D1AsD1_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_D1AsD1_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_D1AsD1_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Test_TestIntf_D1AsD1_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::D1Ptr
IceProxy::Test::TestIntf::end_D1AsD1(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_D1AsD1_name);
    ::Test::D1Ptr ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    istr->readPendingValues();
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_D2AsB(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_D2AsB_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_D2AsB_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_D2AsB_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Test_TestIntf_D2AsB_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::BPtr
IceProxy::Test::TestIntf::end_D2AsB(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_D2AsB_name);
    ::Test::BPtr ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    istr->readPendingValues();
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_paramTest1(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_paramTest1_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_paramTest1_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_paramTest1_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Test_TestIntf_paramTest1_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Test::TestIntf::end_paramTest1(::Test::BPtr& iceP_p1, ::Test::BPtr& iceP_p2, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_paramTest1_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p1);
    istr->read(iceP_p2);
    istr->readPendingValues();
    result->_endReadParams();
}

void IceProxy::Test::TestIntf::_iceI_end_paramTest1(::Test::BPtr& iceP_p1, ::Test::BPtr& iceP_p2, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_paramTest1_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p1);
    istr->read(iceP_p2);
    istr->readPendingValues();
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_paramTest2(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_paramTest2_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_paramTest2_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_paramTest2_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Test_TestIntf_paramTest2_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Test::TestIntf::end_paramTest2(::Test::BPtr& iceP_p2, ::Test::BPtr& iceP_p1, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_paramTest2_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p2);
    istr->read(iceP_p1);
    istr->readPendingValues();
    result->_endReadParams();
}

void IceProxy::Test::TestIntf::_iceI_end_paramTest2(::Test::BPtr& iceP_p2, ::Test::BPtr& iceP_p1, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_paramTest2_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p2);
    istr->read(iceP_p1);
    istr->readPendingValues();
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_paramTest3(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_paramTest3_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_paramTest3_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_paramTest3_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Test_TestIntf_paramTest3_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::BPtr
IceProxy::Test::TestIntf::end_paramTest3(::Test::BPtr& iceP_p1, ::Test::BPtr& iceP_p2, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_paramTest3_name);
    ::Test::BPtr ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p1);
    istr->read(iceP_p2);
    istr->read(ret);
    istr->readPendingValues();
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::TestIntf::_iceI_end_paramTest3(::Test::BPtr& iceP_p1, ::Test::BPtr& iceP_p2, ::Test::BPtr& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_paramTest3_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p1);
    istr->read(iceP_p2);
    istr->read(ret);
    istr->readPendingValues();
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_paramTest4(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_paramTest4_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_paramTest4_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_paramTest4_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Test_TestIntf_paramTest4_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::BPtr
IceProxy::Test::TestIntf::end_paramTest4(::Test::BPtr& iceP_p, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_paramTest4_name);
    ::Test::BPtr ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p);
    istr->read(ret);
    istr->readPendingValues();
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::TestIntf::_iceI_end_paramTest4(::Test::BPtr& iceP_p, ::Test::BPtr& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_paramTest4_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p);
    istr->read(ret);
    istr->readPendingValues();
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_returnTest1(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_returnTest1_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_returnTest1_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_returnTest1_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Test_TestIntf_returnTest1_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::BPtr
IceProxy::Test::TestIntf::end_returnTest1(::Test::BPtr& iceP_p1, ::Test::BPtr& iceP_p2, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_returnTest1_name);
    ::Test::BPtr ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p1);
    istr->read(iceP_p2);
    istr->read(ret);
    istr->readPendingValues();
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::TestIntf::_iceI_end_returnTest1(::Test::BPtr& iceP_p1, ::Test::BPtr& iceP_p2, ::Test::BPtr& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_returnTest1_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p1);
    istr->read(iceP_p2);
    istr->read(ret);
    istr->readPendingValues();
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_returnTest2(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_returnTest2_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_returnTest2_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_returnTest2_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Test_TestIntf_returnTest2_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::BPtr
IceProxy::Test::TestIntf::end_returnTest2(::Test::BPtr& iceP_p2, ::Test::BPtr& iceP_p1, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_returnTest2_name);
    ::Test::BPtr ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p2);
    istr->read(iceP_p1);
    istr->read(ret);
    istr->readPendingValues();
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::TestIntf::_iceI_end_returnTest2(::Test::BPtr& iceP_p2, ::Test::BPtr& iceP_p1, ::Test::BPtr& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_returnTest2_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_p2);
    istr->read(iceP_p1);
    istr->read(ret);
    istr->readPendingValues();
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_returnTest3(const ::Test::BPtr& iceP_p1, const ::Test::BPtr& iceP_p2, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_returnTest3_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_returnTest3_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_returnTest3_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::SlicedFormat);
        ostr->write(iceP_p1);
        ostr->write(iceP_p2);
        ostr->writePendingValues();
        result->endWriteParams();
        result->invoke(iceC_Test_TestIntf_returnTest3_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::BPtr
IceProxy::Test::TestIntf::end_returnTest3(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_returnTest3_name);
    ::Test::BPtr ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    istr->readPendingValues();
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_sequenceTest(const ::Test::SS1Ptr& iceP_p1, const ::Test::SS2Ptr& iceP_p2, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_sequenceTest_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_sequenceTest_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_sequenceTest_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::SlicedFormat);
        ostr->write(iceP_p1);
        ostr->write(iceP_p2);
        ostr->writePendingValues();
        result->endWriteParams();
        result->invoke(iceC_Test_TestIntf_sequenceTest_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::SS
IceProxy::Test::TestIntf::end_sequenceTest(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_sequenceTest_name);
    ::Test::SS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    istr->readPendingValues();
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_dictionaryTest(const ::Test::BDict& iceP_bin, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_dictionaryTest_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_dictionaryTest_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_dictionaryTest_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::SlicedFormat);
        ostr->write(iceP_bin);
        ostr->writePendingValues();
        result->endWriteParams();
        result->invoke(iceC_Test_TestIntf_dictionaryTest_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::BDict
IceProxy::Test::TestIntf::end_dictionaryTest(::Test::BDict& iceP_bout, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_dictionaryTest_name);
    ::Test::BDict ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_bout);
    istr->read(ret);
    istr->readPendingValues();
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::TestIntf::_iceI_end_dictionaryTest(::Test::BDict& iceP_bout, ::Test::BDict& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_dictionaryTest_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_bout);
    istr->read(ret);
    istr->readPendingValues();
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_exchangePBase(const ::Test::PBasePtr& iceP_pb, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_exchangePBase_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_exchangePBase_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_exchangePBase_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::SlicedFormat);
        ostr->write(iceP_pb);
        ostr->writePendingValues();
        result->endWriteParams();
        result->invoke(iceC_Test_TestIntf_exchangePBase_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::PBasePtr
IceProxy::Test::TestIntf::end_exchangePBase(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_exchangePBase_name);
    ::Test::PBasePtr ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    istr->readPendingValues();
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_PBSUnknownAsPreserved(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_PBSUnknownAsPreserved_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_PBSUnknownAsPreserved_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_PBSUnknownAsPreserved_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Test_TestIntf_PBSUnknownAsPreserved_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::PreservedPtr
IceProxy::Test::TestIntf::end_PBSUnknownAsPreserved(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_PBSUnknownAsPreserved_name);
    ::Test::PreservedPtr ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    istr->readPendingValues();
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_checkPBSUnknown(const ::Test::PreservedPtr& iceP_p, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_checkPBSUnknown_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_checkPBSUnknown_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::SlicedFormat);
        ostr->write(iceP_p);
        ostr->writePendingValues();
        result->endWriteParams();
        result->invoke(iceC_Test_TestIntf_checkPBSUnknown_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Test::TestIntf::end_checkPBSUnknown(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_Test_TestIntf_checkPBSUnknown_name);
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_PBSUnknownAsPreservedWithGraph(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_PBSUnknownAsPreservedWithGraph_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_PBSUnknownAsPreservedWithGraph_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_PBSUnknownAsPreservedWithGraph_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Test_TestIntf_PBSUnknownAsPreservedWithGraph_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::PreservedPtr
IceProxy::Test::TestIntf::end_PBSUnknownAsPreservedWithGraph(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_PBSUnknownAsPreservedWithGraph_name);
    ::Test::PreservedPtr ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    istr->readPendingValues();
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_checkPBSUnknownWithGraph(const ::Test::PreservedPtr& iceP_p, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_checkPBSUnknownWithGraph_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_checkPBSUnknownWithGraph_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::SlicedFormat);
        ostr->write(iceP_p);
        ostr->writePendingValues();
        result->endWriteParams();
        result->invoke(iceC_Test_TestIntf_checkPBSUnknownWithGraph_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Test::TestIntf::end_checkPBSUnknownWithGraph(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_Test_TestIntf_checkPBSUnknownWithGraph_name);
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_PBSUnknown2AsPreservedWithGraph(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_PBSUnknown2AsPreservedWithGraph_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_PBSUnknown2AsPreservedWithGraph_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_PBSUnknown2AsPreservedWithGraph_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Test_TestIntf_PBSUnknown2AsPreservedWithGraph_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::PreservedPtr
IceProxy::Test::TestIntf::end_PBSUnknown2AsPreservedWithGraph(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_PBSUnknown2AsPreservedWithGraph_name);
    ::Test::PreservedPtr ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    istr->readPendingValues();
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_checkPBSUnknown2WithGraph(const ::Test::PreservedPtr& iceP_p, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_checkPBSUnknown2WithGraph_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_checkPBSUnknown2WithGraph_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::SlicedFormat);
        ostr->write(iceP_p);
        ostr->writePendingValues();
        result->endWriteParams();
        result->invoke(iceC_Test_TestIntf_checkPBSUnknown2WithGraph_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Test::TestIntf::end_checkPBSUnknown2WithGraph(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_Test_TestIntf_checkPBSUnknown2WithGraph_name);
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_exchangePNode(const ::Test::PNodePtr& iceP_pn, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_exchangePNode_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_exchangePNode_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_exchangePNode_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::SlicedFormat);
        ostr->write(iceP_pn);
        ostr->writePendingValues();
        result->endWriteParams();
        result->invoke(iceC_Test_TestIntf_exchangePNode_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::PNodePtr
IceProxy::Test::TestIntf::end_exchangePNode(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_exchangePNode_name);
    ::Test::PNodePtr ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    istr->readPendingValues();
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_throwBaseAsBase(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_throwBaseAsBase_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_throwBaseAsBase_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_throwBaseAsBase_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Test_TestIntf_throwBaseAsBase_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Test::TestIntf::end_throwBaseAsBase(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_throwBaseAsBase_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Test::BaseException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    result->_readEmptyParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_throwDerivedAsBase(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_throwDerivedAsBase_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_throwDerivedAsBase_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_throwDerivedAsBase_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Test_TestIntf_throwDerivedAsBase_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Test::TestIntf::end_throwDerivedAsBase(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_throwDerivedAsBase_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Test::BaseException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    result->_readEmptyParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_throwDerivedAsDerived(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_throwDerivedAsDerived_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_throwDerivedAsDerived_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_throwDerivedAsDerived_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Test_TestIntf_throwDerivedAsDerived_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Test::TestIntf::end_throwDerivedAsDerived(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_throwDerivedAsDerived_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Test::DerivedException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    result->_readEmptyParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_throwUnknownDerivedAsBase(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_throwUnknownDerivedAsBase_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_throwUnknownDerivedAsBase_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_throwUnknownDerivedAsBase_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Test_TestIntf_throwUnknownDerivedAsBase_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Test::TestIntf::end_throwUnknownDerivedAsBase(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_throwUnknownDerivedAsBase_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Test::BaseException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    result->_readEmptyParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_throwPreservedException(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_throwPreservedException_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_throwPreservedException_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_throwPreservedException_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Test_TestIntf_throwPreservedException_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Test::TestIntf::end_throwPreservedException(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_throwPreservedException_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Test::PreservedException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    result->_readEmptyParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_useForward(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_useForward_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_useForward_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_useForward_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Test_TestIntf_useForward_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Test::TestIntf::end_useForward(::Test::ForwardPtr& iceP_f, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_useForward_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_f);
    istr->readPendingValues();
    result->_endReadParams();
}

void IceProxy::Test::TestIntf::_iceI_end_useForward(::Test::ForwardPtr& iceP_f, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_useForward_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_f);
    istr->readPendingValues();
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_shutdown(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_shutdown_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_shutdown_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Test_TestIntf_shutdown_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Test::TestIntf::end_shutdown(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_Test_TestIntf_shutdown_name);
}

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::Test::TestIntf::_newInstance() const
{
    return new TestIntf;
}
/// \endcond

const ::std::string&
IceProxy::Test::TestIntf::ice_staticId()
{
    return ::Test::TestIntf::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(Hidden* p) { return p; }

void
::IceProxy::Test::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< Hidden>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new Hidden;
        v->_copyFrom(proxy);
    }
}
/// \endcond

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::Test::Hidden::_newInstance() const
{
    return new Hidden;
}
/// \endcond

const ::std::string&
IceProxy::Test::Hidden::ice_staticId()
{
    return ::Test::Hidden::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(Forward* p) { return p; }

void
::IceProxy::Test::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< Forward>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new Forward;
        v->_copyFrom(proxy);
    }
}
/// \endcond

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::Test::Forward::_newInstance() const
{
    return new Forward;
}
/// \endcond

const ::std::string&
IceProxy::Test::Forward::ice_staticId()
{
    return ::Test::Forward::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(D3* p) { return p; }

void
::IceProxy::Test::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< D3>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new D3;
        v->_copyFrom(proxy);
    }
}
/// \endcond

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::Test::D3::_newInstance() const
{
    return new D3;
}
/// \endcond

const ::std::string&
IceProxy::Test::D3::ice_staticId()
{
    return ::Test::D3::ice_staticId();
}

Test::SBase::~SBase()
{
}

/// \cond INTERNAL
::Ice::Object* Test::upCast(SBase* p) { return p; }

/// \endcond
::Ice::ObjectPtr
Test::SBase::ice_clone() const
{
    ::Ice::Object* p = new SBase(*this);
    return p;
}

namespace
{
const ::std::string iceC_Test_SBase_ids[2] =
{
    "::Ice::Object",
    "::Test::SBase"
};

}

bool
Test::SBase::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_SBase_ids, iceC_Test_SBase_ids + 2, s);
}

::std::vector< ::std::string>
Test::SBase::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Test_SBase_ids[0], &iceC_Test_SBase_ids[2]);
}

const ::std::string&
Test::SBase::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::SBase::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::Test::SBase";
    return typeId;
#else
    return iceC_Test_SBase_ids[1];
#endif
}

/// \cond STREAM
void
Test::SBase::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< SBase, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Test::SBase::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< SBase, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

namespace
{
const ::IceInternal::DefaultValueFactoryInit< ::Test::SBase> iceC_Test_SBase_init("::Test::SBase");
}

::Ice::ValueFactoryPtr
Test::SBase::ice_factory()
{
    return ::IceInternal::factoryTable->getValueFactory(::Test::SBase::ice_staticId());
}

/// \cond INTERNAL
void
Test::_icePatchObjectPtr(SBasePtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = SBasePtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(SBase::ice_staticId(), v);
    }
}
/// \endcond

Test::SBSKnownDerived::~SBSKnownDerived()
{
}

/// \cond INTERNAL
::Ice::Object* Test::upCast(SBSKnownDerived* p) { return p; }

/// \endcond
::Ice::ObjectPtr
Test::SBSKnownDerived::ice_clone() const
{
    ::Ice::Object* p = new SBSKnownDerived(*this);
    return p;
}

namespace
{
const ::std::string iceC_Test_SBSKnownDerived_ids[3] =
{
    "::Ice::Object",
    "::Test::SBSKnownDerived",
    "::Test::SBase"
};

}

bool
Test::SBSKnownDerived::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_SBSKnownDerived_ids, iceC_Test_SBSKnownDerived_ids + 3, s);
}

::std::vector< ::std::string>
Test::SBSKnownDerived::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Test_SBSKnownDerived_ids[0], &iceC_Test_SBSKnownDerived_ids[3]);
}

const ::std::string&
Test::SBSKnownDerived::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::SBSKnownDerived::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::Test::SBSKnownDerived";
    return typeId;
#else
    return iceC_Test_SBSKnownDerived_ids[1];
#endif
}

/// \cond STREAM
void
Test::SBSKnownDerived::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, false);
    ::Ice::StreamWriter< SBSKnownDerived, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
    SBase::_iceWriteImpl(ostr);
}

void
Test::SBSKnownDerived::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< SBSKnownDerived, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
    SBase::_iceReadImpl(istr);
}
/// \endcond

namespace
{
const ::IceInternal::DefaultValueFactoryInit< ::Test::SBSKnownDerived> iceC_Test_SBSKnownDerived_init("::Test::SBSKnownDerived");
}

::Ice::ValueFactoryPtr
Test::SBSKnownDerived::ice_factory()
{
    return ::IceInternal::factoryTable->getValueFactory(::Test::SBSKnownDerived::ice_staticId());
}

/// \cond INTERNAL
void
Test::_icePatchObjectPtr(SBSKnownDerivedPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = SBSKnownDerivedPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(SBSKnownDerived::ice_staticId(), v);
    }
}
/// \endcond

Test::B::~B()
{
}

/// \cond INTERNAL
::Ice::Object* Test::upCast(B* p) { return p; }

/// \endcond

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4589)
#endif
::Ice::ObjectPtr
Test::B::ice_clone() const
{
    ::Ice::Object* p = new B(*this);
    return p;
}
#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

namespace
{
const ::std::string iceC_Test_B_ids[2] =
{
    "::Ice::Object",
    "::Test::B"
};

}

bool
Test::B::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_B_ids, iceC_Test_B_ids + 2, s);
}

::std::vector< ::std::string>
Test::B::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Test_B_ids[0], &iceC_Test_B_ids[2]);
}

const ::std::string&
Test::B::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::B::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::Test::B";
    return typeId;
#else
    return iceC_Test_B_ids[1];
#endif
}

void
Test::B::_iceGcVisitMembers(::IceInternal::GCVisitor& v_)
{
    if(pb)
    {
        if((::Test::upCast(pb.get())->_iceGcVisit(v_)))
        {
            pb = 0;
        }
    }
}

/// \cond STREAM
void
Test::B::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< B, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Test::B::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< B, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

namespace
{
const ::IceInternal::DefaultValueFactoryInit< ::Test::B> iceC_Test_B_init("::Test::B");
}

::Ice::ValueFactoryPtr
Test::B::ice_factory()
{
    return ::IceInternal::factoryTable->getValueFactory(::Test::B::ice_staticId());
}

/// \cond INTERNAL
void
Test::_icePatchObjectPtr(BPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = BPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(B::ice_staticId(), v);
    }
}
/// \endcond

Test::D1::~D1()
{
}

/// \cond INTERNAL
::Ice::Object* Test::upCast(D1* p) { return p; }

/// \endcond
::Ice::ObjectPtr
Test::D1::ice_clone() const
{
    ::Ice::Object* p = new D1(*this);
    return p;
}

namespace
{
const ::std::string iceC_Test_D1_ids[3] =
{
    "::Ice::Object",
    "::Test::B",
    "::Test::D1"
};

}

bool
Test::D1::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_D1_ids, iceC_Test_D1_ids + 3, s);
}

::std::vector< ::std::string>
Test::D1::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Test_D1_ids[0], &iceC_Test_D1_ids[3]);
}

const ::std::string&
Test::D1::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::D1::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::Test::D1";
    return typeId;
#else
    return iceC_Test_D1_ids[2];
#endif
}

void
Test::D1::_iceGcVisitMembers(::IceInternal::GCVisitor& v_)
{
    B::_iceGcVisitMembers(v_);
    if(pd1)
    {
        if((::Test::upCast(pd1.get())->_iceGcVisit(v_)))
        {
            pd1 = 0;
        }
    }
}

/// \cond STREAM
void
Test::D1::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, false);
    ::Ice::StreamWriter< D1, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
    B::_iceWriteImpl(ostr);
}

void
Test::D1::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< D1, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
    B::_iceReadImpl(istr);
}
/// \endcond

namespace
{
const ::IceInternal::DefaultValueFactoryInit< ::Test::D1> iceC_Test_D1_init("::Test::D1");
}

::Ice::ValueFactoryPtr
Test::D1::ice_factory()
{
    return ::IceInternal::factoryTable->getValueFactory(::Test::D1::ice_staticId());
}

/// \cond INTERNAL
void
Test::_icePatchObjectPtr(D1Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = D1Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(D1::ice_staticId(), v);
    }
}
/// \endcond

Test::SS1::~SS1()
{
}

/// \cond INTERNAL
::Ice::Object* Test::upCast(SS1* p) { return p; }

/// \endcond

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4589)
#endif
::Ice::ObjectPtr
Test::SS1::ice_clone() const
{
    ::Ice::Object* p = new SS1(*this);
    return p;
}
#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

namespace
{
const ::std::string iceC_Test_SS1_ids[2] =
{
    "::Ice::Object",
    "::Test::SS1"
};

}

bool
Test::SS1::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_SS1_ids, iceC_Test_SS1_ids + 2, s);
}

::std::vector< ::std::string>
Test::SS1::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Test_SS1_ids[0], &iceC_Test_SS1_ids[2]);
}

const ::std::string&
Test::SS1::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::SS1::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::Test::SS1";
    return typeId;
#else
    return iceC_Test_SS1_ids[1];
#endif
}

void
Test::SS1::_iceGcVisitMembers(::IceInternal::GCVisitor& v_)
{
    {
        for(::Test::BSeq::iterator _i0 = s.begin(); _i0 != s.end(); ++_i0)
        {
            if((*_i0))
            {
                if((::Test::upCast((*_i0).get())->_iceGcVisit(v_)))
                {
                    (*_i0) = 0;
                }
            }
        }
    }
}

/// \cond STREAM
void
Test::SS1::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< SS1, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Test::SS1::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< SS1, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

namespace
{
const ::IceInternal::DefaultValueFactoryInit< ::Test::SS1> iceC_Test_SS1_init("::Test::SS1");
}

::Ice::ValueFactoryPtr
Test::SS1::ice_factory()
{
    return ::IceInternal::factoryTable->getValueFactory(::Test::SS1::ice_staticId());
}

/// \cond INTERNAL
void
Test::_icePatchObjectPtr(SS1Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = SS1Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(SS1::ice_staticId(), v);
    }
}
/// \endcond

Test::SS2::~SS2()
{
}

/// \cond INTERNAL
::Ice::Object* Test::upCast(SS2* p) { return p; }

/// \endcond

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4589)
#endif
::Ice::ObjectPtr
Test::SS2::ice_clone() const
{
    ::Ice::Object* p = new SS2(*this);
    return p;
}
#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

namespace
{
const ::std::string iceC_Test_SS2_ids[2] =
{
    "::Ice::Object",
    "::Test::SS2"
};

}

bool
Test::SS2::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_SS2_ids, iceC_Test_SS2_ids + 2, s);
}

::std::vector< ::std::string>
Test::SS2::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Test_SS2_ids[0], &iceC_Test_SS2_ids[2]);
}

const ::std::string&
Test::SS2::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::SS2::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::Test::SS2";
    return typeId;
#else
    return iceC_Test_SS2_ids[1];
#endif
}

void
Test::SS2::_iceGcVisitMembers(::IceInternal::GCVisitor& v_)
{
    {
        for(::Test::BSeq::iterator _i0 = s.begin(); _i0 != s.end(); ++_i0)
        {
            if((*_i0))
            {
                if((::Test::upCast((*_i0).get())->_iceGcVisit(v_)))
                {
                    (*_i0) = 0;
                }
            }
        }
    }
}

/// \cond STREAM
void
Test::SS2::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< SS2, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Test::SS2::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< SS2, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

namespace
{
const ::IceInternal::DefaultValueFactoryInit< ::Test::SS2> iceC_Test_SS2_init("::Test::SS2");
}

::Ice::ValueFactoryPtr
Test::SS2::ice_factory()
{
    return ::IceInternal::factoryTable->getValueFactory(::Test::SS2::ice_staticId());
}

/// \cond INTERNAL
void
Test::_icePatchObjectPtr(SS2Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = SS2Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(SS2::ice_staticId(), v);
    }
}
/// \endcond

Test::PBase::~PBase()
{
}

/// \cond INTERNAL
::Ice::Object* Test::upCast(PBase* p) { return p; }

/// \endcond
::Ice::ObjectPtr
Test::PBase::ice_clone() const
{
    ::Ice::Object* p = new PBase(*this);
    return p;
}

namespace
{
const ::std::string iceC_Test_PBase_ids[2] =
{
    "::Ice::Object",
    "::Test::PBase"
};

}

bool
Test::PBase::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_PBase_ids, iceC_Test_PBase_ids + 2, s);
}

::std::vector< ::std::string>
Test::PBase::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Test_PBase_ids[0], &iceC_Test_PBase_ids[2]);
}

const ::std::string&
Test::PBase::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::PBase::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::Test::PBase";
    return typeId;
#else
    return iceC_Test_PBase_ids[1];
#endif
}

/// \cond STREAM
void
Test::PBase::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< PBase, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Test::PBase::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< PBase, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

namespace
{
const ::IceInternal::DefaultValueFactoryInit< ::Test::PBase> iceC_Test_PBase_init("::Test::PBase");
}

::Ice::ValueFactoryPtr
Test::PBase::ice_factory()
{
    return ::IceInternal::factoryTable->getValueFactory(::Test::PBase::ice_staticId());
}

/// \cond INTERNAL
void
Test::_icePatchObjectPtr(PBasePtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = PBasePtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(PBase::ice_staticId(), v);
    }
}
/// \endcond

Test::Preserved::~Preserved()
{
}

/// \cond INTERNAL
::Ice::Object* Test::upCast(Preserved* p) { return p; }

/// \endcond

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4589)
#endif
::Ice::ObjectPtr
Test::Preserved::ice_clone() const
{
    ::Ice::Object* p = new Preserved(*this);
    return p;
}
#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

namespace
{
const ::std::string iceC_Test_Preserved_ids[3] =
{
    "::Ice::Object",
    "::Test::PBase",
    "::Test::Preserved"
};

}

bool
Test::Preserved::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_Preserved_ids, iceC_Test_Preserved_ids + 3, s);
}

::std::vector< ::std::string>
Test::Preserved::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Test_Preserved_ids[0], &iceC_Test_Preserved_ids[3]);
}

const ::std::string&
Test::Preserved::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::Preserved::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::Test::Preserved";
    return typeId;
#else
    return iceC_Test_Preserved_ids[2];
#endif
}

void
Test::Preserved::_iceGcVisitMembers(::IceInternal::GCVisitor& v_)
{
    if(_iceSlicedData)
    {
        _iceSlicedData->_iceGcVisitMembers(v_);
    }
}

::Ice::SlicedDataPtr
Test::Preserved::ice_getSlicedData() const
{
    return _iceSlicedData;
}

void
Test::Preserved::_iceWrite(::Ice::OutputStream*ostr) const
{
    ostr->startValue(_iceSlicedData);
    _iceWriteImpl(ostr);
    ostr->endValue();
}

void
Test::Preserved::_iceRead(::Ice::InputStream* istr)
{
    istr->startValue();
    _iceReadImpl(istr);
    _iceSlicedData = istr->endValue(true);
}

/// \cond STREAM
void
Test::Preserved::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, false);
    ::Ice::StreamWriter< Preserved, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
    PBase::_iceWriteImpl(ostr);
}

void
Test::Preserved::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< Preserved, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
    PBase::_iceReadImpl(istr);
}
/// \endcond

namespace
{
const ::IceInternal::DefaultValueFactoryInit< ::Test::Preserved> iceC_Test_Preserved_init("::Test::Preserved");
}

::Ice::ValueFactoryPtr
Test::Preserved::ice_factory()
{
    return ::IceInternal::factoryTable->getValueFactory(::Test::Preserved::ice_staticId());
}

/// \cond INTERNAL
void
Test::_icePatchObjectPtr(PreservedPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = PreservedPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(Preserved::ice_staticId(), v);
    }
}
/// \endcond

Test::PDerived::~PDerived()
{
}

/// \cond INTERNAL
::Ice::Object* Test::upCast(PDerived* p) { return p; }

/// \endcond

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4589)
#endif
::Ice::ObjectPtr
Test::PDerived::ice_clone() const
{
    ::Ice::Object* p = new PDerived(*this);
    return p;
}
#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

namespace
{
const ::std::string iceC_Test_PDerived_ids[4] =
{
    "::Ice::Object",
    "::Test::PBase",
    "::Test::PDerived",
    "::Test::Preserved"
};

}

bool
Test::PDerived::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_PDerived_ids, iceC_Test_PDerived_ids + 4, s);
}

::std::vector< ::std::string>
Test::PDerived::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Test_PDerived_ids[0], &iceC_Test_PDerived_ids[4]);
}

const ::std::string&
Test::PDerived::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::PDerived::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::Test::PDerived";
    return typeId;
#else
    return iceC_Test_PDerived_ids[2];
#endif
}

void
Test::PDerived::_iceGcVisitMembers(::IceInternal::GCVisitor& v_)
{
    Preserved::_iceGcVisitMembers(v_);
    if(pb)
    {
        if((::Test::upCast(pb.get())->_iceGcVisit(v_)))
        {
            pb = 0;
        }
    }
}

/// \cond STREAM
void
Test::PDerived::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, false);
    ::Ice::StreamWriter< PDerived, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
    Preserved::_iceWriteImpl(ostr);
}

void
Test::PDerived::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< PDerived, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
    Preserved::_iceReadImpl(istr);
}
/// \endcond

namespace
{
const ::IceInternal::DefaultValueFactoryInit< ::Test::PDerived> iceC_Test_PDerived_init("::Test::PDerived");
}

::Ice::ValueFactoryPtr
Test::PDerived::ice_factory()
{
    return ::IceInternal::factoryTable->getValueFactory(::Test::PDerived::ice_staticId());
}

/// \cond INTERNAL
void
Test::_icePatchObjectPtr(PDerivedPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = PDerivedPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(PDerived::ice_staticId(), v);
    }
}
/// \endcond

Test::CompactPDerived::~CompactPDerived()
{
}

/// \cond INTERNAL
::Ice::Object* Test::upCast(CompactPDerived* p) { return p; }

/// \endcond

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4589)
#endif
::Ice::ObjectPtr
Test::CompactPDerived::ice_clone() const
{
    ::Ice::Object* p = new CompactPDerived(*this);
    return p;
}
#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

namespace
{
const ::std::string iceC_Test_CompactPDerived_ids[4] =
{
    "::Ice::Object",
    "::Test::CompactPDerived",
    "::Test::PBase",
    "::Test::Preserved"
};

}

bool
Test::CompactPDerived::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_CompactPDerived_ids, iceC_Test_CompactPDerived_ids + 4, s);
}

::std::vector< ::std::string>
Test::CompactPDerived::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Test_CompactPDerived_ids[0], &iceC_Test_CompactPDerived_ids[4]);
}

const ::std::string&
Test::CompactPDerived::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::CompactPDerived::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::Test::CompactPDerived";
    return typeId;
#else
    return iceC_Test_CompactPDerived_ids[1];
#endif
}

void
Test::CompactPDerived::_iceGcVisitMembers(::IceInternal::GCVisitor& v_)
{
    Preserved::_iceGcVisitMembers(v_);
    if(pb)
    {
        if((::Test::upCast(pb.get())->_iceGcVisit(v_)))
        {
            pb = 0;
        }
    }
}

/// \cond STREAM
void
Test::CompactPDerived::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), 56, false);
    ::Ice::StreamWriter< CompactPDerived, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
    Preserved::_iceWriteImpl(ostr);
}

void
Test::CompactPDerived::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< CompactPDerived, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
    Preserved::_iceReadImpl(istr);
}
/// \endcond

namespace
{
const ::IceInternal::DefaultValueFactoryInit< ::Test::CompactPDerived> iceC_Test_CompactPDerived_init("::Test::CompactPDerived");
const ::IceInternal::CompactIdInit iceC_Test_CompactPDerived_compactIdInit("::Test::CompactPDerived", 56);
}

::Ice::ValueFactoryPtr
Test::CompactPDerived::ice_factory()
{
    return ::IceInternal::factoryTable->getValueFactory(::Test::CompactPDerived::ice_staticId());
}

/// \cond INTERNAL
void
Test::_icePatchObjectPtr(CompactPDerivedPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = CompactPDerivedPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(CompactPDerived::ice_staticId(), v);
    }
}
/// \endcond

Test::PNode::~PNode()
{
}

/// \cond INTERNAL
::Ice::Object* Test::upCast(PNode* p) { return p; }

/// \endcond

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4589)
#endif
::Ice::ObjectPtr
Test::PNode::ice_clone() const
{
    ::Ice::Object* p = new PNode(*this);
    return p;
}
#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

namespace
{
const ::std::string iceC_Test_PNode_ids[2] =
{
    "::Ice::Object",
    "::Test::PNode"
};

}

bool
Test::PNode::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_PNode_ids, iceC_Test_PNode_ids + 2, s);
}

::std::vector< ::std::string>
Test::PNode::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Test_PNode_ids[0], &iceC_Test_PNode_ids[2]);
}

const ::std::string&
Test::PNode::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::PNode::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::Test::PNode";
    return typeId;
#else
    return iceC_Test_PNode_ids[1];
#endif
}

void
Test::PNode::_iceGcVisitMembers(::IceInternal::GCVisitor& v_)
{
    if(_iceSlicedData)
    {
        _iceSlicedData->_iceGcVisitMembers(v_);
    }
    if(next)
    {
        if((::Test::upCast(next.get())->_iceGcVisit(v_)))
        {
            next = 0;
        }
    }
}

::Ice::SlicedDataPtr
Test::PNode::ice_getSlicedData() const
{
    return _iceSlicedData;
}

void
Test::PNode::_iceWrite(::Ice::OutputStream*ostr) const
{
    ostr->startValue(_iceSlicedData);
    _iceWriteImpl(ostr);
    ostr->endValue();
}

void
Test::PNode::_iceRead(::Ice::InputStream* istr)
{
    istr->startValue();
    _iceReadImpl(istr);
    _iceSlicedData = istr->endValue(true);
}

/// \cond STREAM
void
Test::PNode::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< PNode, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Test::PNode::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< PNode, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

namespace
{
const ::IceInternal::DefaultValueFactoryInit< ::Test::PNode> iceC_Test_PNode_init("::Test::PNode");
}

::Ice::ValueFactoryPtr
Test::PNode::ice_factory()
{
    return ::IceInternal::factoryTable->getValueFactory(::Test::PNode::ice_staticId());
}

/// \cond INTERNAL
void
Test::_icePatchObjectPtr(PNodePtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = PNodePtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(PNode::ice_staticId(), v);
    }
}
/// \endcond

Test::PCUnknown::~PCUnknown()
{
}

/// \cond INTERNAL
::Ice::Object* Test::upCast(PCUnknown* p) { return p; }

/// \endcond

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4589)
#endif
::Ice::ObjectPtr
Test::PCUnknown::ice_clone() const
{
    ::Ice::Object* p = new PCUnknown(*this);
    return p;
}
#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

namespace
{
const ::std::string iceC_Test_PCUnknown_ids[3] =
{
    "::Ice::Object",
    "::Test::PBase",
    "::Test::PCUnknown"
};

}

bool
Test::PCUnknown::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_PCUnknown_ids, iceC_Test_PCUnknown_ids + 3, s);
}

::std::vector< ::std::string>
Test::PCUnknown::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Test_PCUnknown_ids[0], &iceC_Test_PCUnknown_ids[3]);
}

const ::std::string&
Test::PCUnknown::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::PCUnknown::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::Test::PCUnknown";
    return typeId;
#else
    return iceC_Test_PCUnknown_ids[2];
#endif
}

void
Test::PCUnknown::_iceGcVisitMembers(::IceInternal::GCVisitor& v_)
{
    if(_iceSlicedData)
    {
        _iceSlicedData->_iceGcVisitMembers(v_);
    }
}

::Ice::SlicedDataPtr
Test::PCUnknown::ice_getSlicedData() const
{
    return _iceSlicedData;
}

void
Test::PCUnknown::_iceWrite(::Ice::OutputStream*ostr) const
{
    ostr->startValue(_iceSlicedData);
    _iceWriteImpl(ostr);
    ostr->endValue();
}

void
Test::PCUnknown::_iceRead(::Ice::InputStream* istr)
{
    istr->startValue();
    _iceReadImpl(istr);
    _iceSlicedData = istr->endValue(true);
}

/// \cond STREAM
void
Test::PCUnknown::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, false);
    ::Ice::StreamWriter< PCUnknown, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
    PBase::_iceWriteImpl(ostr);
}

void
Test::PCUnknown::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< PCUnknown, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
    PBase::_iceReadImpl(istr);
}
/// \endcond

namespace
{
const ::IceInternal::DefaultValueFactoryInit< ::Test::PCUnknown> iceC_Test_PCUnknown_init("::Test::PCUnknown");
}

::Ice::ValueFactoryPtr
Test::PCUnknown::ice_factory()
{
    return ::IceInternal::factoryTable->getValueFactory(::Test::PCUnknown::ice_staticId());
}

/// \cond INTERNAL
void
Test::_icePatchObjectPtr(PCUnknownPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = PCUnknownPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(PCUnknown::ice_staticId(), v);
    }
}
/// \endcond

Test::PCDerived::~PCDerived()
{
}

/// \cond INTERNAL
::Ice::Object* Test::upCast(PCDerived* p) { return p; }

/// \endcond

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4589)
#endif
::Ice::ObjectPtr
Test::PCDerived::ice_clone() const
{
    ::Ice::Object* p = new PCDerived(*this);
    return p;
}
#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

namespace
{
const ::std::string iceC_Test_PCDerived_ids[5] =
{
    "::Ice::Object",
    "::Test::PBase",
    "::Test::PCDerived",
    "::Test::PDerived",
    "::Test::Preserved"
};

}

bool
Test::PCDerived::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_PCDerived_ids, iceC_Test_PCDerived_ids + 5, s);
}

::std::vector< ::std::string>
Test::PCDerived::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Test_PCDerived_ids[0], &iceC_Test_PCDerived_ids[5]);
}

const ::std::string&
Test::PCDerived::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::PCDerived::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::Test::PCDerived";
    return typeId;
#else
    return iceC_Test_PCDerived_ids[2];
#endif
}

void
Test::PCDerived::_iceGcVisitMembers(::IceInternal::GCVisitor& v_)
{
    PDerived::_iceGcVisitMembers(v_);
    {
        for(::Test::PBaseSeq::iterator _i0 = pbs.begin(); _i0 != pbs.end(); ++_i0)
        {
            if((*_i0))
            {
                if((::Test::upCast((*_i0).get())->_iceGcVisit(v_)))
                {
                    (*_i0) = 0;
                }
            }
        }
    }
}

/// \cond STREAM
void
Test::PCDerived::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, false);
    ::Ice::StreamWriter< PCDerived, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
    PDerived::_iceWriteImpl(ostr);
}

void
Test::PCDerived::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< PCDerived, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
    PDerived::_iceReadImpl(istr);
}
/// \endcond

namespace
{
const ::IceInternal::DefaultValueFactoryInit< ::Test::PCDerived> iceC_Test_PCDerived_init("::Test::PCDerived");
}

::Ice::ValueFactoryPtr
Test::PCDerived::ice_factory()
{
    return ::IceInternal::factoryTable->getValueFactory(::Test::PCDerived::ice_staticId());
}

/// \cond INTERNAL
void
Test::_icePatchObjectPtr(PCDerivedPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = PCDerivedPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(PCDerived::ice_staticId(), v);
    }
}
/// \endcond

Test::PCDerived2::~PCDerived2()
{
}

/// \cond INTERNAL
::Ice::Object* Test::upCast(PCDerived2* p) { return p; }

/// \endcond

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4589)
#endif
::Ice::ObjectPtr
Test::PCDerived2::ice_clone() const
{
    ::Ice::Object* p = new PCDerived2(*this);
    return p;
}
#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

namespace
{
const ::std::string iceC_Test_PCDerived2_ids[6] =
{
    "::Ice::Object",
    "::Test::PBase",
    "::Test::PCDerived",
    "::Test::PCDerived2",
    "::Test::PDerived",
    "::Test::Preserved"
};

}

bool
Test::PCDerived2::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_PCDerived2_ids, iceC_Test_PCDerived2_ids + 6, s);
}

::std::vector< ::std::string>
Test::PCDerived2::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Test_PCDerived2_ids[0], &iceC_Test_PCDerived2_ids[6]);
}

const ::std::string&
Test::PCDerived2::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::PCDerived2::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::Test::PCDerived2";
    return typeId;
#else
    return iceC_Test_PCDerived2_ids[3];
#endif
}

void
Test::PCDerived2::_iceGcVisitMembers(::IceInternal::GCVisitor& v_)
{
    PCDerived::_iceGcVisitMembers(v_);
}

/// \cond STREAM
void
Test::PCDerived2::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, false);
    ::Ice::StreamWriter< PCDerived2, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
    PCDerived::_iceWriteImpl(ostr);
}

void
Test::PCDerived2::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< PCDerived2, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
    PCDerived::_iceReadImpl(istr);
}
/// \endcond

namespace
{
const ::IceInternal::DefaultValueFactoryInit< ::Test::PCDerived2> iceC_Test_PCDerived2_init("::Test::PCDerived2");
}

::Ice::ValueFactoryPtr
Test::PCDerived2::ice_factory()
{
    return ::IceInternal::factoryTable->getValueFactory(::Test::PCDerived2::ice_staticId());
}

/// \cond INTERNAL
void
Test::_icePatchObjectPtr(PCDerived2Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = PCDerived2Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(PCDerived2::ice_staticId(), v);
    }
}
/// \endcond

Test::PCDerived3::~PCDerived3()
{
}

/// \cond INTERNAL
::Ice::Object* Test::upCast(PCDerived3* p) { return p; }

/// \endcond

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4589)
#endif
::Ice::ObjectPtr
Test::PCDerived3::ice_clone() const
{
    ::Ice::Object* p = new PCDerived3(*this);
    return p;
}
#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

namespace
{
const ::std::string iceC_Test_PCDerived3_ids[7] =
{
    "::Ice::Object",
    "::Test::PBase",
    "::Test::PCDerived",
    "::Test::PCDerived2",
    "::Test::PCDerived3",
    "::Test::PDerived",
    "::Test::Preserved"
};

}

bool
Test::PCDerived3::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_PCDerived3_ids, iceC_Test_PCDerived3_ids + 7, s);
}

::std::vector< ::std::string>
Test::PCDerived3::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Test_PCDerived3_ids[0], &iceC_Test_PCDerived3_ids[7]);
}

const ::std::string&
Test::PCDerived3::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::PCDerived3::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::Test::PCDerived3";
    return typeId;
#else
    return iceC_Test_PCDerived3_ids[4];
#endif
}

void
Test::PCDerived3::_iceGcVisitMembers(::IceInternal::GCVisitor& v_)
{
    PCDerived2::_iceGcVisitMembers(v_);
    if(pcd3)
    {
        if((pcd3.get())->_iceGcVisit(v_))
        {
            pcd3 = 0;
        }
    }
}

/// \cond STREAM
void
Test::PCDerived3::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, false);
    ::Ice::StreamWriter< PCDerived3, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
    PCDerived2::_iceWriteImpl(ostr);
}

void
Test::PCDerived3::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< PCDerived3, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
    PCDerived2::_iceReadImpl(istr);
}
/// \endcond

namespace
{
const ::IceInternal::DefaultValueFactoryInit< ::Test::PCDerived3> iceC_Test_PCDerived3_init("::Test::PCDerived3");
}

::Ice::ValueFactoryPtr
Test::PCDerived3::ice_factory()
{
    return ::IceInternal::factoryTable->getValueFactory(::Test::PCDerived3::ice_staticId());
}

/// \cond INTERNAL
void
Test::_icePatchObjectPtr(PCDerived3Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = PCDerived3Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(PCDerived3::ice_staticId(), v);
    }
}
/// \endcond

Test::CompactPCDerived::~CompactPCDerived()
{
}

/// \cond INTERNAL
::Ice::Object* Test::upCast(CompactPCDerived* p) { return p; }

/// \endcond

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4589)
#endif
::Ice::ObjectPtr
Test::CompactPCDerived::ice_clone() const
{
    ::Ice::Object* p = new CompactPCDerived(*this);
    return p;
}
#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

namespace
{
const ::std::string iceC_Test_CompactPCDerived_ids[5] =
{
    "::Ice::Object",
    "::Test::CompactPCDerived",
    "::Test::CompactPDerived",
    "::Test::PBase",
    "::Test::Preserved"
};

}

bool
Test::CompactPCDerived::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_CompactPCDerived_ids, iceC_Test_CompactPCDerived_ids + 5, s);
}

::std::vector< ::std::string>
Test::CompactPCDerived::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Test_CompactPCDerived_ids[0], &iceC_Test_CompactPCDerived_ids[5]);
}

const ::std::string&
Test::CompactPCDerived::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::CompactPCDerived::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::Test::CompactPCDerived";
    return typeId;
#else
    return iceC_Test_CompactPCDerived_ids[1];
#endif
}

void
Test::CompactPCDerived::_iceGcVisitMembers(::IceInternal::GCVisitor& v_)
{
    CompactPDerived::_iceGcVisitMembers(v_);
    {
        for(::Test::PBaseSeq::iterator _i0 = pbs.begin(); _i0 != pbs.end(); ++_i0)
        {
            if((*_i0))
            {
                if((::Test::upCast((*_i0).get())->_iceGcVisit(v_)))
                {
                    (*_i0) = 0;
                }
            }
        }
    }
}

/// \cond STREAM
void
Test::CompactPCDerived::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), 57, false);
    ::Ice::StreamWriter< CompactPCDerived, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
    CompactPDerived::_iceWriteImpl(ostr);
}

void
Test::CompactPCDerived::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< CompactPCDerived, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
    CompactPDerived::_iceReadImpl(istr);
}
/// \endcond

namespace
{
const ::IceInternal::DefaultValueFactoryInit< ::Test::CompactPCDerived> iceC_Test_CompactPCDerived_init("::Test::CompactPCDerived");
const ::IceInternal::CompactIdInit iceC_Test_CompactPCDerived_compactIdInit("::Test::CompactPCDerived", 57);
}

::Ice::ValueFactoryPtr
Test::CompactPCDerived::ice_factory()
{
    return ::IceInternal::factoryTable->getValueFactory(::Test::CompactPCDerived::ice_staticId());
}

/// \cond INTERNAL
void
Test::_icePatchObjectPtr(CompactPCDerivedPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = CompactPCDerivedPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(CompactPCDerived::ice_staticId(), v);
    }
}
/// \endcond

Test::TestIntf::~TestIntf()
{
}

/// \cond INTERNAL
::Ice::Object* Test::upCast(TestIntf* p) { return p; }

/// \endcond

namespace
{
const ::std::string iceC_Test_TestIntf_ids[2] =
{
    "::Ice::Object",
    "::Test::TestIntf"
};

}

bool
Test::TestIntf::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_TestIntf_ids, iceC_Test_TestIntf_ids + 2, s);
}

::std::vector< ::std::string>
Test::TestIntf::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Test_TestIntf_ids[0], &iceC_Test_TestIntf_ids[2]);
}

const ::std::string&
Test::TestIntf::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::TestIntf::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::Test::TestIntf";
    return typeId;
#else
    return iceC_Test_TestIntf_ids[1];
#endif
}

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_SBaseAsObject(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::SlicedFormat);
    ::Ice::ObjectPtr ret = this->SBaseAsObject(current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_SBaseAsSBase(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::SlicedFormat);
    SBasePtr ret = this->SBaseAsSBase(current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_SBSKnownDerivedAsSBase(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::SlicedFormat);
    SBasePtr ret = this->SBSKnownDerivedAsSBase(current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_SBSKnownDerivedAsSBSKnownDerived(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::SlicedFormat);
    SBSKnownDerivedPtr ret = this->SBSKnownDerivedAsSBSKnownDerived(current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_SBSUnknownDerivedAsSBase(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::SlicedFormat);
    SBasePtr ret = this->SBSUnknownDerivedAsSBase(current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_SBSUnknownDerivedAsSBaseCompact(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::CompactFormat);
    SBasePtr ret = this->SBSUnknownDerivedAsSBaseCompact(current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_SUnknownAsObject(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::SlicedFormat);
    ::Ice::ObjectPtr ret = this->SUnknownAsObject(current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_checkSUnknown(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::ObjectPtr iceP_o;
    istr->read(iceP_o);
    istr->readPendingValues();
    inS.endReadParams();
    inS.setFormat(::Ice::SlicedFormat);
    this->checkSUnknown(iceP_o, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_oneElementCycle(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::SlicedFormat);
    BPtr ret = this->oneElementCycle(current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_twoElementCycle(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::SlicedFormat);
    BPtr ret = this->twoElementCycle(current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_D1AsB(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::SlicedFormat);
    BPtr ret = this->D1AsB(current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_D1AsD1(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::SlicedFormat);
    D1Ptr ret = this->D1AsD1(current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_D2AsB(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::SlicedFormat);
    BPtr ret = this->D2AsB(current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_paramTest1(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::SlicedFormat);
    BPtr iceP_p1;
    BPtr iceP_p2;
    this->paramTest1(iceP_p1, iceP_p2, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_p1);
    ostr->write(iceP_p2);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_paramTest2(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::SlicedFormat);
    BPtr iceP_p2;
    BPtr iceP_p1;
    this->paramTest2(iceP_p2, iceP_p1, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_p2);
    ostr->write(iceP_p1);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_paramTest3(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::SlicedFormat);
    BPtr iceP_p1;
    BPtr iceP_p2;
    BPtr ret = this->paramTest3(iceP_p1, iceP_p2, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_p1);
    ostr->write(iceP_p2);
    ostr->write(ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_paramTest4(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::SlicedFormat);
    BPtr iceP_p;
    BPtr ret = this->paramTest4(iceP_p, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_p);
    ostr->write(ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_returnTest1(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::SlicedFormat);
    BPtr iceP_p1;
    BPtr iceP_p2;
    BPtr ret = this->returnTest1(iceP_p1, iceP_p2, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_p1);
    ostr->write(iceP_p2);
    ostr->write(ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_returnTest2(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::SlicedFormat);
    BPtr iceP_p2;
    BPtr iceP_p1;
    BPtr ret = this->returnTest2(iceP_p2, iceP_p1, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_p2);
    ostr->write(iceP_p1);
    ostr->write(ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_returnTest3(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    BPtr iceP_p1;
    BPtr iceP_p2;
    istr->read(iceP_p1);
    istr->read(iceP_p2);
    istr->readPendingValues();
    inS.endReadParams();
    inS.setFormat(::Ice::SlicedFormat);
    BPtr ret = this->returnTest3(iceP_p1, iceP_p2, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_sequenceTest(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    SS1Ptr iceP_p1;
    SS2Ptr iceP_p2;
    istr->read(iceP_p1);
    istr->read(iceP_p2);
    istr->readPendingValues();
    inS.endReadParams();
    inS.setFormat(::Ice::SlicedFormat);
    SS ret = this->sequenceTest(iceP_p1, iceP_p2, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_dictionaryTest(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    BDict iceP_bin;
    istr->read(iceP_bin);
    istr->readPendingValues();
    inS.endReadParams();
    inS.setFormat(::Ice::SlicedFormat);
    BDict iceP_bout;
    BDict ret = this->dictionaryTest(iceP_bin, iceP_bout, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_bout);
    ostr->write(ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_exchangePBase(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    PBasePtr iceP_pb;
    istr->read(iceP_pb);
    istr->readPendingValues();
    inS.endReadParams();
    inS.setFormat(::Ice::SlicedFormat);
    PBasePtr ret = this->exchangePBase(iceP_pb, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_PBSUnknownAsPreserved(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::SlicedFormat);
    PreservedPtr ret = this->PBSUnknownAsPreserved(current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_checkPBSUnknown(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    PreservedPtr iceP_p;
    istr->read(iceP_p);
    istr->readPendingValues();
    inS.endReadParams();
    inS.setFormat(::Ice::SlicedFormat);
    this->checkPBSUnknown(iceP_p, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_PBSUnknownAsPreservedWithGraph(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::SlicedFormat);
    PreservedPtr ret = this->PBSUnknownAsPreservedWithGraph(current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_checkPBSUnknownWithGraph(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    PreservedPtr iceP_p;
    istr->read(iceP_p);
    istr->readPendingValues();
    inS.endReadParams();
    inS.setFormat(::Ice::SlicedFormat);
    this->checkPBSUnknownWithGraph(iceP_p, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_PBSUnknown2AsPreservedWithGraph(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::SlicedFormat);
    PreservedPtr ret = this->PBSUnknown2AsPreservedWithGraph(current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_checkPBSUnknown2WithGraph(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    PreservedPtr iceP_p;
    istr->read(iceP_p);
    istr->readPendingValues();
    inS.endReadParams();
    inS.setFormat(::Ice::SlicedFormat);
    this->checkPBSUnknown2WithGraph(iceP_p, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_exchangePNode(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    PNodePtr iceP_pn;
    istr->read(iceP_pn);
    istr->readPendingValues();
    inS.endReadParams();
    inS.setFormat(::Ice::SlicedFormat);
    PNodePtr ret = this->exchangePNode(iceP_pn, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_throwBaseAsBase(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::SlicedFormat);
    this->throwBaseAsBase(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_throwDerivedAsBase(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::SlicedFormat);
    this->throwDerivedAsBase(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_throwDerivedAsDerived(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::SlicedFormat);
    this->throwDerivedAsDerived(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_throwUnknownDerivedAsBase(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::SlicedFormat);
    this->throwUnknownDerivedAsBase(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_throwPreservedException(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::SlicedFormat);
    this->throwPreservedException_async(new IceAsync::Test::AMD_TestIntf_throwPreservedException(inS), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_useForward(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::SlicedFormat);
    ForwardPtr iceP_f;
    this->useForward(iceP_f, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_f);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_shutdown(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::SlicedFormat);
    this->shutdown(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

namespace
{
const ::std::string iceC_Test_TestIntf_all[] =
{
    "D1AsB",
    "D1AsD1",
    "D2AsB",
    "PBSUnknown2AsPreservedWithGraph",
    "PBSUnknownAsPreserved",
    "PBSUnknownAsPreservedWithGraph",
    "SBSKnownDerivedAsSBSKnownDerived",
    "SBSKnownDerivedAsSBase",
    "SBSUnknownDerivedAsSBase",
    "SBSUnknownDerivedAsSBaseCompact",
    "SBaseAsObject",
    "SBaseAsSBase",
    "SUnknownAsObject",
    "checkPBSUnknown",
    "checkPBSUnknown2WithGraph",
    "checkPBSUnknownWithGraph",
    "checkSUnknown",
    "dictionaryTest",
    "exchangePBase",
    "exchangePNode",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "oneElementCycle",
    "paramTest1",
    "paramTest2",
    "paramTest3",
    "paramTest4",
    "returnTest1",
    "returnTest2",
    "returnTest3",
    "sequenceTest",
    "shutdown",
    "throwBaseAsBase",
    "throwDerivedAsBase",
    "throwDerivedAsDerived",
    "throwPreservedException",
    "throwUnknownDerivedAsBase",
    "twoElementCycle",
    "useForward"
};

}

/// \cond INTERNAL
bool
Test::TestIntf::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_Test_TestIntf_all, iceC_Test_TestIntf_all + 41, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_Test_TestIntf_all)
    {
        case 0:
        {
            return _iceD_D1AsB(in, current);
        }
        case 1:
        {
            return _iceD_D1AsD1(in, current);
        }
        case 2:
        {
            return _iceD_D2AsB(in, current);
        }
        case 3:
        {
            return _iceD_PBSUnknown2AsPreservedWithGraph(in, current);
        }
        case 4:
        {
            return _iceD_PBSUnknownAsPreserved(in, current);
        }
        case 5:
        {
            return _iceD_PBSUnknownAsPreservedWithGraph(in, current);
        }
        case 6:
        {
            return _iceD_SBSKnownDerivedAsSBSKnownDerived(in, current);
        }
        case 7:
        {
            return _iceD_SBSKnownDerivedAsSBase(in, current);
        }
        case 8:
        {
            return _iceD_SBSUnknownDerivedAsSBase(in, current);
        }
        case 9:
        {
            return _iceD_SBSUnknownDerivedAsSBaseCompact(in, current);
        }
        case 10:
        {
            return _iceD_SBaseAsObject(in, current);
        }
        case 11:
        {
            return _iceD_SBaseAsSBase(in, current);
        }
        case 12:
        {
            return _iceD_SUnknownAsObject(in, current);
        }
        case 13:
        {
            return _iceD_checkPBSUnknown(in, current);
        }
        case 14:
        {
            return _iceD_checkPBSUnknown2WithGraph(in, current);
        }
        case 15:
        {
            return _iceD_checkPBSUnknownWithGraph(in, current);
        }
        case 16:
        {
            return _iceD_checkSUnknown(in, current);
        }
        case 17:
        {
            return _iceD_dictionaryTest(in, current);
        }
        case 18:
        {
            return _iceD_exchangePBase(in, current);
        }
        case 19:
        {
            return _iceD_exchangePNode(in, current);
        }
        case 20:
        {
            return _iceD_ice_id(in, current);
        }
        case 21:
        {
            return _iceD_ice_ids(in, current);
        }
        case 22:
        {
            return _iceD_ice_isA(in, current);
        }
        case 23:
        {
            return _iceD_ice_ping(in, current);
        }
        case 24:
        {
            return _iceD_oneElementCycle(in, current);
        }
        case 25:
        {
            return _iceD_paramTest1(in, current);
        }
        case 26:
        {
            return _iceD_paramTest2(in, current);
        }
        case 27:
        {
            return _iceD_paramTest3(in, current);
        }
        case 28:
        {
            return _iceD_paramTest4(in, current);
        }
        case 29:
        {
            return _iceD_returnTest1(in, current);
        }
        case 30:
        {
            return _iceD_returnTest2(in, current);
        }
        case 31:
        {
            return _iceD_returnTest3(in, current);
        }
        case 32:
        {
            return _iceD_sequenceTest(in, current);
        }
        case 33:
        {
            return _iceD_shutdown(in, current);
        }
        case 34:
        {
            return _iceD_throwBaseAsBase(in, current);
        }
        case 35:
        {
            return _iceD_throwDerivedAsBase(in, current);
        }
        case 36:
        {
            return _iceD_throwDerivedAsDerived(in, current);
        }
        case 37:
        {
            return _iceD_throwPreservedException(in, current);
        }
        case 38:
        {
            return _iceD_throwUnknownDerivedAsBase(in, current);
        }
        case 39:
        {
            return _iceD_twoElementCycle(in, current);
        }
        case 40:
        {
            return _iceD_useForward(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

/// \cond STREAM
void
Test::TestIntf::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< TestIntf, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Test::TestIntf::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< TestIntf, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

/// \cond INTERNAL
void
Test::_icePatchObjectPtr(TestIntfPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = TestIntfPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(TestIntf::ice_staticId(), v);
    }
}
/// \endcond

Test::Hidden::~Hidden()
{
}

/// \cond INTERNAL
::Ice::Object* Test::upCast(Hidden* p) { return p; }

/// \endcond

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4589)
#endif
::Ice::ObjectPtr
Test::Hidden::ice_clone() const
{
    ::Ice::Object* p = new Hidden(*this);
    return p;
}
#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

namespace
{
const ::std::string iceC_Test_Hidden_ids[2] =
{
    "::Ice::Object",
    "::Test::Hidden"
};

}

bool
Test::Hidden::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_Hidden_ids, iceC_Test_Hidden_ids + 2, s);
}

::std::vector< ::std::string>
Test::Hidden::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Test_Hidden_ids[0], &iceC_Test_Hidden_ids[2]);
}

const ::std::string&
Test::Hidden::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::Hidden::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::Test::Hidden";
    return typeId;
#else
    return iceC_Test_Hidden_ids[1];
#endif
}

void
Test::Hidden::_iceGcVisitMembers(::IceInternal::GCVisitor& v_)
{
    if(f)
    {
        if((::Test::upCast(f.get())->_iceGcVisit(v_)))
        {
            f = 0;
        }
    }
}

/// \cond STREAM
void
Test::Hidden::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< Hidden, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Test::Hidden::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< Hidden, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

namespace
{
const ::IceInternal::DefaultValueFactoryInit< ::Test::Hidden> iceC_Test_Hidden_init("::Test::Hidden");
}

::Ice::ValueFactoryPtr
Test::Hidden::ice_factory()
{
    return ::IceInternal::factoryTable->getValueFactory(::Test::Hidden::ice_staticId());
}

/// \cond INTERNAL
void
Test::_icePatchObjectPtr(HiddenPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = HiddenPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(Hidden::ice_staticId(), v);
    }
}
/// \endcond

Test::Forward::~Forward()
{
}

/// \cond INTERNAL
::Ice::Object* Test::upCast(Forward* p) { return p; }

/// \endcond

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4589)
#endif
::Ice::ObjectPtr
Test::Forward::ice_clone() const
{
    ::Ice::Object* p = new Forward(*this);
    return p;
}
#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

namespace
{
const ::std::string iceC_Test_Forward_ids[2] =
{
    "::Ice::Object",
    "::Test::Forward"
};

}

bool
Test::Forward::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_Forward_ids, iceC_Test_Forward_ids + 2, s);
}

::std::vector< ::std::string>
Test::Forward::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Test_Forward_ids[0], &iceC_Test_Forward_ids[2]);
}

const ::std::string&
Test::Forward::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::Forward::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::Test::Forward";
    return typeId;
#else
    return iceC_Test_Forward_ids[1];
#endif
}

void
Test::Forward::_iceGcVisitMembers(::IceInternal::GCVisitor& v_)
{
    if(h)
    {
        if((::Test::upCast(h.get())->_iceGcVisit(v_)))
        {
            h = 0;
        }
    }
}

/// \cond STREAM
void
Test::Forward::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< Forward, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Test::Forward::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< Forward, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

namespace
{
const ::IceInternal::DefaultValueFactoryInit< ::Test::Forward> iceC_Test_Forward_init("::Test::Forward");
}

::Ice::ValueFactoryPtr
Test::Forward::ice_factory()
{
    return ::IceInternal::factoryTable->getValueFactory(::Test::Forward::ice_staticId());
}

/// \cond INTERNAL
void
Test::_icePatchObjectPtr(ForwardPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ForwardPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(Forward::ice_staticId(), v);
    }
}
/// \endcond

Test::D3::~D3()
{
}

/// \cond INTERNAL
::Ice::Object* Test::upCast(D3* p) { return p; }

/// \endcond
::Ice::ObjectPtr
Test::D3::ice_clone() const
{
    ::Ice::Object* p = new D3(*this);
    return p;
}

namespace
{
const ::std::string iceC_Test_D3_ids[3] =
{
    "::Ice::Object",
    "::Test::B",
    "::Test::D3"
};

}

bool
Test::D3::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_D3_ids, iceC_Test_D3_ids + 3, s);
}

::std::vector< ::std::string>
Test::D3::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Test_D3_ids[0], &iceC_Test_D3_ids[3]);
}

const ::std::string&
Test::D3::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::D3::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::Test::D3";
    return typeId;
#else
    return iceC_Test_D3_ids[2];
#endif
}

void
Test::D3::_iceGcVisitMembers(::IceInternal::GCVisitor& v_)
{
    B::_iceGcVisitMembers(v_);
    if(pd3)
    {
        if((::Test::upCast(pd3.get())->_iceGcVisit(v_)))
        {
            pd3 = 0;
        }
    }
}

/// \cond STREAM
void
Test::D3::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, false);
    ::Ice::StreamWriter< D3, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
    B::_iceWriteImpl(ostr);
}

void
Test::D3::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< D3, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
    B::_iceReadImpl(istr);
}
/// \endcond

namespace
{
const ::IceInternal::DefaultValueFactoryInit< ::Test::D3> iceC_Test_D3_init("::Test::D3");
}

::Ice::ValueFactoryPtr
Test::D3::ice_factory()
{
    return ::IceInternal::factoryTable->getValueFactory(::Test::D3::ice_staticId());
}

/// \cond INTERNAL
void
Test::_icePatchObjectPtr(D3Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = D3Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(D3::ice_staticId(), v);
    }
}
/// \endcond

namespace Ice
{
}

#endif
