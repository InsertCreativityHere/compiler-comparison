//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.7.10
//
// <auto-generated>
//
// Generated from file `SlicingObjectsTestServer.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __SlicingObjectsTestServer_h__
#define __SlicingObjectsTestServer_h__

#include <IceUtil/PushDisableWarnings.h>
#include <Ice/ProxyF.h>
#include <Ice/ObjectF.h>
#include <Ice/ValueF.h>
#include <Ice/Exception.h>
#include <Ice/LocalObject.h>
#include <Ice/StreamHelpers.h>
#include <Ice/Comparable.h>
#include <Ice/Proxy.h>
#include <Ice/Object.h>
#include <Ice/GCObject.h>
#include <Ice/Value.h>
#include <Ice/Incoming.h>
#include <Ice/IncomingAsync.h>
#include <Ice/FactoryTableInit.h>
#include <IceUtil/ScopedArray.h>
#include <Ice/Optional.h>
#include <Ice/ExceptionHelpers.h>
#include <Ice/SlicedDataF.h>
#include <IceUtil/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 307
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 >= 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 10
#       error Ice patch level mismatch!
#   endif
#endif

#ifdef ICE_CPP11_MAPPING // C++11 mapping

namespace Test
{

class SBase;
class SBSKnownDerived;
class B;
class D1;
class SS1;
class SS2;
class Forward;
class PBase;
class Preserved;
class PDerived;
class CompactPDerived;
class PNode;
class MyClass;
class PSUnknown;
class PSUnknown2;
class TestIntf;
class TestIntfPrx;
class Hidden;
class SBSUnknownDerived;
class SUnknown;
class D2;
class D4;

}

namespace Test
{

using BSeq = ::std::vector<::std::shared_ptr<B>>;

struct SS
{
    ::std::shared_ptr<::Test::SS1> c1;
    ::std::shared_ptr<::Test::SS2> c2;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::shared_ptr<::Test::SS1>&, const ::std::shared_ptr<::Test::SS2>&> ice_tuple() const
    {
        return std::tie(c1, c2);
    }
};

using BDict = ::std::map<int, ::std::shared_ptr<B>>;

class BaseException : public ::Ice::UserExceptionHelper<BaseException, ::Ice::UserException>
{
public:

    virtual ~BaseException();

    BaseException(const BaseException&) = default;

    BaseException() = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    BaseException(const ::std::string& sbe, const ::std::shared_ptr<B>& pb) :
        sbe(sbe),
        pb(pb)
    {
    }

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::std::shared_ptr<::Test::B>&> ice_tuple() const
    {
        return std::tie(sbe, pb);
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /// \cond STREAM
    virtual bool _usesClasses() const override;
    /// \endcond

    ::std::string sbe;
    ::std::shared_ptr<::Test::B> pb;
};

/// \cond INTERNAL
static BaseException _iceS_BaseException_init;
/// \endcond

class DerivedException : public ::Ice::UserExceptionHelper<DerivedException, BaseException>
{
public:

    virtual ~DerivedException();

    DerivedException(const DerivedException&) = default;

    DerivedException() = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    DerivedException(const ::std::string& sbe, const ::std::shared_ptr<B>& pb, const ::std::string& sde, const ::std::shared_ptr<D1>& pd1) :
        ::Ice::UserExceptionHelper<DerivedException, BaseException>(sbe, pb),
        sde(sde),
        pd1(pd1)
    {
    }

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::std::shared_ptr<::Test::B>&, const ::std::string&, const ::std::shared_ptr<::Test::D1>&> ice_tuple() const
    {
        return std::tie(sbe, pb, sde, pd1);
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::std::string sde;
    ::std::shared_ptr<::Test::D1> pd1;
};

using PBaseSeq = ::std::vector<::std::shared_ptr<PBase>>;

class PreservedException : public ::Ice::UserExceptionHelper<PreservedException, ::Ice::UserException>
{
public:

    virtual ~PreservedException();

    PreservedException(const PreservedException&) = default;

    PreservedException() = default;

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<> ice_tuple() const
    {
        return std::tie();
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /**
     * Obtains the SlicedData object created when an unknown exception type was marshaled
     * in the sliced format and the Ice run time sliced it to a known type.
     * @return The SlicedData object, or nil if the exception was not sliced or was not
     * marshaled in the sliced format.
     */
    virtual ::std::shared_ptr<::Ice::SlicedData> ice_getSlicedData() const override;

    /// \cond STREAM
    virtual void _write(::Ice::OutputStream*) const override;
    virtual void _read(::Ice::InputStream*) override;

    ::std::shared_ptr<::Ice::SlicedData> _slicedData;
    /// \endcond
};

class PSUnknownException : public ::Ice::UserExceptionHelper<PSUnknownException, PreservedException>
{
public:

    virtual ~PSUnknownException();

    PSUnknownException(const PSUnknownException&) = default;

    PSUnknownException() = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    PSUnknownException(const ::std::shared_ptr<PSUnknown2>& p) :
        ::Ice::UserExceptionHelper<PSUnknownException, PreservedException>(),
        p(p)
    {
    }

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::shared_ptr<::Test::PSUnknown2>&> ice_tuple() const
    {
        return std::tie(p);
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /// \cond STREAM
    virtual bool _usesClasses() const override;
    /// \endcond

    ::std::shared_ptr<::Test::PSUnknown2> p;
};

class UnknownDerivedException : public ::Ice::UserExceptionHelper<UnknownDerivedException, BaseException>
{
public:

    virtual ~UnknownDerivedException();

    UnknownDerivedException(const UnknownDerivedException&) = default;

    UnknownDerivedException() = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    UnknownDerivedException(const ::std::string& sbe, const ::std::shared_ptr<B>& pb, const ::std::string& sude, const ::std::shared_ptr<D2>& pd2) :
        ::Ice::UserExceptionHelper<UnknownDerivedException, BaseException>(sbe, pb),
        sude(sude),
        pd2(pd2)
    {
    }

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::std::shared_ptr<::Test::B>&, const ::std::string&, const ::std::shared_ptr<::Test::D2>&> ice_tuple() const
    {
        return std::tie(sbe, pb, sude, pd2);
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::std::string sude;
    ::std::shared_ptr<::Test::D2> pd2;
};

using Ice::operator<;
using Ice::operator<=;
using Ice::operator>;
using Ice::operator>=;
using Ice::operator==;
using Ice::operator!=;

}

namespace Test
{

class TestIntf : public virtual ::Ice::Object
{
public:

    using ProxyType = TestIntfPrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual ::std::shared_ptr<::Ice::Value> SBaseAsObject(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_SBaseAsObject(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::std::shared_ptr<SBase> SBaseAsSBase(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_SBaseAsSBase(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::std::shared_ptr<SBase> SBSKnownDerivedAsSBase(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_SBSKnownDerivedAsSBase(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::std::shared_ptr<SBSKnownDerived> SBSKnownDerivedAsSBSKnownDerived(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_SBSKnownDerivedAsSBSKnownDerived(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::std::shared_ptr<SBase> SBSUnknownDerivedAsSBase(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_SBSUnknownDerivedAsSBase(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::std::shared_ptr<SBase> SBSUnknownDerivedAsSBaseCompact(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_SBSUnknownDerivedAsSBaseCompact(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::std::shared_ptr<::Ice::Value> SUnknownAsObject(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_SUnknownAsObject(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void checkSUnknown(::std::shared_ptr<::Ice::Value> o, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_checkSUnknown(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::std::shared_ptr<B> oneElementCycle(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_oneElementCycle(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::std::shared_ptr<B> twoElementCycle(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_twoElementCycle(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::std::shared_ptr<B> D1AsB(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_D1AsB(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::std::shared_ptr<D1> D1AsD1(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_D1AsD1(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::std::shared_ptr<B> D2AsB(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_D2AsB(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to paramTest1.
     */
    struct ParamTest1Result
    {
        ::std::shared_ptr<B> p1;
        ::std::shared_ptr<B> p2;
    };

    virtual void paramTest1(::std::shared_ptr<B>& p1, ::std::shared_ptr<B>& p2, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_paramTest1(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to paramTest2.
     */
    struct ParamTest2Result
    {
        ::std::shared_ptr<B> p2;
        ::std::shared_ptr<B> p1;
    };

    virtual void paramTest2(::std::shared_ptr<B>& p2, ::std::shared_ptr<B>& p1, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_paramTest2(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to paramTest3.
     */
    struct ParamTest3Result
    {
        ::std::shared_ptr<B> returnValue;
        ::std::shared_ptr<B> p1;
        ::std::shared_ptr<B> p2;
    };

    virtual ::std::shared_ptr<B> paramTest3(::std::shared_ptr<B>& p1, ::std::shared_ptr<B>& p2, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_paramTest3(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to paramTest4.
     */
    struct ParamTest4Result
    {
        ::std::shared_ptr<B> returnValue;
        ::std::shared_ptr<B> p;
    };

    virtual ::std::shared_ptr<B> paramTest4(::std::shared_ptr<B>& p, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_paramTest4(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to returnTest1.
     */
    struct ReturnTest1Result
    {
        ::std::shared_ptr<B> returnValue;
        ::std::shared_ptr<B> p1;
        ::std::shared_ptr<B> p2;
    };

    virtual ::std::shared_ptr<B> returnTest1(::std::shared_ptr<B>& p1, ::std::shared_ptr<B>& p2, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_returnTest1(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to returnTest2.
     */
    struct ReturnTest2Result
    {
        ::std::shared_ptr<B> returnValue;
        ::std::shared_ptr<B> p2;
        ::std::shared_ptr<B> p1;
    };

    virtual ::std::shared_ptr<B> returnTest2(::std::shared_ptr<B>& p2, ::std::shared_ptr<B>& p1, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_returnTest2(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::std::shared_ptr<B> returnTest3(::std::shared_ptr<B> p1, ::std::shared_ptr<B> p2, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_returnTest3(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual SS sequenceTest(::std::shared_ptr<SS1> p1, ::std::shared_ptr<SS2> p2, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_sequenceTest(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to dictionaryTest.
     */
    struct DictionaryTestResult
    {
        BDict returnValue;
        BDict bout;
    };

    virtual BDict dictionaryTest(BDict bin, BDict& bout, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_dictionaryTest(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::std::shared_ptr<PBase> exchangePBase(::std::shared_ptr<PBase> pb, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_exchangePBase(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::std::shared_ptr<Preserved> PBSUnknownAsPreserved(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_PBSUnknownAsPreserved(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void checkPBSUnknown(::std::shared_ptr<Preserved> p, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_checkPBSUnknown(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::std::shared_ptr<Preserved> PBSUnknownAsPreservedWithGraph(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_PBSUnknownAsPreservedWithGraph(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void checkPBSUnknownWithGraph(::std::shared_ptr<Preserved> p, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_checkPBSUnknownWithGraph(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::std::shared_ptr<Preserved> PBSUnknown2AsPreservedWithGraph(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_PBSUnknown2AsPreservedWithGraph(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void checkPBSUnknown2WithGraph(::std::shared_ptr<Preserved> p, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_checkPBSUnknown2WithGraph(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::std::shared_ptr<PNode> exchangePNode(::std::shared_ptr<PNode> pn, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_exchangePNode(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void throwBaseAsBase(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_throwBaseAsBase(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void throwDerivedAsBase(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_throwDerivedAsBase(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void throwDerivedAsDerived(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_throwDerivedAsDerived(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void throwUnknownDerivedAsBase(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_throwUnknownDerivedAsBase(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void throwPreservedExceptionAsync(::std::function<void()> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_throwPreservedException(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void useForward(::std::shared_ptr<Forward>& f, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_useForward(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void shutdown(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_shutdown(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

}

namespace Test
{

class SBase : public ::Ice::ValueHelper<SBase, ::Ice::Value>
{
public:

    virtual ~SBase();

    SBase() = default;

    SBase(const SBase&) = default;
    SBase(SBase&&) = default;
    SBase& operator=(const SBase&) = default;
    SBase& operator=(SBase&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit SBase(const ::std::string& sb) :
        sb(sb)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&> ice_tuple() const
    {
        return std::tie(sb);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::std::string sb;
};

/// \cond INTERNAL
static SBase _iceS_SBase_init;
/// \endcond

class SBSKnownDerived : public ::Ice::ValueHelper<SBSKnownDerived, SBase>
{
public:

    virtual ~SBSKnownDerived();

    SBSKnownDerived() = default;

    SBSKnownDerived(const SBSKnownDerived&) = default;
    SBSKnownDerived(SBSKnownDerived&&) = default;
    SBSKnownDerived& operator=(const SBSKnownDerived&) = default;
    SBSKnownDerived& operator=(SBSKnownDerived&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    SBSKnownDerived(const ::std::string& sb, const ::std::string& sbskd) :
        Ice::ValueHelper<SBSKnownDerived, SBase>(sb),
        sbskd(sbskd)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::std::string&> ice_tuple() const
    {
        return std::tie(sb, sbskd);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::std::string sbskd;
};

class B : public ::Ice::ValueHelper<B, ::Ice::Value>
{
public:

    virtual ~B();

    B() = default;

    B(const B&) = default;
    B(B&&) = default;
    B& operator=(const B&) = default;
    B& operator=(B&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    B(const ::std::string& sb, const ::std::shared_ptr<::Test::B>& pb) :
        sb(sb),
        pb(pb)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::std::shared_ptr<::Test::B>&> ice_tuple() const
    {
        return std::tie(sb, pb);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::std::string sb;
    ::std::shared_ptr<::Test::B> pb;
};

class D1 : public ::Ice::ValueHelper<D1, B>
{
public:

    virtual ~D1();

    D1() = default;

    D1(const D1&) = default;
    D1(D1&&) = default;
    D1& operator=(const D1&) = default;
    D1& operator=(D1&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    D1(const ::std::string& sb, const ::std::shared_ptr<::Test::B>& pb, const ::std::string& sd1, const ::std::shared_ptr<::Test::B>& pd1) :
        Ice::ValueHelper<D1, B>(sb, pb),
        sd1(sd1),
        pd1(pd1)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::std::shared_ptr<::Test::B>&, const ::std::string&, const ::std::shared_ptr<::Test::B>&> ice_tuple() const
    {
        return std::tie(sb, pb, sd1, pd1);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::std::string sd1;
    ::std::shared_ptr<::Test::B> pd1;
};

class SS1 : public ::Ice::ValueHelper<SS1, ::Ice::Value>
{
public:

    virtual ~SS1();

    SS1() = default;

    SS1(const SS1&) = default;
    SS1(SS1&&) = default;
    SS1& operator=(const SS1&) = default;
    SS1& operator=(SS1&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit SS1(const ::Test::BSeq& s) :
        s(s)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::Test::BSeq&> ice_tuple() const
    {
        return std::tie(s);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::Test::BSeq s;
};

class SS2 : public ::Ice::ValueHelper<SS2, ::Ice::Value>
{
public:

    virtual ~SS2();

    SS2() = default;

    SS2(const SS2&) = default;
    SS2(SS2&&) = default;
    SS2& operator=(const SS2&) = default;
    SS2& operator=(SS2&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit SS2(const ::Test::BSeq& s) :
        s(s)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::Test::BSeq&> ice_tuple() const
    {
        return std::tie(s);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::Test::BSeq s;
};

class PBase : public ::Ice::ValueHelper<PBase, ::Ice::Value>
{
public:

    virtual ~PBase();

    PBase() = default;

    PBase(const PBase&) = default;
    PBase(PBase&&) = default;
    PBase& operator=(const PBase&) = default;
    PBase& operator=(PBase&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit PBase(int pi) :
        pi(pi)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const int&> ice_tuple() const
    {
        return std::tie(pi);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    int pi;
};

class Preserved : public ::Ice::ValueHelper<Preserved, PBase>
{
public:

    virtual ~Preserved();

    Preserved() = default;

    Preserved(const Preserved&) = default;
    Preserved(Preserved&&) = default;
    Preserved& operator=(const Preserved&) = default;
    Preserved& operator=(Preserved&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    Preserved(int pi, const ::std::string& ps) :
        Ice::ValueHelper<Preserved, PBase>(pi),
        ps(ps)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const int&, const ::std::string&> ice_tuple() const
    {
        return std::tie(pi, ps);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /**
     * Obtains the SlicedData object created when an unknown value type was marshaled
     * in the sliced format and the Ice run time sliced it to a known type.
     * @return The SlicedData object, or nil if the value was not sliced or was not
     * marshaled in the sliced format.
     */
    virtual ::std::shared_ptr<::Ice::SlicedData> ice_getSlicedData() const override;

    /// \cond STREAM
    virtual void _iceWrite(::Ice::OutputStream*) const override;
    virtual void _iceRead(::Ice::InputStream*) override;
    /// \endcond

    ::std::string ps;

protected:

    /// \cond STREAM
    ::std::shared_ptr<::Ice::SlicedData> _iceSlicedData;
    /// \endcond
};

class PDerived : public ::Ice::ValueHelper<PDerived, Preserved>
{
public:

    virtual ~PDerived();

    PDerived() = default;

    PDerived(const PDerived&) = default;
    PDerived(PDerived&&) = default;
    PDerived& operator=(const PDerived&) = default;
    PDerived& operator=(PDerived&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    PDerived(int pi, const ::std::string& ps, const ::std::shared_ptr<::Test::PBase>& pb) :
        Ice::ValueHelper<PDerived, Preserved>(pi, ps),
        pb(pb)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const int&, const ::std::string&, const ::std::shared_ptr<::Test::PBase>&> ice_tuple() const
    {
        return std::tie(pi, ps, pb);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::std::shared_ptr<::Test::PBase> pb;
};

class CompactPDerived : public ::Ice::ValueHelper<CompactPDerived, Preserved>
{
public:

    virtual ~CompactPDerived();

    CompactPDerived() = default;

    CompactPDerived(const CompactPDerived&) = default;
    CompactPDerived(CompactPDerived&&) = default;
    CompactPDerived& operator=(const CompactPDerived&) = default;
    CompactPDerived& operator=(CompactPDerived&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    CompactPDerived(int pi, const ::std::string& ps, const ::std::shared_ptr<::Test::PBase>& pb) :
        Ice::ValueHelper<CompactPDerived, Preserved>(pi, ps),
        pb(pb)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const int&, const ::std::string&, const ::std::shared_ptr<::Test::PBase>&> ice_tuple() const
    {
        return std::tie(pi, ps, pb);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::std::shared_ptr<::Test::PBase> pb;
};

class PNode : public ::Ice::ValueHelper<PNode, ::Ice::Value>
{
public:

    virtual ~PNode();

    PNode() = default;

    PNode(const PNode&) = default;
    PNode(PNode&&) = default;
    PNode& operator=(const PNode&) = default;
    PNode& operator=(PNode&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit PNode(const ::std::shared_ptr<::Test::PNode>& next) :
        next(next)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::shared_ptr<::Test::PNode>&> ice_tuple() const
    {
        return std::tie(next);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /**
     * Obtains the SlicedData object created when an unknown value type was marshaled
     * in the sliced format and the Ice run time sliced it to a known type.
     * @return The SlicedData object, or nil if the value was not sliced or was not
     * marshaled in the sliced format.
     */
    virtual ::std::shared_ptr<::Ice::SlicedData> ice_getSlicedData() const override;

    /// \cond STREAM
    virtual void _iceWrite(::Ice::OutputStream*) const override;
    virtual void _iceRead(::Ice::InputStream*) override;
    /// \endcond

    ::std::shared_ptr<::Test::PNode> next;

protected:

    /// \cond STREAM
    ::std::shared_ptr<::Ice::SlicedData> _iceSlicedData;
    /// \endcond
};

class MyClass : public ::Ice::ValueHelper<MyClass, ::Ice::Value>
{
public:

    virtual ~MyClass();

    MyClass() = default;

    MyClass(const MyClass&) = default;
    MyClass(MyClass&&) = default;
    MyClass& operator=(const MyClass&) = default;
    MyClass& operator=(MyClass&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit MyClass(int i) :
        i(i)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const int&> ice_tuple() const
    {
        return std::tie(i);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    int i;
};

class PSUnknown : public ::Ice::ValueHelper<PSUnknown, Preserved>
{
public:

    virtual ~PSUnknown();

    PSUnknown() = default;

    PSUnknown(const PSUnknown&) = default;
    PSUnknown(PSUnknown&&) = default;
    PSUnknown& operator=(const PSUnknown&) = default;
    PSUnknown& operator=(PSUnknown&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    PSUnknown(int pi, const ::std::string& ps, const ::std::string& psu, const ::std::shared_ptr<::Test::PNode>& graph, const ::std::shared_ptr<::Test::MyClass>& cl) :
        Ice::ValueHelper<PSUnknown, Preserved>(pi, ps),
        psu(psu),
        graph(graph),
        cl(cl)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const int&, const ::std::string&, const ::std::string&, const ::std::shared_ptr<::Test::PNode>&, const ::std::shared_ptr<::Test::MyClass>&> ice_tuple() const
    {
        return std::tie(pi, ps, psu, graph, cl);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::std::string psu;
    ::std::shared_ptr<::Test::PNode> graph;
    ::std::shared_ptr<::Test::MyClass> cl;
};

class PSUnknown2 : public ::Ice::ValueHelper<PSUnknown2, Preserved>
{
public:

    virtual ~PSUnknown2();

    PSUnknown2() = default;

    PSUnknown2(const PSUnknown2&) = default;
    PSUnknown2(PSUnknown2&&) = default;
    PSUnknown2& operator=(const PSUnknown2&) = default;
    PSUnknown2& operator=(PSUnknown2&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    PSUnknown2(int pi, const ::std::string& ps, const ::std::shared_ptr<::Test::PBase>& pb) :
        Ice::ValueHelper<PSUnknown2, Preserved>(pi, ps),
        pb(pb)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const int&, const ::std::string&, const ::std::shared_ptr<::Test::PBase>&> ice_tuple() const
    {
        return std::tie(pi, ps, pb);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::std::shared_ptr<::Test::PBase> pb;
};

class Hidden : public ::Ice::ValueHelper<Hidden, ::Ice::Value>
{
public:

    virtual ~Hidden();

    Hidden() = default;

    Hidden(const Hidden&) = default;
    Hidden(Hidden&&) = default;
    Hidden& operator=(const Hidden&) = default;
    Hidden& operator=(Hidden&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit Hidden(const ::std::shared_ptr<::Test::Forward>& f) :
        f(f)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::shared_ptr<::Test::Forward>&> ice_tuple() const
    {
        return std::tie(f);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::std::shared_ptr<::Test::Forward> f;
};

class Forward : public ::Ice::ValueHelper<Forward, ::Ice::Value>
{
public:

    virtual ~Forward();

    Forward() = default;

    Forward(const Forward&) = default;
    Forward(Forward&&) = default;
    Forward& operator=(const Forward&) = default;
    Forward& operator=(Forward&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit Forward(const ::std::shared_ptr<::Test::Hidden>& h) :
        h(h)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::shared_ptr<::Test::Hidden>&> ice_tuple() const
    {
        return std::tie(h);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::std::shared_ptr<::Test::Hidden> h;
};

class SBSUnknownDerived : public ::Ice::ValueHelper<SBSUnknownDerived, SBase>
{
public:

    virtual ~SBSUnknownDerived();

    SBSUnknownDerived() = default;

    SBSUnknownDerived(const SBSUnknownDerived&) = default;
    SBSUnknownDerived(SBSUnknownDerived&&) = default;
    SBSUnknownDerived& operator=(const SBSUnknownDerived&) = default;
    SBSUnknownDerived& operator=(SBSUnknownDerived&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    SBSUnknownDerived(const ::std::string& sb, const ::std::string& sbsud) :
        Ice::ValueHelper<SBSUnknownDerived, SBase>(sb),
        sbsud(sbsud)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::std::string&> ice_tuple() const
    {
        return std::tie(sb, sbsud);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::std::string sbsud;
};

class SUnknown : public ::Ice::ValueHelper<SUnknown, ::Ice::Value>
{
public:

    virtual ~SUnknown();

    SUnknown() = default;

    SUnknown(const SUnknown&) = default;
    SUnknown(SUnknown&&) = default;
    SUnknown& operator=(const SUnknown&) = default;
    SUnknown& operator=(SUnknown&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    SUnknown(const ::std::string& su, const ::std::shared_ptr<::Test::SUnknown>& cycle) :
        su(su),
        cycle(cycle)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::std::shared_ptr<::Test::SUnknown>&> ice_tuple() const
    {
        return std::tie(su, cycle);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::std::string su;
    ::std::shared_ptr<::Test::SUnknown> cycle;
};

class D2 : public ::Ice::ValueHelper<D2, B>
{
public:

    virtual ~D2();

    D2() = default;

    D2(const D2&) = default;
    D2(D2&&) = default;
    D2& operator=(const D2&) = default;
    D2& operator=(D2&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    D2(const ::std::string& sb, const ::std::shared_ptr<::Test::B>& pb, const ::std::string& sd2, const ::std::shared_ptr<::Test::B>& pd2) :
        Ice::ValueHelper<D2, B>(sb, pb),
        sd2(sd2),
        pd2(pd2)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::std::shared_ptr<::Test::B>&, const ::std::string&, const ::std::shared_ptr<::Test::B>&> ice_tuple() const
    {
        return std::tie(sb, pb, sd2, pd2);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::std::string sd2;
    ::std::shared_ptr<::Test::B> pd2;
};

class D4 : public ::Ice::ValueHelper<D4, B>
{
public:

    virtual ~D4();

    D4() = default;

    D4(const D4&) = default;
    D4(D4&&) = default;
    D4& operator=(const D4&) = default;
    D4& operator=(D4&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    D4(const ::std::string& sb, const ::std::shared_ptr<::Test::B>& pb, const ::std::shared_ptr<::Test::B>& p1, const ::std::shared_ptr<::Test::B>& p2) :
        Ice::ValueHelper<D4, B>(sb, pb),
        p1(p1),
        p2(p2)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::std::shared_ptr<::Test::B>&, const ::std::shared_ptr<::Test::B>&, const ::std::shared_ptr<::Test::B>&> ice_tuple() const
    {
        return std::tie(sb, pb, p1, p2);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::std::shared_ptr<::Test::B> p1;
    ::std::shared_ptr<::Test::B> p2;
};

}

namespace Test
{

class TestIntfPrx : public virtual ::Ice::Proxy<TestIntfPrx, ::Ice::ObjectPrx>
{
public:

    ::std::shared_ptr<::Ice::Value> SBaseAsObject(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Ice::Value>>(true, this, &TestIntfPrx::_iceI_SBaseAsObject, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto SBaseAsObjectAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::shared_ptr<::Ice::Value>>>().get_future())
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Ice::Value>, P>(false, this, &TestIntfPrx::_iceI_SBaseAsObject, context);
    }

    ::std::function<void()>
    SBaseAsObjectAsync(::std::function<void(::std::shared_ptr<::Ice::Value>)> response,
                       ::std::function<void(::std::exception_ptr)> ex = nullptr,
                       ::std::function<void(bool)> sent = nullptr,
                       const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<::std::shared_ptr<::Ice::Value>>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_SBaseAsObject, context);
    }

    /// \cond INTERNAL
    void _iceI_SBaseAsObject(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Ice::Value>>>&, const ::Ice::Context&);
    /// \endcond

    ::std::shared_ptr<SBase> SBaseAsSBase(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Test::SBase>>(true, this, &TestIntfPrx::_iceI_SBaseAsSBase, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto SBaseAsSBaseAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::shared_ptr<::Test::SBase>>>().get_future())
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Test::SBase>, P>(false, this, &TestIntfPrx::_iceI_SBaseAsSBase, context);
    }

    ::std::function<void()>
    SBaseAsSBaseAsync(::std::function<void(::std::shared_ptr<::Test::SBase>)> response,
                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                      ::std::function<void(bool)> sent = nullptr,
                      const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<::std::shared_ptr<::Test::SBase>>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_SBaseAsSBase, context);
    }

    /// \cond INTERNAL
    void _iceI_SBaseAsSBase(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Test::SBase>>>&, const ::Ice::Context&);
    /// \endcond

    ::std::shared_ptr<SBase> SBSKnownDerivedAsSBase(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Test::SBase>>(true, this, &TestIntfPrx::_iceI_SBSKnownDerivedAsSBase, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto SBSKnownDerivedAsSBaseAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::shared_ptr<::Test::SBase>>>().get_future())
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Test::SBase>, P>(false, this, &TestIntfPrx::_iceI_SBSKnownDerivedAsSBase, context);
    }

    ::std::function<void()>
    SBSKnownDerivedAsSBaseAsync(::std::function<void(::std::shared_ptr<::Test::SBase>)> response,
                                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                                ::std::function<void(bool)> sent = nullptr,
                                const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<::std::shared_ptr<::Test::SBase>>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_SBSKnownDerivedAsSBase, context);
    }

    /// \cond INTERNAL
    void _iceI_SBSKnownDerivedAsSBase(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Test::SBase>>>&, const ::Ice::Context&);
    /// \endcond

    ::std::shared_ptr<SBSKnownDerived> SBSKnownDerivedAsSBSKnownDerived(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Test::SBSKnownDerived>>(true, this, &TestIntfPrx::_iceI_SBSKnownDerivedAsSBSKnownDerived, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto SBSKnownDerivedAsSBSKnownDerivedAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::shared_ptr<::Test::SBSKnownDerived>>>().get_future())
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Test::SBSKnownDerived>, P>(false, this, &TestIntfPrx::_iceI_SBSKnownDerivedAsSBSKnownDerived, context);
    }

    ::std::function<void()>
    SBSKnownDerivedAsSBSKnownDerivedAsync(::std::function<void(::std::shared_ptr<::Test::SBSKnownDerived>)> response,
                                          ::std::function<void(::std::exception_ptr)> ex = nullptr,
                                          ::std::function<void(bool)> sent = nullptr,
                                          const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<::std::shared_ptr<::Test::SBSKnownDerived>>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_SBSKnownDerivedAsSBSKnownDerived, context);
    }

    /// \cond INTERNAL
    void _iceI_SBSKnownDerivedAsSBSKnownDerived(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Test::SBSKnownDerived>>>&, const ::Ice::Context&);
    /// \endcond

    ::std::shared_ptr<SBase> SBSUnknownDerivedAsSBase(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Test::SBase>>(true, this, &TestIntfPrx::_iceI_SBSUnknownDerivedAsSBase, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto SBSUnknownDerivedAsSBaseAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::shared_ptr<::Test::SBase>>>().get_future())
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Test::SBase>, P>(false, this, &TestIntfPrx::_iceI_SBSUnknownDerivedAsSBase, context);
    }

    ::std::function<void()>
    SBSUnknownDerivedAsSBaseAsync(::std::function<void(::std::shared_ptr<::Test::SBase>)> response,
                                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                                  ::std::function<void(bool)> sent = nullptr,
                                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<::std::shared_ptr<::Test::SBase>>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_SBSUnknownDerivedAsSBase, context);
    }

    /// \cond INTERNAL
    void _iceI_SBSUnknownDerivedAsSBase(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Test::SBase>>>&, const ::Ice::Context&);
    /// \endcond

    ::std::shared_ptr<SBase> SBSUnknownDerivedAsSBaseCompact(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Test::SBase>>(true, this, &TestIntfPrx::_iceI_SBSUnknownDerivedAsSBaseCompact, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto SBSUnknownDerivedAsSBaseCompactAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::shared_ptr<::Test::SBase>>>().get_future())
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Test::SBase>, P>(false, this, &TestIntfPrx::_iceI_SBSUnknownDerivedAsSBaseCompact, context);
    }

    ::std::function<void()>
    SBSUnknownDerivedAsSBaseCompactAsync(::std::function<void(::std::shared_ptr<::Test::SBase>)> response,
                                         ::std::function<void(::std::exception_ptr)> ex = nullptr,
                                         ::std::function<void(bool)> sent = nullptr,
                                         const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<::std::shared_ptr<::Test::SBase>>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_SBSUnknownDerivedAsSBaseCompact, context);
    }

    /// \cond INTERNAL
    void _iceI_SBSUnknownDerivedAsSBaseCompact(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Test::SBase>>>&, const ::Ice::Context&);
    /// \endcond

    ::std::shared_ptr<::Ice::Value> SUnknownAsObject(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Ice::Value>>(true, this, &TestIntfPrx::_iceI_SUnknownAsObject, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto SUnknownAsObjectAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::shared_ptr<::Ice::Value>>>().get_future())
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Ice::Value>, P>(false, this, &TestIntfPrx::_iceI_SUnknownAsObject, context);
    }

    ::std::function<void()>
    SUnknownAsObjectAsync(::std::function<void(::std::shared_ptr<::Ice::Value>)> response,
                          ::std::function<void(::std::exception_ptr)> ex = nullptr,
                          ::std::function<void(bool)> sent = nullptr,
                          const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<::std::shared_ptr<::Ice::Value>>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_SUnknownAsObject, context);
    }

    /// \cond INTERNAL
    void _iceI_SUnknownAsObject(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Ice::Value>>>&, const ::Ice::Context&);
    /// \endcond

    void checkSUnknown(const ::std::shared_ptr<::Ice::Value>& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &TestIntfPrx::_iceI_checkSUnknown, o, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto checkSUnknownAsync(const ::std::shared_ptr<::Ice::Value>& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &TestIntfPrx::_iceI_checkSUnknown, o, context);
    }

    ::std::function<void()>
    checkSUnknownAsync(const ::std::shared_ptr<::Ice::Value>& o,
                       ::std::function<void()> response,
                       ::std::function<void(::std::exception_ptr)> ex = nullptr,
                       ::std::function<void(bool)> sent = nullptr,
                       const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_checkSUnknown, o, context);
    }

    /// \cond INTERNAL
    void _iceI_checkSUnknown(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::shared_ptr<::Ice::Value>&, const ::Ice::Context&);
    /// \endcond

    ::std::shared_ptr<B> oneElementCycle(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Test::B>>(true, this, &TestIntfPrx::_iceI_oneElementCycle, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto oneElementCycleAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::shared_ptr<::Test::B>>>().get_future())
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Test::B>, P>(false, this, &TestIntfPrx::_iceI_oneElementCycle, context);
    }

    ::std::function<void()>
    oneElementCycleAsync(::std::function<void(::std::shared_ptr<::Test::B>)> response,
                         ::std::function<void(::std::exception_ptr)> ex = nullptr,
                         ::std::function<void(bool)> sent = nullptr,
                         const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<::std::shared_ptr<::Test::B>>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_oneElementCycle, context);
    }

    /// \cond INTERNAL
    void _iceI_oneElementCycle(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Test::B>>>&, const ::Ice::Context&);
    /// \endcond

    ::std::shared_ptr<B> twoElementCycle(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Test::B>>(true, this, &TestIntfPrx::_iceI_twoElementCycle, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto twoElementCycleAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::shared_ptr<::Test::B>>>().get_future())
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Test::B>, P>(false, this, &TestIntfPrx::_iceI_twoElementCycle, context);
    }

    ::std::function<void()>
    twoElementCycleAsync(::std::function<void(::std::shared_ptr<::Test::B>)> response,
                         ::std::function<void(::std::exception_ptr)> ex = nullptr,
                         ::std::function<void(bool)> sent = nullptr,
                         const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<::std::shared_ptr<::Test::B>>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_twoElementCycle, context);
    }

    /// \cond INTERNAL
    void _iceI_twoElementCycle(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Test::B>>>&, const ::Ice::Context&);
    /// \endcond

    ::std::shared_ptr<B> D1AsB(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Test::B>>(true, this, &TestIntfPrx::_iceI_D1AsB, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto D1AsBAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::shared_ptr<::Test::B>>>().get_future())
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Test::B>, P>(false, this, &TestIntfPrx::_iceI_D1AsB, context);
    }

    ::std::function<void()>
    D1AsBAsync(::std::function<void(::std::shared_ptr<::Test::B>)> response,
               ::std::function<void(::std::exception_ptr)> ex = nullptr,
               ::std::function<void(bool)> sent = nullptr,
               const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<::std::shared_ptr<::Test::B>>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_D1AsB, context);
    }

    /// \cond INTERNAL
    void _iceI_D1AsB(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Test::B>>>&, const ::Ice::Context&);
    /// \endcond

    ::std::shared_ptr<D1> D1AsD1(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Test::D1>>(true, this, &TestIntfPrx::_iceI_D1AsD1, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto D1AsD1Async(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::shared_ptr<::Test::D1>>>().get_future())
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Test::D1>, P>(false, this, &TestIntfPrx::_iceI_D1AsD1, context);
    }

    ::std::function<void()>
    D1AsD1Async(::std::function<void(::std::shared_ptr<::Test::D1>)> response,
                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                ::std::function<void(bool)> sent = nullptr,
                const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<::std::shared_ptr<::Test::D1>>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_D1AsD1, context);
    }

    /// \cond INTERNAL
    void _iceI_D1AsD1(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Test::D1>>>&, const ::Ice::Context&);
    /// \endcond

    ::std::shared_ptr<B> D2AsB(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Test::B>>(true, this, &TestIntfPrx::_iceI_D2AsB, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto D2AsBAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::shared_ptr<::Test::B>>>().get_future())
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Test::B>, P>(false, this, &TestIntfPrx::_iceI_D2AsB, context);
    }

    ::std::function<void()>
    D2AsBAsync(::std::function<void(::std::shared_ptr<::Test::B>)> response,
               ::std::function<void(::std::exception_ptr)> ex = nullptr,
               ::std::function<void(bool)> sent = nullptr,
               const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<::std::shared_ptr<::Test::B>>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_D2AsB, context);
    }

    /// \cond INTERNAL
    void _iceI_D2AsB(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Test::B>>>&, const ::Ice::Context&);
    /// \endcond

    void paramTest1(::std::shared_ptr<B>& p1, ::std::shared_ptr<B>& p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::ParamTest1Result>(true, this, &TestIntfPrx::_iceI_paramTest1, context).get();
        p1 = ::std::move(_result.p1);
        p2 = ::std::move(_result.p2);
    }

    template<template<typename> class P = ::std::promise>
    auto paramTest1Async(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::ParamTest1Result>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::ParamTest1Result, P>(false, this, &TestIntfPrx::_iceI_paramTest1, context);
    }

    ::std::function<void()>
    paramTest1Async(::std::function<void(::std::shared_ptr<::Test::B>, ::std::shared_ptr<::Test::B>)> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::ParamTest1Result&& _result)
        {
            response(::std::move(_result.p1), ::std::move(_result.p2));
        };
        return _makeLambdaOutgoing<TestIntf::ParamTest1Result>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_paramTest1, context);
    }

    /// \cond INTERNAL
    void _iceI_paramTest1(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::ParamTest1Result>>&, const ::Ice::Context&);
    /// \endcond

    void paramTest2(::std::shared_ptr<B>& p2, ::std::shared_ptr<B>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::ParamTest2Result>(true, this, &TestIntfPrx::_iceI_paramTest2, context).get();
        p2 = ::std::move(_result.p2);
        p1 = ::std::move(_result.p1);
    }

    template<template<typename> class P = ::std::promise>
    auto paramTest2Async(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::ParamTest2Result>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::ParamTest2Result, P>(false, this, &TestIntfPrx::_iceI_paramTest2, context);
    }

    ::std::function<void()>
    paramTest2Async(::std::function<void(::std::shared_ptr<::Test::B>, ::std::shared_ptr<::Test::B>)> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::ParamTest2Result&& _result)
        {
            response(::std::move(_result.p2), ::std::move(_result.p1));
        };
        return _makeLambdaOutgoing<TestIntf::ParamTest2Result>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_paramTest2, context);
    }

    /// \cond INTERNAL
    void _iceI_paramTest2(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::ParamTest2Result>>&, const ::Ice::Context&);
    /// \endcond

    ::std::shared_ptr<B> paramTest3(::std::shared_ptr<B>& p1, ::std::shared_ptr<B>& p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::ParamTest3Result>(true, this, &TestIntfPrx::_iceI_paramTest3, context).get();
        p1 = ::std::move(_result.p1);
        p2 = ::std::move(_result.p2);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto paramTest3Async(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::ParamTest3Result>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::ParamTest3Result, P>(false, this, &TestIntfPrx::_iceI_paramTest3, context);
    }

    ::std::function<void()>
    paramTest3Async(::std::function<void(::std::shared_ptr<::Test::B>, ::std::shared_ptr<::Test::B>, ::std::shared_ptr<::Test::B>)> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::ParamTest3Result&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.p1), ::std::move(_result.p2));
        };
        return _makeLambdaOutgoing<TestIntf::ParamTest3Result>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_paramTest3, context);
    }

    /// \cond INTERNAL
    void _iceI_paramTest3(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::ParamTest3Result>>&, const ::Ice::Context&);
    /// \endcond

    ::std::shared_ptr<B> paramTest4(::std::shared_ptr<B>& p, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::ParamTest4Result>(true, this, &TestIntfPrx::_iceI_paramTest4, context).get();
        p = ::std::move(_result.p);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto paramTest4Async(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::ParamTest4Result>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::ParamTest4Result, P>(false, this, &TestIntfPrx::_iceI_paramTest4, context);
    }

    ::std::function<void()>
    paramTest4Async(::std::function<void(::std::shared_ptr<::Test::B>, ::std::shared_ptr<::Test::B>)> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::ParamTest4Result&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.p));
        };
        return _makeLambdaOutgoing<TestIntf::ParamTest4Result>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_paramTest4, context);
    }

    /// \cond INTERNAL
    void _iceI_paramTest4(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::ParamTest4Result>>&, const ::Ice::Context&);
    /// \endcond

    ::std::shared_ptr<B> returnTest1(::std::shared_ptr<B>& p1, ::std::shared_ptr<B>& p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::ReturnTest1Result>(true, this, &TestIntfPrx::_iceI_returnTest1, context).get();
        p1 = ::std::move(_result.p1);
        p2 = ::std::move(_result.p2);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto returnTest1Async(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::ReturnTest1Result>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::ReturnTest1Result, P>(false, this, &TestIntfPrx::_iceI_returnTest1, context);
    }

    ::std::function<void()>
    returnTest1Async(::std::function<void(::std::shared_ptr<::Test::B>, ::std::shared_ptr<::Test::B>, ::std::shared_ptr<::Test::B>)> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::ReturnTest1Result&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.p1), ::std::move(_result.p2));
        };
        return _makeLambdaOutgoing<TestIntf::ReturnTest1Result>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_returnTest1, context);
    }

    /// \cond INTERNAL
    void _iceI_returnTest1(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::ReturnTest1Result>>&, const ::Ice::Context&);
    /// \endcond

    ::std::shared_ptr<B> returnTest2(::std::shared_ptr<B>& p2, ::std::shared_ptr<B>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::ReturnTest2Result>(true, this, &TestIntfPrx::_iceI_returnTest2, context).get();
        p2 = ::std::move(_result.p2);
        p1 = ::std::move(_result.p1);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto returnTest2Async(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::ReturnTest2Result>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::ReturnTest2Result, P>(false, this, &TestIntfPrx::_iceI_returnTest2, context);
    }

    ::std::function<void()>
    returnTest2Async(::std::function<void(::std::shared_ptr<::Test::B>, ::std::shared_ptr<::Test::B>, ::std::shared_ptr<::Test::B>)> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::ReturnTest2Result&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.p2), ::std::move(_result.p1));
        };
        return _makeLambdaOutgoing<TestIntf::ReturnTest2Result>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_returnTest2, context);
    }

    /// \cond INTERNAL
    void _iceI_returnTest2(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::ReturnTest2Result>>&, const ::Ice::Context&);
    /// \endcond

    ::std::shared_ptr<B> returnTest3(const ::std::shared_ptr<B>& p1, const ::std::shared_ptr<B>& p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Test::B>>(true, this, &TestIntfPrx::_iceI_returnTest3, p1, p2, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto returnTest3Async(const ::std::shared_ptr<B>& p1, const ::std::shared_ptr<B>& p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::shared_ptr<::Test::B>>>().get_future())
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Test::B>, P>(false, this, &TestIntfPrx::_iceI_returnTest3, p1, p2, context);
    }

    ::std::function<void()>
    returnTest3Async(const ::std::shared_ptr<B>& p1, const ::std::shared_ptr<B>& p2,
                     ::std::function<void(::std::shared_ptr<::Test::B>)> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<::std::shared_ptr<::Test::B>>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_returnTest3, p1, p2, context);
    }

    /// \cond INTERNAL
    void _iceI_returnTest3(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Test::B>>>&, const ::std::shared_ptr<B>&, const ::std::shared_ptr<B>&, const ::Ice::Context&);
    /// \endcond

    SS sequenceTest(const ::std::shared_ptr<SS1>& p1, const ::std::shared_ptr<SS2>& p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::Test::SS>(true, this, &TestIntfPrx::_iceI_sequenceTest, p1, p2, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto sequenceTestAsync(const ::std::shared_ptr<SS1>& p1, const ::std::shared_ptr<SS2>& p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::Test::SS>>().get_future())
    {
        return _makePromiseOutgoing<::Test::SS, P>(false, this, &TestIntfPrx::_iceI_sequenceTest, p1, p2, context);
    }

    ::std::function<void()>
    sequenceTestAsync(const ::std::shared_ptr<SS1>& p1, const ::std::shared_ptr<SS2>& p2,
                      ::std::function<void(::Test::SS)> response,
                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                      ::std::function<void(bool)> sent = nullptr,
                      const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<::Test::SS>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_sequenceTest, p1, p2, context);
    }

    /// \cond INTERNAL
    void _iceI_sequenceTest(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::Test::SS>>&, const ::std::shared_ptr<SS1>&, const ::std::shared_ptr<SS2>&, const ::Ice::Context&);
    /// \endcond

    BDict dictionaryTest(const BDict& bin, BDict& bout, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::DictionaryTestResult>(true, this, &TestIntfPrx::_iceI_dictionaryTest, bin, context).get();
        bout = ::std::move(_result.bout);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto dictionaryTestAsync(const BDict& bin, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::DictionaryTestResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::DictionaryTestResult, P>(false, this, &TestIntfPrx::_iceI_dictionaryTest, bin, context);
    }

    ::std::function<void()>
    dictionaryTestAsync(const BDict& bin,
                        ::std::function<void(::Test::BDict, ::Test::BDict)> response,
                        ::std::function<void(::std::exception_ptr)> ex = nullptr,
                        ::std::function<void(bool)> sent = nullptr,
                        const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::DictionaryTestResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.bout));
        };
        return _makeLambdaOutgoing<TestIntf::DictionaryTestResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_dictionaryTest, bin, context);
    }

    /// \cond INTERNAL
    void _iceI_dictionaryTest(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::DictionaryTestResult>>&, const BDict&, const ::Ice::Context&);
    /// \endcond

    ::std::shared_ptr<PBase> exchangePBase(const ::std::shared_ptr<PBase>& pb, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Test::PBase>>(true, this, &TestIntfPrx::_iceI_exchangePBase, pb, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto exchangePBaseAsync(const ::std::shared_ptr<PBase>& pb, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::shared_ptr<::Test::PBase>>>().get_future())
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Test::PBase>, P>(false, this, &TestIntfPrx::_iceI_exchangePBase, pb, context);
    }

    ::std::function<void()>
    exchangePBaseAsync(const ::std::shared_ptr<PBase>& pb,
                       ::std::function<void(::std::shared_ptr<::Test::PBase>)> response,
                       ::std::function<void(::std::exception_ptr)> ex = nullptr,
                       ::std::function<void(bool)> sent = nullptr,
                       const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<::std::shared_ptr<::Test::PBase>>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_exchangePBase, pb, context);
    }

    /// \cond INTERNAL
    void _iceI_exchangePBase(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Test::PBase>>>&, const ::std::shared_ptr<PBase>&, const ::Ice::Context&);
    /// \endcond

    ::std::shared_ptr<Preserved> PBSUnknownAsPreserved(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Test::Preserved>>(true, this, &TestIntfPrx::_iceI_PBSUnknownAsPreserved, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto PBSUnknownAsPreservedAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::shared_ptr<::Test::Preserved>>>().get_future())
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Test::Preserved>, P>(false, this, &TestIntfPrx::_iceI_PBSUnknownAsPreserved, context);
    }

    ::std::function<void()>
    PBSUnknownAsPreservedAsync(::std::function<void(::std::shared_ptr<::Test::Preserved>)> response,
                               ::std::function<void(::std::exception_ptr)> ex = nullptr,
                               ::std::function<void(bool)> sent = nullptr,
                               const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<::std::shared_ptr<::Test::Preserved>>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_PBSUnknownAsPreserved, context);
    }

    /// \cond INTERNAL
    void _iceI_PBSUnknownAsPreserved(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Test::Preserved>>>&, const ::Ice::Context&);
    /// \endcond

    void checkPBSUnknown(const ::std::shared_ptr<Preserved>& p, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &TestIntfPrx::_iceI_checkPBSUnknown, p, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto checkPBSUnknownAsync(const ::std::shared_ptr<Preserved>& p, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &TestIntfPrx::_iceI_checkPBSUnknown, p, context);
    }

    ::std::function<void()>
    checkPBSUnknownAsync(const ::std::shared_ptr<Preserved>& p,
                         ::std::function<void()> response,
                         ::std::function<void(::std::exception_ptr)> ex = nullptr,
                         ::std::function<void(bool)> sent = nullptr,
                         const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_checkPBSUnknown, p, context);
    }

    /// \cond INTERNAL
    void _iceI_checkPBSUnknown(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::shared_ptr<Preserved>&, const ::Ice::Context&);
    /// \endcond

    ::std::shared_ptr<Preserved> PBSUnknownAsPreservedWithGraph(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Test::Preserved>>(true, this, &TestIntfPrx::_iceI_PBSUnknownAsPreservedWithGraph, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto PBSUnknownAsPreservedWithGraphAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::shared_ptr<::Test::Preserved>>>().get_future())
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Test::Preserved>, P>(false, this, &TestIntfPrx::_iceI_PBSUnknownAsPreservedWithGraph, context);
    }

    ::std::function<void()>
    PBSUnknownAsPreservedWithGraphAsync(::std::function<void(::std::shared_ptr<::Test::Preserved>)> response,
                                        ::std::function<void(::std::exception_ptr)> ex = nullptr,
                                        ::std::function<void(bool)> sent = nullptr,
                                        const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<::std::shared_ptr<::Test::Preserved>>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_PBSUnknownAsPreservedWithGraph, context);
    }

    /// \cond INTERNAL
    void _iceI_PBSUnknownAsPreservedWithGraph(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Test::Preserved>>>&, const ::Ice::Context&);
    /// \endcond

    void checkPBSUnknownWithGraph(const ::std::shared_ptr<Preserved>& p, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &TestIntfPrx::_iceI_checkPBSUnknownWithGraph, p, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto checkPBSUnknownWithGraphAsync(const ::std::shared_ptr<Preserved>& p, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &TestIntfPrx::_iceI_checkPBSUnknownWithGraph, p, context);
    }

    ::std::function<void()>
    checkPBSUnknownWithGraphAsync(const ::std::shared_ptr<Preserved>& p,
                                  ::std::function<void()> response,
                                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                                  ::std::function<void(bool)> sent = nullptr,
                                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_checkPBSUnknownWithGraph, p, context);
    }

    /// \cond INTERNAL
    void _iceI_checkPBSUnknownWithGraph(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::shared_ptr<Preserved>&, const ::Ice::Context&);
    /// \endcond

    ::std::shared_ptr<Preserved> PBSUnknown2AsPreservedWithGraph(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Test::Preserved>>(true, this, &TestIntfPrx::_iceI_PBSUnknown2AsPreservedWithGraph, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto PBSUnknown2AsPreservedWithGraphAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::shared_ptr<::Test::Preserved>>>().get_future())
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Test::Preserved>, P>(false, this, &TestIntfPrx::_iceI_PBSUnknown2AsPreservedWithGraph, context);
    }

    ::std::function<void()>
    PBSUnknown2AsPreservedWithGraphAsync(::std::function<void(::std::shared_ptr<::Test::Preserved>)> response,
                                         ::std::function<void(::std::exception_ptr)> ex = nullptr,
                                         ::std::function<void(bool)> sent = nullptr,
                                         const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<::std::shared_ptr<::Test::Preserved>>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_PBSUnknown2AsPreservedWithGraph, context);
    }

    /// \cond INTERNAL
    void _iceI_PBSUnknown2AsPreservedWithGraph(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Test::Preserved>>>&, const ::Ice::Context&);
    /// \endcond

    void checkPBSUnknown2WithGraph(const ::std::shared_ptr<Preserved>& p, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &TestIntfPrx::_iceI_checkPBSUnknown2WithGraph, p, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto checkPBSUnknown2WithGraphAsync(const ::std::shared_ptr<Preserved>& p, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &TestIntfPrx::_iceI_checkPBSUnknown2WithGraph, p, context);
    }

    ::std::function<void()>
    checkPBSUnknown2WithGraphAsync(const ::std::shared_ptr<Preserved>& p,
                                   ::std::function<void()> response,
                                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                                   ::std::function<void(bool)> sent = nullptr,
                                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_checkPBSUnknown2WithGraph, p, context);
    }

    /// \cond INTERNAL
    void _iceI_checkPBSUnknown2WithGraph(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::shared_ptr<Preserved>&, const ::Ice::Context&);
    /// \endcond

    ::std::shared_ptr<PNode> exchangePNode(const ::std::shared_ptr<PNode>& pn, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Test::PNode>>(true, this, &TestIntfPrx::_iceI_exchangePNode, pn, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto exchangePNodeAsync(const ::std::shared_ptr<PNode>& pn, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::shared_ptr<::Test::PNode>>>().get_future())
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Test::PNode>, P>(false, this, &TestIntfPrx::_iceI_exchangePNode, pn, context);
    }

    ::std::function<void()>
    exchangePNodeAsync(const ::std::shared_ptr<PNode>& pn,
                       ::std::function<void(::std::shared_ptr<::Test::PNode>)> response,
                       ::std::function<void(::std::exception_ptr)> ex = nullptr,
                       ::std::function<void(bool)> sent = nullptr,
                       const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<::std::shared_ptr<::Test::PNode>>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_exchangePNode, pn, context);
    }

    /// \cond INTERNAL
    void _iceI_exchangePNode(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Test::PNode>>>&, const ::std::shared_ptr<PNode>&, const ::Ice::Context&);
    /// \endcond

    void throwBaseAsBase(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &TestIntfPrx::_iceI_throwBaseAsBase, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto throwBaseAsBaseAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &TestIntfPrx::_iceI_throwBaseAsBase, context);
    }

    ::std::function<void()>
    throwBaseAsBaseAsync(::std::function<void()> response,
                         ::std::function<void(::std::exception_ptr)> ex = nullptr,
                         ::std::function<void(bool)> sent = nullptr,
                         const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_throwBaseAsBase, context);
    }

    /// \cond INTERNAL
    void _iceI_throwBaseAsBase(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    void throwDerivedAsBase(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &TestIntfPrx::_iceI_throwDerivedAsBase, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto throwDerivedAsBaseAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &TestIntfPrx::_iceI_throwDerivedAsBase, context);
    }

    ::std::function<void()>
    throwDerivedAsBaseAsync(::std::function<void()> response,
                            ::std::function<void(::std::exception_ptr)> ex = nullptr,
                            ::std::function<void(bool)> sent = nullptr,
                            const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_throwDerivedAsBase, context);
    }

    /// \cond INTERNAL
    void _iceI_throwDerivedAsBase(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    void throwDerivedAsDerived(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &TestIntfPrx::_iceI_throwDerivedAsDerived, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto throwDerivedAsDerivedAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &TestIntfPrx::_iceI_throwDerivedAsDerived, context);
    }

    ::std::function<void()>
    throwDerivedAsDerivedAsync(::std::function<void()> response,
                               ::std::function<void(::std::exception_ptr)> ex = nullptr,
                               ::std::function<void(bool)> sent = nullptr,
                               const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_throwDerivedAsDerived, context);
    }

    /// \cond INTERNAL
    void _iceI_throwDerivedAsDerived(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    void throwUnknownDerivedAsBase(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &TestIntfPrx::_iceI_throwUnknownDerivedAsBase, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto throwUnknownDerivedAsBaseAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &TestIntfPrx::_iceI_throwUnknownDerivedAsBase, context);
    }

    ::std::function<void()>
    throwUnknownDerivedAsBaseAsync(::std::function<void()> response,
                                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                                   ::std::function<void(bool)> sent = nullptr,
                                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_throwUnknownDerivedAsBase, context);
    }

    /// \cond INTERNAL
    void _iceI_throwUnknownDerivedAsBase(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    void throwPreservedException(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &TestIntfPrx::_iceI_throwPreservedException, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto throwPreservedExceptionAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &TestIntfPrx::_iceI_throwPreservedException, context);
    }

    ::std::function<void()>
    throwPreservedExceptionAsync(::std::function<void()> response,
                                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                                 ::std::function<void(bool)> sent = nullptr,
                                 const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_throwPreservedException, context);
    }

    /// \cond INTERNAL
    void _iceI_throwPreservedException(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    void useForward(::std::shared_ptr<Forward>& f, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        f = _makePromiseOutgoing<::std::shared_ptr<::Test::Forward>>(true, this, &TestIntfPrx::_iceI_useForward, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto useForwardAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::shared_ptr<::Test::Forward>>>().get_future())
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Test::Forward>, P>(false, this, &TestIntfPrx::_iceI_useForward, context);
    }

    ::std::function<void()>
    useForwardAsync(::std::function<void(::std::shared_ptr<::Test::Forward>)> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<::std::shared_ptr<::Test::Forward>>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_useForward, context);
    }

    /// \cond INTERNAL
    void _iceI_useForward(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Test::Forward>>>&, const ::Ice::Context&);
    /// \endcond

    void shutdown(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &TestIntfPrx::_iceI_shutdown, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto shutdownAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &TestIntfPrx::_iceI_shutdown, context);
    }

    ::std::function<void()>
    shutdownAsync(::std::function<void()> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_shutdown, context);
    }

    /// \cond INTERNAL
    void _iceI_shutdown(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    TestIntfPrx() = default;
    friend ::std::shared_ptr<TestIntfPrx> IceInternal::createProxy<TestIntfPrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

}

/// \cond STREAM
namespace Ice
{

template<typename S>
struct StreamReader<::Test::SBase, S>
{
    static void read(S* istr, ::Test::SBase& v)
    {
        istr->readAll(v.sb);
    }
};

template<typename S>
struct StreamWriter<::Test::SBSKnownDerived, S>
{
    static void write(S* ostr, const ::Test::SBSKnownDerived& v)
    {
        ostr->writeAll(v.sbskd);
    }
};

template<typename S>
struct StreamReader<::Test::SBSKnownDerived, S>
{
    static void read(S* istr, ::Test::SBSKnownDerived& v)
    {
        istr->readAll(v.sbskd);
    }
};

template<typename S>
struct StreamReader<::Test::B, S>
{
    static void read(S* istr, ::Test::B& v)
    {
        istr->readAll(v.sb, v.pb);
    }
};

template<typename S>
struct StreamWriter<::Test::D1, S>
{
    static void write(S* ostr, const ::Test::D1& v)
    {
        ostr->writeAll(v.sd1, v.pd1);
    }
};

template<typename S>
struct StreamReader<::Test::D1, S>
{
    static void read(S* istr, ::Test::D1& v)
    {
        istr->readAll(v.sd1, v.pd1);
    }
};

template<typename S>
struct StreamReader<::Test::SS1, S>
{
    static void read(S* istr, ::Test::SS1& v)
    {
        istr->readAll(v.s);
    }
};

template<typename S>
struct StreamReader<::Test::SS2, S>
{
    static void read(S* istr, ::Test::SS2& v)
    {
        istr->readAll(v.s);
    }
};

template<>
struct StreamableTraits<::Test::SS>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 2;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::Test::SS, S>
{
    static void read(S* istr, ::Test::SS& v)
    {
        istr->readAll(v.c1, v.c2);
    }
};

template<typename S>
struct StreamReader<::Test::BaseException, S>
{
    static void read(S* istr, ::Test::BaseException& v)
    {
        istr->readAll(v.sbe, v.pb);
    }
};

template<typename S>
struct StreamWriter<::Test::DerivedException, S>
{
    static void write(S* ostr, const ::Test::DerivedException& v)
    {
        ostr->writeAll(v.sde, v.pd1);
    }
};

template<typename S>
struct StreamReader<::Test::DerivedException, S>
{
    static void read(S* istr, ::Test::DerivedException& v)
    {
        istr->readAll(v.sde, v.pd1);
    }
};

template<typename S>
struct StreamReader<::Test::PBase, S>
{
    static void read(S* istr, ::Test::PBase& v)
    {
        istr->readAll(v.pi);
    }
};

template<typename S>
struct StreamWriter<::Test::Preserved, S>
{
    static void write(S* ostr, const ::Test::Preserved& v)
    {
        ostr->writeAll(v.ps);
    }
};

template<typename S>
struct StreamReader<::Test::Preserved, S>
{
    static void read(S* istr, ::Test::Preserved& v)
    {
        istr->readAll(v.ps);
    }
};

template<typename S>
struct StreamWriter<::Test::PDerived, S>
{
    static void write(S* ostr, const ::Test::PDerived& v)
    {
        ostr->writeAll(v.pb);
    }
};

template<typename S>
struct StreamReader<::Test::PDerived, S>
{
    static void read(S* istr, ::Test::PDerived& v)
    {
        istr->readAll(v.pb);
    }
};

template<typename S>
struct StreamWriter<::Test::CompactPDerived, S>
{
    static void write(S* ostr, const ::Test::CompactPDerived& v)
    {
        ostr->writeAll(v.pb);
    }
};

template<typename S>
struct StreamReader<::Test::CompactPDerived, S>
{
    static void read(S* istr, ::Test::CompactPDerived& v)
    {
        istr->readAll(v.pb);
    }
};

template<typename S>
struct StreamReader<::Test::PNode, S>
{
    static void read(S* istr, ::Test::PNode& v)
    {
        istr->readAll(v.next);
    }
};

template<typename S>
struct StreamReader<::Test::MyClass, S>
{
    static void read(S* istr, ::Test::MyClass& v)
    {
        istr->readAll(v.i);
    }
};

template<typename S>
struct StreamWriter<::Test::PSUnknown, S>
{
    static void write(S* ostr, const ::Test::PSUnknown& v)
    {
        ostr->writeAll(v.psu, v.graph, v.cl);
    }
};

template<typename S>
struct StreamReader<::Test::PSUnknown, S>
{
    static void read(S* istr, ::Test::PSUnknown& v)
    {
        istr->readAll(v.psu, v.graph, v.cl);
    }
};

template<typename S>
struct StreamWriter<::Test::PSUnknown2, S>
{
    static void write(S* ostr, const ::Test::PSUnknown2& v)
    {
        ostr->writeAll(v.pb);
    }
};

template<typename S>
struct StreamReader<::Test::PSUnknown2, S>
{
    static void read(S* istr, ::Test::PSUnknown2& v)
    {
        istr->readAll(v.pb);
    }
};

template<typename S>
struct StreamReader<::Test::PSUnknownException, S>
{
    static void read(S* istr, ::Test::PSUnknownException& v)
    {
        istr->readAll(v.p);
    }
};

template<typename S>
struct StreamReader<::Test::Hidden, S>
{
    static void read(S* istr, ::Test::Hidden& v)
    {
        istr->readAll(v.f);
    }
};

template<typename S>
struct StreamReader<::Test::Forward, S>
{
    static void read(S* istr, ::Test::Forward& v)
    {
        istr->readAll(v.h);
    }
};

template<typename S>
struct StreamWriter<::Test::SBSUnknownDerived, S>
{
    static void write(S* ostr, const ::Test::SBSUnknownDerived& v)
    {
        ostr->writeAll(v.sbsud);
    }
};

template<typename S>
struct StreamReader<::Test::SBSUnknownDerived, S>
{
    static void read(S* istr, ::Test::SBSUnknownDerived& v)
    {
        istr->readAll(v.sbsud);
    }
};

template<typename S>
struct StreamReader<::Test::SUnknown, S>
{
    static void read(S* istr, ::Test::SUnknown& v)
    {
        istr->readAll(v.su, v.cycle);
    }
};

template<typename S>
struct StreamWriter<::Test::D2, S>
{
    static void write(S* ostr, const ::Test::D2& v)
    {
        ostr->writeAll(v.sd2, v.pd2);
    }
};

template<typename S>
struct StreamReader<::Test::D2, S>
{
    static void read(S* istr, ::Test::D2& v)
    {
        istr->readAll(v.sd2, v.pd2);
    }
};

template<typename S>
struct StreamWriter<::Test::D4, S>
{
    static void write(S* ostr, const ::Test::D4& v)
    {
        ostr->writeAll(v.p1, v.p2);
    }
};

template<typename S>
struct StreamReader<::Test::D4, S>
{
    static void read(S* istr, ::Test::D4& v)
    {
        istr->readAll(v.p1, v.p2);
    }
};

template<typename S>
struct StreamWriter<::Test::UnknownDerivedException, S>
{
    static void write(S* ostr, const ::Test::UnknownDerivedException& v)
    {
        ostr->writeAll(v.sude, v.pd2);
    }
};

template<typename S>
struct StreamReader<::Test::UnknownDerivedException, S>
{
    static void read(S* istr, ::Test::UnknownDerivedException& v)
    {
        istr->readAll(v.sude, v.pd2);
    }
};

}
/// \endcond

/// \cond INTERNAL
namespace Test
{

using SBasePtr = ::std::shared_ptr<SBase>;

using SBSKnownDerivedPtr = ::std::shared_ptr<SBSKnownDerived>;

using BPtr = ::std::shared_ptr<B>;

using D1Ptr = ::std::shared_ptr<D1>;

using SS1Ptr = ::std::shared_ptr<SS1>;

using SS2Ptr = ::std::shared_ptr<SS2>;

using ForwardPtr = ::std::shared_ptr<Forward>;

using PBasePtr = ::std::shared_ptr<PBase>;

using PreservedPtr = ::std::shared_ptr<Preserved>;

using PDerivedPtr = ::std::shared_ptr<PDerived>;

using CompactPDerivedPtr = ::std::shared_ptr<CompactPDerived>;

using PNodePtr = ::std::shared_ptr<PNode>;

using MyClassPtr = ::std::shared_ptr<MyClass>;

using PSUnknownPtr = ::std::shared_ptr<PSUnknown>;

using PSUnknown2Ptr = ::std::shared_ptr<PSUnknown2>;

using TestIntfPtr = ::std::shared_ptr<TestIntf>;
using TestIntfPrxPtr = ::std::shared_ptr<TestIntfPrx>;

using HiddenPtr = ::std::shared_ptr<Hidden>;

using SBSUnknownDerivedPtr = ::std::shared_ptr<SBSUnknownDerived>;

using SUnknownPtr = ::std::shared_ptr<SUnknown>;

using D2Ptr = ::std::shared_ptr<D2>;

using D4Ptr = ::std::shared_ptr<D4>;

}
/// \endcond

#else // C++98 mapping

namespace IceProxy
{

namespace Test
{

class SBase;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< SBase>&);
::IceProxy::Ice::Object* upCast(SBase*);
/// \endcond

class SBSKnownDerived;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< SBSKnownDerived>&);
::IceProxy::Ice::Object* upCast(SBSKnownDerived*);
/// \endcond

class B;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< B>&);
::IceProxy::Ice::Object* upCast(B*);
/// \endcond

class D1;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< D1>&);
::IceProxy::Ice::Object* upCast(D1*);
/// \endcond

class SS1;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< SS1>&);
::IceProxy::Ice::Object* upCast(SS1*);
/// \endcond

class SS2;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< SS2>&);
::IceProxy::Ice::Object* upCast(SS2*);
/// \endcond

class Forward;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< Forward>&);
::IceProxy::Ice::Object* upCast(Forward*);
/// \endcond

class PBase;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< PBase>&);
::IceProxy::Ice::Object* upCast(PBase*);
/// \endcond

class Preserved;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< Preserved>&);
::IceProxy::Ice::Object* upCast(Preserved*);
/// \endcond

class PDerived;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< PDerived>&);
::IceProxy::Ice::Object* upCast(PDerived*);
/// \endcond

class CompactPDerived;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< CompactPDerived>&);
::IceProxy::Ice::Object* upCast(CompactPDerived*);
/// \endcond

class PNode;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< PNode>&);
::IceProxy::Ice::Object* upCast(PNode*);
/// \endcond

class MyClass;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< MyClass>&);
::IceProxy::Ice::Object* upCast(MyClass*);
/// \endcond

class PSUnknown;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< PSUnknown>&);
::IceProxy::Ice::Object* upCast(PSUnknown*);
/// \endcond

class PSUnknown2;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< PSUnknown2>&);
::IceProxy::Ice::Object* upCast(PSUnknown2*);
/// \endcond

class TestIntf;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< TestIntf>&);
::IceProxy::Ice::Object* upCast(TestIntf*);
/// \endcond

class Hidden;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< Hidden>&);
::IceProxy::Ice::Object* upCast(Hidden*);
/// \endcond

class SBSUnknownDerived;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< SBSUnknownDerived>&);
::IceProxy::Ice::Object* upCast(SBSUnknownDerived*);
/// \endcond

class SUnknown;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< SUnknown>&);
::IceProxy::Ice::Object* upCast(SUnknown*);
/// \endcond

class D2;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< D2>&);
::IceProxy::Ice::Object* upCast(D2*);
/// \endcond

class D4;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< D4>&);
::IceProxy::Ice::Object* upCast(D4*);
/// \endcond

}

}

namespace Test
{

class SBase;
/// \cond INTERNAL
::Ice::Object* upCast(SBase*);
/// \endcond
typedef ::IceInternal::Handle< SBase> SBasePtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::SBase> SBasePrx;
typedef SBasePrx SBasePrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(SBasePtr&, const ::Ice::ObjectPtr&);
/// \endcond

class SBSKnownDerived;
/// \cond INTERNAL
::Ice::Object* upCast(SBSKnownDerived*);
/// \endcond
typedef ::IceInternal::Handle< SBSKnownDerived> SBSKnownDerivedPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::SBSKnownDerived> SBSKnownDerivedPrx;
typedef SBSKnownDerivedPrx SBSKnownDerivedPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(SBSKnownDerivedPtr&, const ::Ice::ObjectPtr&);
/// \endcond

class B;
/// \cond INTERNAL
::Ice::Object* upCast(B*);
/// \endcond
typedef ::IceInternal::Handle< B> BPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::B> BPrx;
typedef BPrx BPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(BPtr&, const ::Ice::ObjectPtr&);
/// \endcond

class D1;
/// \cond INTERNAL
::Ice::Object* upCast(D1*);
/// \endcond
typedef ::IceInternal::Handle< D1> D1Ptr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::D1> D1Prx;
typedef D1Prx D1PrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(D1Ptr&, const ::Ice::ObjectPtr&);
/// \endcond

class SS1;
/// \cond INTERNAL
::Ice::Object* upCast(SS1*);
/// \endcond
typedef ::IceInternal::Handle< SS1> SS1Ptr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::SS1> SS1Prx;
typedef SS1Prx SS1PrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(SS1Ptr&, const ::Ice::ObjectPtr&);
/// \endcond

class SS2;
/// \cond INTERNAL
::Ice::Object* upCast(SS2*);
/// \endcond
typedef ::IceInternal::Handle< SS2> SS2Ptr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::SS2> SS2Prx;
typedef SS2Prx SS2PrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(SS2Ptr&, const ::Ice::ObjectPtr&);
/// \endcond

class Forward;
/// \cond INTERNAL
::Ice::Object* upCast(Forward*);
/// \endcond
typedef ::IceInternal::Handle< Forward> ForwardPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::Forward> ForwardPrx;
typedef ForwardPrx ForwardPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(ForwardPtr&, const ::Ice::ObjectPtr&);
/// \endcond

class PBase;
/// \cond INTERNAL
::Ice::Object* upCast(PBase*);
/// \endcond
typedef ::IceInternal::Handle< PBase> PBasePtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::PBase> PBasePrx;
typedef PBasePrx PBasePrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(PBasePtr&, const ::Ice::ObjectPtr&);
/// \endcond

class Preserved;
/// \cond INTERNAL
::Ice::Object* upCast(Preserved*);
/// \endcond
typedef ::IceInternal::Handle< Preserved> PreservedPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::Preserved> PreservedPrx;
typedef PreservedPrx PreservedPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(PreservedPtr&, const ::Ice::ObjectPtr&);
/// \endcond

class PDerived;
/// \cond INTERNAL
::Ice::Object* upCast(PDerived*);
/// \endcond
typedef ::IceInternal::Handle< PDerived> PDerivedPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::PDerived> PDerivedPrx;
typedef PDerivedPrx PDerivedPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(PDerivedPtr&, const ::Ice::ObjectPtr&);
/// \endcond

class CompactPDerived;
/// \cond INTERNAL
::Ice::Object* upCast(CompactPDerived*);
/// \endcond
typedef ::IceInternal::Handle< CompactPDerived> CompactPDerivedPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::CompactPDerived> CompactPDerivedPrx;
typedef CompactPDerivedPrx CompactPDerivedPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(CompactPDerivedPtr&, const ::Ice::ObjectPtr&);
/// \endcond

class PNode;
/// \cond INTERNAL
::Ice::Object* upCast(PNode*);
/// \endcond
typedef ::IceInternal::Handle< PNode> PNodePtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::PNode> PNodePrx;
typedef PNodePrx PNodePrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(PNodePtr&, const ::Ice::ObjectPtr&);
/// \endcond

class MyClass;
/// \cond INTERNAL
::Ice::Object* upCast(MyClass*);
/// \endcond
typedef ::IceInternal::Handle< MyClass> MyClassPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::MyClass> MyClassPrx;
typedef MyClassPrx MyClassPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(MyClassPtr&, const ::Ice::ObjectPtr&);
/// \endcond

class PSUnknown;
/// \cond INTERNAL
::Ice::Object* upCast(PSUnknown*);
/// \endcond
typedef ::IceInternal::Handle< PSUnknown> PSUnknownPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::PSUnknown> PSUnknownPrx;
typedef PSUnknownPrx PSUnknownPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(PSUnknownPtr&, const ::Ice::ObjectPtr&);
/// \endcond

class PSUnknown2;
/// \cond INTERNAL
::Ice::Object* upCast(PSUnknown2*);
/// \endcond
typedef ::IceInternal::Handle< PSUnknown2> PSUnknown2Ptr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::PSUnknown2> PSUnknown2Prx;
typedef PSUnknown2Prx PSUnknown2PrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(PSUnknown2Ptr&, const ::Ice::ObjectPtr&);
/// \endcond

class TestIntf;
/// \cond INTERNAL
::Ice::Object* upCast(TestIntf*);
/// \endcond
typedef ::IceInternal::Handle< TestIntf> TestIntfPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::TestIntf> TestIntfPrx;
typedef TestIntfPrx TestIntfPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(TestIntfPtr&, const ::Ice::ObjectPtr&);
/// \endcond

class Hidden;
/// \cond INTERNAL
::Ice::Object* upCast(Hidden*);
/// \endcond
typedef ::IceInternal::Handle< Hidden> HiddenPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::Hidden> HiddenPrx;
typedef HiddenPrx HiddenPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(HiddenPtr&, const ::Ice::ObjectPtr&);
/// \endcond

class SBSUnknownDerived;
/// \cond INTERNAL
::Ice::Object* upCast(SBSUnknownDerived*);
/// \endcond
typedef ::IceInternal::Handle< SBSUnknownDerived> SBSUnknownDerivedPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::SBSUnknownDerived> SBSUnknownDerivedPrx;
typedef SBSUnknownDerivedPrx SBSUnknownDerivedPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(SBSUnknownDerivedPtr&, const ::Ice::ObjectPtr&);
/// \endcond

class SUnknown;
/// \cond INTERNAL
::Ice::Object* upCast(SUnknown*);
/// \endcond
typedef ::IceInternal::Handle< SUnknown> SUnknownPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::SUnknown> SUnknownPrx;
typedef SUnknownPrx SUnknownPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(SUnknownPtr&, const ::Ice::ObjectPtr&);
/// \endcond

class D2;
/// \cond INTERNAL
::Ice::Object* upCast(D2*);
/// \endcond
typedef ::IceInternal::Handle< D2> D2Ptr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::D2> D2Prx;
typedef D2Prx D2PrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(D2Ptr&, const ::Ice::ObjectPtr&);
/// \endcond

class D4;
/// \cond INTERNAL
::Ice::Object* upCast(D4*);
/// \endcond
typedef ::IceInternal::Handle< D4> D4Ptr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::D4> D4Prx;
typedef D4Prx D4PrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(D4Ptr&, const ::Ice::ObjectPtr&);
/// \endcond

}

namespace Test
{

typedef ::std::vector<BPtr> BSeq;

struct SS
{
    ::Test::SS1Ptr c1;
    ::Test::SS2Ptr c2;
};

typedef ::std::map< ::Ice::Int, BPtr> BDict;

class BaseException : public ::Ice::UserException
{
public:

    BaseException() {}
    /**
     * One-shot constructor to initialize all data members.
     */
    BaseException(const ::std::string& sbe, const BPtr& pb);

#ifdef ICE_CPP11_COMPILER
    BaseException(const BaseException&) = default;
    virtual ~BaseException();
#else
    virtual ~BaseException() throw();
#endif

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    virtual ::std::string ice_id() const;
    /**
     * Polymorphically clones this exception.
     * @return A shallow copy of this exception.
     */
    virtual BaseException* ice_clone() const;
    /**
     * Throws this exception.
     */
    virtual void ice_throw() const;

    /// \cond STREAM
    virtual bool _usesClasses() const;
    /// \endcond

    ::std::string sbe;
    ::Test::BPtr pb;

protected:

    /// \cond STREAM
    virtual void _writeImpl(::Ice::OutputStream*) const;
    virtual void _readImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
static BaseException _iceS_BaseException_init;
/// \endcond

class DerivedException : public BaseException
{
public:

    DerivedException() {}
    /**
     * One-shot constructor to initialize all data members.
     */
    DerivedException(const ::std::string& sbe, const BPtr& pb, const ::std::string& sde, const D1Ptr& pd1);

#ifdef ICE_CPP11_COMPILER
    DerivedException(const DerivedException&) = default;
    virtual ~DerivedException();
#else
    virtual ~DerivedException() throw();
#endif

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    virtual ::std::string ice_id() const;
    /**
     * Polymorphically clones this exception.
     * @return A shallow copy of this exception.
     */
    virtual DerivedException* ice_clone() const;
    /**
     * Throws this exception.
     */
    virtual void ice_throw() const;

    ::std::string sde;
    ::Test::D1Ptr pd1;

protected:

    /// \cond STREAM
    virtual void _writeImpl(::Ice::OutputStream*) const;
    virtual void _readImpl(::Ice::InputStream*);
    /// \endcond
};

typedef ::std::vector<PBasePtr> PBaseSeq;

class PreservedException : public ::Ice::UserException
{
public:

    PreservedException() {}

#ifdef ICE_CPP11_COMPILER
    PreservedException(const PreservedException&) = default;
    virtual ~PreservedException();
#else
    virtual ~PreservedException() throw();
#endif

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    virtual ::std::string ice_id() const;
    /**
     * Polymorphically clones this exception.
     * @return A shallow copy of this exception.
     */
    virtual PreservedException* ice_clone() const;
    /**
     * Throws this exception.
     */
    virtual void ice_throw() const;

    /**
     * Obtains the SlicedData object created when an unknown exception type was marshaled
     * in the sliced format and the Ice run time sliced it to a known type.
     * @return The SlicedData object, or nil if the exception was not sliced or was not
     * marshaled in the sliced format.
     */
    virtual ::Ice::SlicedDataPtr ice_getSlicedData() const;

    /// \cond STREAM
    virtual void _write(::Ice::OutputStream*) const;
    virtual void _read(::Ice::InputStream*);
    using ::Ice::UserException::_write;
    using ::Ice::UserException::_read;
    /// \endcond

protected:

    /// \cond STREAM
    virtual void _writeImpl(::Ice::OutputStream*) const;
    virtual void _readImpl(::Ice::InputStream*);
    /// \endcond

    /// \cond STREAM
    ::Ice::SlicedDataPtr _slicedData;
    /// \endcond
};

class PSUnknownException : public PreservedException
{
public:

    PSUnknownException() {}
    /**
     * One-shot constructor to initialize all data members.
     */
    explicit PSUnknownException(const PSUnknown2Ptr& p);

#ifdef ICE_CPP11_COMPILER
    PSUnknownException(const PSUnknownException&) = default;
    virtual ~PSUnknownException();
#else
    virtual ~PSUnknownException() throw();
#endif

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    virtual ::std::string ice_id() const;
    /**
     * Polymorphically clones this exception.
     * @return A shallow copy of this exception.
     */
    virtual PSUnknownException* ice_clone() const;
    /**
     * Throws this exception.
     */
    virtual void ice_throw() const;

    /// \cond STREAM
    virtual bool _usesClasses() const;
    /// \endcond

    ::Test::PSUnknown2Ptr p;

protected:

    /// \cond STREAM
    virtual void _writeImpl(::Ice::OutputStream*) const;
    virtual void _readImpl(::Ice::InputStream*);
    /// \endcond
};

class UnknownDerivedException : public BaseException
{
public:

    UnknownDerivedException() {}
    /**
     * One-shot constructor to initialize all data members.
     */
    UnknownDerivedException(const ::std::string& sbe, const BPtr& pb, const ::std::string& sude, const D2Ptr& pd2);

#ifdef ICE_CPP11_COMPILER
    UnknownDerivedException(const UnknownDerivedException&) = default;
    virtual ~UnknownDerivedException();
#else
    virtual ~UnknownDerivedException() throw();
#endif

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    virtual ::std::string ice_id() const;
    /**
     * Polymorphically clones this exception.
     * @return A shallow copy of this exception.
     */
    virtual UnknownDerivedException* ice_clone() const;
    /**
     * Throws this exception.
     */
    virtual void ice_throw() const;

    ::std::string sude;
    ::Test::D2Ptr pd2;

protected:

    /// \cond STREAM
    virtual void _writeImpl(::Ice::OutputStream*) const;
    virtual void _readImpl(::Ice::InputStream*);
    /// \endcond
};

}

namespace Test
{

/**
 * AMD callback class for Test::TestIntf::throwPreservedException_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_TestIntf_throwPreservedException : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_TestIntf_throwPreservedException();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_TestIntf_throwPreservedException> AMD_TestIntf_throwPreservedExceptionPtr;

}

/// \cond INTERNAL
namespace IceAsync
{

namespace Test
{

#if defined(_MSC_VER)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_TestIntf_throwPreservedException : public ::Test::AMD_TestIntf_throwPreservedException, public ::IceInternal::IncomingAsync
{
public:

    AMD_TestIntf_throwPreservedException(::IceInternal::Incoming&);

    virtual void ice_response();
};

#if defined(_MSC_VER)
#   pragma warning(pop)
#endif

}

}
/// \endcond

namespace Test
{

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_SBaseAsObject.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_SBaseAsObject.
 */
class Callback_TestIntf_SBaseAsObject_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_SBaseAsObject_Base> Callback_TestIntf_SBaseAsObjectPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_SBaseAsSBase.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_SBaseAsSBase.
 */
class Callback_TestIntf_SBaseAsSBase_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_SBaseAsSBase_Base> Callback_TestIntf_SBaseAsSBasePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_SBSKnownDerivedAsSBase.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_SBSKnownDerivedAsSBase.
 */
class Callback_TestIntf_SBSKnownDerivedAsSBase_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_SBSKnownDerivedAsSBase_Base> Callback_TestIntf_SBSKnownDerivedAsSBasePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_SBSKnownDerivedAsSBSKnownDerived.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_SBSKnownDerivedAsSBSKnownDerived.
 */
class Callback_TestIntf_SBSKnownDerivedAsSBSKnownDerived_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_SBSKnownDerivedAsSBSKnownDerived_Base> Callback_TestIntf_SBSKnownDerivedAsSBSKnownDerivedPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_SBSUnknownDerivedAsSBase.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_SBSUnknownDerivedAsSBase.
 */
class Callback_TestIntf_SBSUnknownDerivedAsSBase_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_SBSUnknownDerivedAsSBase_Base> Callback_TestIntf_SBSUnknownDerivedAsSBasePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_SBSUnknownDerivedAsSBaseCompact.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_SBSUnknownDerivedAsSBaseCompact.
 */
class Callback_TestIntf_SBSUnknownDerivedAsSBaseCompact_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_SBSUnknownDerivedAsSBaseCompact_Base> Callback_TestIntf_SBSUnknownDerivedAsSBaseCompactPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_SUnknownAsObject.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_SUnknownAsObject.
 */
class Callback_TestIntf_SUnknownAsObject_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_SUnknownAsObject_Base> Callback_TestIntf_SUnknownAsObjectPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_checkSUnknown.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_checkSUnknown.
 */
class Callback_TestIntf_checkSUnknown_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_checkSUnknown_Base> Callback_TestIntf_checkSUnknownPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_oneElementCycle.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_oneElementCycle.
 */
class Callback_TestIntf_oneElementCycle_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_oneElementCycle_Base> Callback_TestIntf_oneElementCyclePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_twoElementCycle.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_twoElementCycle.
 */
class Callback_TestIntf_twoElementCycle_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_twoElementCycle_Base> Callback_TestIntf_twoElementCyclePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_D1AsB.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_D1AsB.
 */
class Callback_TestIntf_D1AsB_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_D1AsB_Base> Callback_TestIntf_D1AsBPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_D1AsD1.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_D1AsD1.
 */
class Callback_TestIntf_D1AsD1_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_D1AsD1_Base> Callback_TestIntf_D1AsD1Ptr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_D2AsB.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_D2AsB.
 */
class Callback_TestIntf_D2AsB_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_D2AsB_Base> Callback_TestIntf_D2AsBPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_paramTest1.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_paramTest1.
 */
class Callback_TestIntf_paramTest1_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_paramTest1_Base> Callback_TestIntf_paramTest1Ptr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_paramTest2.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_paramTest2.
 */
class Callback_TestIntf_paramTest2_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_paramTest2_Base> Callback_TestIntf_paramTest2Ptr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_paramTest3.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_paramTest3.
 */
class Callback_TestIntf_paramTest3_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_paramTest3_Base> Callback_TestIntf_paramTest3Ptr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_paramTest4.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_paramTest4.
 */
class Callback_TestIntf_paramTest4_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_paramTest4_Base> Callback_TestIntf_paramTest4Ptr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_returnTest1.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_returnTest1.
 */
class Callback_TestIntf_returnTest1_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_returnTest1_Base> Callback_TestIntf_returnTest1Ptr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_returnTest2.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_returnTest2.
 */
class Callback_TestIntf_returnTest2_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_returnTest2_Base> Callback_TestIntf_returnTest2Ptr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_returnTest3.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_returnTest3.
 */
class Callback_TestIntf_returnTest3_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_returnTest3_Base> Callback_TestIntf_returnTest3Ptr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_sequenceTest.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_sequenceTest.
 */
class Callback_TestIntf_sequenceTest_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_sequenceTest_Base> Callback_TestIntf_sequenceTestPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_dictionaryTest.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_dictionaryTest.
 */
class Callback_TestIntf_dictionaryTest_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_dictionaryTest_Base> Callback_TestIntf_dictionaryTestPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_exchangePBase.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_exchangePBase.
 */
class Callback_TestIntf_exchangePBase_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_exchangePBase_Base> Callback_TestIntf_exchangePBasePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_PBSUnknownAsPreserved.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_PBSUnknownAsPreserved.
 */
class Callback_TestIntf_PBSUnknownAsPreserved_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_PBSUnknownAsPreserved_Base> Callback_TestIntf_PBSUnknownAsPreservedPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_checkPBSUnknown.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_checkPBSUnknown.
 */
class Callback_TestIntf_checkPBSUnknown_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_checkPBSUnknown_Base> Callback_TestIntf_checkPBSUnknownPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_PBSUnknownAsPreservedWithGraph.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_PBSUnknownAsPreservedWithGraph.
 */
class Callback_TestIntf_PBSUnknownAsPreservedWithGraph_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_PBSUnknownAsPreservedWithGraph_Base> Callback_TestIntf_PBSUnknownAsPreservedWithGraphPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_checkPBSUnknownWithGraph.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_checkPBSUnknownWithGraph.
 */
class Callback_TestIntf_checkPBSUnknownWithGraph_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_checkPBSUnknownWithGraph_Base> Callback_TestIntf_checkPBSUnknownWithGraphPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_PBSUnknown2AsPreservedWithGraph.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_PBSUnknown2AsPreservedWithGraph.
 */
class Callback_TestIntf_PBSUnknown2AsPreservedWithGraph_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_PBSUnknown2AsPreservedWithGraph_Base> Callback_TestIntf_PBSUnknown2AsPreservedWithGraphPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_checkPBSUnknown2WithGraph.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_checkPBSUnknown2WithGraph.
 */
class Callback_TestIntf_checkPBSUnknown2WithGraph_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_checkPBSUnknown2WithGraph_Base> Callback_TestIntf_checkPBSUnknown2WithGraphPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_exchangePNode.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_exchangePNode.
 */
class Callback_TestIntf_exchangePNode_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_exchangePNode_Base> Callback_TestIntf_exchangePNodePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_throwBaseAsBase.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_throwBaseAsBase.
 */
class Callback_TestIntf_throwBaseAsBase_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_throwBaseAsBase_Base> Callback_TestIntf_throwBaseAsBasePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_throwDerivedAsBase.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_throwDerivedAsBase.
 */
class Callback_TestIntf_throwDerivedAsBase_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_throwDerivedAsBase_Base> Callback_TestIntf_throwDerivedAsBasePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_throwDerivedAsDerived.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_throwDerivedAsDerived.
 */
class Callback_TestIntf_throwDerivedAsDerived_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_throwDerivedAsDerived_Base> Callback_TestIntf_throwDerivedAsDerivedPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_throwUnknownDerivedAsBase.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_throwUnknownDerivedAsBase.
 */
class Callback_TestIntf_throwUnknownDerivedAsBase_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_throwUnknownDerivedAsBase_Base> Callback_TestIntf_throwUnknownDerivedAsBasePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_throwPreservedException.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_throwPreservedException.
 */
class Callback_TestIntf_throwPreservedException_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_throwPreservedException_Base> Callback_TestIntf_throwPreservedExceptionPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_useForward.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_useForward.
 */
class Callback_TestIntf_useForward_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_useForward_Base> Callback_TestIntf_useForwardPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_shutdown.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_shutdown.
 */
class Callback_TestIntf_shutdown_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_shutdown_Base> Callback_TestIntf_shutdownPtr;

}

namespace IceProxy
{

namespace Test
{

class SBase : public virtual ::Ice::Proxy<SBase, ::IceProxy::Ice::Object>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class SBSKnownDerived : public virtual ::Ice::Proxy<SBSKnownDerived, ::IceProxy::Test::SBase>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class B : public virtual ::Ice::Proxy<B, ::IceProxy::Ice::Object>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class D1 : public virtual ::Ice::Proxy<D1, ::IceProxy::Test::B>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class SS1 : public virtual ::Ice::Proxy<SS1, ::IceProxy::Ice::Object>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class SS2 : public virtual ::Ice::Proxy<SS2, ::IceProxy::Ice::Object>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class PBase : public virtual ::Ice::Proxy<PBase, ::IceProxy::Ice::Object>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class Preserved : public virtual ::Ice::Proxy<Preserved, ::IceProxy::Test::PBase>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class PDerived : public virtual ::Ice::Proxy<PDerived, ::IceProxy::Test::Preserved>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class CompactPDerived : public virtual ::Ice::Proxy<CompactPDerived, ::IceProxy::Test::Preserved>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class PNode : public virtual ::Ice::Proxy<PNode, ::IceProxy::Ice::Object>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class MyClass : public virtual ::Ice::Proxy<MyClass, ::IceProxy::Ice::Object>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class PSUnknown : public virtual ::Ice::Proxy<PSUnknown, ::IceProxy::Test::Preserved>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class PSUnknown2 : public virtual ::Ice::Proxy<PSUnknown2, ::IceProxy::Test::Preserved>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class TestIntf : public virtual ::Ice::Proxy<TestIntf, ::IceProxy::Ice::Object>
{
public:

    ::Ice::ObjectPtr SBaseAsObject(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_SBaseAsObject(_iceI_begin_SBaseAsObject(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_SBaseAsObject(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_SBaseAsObject(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_SBaseAsObject(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SBaseAsObject(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SBaseAsObject(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SBaseAsObject(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SBaseAsObject(const ::Test::Callback_TestIntf_SBaseAsObjectPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SBaseAsObject(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SBaseAsObject(const ::Ice::Context& context, const ::Test::Callback_TestIntf_SBaseAsObjectPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SBaseAsObject(context, cb, cookie);
    }

    ::Ice::ObjectPtr end_SBaseAsObject(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_SBaseAsObject(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::SBasePtr SBaseAsSBase(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_SBaseAsSBase(_iceI_begin_SBaseAsSBase(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_SBaseAsSBase(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_SBaseAsSBase(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_SBaseAsSBase(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SBaseAsSBase(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SBaseAsSBase(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SBaseAsSBase(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SBaseAsSBase(const ::Test::Callback_TestIntf_SBaseAsSBasePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SBaseAsSBase(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SBaseAsSBase(const ::Ice::Context& context, const ::Test::Callback_TestIntf_SBaseAsSBasePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SBaseAsSBase(context, cb, cookie);
    }

    ::Test::SBasePtr end_SBaseAsSBase(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_SBaseAsSBase(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::SBasePtr SBSKnownDerivedAsSBase(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_SBSKnownDerivedAsSBase(_iceI_begin_SBSKnownDerivedAsSBase(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_SBSKnownDerivedAsSBase(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_SBSKnownDerivedAsSBase(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_SBSKnownDerivedAsSBase(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SBSKnownDerivedAsSBase(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SBSKnownDerivedAsSBase(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SBSKnownDerivedAsSBase(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SBSKnownDerivedAsSBase(const ::Test::Callback_TestIntf_SBSKnownDerivedAsSBasePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SBSKnownDerivedAsSBase(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SBSKnownDerivedAsSBase(const ::Ice::Context& context, const ::Test::Callback_TestIntf_SBSKnownDerivedAsSBasePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SBSKnownDerivedAsSBase(context, cb, cookie);
    }

    ::Test::SBasePtr end_SBSKnownDerivedAsSBase(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_SBSKnownDerivedAsSBase(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::SBSKnownDerivedPtr SBSKnownDerivedAsSBSKnownDerived(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_SBSKnownDerivedAsSBSKnownDerived(_iceI_begin_SBSKnownDerivedAsSBSKnownDerived(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_SBSKnownDerivedAsSBSKnownDerived(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_SBSKnownDerivedAsSBSKnownDerived(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_SBSKnownDerivedAsSBSKnownDerived(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SBSKnownDerivedAsSBSKnownDerived(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SBSKnownDerivedAsSBSKnownDerived(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SBSKnownDerivedAsSBSKnownDerived(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SBSKnownDerivedAsSBSKnownDerived(const ::Test::Callback_TestIntf_SBSKnownDerivedAsSBSKnownDerivedPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SBSKnownDerivedAsSBSKnownDerived(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SBSKnownDerivedAsSBSKnownDerived(const ::Ice::Context& context, const ::Test::Callback_TestIntf_SBSKnownDerivedAsSBSKnownDerivedPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SBSKnownDerivedAsSBSKnownDerived(context, cb, cookie);
    }

    ::Test::SBSKnownDerivedPtr end_SBSKnownDerivedAsSBSKnownDerived(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_SBSKnownDerivedAsSBSKnownDerived(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::SBasePtr SBSUnknownDerivedAsSBase(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_SBSUnknownDerivedAsSBase(_iceI_begin_SBSUnknownDerivedAsSBase(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_SBSUnknownDerivedAsSBase(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_SBSUnknownDerivedAsSBase(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_SBSUnknownDerivedAsSBase(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SBSUnknownDerivedAsSBase(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SBSUnknownDerivedAsSBase(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SBSUnknownDerivedAsSBase(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SBSUnknownDerivedAsSBase(const ::Test::Callback_TestIntf_SBSUnknownDerivedAsSBasePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SBSUnknownDerivedAsSBase(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SBSUnknownDerivedAsSBase(const ::Ice::Context& context, const ::Test::Callback_TestIntf_SBSUnknownDerivedAsSBasePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SBSUnknownDerivedAsSBase(context, cb, cookie);
    }

    ::Test::SBasePtr end_SBSUnknownDerivedAsSBase(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_SBSUnknownDerivedAsSBase(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::SBasePtr SBSUnknownDerivedAsSBaseCompact(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_SBSUnknownDerivedAsSBaseCompact(_iceI_begin_SBSUnknownDerivedAsSBaseCompact(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_SBSUnknownDerivedAsSBaseCompact(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_SBSUnknownDerivedAsSBaseCompact(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_SBSUnknownDerivedAsSBaseCompact(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SBSUnknownDerivedAsSBaseCompact(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SBSUnknownDerivedAsSBaseCompact(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SBSUnknownDerivedAsSBaseCompact(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SBSUnknownDerivedAsSBaseCompact(const ::Test::Callback_TestIntf_SBSUnknownDerivedAsSBaseCompactPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SBSUnknownDerivedAsSBaseCompact(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SBSUnknownDerivedAsSBaseCompact(const ::Ice::Context& context, const ::Test::Callback_TestIntf_SBSUnknownDerivedAsSBaseCompactPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SBSUnknownDerivedAsSBaseCompact(context, cb, cookie);
    }

    ::Test::SBasePtr end_SBSUnknownDerivedAsSBaseCompact(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_SBSUnknownDerivedAsSBaseCompact(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Ice::ObjectPtr SUnknownAsObject(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_SUnknownAsObject(_iceI_begin_SUnknownAsObject(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_SUnknownAsObject(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_SUnknownAsObject(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_SUnknownAsObject(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SUnknownAsObject(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SUnknownAsObject(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SUnknownAsObject(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SUnknownAsObject(const ::Test::Callback_TestIntf_SUnknownAsObjectPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SUnknownAsObject(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SUnknownAsObject(const ::Ice::Context& context, const ::Test::Callback_TestIntf_SUnknownAsObjectPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SUnknownAsObject(context, cb, cookie);
    }

    ::Ice::ObjectPtr end_SUnknownAsObject(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_SUnknownAsObject(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void checkSUnknown(const ::Ice::ObjectPtr& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_checkSUnknown(_iceI_begin_checkSUnknown(o, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_checkSUnknown(const ::Ice::ObjectPtr& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_checkSUnknown(o, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_checkSUnknown(const ::Ice::ObjectPtr& o, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_checkSUnknown(o, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_checkSUnknown(const ::Ice::ObjectPtr& o, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_checkSUnknown(o, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_checkSUnknown(const ::Ice::ObjectPtr& o, const ::Test::Callback_TestIntf_checkSUnknownPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_checkSUnknown(o, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_checkSUnknown(const ::Ice::ObjectPtr& o, const ::Ice::Context& context, const ::Test::Callback_TestIntf_checkSUnknownPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_checkSUnknown(o, context, cb, cookie);
    }

    void end_checkSUnknown(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_checkSUnknown(const ::Ice::ObjectPtr&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::BPtr oneElementCycle(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_oneElementCycle(_iceI_begin_oneElementCycle(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_oneElementCycle(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_oneElementCycle(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_oneElementCycle(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_oneElementCycle(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_oneElementCycle(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_oneElementCycle(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_oneElementCycle(const ::Test::Callback_TestIntf_oneElementCyclePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_oneElementCycle(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_oneElementCycle(const ::Ice::Context& context, const ::Test::Callback_TestIntf_oneElementCyclePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_oneElementCycle(context, cb, cookie);
    }

    ::Test::BPtr end_oneElementCycle(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_oneElementCycle(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::BPtr twoElementCycle(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_twoElementCycle(_iceI_begin_twoElementCycle(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_twoElementCycle(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_twoElementCycle(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_twoElementCycle(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_twoElementCycle(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_twoElementCycle(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_twoElementCycle(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_twoElementCycle(const ::Test::Callback_TestIntf_twoElementCyclePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_twoElementCycle(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_twoElementCycle(const ::Ice::Context& context, const ::Test::Callback_TestIntf_twoElementCyclePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_twoElementCycle(context, cb, cookie);
    }

    ::Test::BPtr end_twoElementCycle(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_twoElementCycle(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::BPtr D1AsB(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_D1AsB(_iceI_begin_D1AsB(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_D1AsB(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_D1AsB(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_D1AsB(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_D1AsB(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_D1AsB(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_D1AsB(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_D1AsB(const ::Test::Callback_TestIntf_D1AsBPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_D1AsB(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_D1AsB(const ::Ice::Context& context, const ::Test::Callback_TestIntf_D1AsBPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_D1AsB(context, cb, cookie);
    }

    ::Test::BPtr end_D1AsB(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_D1AsB(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::D1Ptr D1AsD1(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_D1AsD1(_iceI_begin_D1AsD1(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_D1AsD1(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_D1AsD1(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_D1AsD1(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_D1AsD1(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_D1AsD1(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_D1AsD1(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_D1AsD1(const ::Test::Callback_TestIntf_D1AsD1Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_D1AsD1(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_D1AsD1(const ::Ice::Context& context, const ::Test::Callback_TestIntf_D1AsD1Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_D1AsD1(context, cb, cookie);
    }

    ::Test::D1Ptr end_D1AsD1(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_D1AsD1(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::BPtr D2AsB(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_D2AsB(_iceI_begin_D2AsB(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_D2AsB(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_D2AsB(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_D2AsB(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_D2AsB(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_D2AsB(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_D2AsB(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_D2AsB(const ::Test::Callback_TestIntf_D2AsBPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_D2AsB(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_D2AsB(const ::Ice::Context& context, const ::Test::Callback_TestIntf_D2AsBPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_D2AsB(context, cb, cookie);
    }

    ::Test::BPtr end_D2AsB(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_D2AsB(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void paramTest1(::Test::BPtr& p1, ::Test::BPtr& p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_paramTest1(p1, p2, _iceI_begin_paramTest1(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_paramTest1(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_paramTest1(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_paramTest1(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_paramTest1(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_paramTest1(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_paramTest1(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_paramTest1(const ::Test::Callback_TestIntf_paramTest1Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_paramTest1(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_paramTest1(const ::Ice::Context& context, const ::Test::Callback_TestIntf_paramTest1Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_paramTest1(context, cb, cookie);
    }

    void end_paramTest1(::Test::BPtr& p1, ::Test::BPtr& p2, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_paramTest1(::Test::BPtr& iceP_p1, ::Test::BPtr& iceP_p2, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_paramTest1(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void paramTest2(::Test::BPtr& p2, ::Test::BPtr& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_paramTest2(p2, p1, _iceI_begin_paramTest2(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_paramTest2(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_paramTest2(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_paramTest2(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_paramTest2(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_paramTest2(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_paramTest2(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_paramTest2(const ::Test::Callback_TestIntf_paramTest2Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_paramTest2(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_paramTest2(const ::Ice::Context& context, const ::Test::Callback_TestIntf_paramTest2Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_paramTest2(context, cb, cookie);
    }

    void end_paramTest2(::Test::BPtr& p2, ::Test::BPtr& p1, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_paramTest2(::Test::BPtr& iceP_p2, ::Test::BPtr& iceP_p1, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_paramTest2(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::BPtr paramTest3(::Test::BPtr& p1, ::Test::BPtr& p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_paramTest3(p1, p2, _iceI_begin_paramTest3(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_paramTest3(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_paramTest3(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_paramTest3(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_paramTest3(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_paramTest3(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_paramTest3(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_paramTest3(const ::Test::Callback_TestIntf_paramTest3Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_paramTest3(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_paramTest3(const ::Ice::Context& context, const ::Test::Callback_TestIntf_paramTest3Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_paramTest3(context, cb, cookie);
    }

    ::Test::BPtr end_paramTest3(::Test::BPtr& p1, ::Test::BPtr& p2, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_paramTest3(::Test::BPtr& iceP_p1, ::Test::BPtr& iceP_p2, ::Test::BPtr& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_paramTest3(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::BPtr paramTest4(::Test::BPtr& p, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_paramTest4(p, _iceI_begin_paramTest4(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_paramTest4(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_paramTest4(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_paramTest4(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_paramTest4(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_paramTest4(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_paramTest4(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_paramTest4(const ::Test::Callback_TestIntf_paramTest4Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_paramTest4(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_paramTest4(const ::Ice::Context& context, const ::Test::Callback_TestIntf_paramTest4Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_paramTest4(context, cb, cookie);
    }

    ::Test::BPtr end_paramTest4(::Test::BPtr& p, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_paramTest4(::Test::BPtr& iceP_p, ::Test::BPtr& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_paramTest4(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::BPtr returnTest1(::Test::BPtr& p1, ::Test::BPtr& p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_returnTest1(p1, p2, _iceI_begin_returnTest1(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_returnTest1(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_returnTest1(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_returnTest1(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_returnTest1(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_returnTest1(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_returnTest1(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_returnTest1(const ::Test::Callback_TestIntf_returnTest1Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_returnTest1(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_returnTest1(const ::Ice::Context& context, const ::Test::Callback_TestIntf_returnTest1Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_returnTest1(context, cb, cookie);
    }

    ::Test::BPtr end_returnTest1(::Test::BPtr& p1, ::Test::BPtr& p2, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_returnTest1(::Test::BPtr& iceP_p1, ::Test::BPtr& iceP_p2, ::Test::BPtr& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_returnTest1(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::BPtr returnTest2(::Test::BPtr& p2, ::Test::BPtr& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_returnTest2(p2, p1, _iceI_begin_returnTest2(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_returnTest2(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_returnTest2(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_returnTest2(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_returnTest2(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_returnTest2(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_returnTest2(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_returnTest2(const ::Test::Callback_TestIntf_returnTest2Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_returnTest2(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_returnTest2(const ::Ice::Context& context, const ::Test::Callback_TestIntf_returnTest2Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_returnTest2(context, cb, cookie);
    }

    ::Test::BPtr end_returnTest2(::Test::BPtr& p2, ::Test::BPtr& p1, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_returnTest2(::Test::BPtr& iceP_p2, ::Test::BPtr& iceP_p1, ::Test::BPtr& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_returnTest2(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::BPtr returnTest3(const ::Test::BPtr& p1, const ::Test::BPtr& p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_returnTest3(_iceI_begin_returnTest3(p1, p2, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_returnTest3(const ::Test::BPtr& p1, const ::Test::BPtr& p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_returnTest3(p1, p2, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_returnTest3(const ::Test::BPtr& p1, const ::Test::BPtr& p2, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_returnTest3(p1, p2, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_returnTest3(const ::Test::BPtr& p1, const ::Test::BPtr& p2, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_returnTest3(p1, p2, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_returnTest3(const ::Test::BPtr& p1, const ::Test::BPtr& p2, const ::Test::Callback_TestIntf_returnTest3Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_returnTest3(p1, p2, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_returnTest3(const ::Test::BPtr& p1, const ::Test::BPtr& p2, const ::Ice::Context& context, const ::Test::Callback_TestIntf_returnTest3Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_returnTest3(p1, p2, context, cb, cookie);
    }

    ::Test::BPtr end_returnTest3(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_returnTest3(const ::Test::BPtr&, const ::Test::BPtr&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::SS sequenceTest(const ::Test::SS1Ptr& p1, const ::Test::SS2Ptr& p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_sequenceTest(_iceI_begin_sequenceTest(p1, p2, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_sequenceTest(const ::Test::SS1Ptr& p1, const ::Test::SS2Ptr& p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_sequenceTest(p1, p2, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_sequenceTest(const ::Test::SS1Ptr& p1, const ::Test::SS2Ptr& p2, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_sequenceTest(p1, p2, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_sequenceTest(const ::Test::SS1Ptr& p1, const ::Test::SS2Ptr& p2, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_sequenceTest(p1, p2, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_sequenceTest(const ::Test::SS1Ptr& p1, const ::Test::SS2Ptr& p2, const ::Test::Callback_TestIntf_sequenceTestPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_sequenceTest(p1, p2, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_sequenceTest(const ::Test::SS1Ptr& p1, const ::Test::SS2Ptr& p2, const ::Ice::Context& context, const ::Test::Callback_TestIntf_sequenceTestPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_sequenceTest(p1, p2, context, cb, cookie);
    }

    ::Test::SS end_sequenceTest(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_sequenceTest(const ::Test::SS1Ptr&, const ::Test::SS2Ptr&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::BDict dictionaryTest(const ::Test::BDict& bin, ::Test::BDict& bout, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_dictionaryTest(bout, _iceI_begin_dictionaryTest(bin, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_dictionaryTest(const ::Test::BDict& bin, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_dictionaryTest(bin, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_dictionaryTest(const ::Test::BDict& bin, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_dictionaryTest(bin, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_dictionaryTest(const ::Test::BDict& bin, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_dictionaryTest(bin, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_dictionaryTest(const ::Test::BDict& bin, const ::Test::Callback_TestIntf_dictionaryTestPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_dictionaryTest(bin, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_dictionaryTest(const ::Test::BDict& bin, const ::Ice::Context& context, const ::Test::Callback_TestIntf_dictionaryTestPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_dictionaryTest(bin, context, cb, cookie);
    }

    ::Test::BDict end_dictionaryTest(::Test::BDict& bout, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_dictionaryTest(::Test::BDict& iceP_bout, ::Test::BDict& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_dictionaryTest(const ::Test::BDict&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::PBasePtr exchangePBase(const ::Test::PBasePtr& pb, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_exchangePBase(_iceI_begin_exchangePBase(pb, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_exchangePBase(const ::Test::PBasePtr& pb, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_exchangePBase(pb, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_exchangePBase(const ::Test::PBasePtr& pb, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_exchangePBase(pb, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_exchangePBase(const ::Test::PBasePtr& pb, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_exchangePBase(pb, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_exchangePBase(const ::Test::PBasePtr& pb, const ::Test::Callback_TestIntf_exchangePBasePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_exchangePBase(pb, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_exchangePBase(const ::Test::PBasePtr& pb, const ::Ice::Context& context, const ::Test::Callback_TestIntf_exchangePBasePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_exchangePBase(pb, context, cb, cookie);
    }

    ::Test::PBasePtr end_exchangePBase(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_exchangePBase(const ::Test::PBasePtr&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::PreservedPtr PBSUnknownAsPreserved(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_PBSUnknownAsPreserved(_iceI_begin_PBSUnknownAsPreserved(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_PBSUnknownAsPreserved(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_PBSUnknownAsPreserved(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_PBSUnknownAsPreserved(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_PBSUnknownAsPreserved(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_PBSUnknownAsPreserved(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_PBSUnknownAsPreserved(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_PBSUnknownAsPreserved(const ::Test::Callback_TestIntf_PBSUnknownAsPreservedPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_PBSUnknownAsPreserved(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_PBSUnknownAsPreserved(const ::Ice::Context& context, const ::Test::Callback_TestIntf_PBSUnknownAsPreservedPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_PBSUnknownAsPreserved(context, cb, cookie);
    }

    ::Test::PreservedPtr end_PBSUnknownAsPreserved(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_PBSUnknownAsPreserved(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void checkPBSUnknown(const ::Test::PreservedPtr& p, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_checkPBSUnknown(_iceI_begin_checkPBSUnknown(p, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_checkPBSUnknown(const ::Test::PreservedPtr& p, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_checkPBSUnknown(p, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_checkPBSUnknown(const ::Test::PreservedPtr& p, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_checkPBSUnknown(p, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_checkPBSUnknown(const ::Test::PreservedPtr& p, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_checkPBSUnknown(p, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_checkPBSUnknown(const ::Test::PreservedPtr& p, const ::Test::Callback_TestIntf_checkPBSUnknownPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_checkPBSUnknown(p, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_checkPBSUnknown(const ::Test::PreservedPtr& p, const ::Ice::Context& context, const ::Test::Callback_TestIntf_checkPBSUnknownPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_checkPBSUnknown(p, context, cb, cookie);
    }

    void end_checkPBSUnknown(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_checkPBSUnknown(const ::Test::PreservedPtr&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::PreservedPtr PBSUnknownAsPreservedWithGraph(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_PBSUnknownAsPreservedWithGraph(_iceI_begin_PBSUnknownAsPreservedWithGraph(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_PBSUnknownAsPreservedWithGraph(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_PBSUnknownAsPreservedWithGraph(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_PBSUnknownAsPreservedWithGraph(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_PBSUnknownAsPreservedWithGraph(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_PBSUnknownAsPreservedWithGraph(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_PBSUnknownAsPreservedWithGraph(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_PBSUnknownAsPreservedWithGraph(const ::Test::Callback_TestIntf_PBSUnknownAsPreservedWithGraphPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_PBSUnknownAsPreservedWithGraph(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_PBSUnknownAsPreservedWithGraph(const ::Ice::Context& context, const ::Test::Callback_TestIntf_PBSUnknownAsPreservedWithGraphPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_PBSUnknownAsPreservedWithGraph(context, cb, cookie);
    }

    ::Test::PreservedPtr end_PBSUnknownAsPreservedWithGraph(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_PBSUnknownAsPreservedWithGraph(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void checkPBSUnknownWithGraph(const ::Test::PreservedPtr& p, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_checkPBSUnknownWithGraph(_iceI_begin_checkPBSUnknownWithGraph(p, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_checkPBSUnknownWithGraph(const ::Test::PreservedPtr& p, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_checkPBSUnknownWithGraph(p, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_checkPBSUnknownWithGraph(const ::Test::PreservedPtr& p, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_checkPBSUnknownWithGraph(p, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_checkPBSUnknownWithGraph(const ::Test::PreservedPtr& p, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_checkPBSUnknownWithGraph(p, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_checkPBSUnknownWithGraph(const ::Test::PreservedPtr& p, const ::Test::Callback_TestIntf_checkPBSUnknownWithGraphPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_checkPBSUnknownWithGraph(p, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_checkPBSUnknownWithGraph(const ::Test::PreservedPtr& p, const ::Ice::Context& context, const ::Test::Callback_TestIntf_checkPBSUnknownWithGraphPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_checkPBSUnknownWithGraph(p, context, cb, cookie);
    }

    void end_checkPBSUnknownWithGraph(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_checkPBSUnknownWithGraph(const ::Test::PreservedPtr&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::PreservedPtr PBSUnknown2AsPreservedWithGraph(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_PBSUnknown2AsPreservedWithGraph(_iceI_begin_PBSUnknown2AsPreservedWithGraph(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_PBSUnknown2AsPreservedWithGraph(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_PBSUnknown2AsPreservedWithGraph(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_PBSUnknown2AsPreservedWithGraph(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_PBSUnknown2AsPreservedWithGraph(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_PBSUnknown2AsPreservedWithGraph(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_PBSUnknown2AsPreservedWithGraph(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_PBSUnknown2AsPreservedWithGraph(const ::Test::Callback_TestIntf_PBSUnknown2AsPreservedWithGraphPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_PBSUnknown2AsPreservedWithGraph(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_PBSUnknown2AsPreservedWithGraph(const ::Ice::Context& context, const ::Test::Callback_TestIntf_PBSUnknown2AsPreservedWithGraphPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_PBSUnknown2AsPreservedWithGraph(context, cb, cookie);
    }

    ::Test::PreservedPtr end_PBSUnknown2AsPreservedWithGraph(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_PBSUnknown2AsPreservedWithGraph(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void checkPBSUnknown2WithGraph(const ::Test::PreservedPtr& p, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_checkPBSUnknown2WithGraph(_iceI_begin_checkPBSUnknown2WithGraph(p, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_checkPBSUnknown2WithGraph(const ::Test::PreservedPtr& p, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_checkPBSUnknown2WithGraph(p, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_checkPBSUnknown2WithGraph(const ::Test::PreservedPtr& p, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_checkPBSUnknown2WithGraph(p, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_checkPBSUnknown2WithGraph(const ::Test::PreservedPtr& p, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_checkPBSUnknown2WithGraph(p, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_checkPBSUnknown2WithGraph(const ::Test::PreservedPtr& p, const ::Test::Callback_TestIntf_checkPBSUnknown2WithGraphPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_checkPBSUnknown2WithGraph(p, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_checkPBSUnknown2WithGraph(const ::Test::PreservedPtr& p, const ::Ice::Context& context, const ::Test::Callback_TestIntf_checkPBSUnknown2WithGraphPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_checkPBSUnknown2WithGraph(p, context, cb, cookie);
    }

    void end_checkPBSUnknown2WithGraph(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_checkPBSUnknown2WithGraph(const ::Test::PreservedPtr&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::PNodePtr exchangePNode(const ::Test::PNodePtr& pn, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_exchangePNode(_iceI_begin_exchangePNode(pn, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_exchangePNode(const ::Test::PNodePtr& pn, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_exchangePNode(pn, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_exchangePNode(const ::Test::PNodePtr& pn, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_exchangePNode(pn, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_exchangePNode(const ::Test::PNodePtr& pn, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_exchangePNode(pn, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_exchangePNode(const ::Test::PNodePtr& pn, const ::Test::Callback_TestIntf_exchangePNodePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_exchangePNode(pn, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_exchangePNode(const ::Test::PNodePtr& pn, const ::Ice::Context& context, const ::Test::Callback_TestIntf_exchangePNodePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_exchangePNode(pn, context, cb, cookie);
    }

    ::Test::PNodePtr end_exchangePNode(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_exchangePNode(const ::Test::PNodePtr&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void throwBaseAsBase(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_throwBaseAsBase(_iceI_begin_throwBaseAsBase(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_throwBaseAsBase(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_throwBaseAsBase(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_throwBaseAsBase(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwBaseAsBase(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwBaseAsBase(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwBaseAsBase(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwBaseAsBase(const ::Test::Callback_TestIntf_throwBaseAsBasePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwBaseAsBase(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwBaseAsBase(const ::Ice::Context& context, const ::Test::Callback_TestIntf_throwBaseAsBasePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwBaseAsBase(context, cb, cookie);
    }

    void end_throwBaseAsBase(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_throwBaseAsBase(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void throwDerivedAsBase(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_throwDerivedAsBase(_iceI_begin_throwDerivedAsBase(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_throwDerivedAsBase(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_throwDerivedAsBase(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_throwDerivedAsBase(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwDerivedAsBase(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwDerivedAsBase(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwDerivedAsBase(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwDerivedAsBase(const ::Test::Callback_TestIntf_throwDerivedAsBasePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwDerivedAsBase(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwDerivedAsBase(const ::Ice::Context& context, const ::Test::Callback_TestIntf_throwDerivedAsBasePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwDerivedAsBase(context, cb, cookie);
    }

    void end_throwDerivedAsBase(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_throwDerivedAsBase(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void throwDerivedAsDerived(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_throwDerivedAsDerived(_iceI_begin_throwDerivedAsDerived(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_throwDerivedAsDerived(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_throwDerivedAsDerived(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_throwDerivedAsDerived(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwDerivedAsDerived(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwDerivedAsDerived(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwDerivedAsDerived(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwDerivedAsDerived(const ::Test::Callback_TestIntf_throwDerivedAsDerivedPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwDerivedAsDerived(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwDerivedAsDerived(const ::Ice::Context& context, const ::Test::Callback_TestIntf_throwDerivedAsDerivedPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwDerivedAsDerived(context, cb, cookie);
    }

    void end_throwDerivedAsDerived(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_throwDerivedAsDerived(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void throwUnknownDerivedAsBase(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_throwUnknownDerivedAsBase(_iceI_begin_throwUnknownDerivedAsBase(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_throwUnknownDerivedAsBase(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_throwUnknownDerivedAsBase(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_throwUnknownDerivedAsBase(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwUnknownDerivedAsBase(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwUnknownDerivedAsBase(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwUnknownDerivedAsBase(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwUnknownDerivedAsBase(const ::Test::Callback_TestIntf_throwUnknownDerivedAsBasePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwUnknownDerivedAsBase(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwUnknownDerivedAsBase(const ::Ice::Context& context, const ::Test::Callback_TestIntf_throwUnknownDerivedAsBasePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwUnknownDerivedAsBase(context, cb, cookie);
    }

    void end_throwUnknownDerivedAsBase(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_throwUnknownDerivedAsBase(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void throwPreservedException(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_throwPreservedException(_iceI_begin_throwPreservedException(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_throwPreservedException(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_throwPreservedException(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_throwPreservedException(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwPreservedException(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwPreservedException(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwPreservedException(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwPreservedException(const ::Test::Callback_TestIntf_throwPreservedExceptionPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwPreservedException(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwPreservedException(const ::Ice::Context& context, const ::Test::Callback_TestIntf_throwPreservedExceptionPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwPreservedException(context, cb, cookie);
    }

    void end_throwPreservedException(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_throwPreservedException(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void useForward(::Test::ForwardPtr& f, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_useForward(f, _iceI_begin_useForward(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_useForward(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_useForward(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_useForward(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_useForward(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_useForward(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_useForward(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_useForward(const ::Test::Callback_TestIntf_useForwardPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_useForward(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_useForward(const ::Ice::Context& context, const ::Test::Callback_TestIntf_useForwardPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_useForward(context, cb, cookie);
    }

    void end_useForward(::Test::ForwardPtr& f, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_useForward(::Test::ForwardPtr& iceP_f, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_useForward(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void shutdown(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_shutdown(_iceI_begin_shutdown(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_shutdown(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_shutdown(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_shutdown(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_shutdown(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_shutdown(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_shutdown(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_shutdown(const ::Test::Callback_TestIntf_shutdownPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_shutdown(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_shutdown(const ::Ice::Context& context, const ::Test::Callback_TestIntf_shutdownPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_shutdown(context, cb, cookie);
    }

    void end_shutdown(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_shutdown(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class Hidden : public virtual ::Ice::Proxy<Hidden, ::IceProxy::Ice::Object>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class Forward : public virtual ::Ice::Proxy<Forward, ::IceProxy::Ice::Object>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class SBSUnknownDerived : public virtual ::Ice::Proxy<SBSUnknownDerived, ::IceProxy::Test::SBase>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class SUnknown : public virtual ::Ice::Proxy<SUnknown, ::IceProxy::Ice::Object>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class D2 : public virtual ::Ice::Proxy<D2, ::IceProxy::Test::B>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class D4 : public virtual ::Ice::Proxy<D4, ::IceProxy::Test::B>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

}

}

namespace Test
{

class SBase : public virtual ::Ice::Object
{
public:

    typedef SBasePrx ProxyType;
    typedef SBasePtr PointerType;

    virtual ~SBase();

    SBase()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit SBase(const ::std::string& sb) :
        sb(sb)
    {
    }

#ifdef ICE_CPP11_COMPILER
    SBase(const SBase&) = default;
    SBase& operator=(const SBase&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    ::std::string sb;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_SBase_init = ::Test::SBase::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const SBase& lhs, const SBase& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const SBase& lhs, const SBase& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class SBSKnownDerived : public SBase
{
public:

    typedef SBSKnownDerivedPrx ProxyType;
    typedef SBSKnownDerivedPtr PointerType;

    virtual ~SBSKnownDerived();

    SBSKnownDerived()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    SBSKnownDerived(const ::std::string& sb, const ::std::string& sbskd) :
        ::Test::SBase(sb),
        sbskd(sbskd)
    {
    }

#ifdef ICE_CPP11_COMPILER
    SBSKnownDerived(const SBSKnownDerived&) = default;
    SBSKnownDerived& operator=(const SBSKnownDerived&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    ::std::string sbskd;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_SBSKnownDerived_init = ::Test::SBSKnownDerived::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const SBSKnownDerived& lhs, const SBSKnownDerived& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const SBSKnownDerived& lhs, const SBSKnownDerived& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class B : public virtual ::Ice::Object, public ::IceInternal::GCObject
{
public:

    typedef BPrx ProxyType;
    typedef BPtr PointerType;

    virtual ~B();

    B()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    B(const ::std::string& sb, const ::Test::BPtr& pb) :
        sb(sb),
        pb(pb)
    {
    }

#ifdef ICE_CPP11_COMPILER
    B(const B&) = default;
    B& operator=(const B&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();
    /// \cond INTERNAL
    virtual void _iceGcVisitMembers(::IceInternal::GCVisitor&);
    /// \endcond

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    ::std::string sb;
    ::Test::BPtr pb;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_B_init = ::Test::B::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const B& lhs, const B& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const B& lhs, const B& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class D1 : public B
{
public:

    typedef D1Prx ProxyType;
    typedef D1Ptr PointerType;

    virtual ~D1();

    D1()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    D1(const ::std::string& sb, const ::Test::BPtr& pb, const ::std::string& sd1, const ::Test::BPtr& pd1) :
        ::Test::B(sb, pb),
        sd1(sd1),
        pd1(pd1)
    {
    }

#ifdef ICE_CPP11_COMPILER
    D1(const D1&) = default;
    D1& operator=(const D1&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();
    /// \cond INTERNAL
    virtual void _iceGcVisitMembers(::IceInternal::GCVisitor&);
    /// \endcond

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    ::std::string sd1;
    ::Test::BPtr pd1;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_D1_init = ::Test::D1::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const D1& lhs, const D1& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const D1& lhs, const D1& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class SS1 : public virtual ::Ice::Object, public ::IceInternal::GCObject
{
public:

    typedef SS1Prx ProxyType;
    typedef SS1Ptr PointerType;

    virtual ~SS1();

    SS1()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit SS1(const ::Test::BSeq& s) :
        s(s)
    {
    }

#ifdef ICE_CPP11_COMPILER
    SS1(const SS1&) = default;
    SS1& operator=(const SS1&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();
    /// \cond INTERNAL
    virtual void _iceGcVisitMembers(::IceInternal::GCVisitor&);
    /// \endcond

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    ::Test::BSeq s;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_SS1_init = ::Test::SS1::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const SS1& lhs, const SS1& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const SS1& lhs, const SS1& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class SS2 : public virtual ::Ice::Object, public ::IceInternal::GCObject
{
public:

    typedef SS2Prx ProxyType;
    typedef SS2Ptr PointerType;

    virtual ~SS2();

    SS2()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit SS2(const ::Test::BSeq& s) :
        s(s)
    {
    }

#ifdef ICE_CPP11_COMPILER
    SS2(const SS2&) = default;
    SS2& operator=(const SS2&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();
    /// \cond INTERNAL
    virtual void _iceGcVisitMembers(::IceInternal::GCVisitor&);
    /// \endcond

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    ::Test::BSeq s;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_SS2_init = ::Test::SS2::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const SS2& lhs, const SS2& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const SS2& lhs, const SS2& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class PBase : public virtual ::Ice::Object
{
public:

    typedef PBasePrx ProxyType;
    typedef PBasePtr PointerType;

    virtual ~PBase();

    PBase()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit PBase(::Ice::Int pi) :
        pi(pi)
    {
    }

#ifdef ICE_CPP11_COMPILER
    PBase(const PBase&) = default;
    PBase& operator=(const PBase&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    ::Ice::Int pi;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_PBase_init = ::Test::PBase::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const PBase& lhs, const PBase& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const PBase& lhs, const PBase& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class Preserved : public PBase, public ::IceInternal::GCObject
{
public:

    typedef PreservedPrx ProxyType;
    typedef PreservedPtr PointerType;

    virtual ~Preserved();

    Preserved()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    Preserved(::Ice::Int pi, const ::std::string& ps) :
        ::Test::PBase(pi),
        ps(ps)
    {
    }

#ifdef ICE_CPP11_COMPILER
    Preserved(const Preserved&) = default;
    Preserved& operator=(const Preserved&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();
    /// \cond INTERNAL
    virtual void _iceGcVisitMembers(::IceInternal::GCVisitor&);
    /// \endcond

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

    /**
     * Obtains the SlicedData object created when an unknown class type was marshaled
     * in the sliced format and the Ice run time sliced it to a known type.
     * @return The SlicedData object, or nil if the class was not sliced or was not
     * marshaled in the sliced format.
     */
    virtual ::Ice::SlicedDataPtr ice_getSlicedData() const;

    /// \cond STREAM
    virtual void _iceWrite(::Ice::OutputStream*) const;
    virtual void _iceRead(::Ice::InputStream*);
    /// \endcond

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    ::std::string ps;

protected:

    /// \cond STREAM
    ::Ice::SlicedDataPtr _iceSlicedData;
    /// \endcond
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_Preserved_init = ::Test::Preserved::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const Preserved& lhs, const Preserved& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const Preserved& lhs, const Preserved& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class PDerived : public Preserved
{
public:

    typedef PDerivedPrx ProxyType;
    typedef PDerivedPtr PointerType;

    virtual ~PDerived();

    PDerived()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    PDerived(::Ice::Int pi, const ::std::string& ps, const ::Test::PBasePtr& pb) :
        ::Test::Preserved(pi, ps),
        pb(pb)
    {
    }

#ifdef ICE_CPP11_COMPILER
    PDerived(const PDerived&) = default;
    PDerived& operator=(const PDerived&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();
    /// \cond INTERNAL
    virtual void _iceGcVisitMembers(::IceInternal::GCVisitor&);
    /// \endcond

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    ::Test::PBasePtr pb;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_PDerived_init = ::Test::PDerived::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const PDerived& lhs, const PDerived& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const PDerived& lhs, const PDerived& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class CompactPDerived : public Preserved
{
public:

    typedef CompactPDerivedPrx ProxyType;
    typedef CompactPDerivedPtr PointerType;

    virtual ~CompactPDerived();

    CompactPDerived()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    CompactPDerived(::Ice::Int pi, const ::std::string& ps, const ::Test::PBasePtr& pb) :
        ::Test::Preserved(pi, ps),
        pb(pb)
    {
    }

#ifdef ICE_CPP11_COMPILER
    CompactPDerived(const CompactPDerived&) = default;
    CompactPDerived& operator=(const CompactPDerived&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();
    /// \cond INTERNAL
    virtual void _iceGcVisitMembers(::IceInternal::GCVisitor&);
    /// \endcond

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    ::Test::PBasePtr pb;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_CompactPDerived_init = ::Test::CompactPDerived::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const CompactPDerived& lhs, const CompactPDerived& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const CompactPDerived& lhs, const CompactPDerived& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class PNode : public virtual ::Ice::Object, public ::IceInternal::GCObject
{
public:

    typedef PNodePrx ProxyType;
    typedef PNodePtr PointerType;

    virtual ~PNode();

    PNode()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit PNode(const ::Test::PNodePtr& next) :
        next(next)
    {
    }

#ifdef ICE_CPP11_COMPILER
    PNode(const PNode&) = default;
    PNode& operator=(const PNode&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();
    /// \cond INTERNAL
    virtual void _iceGcVisitMembers(::IceInternal::GCVisitor&);
    /// \endcond

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

    /**
     * Obtains the SlicedData object created when an unknown class type was marshaled
     * in the sliced format and the Ice run time sliced it to a known type.
     * @return The SlicedData object, or nil if the class was not sliced or was not
     * marshaled in the sliced format.
     */
    virtual ::Ice::SlicedDataPtr ice_getSlicedData() const;

    /// \cond STREAM
    virtual void _iceWrite(::Ice::OutputStream*) const;
    virtual void _iceRead(::Ice::InputStream*);
    /// \endcond

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    ::Test::PNodePtr next;

protected:

    /// \cond STREAM
    ::Ice::SlicedDataPtr _iceSlicedData;
    /// \endcond
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_PNode_init = ::Test::PNode::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const PNode& lhs, const PNode& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const PNode& lhs, const PNode& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class MyClass : public virtual ::Ice::Object
{
public:

    typedef MyClassPrx ProxyType;
    typedef MyClassPtr PointerType;

    virtual ~MyClass();

    MyClass()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit MyClass(::Ice::Int i) :
        i(i)
    {
    }

#ifdef ICE_CPP11_COMPILER
    MyClass(const MyClass&) = default;
    MyClass& operator=(const MyClass&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    ::Ice::Int i;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_MyClass_init = ::Test::MyClass::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const MyClass& lhs, const MyClass& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const MyClass& lhs, const MyClass& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class PSUnknown : public Preserved
{
public:

    typedef PSUnknownPrx ProxyType;
    typedef PSUnknownPtr PointerType;

    virtual ~PSUnknown();

    PSUnknown()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    PSUnknown(::Ice::Int pi, const ::std::string& ps, const ::std::string& psu, const ::Test::PNodePtr& graph, const ::Test::MyClassPtr& cl) :
        ::Test::Preserved(pi, ps),
        psu(psu),
        graph(graph),
        cl(cl)
    {
    }

#ifdef ICE_CPP11_COMPILER
    PSUnknown(const PSUnknown&) = default;
    PSUnknown& operator=(const PSUnknown&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();
    /// \cond INTERNAL
    virtual void _iceGcVisitMembers(::IceInternal::GCVisitor&);
    /// \endcond

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    ::std::string psu;
    ::Test::PNodePtr graph;
    ::Test::MyClassPtr cl;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_PSUnknown_init = ::Test::PSUnknown::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const PSUnknown& lhs, const PSUnknown& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const PSUnknown& lhs, const PSUnknown& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class PSUnknown2 : public Preserved
{
public:

    typedef PSUnknown2Prx ProxyType;
    typedef PSUnknown2Ptr PointerType;

    virtual ~PSUnknown2();

    PSUnknown2()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    PSUnknown2(::Ice::Int pi, const ::std::string& ps, const ::Test::PBasePtr& pb) :
        ::Test::Preserved(pi, ps),
        pb(pb)
    {
    }

#ifdef ICE_CPP11_COMPILER
    PSUnknown2(const PSUnknown2&) = default;
    PSUnknown2& operator=(const PSUnknown2&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();
    /// \cond INTERNAL
    virtual void _iceGcVisitMembers(::IceInternal::GCVisitor&);
    /// \endcond

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    ::Test::PBasePtr pb;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_PSUnknown2_init = ::Test::PSUnknown2::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const PSUnknown2& lhs, const PSUnknown2& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const PSUnknown2& lhs, const PSUnknown2& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class TestIntf : public virtual ::Ice::Object
{
public:

    typedef TestIntfPrx ProxyType;
    typedef TestIntfPtr PointerType;

    virtual ~TestIntf();

#ifdef ICE_CPP11_COMPILER
    TestIntf() = default;
    TestIntf(const TestIntf&) = default;
    TestIntf& operator=(const TestIntf&) = default;
#endif

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual ::Ice::ObjectPtr SBaseAsObject(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_SBaseAsObject(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual SBasePtr SBaseAsSBase(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_SBaseAsSBase(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual SBasePtr SBSKnownDerivedAsSBase(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_SBSKnownDerivedAsSBase(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual SBSKnownDerivedPtr SBSKnownDerivedAsSBSKnownDerived(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_SBSKnownDerivedAsSBSKnownDerived(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual SBasePtr SBSUnknownDerivedAsSBase(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_SBSUnknownDerivedAsSBase(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual SBasePtr SBSUnknownDerivedAsSBaseCompact(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_SBSUnknownDerivedAsSBaseCompact(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::Ice::ObjectPtr SUnknownAsObject(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_SUnknownAsObject(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void checkSUnknown(const ::Ice::ObjectPtr& o, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_checkSUnknown(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual BPtr oneElementCycle(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_oneElementCycle(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual BPtr twoElementCycle(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_twoElementCycle(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual BPtr D1AsB(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_D1AsB(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual D1Ptr D1AsD1(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_D1AsD1(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual BPtr D2AsB(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_D2AsB(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void paramTest1(BPtr& p1, BPtr& p2, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_paramTest1(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void paramTest2(BPtr& p2, BPtr& p1, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_paramTest2(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual BPtr paramTest3(BPtr& p1, BPtr& p2, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_paramTest3(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual BPtr paramTest4(BPtr& p, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_paramTest4(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual BPtr returnTest1(BPtr& p1, BPtr& p2, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_returnTest1(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual BPtr returnTest2(BPtr& p2, BPtr& p1, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_returnTest2(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual BPtr returnTest3(const BPtr& p1, const BPtr& p2, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_returnTest3(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual SS sequenceTest(const SS1Ptr& p1, const SS2Ptr& p2, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_sequenceTest(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual BDict dictionaryTest(const BDict& bin, BDict& bout, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_dictionaryTest(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual PBasePtr exchangePBase(const PBasePtr& pb, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_exchangePBase(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual PreservedPtr PBSUnknownAsPreserved(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_PBSUnknownAsPreserved(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void checkPBSUnknown(const PreservedPtr& p, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_checkPBSUnknown(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual PreservedPtr PBSUnknownAsPreservedWithGraph(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_PBSUnknownAsPreservedWithGraph(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void checkPBSUnknownWithGraph(const PreservedPtr& p, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_checkPBSUnknownWithGraph(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual PreservedPtr PBSUnknown2AsPreservedWithGraph(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_PBSUnknown2AsPreservedWithGraph(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void checkPBSUnknown2WithGraph(const PreservedPtr& p, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_checkPBSUnknown2WithGraph(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual PNodePtr exchangePNode(const PNodePtr& pn, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_exchangePNode(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void throwBaseAsBase(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_throwBaseAsBase(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void throwDerivedAsBase(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_throwDerivedAsBase(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void throwDerivedAsDerived(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_throwDerivedAsDerived(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void throwUnknownDerivedAsBase(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_throwUnknownDerivedAsBase(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void throwPreservedException_async(const ::Test::AMD_TestIntf_throwPreservedExceptionPtr& cb, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_throwPreservedException(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void useForward(ForwardPtr& f, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_useForward(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void shutdown(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_shutdown(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
inline bool operator==(const TestIntf& lhs, const TestIntf& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const TestIntf& lhs, const TestIntf& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class Hidden : public virtual ::Ice::Object, public ::IceInternal::GCObject
{
public:

    typedef HiddenPrx ProxyType;
    typedef HiddenPtr PointerType;

    virtual ~Hidden();

    Hidden()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit Hidden(const ::Test::ForwardPtr& f) :
        f(f)
    {
    }

#ifdef ICE_CPP11_COMPILER
    Hidden(const Hidden&) = default;
    Hidden& operator=(const Hidden&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();
    /// \cond INTERNAL
    virtual void _iceGcVisitMembers(::IceInternal::GCVisitor&);
    /// \endcond

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    ::Test::ForwardPtr f;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_Hidden_init = ::Test::Hidden::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const Hidden& lhs, const Hidden& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const Hidden& lhs, const Hidden& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class Forward : public virtual ::Ice::Object, public ::IceInternal::GCObject
{
public:

    typedef ForwardPrx ProxyType;
    typedef ForwardPtr PointerType;

    virtual ~Forward();

    Forward()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit Forward(const ::Test::HiddenPtr& h) :
        h(h)
    {
    }

#ifdef ICE_CPP11_COMPILER
    Forward(const Forward&) = default;
    Forward& operator=(const Forward&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();
    /// \cond INTERNAL
    virtual void _iceGcVisitMembers(::IceInternal::GCVisitor&);
    /// \endcond

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    ::Test::HiddenPtr h;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_Forward_init = ::Test::Forward::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const Forward& lhs, const Forward& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const Forward& lhs, const Forward& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class SBSUnknownDerived : public SBase
{
public:

    typedef SBSUnknownDerivedPrx ProxyType;
    typedef SBSUnknownDerivedPtr PointerType;

    virtual ~SBSUnknownDerived();

    SBSUnknownDerived()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    SBSUnknownDerived(const ::std::string& sb, const ::std::string& sbsud) :
        ::Test::SBase(sb),
        sbsud(sbsud)
    {
    }

#ifdef ICE_CPP11_COMPILER
    SBSUnknownDerived(const SBSUnknownDerived&) = default;
    SBSUnknownDerived& operator=(const SBSUnknownDerived&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    ::std::string sbsud;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_SBSUnknownDerived_init = ::Test::SBSUnknownDerived::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const SBSUnknownDerived& lhs, const SBSUnknownDerived& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const SBSUnknownDerived& lhs, const SBSUnknownDerived& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class SUnknown : public virtual ::Ice::Object, public ::IceInternal::GCObject
{
public:

    typedef SUnknownPrx ProxyType;
    typedef SUnknownPtr PointerType;

    virtual ~SUnknown();

    SUnknown()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    SUnknown(const ::std::string& su, const ::Test::SUnknownPtr& cycle) :
        su(su),
        cycle(cycle)
    {
    }

#ifdef ICE_CPP11_COMPILER
    SUnknown(const SUnknown&) = default;
    SUnknown& operator=(const SUnknown&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();
    /// \cond INTERNAL
    virtual void _iceGcVisitMembers(::IceInternal::GCVisitor&);
    /// \endcond

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    ::std::string su;
    ::Test::SUnknownPtr cycle;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_SUnknown_init = ::Test::SUnknown::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const SUnknown& lhs, const SUnknown& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const SUnknown& lhs, const SUnknown& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class D2 : public B
{
public:

    typedef D2Prx ProxyType;
    typedef D2Ptr PointerType;

    virtual ~D2();

    D2()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    D2(const ::std::string& sb, const ::Test::BPtr& pb, const ::std::string& sd2, const ::Test::BPtr& pd2) :
        ::Test::B(sb, pb),
        sd2(sd2),
        pd2(pd2)
    {
    }

#ifdef ICE_CPP11_COMPILER
    D2(const D2&) = default;
    D2& operator=(const D2&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();
    /// \cond INTERNAL
    virtual void _iceGcVisitMembers(::IceInternal::GCVisitor&);
    /// \endcond

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    ::std::string sd2;
    ::Test::BPtr pd2;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_D2_init = ::Test::D2::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const D2& lhs, const D2& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const D2& lhs, const D2& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class D4 : public B
{
public:

    typedef D4Prx ProxyType;
    typedef D4Ptr PointerType;

    virtual ~D4();

    D4()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    D4(const ::std::string& sb, const ::Test::BPtr& pb, const ::Test::BPtr& p1, const ::Test::BPtr& p2) :
        ::Test::B(sb, pb),
        p1(p1),
        p2(p2)
    {
    }

#ifdef ICE_CPP11_COMPILER
    D4(const D4&) = default;
    D4& operator=(const D4&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();
    /// \cond INTERNAL
    virtual void _iceGcVisitMembers(::IceInternal::GCVisitor&);
    /// \endcond

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    ::Test::BPtr p1;
    ::Test::BPtr p2;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_D4_init = ::Test::D4::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const D4& lhs, const D4& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const D4& lhs, const D4& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

}

/// \cond STREAM
namespace Ice
{

template<typename S>
struct StreamWriter< ::Test::SBase, S>
{
    static void write(S* ostr, const ::Test::SBase& v)
    {
        ostr->write(v.sb);
    }
};

template<typename S>
struct StreamReader< ::Test::SBase, S>
{
    static void read(S* istr, ::Test::SBase& v)
    {
        istr->read(v.sb);
    }
};

template<typename S>
struct StreamWriter< ::Test::SBSKnownDerived, S>
{
    static void write(S* ostr, const ::Test::SBSKnownDerived& v)
    {
        ostr->write(v.sbskd);
    }
};

template<typename S>
struct StreamReader< ::Test::SBSKnownDerived, S>
{
    static void read(S* istr, ::Test::SBSKnownDerived& v)
    {
        istr->read(v.sbskd);
    }
};

template<typename S>
struct StreamWriter< ::Test::B, S>
{
    static void write(S* ostr, const ::Test::B& v)
    {
        ostr->write(v.sb);
        ostr->write(v.pb);
    }
};

template<typename S>
struct StreamReader< ::Test::B, S>
{
    static void read(S* istr, ::Test::B& v)
    {
        istr->read(v.sb);
        istr->read(v.pb);
    }
};

template<typename S>
struct StreamWriter< ::Test::D1, S>
{
    static void write(S* ostr, const ::Test::D1& v)
    {
        ostr->write(v.sd1);
        ostr->write(v.pd1);
    }
};

template<typename S>
struct StreamReader< ::Test::D1, S>
{
    static void read(S* istr, ::Test::D1& v)
    {
        istr->read(v.sd1);
        istr->read(v.pd1);
    }
};

template<typename S>
struct StreamWriter< ::Test::SS1, S>
{
    static void write(S* ostr, const ::Test::SS1& v)
    {
        ostr->write(v.s);
    }
};

template<typename S>
struct StreamReader< ::Test::SS1, S>
{
    static void read(S* istr, ::Test::SS1& v)
    {
        istr->read(v.s);
    }
};

template<typename S>
struct StreamWriter< ::Test::SS2, S>
{
    static void write(S* ostr, const ::Test::SS2& v)
    {
        ostr->write(v.s);
    }
};

template<typename S>
struct StreamReader< ::Test::SS2, S>
{
    static void read(S* istr, ::Test::SS2& v)
    {
        istr->read(v.s);
    }
};

template<>
struct StreamableTraits< ::Test::SS>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 2;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::Test::SS, S>
{
    static void write(S* ostr, const ::Test::SS& v)
    {
        ostr->write(v.c1);
        ostr->write(v.c2);
    }
};

template<typename S>
struct StreamReader< ::Test::SS, S>
{
    static void read(S* istr, ::Test::SS& v)
    {
        istr->read(v.c1);
        istr->read(v.c2);
    }
};

template<>
struct StreamableTraits< ::Test::BaseException>
{
    static const StreamHelperCategory helper = StreamHelperCategoryUserException;
};

template<typename S>
struct StreamWriter< ::Test::BaseException, S>
{
    static void write(S* ostr, const ::Test::BaseException& v)
    {
        ostr->write(v.sbe);
        ostr->write(v.pb);
    }
};

template<typename S>
struct StreamReader< ::Test::BaseException, S>
{
    static void read(S* istr, ::Test::BaseException& v)
    {
        istr->read(v.sbe);
        istr->read(v.pb);
    }
};

template<>
struct StreamableTraits< ::Test::DerivedException>
{
    static const StreamHelperCategory helper = StreamHelperCategoryUserException;
};

template<typename S>
struct StreamWriter< ::Test::DerivedException, S>
{
    static void write(S* ostr, const ::Test::DerivedException& v)
    {
        ostr->write(v.sde);
        ostr->write(v.pd1);
    }
};

template<typename S>
struct StreamReader< ::Test::DerivedException, S>
{
    static void read(S* istr, ::Test::DerivedException& v)
    {
        istr->read(v.sde);
        istr->read(v.pd1);
    }
};

template<typename S>
struct StreamWriter< ::Test::PBase, S>
{
    static void write(S* ostr, const ::Test::PBase& v)
    {
        ostr->write(v.pi);
    }
};

template<typename S>
struct StreamReader< ::Test::PBase, S>
{
    static void read(S* istr, ::Test::PBase& v)
    {
        istr->read(v.pi);
    }
};

template<typename S>
struct StreamWriter< ::Test::Preserved, S>
{
    static void write(S* ostr, const ::Test::Preserved& v)
    {
        ostr->write(v.ps);
    }
};

template<typename S>
struct StreamReader< ::Test::Preserved, S>
{
    static void read(S* istr, ::Test::Preserved& v)
    {
        istr->read(v.ps);
    }
};

template<typename S>
struct StreamWriter< ::Test::PDerived, S>
{
    static void write(S* ostr, const ::Test::PDerived& v)
    {
        ostr->write(v.pb);
    }
};

template<typename S>
struct StreamReader< ::Test::PDerived, S>
{
    static void read(S* istr, ::Test::PDerived& v)
    {
        istr->read(v.pb);
    }
};

template<typename S>
struct StreamWriter< ::Test::CompactPDerived, S>
{
    static void write(S* ostr, const ::Test::CompactPDerived& v)
    {
        ostr->write(v.pb);
    }
};

template<typename S>
struct StreamReader< ::Test::CompactPDerived, S>
{
    static void read(S* istr, ::Test::CompactPDerived& v)
    {
        istr->read(v.pb);
    }
};

template<typename S>
struct StreamWriter< ::Test::PNode, S>
{
    static void write(S* ostr, const ::Test::PNode& v)
    {
        ostr->write(v.next);
    }
};

template<typename S>
struct StreamReader< ::Test::PNode, S>
{
    static void read(S* istr, ::Test::PNode& v)
    {
        istr->read(v.next);
    }
};

template<typename S>
struct StreamWriter< ::Test::MyClass, S>
{
    static void write(S* ostr, const ::Test::MyClass& v)
    {
        ostr->write(v.i);
    }
};

template<typename S>
struct StreamReader< ::Test::MyClass, S>
{
    static void read(S* istr, ::Test::MyClass& v)
    {
        istr->read(v.i);
    }
};

template<typename S>
struct StreamWriter< ::Test::PSUnknown, S>
{
    static void write(S* ostr, const ::Test::PSUnknown& v)
    {
        ostr->write(v.psu);
        ostr->write(v.graph);
        ostr->write(v.cl);
    }
};

template<typename S>
struct StreamReader< ::Test::PSUnknown, S>
{
    static void read(S* istr, ::Test::PSUnknown& v)
    {
        istr->read(v.psu);
        istr->read(v.graph);
        istr->read(v.cl);
    }
};

template<typename S>
struct StreamWriter< ::Test::PSUnknown2, S>
{
    static void write(S* ostr, const ::Test::PSUnknown2& v)
    {
        ostr->write(v.pb);
    }
};

template<typename S>
struct StreamReader< ::Test::PSUnknown2, S>
{
    static void read(S* istr, ::Test::PSUnknown2& v)
    {
        istr->read(v.pb);
    }
};

template<>
struct StreamableTraits< ::Test::PreservedException>
{
    static const StreamHelperCategory helper = StreamHelperCategoryUserException;
};

template<>
struct StreamableTraits< ::Test::PSUnknownException>
{
    static const StreamHelperCategory helper = StreamHelperCategoryUserException;
};

template<typename S>
struct StreamWriter< ::Test::PSUnknownException, S>
{
    static void write(S* ostr, const ::Test::PSUnknownException& v)
    {
        ostr->write(v.p);
    }
};

template<typename S>
struct StreamReader< ::Test::PSUnknownException, S>
{
    static void read(S* istr, ::Test::PSUnknownException& v)
    {
        istr->read(v.p);
    }
};

template<typename S>
struct StreamWriter< ::Test::Hidden, S>
{
    static void write(S* ostr, const ::Test::Hidden& v)
    {
        ostr->write(v.f);
    }
};

template<typename S>
struct StreamReader< ::Test::Hidden, S>
{
    static void read(S* istr, ::Test::Hidden& v)
    {
        istr->read(v.f);
    }
};

template<typename S>
struct StreamWriter< ::Test::Forward, S>
{
    static void write(S* ostr, const ::Test::Forward& v)
    {
        ostr->write(v.h);
    }
};

template<typename S>
struct StreamReader< ::Test::Forward, S>
{
    static void read(S* istr, ::Test::Forward& v)
    {
        istr->read(v.h);
    }
};

template<typename S>
struct StreamWriter< ::Test::SBSUnknownDerived, S>
{
    static void write(S* ostr, const ::Test::SBSUnknownDerived& v)
    {
        ostr->write(v.sbsud);
    }
};

template<typename S>
struct StreamReader< ::Test::SBSUnknownDerived, S>
{
    static void read(S* istr, ::Test::SBSUnknownDerived& v)
    {
        istr->read(v.sbsud);
    }
};

template<typename S>
struct StreamWriter< ::Test::SUnknown, S>
{
    static void write(S* ostr, const ::Test::SUnknown& v)
    {
        ostr->write(v.su);
        ostr->write(v.cycle);
    }
};

template<typename S>
struct StreamReader< ::Test::SUnknown, S>
{
    static void read(S* istr, ::Test::SUnknown& v)
    {
        istr->read(v.su);
        istr->read(v.cycle);
    }
};

template<typename S>
struct StreamWriter< ::Test::D2, S>
{
    static void write(S* ostr, const ::Test::D2& v)
    {
        ostr->write(v.sd2);
        ostr->write(v.pd2);
    }
};

template<typename S>
struct StreamReader< ::Test::D2, S>
{
    static void read(S* istr, ::Test::D2& v)
    {
        istr->read(v.sd2);
        istr->read(v.pd2);
    }
};

template<typename S>
struct StreamWriter< ::Test::D4, S>
{
    static void write(S* ostr, const ::Test::D4& v)
    {
        ostr->write(v.p1);
        ostr->write(v.p2);
    }
};

template<typename S>
struct StreamReader< ::Test::D4, S>
{
    static void read(S* istr, ::Test::D4& v)
    {
        istr->read(v.p1);
        istr->read(v.p2);
    }
};

template<>
struct StreamableTraits< ::Test::UnknownDerivedException>
{
    static const StreamHelperCategory helper = StreamHelperCategoryUserException;
};

template<typename S>
struct StreamWriter< ::Test::UnknownDerivedException, S>
{
    static void write(S* ostr, const ::Test::UnknownDerivedException& v)
    {
        ostr->write(v.sude);
        ostr->write(v.pd2);
    }
};

template<typename S>
struct StreamReader< ::Test::UnknownDerivedException, S>
{
    static void read(S* istr, ::Test::UnknownDerivedException& v)
    {
        istr->read(v.sude);
        istr->read(v.pd2);
    }
};

}
/// \endcond

namespace Test
{

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_SBaseAsObject.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_SBaseAsObject.
 */
template<class T>
class CallbackNC_TestIntf_SBaseAsObject : public Callback_TestIntf_SBaseAsObject_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Ice::ObjectPtr&);

    CallbackNC_TestIntf_SBaseAsObject(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        ::Ice::ObjectPtr ret;
        try
        {
            ret = proxy->end_SBaseAsObject(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_SBaseAsObject.
 */
template<class T> Callback_TestIntf_SBaseAsObjectPtr
newCallback_TestIntf_SBaseAsObject(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Ice::ObjectPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_SBaseAsObject<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_SBaseAsObject.
 */
template<class T> Callback_TestIntf_SBaseAsObjectPtr
newCallback_TestIntf_SBaseAsObject(T* instance, void (T::*cb)(const ::Ice::ObjectPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_SBaseAsObject<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_SBaseAsObject.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_SBaseAsObject.
 */
template<class T, typename CT>
class Callback_TestIntf_SBaseAsObject : public Callback_TestIntf_SBaseAsObject_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Ice::ObjectPtr&, const CT&);

    Callback_TestIntf_SBaseAsObject(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        ::Ice::ObjectPtr ret;
        try
        {
            ret = proxy->end_SBaseAsObject(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_SBaseAsObject.
 */
template<class T, typename CT> Callback_TestIntf_SBaseAsObjectPtr
newCallback_TestIntf_SBaseAsObject(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Ice::ObjectPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_SBaseAsObject<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_SBaseAsObject.
 */
template<class T, typename CT> Callback_TestIntf_SBaseAsObjectPtr
newCallback_TestIntf_SBaseAsObject(T* instance, void (T::*cb)(const ::Ice::ObjectPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_SBaseAsObject<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_SBaseAsSBase.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_SBaseAsSBase.
 */
template<class T>
class CallbackNC_TestIntf_SBaseAsSBase : public Callback_TestIntf_SBaseAsSBase_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const SBasePtr&);

    CallbackNC_TestIntf_SBaseAsSBase(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        SBasePtr ret;
        try
        {
            ret = proxy->end_SBaseAsSBase(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_SBaseAsSBase.
 */
template<class T> Callback_TestIntf_SBaseAsSBasePtr
newCallback_TestIntf_SBaseAsSBase(const IceUtil::Handle<T>& instance, void (T::*cb)(const SBasePtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_SBaseAsSBase<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_SBaseAsSBase.
 */
template<class T> Callback_TestIntf_SBaseAsSBasePtr
newCallback_TestIntf_SBaseAsSBase(T* instance, void (T::*cb)(const SBasePtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_SBaseAsSBase<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_SBaseAsSBase.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_SBaseAsSBase.
 */
template<class T, typename CT>
class Callback_TestIntf_SBaseAsSBase : public Callback_TestIntf_SBaseAsSBase_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const SBasePtr&, const CT&);

    Callback_TestIntf_SBaseAsSBase(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        SBasePtr ret;
        try
        {
            ret = proxy->end_SBaseAsSBase(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_SBaseAsSBase.
 */
template<class T, typename CT> Callback_TestIntf_SBaseAsSBasePtr
newCallback_TestIntf_SBaseAsSBase(const IceUtil::Handle<T>& instance, void (T::*cb)(const SBasePtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_SBaseAsSBase<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_SBaseAsSBase.
 */
template<class T, typename CT> Callback_TestIntf_SBaseAsSBasePtr
newCallback_TestIntf_SBaseAsSBase(T* instance, void (T::*cb)(const SBasePtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_SBaseAsSBase<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_SBSKnownDerivedAsSBase.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_SBSKnownDerivedAsSBase.
 */
template<class T>
class CallbackNC_TestIntf_SBSKnownDerivedAsSBase : public Callback_TestIntf_SBSKnownDerivedAsSBase_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const SBasePtr&);

    CallbackNC_TestIntf_SBSKnownDerivedAsSBase(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        SBasePtr ret;
        try
        {
            ret = proxy->end_SBSKnownDerivedAsSBase(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_SBSKnownDerivedAsSBase.
 */
template<class T> Callback_TestIntf_SBSKnownDerivedAsSBasePtr
newCallback_TestIntf_SBSKnownDerivedAsSBase(const IceUtil::Handle<T>& instance, void (T::*cb)(const SBasePtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_SBSKnownDerivedAsSBase<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_SBSKnownDerivedAsSBase.
 */
template<class T> Callback_TestIntf_SBSKnownDerivedAsSBasePtr
newCallback_TestIntf_SBSKnownDerivedAsSBase(T* instance, void (T::*cb)(const SBasePtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_SBSKnownDerivedAsSBase<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_SBSKnownDerivedAsSBase.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_SBSKnownDerivedAsSBase.
 */
template<class T, typename CT>
class Callback_TestIntf_SBSKnownDerivedAsSBase : public Callback_TestIntf_SBSKnownDerivedAsSBase_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const SBasePtr&, const CT&);

    Callback_TestIntf_SBSKnownDerivedAsSBase(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        SBasePtr ret;
        try
        {
            ret = proxy->end_SBSKnownDerivedAsSBase(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_SBSKnownDerivedAsSBase.
 */
template<class T, typename CT> Callback_TestIntf_SBSKnownDerivedAsSBasePtr
newCallback_TestIntf_SBSKnownDerivedAsSBase(const IceUtil::Handle<T>& instance, void (T::*cb)(const SBasePtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_SBSKnownDerivedAsSBase<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_SBSKnownDerivedAsSBase.
 */
template<class T, typename CT> Callback_TestIntf_SBSKnownDerivedAsSBasePtr
newCallback_TestIntf_SBSKnownDerivedAsSBase(T* instance, void (T::*cb)(const SBasePtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_SBSKnownDerivedAsSBase<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_SBSKnownDerivedAsSBSKnownDerived.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_SBSKnownDerivedAsSBSKnownDerived.
 */
template<class T>
class CallbackNC_TestIntf_SBSKnownDerivedAsSBSKnownDerived : public Callback_TestIntf_SBSKnownDerivedAsSBSKnownDerived_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const SBSKnownDerivedPtr&);

    CallbackNC_TestIntf_SBSKnownDerivedAsSBSKnownDerived(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        SBSKnownDerivedPtr ret;
        try
        {
            ret = proxy->end_SBSKnownDerivedAsSBSKnownDerived(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_SBSKnownDerivedAsSBSKnownDerived.
 */
template<class T> Callback_TestIntf_SBSKnownDerivedAsSBSKnownDerivedPtr
newCallback_TestIntf_SBSKnownDerivedAsSBSKnownDerived(const IceUtil::Handle<T>& instance, void (T::*cb)(const SBSKnownDerivedPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_SBSKnownDerivedAsSBSKnownDerived<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_SBSKnownDerivedAsSBSKnownDerived.
 */
template<class T> Callback_TestIntf_SBSKnownDerivedAsSBSKnownDerivedPtr
newCallback_TestIntf_SBSKnownDerivedAsSBSKnownDerived(T* instance, void (T::*cb)(const SBSKnownDerivedPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_SBSKnownDerivedAsSBSKnownDerived<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_SBSKnownDerivedAsSBSKnownDerived.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_SBSKnownDerivedAsSBSKnownDerived.
 */
template<class T, typename CT>
class Callback_TestIntf_SBSKnownDerivedAsSBSKnownDerived : public Callback_TestIntf_SBSKnownDerivedAsSBSKnownDerived_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const SBSKnownDerivedPtr&, const CT&);

    Callback_TestIntf_SBSKnownDerivedAsSBSKnownDerived(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        SBSKnownDerivedPtr ret;
        try
        {
            ret = proxy->end_SBSKnownDerivedAsSBSKnownDerived(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_SBSKnownDerivedAsSBSKnownDerived.
 */
template<class T, typename CT> Callback_TestIntf_SBSKnownDerivedAsSBSKnownDerivedPtr
newCallback_TestIntf_SBSKnownDerivedAsSBSKnownDerived(const IceUtil::Handle<T>& instance, void (T::*cb)(const SBSKnownDerivedPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_SBSKnownDerivedAsSBSKnownDerived<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_SBSKnownDerivedAsSBSKnownDerived.
 */
template<class T, typename CT> Callback_TestIntf_SBSKnownDerivedAsSBSKnownDerivedPtr
newCallback_TestIntf_SBSKnownDerivedAsSBSKnownDerived(T* instance, void (T::*cb)(const SBSKnownDerivedPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_SBSKnownDerivedAsSBSKnownDerived<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_SBSUnknownDerivedAsSBase.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_SBSUnknownDerivedAsSBase.
 */
template<class T>
class CallbackNC_TestIntf_SBSUnknownDerivedAsSBase : public Callback_TestIntf_SBSUnknownDerivedAsSBase_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const SBasePtr&);

    CallbackNC_TestIntf_SBSUnknownDerivedAsSBase(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        SBasePtr ret;
        try
        {
            ret = proxy->end_SBSUnknownDerivedAsSBase(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_SBSUnknownDerivedAsSBase.
 */
template<class T> Callback_TestIntf_SBSUnknownDerivedAsSBasePtr
newCallback_TestIntf_SBSUnknownDerivedAsSBase(const IceUtil::Handle<T>& instance, void (T::*cb)(const SBasePtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_SBSUnknownDerivedAsSBase<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_SBSUnknownDerivedAsSBase.
 */
template<class T> Callback_TestIntf_SBSUnknownDerivedAsSBasePtr
newCallback_TestIntf_SBSUnknownDerivedAsSBase(T* instance, void (T::*cb)(const SBasePtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_SBSUnknownDerivedAsSBase<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_SBSUnknownDerivedAsSBase.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_SBSUnknownDerivedAsSBase.
 */
template<class T, typename CT>
class Callback_TestIntf_SBSUnknownDerivedAsSBase : public Callback_TestIntf_SBSUnknownDerivedAsSBase_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const SBasePtr&, const CT&);

    Callback_TestIntf_SBSUnknownDerivedAsSBase(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        SBasePtr ret;
        try
        {
            ret = proxy->end_SBSUnknownDerivedAsSBase(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_SBSUnknownDerivedAsSBase.
 */
template<class T, typename CT> Callback_TestIntf_SBSUnknownDerivedAsSBasePtr
newCallback_TestIntf_SBSUnknownDerivedAsSBase(const IceUtil::Handle<T>& instance, void (T::*cb)(const SBasePtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_SBSUnknownDerivedAsSBase<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_SBSUnknownDerivedAsSBase.
 */
template<class T, typename CT> Callback_TestIntf_SBSUnknownDerivedAsSBasePtr
newCallback_TestIntf_SBSUnknownDerivedAsSBase(T* instance, void (T::*cb)(const SBasePtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_SBSUnknownDerivedAsSBase<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_SBSUnknownDerivedAsSBaseCompact.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_SBSUnknownDerivedAsSBaseCompact.
 */
template<class T>
class CallbackNC_TestIntf_SBSUnknownDerivedAsSBaseCompact : public Callback_TestIntf_SBSUnknownDerivedAsSBaseCompact_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const SBasePtr&);

    CallbackNC_TestIntf_SBSUnknownDerivedAsSBaseCompact(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        SBasePtr ret;
        try
        {
            ret = proxy->end_SBSUnknownDerivedAsSBaseCompact(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_SBSUnknownDerivedAsSBaseCompact.
 */
template<class T> Callback_TestIntf_SBSUnknownDerivedAsSBaseCompactPtr
newCallback_TestIntf_SBSUnknownDerivedAsSBaseCompact(const IceUtil::Handle<T>& instance, void (T::*cb)(const SBasePtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_SBSUnknownDerivedAsSBaseCompact<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_SBSUnknownDerivedAsSBaseCompact.
 */
template<class T> Callback_TestIntf_SBSUnknownDerivedAsSBaseCompactPtr
newCallback_TestIntf_SBSUnknownDerivedAsSBaseCompact(T* instance, void (T::*cb)(const SBasePtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_SBSUnknownDerivedAsSBaseCompact<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_SBSUnknownDerivedAsSBaseCompact.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_SBSUnknownDerivedAsSBaseCompact.
 */
template<class T, typename CT>
class Callback_TestIntf_SBSUnknownDerivedAsSBaseCompact : public Callback_TestIntf_SBSUnknownDerivedAsSBaseCompact_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const SBasePtr&, const CT&);

    Callback_TestIntf_SBSUnknownDerivedAsSBaseCompact(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        SBasePtr ret;
        try
        {
            ret = proxy->end_SBSUnknownDerivedAsSBaseCompact(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_SBSUnknownDerivedAsSBaseCompact.
 */
template<class T, typename CT> Callback_TestIntf_SBSUnknownDerivedAsSBaseCompactPtr
newCallback_TestIntf_SBSUnknownDerivedAsSBaseCompact(const IceUtil::Handle<T>& instance, void (T::*cb)(const SBasePtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_SBSUnknownDerivedAsSBaseCompact<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_SBSUnknownDerivedAsSBaseCompact.
 */
template<class T, typename CT> Callback_TestIntf_SBSUnknownDerivedAsSBaseCompactPtr
newCallback_TestIntf_SBSUnknownDerivedAsSBaseCompact(T* instance, void (T::*cb)(const SBasePtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_SBSUnknownDerivedAsSBaseCompact<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_SUnknownAsObject.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_SUnknownAsObject.
 */
template<class T>
class CallbackNC_TestIntf_SUnknownAsObject : public Callback_TestIntf_SUnknownAsObject_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Ice::ObjectPtr&);

    CallbackNC_TestIntf_SUnknownAsObject(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        ::Ice::ObjectPtr ret;
        try
        {
            ret = proxy->end_SUnknownAsObject(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_SUnknownAsObject.
 */
template<class T> Callback_TestIntf_SUnknownAsObjectPtr
newCallback_TestIntf_SUnknownAsObject(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Ice::ObjectPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_SUnknownAsObject<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_SUnknownAsObject.
 */
template<class T> Callback_TestIntf_SUnknownAsObjectPtr
newCallback_TestIntf_SUnknownAsObject(T* instance, void (T::*cb)(const ::Ice::ObjectPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_SUnknownAsObject<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_SUnknownAsObject.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_SUnknownAsObject.
 */
template<class T, typename CT>
class Callback_TestIntf_SUnknownAsObject : public Callback_TestIntf_SUnknownAsObject_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Ice::ObjectPtr&, const CT&);

    Callback_TestIntf_SUnknownAsObject(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        ::Ice::ObjectPtr ret;
        try
        {
            ret = proxy->end_SUnknownAsObject(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_SUnknownAsObject.
 */
template<class T, typename CT> Callback_TestIntf_SUnknownAsObjectPtr
newCallback_TestIntf_SUnknownAsObject(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Ice::ObjectPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_SUnknownAsObject<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_SUnknownAsObject.
 */
template<class T, typename CT> Callback_TestIntf_SUnknownAsObjectPtr
newCallback_TestIntf_SUnknownAsObject(T* instance, void (T::*cb)(const ::Ice::ObjectPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_SUnknownAsObject<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_checkSUnknown.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_checkSUnknown.
 */
template<class T>
class CallbackNC_TestIntf_checkSUnknown : public Callback_TestIntf_checkSUnknown_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_TestIntf_checkSUnknown(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_checkSUnknown.
 */
template<class T> Callback_TestIntf_checkSUnknownPtr
newCallback_TestIntf_checkSUnknown(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_checkSUnknown<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_checkSUnknown.
 */
template<class T> Callback_TestIntf_checkSUnknownPtr
newCallback_TestIntf_checkSUnknown(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_checkSUnknown<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_checkSUnknown.
 */
template<class T> Callback_TestIntf_checkSUnknownPtr
newCallback_TestIntf_checkSUnknown(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_checkSUnknown<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_checkSUnknown.
 */
template<class T> Callback_TestIntf_checkSUnknownPtr
newCallback_TestIntf_checkSUnknown(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_checkSUnknown<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_checkSUnknown.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_checkSUnknown.
 */
template<class T, typename CT>
class Callback_TestIntf_checkSUnknown : public Callback_TestIntf_checkSUnknown_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_TestIntf_checkSUnknown(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_checkSUnknown.
 */
template<class T, typename CT> Callback_TestIntf_checkSUnknownPtr
newCallback_TestIntf_checkSUnknown(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_checkSUnknown<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_checkSUnknown.
 */
template<class T, typename CT> Callback_TestIntf_checkSUnknownPtr
newCallback_TestIntf_checkSUnknown(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_checkSUnknown<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_checkSUnknown.
 */
template<class T, typename CT> Callback_TestIntf_checkSUnknownPtr
newCallback_TestIntf_checkSUnknown(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_checkSUnknown<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_checkSUnknown.
 */
template<class T, typename CT> Callback_TestIntf_checkSUnknownPtr
newCallback_TestIntf_checkSUnknown(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_checkSUnknown<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_oneElementCycle.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_oneElementCycle.
 */
template<class T>
class CallbackNC_TestIntf_oneElementCycle : public Callback_TestIntf_oneElementCycle_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const BPtr&);

    CallbackNC_TestIntf_oneElementCycle(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        BPtr ret;
        try
        {
            ret = proxy->end_oneElementCycle(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_oneElementCycle.
 */
template<class T> Callback_TestIntf_oneElementCyclePtr
newCallback_TestIntf_oneElementCycle(const IceUtil::Handle<T>& instance, void (T::*cb)(const BPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_oneElementCycle<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_oneElementCycle.
 */
template<class T> Callback_TestIntf_oneElementCyclePtr
newCallback_TestIntf_oneElementCycle(T* instance, void (T::*cb)(const BPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_oneElementCycle<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_oneElementCycle.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_oneElementCycle.
 */
template<class T, typename CT>
class Callback_TestIntf_oneElementCycle : public Callback_TestIntf_oneElementCycle_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const BPtr&, const CT&);

    Callback_TestIntf_oneElementCycle(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        BPtr ret;
        try
        {
            ret = proxy->end_oneElementCycle(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_oneElementCycle.
 */
template<class T, typename CT> Callback_TestIntf_oneElementCyclePtr
newCallback_TestIntf_oneElementCycle(const IceUtil::Handle<T>& instance, void (T::*cb)(const BPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_oneElementCycle<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_oneElementCycle.
 */
template<class T, typename CT> Callback_TestIntf_oneElementCyclePtr
newCallback_TestIntf_oneElementCycle(T* instance, void (T::*cb)(const BPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_oneElementCycle<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_twoElementCycle.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_twoElementCycle.
 */
template<class T>
class CallbackNC_TestIntf_twoElementCycle : public Callback_TestIntf_twoElementCycle_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const BPtr&);

    CallbackNC_TestIntf_twoElementCycle(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        BPtr ret;
        try
        {
            ret = proxy->end_twoElementCycle(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_twoElementCycle.
 */
template<class T> Callback_TestIntf_twoElementCyclePtr
newCallback_TestIntf_twoElementCycle(const IceUtil::Handle<T>& instance, void (T::*cb)(const BPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_twoElementCycle<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_twoElementCycle.
 */
template<class T> Callback_TestIntf_twoElementCyclePtr
newCallback_TestIntf_twoElementCycle(T* instance, void (T::*cb)(const BPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_twoElementCycle<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_twoElementCycle.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_twoElementCycle.
 */
template<class T, typename CT>
class Callback_TestIntf_twoElementCycle : public Callback_TestIntf_twoElementCycle_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const BPtr&, const CT&);

    Callback_TestIntf_twoElementCycle(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        BPtr ret;
        try
        {
            ret = proxy->end_twoElementCycle(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_twoElementCycle.
 */
template<class T, typename CT> Callback_TestIntf_twoElementCyclePtr
newCallback_TestIntf_twoElementCycle(const IceUtil::Handle<T>& instance, void (T::*cb)(const BPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_twoElementCycle<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_twoElementCycle.
 */
template<class T, typename CT> Callback_TestIntf_twoElementCyclePtr
newCallback_TestIntf_twoElementCycle(T* instance, void (T::*cb)(const BPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_twoElementCycle<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_D1AsB.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_D1AsB.
 */
template<class T>
class CallbackNC_TestIntf_D1AsB : public Callback_TestIntf_D1AsB_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const BPtr&);

    CallbackNC_TestIntf_D1AsB(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        BPtr ret;
        try
        {
            ret = proxy->end_D1AsB(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_D1AsB.
 */
template<class T> Callback_TestIntf_D1AsBPtr
newCallback_TestIntf_D1AsB(const IceUtil::Handle<T>& instance, void (T::*cb)(const BPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_D1AsB<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_D1AsB.
 */
template<class T> Callback_TestIntf_D1AsBPtr
newCallback_TestIntf_D1AsB(T* instance, void (T::*cb)(const BPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_D1AsB<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_D1AsB.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_D1AsB.
 */
template<class T, typename CT>
class Callback_TestIntf_D1AsB : public Callback_TestIntf_D1AsB_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const BPtr&, const CT&);

    Callback_TestIntf_D1AsB(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        BPtr ret;
        try
        {
            ret = proxy->end_D1AsB(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_D1AsB.
 */
template<class T, typename CT> Callback_TestIntf_D1AsBPtr
newCallback_TestIntf_D1AsB(const IceUtil::Handle<T>& instance, void (T::*cb)(const BPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_D1AsB<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_D1AsB.
 */
template<class T, typename CT> Callback_TestIntf_D1AsBPtr
newCallback_TestIntf_D1AsB(T* instance, void (T::*cb)(const BPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_D1AsB<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_D1AsD1.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_D1AsD1.
 */
template<class T>
class CallbackNC_TestIntf_D1AsD1 : public Callback_TestIntf_D1AsD1_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const D1Ptr&);

    CallbackNC_TestIntf_D1AsD1(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        D1Ptr ret;
        try
        {
            ret = proxy->end_D1AsD1(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_D1AsD1.
 */
template<class T> Callback_TestIntf_D1AsD1Ptr
newCallback_TestIntf_D1AsD1(const IceUtil::Handle<T>& instance, void (T::*cb)(const D1Ptr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_D1AsD1<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_D1AsD1.
 */
template<class T> Callback_TestIntf_D1AsD1Ptr
newCallback_TestIntf_D1AsD1(T* instance, void (T::*cb)(const D1Ptr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_D1AsD1<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_D1AsD1.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_D1AsD1.
 */
template<class T, typename CT>
class Callback_TestIntf_D1AsD1 : public Callback_TestIntf_D1AsD1_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const D1Ptr&, const CT&);

    Callback_TestIntf_D1AsD1(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        D1Ptr ret;
        try
        {
            ret = proxy->end_D1AsD1(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_D1AsD1.
 */
template<class T, typename CT> Callback_TestIntf_D1AsD1Ptr
newCallback_TestIntf_D1AsD1(const IceUtil::Handle<T>& instance, void (T::*cb)(const D1Ptr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_D1AsD1<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_D1AsD1.
 */
template<class T, typename CT> Callback_TestIntf_D1AsD1Ptr
newCallback_TestIntf_D1AsD1(T* instance, void (T::*cb)(const D1Ptr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_D1AsD1<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_D2AsB.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_D2AsB.
 */
template<class T>
class CallbackNC_TestIntf_D2AsB : public Callback_TestIntf_D2AsB_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const BPtr&);

    CallbackNC_TestIntf_D2AsB(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        BPtr ret;
        try
        {
            ret = proxy->end_D2AsB(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_D2AsB.
 */
template<class T> Callback_TestIntf_D2AsBPtr
newCallback_TestIntf_D2AsB(const IceUtil::Handle<T>& instance, void (T::*cb)(const BPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_D2AsB<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_D2AsB.
 */
template<class T> Callback_TestIntf_D2AsBPtr
newCallback_TestIntf_D2AsB(T* instance, void (T::*cb)(const BPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_D2AsB<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_D2AsB.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_D2AsB.
 */
template<class T, typename CT>
class Callback_TestIntf_D2AsB : public Callback_TestIntf_D2AsB_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const BPtr&, const CT&);

    Callback_TestIntf_D2AsB(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        BPtr ret;
        try
        {
            ret = proxy->end_D2AsB(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_D2AsB.
 */
template<class T, typename CT> Callback_TestIntf_D2AsBPtr
newCallback_TestIntf_D2AsB(const IceUtil::Handle<T>& instance, void (T::*cb)(const BPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_D2AsB<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_D2AsB.
 */
template<class T, typename CT> Callback_TestIntf_D2AsBPtr
newCallback_TestIntf_D2AsB(T* instance, void (T::*cb)(const BPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_D2AsB<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_paramTest1.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_paramTest1.
 */
template<class T>
class CallbackNC_TestIntf_paramTest1 : public Callback_TestIntf_paramTest1_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const BPtr&, const BPtr&);

    CallbackNC_TestIntf_paramTest1(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        BPtr iceP_p1;
        BPtr iceP_p2;
        try
        {
            proxy->end_paramTest1(iceP_p1, iceP_p2, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(iceP_p1, iceP_p2);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_paramTest1.
 */
template<class T> Callback_TestIntf_paramTest1Ptr
newCallback_TestIntf_paramTest1(const IceUtil::Handle<T>& instance, void (T::*cb)(const BPtr&, const BPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_paramTest1<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_paramTest1.
 */
template<class T> Callback_TestIntf_paramTest1Ptr
newCallback_TestIntf_paramTest1(T* instance, void (T::*cb)(const BPtr&, const BPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_paramTest1<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_paramTest1.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_paramTest1.
 */
template<class T, typename CT>
class Callback_TestIntf_paramTest1 : public Callback_TestIntf_paramTest1_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const BPtr&, const BPtr&, const CT&);

    Callback_TestIntf_paramTest1(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        BPtr iceP_p1;
        BPtr iceP_p2;
        try
        {
            proxy->end_paramTest1(iceP_p1, iceP_p2, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(iceP_p1, iceP_p2, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_paramTest1.
 */
template<class T, typename CT> Callback_TestIntf_paramTest1Ptr
newCallback_TestIntf_paramTest1(const IceUtil::Handle<T>& instance, void (T::*cb)(const BPtr&, const BPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_paramTest1<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_paramTest1.
 */
template<class T, typename CT> Callback_TestIntf_paramTest1Ptr
newCallback_TestIntf_paramTest1(T* instance, void (T::*cb)(const BPtr&, const BPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_paramTest1<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_paramTest2.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_paramTest2.
 */
template<class T>
class CallbackNC_TestIntf_paramTest2 : public Callback_TestIntf_paramTest2_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const BPtr&, const BPtr&);

    CallbackNC_TestIntf_paramTest2(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        BPtr iceP_p2;
        BPtr iceP_p1;
        try
        {
            proxy->end_paramTest2(iceP_p2, iceP_p1, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(iceP_p2, iceP_p1);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_paramTest2.
 */
template<class T> Callback_TestIntf_paramTest2Ptr
newCallback_TestIntf_paramTest2(const IceUtil::Handle<T>& instance, void (T::*cb)(const BPtr&, const BPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_paramTest2<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_paramTest2.
 */
template<class T> Callback_TestIntf_paramTest2Ptr
newCallback_TestIntf_paramTest2(T* instance, void (T::*cb)(const BPtr&, const BPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_paramTest2<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_paramTest2.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_paramTest2.
 */
template<class T, typename CT>
class Callback_TestIntf_paramTest2 : public Callback_TestIntf_paramTest2_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const BPtr&, const BPtr&, const CT&);

    Callback_TestIntf_paramTest2(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        BPtr iceP_p2;
        BPtr iceP_p1;
        try
        {
            proxy->end_paramTest2(iceP_p2, iceP_p1, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(iceP_p2, iceP_p1, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_paramTest2.
 */
template<class T, typename CT> Callback_TestIntf_paramTest2Ptr
newCallback_TestIntf_paramTest2(const IceUtil::Handle<T>& instance, void (T::*cb)(const BPtr&, const BPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_paramTest2<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_paramTest2.
 */
template<class T, typename CT> Callback_TestIntf_paramTest2Ptr
newCallback_TestIntf_paramTest2(T* instance, void (T::*cb)(const BPtr&, const BPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_paramTest2<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_paramTest3.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_paramTest3.
 */
template<class T>
class CallbackNC_TestIntf_paramTest3 : public Callback_TestIntf_paramTest3_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const BPtr&, const BPtr&, const BPtr&);

    CallbackNC_TestIntf_paramTest3(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        BPtr iceP_p1;
        BPtr iceP_p2;
        BPtr ret;
        try
        {
            ret = proxy->end_paramTest3(iceP_p1, iceP_p2, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p1, iceP_p2);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_paramTest3.
 */
template<class T> Callback_TestIntf_paramTest3Ptr
newCallback_TestIntf_paramTest3(const IceUtil::Handle<T>& instance, void (T::*cb)(const BPtr&, const BPtr&, const BPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_paramTest3<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_paramTest3.
 */
template<class T> Callback_TestIntf_paramTest3Ptr
newCallback_TestIntf_paramTest3(T* instance, void (T::*cb)(const BPtr&, const BPtr&, const BPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_paramTest3<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_paramTest3.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_paramTest3.
 */
template<class T, typename CT>
class Callback_TestIntf_paramTest3 : public Callback_TestIntf_paramTest3_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const BPtr&, const BPtr&, const BPtr&, const CT&);

    Callback_TestIntf_paramTest3(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        BPtr iceP_p1;
        BPtr iceP_p2;
        BPtr ret;
        try
        {
            ret = proxy->end_paramTest3(iceP_p1, iceP_p2, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p1, iceP_p2, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_paramTest3.
 */
template<class T, typename CT> Callback_TestIntf_paramTest3Ptr
newCallback_TestIntf_paramTest3(const IceUtil::Handle<T>& instance, void (T::*cb)(const BPtr&, const BPtr&, const BPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_paramTest3<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_paramTest3.
 */
template<class T, typename CT> Callback_TestIntf_paramTest3Ptr
newCallback_TestIntf_paramTest3(T* instance, void (T::*cb)(const BPtr&, const BPtr&, const BPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_paramTest3<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_paramTest4.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_paramTest4.
 */
template<class T>
class CallbackNC_TestIntf_paramTest4 : public Callback_TestIntf_paramTest4_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const BPtr&, const BPtr&);

    CallbackNC_TestIntf_paramTest4(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        BPtr iceP_p;
        BPtr ret;
        try
        {
            ret = proxy->end_paramTest4(iceP_p, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_paramTest4.
 */
template<class T> Callback_TestIntf_paramTest4Ptr
newCallback_TestIntf_paramTest4(const IceUtil::Handle<T>& instance, void (T::*cb)(const BPtr&, const BPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_paramTest4<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_paramTest4.
 */
template<class T> Callback_TestIntf_paramTest4Ptr
newCallback_TestIntf_paramTest4(T* instance, void (T::*cb)(const BPtr&, const BPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_paramTest4<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_paramTest4.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_paramTest4.
 */
template<class T, typename CT>
class Callback_TestIntf_paramTest4 : public Callback_TestIntf_paramTest4_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const BPtr&, const BPtr&, const CT&);

    Callback_TestIntf_paramTest4(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        BPtr iceP_p;
        BPtr ret;
        try
        {
            ret = proxy->end_paramTest4(iceP_p, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_paramTest4.
 */
template<class T, typename CT> Callback_TestIntf_paramTest4Ptr
newCallback_TestIntf_paramTest4(const IceUtil::Handle<T>& instance, void (T::*cb)(const BPtr&, const BPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_paramTest4<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_paramTest4.
 */
template<class T, typename CT> Callback_TestIntf_paramTest4Ptr
newCallback_TestIntf_paramTest4(T* instance, void (T::*cb)(const BPtr&, const BPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_paramTest4<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_returnTest1.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_returnTest1.
 */
template<class T>
class CallbackNC_TestIntf_returnTest1 : public Callback_TestIntf_returnTest1_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const BPtr&, const BPtr&, const BPtr&);

    CallbackNC_TestIntf_returnTest1(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        BPtr iceP_p1;
        BPtr iceP_p2;
        BPtr ret;
        try
        {
            ret = proxy->end_returnTest1(iceP_p1, iceP_p2, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p1, iceP_p2);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_returnTest1.
 */
template<class T> Callback_TestIntf_returnTest1Ptr
newCallback_TestIntf_returnTest1(const IceUtil::Handle<T>& instance, void (T::*cb)(const BPtr&, const BPtr&, const BPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_returnTest1<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_returnTest1.
 */
template<class T> Callback_TestIntf_returnTest1Ptr
newCallback_TestIntf_returnTest1(T* instance, void (T::*cb)(const BPtr&, const BPtr&, const BPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_returnTest1<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_returnTest1.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_returnTest1.
 */
template<class T, typename CT>
class Callback_TestIntf_returnTest1 : public Callback_TestIntf_returnTest1_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const BPtr&, const BPtr&, const BPtr&, const CT&);

    Callback_TestIntf_returnTest1(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        BPtr iceP_p1;
        BPtr iceP_p2;
        BPtr ret;
        try
        {
            ret = proxy->end_returnTest1(iceP_p1, iceP_p2, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p1, iceP_p2, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_returnTest1.
 */
template<class T, typename CT> Callback_TestIntf_returnTest1Ptr
newCallback_TestIntf_returnTest1(const IceUtil::Handle<T>& instance, void (T::*cb)(const BPtr&, const BPtr&, const BPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_returnTest1<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_returnTest1.
 */
template<class T, typename CT> Callback_TestIntf_returnTest1Ptr
newCallback_TestIntf_returnTest1(T* instance, void (T::*cb)(const BPtr&, const BPtr&, const BPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_returnTest1<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_returnTest2.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_returnTest2.
 */
template<class T>
class CallbackNC_TestIntf_returnTest2 : public Callback_TestIntf_returnTest2_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const BPtr&, const BPtr&, const BPtr&);

    CallbackNC_TestIntf_returnTest2(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        BPtr iceP_p2;
        BPtr iceP_p1;
        BPtr ret;
        try
        {
            ret = proxy->end_returnTest2(iceP_p2, iceP_p1, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_p2, iceP_p1);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_returnTest2.
 */
template<class T> Callback_TestIntf_returnTest2Ptr
newCallback_TestIntf_returnTest2(const IceUtil::Handle<T>& instance, void (T::*cb)(const BPtr&, const BPtr&, const BPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_returnTest2<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_returnTest2.
 */
template<class T> Callback_TestIntf_returnTest2Ptr
newCallback_TestIntf_returnTest2(T* instance, void (T::*cb)(const BPtr&, const BPtr&, const BPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_returnTest2<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_returnTest2.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_returnTest2.
 */
template<class T, typename CT>
class Callback_TestIntf_returnTest2 : public Callback_TestIntf_returnTest2_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const BPtr&, const BPtr&, const BPtr&, const CT&);

    Callback_TestIntf_returnTest2(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        BPtr iceP_p2;
        BPtr iceP_p1;
        BPtr ret;
        try
        {
            ret = proxy->end_returnTest2(iceP_p2, iceP_p1, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_p2, iceP_p1, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_returnTest2.
 */
template<class T, typename CT> Callback_TestIntf_returnTest2Ptr
newCallback_TestIntf_returnTest2(const IceUtil::Handle<T>& instance, void (T::*cb)(const BPtr&, const BPtr&, const BPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_returnTest2<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_returnTest2.
 */
template<class T, typename CT> Callback_TestIntf_returnTest2Ptr
newCallback_TestIntf_returnTest2(T* instance, void (T::*cb)(const BPtr&, const BPtr&, const BPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_returnTest2<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_returnTest3.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_returnTest3.
 */
template<class T>
class CallbackNC_TestIntf_returnTest3 : public Callback_TestIntf_returnTest3_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const BPtr&);

    CallbackNC_TestIntf_returnTest3(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        BPtr ret;
        try
        {
            ret = proxy->end_returnTest3(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_returnTest3.
 */
template<class T> Callback_TestIntf_returnTest3Ptr
newCallback_TestIntf_returnTest3(const IceUtil::Handle<T>& instance, void (T::*cb)(const BPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_returnTest3<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_returnTest3.
 */
template<class T> Callback_TestIntf_returnTest3Ptr
newCallback_TestIntf_returnTest3(T* instance, void (T::*cb)(const BPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_returnTest3<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_returnTest3.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_returnTest3.
 */
template<class T, typename CT>
class Callback_TestIntf_returnTest3 : public Callback_TestIntf_returnTest3_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const BPtr&, const CT&);

    Callback_TestIntf_returnTest3(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        BPtr ret;
        try
        {
            ret = proxy->end_returnTest3(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_returnTest3.
 */
template<class T, typename CT> Callback_TestIntf_returnTest3Ptr
newCallback_TestIntf_returnTest3(const IceUtil::Handle<T>& instance, void (T::*cb)(const BPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_returnTest3<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_returnTest3.
 */
template<class T, typename CT> Callback_TestIntf_returnTest3Ptr
newCallback_TestIntf_returnTest3(T* instance, void (T::*cb)(const BPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_returnTest3<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_sequenceTest.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_sequenceTest.
 */
template<class T>
class CallbackNC_TestIntf_sequenceTest : public Callback_TestIntf_sequenceTest_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const SS&);

    CallbackNC_TestIntf_sequenceTest(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        SS ret;
        try
        {
            ret = proxy->end_sequenceTest(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_sequenceTest.
 */
template<class T> Callback_TestIntf_sequenceTestPtr
newCallback_TestIntf_sequenceTest(const IceUtil::Handle<T>& instance, void (T::*cb)(const SS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_sequenceTest<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_sequenceTest.
 */
template<class T> Callback_TestIntf_sequenceTestPtr
newCallback_TestIntf_sequenceTest(T* instance, void (T::*cb)(const SS&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_sequenceTest<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_sequenceTest.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_sequenceTest.
 */
template<class T, typename CT>
class Callback_TestIntf_sequenceTest : public Callback_TestIntf_sequenceTest_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const SS&, const CT&);

    Callback_TestIntf_sequenceTest(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        SS ret;
        try
        {
            ret = proxy->end_sequenceTest(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_sequenceTest.
 */
template<class T, typename CT> Callback_TestIntf_sequenceTestPtr
newCallback_TestIntf_sequenceTest(const IceUtil::Handle<T>& instance, void (T::*cb)(const SS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_sequenceTest<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_sequenceTest.
 */
template<class T, typename CT> Callback_TestIntf_sequenceTestPtr
newCallback_TestIntf_sequenceTest(T* instance, void (T::*cb)(const SS&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_sequenceTest<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_dictionaryTest.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_dictionaryTest.
 */
template<class T>
class CallbackNC_TestIntf_dictionaryTest : public Callback_TestIntf_dictionaryTest_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const BDict&, const BDict&);

    CallbackNC_TestIntf_dictionaryTest(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        BDict iceP_bout;
        BDict ret;
        try
        {
            ret = proxy->end_dictionaryTest(iceP_bout, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_bout);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_dictionaryTest.
 */
template<class T> Callback_TestIntf_dictionaryTestPtr
newCallback_TestIntf_dictionaryTest(const IceUtil::Handle<T>& instance, void (T::*cb)(const BDict&, const BDict&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_dictionaryTest<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_dictionaryTest.
 */
template<class T> Callback_TestIntf_dictionaryTestPtr
newCallback_TestIntf_dictionaryTest(T* instance, void (T::*cb)(const BDict&, const BDict&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_dictionaryTest<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_dictionaryTest.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_dictionaryTest.
 */
template<class T, typename CT>
class Callback_TestIntf_dictionaryTest : public Callback_TestIntf_dictionaryTest_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const BDict&, const BDict&, const CT&);

    Callback_TestIntf_dictionaryTest(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        BDict iceP_bout;
        BDict ret;
        try
        {
            ret = proxy->end_dictionaryTest(iceP_bout, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_bout, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_dictionaryTest.
 */
template<class T, typename CT> Callback_TestIntf_dictionaryTestPtr
newCallback_TestIntf_dictionaryTest(const IceUtil::Handle<T>& instance, void (T::*cb)(const BDict&, const BDict&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_dictionaryTest<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_dictionaryTest.
 */
template<class T, typename CT> Callback_TestIntf_dictionaryTestPtr
newCallback_TestIntf_dictionaryTest(T* instance, void (T::*cb)(const BDict&, const BDict&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_dictionaryTest<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_exchangePBase.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_exchangePBase.
 */
template<class T>
class CallbackNC_TestIntf_exchangePBase : public Callback_TestIntf_exchangePBase_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const PBasePtr&);

    CallbackNC_TestIntf_exchangePBase(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        PBasePtr ret;
        try
        {
            ret = proxy->end_exchangePBase(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_exchangePBase.
 */
template<class T> Callback_TestIntf_exchangePBasePtr
newCallback_TestIntf_exchangePBase(const IceUtil::Handle<T>& instance, void (T::*cb)(const PBasePtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_exchangePBase<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_exchangePBase.
 */
template<class T> Callback_TestIntf_exchangePBasePtr
newCallback_TestIntf_exchangePBase(T* instance, void (T::*cb)(const PBasePtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_exchangePBase<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_exchangePBase.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_exchangePBase.
 */
template<class T, typename CT>
class Callback_TestIntf_exchangePBase : public Callback_TestIntf_exchangePBase_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const PBasePtr&, const CT&);

    Callback_TestIntf_exchangePBase(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        PBasePtr ret;
        try
        {
            ret = proxy->end_exchangePBase(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_exchangePBase.
 */
template<class T, typename CT> Callback_TestIntf_exchangePBasePtr
newCallback_TestIntf_exchangePBase(const IceUtil::Handle<T>& instance, void (T::*cb)(const PBasePtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_exchangePBase<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_exchangePBase.
 */
template<class T, typename CT> Callback_TestIntf_exchangePBasePtr
newCallback_TestIntf_exchangePBase(T* instance, void (T::*cb)(const PBasePtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_exchangePBase<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_PBSUnknownAsPreserved.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_PBSUnknownAsPreserved.
 */
template<class T>
class CallbackNC_TestIntf_PBSUnknownAsPreserved : public Callback_TestIntf_PBSUnknownAsPreserved_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const PreservedPtr&);

    CallbackNC_TestIntf_PBSUnknownAsPreserved(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        PreservedPtr ret;
        try
        {
            ret = proxy->end_PBSUnknownAsPreserved(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_PBSUnknownAsPreserved.
 */
template<class T> Callback_TestIntf_PBSUnknownAsPreservedPtr
newCallback_TestIntf_PBSUnknownAsPreserved(const IceUtil::Handle<T>& instance, void (T::*cb)(const PreservedPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_PBSUnknownAsPreserved<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_PBSUnknownAsPreserved.
 */
template<class T> Callback_TestIntf_PBSUnknownAsPreservedPtr
newCallback_TestIntf_PBSUnknownAsPreserved(T* instance, void (T::*cb)(const PreservedPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_PBSUnknownAsPreserved<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_PBSUnknownAsPreserved.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_PBSUnknownAsPreserved.
 */
template<class T, typename CT>
class Callback_TestIntf_PBSUnknownAsPreserved : public Callback_TestIntf_PBSUnknownAsPreserved_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const PreservedPtr&, const CT&);

    Callback_TestIntf_PBSUnknownAsPreserved(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        PreservedPtr ret;
        try
        {
            ret = proxy->end_PBSUnknownAsPreserved(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_PBSUnknownAsPreserved.
 */
template<class T, typename CT> Callback_TestIntf_PBSUnknownAsPreservedPtr
newCallback_TestIntf_PBSUnknownAsPreserved(const IceUtil::Handle<T>& instance, void (T::*cb)(const PreservedPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_PBSUnknownAsPreserved<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_PBSUnknownAsPreserved.
 */
template<class T, typename CT> Callback_TestIntf_PBSUnknownAsPreservedPtr
newCallback_TestIntf_PBSUnknownAsPreserved(T* instance, void (T::*cb)(const PreservedPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_PBSUnknownAsPreserved<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_checkPBSUnknown.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_checkPBSUnknown.
 */
template<class T>
class CallbackNC_TestIntf_checkPBSUnknown : public Callback_TestIntf_checkPBSUnknown_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_TestIntf_checkPBSUnknown(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_checkPBSUnknown.
 */
template<class T> Callback_TestIntf_checkPBSUnknownPtr
newCallback_TestIntf_checkPBSUnknown(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_checkPBSUnknown<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_checkPBSUnknown.
 */
template<class T> Callback_TestIntf_checkPBSUnknownPtr
newCallback_TestIntf_checkPBSUnknown(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_checkPBSUnknown<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_checkPBSUnknown.
 */
template<class T> Callback_TestIntf_checkPBSUnknownPtr
newCallback_TestIntf_checkPBSUnknown(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_checkPBSUnknown<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_checkPBSUnknown.
 */
template<class T> Callback_TestIntf_checkPBSUnknownPtr
newCallback_TestIntf_checkPBSUnknown(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_checkPBSUnknown<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_checkPBSUnknown.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_checkPBSUnknown.
 */
template<class T, typename CT>
class Callback_TestIntf_checkPBSUnknown : public Callback_TestIntf_checkPBSUnknown_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_TestIntf_checkPBSUnknown(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_checkPBSUnknown.
 */
template<class T, typename CT> Callback_TestIntf_checkPBSUnknownPtr
newCallback_TestIntf_checkPBSUnknown(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_checkPBSUnknown<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_checkPBSUnknown.
 */
template<class T, typename CT> Callback_TestIntf_checkPBSUnknownPtr
newCallback_TestIntf_checkPBSUnknown(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_checkPBSUnknown<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_checkPBSUnknown.
 */
template<class T, typename CT> Callback_TestIntf_checkPBSUnknownPtr
newCallback_TestIntf_checkPBSUnknown(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_checkPBSUnknown<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_checkPBSUnknown.
 */
template<class T, typename CT> Callback_TestIntf_checkPBSUnknownPtr
newCallback_TestIntf_checkPBSUnknown(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_checkPBSUnknown<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_PBSUnknownAsPreservedWithGraph.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_PBSUnknownAsPreservedWithGraph.
 */
template<class T>
class CallbackNC_TestIntf_PBSUnknownAsPreservedWithGraph : public Callback_TestIntf_PBSUnknownAsPreservedWithGraph_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const PreservedPtr&);

    CallbackNC_TestIntf_PBSUnknownAsPreservedWithGraph(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        PreservedPtr ret;
        try
        {
            ret = proxy->end_PBSUnknownAsPreservedWithGraph(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_PBSUnknownAsPreservedWithGraph.
 */
template<class T> Callback_TestIntf_PBSUnknownAsPreservedWithGraphPtr
newCallback_TestIntf_PBSUnknownAsPreservedWithGraph(const IceUtil::Handle<T>& instance, void (T::*cb)(const PreservedPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_PBSUnknownAsPreservedWithGraph<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_PBSUnknownAsPreservedWithGraph.
 */
template<class T> Callback_TestIntf_PBSUnknownAsPreservedWithGraphPtr
newCallback_TestIntf_PBSUnknownAsPreservedWithGraph(T* instance, void (T::*cb)(const PreservedPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_PBSUnknownAsPreservedWithGraph<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_PBSUnknownAsPreservedWithGraph.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_PBSUnknownAsPreservedWithGraph.
 */
template<class T, typename CT>
class Callback_TestIntf_PBSUnknownAsPreservedWithGraph : public Callback_TestIntf_PBSUnknownAsPreservedWithGraph_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const PreservedPtr&, const CT&);

    Callback_TestIntf_PBSUnknownAsPreservedWithGraph(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        PreservedPtr ret;
        try
        {
            ret = proxy->end_PBSUnknownAsPreservedWithGraph(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_PBSUnknownAsPreservedWithGraph.
 */
template<class T, typename CT> Callback_TestIntf_PBSUnknownAsPreservedWithGraphPtr
newCallback_TestIntf_PBSUnknownAsPreservedWithGraph(const IceUtil::Handle<T>& instance, void (T::*cb)(const PreservedPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_PBSUnknownAsPreservedWithGraph<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_PBSUnknownAsPreservedWithGraph.
 */
template<class T, typename CT> Callback_TestIntf_PBSUnknownAsPreservedWithGraphPtr
newCallback_TestIntf_PBSUnknownAsPreservedWithGraph(T* instance, void (T::*cb)(const PreservedPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_PBSUnknownAsPreservedWithGraph<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_checkPBSUnknownWithGraph.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_checkPBSUnknownWithGraph.
 */
template<class T>
class CallbackNC_TestIntf_checkPBSUnknownWithGraph : public Callback_TestIntf_checkPBSUnknownWithGraph_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_TestIntf_checkPBSUnknownWithGraph(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_checkPBSUnknownWithGraph.
 */
template<class T> Callback_TestIntf_checkPBSUnknownWithGraphPtr
newCallback_TestIntf_checkPBSUnknownWithGraph(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_checkPBSUnknownWithGraph<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_checkPBSUnknownWithGraph.
 */
template<class T> Callback_TestIntf_checkPBSUnknownWithGraphPtr
newCallback_TestIntf_checkPBSUnknownWithGraph(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_checkPBSUnknownWithGraph<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_checkPBSUnknownWithGraph.
 */
template<class T> Callback_TestIntf_checkPBSUnknownWithGraphPtr
newCallback_TestIntf_checkPBSUnknownWithGraph(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_checkPBSUnknownWithGraph<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_checkPBSUnknownWithGraph.
 */
template<class T> Callback_TestIntf_checkPBSUnknownWithGraphPtr
newCallback_TestIntf_checkPBSUnknownWithGraph(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_checkPBSUnknownWithGraph<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_checkPBSUnknownWithGraph.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_checkPBSUnknownWithGraph.
 */
template<class T, typename CT>
class Callback_TestIntf_checkPBSUnknownWithGraph : public Callback_TestIntf_checkPBSUnknownWithGraph_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_TestIntf_checkPBSUnknownWithGraph(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_checkPBSUnknownWithGraph.
 */
template<class T, typename CT> Callback_TestIntf_checkPBSUnknownWithGraphPtr
newCallback_TestIntf_checkPBSUnknownWithGraph(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_checkPBSUnknownWithGraph<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_checkPBSUnknownWithGraph.
 */
template<class T, typename CT> Callback_TestIntf_checkPBSUnknownWithGraphPtr
newCallback_TestIntf_checkPBSUnknownWithGraph(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_checkPBSUnknownWithGraph<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_checkPBSUnknownWithGraph.
 */
template<class T, typename CT> Callback_TestIntf_checkPBSUnknownWithGraphPtr
newCallback_TestIntf_checkPBSUnknownWithGraph(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_checkPBSUnknownWithGraph<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_checkPBSUnknownWithGraph.
 */
template<class T, typename CT> Callback_TestIntf_checkPBSUnknownWithGraphPtr
newCallback_TestIntf_checkPBSUnknownWithGraph(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_checkPBSUnknownWithGraph<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_PBSUnknown2AsPreservedWithGraph.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_PBSUnknown2AsPreservedWithGraph.
 */
template<class T>
class CallbackNC_TestIntf_PBSUnknown2AsPreservedWithGraph : public Callback_TestIntf_PBSUnknown2AsPreservedWithGraph_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const PreservedPtr&);

    CallbackNC_TestIntf_PBSUnknown2AsPreservedWithGraph(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        PreservedPtr ret;
        try
        {
            ret = proxy->end_PBSUnknown2AsPreservedWithGraph(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_PBSUnknown2AsPreservedWithGraph.
 */
template<class T> Callback_TestIntf_PBSUnknown2AsPreservedWithGraphPtr
newCallback_TestIntf_PBSUnknown2AsPreservedWithGraph(const IceUtil::Handle<T>& instance, void (T::*cb)(const PreservedPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_PBSUnknown2AsPreservedWithGraph<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_PBSUnknown2AsPreservedWithGraph.
 */
template<class T> Callback_TestIntf_PBSUnknown2AsPreservedWithGraphPtr
newCallback_TestIntf_PBSUnknown2AsPreservedWithGraph(T* instance, void (T::*cb)(const PreservedPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_PBSUnknown2AsPreservedWithGraph<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_PBSUnknown2AsPreservedWithGraph.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_PBSUnknown2AsPreservedWithGraph.
 */
template<class T, typename CT>
class Callback_TestIntf_PBSUnknown2AsPreservedWithGraph : public Callback_TestIntf_PBSUnknown2AsPreservedWithGraph_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const PreservedPtr&, const CT&);

    Callback_TestIntf_PBSUnknown2AsPreservedWithGraph(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        PreservedPtr ret;
        try
        {
            ret = proxy->end_PBSUnknown2AsPreservedWithGraph(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_PBSUnknown2AsPreservedWithGraph.
 */
template<class T, typename CT> Callback_TestIntf_PBSUnknown2AsPreservedWithGraphPtr
newCallback_TestIntf_PBSUnknown2AsPreservedWithGraph(const IceUtil::Handle<T>& instance, void (T::*cb)(const PreservedPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_PBSUnknown2AsPreservedWithGraph<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_PBSUnknown2AsPreservedWithGraph.
 */
template<class T, typename CT> Callback_TestIntf_PBSUnknown2AsPreservedWithGraphPtr
newCallback_TestIntf_PBSUnknown2AsPreservedWithGraph(T* instance, void (T::*cb)(const PreservedPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_PBSUnknown2AsPreservedWithGraph<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_checkPBSUnknown2WithGraph.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_checkPBSUnknown2WithGraph.
 */
template<class T>
class CallbackNC_TestIntf_checkPBSUnknown2WithGraph : public Callback_TestIntf_checkPBSUnknown2WithGraph_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_TestIntf_checkPBSUnknown2WithGraph(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_checkPBSUnknown2WithGraph.
 */
template<class T> Callback_TestIntf_checkPBSUnknown2WithGraphPtr
newCallback_TestIntf_checkPBSUnknown2WithGraph(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_checkPBSUnknown2WithGraph<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_checkPBSUnknown2WithGraph.
 */
template<class T> Callback_TestIntf_checkPBSUnknown2WithGraphPtr
newCallback_TestIntf_checkPBSUnknown2WithGraph(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_checkPBSUnknown2WithGraph<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_checkPBSUnknown2WithGraph.
 */
template<class T> Callback_TestIntf_checkPBSUnknown2WithGraphPtr
newCallback_TestIntf_checkPBSUnknown2WithGraph(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_checkPBSUnknown2WithGraph<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_checkPBSUnknown2WithGraph.
 */
template<class T> Callback_TestIntf_checkPBSUnknown2WithGraphPtr
newCallback_TestIntf_checkPBSUnknown2WithGraph(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_checkPBSUnknown2WithGraph<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_checkPBSUnknown2WithGraph.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_checkPBSUnknown2WithGraph.
 */
template<class T, typename CT>
class Callback_TestIntf_checkPBSUnknown2WithGraph : public Callback_TestIntf_checkPBSUnknown2WithGraph_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_TestIntf_checkPBSUnknown2WithGraph(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_checkPBSUnknown2WithGraph.
 */
template<class T, typename CT> Callback_TestIntf_checkPBSUnknown2WithGraphPtr
newCallback_TestIntf_checkPBSUnknown2WithGraph(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_checkPBSUnknown2WithGraph<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_checkPBSUnknown2WithGraph.
 */
template<class T, typename CT> Callback_TestIntf_checkPBSUnknown2WithGraphPtr
newCallback_TestIntf_checkPBSUnknown2WithGraph(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_checkPBSUnknown2WithGraph<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_checkPBSUnknown2WithGraph.
 */
template<class T, typename CT> Callback_TestIntf_checkPBSUnknown2WithGraphPtr
newCallback_TestIntf_checkPBSUnknown2WithGraph(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_checkPBSUnknown2WithGraph<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_checkPBSUnknown2WithGraph.
 */
template<class T, typename CT> Callback_TestIntf_checkPBSUnknown2WithGraphPtr
newCallback_TestIntf_checkPBSUnknown2WithGraph(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_checkPBSUnknown2WithGraph<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_exchangePNode.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_exchangePNode.
 */
template<class T>
class CallbackNC_TestIntf_exchangePNode : public Callback_TestIntf_exchangePNode_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const PNodePtr&);

    CallbackNC_TestIntf_exchangePNode(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        PNodePtr ret;
        try
        {
            ret = proxy->end_exchangePNode(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_exchangePNode.
 */
template<class T> Callback_TestIntf_exchangePNodePtr
newCallback_TestIntf_exchangePNode(const IceUtil::Handle<T>& instance, void (T::*cb)(const PNodePtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_exchangePNode<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_exchangePNode.
 */
template<class T> Callback_TestIntf_exchangePNodePtr
newCallback_TestIntf_exchangePNode(T* instance, void (T::*cb)(const PNodePtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_exchangePNode<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_exchangePNode.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_exchangePNode.
 */
template<class T, typename CT>
class Callback_TestIntf_exchangePNode : public Callback_TestIntf_exchangePNode_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const PNodePtr&, const CT&);

    Callback_TestIntf_exchangePNode(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        PNodePtr ret;
        try
        {
            ret = proxy->end_exchangePNode(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_exchangePNode.
 */
template<class T, typename CT> Callback_TestIntf_exchangePNodePtr
newCallback_TestIntf_exchangePNode(const IceUtil::Handle<T>& instance, void (T::*cb)(const PNodePtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_exchangePNode<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_exchangePNode.
 */
template<class T, typename CT> Callback_TestIntf_exchangePNodePtr
newCallback_TestIntf_exchangePNode(T* instance, void (T::*cb)(const PNodePtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_exchangePNode<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_throwBaseAsBase.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_throwBaseAsBase.
 */
template<class T>
class CallbackNC_TestIntf_throwBaseAsBase : public Callback_TestIntf_throwBaseAsBase_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_TestIntf_throwBaseAsBase(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_throwBaseAsBase(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_throwBaseAsBase.
 */
template<class T> Callback_TestIntf_throwBaseAsBasePtr
newCallback_TestIntf_throwBaseAsBase(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_throwBaseAsBase<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_throwBaseAsBase.
 */
template<class T> Callback_TestIntf_throwBaseAsBasePtr
newCallback_TestIntf_throwBaseAsBase(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_throwBaseAsBase<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_throwBaseAsBase.
 */
template<class T> Callback_TestIntf_throwBaseAsBasePtr
newCallback_TestIntf_throwBaseAsBase(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_throwBaseAsBase<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_throwBaseAsBase.
 */
template<class T> Callback_TestIntf_throwBaseAsBasePtr
newCallback_TestIntf_throwBaseAsBase(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_throwBaseAsBase<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_throwBaseAsBase.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_throwBaseAsBase.
 */
template<class T, typename CT>
class Callback_TestIntf_throwBaseAsBase : public Callback_TestIntf_throwBaseAsBase_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_TestIntf_throwBaseAsBase(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_throwBaseAsBase(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_throwBaseAsBase.
 */
template<class T, typename CT> Callback_TestIntf_throwBaseAsBasePtr
newCallback_TestIntf_throwBaseAsBase(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_throwBaseAsBase<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_throwBaseAsBase.
 */
template<class T, typename CT> Callback_TestIntf_throwBaseAsBasePtr
newCallback_TestIntf_throwBaseAsBase(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_throwBaseAsBase<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_throwBaseAsBase.
 */
template<class T, typename CT> Callback_TestIntf_throwBaseAsBasePtr
newCallback_TestIntf_throwBaseAsBase(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_throwBaseAsBase<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_throwBaseAsBase.
 */
template<class T, typename CT> Callback_TestIntf_throwBaseAsBasePtr
newCallback_TestIntf_throwBaseAsBase(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_throwBaseAsBase<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_throwDerivedAsBase.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_throwDerivedAsBase.
 */
template<class T>
class CallbackNC_TestIntf_throwDerivedAsBase : public Callback_TestIntf_throwDerivedAsBase_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_TestIntf_throwDerivedAsBase(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_throwDerivedAsBase(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_throwDerivedAsBase.
 */
template<class T> Callback_TestIntf_throwDerivedAsBasePtr
newCallback_TestIntf_throwDerivedAsBase(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_throwDerivedAsBase<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_throwDerivedAsBase.
 */
template<class T> Callback_TestIntf_throwDerivedAsBasePtr
newCallback_TestIntf_throwDerivedAsBase(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_throwDerivedAsBase<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_throwDerivedAsBase.
 */
template<class T> Callback_TestIntf_throwDerivedAsBasePtr
newCallback_TestIntf_throwDerivedAsBase(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_throwDerivedAsBase<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_throwDerivedAsBase.
 */
template<class T> Callback_TestIntf_throwDerivedAsBasePtr
newCallback_TestIntf_throwDerivedAsBase(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_throwDerivedAsBase<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_throwDerivedAsBase.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_throwDerivedAsBase.
 */
template<class T, typename CT>
class Callback_TestIntf_throwDerivedAsBase : public Callback_TestIntf_throwDerivedAsBase_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_TestIntf_throwDerivedAsBase(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_throwDerivedAsBase(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_throwDerivedAsBase.
 */
template<class T, typename CT> Callback_TestIntf_throwDerivedAsBasePtr
newCallback_TestIntf_throwDerivedAsBase(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_throwDerivedAsBase<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_throwDerivedAsBase.
 */
template<class T, typename CT> Callback_TestIntf_throwDerivedAsBasePtr
newCallback_TestIntf_throwDerivedAsBase(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_throwDerivedAsBase<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_throwDerivedAsBase.
 */
template<class T, typename CT> Callback_TestIntf_throwDerivedAsBasePtr
newCallback_TestIntf_throwDerivedAsBase(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_throwDerivedAsBase<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_throwDerivedAsBase.
 */
template<class T, typename CT> Callback_TestIntf_throwDerivedAsBasePtr
newCallback_TestIntf_throwDerivedAsBase(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_throwDerivedAsBase<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_throwDerivedAsDerived.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_throwDerivedAsDerived.
 */
template<class T>
class CallbackNC_TestIntf_throwDerivedAsDerived : public Callback_TestIntf_throwDerivedAsDerived_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_TestIntf_throwDerivedAsDerived(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_throwDerivedAsDerived(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_throwDerivedAsDerived.
 */
template<class T> Callback_TestIntf_throwDerivedAsDerivedPtr
newCallback_TestIntf_throwDerivedAsDerived(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_throwDerivedAsDerived<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_throwDerivedAsDerived.
 */
template<class T> Callback_TestIntf_throwDerivedAsDerivedPtr
newCallback_TestIntf_throwDerivedAsDerived(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_throwDerivedAsDerived<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_throwDerivedAsDerived.
 */
template<class T> Callback_TestIntf_throwDerivedAsDerivedPtr
newCallback_TestIntf_throwDerivedAsDerived(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_throwDerivedAsDerived<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_throwDerivedAsDerived.
 */
template<class T> Callback_TestIntf_throwDerivedAsDerivedPtr
newCallback_TestIntf_throwDerivedAsDerived(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_throwDerivedAsDerived<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_throwDerivedAsDerived.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_throwDerivedAsDerived.
 */
template<class T, typename CT>
class Callback_TestIntf_throwDerivedAsDerived : public Callback_TestIntf_throwDerivedAsDerived_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_TestIntf_throwDerivedAsDerived(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_throwDerivedAsDerived(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_throwDerivedAsDerived.
 */
template<class T, typename CT> Callback_TestIntf_throwDerivedAsDerivedPtr
newCallback_TestIntf_throwDerivedAsDerived(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_throwDerivedAsDerived<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_throwDerivedAsDerived.
 */
template<class T, typename CT> Callback_TestIntf_throwDerivedAsDerivedPtr
newCallback_TestIntf_throwDerivedAsDerived(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_throwDerivedAsDerived<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_throwDerivedAsDerived.
 */
template<class T, typename CT> Callback_TestIntf_throwDerivedAsDerivedPtr
newCallback_TestIntf_throwDerivedAsDerived(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_throwDerivedAsDerived<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_throwDerivedAsDerived.
 */
template<class T, typename CT> Callback_TestIntf_throwDerivedAsDerivedPtr
newCallback_TestIntf_throwDerivedAsDerived(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_throwDerivedAsDerived<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_throwUnknownDerivedAsBase.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_throwUnknownDerivedAsBase.
 */
template<class T>
class CallbackNC_TestIntf_throwUnknownDerivedAsBase : public Callback_TestIntf_throwUnknownDerivedAsBase_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_TestIntf_throwUnknownDerivedAsBase(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_throwUnknownDerivedAsBase(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_throwUnknownDerivedAsBase.
 */
template<class T> Callback_TestIntf_throwUnknownDerivedAsBasePtr
newCallback_TestIntf_throwUnknownDerivedAsBase(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_throwUnknownDerivedAsBase<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_throwUnknownDerivedAsBase.
 */
template<class T> Callback_TestIntf_throwUnknownDerivedAsBasePtr
newCallback_TestIntf_throwUnknownDerivedAsBase(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_throwUnknownDerivedAsBase<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_throwUnknownDerivedAsBase.
 */
template<class T> Callback_TestIntf_throwUnknownDerivedAsBasePtr
newCallback_TestIntf_throwUnknownDerivedAsBase(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_throwUnknownDerivedAsBase<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_throwUnknownDerivedAsBase.
 */
template<class T> Callback_TestIntf_throwUnknownDerivedAsBasePtr
newCallback_TestIntf_throwUnknownDerivedAsBase(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_throwUnknownDerivedAsBase<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_throwUnknownDerivedAsBase.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_throwUnknownDerivedAsBase.
 */
template<class T, typename CT>
class Callback_TestIntf_throwUnknownDerivedAsBase : public Callback_TestIntf_throwUnknownDerivedAsBase_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_TestIntf_throwUnknownDerivedAsBase(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_throwUnknownDerivedAsBase(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_throwUnknownDerivedAsBase.
 */
template<class T, typename CT> Callback_TestIntf_throwUnknownDerivedAsBasePtr
newCallback_TestIntf_throwUnknownDerivedAsBase(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_throwUnknownDerivedAsBase<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_throwUnknownDerivedAsBase.
 */
template<class T, typename CT> Callback_TestIntf_throwUnknownDerivedAsBasePtr
newCallback_TestIntf_throwUnknownDerivedAsBase(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_throwUnknownDerivedAsBase<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_throwUnknownDerivedAsBase.
 */
template<class T, typename CT> Callback_TestIntf_throwUnknownDerivedAsBasePtr
newCallback_TestIntf_throwUnknownDerivedAsBase(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_throwUnknownDerivedAsBase<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_throwUnknownDerivedAsBase.
 */
template<class T, typename CT> Callback_TestIntf_throwUnknownDerivedAsBasePtr
newCallback_TestIntf_throwUnknownDerivedAsBase(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_throwUnknownDerivedAsBase<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_throwPreservedException.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_throwPreservedException.
 */
template<class T>
class CallbackNC_TestIntf_throwPreservedException : public Callback_TestIntf_throwPreservedException_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_TestIntf_throwPreservedException(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_throwPreservedException(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_throwPreservedException.
 */
template<class T> Callback_TestIntf_throwPreservedExceptionPtr
newCallback_TestIntf_throwPreservedException(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_throwPreservedException<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_throwPreservedException.
 */
template<class T> Callback_TestIntf_throwPreservedExceptionPtr
newCallback_TestIntf_throwPreservedException(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_throwPreservedException<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_throwPreservedException.
 */
template<class T> Callback_TestIntf_throwPreservedExceptionPtr
newCallback_TestIntf_throwPreservedException(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_throwPreservedException<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_throwPreservedException.
 */
template<class T> Callback_TestIntf_throwPreservedExceptionPtr
newCallback_TestIntf_throwPreservedException(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_throwPreservedException<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_throwPreservedException.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_throwPreservedException.
 */
template<class T, typename CT>
class Callback_TestIntf_throwPreservedException : public Callback_TestIntf_throwPreservedException_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_TestIntf_throwPreservedException(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_throwPreservedException(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_throwPreservedException.
 */
template<class T, typename CT> Callback_TestIntf_throwPreservedExceptionPtr
newCallback_TestIntf_throwPreservedException(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_throwPreservedException<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_throwPreservedException.
 */
template<class T, typename CT> Callback_TestIntf_throwPreservedExceptionPtr
newCallback_TestIntf_throwPreservedException(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_throwPreservedException<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_throwPreservedException.
 */
template<class T, typename CT> Callback_TestIntf_throwPreservedExceptionPtr
newCallback_TestIntf_throwPreservedException(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_throwPreservedException<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_throwPreservedException.
 */
template<class T, typename CT> Callback_TestIntf_throwPreservedExceptionPtr
newCallback_TestIntf_throwPreservedException(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_throwPreservedException<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_useForward.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_useForward.
 */
template<class T>
class CallbackNC_TestIntf_useForward : public Callback_TestIntf_useForward_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ForwardPtr&);

    CallbackNC_TestIntf_useForward(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        ForwardPtr iceP_f;
        try
        {
            proxy->end_useForward(iceP_f, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(iceP_f);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_useForward.
 */
template<class T> Callback_TestIntf_useForwardPtr
newCallback_TestIntf_useForward(const IceUtil::Handle<T>& instance, void (T::*cb)(const ForwardPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_useForward<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_useForward.
 */
template<class T> Callback_TestIntf_useForwardPtr
newCallback_TestIntf_useForward(T* instance, void (T::*cb)(const ForwardPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_useForward<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_useForward.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_useForward.
 */
template<class T, typename CT>
class Callback_TestIntf_useForward : public Callback_TestIntf_useForward_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ForwardPtr&, const CT&);

    Callback_TestIntf_useForward(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        ForwardPtr iceP_f;
        try
        {
            proxy->end_useForward(iceP_f, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(iceP_f, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_useForward.
 */
template<class T, typename CT> Callback_TestIntf_useForwardPtr
newCallback_TestIntf_useForward(const IceUtil::Handle<T>& instance, void (T::*cb)(const ForwardPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_useForward<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_useForward.
 */
template<class T, typename CT> Callback_TestIntf_useForwardPtr
newCallback_TestIntf_useForward(T* instance, void (T::*cb)(const ForwardPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_useForward<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_shutdown.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_shutdown.
 */
template<class T>
class CallbackNC_TestIntf_shutdown : public Callback_TestIntf_shutdown_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_TestIntf_shutdown(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_shutdown.
 */
template<class T> Callback_TestIntf_shutdownPtr
newCallback_TestIntf_shutdown(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_shutdown<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_shutdown.
 */
template<class T> Callback_TestIntf_shutdownPtr
newCallback_TestIntf_shutdown(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_shutdown<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_shutdown.
 */
template<class T> Callback_TestIntf_shutdownPtr
newCallback_TestIntf_shutdown(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_shutdown<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_shutdown.
 */
template<class T> Callback_TestIntf_shutdownPtr
newCallback_TestIntf_shutdown(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_shutdown<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_shutdown.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_shutdown.
 */
template<class T, typename CT>
class Callback_TestIntf_shutdown : public Callback_TestIntf_shutdown_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_TestIntf_shutdown(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_shutdown.
 */
template<class T, typename CT> Callback_TestIntf_shutdownPtr
newCallback_TestIntf_shutdown(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_shutdown<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_shutdown.
 */
template<class T, typename CT> Callback_TestIntf_shutdownPtr
newCallback_TestIntf_shutdown(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_shutdown<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_shutdown.
 */
template<class T, typename CT> Callback_TestIntf_shutdownPtr
newCallback_TestIntf_shutdown(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_shutdown<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_shutdown.
 */
template<class T, typename CT> Callback_TestIntf_shutdownPtr
newCallback_TestIntf_shutdown(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_shutdown<T, CT>(instance, 0, excb, sentcb);
}

}

#endif

#include <IceUtil/PopDisableWarnings.h>
#endif
