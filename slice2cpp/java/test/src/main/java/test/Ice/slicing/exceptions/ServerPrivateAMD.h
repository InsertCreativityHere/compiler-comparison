//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.7.10
//
// <auto-generated>
//
// Generated from file `ServerPrivateAMD.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __ServerPrivateAMD_h__
#define __ServerPrivateAMD_h__

#include <IceUtil/PushDisableWarnings.h>
#include <Ice/Ice.h>
#include <IceUtil/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 307
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 >= 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 10
#       error Ice patch level mismatch!
#   endif
#endif

#ifdef ICE_CPP11_MAPPING // C++11 mapping

namespace Test
{

class BaseClass;
class Relay;
class RelayPrx;
class TestIntf;
class TestIntfPrx;
class SPreservedClass;

}

namespace Test
{

class Base : public ::Ice::UserExceptionHelper<Base, ::Ice::UserException>
{
public:

    virtual ~Base();

    Base(const Base&) = default;

    Base() = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    Base(const ::std::string& b) :
        b(b)
    {
    }

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&> ice_tuple() const
    {
        return std::tie(b);
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::std::string b;
};

/// \cond INTERNAL
static Base _iceS_Base_init;
/// \endcond

class KnownDerived : public ::Ice::UserExceptionHelper<KnownDerived, Base>
{
public:

    virtual ~KnownDerived();

    KnownDerived(const KnownDerived&) = default;

    KnownDerived() = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    KnownDerived(const ::std::string& b, const ::std::string& kd) :
        ::Ice::UserExceptionHelper<KnownDerived, Base>(b),
        kd(kd)
    {
    }

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::std::string&> ice_tuple() const
    {
        return std::tie(b, kd);
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::std::string kd;
};

class KnownIntermediate : public ::Ice::UserExceptionHelper<KnownIntermediate, Base>
{
public:

    virtual ~KnownIntermediate();

    KnownIntermediate(const KnownIntermediate&) = default;

    KnownIntermediate() = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    KnownIntermediate(const ::std::string& b, const ::std::string& ki) :
        ::Ice::UserExceptionHelper<KnownIntermediate, Base>(b),
        ki(ki)
    {
    }

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::std::string&> ice_tuple() const
    {
        return std::tie(b, ki);
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::std::string ki;
};

class KnownMostDerived : public ::Ice::UserExceptionHelper<KnownMostDerived, KnownIntermediate>
{
public:

    virtual ~KnownMostDerived();

    KnownMostDerived(const KnownMostDerived&) = default;

    KnownMostDerived() = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    KnownMostDerived(const ::std::string& b, const ::std::string& ki, const ::std::string& kmd) :
        ::Ice::UserExceptionHelper<KnownMostDerived, KnownIntermediate>(b, ki),
        kmd(kmd)
    {
    }

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::std::string&, const ::std::string&> ice_tuple() const
    {
        return std::tie(b, ki, kmd);
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::std::string kmd;
};

class KnownPreserved : public ::Ice::UserExceptionHelper<KnownPreserved, Base>
{
public:

    virtual ~KnownPreserved();

    KnownPreserved(const KnownPreserved&) = default;

    KnownPreserved() = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    KnownPreserved(const ::std::string& b, const ::std::string& kp) :
        ::Ice::UserExceptionHelper<KnownPreserved, Base>(b),
        kp(kp)
    {
    }

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::std::string&> ice_tuple() const
    {
        return std::tie(b, kp);
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::std::string kp;

    /**
     * Obtains the SlicedData object created when an unknown exception type was marshaled
     * in the sliced format and the Ice run time sliced it to a known type.
     * @return The SlicedData object, or nil if the exception was not sliced or was not
     * marshaled in the sliced format.
     */
    virtual ::std::shared_ptr<::Ice::SlicedData> ice_getSlicedData() const override;

    /// \cond STREAM
    virtual void _write(::Ice::OutputStream*) const override;
    virtual void _read(::Ice::InputStream*) override;

    ::std::shared_ptr<::Ice::SlicedData> _slicedData;
    /// \endcond
};

class KnownPreservedDerived : public ::Ice::UserExceptionHelper<KnownPreservedDerived, KnownPreserved>
{
public:

    virtual ~KnownPreservedDerived();

    KnownPreservedDerived(const KnownPreservedDerived&) = default;

    KnownPreservedDerived() = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    KnownPreservedDerived(const ::std::string& b, const ::std::string& kp, const ::std::string& kpd) :
        ::Ice::UserExceptionHelper<KnownPreservedDerived, KnownPreserved>(b, kp),
        kpd(kpd)
    {
    }

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::std::string&, const ::std::string&> ice_tuple() const
    {
        return std::tie(b, kp, kpd);
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::std::string kpd;
};

class UnknownDerived : public ::Ice::UserExceptionHelper<UnknownDerived, Base>
{
public:

    virtual ~UnknownDerived();

    UnknownDerived(const UnknownDerived&) = default;

    UnknownDerived() = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    UnknownDerived(const ::std::string& b, const ::std::string& ud) :
        ::Ice::UserExceptionHelper<UnknownDerived, Base>(b),
        ud(ud)
    {
    }

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::std::string&> ice_tuple() const
    {
        return std::tie(b, ud);
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::std::string ud;
};

class UnknownIntermediate : public ::Ice::UserExceptionHelper<UnknownIntermediate, Base>
{
public:

    virtual ~UnknownIntermediate();

    UnknownIntermediate(const UnknownIntermediate&) = default;

    UnknownIntermediate() = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    UnknownIntermediate(const ::std::string& b, const ::std::string& ui) :
        ::Ice::UserExceptionHelper<UnknownIntermediate, Base>(b),
        ui(ui)
    {
    }

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::std::string&> ice_tuple() const
    {
        return std::tie(b, ui);
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::std::string ui;
};

class UnknownMostDerived1 : public ::Ice::UserExceptionHelper<UnknownMostDerived1, KnownIntermediate>
{
public:

    virtual ~UnknownMostDerived1();

    UnknownMostDerived1(const UnknownMostDerived1&) = default;

    UnknownMostDerived1() = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    UnknownMostDerived1(const ::std::string& b, const ::std::string& ki, const ::std::string& umd1) :
        ::Ice::UserExceptionHelper<UnknownMostDerived1, KnownIntermediate>(b, ki),
        umd1(umd1)
    {
    }

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::std::string&, const ::std::string&> ice_tuple() const
    {
        return std::tie(b, ki, umd1);
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::std::string umd1;
};

class UnknownMostDerived2 : public ::Ice::UserExceptionHelper<UnknownMostDerived2, UnknownIntermediate>
{
public:

    virtual ~UnknownMostDerived2();

    UnknownMostDerived2(const UnknownMostDerived2&) = default;

    UnknownMostDerived2() = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    UnknownMostDerived2(const ::std::string& b, const ::std::string& ui, const ::std::string& umd2) :
        ::Ice::UserExceptionHelper<UnknownMostDerived2, UnknownIntermediate>(b, ui),
        umd2(umd2)
    {
    }

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::std::string&, const ::std::string&> ice_tuple() const
    {
        return std::tie(b, ui, umd2);
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::std::string umd2;
};

class SPreserved1 : public ::Ice::UserExceptionHelper<SPreserved1, KnownPreservedDerived>
{
public:

    virtual ~SPreserved1();

    SPreserved1(const SPreserved1&) = default;

    SPreserved1() = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    SPreserved1(const ::std::string& b, const ::std::string& kp, const ::std::string& kpd, const ::std::shared_ptr<BaseClass>& p1) :
        ::Ice::UserExceptionHelper<SPreserved1, KnownPreservedDerived>(b, kp, kpd),
        p1(p1)
    {
    }

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::std::string&, const ::std::string&, const ::std::shared_ptr<::Test::BaseClass>&> ice_tuple() const
    {
        return std::tie(b, kp, kpd, p1);
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /// \cond STREAM
    virtual bool _usesClasses() const override;
    /// \endcond

    ::std::shared_ptr<::Test::BaseClass> p1;
};

class SPreserved2 : public ::Ice::UserExceptionHelper<SPreserved2, SPreserved1>
{
public:

    virtual ~SPreserved2();

    SPreserved2(const SPreserved2&) = default;

    SPreserved2() = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    SPreserved2(const ::std::string& b, const ::std::string& kp, const ::std::string& kpd, const ::std::shared_ptr<BaseClass>& p1, const ::std::shared_ptr<BaseClass>& p2) :
        ::Ice::UserExceptionHelper<SPreserved2, SPreserved1>(b, kp, kpd, p1),
        p2(p2)
    {
    }

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::std::string&, const ::std::string&, const ::std::shared_ptr<::Test::BaseClass>&, const ::std::shared_ptr<::Test::BaseClass>&> ice_tuple() const
    {
        return std::tie(b, kp, kpd, p1, p2);
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::std::shared_ptr<::Test::BaseClass> p2;
};

}

namespace Test
{

class Relay : public virtual ::Ice::Object
{
public:

    using ProxyType = RelayPrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void knownPreservedAsBase(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_knownPreservedAsBase(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void knownPreservedAsKnownPreserved(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_knownPreservedAsKnownPreserved(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void unknownPreservedAsBase(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_unknownPreservedAsBase(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void unknownPreservedAsKnownPreserved(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_unknownPreservedAsKnownPreserved(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

class TestIntf : public virtual ::Ice::Object
{
public:

    using ProxyType = TestIntfPrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void baseAsBaseAsync(::std::function<void()> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_baseAsBase(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void unknownDerivedAsBaseAsync(::std::function<void()> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_unknownDerivedAsBase(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void knownDerivedAsBaseAsync(::std::function<void()> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_knownDerivedAsBase(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void knownDerivedAsKnownDerivedAsync(::std::function<void()> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_knownDerivedAsKnownDerived(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void unknownIntermediateAsBaseAsync(::std::function<void()> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_unknownIntermediateAsBase(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void knownIntermediateAsBaseAsync(::std::function<void()> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_knownIntermediateAsBase(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void knownMostDerivedAsBaseAsync(::std::function<void()> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_knownMostDerivedAsBase(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void knownIntermediateAsKnownIntermediateAsync(::std::function<void()> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_knownIntermediateAsKnownIntermediate(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void knownMostDerivedAsKnownIntermediateAsync(::std::function<void()> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_knownMostDerivedAsKnownIntermediate(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void knownMostDerivedAsKnownMostDerivedAsync(::std::function<void()> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_knownMostDerivedAsKnownMostDerived(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void unknownMostDerived1AsBaseAsync(::std::function<void()> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_unknownMostDerived1AsBase(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void unknownMostDerived1AsKnownIntermediateAsync(::std::function<void()> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_unknownMostDerived1AsKnownIntermediate(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void unknownMostDerived2AsBaseAsync(::std::function<void()> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_unknownMostDerived2AsBase(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void unknownMostDerived2AsBaseCompactAsync(::std::function<void()> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_unknownMostDerived2AsBaseCompact(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void knownPreservedAsBaseAsync(::std::function<void()> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_knownPreservedAsBase(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void knownPreservedAsKnownPreservedAsync(::std::function<void()> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_knownPreservedAsKnownPreserved(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void relayKnownPreservedAsBaseAsync(::std::shared_ptr<RelayPrx> r, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_relayKnownPreservedAsBase(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void relayKnownPreservedAsKnownPreservedAsync(::std::shared_ptr<RelayPrx> r, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_relayKnownPreservedAsKnownPreserved(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void unknownPreservedAsBaseAsync(::std::function<void()> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_unknownPreservedAsBase(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void unknownPreservedAsKnownPreservedAsync(::std::function<void()> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_unknownPreservedAsKnownPreserved(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void relayUnknownPreservedAsBaseAsync(::std::shared_ptr<RelayPrx> r, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_relayUnknownPreservedAsBase(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void relayUnknownPreservedAsKnownPreservedAsync(::std::shared_ptr<RelayPrx> r, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_relayUnknownPreservedAsKnownPreserved(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void shutdownAsync(::std::function<void()> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_shutdown(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

}

namespace Test
{

class BaseClass : public ::Ice::ValueHelper<BaseClass, ::Ice::Value>
{
public:

    virtual ~BaseClass();

    BaseClass() = default;

    BaseClass(const BaseClass&) = default;
    BaseClass(BaseClass&&) = default;
    BaseClass& operator=(const BaseClass&) = default;
    BaseClass& operator=(BaseClass&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit BaseClass(const ::std::string& bc) :
        bc(bc)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&> ice_tuple() const
    {
        return std::tie(bc);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /**
     * Obtains the SlicedData object created when an unknown value type was marshaled
     * in the sliced format and the Ice run time sliced it to a known type.
     * @return The SlicedData object, or nil if the value was not sliced or was not
     * marshaled in the sliced format.
     */
    virtual ::std::shared_ptr<::Ice::SlicedData> ice_getSlicedData() const override;

    /// \cond STREAM
    virtual void _iceWrite(::Ice::OutputStream*) const override;
    virtual void _iceRead(::Ice::InputStream*) override;
    /// \endcond

    ::std::string bc;

protected:

    /// \cond STREAM
    ::std::shared_ptr<::Ice::SlicedData> _iceSlicedData;
    /// \endcond
};

/// \cond INTERNAL
static BaseClass _iceS_BaseClass_init;
/// \endcond

class SPreservedClass : public ::Ice::ValueHelper<SPreservedClass, BaseClass>
{
public:

    virtual ~SPreservedClass();

    SPreservedClass() = default;

    SPreservedClass(const SPreservedClass&) = default;
    SPreservedClass(SPreservedClass&&) = default;
    SPreservedClass& operator=(const SPreservedClass&) = default;
    SPreservedClass& operator=(SPreservedClass&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    SPreservedClass(const ::std::string& bc, const ::std::string& spc) :
        Ice::ValueHelper<SPreservedClass, BaseClass>(bc),
        spc(spc)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::std::string&> ice_tuple() const
    {
        return std::tie(bc, spc);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::std::string spc;
};

}

namespace Test
{

class RelayPrx : public virtual ::Ice::Proxy<RelayPrx, ::Ice::ObjectPrx>
{
public:

    void knownPreservedAsBase(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &RelayPrx::_iceI_knownPreservedAsBase, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto knownPreservedAsBaseAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &RelayPrx::_iceI_knownPreservedAsBase, context);
    }

    ::std::function<void()>
    knownPreservedAsBaseAsync(::std::function<void()> response,
                              ::std::function<void(::std::exception_ptr)> ex = nullptr,
                              ::std::function<void(bool)> sent = nullptr,
                              const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::RelayPrx::_iceI_knownPreservedAsBase, context);
    }

    /// \cond INTERNAL
    void _iceI_knownPreservedAsBase(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    void knownPreservedAsKnownPreserved(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &RelayPrx::_iceI_knownPreservedAsKnownPreserved, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto knownPreservedAsKnownPreservedAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &RelayPrx::_iceI_knownPreservedAsKnownPreserved, context);
    }

    ::std::function<void()>
    knownPreservedAsKnownPreservedAsync(::std::function<void()> response,
                                        ::std::function<void(::std::exception_ptr)> ex = nullptr,
                                        ::std::function<void(bool)> sent = nullptr,
                                        const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::RelayPrx::_iceI_knownPreservedAsKnownPreserved, context);
    }

    /// \cond INTERNAL
    void _iceI_knownPreservedAsKnownPreserved(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    void unknownPreservedAsBase(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &RelayPrx::_iceI_unknownPreservedAsBase, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto unknownPreservedAsBaseAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &RelayPrx::_iceI_unknownPreservedAsBase, context);
    }

    ::std::function<void()>
    unknownPreservedAsBaseAsync(::std::function<void()> response,
                                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                                ::std::function<void(bool)> sent = nullptr,
                                const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::RelayPrx::_iceI_unknownPreservedAsBase, context);
    }

    /// \cond INTERNAL
    void _iceI_unknownPreservedAsBase(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    void unknownPreservedAsKnownPreserved(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &RelayPrx::_iceI_unknownPreservedAsKnownPreserved, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto unknownPreservedAsKnownPreservedAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &RelayPrx::_iceI_unknownPreservedAsKnownPreserved, context);
    }

    ::std::function<void()>
    unknownPreservedAsKnownPreservedAsync(::std::function<void()> response,
                                          ::std::function<void(::std::exception_ptr)> ex = nullptr,
                                          ::std::function<void(bool)> sent = nullptr,
                                          const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::RelayPrx::_iceI_unknownPreservedAsKnownPreserved, context);
    }

    /// \cond INTERNAL
    void _iceI_unknownPreservedAsKnownPreserved(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    RelayPrx() = default;
    friend ::std::shared_ptr<RelayPrx> IceInternal::createProxy<RelayPrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

class TestIntfPrx : public virtual ::Ice::Proxy<TestIntfPrx, ::Ice::ObjectPrx>
{
public:

    void baseAsBase(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &TestIntfPrx::_iceI_baseAsBase, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto baseAsBaseAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &TestIntfPrx::_iceI_baseAsBase, context);
    }

    ::std::function<void()>
    baseAsBaseAsync(::std::function<void()> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_baseAsBase, context);
    }

    /// \cond INTERNAL
    void _iceI_baseAsBase(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    void unknownDerivedAsBase(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &TestIntfPrx::_iceI_unknownDerivedAsBase, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto unknownDerivedAsBaseAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &TestIntfPrx::_iceI_unknownDerivedAsBase, context);
    }

    ::std::function<void()>
    unknownDerivedAsBaseAsync(::std::function<void()> response,
                              ::std::function<void(::std::exception_ptr)> ex = nullptr,
                              ::std::function<void(bool)> sent = nullptr,
                              const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_unknownDerivedAsBase, context);
    }

    /// \cond INTERNAL
    void _iceI_unknownDerivedAsBase(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    void knownDerivedAsBase(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &TestIntfPrx::_iceI_knownDerivedAsBase, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto knownDerivedAsBaseAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &TestIntfPrx::_iceI_knownDerivedAsBase, context);
    }

    ::std::function<void()>
    knownDerivedAsBaseAsync(::std::function<void()> response,
                            ::std::function<void(::std::exception_ptr)> ex = nullptr,
                            ::std::function<void(bool)> sent = nullptr,
                            const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_knownDerivedAsBase, context);
    }

    /// \cond INTERNAL
    void _iceI_knownDerivedAsBase(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    void knownDerivedAsKnownDerived(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &TestIntfPrx::_iceI_knownDerivedAsKnownDerived, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto knownDerivedAsKnownDerivedAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &TestIntfPrx::_iceI_knownDerivedAsKnownDerived, context);
    }

    ::std::function<void()>
    knownDerivedAsKnownDerivedAsync(::std::function<void()> response,
                                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                                    ::std::function<void(bool)> sent = nullptr,
                                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_knownDerivedAsKnownDerived, context);
    }

    /// \cond INTERNAL
    void _iceI_knownDerivedAsKnownDerived(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    void unknownIntermediateAsBase(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &TestIntfPrx::_iceI_unknownIntermediateAsBase, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto unknownIntermediateAsBaseAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &TestIntfPrx::_iceI_unknownIntermediateAsBase, context);
    }

    ::std::function<void()>
    unknownIntermediateAsBaseAsync(::std::function<void()> response,
                                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                                   ::std::function<void(bool)> sent = nullptr,
                                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_unknownIntermediateAsBase, context);
    }

    /// \cond INTERNAL
    void _iceI_unknownIntermediateAsBase(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    void knownIntermediateAsBase(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &TestIntfPrx::_iceI_knownIntermediateAsBase, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto knownIntermediateAsBaseAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &TestIntfPrx::_iceI_knownIntermediateAsBase, context);
    }

    ::std::function<void()>
    knownIntermediateAsBaseAsync(::std::function<void()> response,
                                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                                 ::std::function<void(bool)> sent = nullptr,
                                 const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_knownIntermediateAsBase, context);
    }

    /// \cond INTERNAL
    void _iceI_knownIntermediateAsBase(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    void knownMostDerivedAsBase(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &TestIntfPrx::_iceI_knownMostDerivedAsBase, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto knownMostDerivedAsBaseAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &TestIntfPrx::_iceI_knownMostDerivedAsBase, context);
    }

    ::std::function<void()>
    knownMostDerivedAsBaseAsync(::std::function<void()> response,
                                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                                ::std::function<void(bool)> sent = nullptr,
                                const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_knownMostDerivedAsBase, context);
    }

    /// \cond INTERNAL
    void _iceI_knownMostDerivedAsBase(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    void knownIntermediateAsKnownIntermediate(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &TestIntfPrx::_iceI_knownIntermediateAsKnownIntermediate, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto knownIntermediateAsKnownIntermediateAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &TestIntfPrx::_iceI_knownIntermediateAsKnownIntermediate, context);
    }

    ::std::function<void()>
    knownIntermediateAsKnownIntermediateAsync(::std::function<void()> response,
                                              ::std::function<void(::std::exception_ptr)> ex = nullptr,
                                              ::std::function<void(bool)> sent = nullptr,
                                              const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_knownIntermediateAsKnownIntermediate, context);
    }

    /// \cond INTERNAL
    void _iceI_knownIntermediateAsKnownIntermediate(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    void knownMostDerivedAsKnownIntermediate(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &TestIntfPrx::_iceI_knownMostDerivedAsKnownIntermediate, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto knownMostDerivedAsKnownIntermediateAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &TestIntfPrx::_iceI_knownMostDerivedAsKnownIntermediate, context);
    }

    ::std::function<void()>
    knownMostDerivedAsKnownIntermediateAsync(::std::function<void()> response,
                                             ::std::function<void(::std::exception_ptr)> ex = nullptr,
                                             ::std::function<void(bool)> sent = nullptr,
                                             const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_knownMostDerivedAsKnownIntermediate, context);
    }

    /// \cond INTERNAL
    void _iceI_knownMostDerivedAsKnownIntermediate(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    void knownMostDerivedAsKnownMostDerived(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &TestIntfPrx::_iceI_knownMostDerivedAsKnownMostDerived, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto knownMostDerivedAsKnownMostDerivedAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &TestIntfPrx::_iceI_knownMostDerivedAsKnownMostDerived, context);
    }

    ::std::function<void()>
    knownMostDerivedAsKnownMostDerivedAsync(::std::function<void()> response,
                                            ::std::function<void(::std::exception_ptr)> ex = nullptr,
                                            ::std::function<void(bool)> sent = nullptr,
                                            const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_knownMostDerivedAsKnownMostDerived, context);
    }

    /// \cond INTERNAL
    void _iceI_knownMostDerivedAsKnownMostDerived(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    void unknownMostDerived1AsBase(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &TestIntfPrx::_iceI_unknownMostDerived1AsBase, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto unknownMostDerived1AsBaseAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &TestIntfPrx::_iceI_unknownMostDerived1AsBase, context);
    }

    ::std::function<void()>
    unknownMostDerived1AsBaseAsync(::std::function<void()> response,
                                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                                   ::std::function<void(bool)> sent = nullptr,
                                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_unknownMostDerived1AsBase, context);
    }

    /// \cond INTERNAL
    void _iceI_unknownMostDerived1AsBase(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    void unknownMostDerived1AsKnownIntermediate(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &TestIntfPrx::_iceI_unknownMostDerived1AsKnownIntermediate, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto unknownMostDerived1AsKnownIntermediateAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &TestIntfPrx::_iceI_unknownMostDerived1AsKnownIntermediate, context);
    }

    ::std::function<void()>
    unknownMostDerived1AsKnownIntermediateAsync(::std::function<void()> response,
                                                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                                                ::std::function<void(bool)> sent = nullptr,
                                                const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_unknownMostDerived1AsKnownIntermediate, context);
    }

    /// \cond INTERNAL
    void _iceI_unknownMostDerived1AsKnownIntermediate(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    void unknownMostDerived2AsBase(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &TestIntfPrx::_iceI_unknownMostDerived2AsBase, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto unknownMostDerived2AsBaseAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &TestIntfPrx::_iceI_unknownMostDerived2AsBase, context);
    }

    ::std::function<void()>
    unknownMostDerived2AsBaseAsync(::std::function<void()> response,
                                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                                   ::std::function<void(bool)> sent = nullptr,
                                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_unknownMostDerived2AsBase, context);
    }

    /// \cond INTERNAL
    void _iceI_unknownMostDerived2AsBase(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    void unknownMostDerived2AsBaseCompact(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &TestIntfPrx::_iceI_unknownMostDerived2AsBaseCompact, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto unknownMostDerived2AsBaseCompactAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &TestIntfPrx::_iceI_unknownMostDerived2AsBaseCompact, context);
    }

    ::std::function<void()>
    unknownMostDerived2AsBaseCompactAsync(::std::function<void()> response,
                                          ::std::function<void(::std::exception_ptr)> ex = nullptr,
                                          ::std::function<void(bool)> sent = nullptr,
                                          const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_unknownMostDerived2AsBaseCompact, context);
    }

    /// \cond INTERNAL
    void _iceI_unknownMostDerived2AsBaseCompact(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    void knownPreservedAsBase(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &TestIntfPrx::_iceI_knownPreservedAsBase, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto knownPreservedAsBaseAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &TestIntfPrx::_iceI_knownPreservedAsBase, context);
    }

    ::std::function<void()>
    knownPreservedAsBaseAsync(::std::function<void()> response,
                              ::std::function<void(::std::exception_ptr)> ex = nullptr,
                              ::std::function<void(bool)> sent = nullptr,
                              const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_knownPreservedAsBase, context);
    }

    /// \cond INTERNAL
    void _iceI_knownPreservedAsBase(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    void knownPreservedAsKnownPreserved(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &TestIntfPrx::_iceI_knownPreservedAsKnownPreserved, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto knownPreservedAsKnownPreservedAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &TestIntfPrx::_iceI_knownPreservedAsKnownPreserved, context);
    }

    ::std::function<void()>
    knownPreservedAsKnownPreservedAsync(::std::function<void()> response,
                                        ::std::function<void(::std::exception_ptr)> ex = nullptr,
                                        ::std::function<void(bool)> sent = nullptr,
                                        const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_knownPreservedAsKnownPreserved, context);
    }

    /// \cond INTERNAL
    void _iceI_knownPreservedAsKnownPreserved(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    void relayKnownPreservedAsBase(const ::std::shared_ptr<RelayPrx>& r, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &TestIntfPrx::_iceI_relayKnownPreservedAsBase, r, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto relayKnownPreservedAsBaseAsync(const ::std::shared_ptr<RelayPrx>& r, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &TestIntfPrx::_iceI_relayKnownPreservedAsBase, r, context);
    }

    ::std::function<void()>
    relayKnownPreservedAsBaseAsync(const ::std::shared_ptr<RelayPrx>& r,
                                   ::std::function<void()> response,
                                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                                   ::std::function<void(bool)> sent = nullptr,
                                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_relayKnownPreservedAsBase, r, context);
    }

    /// \cond INTERNAL
    void _iceI_relayKnownPreservedAsBase(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::shared_ptr<RelayPrx>&, const ::Ice::Context&);
    /// \endcond

    void relayKnownPreservedAsKnownPreserved(const ::std::shared_ptr<RelayPrx>& r, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &TestIntfPrx::_iceI_relayKnownPreservedAsKnownPreserved, r, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto relayKnownPreservedAsKnownPreservedAsync(const ::std::shared_ptr<RelayPrx>& r, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &TestIntfPrx::_iceI_relayKnownPreservedAsKnownPreserved, r, context);
    }

    ::std::function<void()>
    relayKnownPreservedAsKnownPreservedAsync(const ::std::shared_ptr<RelayPrx>& r,
                                             ::std::function<void()> response,
                                             ::std::function<void(::std::exception_ptr)> ex = nullptr,
                                             ::std::function<void(bool)> sent = nullptr,
                                             const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_relayKnownPreservedAsKnownPreserved, r, context);
    }

    /// \cond INTERNAL
    void _iceI_relayKnownPreservedAsKnownPreserved(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::shared_ptr<RelayPrx>&, const ::Ice::Context&);
    /// \endcond

    void unknownPreservedAsBase(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &TestIntfPrx::_iceI_unknownPreservedAsBase, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto unknownPreservedAsBaseAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &TestIntfPrx::_iceI_unknownPreservedAsBase, context);
    }

    ::std::function<void()>
    unknownPreservedAsBaseAsync(::std::function<void()> response,
                                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                                ::std::function<void(bool)> sent = nullptr,
                                const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_unknownPreservedAsBase, context);
    }

    /// \cond INTERNAL
    void _iceI_unknownPreservedAsBase(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    void unknownPreservedAsKnownPreserved(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &TestIntfPrx::_iceI_unknownPreservedAsKnownPreserved, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto unknownPreservedAsKnownPreservedAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &TestIntfPrx::_iceI_unknownPreservedAsKnownPreserved, context);
    }

    ::std::function<void()>
    unknownPreservedAsKnownPreservedAsync(::std::function<void()> response,
                                          ::std::function<void(::std::exception_ptr)> ex = nullptr,
                                          ::std::function<void(bool)> sent = nullptr,
                                          const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_unknownPreservedAsKnownPreserved, context);
    }

    /// \cond INTERNAL
    void _iceI_unknownPreservedAsKnownPreserved(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    void relayUnknownPreservedAsBase(const ::std::shared_ptr<RelayPrx>& r, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &TestIntfPrx::_iceI_relayUnknownPreservedAsBase, r, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto relayUnknownPreservedAsBaseAsync(const ::std::shared_ptr<RelayPrx>& r, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &TestIntfPrx::_iceI_relayUnknownPreservedAsBase, r, context);
    }

    ::std::function<void()>
    relayUnknownPreservedAsBaseAsync(const ::std::shared_ptr<RelayPrx>& r,
                                     ::std::function<void()> response,
                                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                                     ::std::function<void(bool)> sent = nullptr,
                                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_relayUnknownPreservedAsBase, r, context);
    }

    /// \cond INTERNAL
    void _iceI_relayUnknownPreservedAsBase(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::shared_ptr<RelayPrx>&, const ::Ice::Context&);
    /// \endcond

    void relayUnknownPreservedAsKnownPreserved(const ::std::shared_ptr<RelayPrx>& r, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &TestIntfPrx::_iceI_relayUnknownPreservedAsKnownPreserved, r, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto relayUnknownPreservedAsKnownPreservedAsync(const ::std::shared_ptr<RelayPrx>& r, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &TestIntfPrx::_iceI_relayUnknownPreservedAsKnownPreserved, r, context);
    }

    ::std::function<void()>
    relayUnknownPreservedAsKnownPreservedAsync(const ::std::shared_ptr<RelayPrx>& r,
                                               ::std::function<void()> response,
                                               ::std::function<void(::std::exception_ptr)> ex = nullptr,
                                               ::std::function<void(bool)> sent = nullptr,
                                               const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_relayUnknownPreservedAsKnownPreserved, r, context);
    }

    /// \cond INTERNAL
    void _iceI_relayUnknownPreservedAsKnownPreserved(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::shared_ptr<RelayPrx>&, const ::Ice::Context&);
    /// \endcond

    void shutdown(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &TestIntfPrx::_iceI_shutdown, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto shutdownAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &TestIntfPrx::_iceI_shutdown, context);
    }

    ::std::function<void()>
    shutdownAsync(::std::function<void()> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_shutdown, context);
    }

    /// \cond INTERNAL
    void _iceI_shutdown(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    TestIntfPrx() = default;
    friend ::std::shared_ptr<TestIntfPrx> IceInternal::createProxy<TestIntfPrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

}

/// \cond STREAM
namespace Ice
{

template<typename S>
struct StreamReader<::Test::Base, S>
{
    static void read(S* istr, ::Test::Base& v)
    {
        istr->readAll(v.b);
    }
};

template<typename S>
struct StreamWriter<::Test::KnownDerived, S>
{
    static void write(S* ostr, const ::Test::KnownDerived& v)
    {
        ostr->writeAll(v.kd);
    }
};

template<typename S>
struct StreamReader<::Test::KnownDerived, S>
{
    static void read(S* istr, ::Test::KnownDerived& v)
    {
        istr->readAll(v.kd);
    }
};

template<typename S>
struct StreamWriter<::Test::KnownIntermediate, S>
{
    static void write(S* ostr, const ::Test::KnownIntermediate& v)
    {
        ostr->writeAll(v.ki);
    }
};

template<typename S>
struct StreamReader<::Test::KnownIntermediate, S>
{
    static void read(S* istr, ::Test::KnownIntermediate& v)
    {
        istr->readAll(v.ki);
    }
};

template<typename S>
struct StreamWriter<::Test::KnownMostDerived, S>
{
    static void write(S* ostr, const ::Test::KnownMostDerived& v)
    {
        ostr->writeAll(v.kmd);
    }
};

template<typename S>
struct StreamReader<::Test::KnownMostDerived, S>
{
    static void read(S* istr, ::Test::KnownMostDerived& v)
    {
        istr->readAll(v.kmd);
    }
};

template<typename S>
struct StreamWriter<::Test::KnownPreserved, S>
{
    static void write(S* ostr, const ::Test::KnownPreserved& v)
    {
        ostr->writeAll(v.kp);
    }
};

template<typename S>
struct StreamReader<::Test::KnownPreserved, S>
{
    static void read(S* istr, ::Test::KnownPreserved& v)
    {
        istr->readAll(v.kp);
    }
};

template<typename S>
struct StreamWriter<::Test::KnownPreservedDerived, S>
{
    static void write(S* ostr, const ::Test::KnownPreservedDerived& v)
    {
        ostr->writeAll(v.kpd);
    }
};

template<typename S>
struct StreamReader<::Test::KnownPreservedDerived, S>
{
    static void read(S* istr, ::Test::KnownPreservedDerived& v)
    {
        istr->readAll(v.kpd);
    }
};

template<typename S>
struct StreamReader<::Test::BaseClass, S>
{
    static void read(S* istr, ::Test::BaseClass& v)
    {
        istr->readAll(v.bc);
    }
};

template<typename S>
struct StreamWriter<::Test::UnknownDerived, S>
{
    static void write(S* ostr, const ::Test::UnknownDerived& v)
    {
        ostr->writeAll(v.ud);
    }
};

template<typename S>
struct StreamReader<::Test::UnknownDerived, S>
{
    static void read(S* istr, ::Test::UnknownDerived& v)
    {
        istr->readAll(v.ud);
    }
};

template<typename S>
struct StreamWriter<::Test::UnknownIntermediate, S>
{
    static void write(S* ostr, const ::Test::UnknownIntermediate& v)
    {
        ostr->writeAll(v.ui);
    }
};

template<typename S>
struct StreamReader<::Test::UnknownIntermediate, S>
{
    static void read(S* istr, ::Test::UnknownIntermediate& v)
    {
        istr->readAll(v.ui);
    }
};

template<typename S>
struct StreamWriter<::Test::UnknownMostDerived1, S>
{
    static void write(S* ostr, const ::Test::UnknownMostDerived1& v)
    {
        ostr->writeAll(v.umd1);
    }
};

template<typename S>
struct StreamReader<::Test::UnknownMostDerived1, S>
{
    static void read(S* istr, ::Test::UnknownMostDerived1& v)
    {
        istr->readAll(v.umd1);
    }
};

template<typename S>
struct StreamWriter<::Test::UnknownMostDerived2, S>
{
    static void write(S* ostr, const ::Test::UnknownMostDerived2& v)
    {
        ostr->writeAll(v.umd2);
    }
};

template<typename S>
struct StreamReader<::Test::UnknownMostDerived2, S>
{
    static void read(S* istr, ::Test::UnknownMostDerived2& v)
    {
        istr->readAll(v.umd2);
    }
};

template<typename S>
struct StreamWriter<::Test::SPreservedClass, S>
{
    static void write(S* ostr, const ::Test::SPreservedClass& v)
    {
        ostr->writeAll(v.spc);
    }
};

template<typename S>
struct StreamReader<::Test::SPreservedClass, S>
{
    static void read(S* istr, ::Test::SPreservedClass& v)
    {
        istr->readAll(v.spc);
    }
};

template<typename S>
struct StreamWriter<::Test::SPreserved1, S>
{
    static void write(S* ostr, const ::Test::SPreserved1& v)
    {
        ostr->writeAll(v.p1);
    }
};

template<typename S>
struct StreamReader<::Test::SPreserved1, S>
{
    static void read(S* istr, ::Test::SPreserved1& v)
    {
        istr->readAll(v.p1);
    }
};

template<typename S>
struct StreamWriter<::Test::SPreserved2, S>
{
    static void write(S* ostr, const ::Test::SPreserved2& v)
    {
        ostr->writeAll(v.p2);
    }
};

template<typename S>
struct StreamReader<::Test::SPreserved2, S>
{
    static void read(S* istr, ::Test::SPreserved2& v)
    {
        istr->readAll(v.p2);
    }
};

}
/// \endcond

/// \cond INTERNAL
namespace Test
{

using BaseClassPtr = ::std::shared_ptr<BaseClass>;

using RelayPtr = ::std::shared_ptr<Relay>;
using RelayPrxPtr = ::std::shared_ptr<RelayPrx>;

using TestIntfPtr = ::std::shared_ptr<TestIntf>;
using TestIntfPrxPtr = ::std::shared_ptr<TestIntfPrx>;

using SPreservedClassPtr = ::std::shared_ptr<SPreservedClass>;

}
/// \endcond

#else // C++98 mapping

namespace IceProxy
{

namespace Test
{

class Relay;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< Relay>&);
::IceProxy::Ice::Object* upCast(Relay*);
/// \endcond

class TestIntf;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< TestIntf>&);
::IceProxy::Ice::Object* upCast(TestIntf*);
/// \endcond

}

}

namespace Test
{

class BaseClass;
using BaseClassPtr = ::Ice::SharedPtr<BaseClass>;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::Relay> RelayPrx;
typedef RelayPrx RelayPrxPtr;

class Relay;
using RelayPtr = ::Ice::SharedPtr< Relay>;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::TestIntf> TestIntfPrx;
typedef TestIntfPrx TestIntfPrxPtr;

class TestIntf;
using TestIntfPtr = ::Ice::SharedPtr< TestIntf>;

class SPreservedClass;
using SPreservedClassPtr = ::Ice::SharedPtr<SPreservedClass>;

}

namespace Test
{

class Base : public ::Ice::UserException
{
public:

    Base() {}
    /**
     * One-shot constructor to initialize all data members.
     */
    explicit Base(const ::std::string& b);
    Base(const Base&) = default;
    virtual ~Base();

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    virtual ::std::string ice_id() const;
    /**
     * Polymorphically clones this exception.
     * @return A shallow copy of this exception.
     */
    virtual Base* ice_clone() const;
    /**
     * Throws this exception.
     */
    virtual void ice_throw() const;

    ::std::string b;

protected:

    /// \cond STREAM
    virtual void _writeImpl(::Ice::OutputStream*) const;
    virtual void _readImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
static Base _iceS_Base_init;
/// \endcond

class KnownDerived : public Base
{
public:

    KnownDerived() {}
    /**
     * One-shot constructor to initialize all data members.
     */
    KnownDerived(const ::std::string& b, const ::std::string& kd);
    KnownDerived(const KnownDerived&) = default;
    virtual ~KnownDerived();

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    virtual ::std::string ice_id() const;
    /**
     * Polymorphically clones this exception.
     * @return A shallow copy of this exception.
     */
    virtual KnownDerived* ice_clone() const;
    /**
     * Throws this exception.
     */
    virtual void ice_throw() const;

    ::std::string kd;

protected:

    /// \cond STREAM
    virtual void _writeImpl(::Ice::OutputStream*) const;
    virtual void _readImpl(::Ice::InputStream*);
    /// \endcond
};

class KnownIntermediate : public Base
{
public:

    KnownIntermediate() {}
    /**
     * One-shot constructor to initialize all data members.
     */
    KnownIntermediate(const ::std::string& b, const ::std::string& ki);
    KnownIntermediate(const KnownIntermediate&) = default;
    virtual ~KnownIntermediate();

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    virtual ::std::string ice_id() const;
    /**
     * Polymorphically clones this exception.
     * @return A shallow copy of this exception.
     */
    virtual KnownIntermediate* ice_clone() const;
    /**
     * Throws this exception.
     */
    virtual void ice_throw() const;

    ::std::string ki;

protected:

    /// \cond STREAM
    virtual void _writeImpl(::Ice::OutputStream*) const;
    virtual void _readImpl(::Ice::InputStream*);
    /// \endcond
};

class KnownMostDerived : public KnownIntermediate
{
public:

    KnownMostDerived() {}
    /**
     * One-shot constructor to initialize all data members.
     */
    KnownMostDerived(const ::std::string& b, const ::std::string& ki, const ::std::string& kmd);
    KnownMostDerived(const KnownMostDerived&) = default;
    virtual ~KnownMostDerived();

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    virtual ::std::string ice_id() const;
    /**
     * Polymorphically clones this exception.
     * @return A shallow copy of this exception.
     */
    virtual KnownMostDerived* ice_clone() const;
    /**
     * Throws this exception.
     */
    virtual void ice_throw() const;

    ::std::string kmd;

protected:

    /// \cond STREAM
    virtual void _writeImpl(::Ice::OutputStream*) const;
    virtual void _readImpl(::Ice::InputStream*);
    /// \endcond
};

class KnownPreserved : public Base
{
public:

    KnownPreserved() {}
    /**
     * One-shot constructor to initialize all data members.
     */
    KnownPreserved(const ::std::string& b, const ::std::string& kp);
    KnownPreserved(const KnownPreserved&) = default;
    virtual ~KnownPreserved();

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    virtual ::std::string ice_id() const;
    /**
     * Polymorphically clones this exception.
     * @return A shallow copy of this exception.
     */
    virtual KnownPreserved* ice_clone() const;
    /**
     * Throws this exception.
     */
    virtual void ice_throw() const;

    ::std::string kp;

    /**
     * Obtains the SlicedData object created when an unknown exception type was marshaled
     * in the sliced format and the Ice run time sliced it to a known type.
     * @return The SlicedData object, or nil if the exception was not sliced or was not
     * marshaled in the sliced format.
     */
    virtual ::Ice::SlicedDataPtr ice_getSlicedData() const;

    /// \cond STREAM
    virtual void _write(::Ice::OutputStream*) const;
    virtual void _read(::Ice::InputStream*);
    using ::Test::Base::_write;
    using ::Test::Base::_read;
    /// \endcond

protected:

    /// \cond STREAM
    virtual void _writeImpl(::Ice::OutputStream*) const;
    virtual void _readImpl(::Ice::InputStream*);
    /// \endcond

    /// \cond STREAM
    ::Ice::SlicedDataPtr _slicedData;
    /// \endcond
};

class KnownPreservedDerived : public KnownPreserved
{
public:

    KnownPreservedDerived() {}
    /**
     * One-shot constructor to initialize all data members.
     */
    KnownPreservedDerived(const ::std::string& b, const ::std::string& kp, const ::std::string& kpd);
    KnownPreservedDerived(const KnownPreservedDerived&) = default;
    virtual ~KnownPreservedDerived();

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    virtual ::std::string ice_id() const;
    /**
     * Polymorphically clones this exception.
     * @return A shallow copy of this exception.
     */
    virtual KnownPreservedDerived* ice_clone() const;
    /**
     * Throws this exception.
     */
    virtual void ice_throw() const;

    ::std::string kpd;

protected:

    /// \cond STREAM
    virtual void _writeImpl(::Ice::OutputStream*) const;
    virtual void _readImpl(::Ice::InputStream*);
    /// \endcond
};

class UnknownDerived : public Base
{
public:

    UnknownDerived() {}
    /**
     * One-shot constructor to initialize all data members.
     */
    UnknownDerived(const ::std::string& b, const ::std::string& ud);
    UnknownDerived(const UnknownDerived&) = default;
    virtual ~UnknownDerived();

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    virtual ::std::string ice_id() const;
    /**
     * Polymorphically clones this exception.
     * @return A shallow copy of this exception.
     */
    virtual UnknownDerived* ice_clone() const;
    /**
     * Throws this exception.
     */
    virtual void ice_throw() const;

    ::std::string ud;

protected:

    /// \cond STREAM
    virtual void _writeImpl(::Ice::OutputStream*) const;
    virtual void _readImpl(::Ice::InputStream*);
    /// \endcond
};

class UnknownIntermediate : public Base
{
public:

    UnknownIntermediate() {}
    /**
     * One-shot constructor to initialize all data members.
     */
    UnknownIntermediate(const ::std::string& b, const ::std::string& ui);
    UnknownIntermediate(const UnknownIntermediate&) = default;
    virtual ~UnknownIntermediate();

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    virtual ::std::string ice_id() const;
    /**
     * Polymorphically clones this exception.
     * @return A shallow copy of this exception.
     */
    virtual UnknownIntermediate* ice_clone() const;
    /**
     * Throws this exception.
     */
    virtual void ice_throw() const;

    ::std::string ui;

protected:

    /// \cond STREAM
    virtual void _writeImpl(::Ice::OutputStream*) const;
    virtual void _readImpl(::Ice::InputStream*);
    /// \endcond
};

class UnknownMostDerived1 : public KnownIntermediate
{
public:

    UnknownMostDerived1() {}
    /**
     * One-shot constructor to initialize all data members.
     */
    UnknownMostDerived1(const ::std::string& b, const ::std::string& ki, const ::std::string& umd1);
    UnknownMostDerived1(const UnknownMostDerived1&) = default;
    virtual ~UnknownMostDerived1();

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    virtual ::std::string ice_id() const;
    /**
     * Polymorphically clones this exception.
     * @return A shallow copy of this exception.
     */
    virtual UnknownMostDerived1* ice_clone() const;
    /**
     * Throws this exception.
     */
    virtual void ice_throw() const;

    ::std::string umd1;

protected:

    /// \cond STREAM
    virtual void _writeImpl(::Ice::OutputStream*) const;
    virtual void _readImpl(::Ice::InputStream*);
    /// \endcond
};

class UnknownMostDerived2 : public UnknownIntermediate
{
public:

    UnknownMostDerived2() {}
    /**
     * One-shot constructor to initialize all data members.
     */
    UnknownMostDerived2(const ::std::string& b, const ::std::string& ui, const ::std::string& umd2);
    UnknownMostDerived2(const UnknownMostDerived2&) = default;
    virtual ~UnknownMostDerived2();

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    virtual ::std::string ice_id() const;
    /**
     * Polymorphically clones this exception.
     * @return A shallow copy of this exception.
     */
    virtual UnknownMostDerived2* ice_clone() const;
    /**
     * Throws this exception.
     */
    virtual void ice_throw() const;

    ::std::string umd2;

protected:

    /// \cond STREAM
    virtual void _writeImpl(::Ice::OutputStream*) const;
    virtual void _readImpl(::Ice::InputStream*);
    /// \endcond
};

class SPreserved1 : public KnownPreservedDerived
{
public:

    SPreserved1() {}
    /**
     * One-shot constructor to initialize all data members.
     */
    SPreserved1(const ::std::string& b, const ::std::string& kp, const ::std::string& kpd, const BaseClassPtr& p1);
    SPreserved1(const SPreserved1&) = default;
    virtual ~SPreserved1();

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    virtual ::std::string ice_id() const;
    /**
     * Polymorphically clones this exception.
     * @return A shallow copy of this exception.
     */
    virtual SPreserved1* ice_clone() const;
    /**
     * Throws this exception.
     */
    virtual void ice_throw() const;

    /// \cond STREAM
    virtual bool _usesClasses() const;
    /// \endcond

    ::Test::BaseClassPtr p1;

protected:

    /// \cond STREAM
    virtual void _writeImpl(::Ice::OutputStream*) const;
    virtual void _readImpl(::Ice::InputStream*);
    /// \endcond
};

class SPreserved2 : public SPreserved1
{
public:

    SPreserved2() {}
    /**
     * One-shot constructor to initialize all data members.
     */
    SPreserved2(const ::std::string& b, const ::std::string& kp, const ::std::string& kpd, const BaseClassPtr& p1, const BaseClassPtr& p2);
    SPreserved2(const SPreserved2&) = default;
    virtual ~SPreserved2();

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    virtual ::std::string ice_id() const;
    /**
     * Polymorphically clones this exception.
     * @return A shallow copy of this exception.
     */
    virtual SPreserved2* ice_clone() const;
    /**
     * Throws this exception.
     */
    virtual void ice_throw() const;

    ::Test::BaseClassPtr p2;

protected:

    /// \cond STREAM
    virtual void _writeImpl(::Ice::OutputStream*) const;
    virtual void _readImpl(::Ice::InputStream*);
    /// \endcond
};

}

namespace Test
{

/**
 * AMD callback class for Test::TestIntf::baseAsBase_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_TestIntf_baseAsBase : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_TestIntf_baseAsBase();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_TestIntf_baseAsBase> AMD_TestIntf_baseAsBasePtr;

/**
 * AMD callback class for Test::TestIntf::unknownDerivedAsBase_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_TestIntf_unknownDerivedAsBase : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_TestIntf_unknownDerivedAsBase();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_TestIntf_unknownDerivedAsBase> AMD_TestIntf_unknownDerivedAsBasePtr;

/**
 * AMD callback class for Test::TestIntf::knownDerivedAsBase_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_TestIntf_knownDerivedAsBase : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_TestIntf_knownDerivedAsBase();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_TestIntf_knownDerivedAsBase> AMD_TestIntf_knownDerivedAsBasePtr;

/**
 * AMD callback class for Test::TestIntf::knownDerivedAsKnownDerived_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_TestIntf_knownDerivedAsKnownDerived : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_TestIntf_knownDerivedAsKnownDerived();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_TestIntf_knownDerivedAsKnownDerived> AMD_TestIntf_knownDerivedAsKnownDerivedPtr;

/**
 * AMD callback class for Test::TestIntf::unknownIntermediateAsBase_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_TestIntf_unknownIntermediateAsBase : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_TestIntf_unknownIntermediateAsBase();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_TestIntf_unknownIntermediateAsBase> AMD_TestIntf_unknownIntermediateAsBasePtr;

/**
 * AMD callback class for Test::TestIntf::knownIntermediateAsBase_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_TestIntf_knownIntermediateAsBase : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_TestIntf_knownIntermediateAsBase();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_TestIntf_knownIntermediateAsBase> AMD_TestIntf_knownIntermediateAsBasePtr;

/**
 * AMD callback class for Test::TestIntf::knownMostDerivedAsBase_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_TestIntf_knownMostDerivedAsBase : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_TestIntf_knownMostDerivedAsBase();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_TestIntf_knownMostDerivedAsBase> AMD_TestIntf_knownMostDerivedAsBasePtr;

/**
 * AMD callback class for Test::TestIntf::knownIntermediateAsKnownIntermediate_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_TestIntf_knownIntermediateAsKnownIntermediate : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_TestIntf_knownIntermediateAsKnownIntermediate();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_TestIntf_knownIntermediateAsKnownIntermediate> AMD_TestIntf_knownIntermediateAsKnownIntermediatePtr;

/**
 * AMD callback class for Test::TestIntf::knownMostDerivedAsKnownIntermediate_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_TestIntf_knownMostDerivedAsKnownIntermediate : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_TestIntf_knownMostDerivedAsKnownIntermediate();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_TestIntf_knownMostDerivedAsKnownIntermediate> AMD_TestIntf_knownMostDerivedAsKnownIntermediatePtr;

/**
 * AMD callback class for Test::TestIntf::knownMostDerivedAsKnownMostDerived_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_TestIntf_knownMostDerivedAsKnownMostDerived : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_TestIntf_knownMostDerivedAsKnownMostDerived();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_TestIntf_knownMostDerivedAsKnownMostDerived> AMD_TestIntf_knownMostDerivedAsKnownMostDerivedPtr;

/**
 * AMD callback class for Test::TestIntf::unknownMostDerived1AsBase_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_TestIntf_unknownMostDerived1AsBase : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_TestIntf_unknownMostDerived1AsBase();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_TestIntf_unknownMostDerived1AsBase> AMD_TestIntf_unknownMostDerived1AsBasePtr;

/**
 * AMD callback class for Test::TestIntf::unknownMostDerived1AsKnownIntermediate_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_TestIntf_unknownMostDerived1AsKnownIntermediate : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_TestIntf_unknownMostDerived1AsKnownIntermediate();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_TestIntf_unknownMostDerived1AsKnownIntermediate> AMD_TestIntf_unknownMostDerived1AsKnownIntermediatePtr;

/**
 * AMD callback class for Test::TestIntf::unknownMostDerived2AsBase_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_TestIntf_unknownMostDerived2AsBase : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_TestIntf_unknownMostDerived2AsBase();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_TestIntf_unknownMostDerived2AsBase> AMD_TestIntf_unknownMostDerived2AsBasePtr;

/**
 * AMD callback class for Test::TestIntf::unknownMostDerived2AsBaseCompact_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_TestIntf_unknownMostDerived2AsBaseCompact : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_TestIntf_unknownMostDerived2AsBaseCompact();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_TestIntf_unknownMostDerived2AsBaseCompact> AMD_TestIntf_unknownMostDerived2AsBaseCompactPtr;

/**
 * AMD callback class for Test::TestIntf::knownPreservedAsBase_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_TestIntf_knownPreservedAsBase : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_TestIntf_knownPreservedAsBase();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_TestIntf_knownPreservedAsBase> AMD_TestIntf_knownPreservedAsBasePtr;

/**
 * AMD callback class for Test::TestIntf::knownPreservedAsKnownPreserved_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_TestIntf_knownPreservedAsKnownPreserved : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_TestIntf_knownPreservedAsKnownPreserved();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_TestIntf_knownPreservedAsKnownPreserved> AMD_TestIntf_knownPreservedAsKnownPreservedPtr;

/**
 * AMD callback class for Test::TestIntf::relayKnownPreservedAsBase_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_TestIntf_relayKnownPreservedAsBase : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_TestIntf_relayKnownPreservedAsBase();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_TestIntf_relayKnownPreservedAsBase> AMD_TestIntf_relayKnownPreservedAsBasePtr;

/**
 * AMD callback class for Test::TestIntf::relayKnownPreservedAsKnownPreserved_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_TestIntf_relayKnownPreservedAsKnownPreserved : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_TestIntf_relayKnownPreservedAsKnownPreserved();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_TestIntf_relayKnownPreservedAsKnownPreserved> AMD_TestIntf_relayKnownPreservedAsKnownPreservedPtr;

/**
 * AMD callback class for Test::TestIntf::unknownPreservedAsBase_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_TestIntf_unknownPreservedAsBase : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_TestIntf_unknownPreservedAsBase();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_TestIntf_unknownPreservedAsBase> AMD_TestIntf_unknownPreservedAsBasePtr;

/**
 * AMD callback class for Test::TestIntf::unknownPreservedAsKnownPreserved_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_TestIntf_unknownPreservedAsKnownPreserved : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_TestIntf_unknownPreservedAsKnownPreserved();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_TestIntf_unknownPreservedAsKnownPreserved> AMD_TestIntf_unknownPreservedAsKnownPreservedPtr;

/**
 * AMD callback class for Test::TestIntf::relayUnknownPreservedAsBase_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_TestIntf_relayUnknownPreservedAsBase : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_TestIntf_relayUnknownPreservedAsBase();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_TestIntf_relayUnknownPreservedAsBase> AMD_TestIntf_relayUnknownPreservedAsBasePtr;

/**
 * AMD callback class for Test::TestIntf::relayUnknownPreservedAsKnownPreserved_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_TestIntf_relayUnknownPreservedAsKnownPreserved : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_TestIntf_relayUnknownPreservedAsKnownPreserved();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_TestIntf_relayUnknownPreservedAsKnownPreserved> AMD_TestIntf_relayUnknownPreservedAsKnownPreservedPtr;

/**
 * AMD callback class for Test::TestIntf::shutdown_async.
 * Call the ice_response method for a successful completion, or the ice_exception
 * method in the case of an error.
 */
class AMD_TestIntf_shutdown : public virtual ::Ice::AMDCallback
{
public:

    virtual ~AMD_TestIntf_shutdown();

    /**
     * Call ice_response for a successful completion.
     */
    virtual void ice_response() = 0;
};

typedef ::IceUtil::Handle< ::Test::AMD_TestIntf_shutdown> AMD_TestIntf_shutdownPtr;

}

/// \cond INTERNAL
namespace IceAsync
{

namespace Test
{

#if defined(_MSC_VER)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_TestIntf_baseAsBase : public ::Test::AMD_TestIntf_baseAsBase, public ::IceInternal::IncomingAsync
{
public:

    AMD_TestIntf_baseAsBase(::IceInternal::Incoming&);

    virtual void ice_response();
};

#if defined(_MSC_VER)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_TestIntf_unknownDerivedAsBase : public ::Test::AMD_TestIntf_unknownDerivedAsBase, public ::IceInternal::IncomingAsync
{
public:

    AMD_TestIntf_unknownDerivedAsBase(::IceInternal::Incoming&);

    virtual void ice_response();
};

#if defined(_MSC_VER)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_TestIntf_knownDerivedAsBase : public ::Test::AMD_TestIntf_knownDerivedAsBase, public ::IceInternal::IncomingAsync
{
public:

    AMD_TestIntf_knownDerivedAsBase(::IceInternal::Incoming&);

    virtual void ice_response();
};

#if defined(_MSC_VER)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_TestIntf_knownDerivedAsKnownDerived : public ::Test::AMD_TestIntf_knownDerivedAsKnownDerived, public ::IceInternal::IncomingAsync
{
public:

    AMD_TestIntf_knownDerivedAsKnownDerived(::IceInternal::Incoming&);

    virtual void ice_response();
};

#if defined(_MSC_VER)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_TestIntf_unknownIntermediateAsBase : public ::Test::AMD_TestIntf_unknownIntermediateAsBase, public ::IceInternal::IncomingAsync
{
public:

    AMD_TestIntf_unknownIntermediateAsBase(::IceInternal::Incoming&);

    virtual void ice_response();
};

#if defined(_MSC_VER)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_TestIntf_knownIntermediateAsBase : public ::Test::AMD_TestIntf_knownIntermediateAsBase, public ::IceInternal::IncomingAsync
{
public:

    AMD_TestIntf_knownIntermediateAsBase(::IceInternal::Incoming&);

    virtual void ice_response();
};

#if defined(_MSC_VER)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_TestIntf_knownMostDerivedAsBase : public ::Test::AMD_TestIntf_knownMostDerivedAsBase, public ::IceInternal::IncomingAsync
{
public:

    AMD_TestIntf_knownMostDerivedAsBase(::IceInternal::Incoming&);

    virtual void ice_response();
};

#if defined(_MSC_VER)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_TestIntf_knownIntermediateAsKnownIntermediate : public ::Test::AMD_TestIntf_knownIntermediateAsKnownIntermediate, public ::IceInternal::IncomingAsync
{
public:

    AMD_TestIntf_knownIntermediateAsKnownIntermediate(::IceInternal::Incoming&);

    virtual void ice_response();
};

#if defined(_MSC_VER)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_TestIntf_knownMostDerivedAsKnownIntermediate : public ::Test::AMD_TestIntf_knownMostDerivedAsKnownIntermediate, public ::IceInternal::IncomingAsync
{
public:

    AMD_TestIntf_knownMostDerivedAsKnownIntermediate(::IceInternal::Incoming&);

    virtual void ice_response();
};

#if defined(_MSC_VER)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_TestIntf_knownMostDerivedAsKnownMostDerived : public ::Test::AMD_TestIntf_knownMostDerivedAsKnownMostDerived, public ::IceInternal::IncomingAsync
{
public:

    AMD_TestIntf_knownMostDerivedAsKnownMostDerived(::IceInternal::Incoming&);

    virtual void ice_response();
};

#if defined(_MSC_VER)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_TestIntf_unknownMostDerived1AsBase : public ::Test::AMD_TestIntf_unknownMostDerived1AsBase, public ::IceInternal::IncomingAsync
{
public:

    AMD_TestIntf_unknownMostDerived1AsBase(::IceInternal::Incoming&);

    virtual void ice_response();
};

#if defined(_MSC_VER)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_TestIntf_unknownMostDerived1AsKnownIntermediate : public ::Test::AMD_TestIntf_unknownMostDerived1AsKnownIntermediate, public ::IceInternal::IncomingAsync
{
public:

    AMD_TestIntf_unknownMostDerived1AsKnownIntermediate(::IceInternal::Incoming&);

    virtual void ice_response();
};

#if defined(_MSC_VER)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_TestIntf_unknownMostDerived2AsBase : public ::Test::AMD_TestIntf_unknownMostDerived2AsBase, public ::IceInternal::IncomingAsync
{
public:

    AMD_TestIntf_unknownMostDerived2AsBase(::IceInternal::Incoming&);

    virtual void ice_response();
};

#if defined(_MSC_VER)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_TestIntf_unknownMostDerived2AsBaseCompact : public ::Test::AMD_TestIntf_unknownMostDerived2AsBaseCompact, public ::IceInternal::IncomingAsync
{
public:

    AMD_TestIntf_unknownMostDerived2AsBaseCompact(::IceInternal::Incoming&);

    virtual void ice_response();
};

#if defined(_MSC_VER)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_TestIntf_knownPreservedAsBase : public ::Test::AMD_TestIntf_knownPreservedAsBase, public ::IceInternal::IncomingAsync
{
public:

    AMD_TestIntf_knownPreservedAsBase(::IceInternal::Incoming&);

    virtual void ice_response();
};

#if defined(_MSC_VER)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_TestIntf_knownPreservedAsKnownPreserved : public ::Test::AMD_TestIntf_knownPreservedAsKnownPreserved, public ::IceInternal::IncomingAsync
{
public:

    AMD_TestIntf_knownPreservedAsKnownPreserved(::IceInternal::Incoming&);

    virtual void ice_response();
};

#if defined(_MSC_VER)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_TestIntf_relayKnownPreservedAsBase : public ::Test::AMD_TestIntf_relayKnownPreservedAsBase, public ::IceInternal::IncomingAsync
{
public:

    AMD_TestIntf_relayKnownPreservedAsBase(::IceInternal::Incoming&);

    virtual void ice_response();
};

#if defined(_MSC_VER)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_TestIntf_relayKnownPreservedAsKnownPreserved : public ::Test::AMD_TestIntf_relayKnownPreservedAsKnownPreserved, public ::IceInternal::IncomingAsync
{
public:

    AMD_TestIntf_relayKnownPreservedAsKnownPreserved(::IceInternal::Incoming&);

    virtual void ice_response();
};

#if defined(_MSC_VER)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_TestIntf_unknownPreservedAsBase : public ::Test::AMD_TestIntf_unknownPreservedAsBase, public ::IceInternal::IncomingAsync
{
public:

    AMD_TestIntf_unknownPreservedAsBase(::IceInternal::Incoming&);

    virtual void ice_response();
};

#if defined(_MSC_VER)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_TestIntf_unknownPreservedAsKnownPreserved : public ::Test::AMD_TestIntf_unknownPreservedAsKnownPreserved, public ::IceInternal::IncomingAsync
{
public:

    AMD_TestIntf_unknownPreservedAsKnownPreserved(::IceInternal::Incoming&);

    virtual void ice_response();
};

#if defined(_MSC_VER)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_TestIntf_relayUnknownPreservedAsBase : public ::Test::AMD_TestIntf_relayUnknownPreservedAsBase, public ::IceInternal::IncomingAsync
{
public:

    AMD_TestIntf_relayUnknownPreservedAsBase(::IceInternal::Incoming&);

    virtual void ice_response();
};

#if defined(_MSC_VER)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_TestIntf_relayUnknownPreservedAsKnownPreserved : public ::Test::AMD_TestIntf_relayUnknownPreservedAsKnownPreserved, public ::IceInternal::IncomingAsync
{
public:

    AMD_TestIntf_relayUnknownPreservedAsKnownPreserved(::IceInternal::Incoming&);

    virtual void ice_response();
};

#if defined(_MSC_VER)
#   pragma warning(pop)
#endif

#if defined(_MSC_VER)
#   pragma warning(push)
#   pragma warning(disable:4239)
#endif

class AMD_TestIntf_shutdown : public ::Test::AMD_TestIntf_shutdown, public ::IceInternal::IncomingAsync
{
public:

    AMD_TestIntf_shutdown(::IceInternal::Incoming&);

    virtual void ice_response();
};

#if defined(_MSC_VER)
#   pragma warning(pop)
#endif

}

}
/// \endcond

namespace Test
{

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Relay::begin_knownPreservedAsBase.
 * Create a wrapper instance by calling ::Test::newCallback_Relay_knownPreservedAsBase.
 */
class Callback_Relay_knownPreservedAsBase_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Relay_knownPreservedAsBase_Base> Callback_Relay_knownPreservedAsBasePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Relay::begin_knownPreservedAsKnownPreserved.
 * Create a wrapper instance by calling ::Test::newCallback_Relay_knownPreservedAsKnownPreserved.
 */
class Callback_Relay_knownPreservedAsKnownPreserved_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Relay_knownPreservedAsKnownPreserved_Base> Callback_Relay_knownPreservedAsKnownPreservedPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Relay::begin_unknownPreservedAsBase.
 * Create a wrapper instance by calling ::Test::newCallback_Relay_unknownPreservedAsBase.
 */
class Callback_Relay_unknownPreservedAsBase_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Relay_unknownPreservedAsBase_Base> Callback_Relay_unknownPreservedAsBasePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Relay::begin_unknownPreservedAsKnownPreserved.
 * Create a wrapper instance by calling ::Test::newCallback_Relay_unknownPreservedAsKnownPreserved.
 */
class Callback_Relay_unknownPreservedAsKnownPreserved_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Relay_unknownPreservedAsKnownPreserved_Base> Callback_Relay_unknownPreservedAsKnownPreservedPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_baseAsBase.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_baseAsBase.
 */
class Callback_TestIntf_baseAsBase_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_baseAsBase_Base> Callback_TestIntf_baseAsBasePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_unknownDerivedAsBase.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_unknownDerivedAsBase.
 */
class Callback_TestIntf_unknownDerivedAsBase_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_unknownDerivedAsBase_Base> Callback_TestIntf_unknownDerivedAsBasePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_knownDerivedAsBase.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_knownDerivedAsBase.
 */
class Callback_TestIntf_knownDerivedAsBase_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_knownDerivedAsBase_Base> Callback_TestIntf_knownDerivedAsBasePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_knownDerivedAsKnownDerived.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_knownDerivedAsKnownDerived.
 */
class Callback_TestIntf_knownDerivedAsKnownDerived_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_knownDerivedAsKnownDerived_Base> Callback_TestIntf_knownDerivedAsKnownDerivedPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_unknownIntermediateAsBase.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_unknownIntermediateAsBase.
 */
class Callback_TestIntf_unknownIntermediateAsBase_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_unknownIntermediateAsBase_Base> Callback_TestIntf_unknownIntermediateAsBasePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_knownIntermediateAsBase.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_knownIntermediateAsBase.
 */
class Callback_TestIntf_knownIntermediateAsBase_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_knownIntermediateAsBase_Base> Callback_TestIntf_knownIntermediateAsBasePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_knownMostDerivedAsBase.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_knownMostDerivedAsBase.
 */
class Callback_TestIntf_knownMostDerivedAsBase_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_knownMostDerivedAsBase_Base> Callback_TestIntf_knownMostDerivedAsBasePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_knownIntermediateAsKnownIntermediate.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_knownIntermediateAsKnownIntermediate.
 */
class Callback_TestIntf_knownIntermediateAsKnownIntermediate_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_knownIntermediateAsKnownIntermediate_Base> Callback_TestIntf_knownIntermediateAsKnownIntermediatePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_knownMostDerivedAsKnownIntermediate.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_knownMostDerivedAsKnownIntermediate.
 */
class Callback_TestIntf_knownMostDerivedAsKnownIntermediate_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_knownMostDerivedAsKnownIntermediate_Base> Callback_TestIntf_knownMostDerivedAsKnownIntermediatePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_knownMostDerivedAsKnownMostDerived.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_knownMostDerivedAsKnownMostDerived.
 */
class Callback_TestIntf_knownMostDerivedAsKnownMostDerived_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_knownMostDerivedAsKnownMostDerived_Base> Callback_TestIntf_knownMostDerivedAsKnownMostDerivedPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_unknownMostDerived1AsBase.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_unknownMostDerived1AsBase.
 */
class Callback_TestIntf_unknownMostDerived1AsBase_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_unknownMostDerived1AsBase_Base> Callback_TestIntf_unknownMostDerived1AsBasePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_unknownMostDerived1AsKnownIntermediate.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_unknownMostDerived1AsKnownIntermediate.
 */
class Callback_TestIntf_unknownMostDerived1AsKnownIntermediate_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_unknownMostDerived1AsKnownIntermediate_Base> Callback_TestIntf_unknownMostDerived1AsKnownIntermediatePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_unknownMostDerived2AsBase.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_unknownMostDerived2AsBase.
 */
class Callback_TestIntf_unknownMostDerived2AsBase_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_unknownMostDerived2AsBase_Base> Callback_TestIntf_unknownMostDerived2AsBasePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_unknownMostDerived2AsBaseCompact.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_unknownMostDerived2AsBaseCompact.
 */
class Callback_TestIntf_unknownMostDerived2AsBaseCompact_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_unknownMostDerived2AsBaseCompact_Base> Callback_TestIntf_unknownMostDerived2AsBaseCompactPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_knownPreservedAsBase.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_knownPreservedAsBase.
 */
class Callback_TestIntf_knownPreservedAsBase_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_knownPreservedAsBase_Base> Callback_TestIntf_knownPreservedAsBasePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_knownPreservedAsKnownPreserved.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_knownPreservedAsKnownPreserved.
 */
class Callback_TestIntf_knownPreservedAsKnownPreserved_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_knownPreservedAsKnownPreserved_Base> Callback_TestIntf_knownPreservedAsKnownPreservedPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_relayKnownPreservedAsBase.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_relayKnownPreservedAsBase.
 */
class Callback_TestIntf_relayKnownPreservedAsBase_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_relayKnownPreservedAsBase_Base> Callback_TestIntf_relayKnownPreservedAsBasePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_relayKnownPreservedAsKnownPreserved.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_relayKnownPreservedAsKnownPreserved.
 */
class Callback_TestIntf_relayKnownPreservedAsKnownPreserved_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_relayKnownPreservedAsKnownPreserved_Base> Callback_TestIntf_relayKnownPreservedAsKnownPreservedPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_unknownPreservedAsBase.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_unknownPreservedAsBase.
 */
class Callback_TestIntf_unknownPreservedAsBase_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_unknownPreservedAsBase_Base> Callback_TestIntf_unknownPreservedAsBasePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_unknownPreservedAsKnownPreserved.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_unknownPreservedAsKnownPreserved.
 */
class Callback_TestIntf_unknownPreservedAsKnownPreserved_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_unknownPreservedAsKnownPreserved_Base> Callback_TestIntf_unknownPreservedAsKnownPreservedPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_relayUnknownPreservedAsBase.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_relayUnknownPreservedAsBase.
 */
class Callback_TestIntf_relayUnknownPreservedAsBase_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_relayUnknownPreservedAsBase_Base> Callback_TestIntf_relayUnknownPreservedAsBasePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_relayUnknownPreservedAsKnownPreserved.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_relayUnknownPreservedAsKnownPreserved.
 */
class Callback_TestIntf_relayUnknownPreservedAsKnownPreserved_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_relayUnknownPreservedAsKnownPreserved_Base> Callback_TestIntf_relayUnknownPreservedAsKnownPreservedPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_shutdown.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_shutdown.
 */
class Callback_TestIntf_shutdown_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_shutdown_Base> Callback_TestIntf_shutdownPtr;

}

namespace IceProxy
{

namespace Test
{

class Relay : public virtual ::Ice::Proxy<Relay, ::IceProxy::Ice::Object>
{
public:

    void knownPreservedAsBase(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_knownPreservedAsBase(_iceI_begin_knownPreservedAsBase(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_knownPreservedAsBase(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_knownPreservedAsBase(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_knownPreservedAsBase(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_knownPreservedAsBase(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_knownPreservedAsBase(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_knownPreservedAsBase(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_knownPreservedAsBase(const ::Test::Callback_Relay_knownPreservedAsBasePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_knownPreservedAsBase(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_knownPreservedAsBase(const ::Ice::Context& context, const ::Test::Callback_Relay_knownPreservedAsBasePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_knownPreservedAsBase(context, cb, cookie);
    }

    void end_knownPreservedAsBase(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_knownPreservedAsBase(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void knownPreservedAsKnownPreserved(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_knownPreservedAsKnownPreserved(_iceI_begin_knownPreservedAsKnownPreserved(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_knownPreservedAsKnownPreserved(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_knownPreservedAsKnownPreserved(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_knownPreservedAsKnownPreserved(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_knownPreservedAsKnownPreserved(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_knownPreservedAsKnownPreserved(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_knownPreservedAsKnownPreserved(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_knownPreservedAsKnownPreserved(const ::Test::Callback_Relay_knownPreservedAsKnownPreservedPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_knownPreservedAsKnownPreserved(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_knownPreservedAsKnownPreserved(const ::Ice::Context& context, const ::Test::Callback_Relay_knownPreservedAsKnownPreservedPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_knownPreservedAsKnownPreserved(context, cb, cookie);
    }

    void end_knownPreservedAsKnownPreserved(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_knownPreservedAsKnownPreserved(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void unknownPreservedAsBase(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_unknownPreservedAsBase(_iceI_begin_unknownPreservedAsBase(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_unknownPreservedAsBase(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_unknownPreservedAsBase(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_unknownPreservedAsBase(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_unknownPreservedAsBase(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_unknownPreservedAsBase(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_unknownPreservedAsBase(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_unknownPreservedAsBase(const ::Test::Callback_Relay_unknownPreservedAsBasePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_unknownPreservedAsBase(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_unknownPreservedAsBase(const ::Ice::Context& context, const ::Test::Callback_Relay_unknownPreservedAsBasePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_unknownPreservedAsBase(context, cb, cookie);
    }

    void end_unknownPreservedAsBase(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_unknownPreservedAsBase(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void unknownPreservedAsKnownPreserved(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_unknownPreservedAsKnownPreserved(_iceI_begin_unknownPreservedAsKnownPreserved(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_unknownPreservedAsKnownPreserved(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_unknownPreservedAsKnownPreserved(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_unknownPreservedAsKnownPreserved(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_unknownPreservedAsKnownPreserved(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_unknownPreservedAsKnownPreserved(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_unknownPreservedAsKnownPreserved(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_unknownPreservedAsKnownPreserved(const ::Test::Callback_Relay_unknownPreservedAsKnownPreservedPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_unknownPreservedAsKnownPreserved(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_unknownPreservedAsKnownPreserved(const ::Ice::Context& context, const ::Test::Callback_Relay_unknownPreservedAsKnownPreservedPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_unknownPreservedAsKnownPreserved(context, cb, cookie);
    }

    void end_unknownPreservedAsKnownPreserved(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_unknownPreservedAsKnownPreserved(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class TestIntf : public virtual ::Ice::Proxy<TestIntf, ::IceProxy::Ice::Object>
{
public:

    void baseAsBase(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_baseAsBase(_iceI_begin_baseAsBase(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_baseAsBase(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_baseAsBase(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_baseAsBase(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_baseAsBase(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_baseAsBase(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_baseAsBase(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_baseAsBase(const ::Test::Callback_TestIntf_baseAsBasePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_baseAsBase(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_baseAsBase(const ::Ice::Context& context, const ::Test::Callback_TestIntf_baseAsBasePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_baseAsBase(context, cb, cookie);
    }

    void end_baseAsBase(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_baseAsBase(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void unknownDerivedAsBase(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_unknownDerivedAsBase(_iceI_begin_unknownDerivedAsBase(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_unknownDerivedAsBase(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_unknownDerivedAsBase(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_unknownDerivedAsBase(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_unknownDerivedAsBase(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_unknownDerivedAsBase(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_unknownDerivedAsBase(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_unknownDerivedAsBase(const ::Test::Callback_TestIntf_unknownDerivedAsBasePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_unknownDerivedAsBase(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_unknownDerivedAsBase(const ::Ice::Context& context, const ::Test::Callback_TestIntf_unknownDerivedAsBasePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_unknownDerivedAsBase(context, cb, cookie);
    }

    void end_unknownDerivedAsBase(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_unknownDerivedAsBase(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void knownDerivedAsBase(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_knownDerivedAsBase(_iceI_begin_knownDerivedAsBase(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_knownDerivedAsBase(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_knownDerivedAsBase(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_knownDerivedAsBase(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_knownDerivedAsBase(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_knownDerivedAsBase(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_knownDerivedAsBase(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_knownDerivedAsBase(const ::Test::Callback_TestIntf_knownDerivedAsBasePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_knownDerivedAsBase(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_knownDerivedAsBase(const ::Ice::Context& context, const ::Test::Callback_TestIntf_knownDerivedAsBasePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_knownDerivedAsBase(context, cb, cookie);
    }

    void end_knownDerivedAsBase(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_knownDerivedAsBase(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void knownDerivedAsKnownDerived(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_knownDerivedAsKnownDerived(_iceI_begin_knownDerivedAsKnownDerived(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_knownDerivedAsKnownDerived(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_knownDerivedAsKnownDerived(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_knownDerivedAsKnownDerived(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_knownDerivedAsKnownDerived(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_knownDerivedAsKnownDerived(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_knownDerivedAsKnownDerived(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_knownDerivedAsKnownDerived(const ::Test::Callback_TestIntf_knownDerivedAsKnownDerivedPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_knownDerivedAsKnownDerived(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_knownDerivedAsKnownDerived(const ::Ice::Context& context, const ::Test::Callback_TestIntf_knownDerivedAsKnownDerivedPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_knownDerivedAsKnownDerived(context, cb, cookie);
    }

    void end_knownDerivedAsKnownDerived(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_knownDerivedAsKnownDerived(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void unknownIntermediateAsBase(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_unknownIntermediateAsBase(_iceI_begin_unknownIntermediateAsBase(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_unknownIntermediateAsBase(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_unknownIntermediateAsBase(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_unknownIntermediateAsBase(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_unknownIntermediateAsBase(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_unknownIntermediateAsBase(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_unknownIntermediateAsBase(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_unknownIntermediateAsBase(const ::Test::Callback_TestIntf_unknownIntermediateAsBasePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_unknownIntermediateAsBase(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_unknownIntermediateAsBase(const ::Ice::Context& context, const ::Test::Callback_TestIntf_unknownIntermediateAsBasePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_unknownIntermediateAsBase(context, cb, cookie);
    }

    void end_unknownIntermediateAsBase(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_unknownIntermediateAsBase(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void knownIntermediateAsBase(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_knownIntermediateAsBase(_iceI_begin_knownIntermediateAsBase(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_knownIntermediateAsBase(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_knownIntermediateAsBase(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_knownIntermediateAsBase(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_knownIntermediateAsBase(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_knownIntermediateAsBase(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_knownIntermediateAsBase(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_knownIntermediateAsBase(const ::Test::Callback_TestIntf_knownIntermediateAsBasePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_knownIntermediateAsBase(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_knownIntermediateAsBase(const ::Ice::Context& context, const ::Test::Callback_TestIntf_knownIntermediateAsBasePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_knownIntermediateAsBase(context, cb, cookie);
    }

    void end_knownIntermediateAsBase(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_knownIntermediateAsBase(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void knownMostDerivedAsBase(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_knownMostDerivedAsBase(_iceI_begin_knownMostDerivedAsBase(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_knownMostDerivedAsBase(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_knownMostDerivedAsBase(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_knownMostDerivedAsBase(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_knownMostDerivedAsBase(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_knownMostDerivedAsBase(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_knownMostDerivedAsBase(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_knownMostDerivedAsBase(const ::Test::Callback_TestIntf_knownMostDerivedAsBasePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_knownMostDerivedAsBase(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_knownMostDerivedAsBase(const ::Ice::Context& context, const ::Test::Callback_TestIntf_knownMostDerivedAsBasePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_knownMostDerivedAsBase(context, cb, cookie);
    }

    void end_knownMostDerivedAsBase(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_knownMostDerivedAsBase(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void knownIntermediateAsKnownIntermediate(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_knownIntermediateAsKnownIntermediate(_iceI_begin_knownIntermediateAsKnownIntermediate(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_knownIntermediateAsKnownIntermediate(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_knownIntermediateAsKnownIntermediate(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_knownIntermediateAsKnownIntermediate(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_knownIntermediateAsKnownIntermediate(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_knownIntermediateAsKnownIntermediate(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_knownIntermediateAsKnownIntermediate(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_knownIntermediateAsKnownIntermediate(const ::Test::Callback_TestIntf_knownIntermediateAsKnownIntermediatePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_knownIntermediateAsKnownIntermediate(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_knownIntermediateAsKnownIntermediate(const ::Ice::Context& context, const ::Test::Callback_TestIntf_knownIntermediateAsKnownIntermediatePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_knownIntermediateAsKnownIntermediate(context, cb, cookie);
    }

    void end_knownIntermediateAsKnownIntermediate(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_knownIntermediateAsKnownIntermediate(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void knownMostDerivedAsKnownIntermediate(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_knownMostDerivedAsKnownIntermediate(_iceI_begin_knownMostDerivedAsKnownIntermediate(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_knownMostDerivedAsKnownIntermediate(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_knownMostDerivedAsKnownIntermediate(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_knownMostDerivedAsKnownIntermediate(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_knownMostDerivedAsKnownIntermediate(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_knownMostDerivedAsKnownIntermediate(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_knownMostDerivedAsKnownIntermediate(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_knownMostDerivedAsKnownIntermediate(const ::Test::Callback_TestIntf_knownMostDerivedAsKnownIntermediatePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_knownMostDerivedAsKnownIntermediate(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_knownMostDerivedAsKnownIntermediate(const ::Ice::Context& context, const ::Test::Callback_TestIntf_knownMostDerivedAsKnownIntermediatePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_knownMostDerivedAsKnownIntermediate(context, cb, cookie);
    }

    void end_knownMostDerivedAsKnownIntermediate(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_knownMostDerivedAsKnownIntermediate(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void knownMostDerivedAsKnownMostDerived(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_knownMostDerivedAsKnownMostDerived(_iceI_begin_knownMostDerivedAsKnownMostDerived(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_knownMostDerivedAsKnownMostDerived(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_knownMostDerivedAsKnownMostDerived(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_knownMostDerivedAsKnownMostDerived(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_knownMostDerivedAsKnownMostDerived(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_knownMostDerivedAsKnownMostDerived(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_knownMostDerivedAsKnownMostDerived(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_knownMostDerivedAsKnownMostDerived(const ::Test::Callback_TestIntf_knownMostDerivedAsKnownMostDerivedPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_knownMostDerivedAsKnownMostDerived(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_knownMostDerivedAsKnownMostDerived(const ::Ice::Context& context, const ::Test::Callback_TestIntf_knownMostDerivedAsKnownMostDerivedPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_knownMostDerivedAsKnownMostDerived(context, cb, cookie);
    }

    void end_knownMostDerivedAsKnownMostDerived(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_knownMostDerivedAsKnownMostDerived(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void unknownMostDerived1AsBase(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_unknownMostDerived1AsBase(_iceI_begin_unknownMostDerived1AsBase(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_unknownMostDerived1AsBase(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_unknownMostDerived1AsBase(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_unknownMostDerived1AsBase(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_unknownMostDerived1AsBase(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_unknownMostDerived1AsBase(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_unknownMostDerived1AsBase(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_unknownMostDerived1AsBase(const ::Test::Callback_TestIntf_unknownMostDerived1AsBasePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_unknownMostDerived1AsBase(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_unknownMostDerived1AsBase(const ::Ice::Context& context, const ::Test::Callback_TestIntf_unknownMostDerived1AsBasePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_unknownMostDerived1AsBase(context, cb, cookie);
    }

    void end_unknownMostDerived1AsBase(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_unknownMostDerived1AsBase(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void unknownMostDerived1AsKnownIntermediate(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_unknownMostDerived1AsKnownIntermediate(_iceI_begin_unknownMostDerived1AsKnownIntermediate(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_unknownMostDerived1AsKnownIntermediate(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_unknownMostDerived1AsKnownIntermediate(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_unknownMostDerived1AsKnownIntermediate(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_unknownMostDerived1AsKnownIntermediate(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_unknownMostDerived1AsKnownIntermediate(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_unknownMostDerived1AsKnownIntermediate(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_unknownMostDerived1AsKnownIntermediate(const ::Test::Callback_TestIntf_unknownMostDerived1AsKnownIntermediatePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_unknownMostDerived1AsKnownIntermediate(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_unknownMostDerived1AsKnownIntermediate(const ::Ice::Context& context, const ::Test::Callback_TestIntf_unknownMostDerived1AsKnownIntermediatePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_unknownMostDerived1AsKnownIntermediate(context, cb, cookie);
    }

    void end_unknownMostDerived1AsKnownIntermediate(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_unknownMostDerived1AsKnownIntermediate(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void unknownMostDerived2AsBase(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_unknownMostDerived2AsBase(_iceI_begin_unknownMostDerived2AsBase(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_unknownMostDerived2AsBase(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_unknownMostDerived2AsBase(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_unknownMostDerived2AsBase(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_unknownMostDerived2AsBase(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_unknownMostDerived2AsBase(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_unknownMostDerived2AsBase(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_unknownMostDerived2AsBase(const ::Test::Callback_TestIntf_unknownMostDerived2AsBasePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_unknownMostDerived2AsBase(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_unknownMostDerived2AsBase(const ::Ice::Context& context, const ::Test::Callback_TestIntf_unknownMostDerived2AsBasePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_unknownMostDerived2AsBase(context, cb, cookie);
    }

    void end_unknownMostDerived2AsBase(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_unknownMostDerived2AsBase(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void unknownMostDerived2AsBaseCompact(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_unknownMostDerived2AsBaseCompact(_iceI_begin_unknownMostDerived2AsBaseCompact(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_unknownMostDerived2AsBaseCompact(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_unknownMostDerived2AsBaseCompact(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_unknownMostDerived2AsBaseCompact(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_unknownMostDerived2AsBaseCompact(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_unknownMostDerived2AsBaseCompact(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_unknownMostDerived2AsBaseCompact(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_unknownMostDerived2AsBaseCompact(const ::Test::Callback_TestIntf_unknownMostDerived2AsBaseCompactPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_unknownMostDerived2AsBaseCompact(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_unknownMostDerived2AsBaseCompact(const ::Ice::Context& context, const ::Test::Callback_TestIntf_unknownMostDerived2AsBaseCompactPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_unknownMostDerived2AsBaseCompact(context, cb, cookie);
    }

    void end_unknownMostDerived2AsBaseCompact(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_unknownMostDerived2AsBaseCompact(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void knownPreservedAsBase(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_knownPreservedAsBase(_iceI_begin_knownPreservedAsBase(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_knownPreservedAsBase(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_knownPreservedAsBase(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_knownPreservedAsBase(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_knownPreservedAsBase(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_knownPreservedAsBase(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_knownPreservedAsBase(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_knownPreservedAsBase(const ::Test::Callback_TestIntf_knownPreservedAsBasePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_knownPreservedAsBase(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_knownPreservedAsBase(const ::Ice::Context& context, const ::Test::Callback_TestIntf_knownPreservedAsBasePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_knownPreservedAsBase(context, cb, cookie);
    }

    void end_knownPreservedAsBase(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_knownPreservedAsBase(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void knownPreservedAsKnownPreserved(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_knownPreservedAsKnownPreserved(_iceI_begin_knownPreservedAsKnownPreserved(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_knownPreservedAsKnownPreserved(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_knownPreservedAsKnownPreserved(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_knownPreservedAsKnownPreserved(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_knownPreservedAsKnownPreserved(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_knownPreservedAsKnownPreserved(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_knownPreservedAsKnownPreserved(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_knownPreservedAsKnownPreserved(const ::Test::Callback_TestIntf_knownPreservedAsKnownPreservedPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_knownPreservedAsKnownPreserved(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_knownPreservedAsKnownPreserved(const ::Ice::Context& context, const ::Test::Callback_TestIntf_knownPreservedAsKnownPreservedPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_knownPreservedAsKnownPreserved(context, cb, cookie);
    }

    void end_knownPreservedAsKnownPreserved(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_knownPreservedAsKnownPreserved(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void relayKnownPreservedAsBase(const ::Test::RelayPrx& r, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_relayKnownPreservedAsBase(_iceI_begin_relayKnownPreservedAsBase(r, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_relayKnownPreservedAsBase(const ::Test::RelayPrx& r, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_relayKnownPreservedAsBase(r, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_relayKnownPreservedAsBase(const ::Test::RelayPrx& r, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_relayKnownPreservedAsBase(r, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_relayKnownPreservedAsBase(const ::Test::RelayPrx& r, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_relayKnownPreservedAsBase(r, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_relayKnownPreservedAsBase(const ::Test::RelayPrx& r, const ::Test::Callback_TestIntf_relayKnownPreservedAsBasePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_relayKnownPreservedAsBase(r, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_relayKnownPreservedAsBase(const ::Test::RelayPrx& r, const ::Ice::Context& context, const ::Test::Callback_TestIntf_relayKnownPreservedAsBasePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_relayKnownPreservedAsBase(r, context, cb, cookie);
    }

    void end_relayKnownPreservedAsBase(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_relayKnownPreservedAsBase(const ::Test::RelayPrx&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void relayKnownPreservedAsKnownPreserved(const ::Test::RelayPrx& r, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_relayKnownPreservedAsKnownPreserved(_iceI_begin_relayKnownPreservedAsKnownPreserved(r, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_relayKnownPreservedAsKnownPreserved(const ::Test::RelayPrx& r, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_relayKnownPreservedAsKnownPreserved(r, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_relayKnownPreservedAsKnownPreserved(const ::Test::RelayPrx& r, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_relayKnownPreservedAsKnownPreserved(r, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_relayKnownPreservedAsKnownPreserved(const ::Test::RelayPrx& r, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_relayKnownPreservedAsKnownPreserved(r, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_relayKnownPreservedAsKnownPreserved(const ::Test::RelayPrx& r, const ::Test::Callback_TestIntf_relayKnownPreservedAsKnownPreservedPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_relayKnownPreservedAsKnownPreserved(r, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_relayKnownPreservedAsKnownPreserved(const ::Test::RelayPrx& r, const ::Ice::Context& context, const ::Test::Callback_TestIntf_relayKnownPreservedAsKnownPreservedPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_relayKnownPreservedAsKnownPreserved(r, context, cb, cookie);
    }

    void end_relayKnownPreservedAsKnownPreserved(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_relayKnownPreservedAsKnownPreserved(const ::Test::RelayPrx&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void unknownPreservedAsBase(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_unknownPreservedAsBase(_iceI_begin_unknownPreservedAsBase(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_unknownPreservedAsBase(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_unknownPreservedAsBase(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_unknownPreservedAsBase(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_unknownPreservedAsBase(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_unknownPreservedAsBase(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_unknownPreservedAsBase(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_unknownPreservedAsBase(const ::Test::Callback_TestIntf_unknownPreservedAsBasePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_unknownPreservedAsBase(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_unknownPreservedAsBase(const ::Ice::Context& context, const ::Test::Callback_TestIntf_unknownPreservedAsBasePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_unknownPreservedAsBase(context, cb, cookie);
    }

    void end_unknownPreservedAsBase(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_unknownPreservedAsBase(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void unknownPreservedAsKnownPreserved(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_unknownPreservedAsKnownPreserved(_iceI_begin_unknownPreservedAsKnownPreserved(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_unknownPreservedAsKnownPreserved(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_unknownPreservedAsKnownPreserved(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_unknownPreservedAsKnownPreserved(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_unknownPreservedAsKnownPreserved(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_unknownPreservedAsKnownPreserved(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_unknownPreservedAsKnownPreserved(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_unknownPreservedAsKnownPreserved(const ::Test::Callback_TestIntf_unknownPreservedAsKnownPreservedPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_unknownPreservedAsKnownPreserved(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_unknownPreservedAsKnownPreserved(const ::Ice::Context& context, const ::Test::Callback_TestIntf_unknownPreservedAsKnownPreservedPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_unknownPreservedAsKnownPreserved(context, cb, cookie);
    }

    void end_unknownPreservedAsKnownPreserved(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_unknownPreservedAsKnownPreserved(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void relayUnknownPreservedAsBase(const ::Test::RelayPrx& r, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_relayUnknownPreservedAsBase(_iceI_begin_relayUnknownPreservedAsBase(r, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_relayUnknownPreservedAsBase(const ::Test::RelayPrx& r, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_relayUnknownPreservedAsBase(r, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_relayUnknownPreservedAsBase(const ::Test::RelayPrx& r, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_relayUnknownPreservedAsBase(r, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_relayUnknownPreservedAsBase(const ::Test::RelayPrx& r, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_relayUnknownPreservedAsBase(r, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_relayUnknownPreservedAsBase(const ::Test::RelayPrx& r, const ::Test::Callback_TestIntf_relayUnknownPreservedAsBasePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_relayUnknownPreservedAsBase(r, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_relayUnknownPreservedAsBase(const ::Test::RelayPrx& r, const ::Ice::Context& context, const ::Test::Callback_TestIntf_relayUnknownPreservedAsBasePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_relayUnknownPreservedAsBase(r, context, cb, cookie);
    }

    void end_relayUnknownPreservedAsBase(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_relayUnknownPreservedAsBase(const ::Test::RelayPrx&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void relayUnknownPreservedAsKnownPreserved(const ::Test::RelayPrx& r, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_relayUnknownPreservedAsKnownPreserved(_iceI_begin_relayUnknownPreservedAsKnownPreserved(r, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_relayUnknownPreservedAsKnownPreserved(const ::Test::RelayPrx& r, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_relayUnknownPreservedAsKnownPreserved(r, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_relayUnknownPreservedAsKnownPreserved(const ::Test::RelayPrx& r, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_relayUnknownPreservedAsKnownPreserved(r, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_relayUnknownPreservedAsKnownPreserved(const ::Test::RelayPrx& r, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_relayUnknownPreservedAsKnownPreserved(r, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_relayUnknownPreservedAsKnownPreserved(const ::Test::RelayPrx& r, const ::Test::Callback_TestIntf_relayUnknownPreservedAsKnownPreservedPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_relayUnknownPreservedAsKnownPreserved(r, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_relayUnknownPreservedAsKnownPreserved(const ::Test::RelayPrx& r, const ::Ice::Context& context, const ::Test::Callback_TestIntf_relayUnknownPreservedAsKnownPreservedPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_relayUnknownPreservedAsKnownPreserved(r, context, cb, cookie);
    }

    void end_relayUnknownPreservedAsKnownPreserved(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_relayUnknownPreservedAsKnownPreserved(const ::Test::RelayPrx&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void shutdown(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_shutdown(_iceI_begin_shutdown(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_shutdown(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_shutdown(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_shutdown(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_shutdown(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_shutdown(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_shutdown(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_shutdown(const ::Test::Callback_TestIntf_shutdownPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_shutdown(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_shutdown(const ::Ice::Context& context, const ::Test::Callback_TestIntf_shutdownPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_shutdown(context, cb, cookie);
    }

    void end_shutdown(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_shutdown(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

}

}

namespace Test
{

class Relay : public virtual ::Ice::Object
{
public:

    typedef RelayPrx ProxyType;

    virtual ~Relay();
    Relay() = default;
    Relay(const Relay&) = default;
    Relay& operator=(const Relay&) = default;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void knownPreservedAsBase(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_knownPreservedAsBase(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void knownPreservedAsKnownPreserved(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_knownPreservedAsKnownPreserved(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void unknownPreservedAsBase(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_unknownPreservedAsBase(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void unknownPreservedAsKnownPreserved(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_unknownPreservedAsKnownPreserved(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond
};

class TestIntf : public virtual ::Ice::Object
{
public:

    typedef TestIntfPrx ProxyType;

    virtual ~TestIntf();
    TestIntf() = default;
    TestIntf(const TestIntf&) = default;
    TestIntf& operator=(const TestIntf&) = default;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void baseAsBase_async(const ::Test::AMD_TestIntf_baseAsBasePtr& cb, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_baseAsBase(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void unknownDerivedAsBase_async(const ::Test::AMD_TestIntf_unknownDerivedAsBasePtr& cb, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_unknownDerivedAsBase(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void knownDerivedAsBase_async(const ::Test::AMD_TestIntf_knownDerivedAsBasePtr& cb, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_knownDerivedAsBase(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void knownDerivedAsKnownDerived_async(const ::Test::AMD_TestIntf_knownDerivedAsKnownDerivedPtr& cb, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_knownDerivedAsKnownDerived(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void unknownIntermediateAsBase_async(const ::Test::AMD_TestIntf_unknownIntermediateAsBasePtr& cb, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_unknownIntermediateAsBase(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void knownIntermediateAsBase_async(const ::Test::AMD_TestIntf_knownIntermediateAsBasePtr& cb, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_knownIntermediateAsBase(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void knownMostDerivedAsBase_async(const ::Test::AMD_TestIntf_knownMostDerivedAsBasePtr& cb, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_knownMostDerivedAsBase(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void knownIntermediateAsKnownIntermediate_async(const ::Test::AMD_TestIntf_knownIntermediateAsKnownIntermediatePtr& cb, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_knownIntermediateAsKnownIntermediate(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void knownMostDerivedAsKnownIntermediate_async(const ::Test::AMD_TestIntf_knownMostDerivedAsKnownIntermediatePtr& cb, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_knownMostDerivedAsKnownIntermediate(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void knownMostDerivedAsKnownMostDerived_async(const ::Test::AMD_TestIntf_knownMostDerivedAsKnownMostDerivedPtr& cb, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_knownMostDerivedAsKnownMostDerived(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void unknownMostDerived1AsBase_async(const ::Test::AMD_TestIntf_unknownMostDerived1AsBasePtr& cb, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_unknownMostDerived1AsBase(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void unknownMostDerived1AsKnownIntermediate_async(const ::Test::AMD_TestIntf_unknownMostDerived1AsKnownIntermediatePtr& cb, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_unknownMostDerived1AsKnownIntermediate(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void unknownMostDerived2AsBase_async(const ::Test::AMD_TestIntf_unknownMostDerived2AsBasePtr& cb, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_unknownMostDerived2AsBase(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void unknownMostDerived2AsBaseCompact_async(const ::Test::AMD_TestIntf_unknownMostDerived2AsBaseCompactPtr& cb, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_unknownMostDerived2AsBaseCompact(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void knownPreservedAsBase_async(const ::Test::AMD_TestIntf_knownPreservedAsBasePtr& cb, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_knownPreservedAsBase(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void knownPreservedAsKnownPreserved_async(const ::Test::AMD_TestIntf_knownPreservedAsKnownPreservedPtr& cb, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_knownPreservedAsKnownPreserved(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void relayKnownPreservedAsBase_async(const ::Test::AMD_TestIntf_relayKnownPreservedAsBasePtr& cb, const RelayPrx& r, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_relayKnownPreservedAsBase(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void relayKnownPreservedAsKnownPreserved_async(const ::Test::AMD_TestIntf_relayKnownPreservedAsKnownPreservedPtr& cb, const RelayPrx& r, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_relayKnownPreservedAsKnownPreserved(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void unknownPreservedAsBase_async(const ::Test::AMD_TestIntf_unknownPreservedAsBasePtr& cb, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_unknownPreservedAsBase(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void unknownPreservedAsKnownPreserved_async(const ::Test::AMD_TestIntf_unknownPreservedAsKnownPreservedPtr& cb, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_unknownPreservedAsKnownPreserved(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void relayUnknownPreservedAsBase_async(const ::Test::AMD_TestIntf_relayUnknownPreservedAsBasePtr& cb, const RelayPrx& r, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_relayUnknownPreservedAsBase(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void relayUnknownPreservedAsKnownPreserved_async(const ::Test::AMD_TestIntf_relayUnknownPreservedAsKnownPreservedPtr& cb, const RelayPrx& r, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_relayUnknownPreservedAsKnownPreserved(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void shutdown_async(const ::Test::AMD_TestIntf_shutdownPtr& cb, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_shutdown(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond
};

}

namespace Test
{

class BaseClass : public ::Ice::ValueHelper<BaseClass, ::Ice::Value>
{
public:

    virtual ~BaseClass();

    BaseClass() = default;

    BaseClass(const BaseClass&) = default;
    BaseClass(BaseClass&&) = default;
    BaseClass& operator=(const BaseClass&) = default;
    BaseClass& operator=(BaseClass&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit BaseClass(const ::std::string& bc) :
        bc(bc)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&> ice_tuple() const
    {
        return std::tie(bc);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /**
     * Obtains the SlicedData object created when an unknown value type was marshaled
     * in the sliced format and the Ice run time sliced it to a known type.
     * @return The SlicedData object, or nil if the value was not sliced or was not
     * marshaled in the sliced format.
     */
    virtual ::Ice::SlicedDataPtr ice_getSlicedData() const override;

    /// \cond STREAM
    virtual void _iceWrite(::Ice::OutputStream*) const override;
    virtual void _iceRead(::Ice::InputStream*) override;
    /// \endcond

    ::std::string bc;

protected:

    /// \cond STREAM
    ::Ice::SlicedDataPtr _iceSlicedData;
    /// \endcond
};

/// \cond INTERNAL
static BaseClass _iceS_BaseClass_init;
/// \endcond

class SPreservedClass : public ::Ice::ValueHelper<SPreservedClass, BaseClass>
{
public:

    virtual ~SPreservedClass();

    SPreservedClass() = default;

    SPreservedClass(const SPreservedClass&) = default;
    SPreservedClass(SPreservedClass&&) = default;
    SPreservedClass& operator=(const SPreservedClass&) = default;
    SPreservedClass& operator=(SPreservedClass&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    SPreservedClass(const ::std::string& bc, const ::std::string& spc) :
        Ice::ValueHelper<SPreservedClass, BaseClass>(bc),
        spc(spc)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::std::string&> ice_tuple() const
    {
        return std::tie(bc, spc);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::std::string spc;
};

}

/// \cond STREAM
namespace Ice
{

template<>
struct StreamableTraits< ::Test::Base>
{
    static const StreamHelperCategory helper = StreamHelperCategoryUserException;
};

template<typename S>
struct StreamWriter< ::Test::Base, S>
{
    static void write(S* ostr, const ::Test::Base& v)
    {
        ostr->write(v.b);
    }
};

template<typename S>
struct StreamReader< ::Test::Base, S>
{
    static void read(S* istr, ::Test::Base& v)
    {
        istr->read(v.b);
    }
};

template<>
struct StreamableTraits< ::Test::KnownDerived>
{
    static const StreamHelperCategory helper = StreamHelperCategoryUserException;
};

template<typename S>
struct StreamWriter< ::Test::KnownDerived, S>
{
    static void write(S* ostr, const ::Test::KnownDerived& v)
    {
        ostr->write(v.kd);
    }
};

template<typename S>
struct StreamReader< ::Test::KnownDerived, S>
{
    static void read(S* istr, ::Test::KnownDerived& v)
    {
        istr->read(v.kd);
    }
};

template<>
struct StreamableTraits< ::Test::KnownIntermediate>
{
    static const StreamHelperCategory helper = StreamHelperCategoryUserException;
};

template<typename S>
struct StreamWriter< ::Test::KnownIntermediate, S>
{
    static void write(S* ostr, const ::Test::KnownIntermediate& v)
    {
        ostr->write(v.ki);
    }
};

template<typename S>
struct StreamReader< ::Test::KnownIntermediate, S>
{
    static void read(S* istr, ::Test::KnownIntermediate& v)
    {
        istr->read(v.ki);
    }
};

template<>
struct StreamableTraits< ::Test::KnownMostDerived>
{
    static const StreamHelperCategory helper = StreamHelperCategoryUserException;
};

template<typename S>
struct StreamWriter< ::Test::KnownMostDerived, S>
{
    static void write(S* ostr, const ::Test::KnownMostDerived& v)
    {
        ostr->write(v.kmd);
    }
};

template<typename S>
struct StreamReader< ::Test::KnownMostDerived, S>
{
    static void read(S* istr, ::Test::KnownMostDerived& v)
    {
        istr->read(v.kmd);
    }
};

template<>
struct StreamableTraits< ::Test::KnownPreserved>
{
    static const StreamHelperCategory helper = StreamHelperCategoryUserException;
};

template<typename S>
struct StreamWriter< ::Test::KnownPreserved, S>
{
    static void write(S* ostr, const ::Test::KnownPreserved& v)
    {
        ostr->write(v.kp);
    }
};

template<typename S>
struct StreamReader< ::Test::KnownPreserved, S>
{
    static void read(S* istr, ::Test::KnownPreserved& v)
    {
        istr->read(v.kp);
    }
};

template<>
struct StreamableTraits< ::Test::KnownPreservedDerived>
{
    static const StreamHelperCategory helper = StreamHelperCategoryUserException;
};

template<typename S>
struct StreamWriter< ::Test::KnownPreservedDerived, S>
{
    static void write(S* ostr, const ::Test::KnownPreservedDerived& v)
    {
        ostr->write(v.kpd);
    }
};

template<typename S>
struct StreamReader< ::Test::KnownPreservedDerived, S>
{
    static void read(S* istr, ::Test::KnownPreservedDerived& v)
    {
        istr->read(v.kpd);
    }
};

template<typename S>
struct StreamWriter< ::Test::BaseClass, S>
{
    static void write(S* ostr, const ::Test::BaseClass& v)
    {
        ostr->write(v.bc);
    }
};

template<typename S>
struct StreamReader< ::Test::BaseClass, S>
{
    static void read(S* istr, ::Test::BaseClass& v)
    {
        istr->read(v.bc);
    }
};

template<>
struct StreamableTraits< ::Test::UnknownDerived>
{
    static const StreamHelperCategory helper = StreamHelperCategoryUserException;
};

template<typename S>
struct StreamWriter< ::Test::UnknownDerived, S>
{
    static void write(S* ostr, const ::Test::UnknownDerived& v)
    {
        ostr->write(v.ud);
    }
};

template<typename S>
struct StreamReader< ::Test::UnknownDerived, S>
{
    static void read(S* istr, ::Test::UnknownDerived& v)
    {
        istr->read(v.ud);
    }
};

template<>
struct StreamableTraits< ::Test::UnknownIntermediate>
{
    static const StreamHelperCategory helper = StreamHelperCategoryUserException;
};

template<typename S>
struct StreamWriter< ::Test::UnknownIntermediate, S>
{
    static void write(S* ostr, const ::Test::UnknownIntermediate& v)
    {
        ostr->write(v.ui);
    }
};

template<typename S>
struct StreamReader< ::Test::UnknownIntermediate, S>
{
    static void read(S* istr, ::Test::UnknownIntermediate& v)
    {
        istr->read(v.ui);
    }
};

template<>
struct StreamableTraits< ::Test::UnknownMostDerived1>
{
    static const StreamHelperCategory helper = StreamHelperCategoryUserException;
};

template<typename S>
struct StreamWriter< ::Test::UnknownMostDerived1, S>
{
    static void write(S* ostr, const ::Test::UnknownMostDerived1& v)
    {
        ostr->write(v.umd1);
    }
};

template<typename S>
struct StreamReader< ::Test::UnknownMostDerived1, S>
{
    static void read(S* istr, ::Test::UnknownMostDerived1& v)
    {
        istr->read(v.umd1);
    }
};

template<>
struct StreamableTraits< ::Test::UnknownMostDerived2>
{
    static const StreamHelperCategory helper = StreamHelperCategoryUserException;
};

template<typename S>
struct StreamWriter< ::Test::UnknownMostDerived2, S>
{
    static void write(S* ostr, const ::Test::UnknownMostDerived2& v)
    {
        ostr->write(v.umd2);
    }
};

template<typename S>
struct StreamReader< ::Test::UnknownMostDerived2, S>
{
    static void read(S* istr, ::Test::UnknownMostDerived2& v)
    {
        istr->read(v.umd2);
    }
};

template<typename S>
struct StreamWriter< ::Test::SPreservedClass, S>
{
    static void write(S* ostr, const ::Test::SPreservedClass& v)
    {
        ostr->write(v.spc);
    }
};

template<typename S>
struct StreamReader< ::Test::SPreservedClass, S>
{
    static void read(S* istr, ::Test::SPreservedClass& v)
    {
        istr->read(v.spc);
    }
};

template<>
struct StreamableTraits< ::Test::SPreserved1>
{
    static const StreamHelperCategory helper = StreamHelperCategoryUserException;
};

template<typename S>
struct StreamWriter< ::Test::SPreserved1, S>
{
    static void write(S* ostr, const ::Test::SPreserved1& v)
    {
        ostr->write(v.p1);
    }
};

template<typename S>
struct StreamReader< ::Test::SPreserved1, S>
{
    static void read(S* istr, ::Test::SPreserved1& v)
    {
        istr->read(v.p1);
    }
};

template<>
struct StreamableTraits< ::Test::SPreserved2>
{
    static const StreamHelperCategory helper = StreamHelperCategoryUserException;
};

template<typename S>
struct StreamWriter< ::Test::SPreserved2, S>
{
    static void write(S* ostr, const ::Test::SPreserved2& v)
    {
        ostr->write(v.p2);
    }
};

template<typename S>
struct StreamReader< ::Test::SPreserved2, S>
{
    static void read(S* istr, ::Test::SPreserved2& v)
    {
        istr->read(v.p2);
    }
};

}
/// \endcond

namespace Test
{

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Relay::begin_knownPreservedAsBase.
 * Create a wrapper instance by calling ::Test::newCallback_Relay_knownPreservedAsBase.
 */
template<class T>
class CallbackNC_Relay_knownPreservedAsBase : public Callback_Relay_knownPreservedAsBase_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Relay_knownPreservedAsBase(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        RelayPrx proxy = RelayPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_knownPreservedAsBase(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Relay::begin_knownPreservedAsBase.
 */
template<class T> Callback_Relay_knownPreservedAsBasePtr
newCallback_Relay_knownPreservedAsBase(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Relay_knownPreservedAsBase<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Relay::begin_knownPreservedAsBase.
 */
template<class T> Callback_Relay_knownPreservedAsBasePtr
newCallback_Relay_knownPreservedAsBase(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Relay_knownPreservedAsBase<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Relay::begin_knownPreservedAsBase.
 */
template<class T> Callback_Relay_knownPreservedAsBasePtr
newCallback_Relay_knownPreservedAsBase(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Relay_knownPreservedAsBase<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Relay::begin_knownPreservedAsBase.
 */
template<class T> Callback_Relay_knownPreservedAsBasePtr
newCallback_Relay_knownPreservedAsBase(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Relay_knownPreservedAsBase<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Relay::begin_knownPreservedAsBase.
 * Create a wrapper instance by calling ::Test::newCallback_Relay_knownPreservedAsBase.
 */
template<class T, typename CT>
class Callback_Relay_knownPreservedAsBase : public Callback_Relay_knownPreservedAsBase_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Relay_knownPreservedAsBase(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        RelayPrx proxy = RelayPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_knownPreservedAsBase(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Relay::begin_knownPreservedAsBase.
 */
template<class T, typename CT> Callback_Relay_knownPreservedAsBasePtr
newCallback_Relay_knownPreservedAsBase(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Relay_knownPreservedAsBase<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Relay::begin_knownPreservedAsBase.
 */
template<class T, typename CT> Callback_Relay_knownPreservedAsBasePtr
newCallback_Relay_knownPreservedAsBase(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Relay_knownPreservedAsBase<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Relay::begin_knownPreservedAsBase.
 */
template<class T, typename CT> Callback_Relay_knownPreservedAsBasePtr
newCallback_Relay_knownPreservedAsBase(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Relay_knownPreservedAsBase<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Relay::begin_knownPreservedAsBase.
 */
template<class T, typename CT> Callback_Relay_knownPreservedAsBasePtr
newCallback_Relay_knownPreservedAsBase(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Relay_knownPreservedAsBase<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Relay::begin_knownPreservedAsKnownPreserved.
 * Create a wrapper instance by calling ::Test::newCallback_Relay_knownPreservedAsKnownPreserved.
 */
template<class T>
class CallbackNC_Relay_knownPreservedAsKnownPreserved : public Callback_Relay_knownPreservedAsKnownPreserved_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Relay_knownPreservedAsKnownPreserved(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        RelayPrx proxy = RelayPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_knownPreservedAsKnownPreserved(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Relay::begin_knownPreservedAsKnownPreserved.
 */
template<class T> Callback_Relay_knownPreservedAsKnownPreservedPtr
newCallback_Relay_knownPreservedAsKnownPreserved(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Relay_knownPreservedAsKnownPreserved<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Relay::begin_knownPreservedAsKnownPreserved.
 */
template<class T> Callback_Relay_knownPreservedAsKnownPreservedPtr
newCallback_Relay_knownPreservedAsKnownPreserved(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Relay_knownPreservedAsKnownPreserved<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Relay::begin_knownPreservedAsKnownPreserved.
 */
template<class T> Callback_Relay_knownPreservedAsKnownPreservedPtr
newCallback_Relay_knownPreservedAsKnownPreserved(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Relay_knownPreservedAsKnownPreserved<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Relay::begin_knownPreservedAsKnownPreserved.
 */
template<class T> Callback_Relay_knownPreservedAsKnownPreservedPtr
newCallback_Relay_knownPreservedAsKnownPreserved(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Relay_knownPreservedAsKnownPreserved<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Relay::begin_knownPreservedAsKnownPreserved.
 * Create a wrapper instance by calling ::Test::newCallback_Relay_knownPreservedAsKnownPreserved.
 */
template<class T, typename CT>
class Callback_Relay_knownPreservedAsKnownPreserved : public Callback_Relay_knownPreservedAsKnownPreserved_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Relay_knownPreservedAsKnownPreserved(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        RelayPrx proxy = RelayPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_knownPreservedAsKnownPreserved(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Relay::begin_knownPreservedAsKnownPreserved.
 */
template<class T, typename CT> Callback_Relay_knownPreservedAsKnownPreservedPtr
newCallback_Relay_knownPreservedAsKnownPreserved(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Relay_knownPreservedAsKnownPreserved<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Relay::begin_knownPreservedAsKnownPreserved.
 */
template<class T, typename CT> Callback_Relay_knownPreservedAsKnownPreservedPtr
newCallback_Relay_knownPreservedAsKnownPreserved(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Relay_knownPreservedAsKnownPreserved<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Relay::begin_knownPreservedAsKnownPreserved.
 */
template<class T, typename CT> Callback_Relay_knownPreservedAsKnownPreservedPtr
newCallback_Relay_knownPreservedAsKnownPreserved(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Relay_knownPreservedAsKnownPreserved<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Relay::begin_knownPreservedAsKnownPreserved.
 */
template<class T, typename CT> Callback_Relay_knownPreservedAsKnownPreservedPtr
newCallback_Relay_knownPreservedAsKnownPreserved(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Relay_knownPreservedAsKnownPreserved<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Relay::begin_unknownPreservedAsBase.
 * Create a wrapper instance by calling ::Test::newCallback_Relay_unknownPreservedAsBase.
 */
template<class T>
class CallbackNC_Relay_unknownPreservedAsBase : public Callback_Relay_unknownPreservedAsBase_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Relay_unknownPreservedAsBase(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        RelayPrx proxy = RelayPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_unknownPreservedAsBase(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Relay::begin_unknownPreservedAsBase.
 */
template<class T> Callback_Relay_unknownPreservedAsBasePtr
newCallback_Relay_unknownPreservedAsBase(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Relay_unknownPreservedAsBase<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Relay::begin_unknownPreservedAsBase.
 */
template<class T> Callback_Relay_unknownPreservedAsBasePtr
newCallback_Relay_unknownPreservedAsBase(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Relay_unknownPreservedAsBase<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Relay::begin_unknownPreservedAsBase.
 */
template<class T> Callback_Relay_unknownPreservedAsBasePtr
newCallback_Relay_unknownPreservedAsBase(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Relay_unknownPreservedAsBase<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Relay::begin_unknownPreservedAsBase.
 */
template<class T> Callback_Relay_unknownPreservedAsBasePtr
newCallback_Relay_unknownPreservedAsBase(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Relay_unknownPreservedAsBase<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Relay::begin_unknownPreservedAsBase.
 * Create a wrapper instance by calling ::Test::newCallback_Relay_unknownPreservedAsBase.
 */
template<class T, typename CT>
class Callback_Relay_unknownPreservedAsBase : public Callback_Relay_unknownPreservedAsBase_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Relay_unknownPreservedAsBase(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        RelayPrx proxy = RelayPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_unknownPreservedAsBase(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Relay::begin_unknownPreservedAsBase.
 */
template<class T, typename CT> Callback_Relay_unknownPreservedAsBasePtr
newCallback_Relay_unknownPreservedAsBase(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Relay_unknownPreservedAsBase<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Relay::begin_unknownPreservedAsBase.
 */
template<class T, typename CT> Callback_Relay_unknownPreservedAsBasePtr
newCallback_Relay_unknownPreservedAsBase(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Relay_unknownPreservedAsBase<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Relay::begin_unknownPreservedAsBase.
 */
template<class T, typename CT> Callback_Relay_unknownPreservedAsBasePtr
newCallback_Relay_unknownPreservedAsBase(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Relay_unknownPreservedAsBase<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Relay::begin_unknownPreservedAsBase.
 */
template<class T, typename CT> Callback_Relay_unknownPreservedAsBasePtr
newCallback_Relay_unknownPreservedAsBase(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Relay_unknownPreservedAsBase<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Relay::begin_unknownPreservedAsKnownPreserved.
 * Create a wrapper instance by calling ::Test::newCallback_Relay_unknownPreservedAsKnownPreserved.
 */
template<class T>
class CallbackNC_Relay_unknownPreservedAsKnownPreserved : public Callback_Relay_unknownPreservedAsKnownPreserved_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Relay_unknownPreservedAsKnownPreserved(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        RelayPrx proxy = RelayPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_unknownPreservedAsKnownPreserved(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Relay::begin_unknownPreservedAsKnownPreserved.
 */
template<class T> Callback_Relay_unknownPreservedAsKnownPreservedPtr
newCallback_Relay_unknownPreservedAsKnownPreserved(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Relay_unknownPreservedAsKnownPreserved<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Relay::begin_unknownPreservedAsKnownPreserved.
 */
template<class T> Callback_Relay_unknownPreservedAsKnownPreservedPtr
newCallback_Relay_unknownPreservedAsKnownPreserved(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Relay_unknownPreservedAsKnownPreserved<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Relay::begin_unknownPreservedAsKnownPreserved.
 */
template<class T> Callback_Relay_unknownPreservedAsKnownPreservedPtr
newCallback_Relay_unknownPreservedAsKnownPreserved(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Relay_unknownPreservedAsKnownPreserved<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Relay::begin_unknownPreservedAsKnownPreserved.
 */
template<class T> Callback_Relay_unknownPreservedAsKnownPreservedPtr
newCallback_Relay_unknownPreservedAsKnownPreserved(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Relay_unknownPreservedAsKnownPreserved<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Relay::begin_unknownPreservedAsKnownPreserved.
 * Create a wrapper instance by calling ::Test::newCallback_Relay_unknownPreservedAsKnownPreserved.
 */
template<class T, typename CT>
class Callback_Relay_unknownPreservedAsKnownPreserved : public Callback_Relay_unknownPreservedAsKnownPreserved_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Relay_unknownPreservedAsKnownPreserved(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        RelayPrx proxy = RelayPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_unknownPreservedAsKnownPreserved(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Relay::begin_unknownPreservedAsKnownPreserved.
 */
template<class T, typename CT> Callback_Relay_unknownPreservedAsKnownPreservedPtr
newCallback_Relay_unknownPreservedAsKnownPreserved(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Relay_unknownPreservedAsKnownPreserved<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Relay::begin_unknownPreservedAsKnownPreserved.
 */
template<class T, typename CT> Callback_Relay_unknownPreservedAsKnownPreservedPtr
newCallback_Relay_unknownPreservedAsKnownPreserved(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Relay_unknownPreservedAsKnownPreserved<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Relay::begin_unknownPreservedAsKnownPreserved.
 */
template<class T, typename CT> Callback_Relay_unknownPreservedAsKnownPreservedPtr
newCallback_Relay_unknownPreservedAsKnownPreserved(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Relay_unknownPreservedAsKnownPreserved<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Relay::begin_unknownPreservedAsKnownPreserved.
 */
template<class T, typename CT> Callback_Relay_unknownPreservedAsKnownPreservedPtr
newCallback_Relay_unknownPreservedAsKnownPreserved(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Relay_unknownPreservedAsKnownPreserved<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_baseAsBase.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_baseAsBase.
 */
template<class T>
class CallbackNC_TestIntf_baseAsBase : public Callback_TestIntf_baseAsBase_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_TestIntf_baseAsBase(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_baseAsBase(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_baseAsBase.
 */
template<class T> Callback_TestIntf_baseAsBasePtr
newCallback_TestIntf_baseAsBase(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_baseAsBase<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_baseAsBase.
 */
template<class T> Callback_TestIntf_baseAsBasePtr
newCallback_TestIntf_baseAsBase(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_baseAsBase<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_baseAsBase.
 */
template<class T> Callback_TestIntf_baseAsBasePtr
newCallback_TestIntf_baseAsBase(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_baseAsBase<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_baseAsBase.
 */
template<class T> Callback_TestIntf_baseAsBasePtr
newCallback_TestIntf_baseAsBase(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_baseAsBase<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_baseAsBase.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_baseAsBase.
 */
template<class T, typename CT>
class Callback_TestIntf_baseAsBase : public Callback_TestIntf_baseAsBase_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_TestIntf_baseAsBase(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_baseAsBase(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_baseAsBase.
 */
template<class T, typename CT> Callback_TestIntf_baseAsBasePtr
newCallback_TestIntf_baseAsBase(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_baseAsBase<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_baseAsBase.
 */
template<class T, typename CT> Callback_TestIntf_baseAsBasePtr
newCallback_TestIntf_baseAsBase(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_baseAsBase<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_baseAsBase.
 */
template<class T, typename CT> Callback_TestIntf_baseAsBasePtr
newCallback_TestIntf_baseAsBase(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_baseAsBase<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_baseAsBase.
 */
template<class T, typename CT> Callback_TestIntf_baseAsBasePtr
newCallback_TestIntf_baseAsBase(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_baseAsBase<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_unknownDerivedAsBase.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_unknownDerivedAsBase.
 */
template<class T>
class CallbackNC_TestIntf_unknownDerivedAsBase : public Callback_TestIntf_unknownDerivedAsBase_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_TestIntf_unknownDerivedAsBase(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_unknownDerivedAsBase(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_unknownDerivedAsBase.
 */
template<class T> Callback_TestIntf_unknownDerivedAsBasePtr
newCallback_TestIntf_unknownDerivedAsBase(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_unknownDerivedAsBase<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_unknownDerivedAsBase.
 */
template<class T> Callback_TestIntf_unknownDerivedAsBasePtr
newCallback_TestIntf_unknownDerivedAsBase(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_unknownDerivedAsBase<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_unknownDerivedAsBase.
 */
template<class T> Callback_TestIntf_unknownDerivedAsBasePtr
newCallback_TestIntf_unknownDerivedAsBase(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_unknownDerivedAsBase<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_unknownDerivedAsBase.
 */
template<class T> Callback_TestIntf_unknownDerivedAsBasePtr
newCallback_TestIntf_unknownDerivedAsBase(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_unknownDerivedAsBase<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_unknownDerivedAsBase.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_unknownDerivedAsBase.
 */
template<class T, typename CT>
class Callback_TestIntf_unknownDerivedAsBase : public Callback_TestIntf_unknownDerivedAsBase_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_TestIntf_unknownDerivedAsBase(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_unknownDerivedAsBase(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_unknownDerivedAsBase.
 */
template<class T, typename CT> Callback_TestIntf_unknownDerivedAsBasePtr
newCallback_TestIntf_unknownDerivedAsBase(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_unknownDerivedAsBase<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_unknownDerivedAsBase.
 */
template<class T, typename CT> Callback_TestIntf_unknownDerivedAsBasePtr
newCallback_TestIntf_unknownDerivedAsBase(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_unknownDerivedAsBase<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_unknownDerivedAsBase.
 */
template<class T, typename CT> Callback_TestIntf_unknownDerivedAsBasePtr
newCallback_TestIntf_unknownDerivedAsBase(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_unknownDerivedAsBase<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_unknownDerivedAsBase.
 */
template<class T, typename CT> Callback_TestIntf_unknownDerivedAsBasePtr
newCallback_TestIntf_unknownDerivedAsBase(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_unknownDerivedAsBase<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_knownDerivedAsBase.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_knownDerivedAsBase.
 */
template<class T>
class CallbackNC_TestIntf_knownDerivedAsBase : public Callback_TestIntf_knownDerivedAsBase_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_TestIntf_knownDerivedAsBase(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_knownDerivedAsBase(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_knownDerivedAsBase.
 */
template<class T> Callback_TestIntf_knownDerivedAsBasePtr
newCallback_TestIntf_knownDerivedAsBase(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_knownDerivedAsBase<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_knownDerivedAsBase.
 */
template<class T> Callback_TestIntf_knownDerivedAsBasePtr
newCallback_TestIntf_knownDerivedAsBase(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_knownDerivedAsBase<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_knownDerivedAsBase.
 */
template<class T> Callback_TestIntf_knownDerivedAsBasePtr
newCallback_TestIntf_knownDerivedAsBase(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_knownDerivedAsBase<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_knownDerivedAsBase.
 */
template<class T> Callback_TestIntf_knownDerivedAsBasePtr
newCallback_TestIntf_knownDerivedAsBase(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_knownDerivedAsBase<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_knownDerivedAsBase.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_knownDerivedAsBase.
 */
template<class T, typename CT>
class Callback_TestIntf_knownDerivedAsBase : public Callback_TestIntf_knownDerivedAsBase_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_TestIntf_knownDerivedAsBase(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_knownDerivedAsBase(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_knownDerivedAsBase.
 */
template<class T, typename CT> Callback_TestIntf_knownDerivedAsBasePtr
newCallback_TestIntf_knownDerivedAsBase(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_knownDerivedAsBase<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_knownDerivedAsBase.
 */
template<class T, typename CT> Callback_TestIntf_knownDerivedAsBasePtr
newCallback_TestIntf_knownDerivedAsBase(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_knownDerivedAsBase<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_knownDerivedAsBase.
 */
template<class T, typename CT> Callback_TestIntf_knownDerivedAsBasePtr
newCallback_TestIntf_knownDerivedAsBase(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_knownDerivedAsBase<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_knownDerivedAsBase.
 */
template<class T, typename CT> Callback_TestIntf_knownDerivedAsBasePtr
newCallback_TestIntf_knownDerivedAsBase(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_knownDerivedAsBase<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_knownDerivedAsKnownDerived.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_knownDerivedAsKnownDerived.
 */
template<class T>
class CallbackNC_TestIntf_knownDerivedAsKnownDerived : public Callback_TestIntf_knownDerivedAsKnownDerived_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_TestIntf_knownDerivedAsKnownDerived(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_knownDerivedAsKnownDerived(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_knownDerivedAsKnownDerived.
 */
template<class T> Callback_TestIntf_knownDerivedAsKnownDerivedPtr
newCallback_TestIntf_knownDerivedAsKnownDerived(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_knownDerivedAsKnownDerived<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_knownDerivedAsKnownDerived.
 */
template<class T> Callback_TestIntf_knownDerivedAsKnownDerivedPtr
newCallback_TestIntf_knownDerivedAsKnownDerived(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_knownDerivedAsKnownDerived<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_knownDerivedAsKnownDerived.
 */
template<class T> Callback_TestIntf_knownDerivedAsKnownDerivedPtr
newCallback_TestIntf_knownDerivedAsKnownDerived(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_knownDerivedAsKnownDerived<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_knownDerivedAsKnownDerived.
 */
template<class T> Callback_TestIntf_knownDerivedAsKnownDerivedPtr
newCallback_TestIntf_knownDerivedAsKnownDerived(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_knownDerivedAsKnownDerived<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_knownDerivedAsKnownDerived.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_knownDerivedAsKnownDerived.
 */
template<class T, typename CT>
class Callback_TestIntf_knownDerivedAsKnownDerived : public Callback_TestIntf_knownDerivedAsKnownDerived_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_TestIntf_knownDerivedAsKnownDerived(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_knownDerivedAsKnownDerived(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_knownDerivedAsKnownDerived.
 */
template<class T, typename CT> Callback_TestIntf_knownDerivedAsKnownDerivedPtr
newCallback_TestIntf_knownDerivedAsKnownDerived(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_knownDerivedAsKnownDerived<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_knownDerivedAsKnownDerived.
 */
template<class T, typename CT> Callback_TestIntf_knownDerivedAsKnownDerivedPtr
newCallback_TestIntf_knownDerivedAsKnownDerived(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_knownDerivedAsKnownDerived<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_knownDerivedAsKnownDerived.
 */
template<class T, typename CT> Callback_TestIntf_knownDerivedAsKnownDerivedPtr
newCallback_TestIntf_knownDerivedAsKnownDerived(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_knownDerivedAsKnownDerived<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_knownDerivedAsKnownDerived.
 */
template<class T, typename CT> Callback_TestIntf_knownDerivedAsKnownDerivedPtr
newCallback_TestIntf_knownDerivedAsKnownDerived(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_knownDerivedAsKnownDerived<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_unknownIntermediateAsBase.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_unknownIntermediateAsBase.
 */
template<class T>
class CallbackNC_TestIntf_unknownIntermediateAsBase : public Callback_TestIntf_unknownIntermediateAsBase_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_TestIntf_unknownIntermediateAsBase(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_unknownIntermediateAsBase(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_unknownIntermediateAsBase.
 */
template<class T> Callback_TestIntf_unknownIntermediateAsBasePtr
newCallback_TestIntf_unknownIntermediateAsBase(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_unknownIntermediateAsBase<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_unknownIntermediateAsBase.
 */
template<class T> Callback_TestIntf_unknownIntermediateAsBasePtr
newCallback_TestIntf_unknownIntermediateAsBase(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_unknownIntermediateAsBase<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_unknownIntermediateAsBase.
 */
template<class T> Callback_TestIntf_unknownIntermediateAsBasePtr
newCallback_TestIntf_unknownIntermediateAsBase(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_unknownIntermediateAsBase<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_unknownIntermediateAsBase.
 */
template<class T> Callback_TestIntf_unknownIntermediateAsBasePtr
newCallback_TestIntf_unknownIntermediateAsBase(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_unknownIntermediateAsBase<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_unknownIntermediateAsBase.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_unknownIntermediateAsBase.
 */
template<class T, typename CT>
class Callback_TestIntf_unknownIntermediateAsBase : public Callback_TestIntf_unknownIntermediateAsBase_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_TestIntf_unknownIntermediateAsBase(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_unknownIntermediateAsBase(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_unknownIntermediateAsBase.
 */
template<class T, typename CT> Callback_TestIntf_unknownIntermediateAsBasePtr
newCallback_TestIntf_unknownIntermediateAsBase(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_unknownIntermediateAsBase<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_unknownIntermediateAsBase.
 */
template<class T, typename CT> Callback_TestIntf_unknownIntermediateAsBasePtr
newCallback_TestIntf_unknownIntermediateAsBase(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_unknownIntermediateAsBase<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_unknownIntermediateAsBase.
 */
template<class T, typename CT> Callback_TestIntf_unknownIntermediateAsBasePtr
newCallback_TestIntf_unknownIntermediateAsBase(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_unknownIntermediateAsBase<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_unknownIntermediateAsBase.
 */
template<class T, typename CT> Callback_TestIntf_unknownIntermediateAsBasePtr
newCallback_TestIntf_unknownIntermediateAsBase(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_unknownIntermediateAsBase<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_knownIntermediateAsBase.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_knownIntermediateAsBase.
 */
template<class T>
class CallbackNC_TestIntf_knownIntermediateAsBase : public Callback_TestIntf_knownIntermediateAsBase_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_TestIntf_knownIntermediateAsBase(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_knownIntermediateAsBase(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_knownIntermediateAsBase.
 */
template<class T> Callback_TestIntf_knownIntermediateAsBasePtr
newCallback_TestIntf_knownIntermediateAsBase(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_knownIntermediateAsBase<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_knownIntermediateAsBase.
 */
template<class T> Callback_TestIntf_knownIntermediateAsBasePtr
newCallback_TestIntf_knownIntermediateAsBase(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_knownIntermediateAsBase<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_knownIntermediateAsBase.
 */
template<class T> Callback_TestIntf_knownIntermediateAsBasePtr
newCallback_TestIntf_knownIntermediateAsBase(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_knownIntermediateAsBase<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_knownIntermediateAsBase.
 */
template<class T> Callback_TestIntf_knownIntermediateAsBasePtr
newCallback_TestIntf_knownIntermediateAsBase(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_knownIntermediateAsBase<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_knownIntermediateAsBase.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_knownIntermediateAsBase.
 */
template<class T, typename CT>
class Callback_TestIntf_knownIntermediateAsBase : public Callback_TestIntf_knownIntermediateAsBase_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_TestIntf_knownIntermediateAsBase(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_knownIntermediateAsBase(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_knownIntermediateAsBase.
 */
template<class T, typename CT> Callback_TestIntf_knownIntermediateAsBasePtr
newCallback_TestIntf_knownIntermediateAsBase(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_knownIntermediateAsBase<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_knownIntermediateAsBase.
 */
template<class T, typename CT> Callback_TestIntf_knownIntermediateAsBasePtr
newCallback_TestIntf_knownIntermediateAsBase(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_knownIntermediateAsBase<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_knownIntermediateAsBase.
 */
template<class T, typename CT> Callback_TestIntf_knownIntermediateAsBasePtr
newCallback_TestIntf_knownIntermediateAsBase(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_knownIntermediateAsBase<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_knownIntermediateAsBase.
 */
template<class T, typename CT> Callback_TestIntf_knownIntermediateAsBasePtr
newCallback_TestIntf_knownIntermediateAsBase(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_knownIntermediateAsBase<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_knownMostDerivedAsBase.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_knownMostDerivedAsBase.
 */
template<class T>
class CallbackNC_TestIntf_knownMostDerivedAsBase : public Callback_TestIntf_knownMostDerivedAsBase_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_TestIntf_knownMostDerivedAsBase(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_knownMostDerivedAsBase(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_knownMostDerivedAsBase.
 */
template<class T> Callback_TestIntf_knownMostDerivedAsBasePtr
newCallback_TestIntf_knownMostDerivedAsBase(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_knownMostDerivedAsBase<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_knownMostDerivedAsBase.
 */
template<class T> Callback_TestIntf_knownMostDerivedAsBasePtr
newCallback_TestIntf_knownMostDerivedAsBase(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_knownMostDerivedAsBase<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_knownMostDerivedAsBase.
 */
template<class T> Callback_TestIntf_knownMostDerivedAsBasePtr
newCallback_TestIntf_knownMostDerivedAsBase(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_knownMostDerivedAsBase<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_knownMostDerivedAsBase.
 */
template<class T> Callback_TestIntf_knownMostDerivedAsBasePtr
newCallback_TestIntf_knownMostDerivedAsBase(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_knownMostDerivedAsBase<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_knownMostDerivedAsBase.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_knownMostDerivedAsBase.
 */
template<class T, typename CT>
class Callback_TestIntf_knownMostDerivedAsBase : public Callback_TestIntf_knownMostDerivedAsBase_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_TestIntf_knownMostDerivedAsBase(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_knownMostDerivedAsBase(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_knownMostDerivedAsBase.
 */
template<class T, typename CT> Callback_TestIntf_knownMostDerivedAsBasePtr
newCallback_TestIntf_knownMostDerivedAsBase(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_knownMostDerivedAsBase<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_knownMostDerivedAsBase.
 */
template<class T, typename CT> Callback_TestIntf_knownMostDerivedAsBasePtr
newCallback_TestIntf_knownMostDerivedAsBase(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_knownMostDerivedAsBase<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_knownMostDerivedAsBase.
 */
template<class T, typename CT> Callback_TestIntf_knownMostDerivedAsBasePtr
newCallback_TestIntf_knownMostDerivedAsBase(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_knownMostDerivedAsBase<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_knownMostDerivedAsBase.
 */
template<class T, typename CT> Callback_TestIntf_knownMostDerivedAsBasePtr
newCallback_TestIntf_knownMostDerivedAsBase(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_knownMostDerivedAsBase<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_knownIntermediateAsKnownIntermediate.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_knownIntermediateAsKnownIntermediate.
 */
template<class T>
class CallbackNC_TestIntf_knownIntermediateAsKnownIntermediate : public Callback_TestIntf_knownIntermediateAsKnownIntermediate_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_TestIntf_knownIntermediateAsKnownIntermediate(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_knownIntermediateAsKnownIntermediate(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_knownIntermediateAsKnownIntermediate.
 */
template<class T> Callback_TestIntf_knownIntermediateAsKnownIntermediatePtr
newCallback_TestIntf_knownIntermediateAsKnownIntermediate(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_knownIntermediateAsKnownIntermediate<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_knownIntermediateAsKnownIntermediate.
 */
template<class T> Callback_TestIntf_knownIntermediateAsKnownIntermediatePtr
newCallback_TestIntf_knownIntermediateAsKnownIntermediate(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_knownIntermediateAsKnownIntermediate<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_knownIntermediateAsKnownIntermediate.
 */
template<class T> Callback_TestIntf_knownIntermediateAsKnownIntermediatePtr
newCallback_TestIntf_knownIntermediateAsKnownIntermediate(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_knownIntermediateAsKnownIntermediate<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_knownIntermediateAsKnownIntermediate.
 */
template<class T> Callback_TestIntf_knownIntermediateAsKnownIntermediatePtr
newCallback_TestIntf_knownIntermediateAsKnownIntermediate(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_knownIntermediateAsKnownIntermediate<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_knownIntermediateAsKnownIntermediate.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_knownIntermediateAsKnownIntermediate.
 */
template<class T, typename CT>
class Callback_TestIntf_knownIntermediateAsKnownIntermediate : public Callback_TestIntf_knownIntermediateAsKnownIntermediate_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_TestIntf_knownIntermediateAsKnownIntermediate(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_knownIntermediateAsKnownIntermediate(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_knownIntermediateAsKnownIntermediate.
 */
template<class T, typename CT> Callback_TestIntf_knownIntermediateAsKnownIntermediatePtr
newCallback_TestIntf_knownIntermediateAsKnownIntermediate(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_knownIntermediateAsKnownIntermediate<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_knownIntermediateAsKnownIntermediate.
 */
template<class T, typename CT> Callback_TestIntf_knownIntermediateAsKnownIntermediatePtr
newCallback_TestIntf_knownIntermediateAsKnownIntermediate(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_knownIntermediateAsKnownIntermediate<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_knownIntermediateAsKnownIntermediate.
 */
template<class T, typename CT> Callback_TestIntf_knownIntermediateAsKnownIntermediatePtr
newCallback_TestIntf_knownIntermediateAsKnownIntermediate(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_knownIntermediateAsKnownIntermediate<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_knownIntermediateAsKnownIntermediate.
 */
template<class T, typename CT> Callback_TestIntf_knownIntermediateAsKnownIntermediatePtr
newCallback_TestIntf_knownIntermediateAsKnownIntermediate(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_knownIntermediateAsKnownIntermediate<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_knownMostDerivedAsKnownIntermediate.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_knownMostDerivedAsKnownIntermediate.
 */
template<class T>
class CallbackNC_TestIntf_knownMostDerivedAsKnownIntermediate : public Callback_TestIntf_knownMostDerivedAsKnownIntermediate_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_TestIntf_knownMostDerivedAsKnownIntermediate(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_knownMostDerivedAsKnownIntermediate(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_knownMostDerivedAsKnownIntermediate.
 */
template<class T> Callback_TestIntf_knownMostDerivedAsKnownIntermediatePtr
newCallback_TestIntf_knownMostDerivedAsKnownIntermediate(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_knownMostDerivedAsKnownIntermediate<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_knownMostDerivedAsKnownIntermediate.
 */
template<class T> Callback_TestIntf_knownMostDerivedAsKnownIntermediatePtr
newCallback_TestIntf_knownMostDerivedAsKnownIntermediate(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_knownMostDerivedAsKnownIntermediate<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_knownMostDerivedAsKnownIntermediate.
 */
template<class T> Callback_TestIntf_knownMostDerivedAsKnownIntermediatePtr
newCallback_TestIntf_knownMostDerivedAsKnownIntermediate(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_knownMostDerivedAsKnownIntermediate<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_knownMostDerivedAsKnownIntermediate.
 */
template<class T> Callback_TestIntf_knownMostDerivedAsKnownIntermediatePtr
newCallback_TestIntf_knownMostDerivedAsKnownIntermediate(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_knownMostDerivedAsKnownIntermediate<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_knownMostDerivedAsKnownIntermediate.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_knownMostDerivedAsKnownIntermediate.
 */
template<class T, typename CT>
class Callback_TestIntf_knownMostDerivedAsKnownIntermediate : public Callback_TestIntf_knownMostDerivedAsKnownIntermediate_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_TestIntf_knownMostDerivedAsKnownIntermediate(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_knownMostDerivedAsKnownIntermediate(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_knownMostDerivedAsKnownIntermediate.
 */
template<class T, typename CT> Callback_TestIntf_knownMostDerivedAsKnownIntermediatePtr
newCallback_TestIntf_knownMostDerivedAsKnownIntermediate(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_knownMostDerivedAsKnownIntermediate<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_knownMostDerivedAsKnownIntermediate.
 */
template<class T, typename CT> Callback_TestIntf_knownMostDerivedAsKnownIntermediatePtr
newCallback_TestIntf_knownMostDerivedAsKnownIntermediate(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_knownMostDerivedAsKnownIntermediate<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_knownMostDerivedAsKnownIntermediate.
 */
template<class T, typename CT> Callback_TestIntf_knownMostDerivedAsKnownIntermediatePtr
newCallback_TestIntf_knownMostDerivedAsKnownIntermediate(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_knownMostDerivedAsKnownIntermediate<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_knownMostDerivedAsKnownIntermediate.
 */
template<class T, typename CT> Callback_TestIntf_knownMostDerivedAsKnownIntermediatePtr
newCallback_TestIntf_knownMostDerivedAsKnownIntermediate(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_knownMostDerivedAsKnownIntermediate<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_knownMostDerivedAsKnownMostDerived.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_knownMostDerivedAsKnownMostDerived.
 */
template<class T>
class CallbackNC_TestIntf_knownMostDerivedAsKnownMostDerived : public Callback_TestIntf_knownMostDerivedAsKnownMostDerived_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_TestIntf_knownMostDerivedAsKnownMostDerived(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_knownMostDerivedAsKnownMostDerived(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_knownMostDerivedAsKnownMostDerived.
 */
template<class T> Callback_TestIntf_knownMostDerivedAsKnownMostDerivedPtr
newCallback_TestIntf_knownMostDerivedAsKnownMostDerived(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_knownMostDerivedAsKnownMostDerived<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_knownMostDerivedAsKnownMostDerived.
 */
template<class T> Callback_TestIntf_knownMostDerivedAsKnownMostDerivedPtr
newCallback_TestIntf_knownMostDerivedAsKnownMostDerived(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_knownMostDerivedAsKnownMostDerived<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_knownMostDerivedAsKnownMostDerived.
 */
template<class T> Callback_TestIntf_knownMostDerivedAsKnownMostDerivedPtr
newCallback_TestIntf_knownMostDerivedAsKnownMostDerived(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_knownMostDerivedAsKnownMostDerived<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_knownMostDerivedAsKnownMostDerived.
 */
template<class T> Callback_TestIntf_knownMostDerivedAsKnownMostDerivedPtr
newCallback_TestIntf_knownMostDerivedAsKnownMostDerived(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_knownMostDerivedAsKnownMostDerived<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_knownMostDerivedAsKnownMostDerived.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_knownMostDerivedAsKnownMostDerived.
 */
template<class T, typename CT>
class Callback_TestIntf_knownMostDerivedAsKnownMostDerived : public Callback_TestIntf_knownMostDerivedAsKnownMostDerived_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_TestIntf_knownMostDerivedAsKnownMostDerived(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_knownMostDerivedAsKnownMostDerived(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_knownMostDerivedAsKnownMostDerived.
 */
template<class T, typename CT> Callback_TestIntf_knownMostDerivedAsKnownMostDerivedPtr
newCallback_TestIntf_knownMostDerivedAsKnownMostDerived(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_knownMostDerivedAsKnownMostDerived<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_knownMostDerivedAsKnownMostDerived.
 */
template<class T, typename CT> Callback_TestIntf_knownMostDerivedAsKnownMostDerivedPtr
newCallback_TestIntf_knownMostDerivedAsKnownMostDerived(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_knownMostDerivedAsKnownMostDerived<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_knownMostDerivedAsKnownMostDerived.
 */
template<class T, typename CT> Callback_TestIntf_knownMostDerivedAsKnownMostDerivedPtr
newCallback_TestIntf_knownMostDerivedAsKnownMostDerived(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_knownMostDerivedAsKnownMostDerived<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_knownMostDerivedAsKnownMostDerived.
 */
template<class T, typename CT> Callback_TestIntf_knownMostDerivedAsKnownMostDerivedPtr
newCallback_TestIntf_knownMostDerivedAsKnownMostDerived(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_knownMostDerivedAsKnownMostDerived<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_unknownMostDerived1AsBase.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_unknownMostDerived1AsBase.
 */
template<class T>
class CallbackNC_TestIntf_unknownMostDerived1AsBase : public Callback_TestIntf_unknownMostDerived1AsBase_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_TestIntf_unknownMostDerived1AsBase(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_unknownMostDerived1AsBase(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_unknownMostDerived1AsBase.
 */
template<class T> Callback_TestIntf_unknownMostDerived1AsBasePtr
newCallback_TestIntf_unknownMostDerived1AsBase(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_unknownMostDerived1AsBase<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_unknownMostDerived1AsBase.
 */
template<class T> Callback_TestIntf_unknownMostDerived1AsBasePtr
newCallback_TestIntf_unknownMostDerived1AsBase(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_unknownMostDerived1AsBase<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_unknownMostDerived1AsBase.
 */
template<class T> Callback_TestIntf_unknownMostDerived1AsBasePtr
newCallback_TestIntf_unknownMostDerived1AsBase(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_unknownMostDerived1AsBase<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_unknownMostDerived1AsBase.
 */
template<class T> Callback_TestIntf_unknownMostDerived1AsBasePtr
newCallback_TestIntf_unknownMostDerived1AsBase(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_unknownMostDerived1AsBase<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_unknownMostDerived1AsBase.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_unknownMostDerived1AsBase.
 */
template<class T, typename CT>
class Callback_TestIntf_unknownMostDerived1AsBase : public Callback_TestIntf_unknownMostDerived1AsBase_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_TestIntf_unknownMostDerived1AsBase(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_unknownMostDerived1AsBase(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_unknownMostDerived1AsBase.
 */
template<class T, typename CT> Callback_TestIntf_unknownMostDerived1AsBasePtr
newCallback_TestIntf_unknownMostDerived1AsBase(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_unknownMostDerived1AsBase<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_unknownMostDerived1AsBase.
 */
template<class T, typename CT> Callback_TestIntf_unknownMostDerived1AsBasePtr
newCallback_TestIntf_unknownMostDerived1AsBase(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_unknownMostDerived1AsBase<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_unknownMostDerived1AsBase.
 */
template<class T, typename CT> Callback_TestIntf_unknownMostDerived1AsBasePtr
newCallback_TestIntf_unknownMostDerived1AsBase(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_unknownMostDerived1AsBase<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_unknownMostDerived1AsBase.
 */
template<class T, typename CT> Callback_TestIntf_unknownMostDerived1AsBasePtr
newCallback_TestIntf_unknownMostDerived1AsBase(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_unknownMostDerived1AsBase<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_unknownMostDerived1AsKnownIntermediate.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_unknownMostDerived1AsKnownIntermediate.
 */
template<class T>
class CallbackNC_TestIntf_unknownMostDerived1AsKnownIntermediate : public Callback_TestIntf_unknownMostDerived1AsKnownIntermediate_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_TestIntf_unknownMostDerived1AsKnownIntermediate(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_unknownMostDerived1AsKnownIntermediate(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_unknownMostDerived1AsKnownIntermediate.
 */
template<class T> Callback_TestIntf_unknownMostDerived1AsKnownIntermediatePtr
newCallback_TestIntf_unknownMostDerived1AsKnownIntermediate(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_unknownMostDerived1AsKnownIntermediate<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_unknownMostDerived1AsKnownIntermediate.
 */
template<class T> Callback_TestIntf_unknownMostDerived1AsKnownIntermediatePtr
newCallback_TestIntf_unknownMostDerived1AsKnownIntermediate(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_unknownMostDerived1AsKnownIntermediate<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_unknownMostDerived1AsKnownIntermediate.
 */
template<class T> Callback_TestIntf_unknownMostDerived1AsKnownIntermediatePtr
newCallback_TestIntf_unknownMostDerived1AsKnownIntermediate(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_unknownMostDerived1AsKnownIntermediate<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_unknownMostDerived1AsKnownIntermediate.
 */
template<class T> Callback_TestIntf_unknownMostDerived1AsKnownIntermediatePtr
newCallback_TestIntf_unknownMostDerived1AsKnownIntermediate(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_unknownMostDerived1AsKnownIntermediate<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_unknownMostDerived1AsKnownIntermediate.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_unknownMostDerived1AsKnownIntermediate.
 */
template<class T, typename CT>
class Callback_TestIntf_unknownMostDerived1AsKnownIntermediate : public Callback_TestIntf_unknownMostDerived1AsKnownIntermediate_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_TestIntf_unknownMostDerived1AsKnownIntermediate(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_unknownMostDerived1AsKnownIntermediate(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_unknownMostDerived1AsKnownIntermediate.
 */
template<class T, typename CT> Callback_TestIntf_unknownMostDerived1AsKnownIntermediatePtr
newCallback_TestIntf_unknownMostDerived1AsKnownIntermediate(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_unknownMostDerived1AsKnownIntermediate<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_unknownMostDerived1AsKnownIntermediate.
 */
template<class T, typename CT> Callback_TestIntf_unknownMostDerived1AsKnownIntermediatePtr
newCallback_TestIntf_unknownMostDerived1AsKnownIntermediate(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_unknownMostDerived1AsKnownIntermediate<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_unknownMostDerived1AsKnownIntermediate.
 */
template<class T, typename CT> Callback_TestIntf_unknownMostDerived1AsKnownIntermediatePtr
newCallback_TestIntf_unknownMostDerived1AsKnownIntermediate(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_unknownMostDerived1AsKnownIntermediate<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_unknownMostDerived1AsKnownIntermediate.
 */
template<class T, typename CT> Callback_TestIntf_unknownMostDerived1AsKnownIntermediatePtr
newCallback_TestIntf_unknownMostDerived1AsKnownIntermediate(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_unknownMostDerived1AsKnownIntermediate<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_unknownMostDerived2AsBase.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_unknownMostDerived2AsBase.
 */
template<class T>
class CallbackNC_TestIntf_unknownMostDerived2AsBase : public Callback_TestIntf_unknownMostDerived2AsBase_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_TestIntf_unknownMostDerived2AsBase(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_unknownMostDerived2AsBase(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_unknownMostDerived2AsBase.
 */
template<class T> Callback_TestIntf_unknownMostDerived2AsBasePtr
newCallback_TestIntf_unknownMostDerived2AsBase(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_unknownMostDerived2AsBase<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_unknownMostDerived2AsBase.
 */
template<class T> Callback_TestIntf_unknownMostDerived2AsBasePtr
newCallback_TestIntf_unknownMostDerived2AsBase(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_unknownMostDerived2AsBase<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_unknownMostDerived2AsBase.
 */
template<class T> Callback_TestIntf_unknownMostDerived2AsBasePtr
newCallback_TestIntf_unknownMostDerived2AsBase(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_unknownMostDerived2AsBase<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_unknownMostDerived2AsBase.
 */
template<class T> Callback_TestIntf_unknownMostDerived2AsBasePtr
newCallback_TestIntf_unknownMostDerived2AsBase(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_unknownMostDerived2AsBase<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_unknownMostDerived2AsBase.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_unknownMostDerived2AsBase.
 */
template<class T, typename CT>
class Callback_TestIntf_unknownMostDerived2AsBase : public Callback_TestIntf_unknownMostDerived2AsBase_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_TestIntf_unknownMostDerived2AsBase(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_unknownMostDerived2AsBase(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_unknownMostDerived2AsBase.
 */
template<class T, typename CT> Callback_TestIntf_unknownMostDerived2AsBasePtr
newCallback_TestIntf_unknownMostDerived2AsBase(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_unknownMostDerived2AsBase<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_unknownMostDerived2AsBase.
 */
template<class T, typename CT> Callback_TestIntf_unknownMostDerived2AsBasePtr
newCallback_TestIntf_unknownMostDerived2AsBase(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_unknownMostDerived2AsBase<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_unknownMostDerived2AsBase.
 */
template<class T, typename CT> Callback_TestIntf_unknownMostDerived2AsBasePtr
newCallback_TestIntf_unknownMostDerived2AsBase(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_unknownMostDerived2AsBase<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_unknownMostDerived2AsBase.
 */
template<class T, typename CT> Callback_TestIntf_unknownMostDerived2AsBasePtr
newCallback_TestIntf_unknownMostDerived2AsBase(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_unknownMostDerived2AsBase<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_unknownMostDerived2AsBaseCompact.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_unknownMostDerived2AsBaseCompact.
 */
template<class T>
class CallbackNC_TestIntf_unknownMostDerived2AsBaseCompact : public Callback_TestIntf_unknownMostDerived2AsBaseCompact_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_TestIntf_unknownMostDerived2AsBaseCompact(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_unknownMostDerived2AsBaseCompact(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_unknownMostDerived2AsBaseCompact.
 */
template<class T> Callback_TestIntf_unknownMostDerived2AsBaseCompactPtr
newCallback_TestIntf_unknownMostDerived2AsBaseCompact(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_unknownMostDerived2AsBaseCompact<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_unknownMostDerived2AsBaseCompact.
 */
template<class T> Callback_TestIntf_unknownMostDerived2AsBaseCompactPtr
newCallback_TestIntf_unknownMostDerived2AsBaseCompact(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_unknownMostDerived2AsBaseCompact<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_unknownMostDerived2AsBaseCompact.
 */
template<class T> Callback_TestIntf_unknownMostDerived2AsBaseCompactPtr
newCallback_TestIntf_unknownMostDerived2AsBaseCompact(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_unknownMostDerived2AsBaseCompact<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_unknownMostDerived2AsBaseCompact.
 */
template<class T> Callback_TestIntf_unknownMostDerived2AsBaseCompactPtr
newCallback_TestIntf_unknownMostDerived2AsBaseCompact(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_unknownMostDerived2AsBaseCompact<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_unknownMostDerived2AsBaseCompact.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_unknownMostDerived2AsBaseCompact.
 */
template<class T, typename CT>
class Callback_TestIntf_unknownMostDerived2AsBaseCompact : public Callback_TestIntf_unknownMostDerived2AsBaseCompact_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_TestIntf_unknownMostDerived2AsBaseCompact(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_unknownMostDerived2AsBaseCompact(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_unknownMostDerived2AsBaseCompact.
 */
template<class T, typename CT> Callback_TestIntf_unknownMostDerived2AsBaseCompactPtr
newCallback_TestIntf_unknownMostDerived2AsBaseCompact(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_unknownMostDerived2AsBaseCompact<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_unknownMostDerived2AsBaseCompact.
 */
template<class T, typename CT> Callback_TestIntf_unknownMostDerived2AsBaseCompactPtr
newCallback_TestIntf_unknownMostDerived2AsBaseCompact(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_unknownMostDerived2AsBaseCompact<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_unknownMostDerived2AsBaseCompact.
 */
template<class T, typename CT> Callback_TestIntf_unknownMostDerived2AsBaseCompactPtr
newCallback_TestIntf_unknownMostDerived2AsBaseCompact(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_unknownMostDerived2AsBaseCompact<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_unknownMostDerived2AsBaseCompact.
 */
template<class T, typename CT> Callback_TestIntf_unknownMostDerived2AsBaseCompactPtr
newCallback_TestIntf_unknownMostDerived2AsBaseCompact(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_unknownMostDerived2AsBaseCompact<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_knownPreservedAsBase.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_knownPreservedAsBase.
 */
template<class T>
class CallbackNC_TestIntf_knownPreservedAsBase : public Callback_TestIntf_knownPreservedAsBase_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_TestIntf_knownPreservedAsBase(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_knownPreservedAsBase(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_knownPreservedAsBase.
 */
template<class T> Callback_TestIntf_knownPreservedAsBasePtr
newCallback_TestIntf_knownPreservedAsBase(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_knownPreservedAsBase<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_knownPreservedAsBase.
 */
template<class T> Callback_TestIntf_knownPreservedAsBasePtr
newCallback_TestIntf_knownPreservedAsBase(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_knownPreservedAsBase<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_knownPreservedAsBase.
 */
template<class T> Callback_TestIntf_knownPreservedAsBasePtr
newCallback_TestIntf_knownPreservedAsBase(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_knownPreservedAsBase<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_knownPreservedAsBase.
 */
template<class T> Callback_TestIntf_knownPreservedAsBasePtr
newCallback_TestIntf_knownPreservedAsBase(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_knownPreservedAsBase<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_knownPreservedAsBase.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_knownPreservedAsBase.
 */
template<class T, typename CT>
class Callback_TestIntf_knownPreservedAsBase : public Callback_TestIntf_knownPreservedAsBase_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_TestIntf_knownPreservedAsBase(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_knownPreservedAsBase(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_knownPreservedAsBase.
 */
template<class T, typename CT> Callback_TestIntf_knownPreservedAsBasePtr
newCallback_TestIntf_knownPreservedAsBase(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_knownPreservedAsBase<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_knownPreservedAsBase.
 */
template<class T, typename CT> Callback_TestIntf_knownPreservedAsBasePtr
newCallback_TestIntf_knownPreservedAsBase(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_knownPreservedAsBase<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_knownPreservedAsBase.
 */
template<class T, typename CT> Callback_TestIntf_knownPreservedAsBasePtr
newCallback_TestIntf_knownPreservedAsBase(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_knownPreservedAsBase<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_knownPreservedAsBase.
 */
template<class T, typename CT> Callback_TestIntf_knownPreservedAsBasePtr
newCallback_TestIntf_knownPreservedAsBase(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_knownPreservedAsBase<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_knownPreservedAsKnownPreserved.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_knownPreservedAsKnownPreserved.
 */
template<class T>
class CallbackNC_TestIntf_knownPreservedAsKnownPreserved : public Callback_TestIntf_knownPreservedAsKnownPreserved_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_TestIntf_knownPreservedAsKnownPreserved(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_knownPreservedAsKnownPreserved(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_knownPreservedAsKnownPreserved.
 */
template<class T> Callback_TestIntf_knownPreservedAsKnownPreservedPtr
newCallback_TestIntf_knownPreservedAsKnownPreserved(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_knownPreservedAsKnownPreserved<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_knownPreservedAsKnownPreserved.
 */
template<class T> Callback_TestIntf_knownPreservedAsKnownPreservedPtr
newCallback_TestIntf_knownPreservedAsKnownPreserved(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_knownPreservedAsKnownPreserved<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_knownPreservedAsKnownPreserved.
 */
template<class T> Callback_TestIntf_knownPreservedAsKnownPreservedPtr
newCallback_TestIntf_knownPreservedAsKnownPreserved(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_knownPreservedAsKnownPreserved<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_knownPreservedAsKnownPreserved.
 */
template<class T> Callback_TestIntf_knownPreservedAsKnownPreservedPtr
newCallback_TestIntf_knownPreservedAsKnownPreserved(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_knownPreservedAsKnownPreserved<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_knownPreservedAsKnownPreserved.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_knownPreservedAsKnownPreserved.
 */
template<class T, typename CT>
class Callback_TestIntf_knownPreservedAsKnownPreserved : public Callback_TestIntf_knownPreservedAsKnownPreserved_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_TestIntf_knownPreservedAsKnownPreserved(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_knownPreservedAsKnownPreserved(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_knownPreservedAsKnownPreserved.
 */
template<class T, typename CT> Callback_TestIntf_knownPreservedAsKnownPreservedPtr
newCallback_TestIntf_knownPreservedAsKnownPreserved(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_knownPreservedAsKnownPreserved<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_knownPreservedAsKnownPreserved.
 */
template<class T, typename CT> Callback_TestIntf_knownPreservedAsKnownPreservedPtr
newCallback_TestIntf_knownPreservedAsKnownPreserved(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_knownPreservedAsKnownPreserved<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_knownPreservedAsKnownPreserved.
 */
template<class T, typename CT> Callback_TestIntf_knownPreservedAsKnownPreservedPtr
newCallback_TestIntf_knownPreservedAsKnownPreserved(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_knownPreservedAsKnownPreserved<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_knownPreservedAsKnownPreserved.
 */
template<class T, typename CT> Callback_TestIntf_knownPreservedAsKnownPreservedPtr
newCallback_TestIntf_knownPreservedAsKnownPreserved(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_knownPreservedAsKnownPreserved<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_relayKnownPreservedAsBase.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_relayKnownPreservedAsBase.
 */
template<class T>
class CallbackNC_TestIntf_relayKnownPreservedAsBase : public Callback_TestIntf_relayKnownPreservedAsBase_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_TestIntf_relayKnownPreservedAsBase(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_relayKnownPreservedAsBase(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_relayKnownPreservedAsBase.
 */
template<class T> Callback_TestIntf_relayKnownPreservedAsBasePtr
newCallback_TestIntf_relayKnownPreservedAsBase(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_relayKnownPreservedAsBase<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_relayKnownPreservedAsBase.
 */
template<class T> Callback_TestIntf_relayKnownPreservedAsBasePtr
newCallback_TestIntf_relayKnownPreservedAsBase(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_relayKnownPreservedAsBase<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_relayKnownPreservedAsBase.
 */
template<class T> Callback_TestIntf_relayKnownPreservedAsBasePtr
newCallback_TestIntf_relayKnownPreservedAsBase(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_relayKnownPreservedAsBase<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_relayKnownPreservedAsBase.
 */
template<class T> Callback_TestIntf_relayKnownPreservedAsBasePtr
newCallback_TestIntf_relayKnownPreservedAsBase(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_relayKnownPreservedAsBase<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_relayKnownPreservedAsBase.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_relayKnownPreservedAsBase.
 */
template<class T, typename CT>
class Callback_TestIntf_relayKnownPreservedAsBase : public Callback_TestIntf_relayKnownPreservedAsBase_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_TestIntf_relayKnownPreservedAsBase(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_relayKnownPreservedAsBase(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_relayKnownPreservedAsBase.
 */
template<class T, typename CT> Callback_TestIntf_relayKnownPreservedAsBasePtr
newCallback_TestIntf_relayKnownPreservedAsBase(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_relayKnownPreservedAsBase<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_relayKnownPreservedAsBase.
 */
template<class T, typename CT> Callback_TestIntf_relayKnownPreservedAsBasePtr
newCallback_TestIntf_relayKnownPreservedAsBase(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_relayKnownPreservedAsBase<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_relayKnownPreservedAsBase.
 */
template<class T, typename CT> Callback_TestIntf_relayKnownPreservedAsBasePtr
newCallback_TestIntf_relayKnownPreservedAsBase(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_relayKnownPreservedAsBase<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_relayKnownPreservedAsBase.
 */
template<class T, typename CT> Callback_TestIntf_relayKnownPreservedAsBasePtr
newCallback_TestIntf_relayKnownPreservedAsBase(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_relayKnownPreservedAsBase<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_relayKnownPreservedAsKnownPreserved.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_relayKnownPreservedAsKnownPreserved.
 */
template<class T>
class CallbackNC_TestIntf_relayKnownPreservedAsKnownPreserved : public Callback_TestIntf_relayKnownPreservedAsKnownPreserved_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_TestIntf_relayKnownPreservedAsKnownPreserved(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_relayKnownPreservedAsKnownPreserved(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_relayKnownPreservedAsKnownPreserved.
 */
template<class T> Callback_TestIntf_relayKnownPreservedAsKnownPreservedPtr
newCallback_TestIntf_relayKnownPreservedAsKnownPreserved(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_relayKnownPreservedAsKnownPreserved<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_relayKnownPreservedAsKnownPreserved.
 */
template<class T> Callback_TestIntf_relayKnownPreservedAsKnownPreservedPtr
newCallback_TestIntf_relayKnownPreservedAsKnownPreserved(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_relayKnownPreservedAsKnownPreserved<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_relayKnownPreservedAsKnownPreserved.
 */
template<class T> Callback_TestIntf_relayKnownPreservedAsKnownPreservedPtr
newCallback_TestIntf_relayKnownPreservedAsKnownPreserved(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_relayKnownPreservedAsKnownPreserved<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_relayKnownPreservedAsKnownPreserved.
 */
template<class T> Callback_TestIntf_relayKnownPreservedAsKnownPreservedPtr
newCallback_TestIntf_relayKnownPreservedAsKnownPreserved(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_relayKnownPreservedAsKnownPreserved<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_relayKnownPreservedAsKnownPreserved.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_relayKnownPreservedAsKnownPreserved.
 */
template<class T, typename CT>
class Callback_TestIntf_relayKnownPreservedAsKnownPreserved : public Callback_TestIntf_relayKnownPreservedAsKnownPreserved_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_TestIntf_relayKnownPreservedAsKnownPreserved(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_relayKnownPreservedAsKnownPreserved(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_relayKnownPreservedAsKnownPreserved.
 */
template<class T, typename CT> Callback_TestIntf_relayKnownPreservedAsKnownPreservedPtr
newCallback_TestIntf_relayKnownPreservedAsKnownPreserved(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_relayKnownPreservedAsKnownPreserved<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_relayKnownPreservedAsKnownPreserved.
 */
template<class T, typename CT> Callback_TestIntf_relayKnownPreservedAsKnownPreservedPtr
newCallback_TestIntf_relayKnownPreservedAsKnownPreserved(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_relayKnownPreservedAsKnownPreserved<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_relayKnownPreservedAsKnownPreserved.
 */
template<class T, typename CT> Callback_TestIntf_relayKnownPreservedAsKnownPreservedPtr
newCallback_TestIntf_relayKnownPreservedAsKnownPreserved(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_relayKnownPreservedAsKnownPreserved<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_relayKnownPreservedAsKnownPreserved.
 */
template<class T, typename CT> Callback_TestIntf_relayKnownPreservedAsKnownPreservedPtr
newCallback_TestIntf_relayKnownPreservedAsKnownPreserved(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_relayKnownPreservedAsKnownPreserved<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_unknownPreservedAsBase.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_unknownPreservedAsBase.
 */
template<class T>
class CallbackNC_TestIntf_unknownPreservedAsBase : public Callback_TestIntf_unknownPreservedAsBase_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_TestIntf_unknownPreservedAsBase(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_unknownPreservedAsBase(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_unknownPreservedAsBase.
 */
template<class T> Callback_TestIntf_unknownPreservedAsBasePtr
newCallback_TestIntf_unknownPreservedAsBase(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_unknownPreservedAsBase<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_unknownPreservedAsBase.
 */
template<class T> Callback_TestIntf_unknownPreservedAsBasePtr
newCallback_TestIntf_unknownPreservedAsBase(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_unknownPreservedAsBase<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_unknownPreservedAsBase.
 */
template<class T> Callback_TestIntf_unknownPreservedAsBasePtr
newCallback_TestIntf_unknownPreservedAsBase(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_unknownPreservedAsBase<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_unknownPreservedAsBase.
 */
template<class T> Callback_TestIntf_unknownPreservedAsBasePtr
newCallback_TestIntf_unknownPreservedAsBase(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_unknownPreservedAsBase<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_unknownPreservedAsBase.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_unknownPreservedAsBase.
 */
template<class T, typename CT>
class Callback_TestIntf_unknownPreservedAsBase : public Callback_TestIntf_unknownPreservedAsBase_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_TestIntf_unknownPreservedAsBase(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_unknownPreservedAsBase(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_unknownPreservedAsBase.
 */
template<class T, typename CT> Callback_TestIntf_unknownPreservedAsBasePtr
newCallback_TestIntf_unknownPreservedAsBase(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_unknownPreservedAsBase<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_unknownPreservedAsBase.
 */
template<class T, typename CT> Callback_TestIntf_unknownPreservedAsBasePtr
newCallback_TestIntf_unknownPreservedAsBase(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_unknownPreservedAsBase<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_unknownPreservedAsBase.
 */
template<class T, typename CT> Callback_TestIntf_unknownPreservedAsBasePtr
newCallback_TestIntf_unknownPreservedAsBase(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_unknownPreservedAsBase<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_unknownPreservedAsBase.
 */
template<class T, typename CT> Callback_TestIntf_unknownPreservedAsBasePtr
newCallback_TestIntf_unknownPreservedAsBase(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_unknownPreservedAsBase<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_unknownPreservedAsKnownPreserved.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_unknownPreservedAsKnownPreserved.
 */
template<class T>
class CallbackNC_TestIntf_unknownPreservedAsKnownPreserved : public Callback_TestIntf_unknownPreservedAsKnownPreserved_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_TestIntf_unknownPreservedAsKnownPreserved(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_unknownPreservedAsKnownPreserved(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_unknownPreservedAsKnownPreserved.
 */
template<class T> Callback_TestIntf_unknownPreservedAsKnownPreservedPtr
newCallback_TestIntf_unknownPreservedAsKnownPreserved(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_unknownPreservedAsKnownPreserved<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_unknownPreservedAsKnownPreserved.
 */
template<class T> Callback_TestIntf_unknownPreservedAsKnownPreservedPtr
newCallback_TestIntf_unknownPreservedAsKnownPreserved(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_unknownPreservedAsKnownPreserved<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_unknownPreservedAsKnownPreserved.
 */
template<class T> Callback_TestIntf_unknownPreservedAsKnownPreservedPtr
newCallback_TestIntf_unknownPreservedAsKnownPreserved(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_unknownPreservedAsKnownPreserved<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_unknownPreservedAsKnownPreserved.
 */
template<class T> Callback_TestIntf_unknownPreservedAsKnownPreservedPtr
newCallback_TestIntf_unknownPreservedAsKnownPreserved(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_unknownPreservedAsKnownPreserved<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_unknownPreservedAsKnownPreserved.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_unknownPreservedAsKnownPreserved.
 */
template<class T, typename CT>
class Callback_TestIntf_unknownPreservedAsKnownPreserved : public Callback_TestIntf_unknownPreservedAsKnownPreserved_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_TestIntf_unknownPreservedAsKnownPreserved(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_unknownPreservedAsKnownPreserved(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_unknownPreservedAsKnownPreserved.
 */
template<class T, typename CT> Callback_TestIntf_unknownPreservedAsKnownPreservedPtr
newCallback_TestIntf_unknownPreservedAsKnownPreserved(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_unknownPreservedAsKnownPreserved<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_unknownPreservedAsKnownPreserved.
 */
template<class T, typename CT> Callback_TestIntf_unknownPreservedAsKnownPreservedPtr
newCallback_TestIntf_unknownPreservedAsKnownPreserved(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_unknownPreservedAsKnownPreserved<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_unknownPreservedAsKnownPreserved.
 */
template<class T, typename CT> Callback_TestIntf_unknownPreservedAsKnownPreservedPtr
newCallback_TestIntf_unknownPreservedAsKnownPreserved(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_unknownPreservedAsKnownPreserved<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_unknownPreservedAsKnownPreserved.
 */
template<class T, typename CT> Callback_TestIntf_unknownPreservedAsKnownPreservedPtr
newCallback_TestIntf_unknownPreservedAsKnownPreserved(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_unknownPreservedAsKnownPreserved<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_relayUnknownPreservedAsBase.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_relayUnknownPreservedAsBase.
 */
template<class T>
class CallbackNC_TestIntf_relayUnknownPreservedAsBase : public Callback_TestIntf_relayUnknownPreservedAsBase_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_TestIntf_relayUnknownPreservedAsBase(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_relayUnknownPreservedAsBase(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_relayUnknownPreservedAsBase.
 */
template<class T> Callback_TestIntf_relayUnknownPreservedAsBasePtr
newCallback_TestIntf_relayUnknownPreservedAsBase(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_relayUnknownPreservedAsBase<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_relayUnknownPreservedAsBase.
 */
template<class T> Callback_TestIntf_relayUnknownPreservedAsBasePtr
newCallback_TestIntf_relayUnknownPreservedAsBase(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_relayUnknownPreservedAsBase<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_relayUnknownPreservedAsBase.
 */
template<class T> Callback_TestIntf_relayUnknownPreservedAsBasePtr
newCallback_TestIntf_relayUnknownPreservedAsBase(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_relayUnknownPreservedAsBase<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_relayUnknownPreservedAsBase.
 */
template<class T> Callback_TestIntf_relayUnknownPreservedAsBasePtr
newCallback_TestIntf_relayUnknownPreservedAsBase(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_relayUnknownPreservedAsBase<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_relayUnknownPreservedAsBase.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_relayUnknownPreservedAsBase.
 */
template<class T, typename CT>
class Callback_TestIntf_relayUnknownPreservedAsBase : public Callback_TestIntf_relayUnknownPreservedAsBase_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_TestIntf_relayUnknownPreservedAsBase(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_relayUnknownPreservedAsBase(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_relayUnknownPreservedAsBase.
 */
template<class T, typename CT> Callback_TestIntf_relayUnknownPreservedAsBasePtr
newCallback_TestIntf_relayUnknownPreservedAsBase(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_relayUnknownPreservedAsBase<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_relayUnknownPreservedAsBase.
 */
template<class T, typename CT> Callback_TestIntf_relayUnknownPreservedAsBasePtr
newCallback_TestIntf_relayUnknownPreservedAsBase(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_relayUnknownPreservedAsBase<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_relayUnknownPreservedAsBase.
 */
template<class T, typename CT> Callback_TestIntf_relayUnknownPreservedAsBasePtr
newCallback_TestIntf_relayUnknownPreservedAsBase(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_relayUnknownPreservedAsBase<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_relayUnknownPreservedAsBase.
 */
template<class T, typename CT> Callback_TestIntf_relayUnknownPreservedAsBasePtr
newCallback_TestIntf_relayUnknownPreservedAsBase(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_relayUnknownPreservedAsBase<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_relayUnknownPreservedAsKnownPreserved.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_relayUnknownPreservedAsKnownPreserved.
 */
template<class T>
class CallbackNC_TestIntf_relayUnknownPreservedAsKnownPreserved : public Callback_TestIntf_relayUnknownPreservedAsKnownPreserved_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_TestIntf_relayUnknownPreservedAsKnownPreserved(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_relayUnknownPreservedAsKnownPreserved(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_relayUnknownPreservedAsKnownPreserved.
 */
template<class T> Callback_TestIntf_relayUnknownPreservedAsKnownPreservedPtr
newCallback_TestIntf_relayUnknownPreservedAsKnownPreserved(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_relayUnknownPreservedAsKnownPreserved<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_relayUnknownPreservedAsKnownPreserved.
 */
template<class T> Callback_TestIntf_relayUnknownPreservedAsKnownPreservedPtr
newCallback_TestIntf_relayUnknownPreservedAsKnownPreserved(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_relayUnknownPreservedAsKnownPreserved<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_relayUnknownPreservedAsKnownPreserved.
 */
template<class T> Callback_TestIntf_relayUnknownPreservedAsKnownPreservedPtr
newCallback_TestIntf_relayUnknownPreservedAsKnownPreserved(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_relayUnknownPreservedAsKnownPreserved<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_relayUnknownPreservedAsKnownPreserved.
 */
template<class T> Callback_TestIntf_relayUnknownPreservedAsKnownPreservedPtr
newCallback_TestIntf_relayUnknownPreservedAsKnownPreserved(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_relayUnknownPreservedAsKnownPreserved<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_relayUnknownPreservedAsKnownPreserved.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_relayUnknownPreservedAsKnownPreserved.
 */
template<class T, typename CT>
class Callback_TestIntf_relayUnknownPreservedAsKnownPreserved : public Callback_TestIntf_relayUnknownPreservedAsKnownPreserved_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_TestIntf_relayUnknownPreservedAsKnownPreserved(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_relayUnknownPreservedAsKnownPreserved(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_relayUnknownPreservedAsKnownPreserved.
 */
template<class T, typename CT> Callback_TestIntf_relayUnknownPreservedAsKnownPreservedPtr
newCallback_TestIntf_relayUnknownPreservedAsKnownPreserved(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_relayUnknownPreservedAsKnownPreserved<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_relayUnknownPreservedAsKnownPreserved.
 */
template<class T, typename CT> Callback_TestIntf_relayUnknownPreservedAsKnownPreservedPtr
newCallback_TestIntf_relayUnknownPreservedAsKnownPreserved(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_relayUnknownPreservedAsKnownPreserved<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_relayUnknownPreservedAsKnownPreserved.
 */
template<class T, typename CT> Callback_TestIntf_relayUnknownPreservedAsKnownPreservedPtr
newCallback_TestIntf_relayUnknownPreservedAsKnownPreserved(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_relayUnknownPreservedAsKnownPreserved<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_relayUnknownPreservedAsKnownPreserved.
 */
template<class T, typename CT> Callback_TestIntf_relayUnknownPreservedAsKnownPreservedPtr
newCallback_TestIntf_relayUnknownPreservedAsKnownPreserved(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_relayUnknownPreservedAsKnownPreserved<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_shutdown.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_shutdown.
 */
template<class T>
class CallbackNC_TestIntf_shutdown : public Callback_TestIntf_shutdown_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_TestIntf_shutdown(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_shutdown.
 */
template<class T> Callback_TestIntf_shutdownPtr
newCallback_TestIntf_shutdown(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_shutdown<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_shutdown.
 */
template<class T> Callback_TestIntf_shutdownPtr
newCallback_TestIntf_shutdown(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_shutdown<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_shutdown.
 */
template<class T> Callback_TestIntf_shutdownPtr
newCallback_TestIntf_shutdown(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_shutdown<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_shutdown.
 */
template<class T> Callback_TestIntf_shutdownPtr
newCallback_TestIntf_shutdown(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_shutdown<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_shutdown.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_shutdown.
 */
template<class T, typename CT>
class Callback_TestIntf_shutdown : public Callback_TestIntf_shutdown_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_TestIntf_shutdown(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_shutdown.
 */
template<class T, typename CT> Callback_TestIntf_shutdownPtr
newCallback_TestIntf_shutdown(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_shutdown<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_shutdown.
 */
template<class T, typename CT> Callback_TestIntf_shutdownPtr
newCallback_TestIntf_shutdown(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_shutdown<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_shutdown.
 */
template<class T, typename CT> Callback_TestIntf_shutdownPtr
newCallback_TestIntf_shutdown(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_shutdown<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_shutdown.
 */
template<class T, typename CT> Callback_TestIntf_shutdownPtr
newCallback_TestIntf_shutdown(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_shutdown<T, CT>(instance, 0, excb, sentcb);
}

}

#endif

#include <IceUtil/PopDisableWarnings.h>
#endif
