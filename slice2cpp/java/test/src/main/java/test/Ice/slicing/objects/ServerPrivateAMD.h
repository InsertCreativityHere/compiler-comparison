//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.8.0-alpha.0
//
// <auto-generated>
//
// Generated from file `ServerPrivateAMD.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __ServerPrivateAMD_h__
#define __ServerPrivateAMD_h__

#include <Ice/PushDisableWarnings.h>
#include <Ice/Ice.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION  != 30850
#       error Ice version mismatch: an exact match is required for beta generated code
#   endif
#endif

namespace Test
{
    class SBase;
    using SBasePtr = ::std::shared_ptr<SBase>;

    class SBSKnownDerived;
    using SBSKnownDerivedPtr = ::std::shared_ptr<SBSKnownDerived>;

    class B;
    using BPtr = ::std::shared_ptr<B>;

    class D1;
    using D1Ptr = ::std::shared_ptr<D1>;

    using BSeq = ::std::vector<BPtr>;

    class SS1;
    using SS1Ptr = ::std::shared_ptr<SS1>;

    class SS2;
    using SS2Ptr = ::std::shared_ptr<SS2>;

    struct SS3;

    using BDict = ::std::map<::std::int32_t, BPtr>;

    class Forward;
    using ForwardPtr = ::std::shared_ptr<Forward>;

    class PBase;
    using PBasePtr = ::std::shared_ptr<PBase>;

    using PBaseSeq = ::std::vector<PBasePtr>;

    class Preserved;
    using PreservedPtr = ::std::shared_ptr<Preserved>;

    class PDerived;
    using PDerivedPtr = ::std::shared_ptr<PDerived>;

    class PNode;
    using PNodePtr = ::std::shared_ptr<PNode>;

    class TestIntfPrx;

    class SBSUnknownDerived;
    using SBSUnknownDerivedPtr = ::std::shared_ptr<SBSUnknownDerived>;

    class SUnknown;
    using SUnknownPtr = ::std::shared_ptr<SUnknown>;

    class D2;
    using D2Ptr = ::std::shared_ptr<D2>;

    class D4;
    using D4Ptr = ::std::shared_ptr<D4>;

    class MyClass;
    using MyClassPtr = ::std::shared_ptr<MyClass>;

    class PSUnknown;
    using PSUnknownPtr = ::std::shared_ptr<PSUnknown>;

    class PSUnknown2;
    using PSUnknown2Ptr = ::std::shared_ptr<PSUnknown2>;

    class Hidden;
    using HiddenPtr = ::std::shared_ptr<Hidden>;

}

namespace Test
{

class TestIntfPrx : public ::Ice::Proxy<TestIntfPrx, ::Ice::ObjectPrx>
{
public:

    ::Ice::ValuePtr SBaseAsObject(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    [[nodiscard]] ::std::future<::Ice::ValuePtr> SBaseAsObjectAsync(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    SBaseAsObjectAsync(::std::function<void(::Ice::ValuePtr)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_SBaseAsObject(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::Ice::ValuePtr>>&, const ::Ice::Context&) const;
    /// \endcond

    SBasePtr SBaseAsSBase(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    [[nodiscard]] ::std::future<SBasePtr> SBaseAsSBaseAsync(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    SBaseAsSBaseAsync(::std::function<void(::Test::SBasePtr)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_SBaseAsSBase(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<SBasePtr>>&, const ::Ice::Context&) const;
    /// \endcond

    SBasePtr SBSKnownDerivedAsSBase(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    [[nodiscard]] ::std::future<SBasePtr> SBSKnownDerivedAsSBaseAsync(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    SBSKnownDerivedAsSBaseAsync(::std::function<void(::Test::SBasePtr)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_SBSKnownDerivedAsSBase(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<SBasePtr>>&, const ::Ice::Context&) const;
    /// \endcond

    SBSKnownDerivedPtr SBSKnownDerivedAsSBSKnownDerived(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    [[nodiscard]] ::std::future<SBSKnownDerivedPtr> SBSKnownDerivedAsSBSKnownDerivedAsync(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    SBSKnownDerivedAsSBSKnownDerivedAsync(::std::function<void(::Test::SBSKnownDerivedPtr)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_SBSKnownDerivedAsSBSKnownDerived(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<SBSKnownDerivedPtr>>&, const ::Ice::Context&) const;
    /// \endcond

    SBasePtr SBSUnknownDerivedAsSBase(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    [[nodiscard]] ::std::future<SBasePtr> SBSUnknownDerivedAsSBaseAsync(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    SBSUnknownDerivedAsSBaseAsync(::std::function<void(::Test::SBasePtr)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_SBSUnknownDerivedAsSBase(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<SBasePtr>>&, const ::Ice::Context&) const;
    /// \endcond

    SBasePtr SBSUnknownDerivedAsSBaseCompact(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    [[nodiscard]] ::std::future<SBasePtr> SBSUnknownDerivedAsSBaseCompactAsync(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    SBSUnknownDerivedAsSBaseCompactAsync(::std::function<void(::Test::SBasePtr)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_SBSUnknownDerivedAsSBaseCompact(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<SBasePtr>>&, const ::Ice::Context&) const;
    /// \endcond

    ::Ice::ValuePtr SUnknownAsObject(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    [[nodiscard]] ::std::future<::Ice::ValuePtr> SUnknownAsObjectAsync(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    SUnknownAsObjectAsync(::std::function<void(::Ice::ValuePtr)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_SUnknownAsObject(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::Ice::ValuePtr>>&, const ::Ice::Context&) const;
    /// \endcond

    void checkSUnknown(const ::Ice::ValuePtr& o, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    [[nodiscard]] ::std::future<void> checkSUnknownAsync(const ::Ice::ValuePtr& o, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    checkSUnknownAsync(const ::Ice::ValuePtr& o, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_checkSUnknown(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::ValuePtr&, const ::Ice::Context&) const;
    /// \endcond

    BPtr oneElementCycle(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    [[nodiscard]] ::std::future<BPtr> oneElementCycleAsync(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    oneElementCycleAsync(::std::function<void(::Test::BPtr)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_oneElementCycle(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<BPtr>>&, const ::Ice::Context&) const;
    /// \endcond

    BPtr twoElementCycle(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    [[nodiscard]] ::std::future<BPtr> twoElementCycleAsync(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    twoElementCycleAsync(::std::function<void(::Test::BPtr)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_twoElementCycle(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<BPtr>>&, const ::Ice::Context&) const;
    /// \endcond

    BPtr D1AsB(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    [[nodiscard]] ::std::future<BPtr> D1AsBAsync(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    D1AsBAsync(::std::function<void(::Test::BPtr)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_D1AsB(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<BPtr>>&, const ::Ice::Context&) const;
    /// \endcond

    D1Ptr D1AsD1(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    [[nodiscard]] ::std::future<D1Ptr> D1AsD1Async(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    D1AsD1Async(::std::function<void(::Test::D1Ptr)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_D1AsD1(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<D1Ptr>>&, const ::Ice::Context&) const;
    /// \endcond

    BPtr D2AsB(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    [[nodiscard]] ::std::future<BPtr> D2AsBAsync(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    D2AsBAsync(::std::function<void(::Test::BPtr)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_D2AsB(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<BPtr>>&, const ::Ice::Context&) const;
    /// \endcond

    void paramTest1(BPtr& p1, BPtr& p2, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    [[nodiscard]] ::std::future<::std::tuple<BPtr, BPtr>> paramTest1Async(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    paramTest1Async(::std::function<void(::Test::BPtr, ::Test::BPtr)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_paramTest1(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<BPtr, BPtr>>>&, const ::Ice::Context&) const;
    /// \endcond

    void paramTest2(BPtr& p2, BPtr& p1, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    [[nodiscard]] ::std::future<::std::tuple<BPtr, BPtr>> paramTest2Async(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    paramTest2Async(::std::function<void(::Test::BPtr, ::Test::BPtr)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_paramTest2(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<BPtr, BPtr>>>&, const ::Ice::Context&) const;
    /// \endcond

    BPtr paramTest3(BPtr& p1, BPtr& p2, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    [[nodiscard]] ::std::future<::std::tuple<BPtr, BPtr, BPtr>> paramTest3Async(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    paramTest3Async(::std::function<void(::Test::BPtr, ::Test::BPtr, ::Test::BPtr)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_paramTest3(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<BPtr, BPtr, BPtr>>>&, const ::Ice::Context&) const;
    /// \endcond

    BPtr paramTest4(BPtr& p, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    [[nodiscard]] ::std::future<::std::tuple<BPtr, BPtr>> paramTest4Async(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    paramTest4Async(::std::function<void(::Test::BPtr, ::Test::BPtr)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_paramTest4(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<BPtr, BPtr>>>&, const ::Ice::Context&) const;
    /// \endcond

    BPtr returnTest1(BPtr& p1, BPtr& p2, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    [[nodiscard]] ::std::future<::std::tuple<BPtr, BPtr, BPtr>> returnTest1Async(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    returnTest1Async(::std::function<void(::Test::BPtr, ::Test::BPtr, ::Test::BPtr)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_returnTest1(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<BPtr, BPtr, BPtr>>>&, const ::Ice::Context&) const;
    /// \endcond

    BPtr returnTest2(BPtr& p2, BPtr& p1, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    [[nodiscard]] ::std::future<::std::tuple<BPtr, BPtr, BPtr>> returnTest2Async(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    returnTest2Async(::std::function<void(::Test::BPtr, ::Test::BPtr, ::Test::BPtr)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_returnTest2(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<BPtr, BPtr, BPtr>>>&, const ::Ice::Context&) const;
    /// \endcond

    BPtr returnTest3(const BPtr& p1, const BPtr& p2, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    [[nodiscard]] ::std::future<BPtr> returnTest3Async(const BPtr& p1, const BPtr& p2, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    returnTest3Async(const BPtr& p1, const BPtr& p2, ::std::function<void(::Test::BPtr)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_returnTest3(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<BPtr>>&, const BPtr&, const BPtr&, const ::Ice::Context&) const;
    /// \endcond

    SS3 sequenceTest(const SS1Ptr& p1, const SS2Ptr& p2, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    [[nodiscard]] ::std::future<SS3> sequenceTestAsync(const SS1Ptr& p1, const SS2Ptr& p2, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    sequenceTestAsync(const SS1Ptr& p1, const SS2Ptr& p2, ::std::function<void(::Test::SS3)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_sequenceTest(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<SS3>>&, const SS1Ptr&, const SS2Ptr&, const ::Ice::Context&) const;
    /// \endcond

    BDict dictionaryTest(const BDict& bin, BDict& bout, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    [[nodiscard]] ::std::future<::std::tuple<BDict, BDict>> dictionaryTestAsync(const BDict& bin, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    dictionaryTestAsync(const BDict& bin, ::std::function<void(::Test::BDict, ::Test::BDict)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_dictionaryTest(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<BDict, BDict>>>&, const BDict&, const ::Ice::Context&) const;
    /// \endcond

    PBasePtr exchangePBase(const PBasePtr& pb, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    [[nodiscard]] ::std::future<PBasePtr> exchangePBaseAsync(const PBasePtr& pb, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    exchangePBaseAsync(const PBasePtr& pb, ::std::function<void(::Test::PBasePtr)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_exchangePBase(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<PBasePtr>>&, const PBasePtr&, const ::Ice::Context&) const;
    /// \endcond

    PreservedPtr PBSUnknownAsPreserved(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    [[nodiscard]] ::std::future<PreservedPtr> PBSUnknownAsPreservedAsync(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    PBSUnknownAsPreservedAsync(::std::function<void(::Test::PreservedPtr)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_PBSUnknownAsPreserved(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<PreservedPtr>>&, const ::Ice::Context&) const;
    /// \endcond

    void checkPBSUnknown(const PreservedPtr& p, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    [[nodiscard]] ::std::future<void> checkPBSUnknownAsync(const PreservedPtr& p, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    checkPBSUnknownAsync(const PreservedPtr& p, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_checkPBSUnknown(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const PreservedPtr&, const ::Ice::Context&) const;
    /// \endcond

    PreservedPtr PBSUnknownAsPreservedWithGraph(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    [[nodiscard]] ::std::future<PreservedPtr> PBSUnknownAsPreservedWithGraphAsync(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    PBSUnknownAsPreservedWithGraphAsync(::std::function<void(::Test::PreservedPtr)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_PBSUnknownAsPreservedWithGraph(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<PreservedPtr>>&, const ::Ice::Context&) const;
    /// \endcond

    void checkPBSUnknownWithGraph(const PreservedPtr& p, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    [[nodiscard]] ::std::future<void> checkPBSUnknownWithGraphAsync(const PreservedPtr& p, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    checkPBSUnknownWithGraphAsync(const PreservedPtr& p, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_checkPBSUnknownWithGraph(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const PreservedPtr&, const ::Ice::Context&) const;
    /// \endcond

    PreservedPtr PBSUnknown2AsPreservedWithGraph(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    [[nodiscard]] ::std::future<PreservedPtr> PBSUnknown2AsPreservedWithGraphAsync(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    PBSUnknown2AsPreservedWithGraphAsync(::std::function<void(::Test::PreservedPtr)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_PBSUnknown2AsPreservedWithGraph(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<PreservedPtr>>&, const ::Ice::Context&) const;
    /// \endcond

    void checkPBSUnknown2WithGraph(const PreservedPtr& p, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    [[nodiscard]] ::std::future<void> checkPBSUnknown2WithGraphAsync(const PreservedPtr& p, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    checkPBSUnknown2WithGraphAsync(const PreservedPtr& p, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_checkPBSUnknown2WithGraph(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const PreservedPtr&, const ::Ice::Context&) const;
    /// \endcond

    PNodePtr exchangePNode(const PNodePtr& pn, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    [[nodiscard]] ::std::future<PNodePtr> exchangePNodeAsync(const PNodePtr& pn, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    exchangePNodeAsync(const PNodePtr& pn, ::std::function<void(::Test::PNodePtr)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_exchangePNode(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<PNodePtr>>&, const PNodePtr&, const ::Ice::Context&) const;
    /// \endcond

    void throwBaseAsBase(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    [[nodiscard]] ::std::future<void> throwBaseAsBaseAsync(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    throwBaseAsBaseAsync(::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_throwBaseAsBase(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&) const;
    /// \endcond

    void throwDerivedAsBase(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    [[nodiscard]] ::std::future<void> throwDerivedAsBaseAsync(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    throwDerivedAsBaseAsync(::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_throwDerivedAsBase(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&) const;
    /// \endcond

    void throwDerivedAsDerived(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    [[nodiscard]] ::std::future<void> throwDerivedAsDerivedAsync(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    throwDerivedAsDerivedAsync(::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_throwDerivedAsDerived(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&) const;
    /// \endcond

    void throwUnknownDerivedAsBase(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    [[nodiscard]] ::std::future<void> throwUnknownDerivedAsBaseAsync(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    throwUnknownDerivedAsBaseAsync(::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_throwUnknownDerivedAsBase(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&) const;
    /// \endcond

    void throwPreservedException(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    [[nodiscard]] ::std::future<void> throwPreservedExceptionAsync(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    throwPreservedExceptionAsync(::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_throwPreservedException(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&) const;
    /// \endcond

    /**
     * Use of forward-declared class to verify that code is generated correctly.
     * @param context The Context map to send with the invocation.
     */
    void useForward(ForwardPtr& f, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Use of forward-declared class to verify that code is generated correctly.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    [[nodiscard]] ::std::future<ForwardPtr> useForwardAsync(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Use of forward-declared class to verify that code is generated correctly.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    useForwardAsync(::std::function<void(::Test::ForwardPtr)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_useForward(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ForwardPtr>>&, const ::Ice::Context&) const;
    /// \endcond

    void shutdown(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    [[nodiscard]] ::std::future<void> shutdownAsync(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    shutdownAsync(::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_shutdown(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&) const;
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const char* ice_staticId() noexcept;
    TestIntfPrx(const TestIntfPrx& other) noexcept : ::Ice::ObjectPrx(other)
    {
    }

    TestIntfPrx(TestIntfPrx&& other) noexcept : ::Ice::ObjectPrx(::std::move(other))
    {
    }

    TestIntfPrx(const ::Ice::CommunicatorPtr& communicator, std::string_view proxyString) :
        ::Ice::ObjectPrx(communicator, proxyString)
    {
    }

    TestIntfPrx& operator=(const TestIntfPrx& rhs) noexcept
    {
        ::Ice::ObjectPrx::operator=(rhs);
        return *this;
    }

    TestIntfPrx& operator=(TestIntfPrx&& rhs) noexcept
    {
        ::Ice::ObjectPrx::operator=(::std::move(rhs));
        return *this;
    }

    /// \cond INTERNAL
    static TestIntfPrx _fromReference(::IceInternal::ReferencePtr ref) { return TestIntfPrx(::std::move(ref)); }

protected:

    TestIntfPrx() = default;

    explicit TestIntfPrx(::IceInternal::ReferencePtr&& ref) : ::Ice::ObjectPrx(::std::move(ref))
    {
    }
    /// \endcond
};

}

namespace Test
{

class SBase : public ::Ice::Value
{
public:
    /**
     * Default constructor.
     */
    SBase() noexcept = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit SBase(::std::string sb) noexcept :
        sb(::std::move(sb))
    {
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const char* ice_staticId() noexcept;

    const char* ice_id() const noexcept override;

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&> ice_tuple() const
    {
        return std::tie(sb);
    }

    /**
     * Creates a shallow polymorphic copy of this instance.
     * @return The cloned value.
     */
    SBasePtr ice_clone() const { return ::std::static_pointer_cast<SBase>(_iceCloneImpl()); }

    ::std::string sb;

protected:
    SBase(const SBase&) = default;

    ::Ice::ValuePtr _iceCloneImpl() const override;
    void _iceWriteImpl(::Ice::OutputStream*) const override;

    void _iceReadImpl(::Ice::InputStream*) override;
};

class SBSKnownDerived : public SBase
{
public:
    /**
     * Default constructor.
     */
    SBSKnownDerived() noexcept = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    SBSKnownDerived(::std::string sb, ::std::string sbskd) noexcept :
        SBase(::std::move(sb)),
        sbskd(::std::move(sbskd))
    {
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const char* ice_staticId() noexcept;

    const char* ice_id() const noexcept override;

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::std::string&> ice_tuple() const
    {
        return std::tie(sb, sbskd);
    }

    /**
     * Creates a shallow polymorphic copy of this instance.
     * @return The cloned value.
     */
    SBSKnownDerivedPtr ice_clone() const { return ::std::static_pointer_cast<SBSKnownDerived>(_iceCloneImpl()); }

    ::std::string sbskd;

protected:
    SBSKnownDerived(const SBSKnownDerived&) = default;

    ::Ice::ValuePtr _iceCloneImpl() const override;
    void _iceWriteImpl(::Ice::OutputStream*) const override;

    void _iceReadImpl(::Ice::InputStream*) override;
};

class B : public ::Ice::Value
{
public:
    /**
     * Default constructor.
     */
    B() noexcept = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    B(::std::string sb, ::Test::BPtr pb) noexcept :
        sb(::std::move(sb)),
        pb(::std::move(pb))
    {
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const char* ice_staticId() noexcept;

    const char* ice_id() const noexcept override;

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::Test::BPtr&> ice_tuple() const
    {
        return std::tie(sb, pb);
    }

    /**
     * Creates a shallow polymorphic copy of this instance.
     * @return The cloned value.
     */
    BPtr ice_clone() const { return ::std::static_pointer_cast<B>(_iceCloneImpl()); }

    ::std::string sb;
    ::Test::BPtr pb;

protected:
    B(const B&) = default;

    ::Ice::ValuePtr _iceCloneImpl() const override;
    void _iceWriteImpl(::Ice::OutputStream*) const override;

    void _iceReadImpl(::Ice::InputStream*) override;
};

class D1 : public B
{
public:
    /**
     * Default constructor.
     */
    D1() noexcept = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    D1(::std::string sb, ::Test::BPtr pb, ::std::string sd1, ::Test::BPtr pd1) noexcept :
        B(::std::move(sb), ::std::move(pb)),
        sd1(::std::move(sd1)),
        pd1(::std::move(pd1))
    {
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const char* ice_staticId() noexcept;

    const char* ice_id() const noexcept override;

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::Test::BPtr&, const ::std::string&, const ::Test::BPtr&> ice_tuple() const
    {
        return std::tie(sb, pb, sd1, pd1);
    }

    /**
     * Creates a shallow polymorphic copy of this instance.
     * @return The cloned value.
     */
    D1Ptr ice_clone() const { return ::std::static_pointer_cast<D1>(_iceCloneImpl()); }

    ::std::string sd1;
    ::Test::BPtr pd1;

protected:
    D1(const D1&) = default;

    ::Ice::ValuePtr _iceCloneImpl() const override;
    void _iceWriteImpl(::Ice::OutputStream*) const override;

    void _iceReadImpl(::Ice::InputStream*) override;
};

class SS1 : public ::Ice::Value
{
public:
    /**
     * Default constructor.
     */
    SS1() noexcept = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit SS1(::Test::BSeq s) noexcept :
        s(::std::move(s))
    {
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const char* ice_staticId() noexcept;

    const char* ice_id() const noexcept override;

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::Test::BSeq&> ice_tuple() const
    {
        return std::tie(s);
    }

    /**
     * Creates a shallow polymorphic copy of this instance.
     * @return The cloned value.
     */
    SS1Ptr ice_clone() const { return ::std::static_pointer_cast<SS1>(_iceCloneImpl()); }

    ::Test::BSeq s;

protected:
    SS1(const SS1&) = default;

    ::Ice::ValuePtr _iceCloneImpl() const override;
    void _iceWriteImpl(::Ice::OutputStream*) const override;

    void _iceReadImpl(::Ice::InputStream*) override;
};

class SS2 : public ::Ice::Value
{
public:
    /**
     * Default constructor.
     */
    SS2() noexcept = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit SS2(::Test::BSeq s) noexcept :
        s(::std::move(s))
    {
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const char* ice_staticId() noexcept;

    const char* ice_id() const noexcept override;

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::Test::BSeq&> ice_tuple() const
    {
        return std::tie(s);
    }

    /**
     * Creates a shallow polymorphic copy of this instance.
     * @return The cloned value.
     */
    SS2Ptr ice_clone() const { return ::std::static_pointer_cast<SS2>(_iceCloneImpl()); }

    ::Test::BSeq s;

protected:
    SS2(const SS2&) = default;

    ::Ice::ValuePtr _iceCloneImpl() const override;
    void _iceWriteImpl(::Ice::OutputStream*) const override;

    void _iceReadImpl(::Ice::InputStream*) override;
};

struct SS3
{
    ::Test::SS1Ptr c1;
    ::Test::SS2Ptr c2;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::Test::SS1Ptr&, const ::Test::SS2Ptr&> ice_tuple() const
    {
        return std::tie(c1, c2);
    }
};

class BaseException : public ::Ice::UserException
{
public:
    /**
     * Default constructor.
     */
    BaseException() noexcept = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    BaseException(::std::string sbe, BPtr pb) noexcept :
        sbe(::std::move(sbe)),
        pb(::std::move(pb))
    {
    }

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::Test::BPtr&> ice_tuple() const
    {
        return std::tie(sbe, pb);
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    static const char* ice_staticId() noexcept;

    const char* ice_id() const noexcept override;

    void ice_throw() const override;

    /// \cond STREAM
    bool _usesClasses() const override;
    /// \endcond

    ::std::string sbe;
    ::Test::BPtr pb;

protected:
    void _writeImpl(::Ice::OutputStream*) const override;

    void _readImpl(::Ice::InputStream*) override;
};

class DerivedException : public BaseException
{
public:
    /**
     * Default constructor.
     */
    DerivedException() noexcept = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    DerivedException(::std::string sbe, BPtr pb, ::std::string sde, D1Ptr pd1) noexcept :
        BaseException(::std::move(sbe), ::std::move(pb)),
        sde(::std::move(sde)),
        pd1(::std::move(pd1))
    {
    }

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::Test::BPtr&, const ::std::string&, const ::Test::D1Ptr&> ice_tuple() const
    {
        return std::tie(sbe, pb, sde, pd1);
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    static const char* ice_staticId() noexcept;

    const char* ice_id() const noexcept override;

    void ice_throw() const override;

    ::std::string sde;
    ::Test::D1Ptr pd1;

protected:
    void _writeImpl(::Ice::OutputStream*) const override;

    void _readImpl(::Ice::InputStream*) override;
};

class PBase : public ::Ice::Value
{
public:
    /**
     * Default constructor.
     */
    PBase() noexcept = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit PBase(::std::int32_t pi) noexcept :
        pi(pi)
    {
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const char* ice_staticId() noexcept;

    const char* ice_id() const noexcept override;

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::int32_t&> ice_tuple() const
    {
        return std::tie(pi);
    }

    /**
     * Creates a shallow polymorphic copy of this instance.
     * @return The cloned value.
     */
    PBasePtr ice_clone() const { return ::std::static_pointer_cast<PBase>(_iceCloneImpl()); }

    ::std::int32_t pi;

protected:
    PBase(const PBase&) = default;

    ::Ice::ValuePtr _iceCloneImpl() const override;
    void _iceWriteImpl(::Ice::OutputStream*) const override;

    void _iceReadImpl(::Ice::InputStream*) override;
};

class Preserved : public PBase
{
public:
    /**
     * Default constructor.
     */
    Preserved() noexcept = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    Preserved(::std::int32_t pi, ::std::string ps) noexcept :
        PBase(pi),
        ps(::std::move(ps))
    {
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const char* ice_staticId() noexcept;

    const char* ice_id() const noexcept override;

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::int32_t&, const ::std::string&> ice_tuple() const
    {
        return std::tie(pi, ps);
    }

    /**
     * Creates a shallow polymorphic copy of this instance.
     * @return The cloned value.
     */
    PreservedPtr ice_clone() const { return ::std::static_pointer_cast<Preserved>(_iceCloneImpl()); }

    ::std::string ps;

protected:
    Preserved(const Preserved&) = default;

    ::Ice::ValuePtr _iceCloneImpl() const override;
    void _iceWriteImpl(::Ice::OutputStream*) const override;

    void _iceReadImpl(::Ice::InputStream*) override;
};

class PDerived : public Preserved
{
public:
    /**
     * Default constructor.
     */
    PDerived() noexcept = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    PDerived(::std::int32_t pi, ::std::string ps, ::Test::PBasePtr pb) noexcept :
        Preserved(pi, ::std::move(ps)),
        pb(::std::move(pb))
    {
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const char* ice_staticId() noexcept;

    const char* ice_id() const noexcept override;

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::int32_t&, const ::std::string&, const ::Test::PBasePtr&> ice_tuple() const
    {
        return std::tie(pi, ps, pb);
    }

    /**
     * Creates a shallow polymorphic copy of this instance.
     * @return The cloned value.
     */
    PDerivedPtr ice_clone() const { return ::std::static_pointer_cast<PDerived>(_iceCloneImpl()); }

    ::Test::PBasePtr pb;

protected:
    PDerived(const PDerived&) = default;

    ::Ice::ValuePtr _iceCloneImpl() const override;
    void _iceWriteImpl(::Ice::OutputStream*) const override;

    void _iceReadImpl(::Ice::InputStream*) override;
};

class PNode : public ::Ice::Value
{
public:
    /**
     * Default constructor.
     */
    PNode() noexcept = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit PNode(::Test::PNodePtr next) noexcept :
        next(::std::move(next))
    {
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const char* ice_staticId() noexcept;

    const char* ice_id() const noexcept override;

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::Test::PNodePtr&> ice_tuple() const
    {
        return std::tie(next);
    }

    /**
     * Creates a shallow polymorphic copy of this instance.
     * @return The cloned value.
     */
    PNodePtr ice_clone() const { return ::std::static_pointer_cast<PNode>(_iceCloneImpl()); }

    ::Test::PNodePtr next;

protected:
    PNode(const PNode&) = default;

    ::Ice::ValuePtr _iceCloneImpl() const override;
    void _iceWriteImpl(::Ice::OutputStream*) const override;

    void _iceReadImpl(::Ice::InputStream*) override;
};

class PreservedException : public ::Ice::UserException
{
public:
    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    static const char* ice_staticId() noexcept;

    const char* ice_id() const noexcept override;

    void ice_throw() const override;

protected:
    void _writeImpl(::Ice::OutputStream*) const override;

    void _readImpl(::Ice::InputStream*) override;
};

class SBSUnknownDerived : public SBase
{
public:
    /**
     * Default constructor.
     */
    SBSUnknownDerived() noexcept = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    SBSUnknownDerived(::std::string sb, ::std::string sbsud) noexcept :
        SBase(::std::move(sb)),
        sbsud(::std::move(sbsud))
    {
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const char* ice_staticId() noexcept;

    const char* ice_id() const noexcept override;

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::std::string&> ice_tuple() const
    {
        return std::tie(sb, sbsud);
    }

    /**
     * Creates a shallow polymorphic copy of this instance.
     * @return The cloned value.
     */
    SBSUnknownDerivedPtr ice_clone() const { return ::std::static_pointer_cast<SBSUnknownDerived>(_iceCloneImpl()); }

    ::std::string sbsud;

protected:
    SBSUnknownDerived(const SBSUnknownDerived&) = default;

    ::Ice::ValuePtr _iceCloneImpl() const override;
    void _iceWriteImpl(::Ice::OutputStream*) const override;

    void _iceReadImpl(::Ice::InputStream*) override;
};

class SUnknown : public ::Ice::Value
{
public:
    /**
     * Default constructor.
     */
    SUnknown() noexcept = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    SUnknown(::std::string su, ::Test::SUnknownPtr cycle) noexcept :
        su(::std::move(su)),
        cycle(::std::move(cycle))
    {
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const char* ice_staticId() noexcept;

    const char* ice_id() const noexcept override;

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::Test::SUnknownPtr&> ice_tuple() const
    {
        return std::tie(su, cycle);
    }

    /**
     * Creates a shallow polymorphic copy of this instance.
     * @return The cloned value.
     */
    SUnknownPtr ice_clone() const { return ::std::static_pointer_cast<SUnknown>(_iceCloneImpl()); }

    ::std::string su;
    ::Test::SUnknownPtr cycle;

protected:
    SUnknown(const SUnknown&) = default;

    ::Ice::ValuePtr _iceCloneImpl() const override;
    void _iceWriteImpl(::Ice::OutputStream*) const override;

    void _iceReadImpl(::Ice::InputStream*) override;
};

class D2 : public B
{
public:
    /**
     * Default constructor.
     */
    D2() noexcept = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    D2(::std::string sb, ::Test::BPtr pb, ::std::string sd2, ::Test::BPtr pd2) noexcept :
        B(::std::move(sb), ::std::move(pb)),
        sd2(::std::move(sd2)),
        pd2(::std::move(pd2))
    {
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const char* ice_staticId() noexcept;

    const char* ice_id() const noexcept override;

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::Test::BPtr&, const ::std::string&, const ::Test::BPtr&> ice_tuple() const
    {
        return std::tie(sb, pb, sd2, pd2);
    }

    /**
     * Creates a shallow polymorphic copy of this instance.
     * @return The cloned value.
     */
    D2Ptr ice_clone() const { return ::std::static_pointer_cast<D2>(_iceCloneImpl()); }

    ::std::string sd2;
    ::Test::BPtr pd2;

protected:
    D2(const D2&) = default;

    ::Ice::ValuePtr _iceCloneImpl() const override;
    void _iceWriteImpl(::Ice::OutputStream*) const override;

    void _iceReadImpl(::Ice::InputStream*) override;
};

class D4 : public B
{
public:
    /**
     * Default constructor.
     */
    D4() noexcept = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    D4(::std::string sb, ::Test::BPtr pb, ::Test::BPtr p1, ::Test::BPtr p2) noexcept :
        B(::std::move(sb), ::std::move(pb)),
        p1(::std::move(p1)),
        p2(::std::move(p2))
    {
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const char* ice_staticId() noexcept;

    const char* ice_id() const noexcept override;

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::Test::BPtr&, const ::Test::BPtr&, const ::Test::BPtr&> ice_tuple() const
    {
        return std::tie(sb, pb, p1, p2);
    }

    /**
     * Creates a shallow polymorphic copy of this instance.
     * @return The cloned value.
     */
    D4Ptr ice_clone() const { return ::std::static_pointer_cast<D4>(_iceCloneImpl()); }

    ::Test::BPtr p1;
    ::Test::BPtr p2;

protected:
    D4(const D4&) = default;

    ::Ice::ValuePtr _iceCloneImpl() const override;
    void _iceWriteImpl(::Ice::OutputStream*) const override;

    void _iceReadImpl(::Ice::InputStream*) override;
};

class UnknownDerivedException : public BaseException
{
public:
    /**
     * Default constructor.
     */
    UnknownDerivedException() noexcept = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    UnknownDerivedException(::std::string sbe, BPtr pb, ::std::string sude, D2Ptr pd2) noexcept :
        BaseException(::std::move(sbe), ::std::move(pb)),
        sude(::std::move(sude)),
        pd2(::std::move(pd2))
    {
    }

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::Test::BPtr&, const ::std::string&, const ::Test::D2Ptr&> ice_tuple() const
    {
        return std::tie(sbe, pb, sude, pd2);
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    static const char* ice_staticId() noexcept;

    const char* ice_id() const noexcept override;

    void ice_throw() const override;

    ::std::string sude;
    ::Test::D2Ptr pd2;

protected:
    void _writeImpl(::Ice::OutputStream*) const override;

    void _readImpl(::Ice::InputStream*) override;
};

class MyClass : public ::Ice::Value
{
public:
    /**
     * Default constructor.
     */
    MyClass() noexcept = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit MyClass(::std::int32_t i) noexcept :
        i(i)
    {
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const char* ice_staticId() noexcept;

    const char* ice_id() const noexcept override;

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::int32_t&> ice_tuple() const
    {
        return std::tie(i);
    }

    /**
     * Creates a shallow polymorphic copy of this instance.
     * @return The cloned value.
     */
    MyClassPtr ice_clone() const { return ::std::static_pointer_cast<MyClass>(_iceCloneImpl()); }

    ::std::int32_t i;

protected:
    MyClass(const MyClass&) = default;

    ::Ice::ValuePtr _iceCloneImpl() const override;
    void _iceWriteImpl(::Ice::OutputStream*) const override;

    void _iceReadImpl(::Ice::InputStream*) override;
};

class PSUnknown : public Preserved
{
public:
    /**
     * Default constructor.
     */
    PSUnknown() noexcept = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    PSUnknown(::std::int32_t pi, ::std::string ps, ::std::string psu, ::Test::PNodePtr graph, ::Test::MyClassPtr cl) noexcept :
        Preserved(pi, ::std::move(ps)),
        psu(::std::move(psu)),
        graph(::std::move(graph)),
        cl(::std::move(cl))
    {
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const char* ice_staticId() noexcept;

    const char* ice_id() const noexcept override;

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::int32_t&, const ::std::string&, const ::std::string&, const ::Test::PNodePtr&, const ::Test::MyClassPtr&> ice_tuple() const
    {
        return std::tie(pi, ps, psu, graph, cl);
    }

    /**
     * Creates a shallow polymorphic copy of this instance.
     * @return The cloned value.
     */
    PSUnknownPtr ice_clone() const { return ::std::static_pointer_cast<PSUnknown>(_iceCloneImpl()); }

    ::std::string psu;
    ::Test::PNodePtr graph;
    ::Test::MyClassPtr cl;

protected:
    PSUnknown(const PSUnknown&) = default;

    ::Ice::ValuePtr _iceCloneImpl() const override;
    void _iceWriteImpl(::Ice::OutputStream*) const override;

    void _iceReadImpl(::Ice::InputStream*) override;
};

class PSUnknown2 : public Preserved
{
public:
    /**
     * Default constructor.
     */
    PSUnknown2() noexcept = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    PSUnknown2(::std::int32_t pi, ::std::string ps, ::Test::PBasePtr pb) noexcept :
        Preserved(pi, ::std::move(ps)),
        pb(::std::move(pb))
    {
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const char* ice_staticId() noexcept;

    const char* ice_id() const noexcept override;

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::int32_t&, const ::std::string&, const ::Test::PBasePtr&> ice_tuple() const
    {
        return std::tie(pi, ps, pb);
    }

    /**
     * Creates a shallow polymorphic copy of this instance.
     * @return The cloned value.
     */
    PSUnknown2Ptr ice_clone() const { return ::std::static_pointer_cast<PSUnknown2>(_iceCloneImpl()); }

    ::Test::PBasePtr pb;

protected:
    PSUnknown2(const PSUnknown2&) = default;

    ::Ice::ValuePtr _iceCloneImpl() const override;
    void _iceWriteImpl(::Ice::OutputStream*) const override;

    void _iceReadImpl(::Ice::InputStream*) override;
};

class PSUnknownException : public PreservedException
{
public:
    /**
     * Default constructor.
     */
    PSUnknownException() noexcept = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    PSUnknownException(PSUnknown2Ptr p) noexcept :
        PreservedException(),
        p(::std::move(p))
    {
    }

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::Test::PSUnknown2Ptr&> ice_tuple() const
    {
        return std::tie(p);
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    static const char* ice_staticId() noexcept;

    const char* ice_id() const noexcept override;

    void ice_throw() const override;

    /// \cond STREAM
    bool _usesClasses() const override;
    /// \endcond

    ::Test::PSUnknown2Ptr p;

protected:
    void _writeImpl(::Ice::OutputStream*) const override;

    void _readImpl(::Ice::InputStream*) override;
};

class Hidden : public ::Ice::Value
{
public:
    /**
     * Default constructor.
     */
    Hidden() noexcept = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit Hidden(::Test::ForwardPtr f) noexcept :
        f(::std::move(f))
    {
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const char* ice_staticId() noexcept;

    const char* ice_id() const noexcept override;

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::Test::ForwardPtr&> ice_tuple() const
    {
        return std::tie(f);
    }

    /**
     * Creates a shallow polymorphic copy of this instance.
     * @return The cloned value.
     */
    HiddenPtr ice_clone() const { return ::std::static_pointer_cast<Hidden>(_iceCloneImpl()); }

    ::Test::ForwardPtr f;

protected:
    Hidden(const Hidden&) = default;

    ::Ice::ValuePtr _iceCloneImpl() const override;
    void _iceWriteImpl(::Ice::OutputStream*) const override;

    void _iceReadImpl(::Ice::InputStream*) override;
};

class Forward : public ::Ice::Value
{
public:
    /**
     * Default constructor.
     */
    Forward() noexcept = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit Forward(::Test::HiddenPtr h) noexcept :
        h(::std::move(h))
    {
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const char* ice_staticId() noexcept;

    const char* ice_id() const noexcept override;

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::Test::HiddenPtr&> ice_tuple() const
    {
        return std::tie(h);
    }

    /**
     * Creates a shallow polymorphic copy of this instance.
     * @return The cloned value.
     */
    ForwardPtr ice_clone() const { return ::std::static_pointer_cast<Forward>(_iceCloneImpl()); }

    ::Test::HiddenPtr h;

protected:
    Forward(const Forward&) = default;

    ::Ice::ValuePtr _iceCloneImpl() const override;
    void _iceWriteImpl(::Ice::OutputStream*) const override;

    void _iceReadImpl(::Ice::InputStream*) override;
};

using Ice::operator<;
using Ice::operator<=;
using Ice::operator>;
using Ice::operator>=;
using Ice::operator==;
using Ice::operator!=;

}

namespace Test
{

class TestIntf : public virtual ::Ice::Object
{
public:

    using ProxyType = TestIntfPrx;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const char* ice_staticId() noexcept;

    virtual void SBaseAsObjectAsync(::std::function<void(const ::Ice::ValuePtr& returnValue)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_SBaseAsObject(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    virtual void SBaseAsSBaseAsync(::std::function<void(const SBasePtr& returnValue)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_SBaseAsSBase(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    virtual void SBSKnownDerivedAsSBaseAsync(::std::function<void(const SBasePtr& returnValue)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_SBSKnownDerivedAsSBase(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    virtual void SBSKnownDerivedAsSBSKnownDerivedAsync(::std::function<void(const SBSKnownDerivedPtr& returnValue)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_SBSKnownDerivedAsSBSKnownDerived(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    virtual void SBSUnknownDerivedAsSBaseAsync(::std::function<void(const SBasePtr& returnValue)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_SBSUnknownDerivedAsSBase(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    virtual void SBSUnknownDerivedAsSBaseCompactAsync(::std::function<void(const SBasePtr& returnValue)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_SBSUnknownDerivedAsSBaseCompact(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    virtual void SUnknownAsObjectAsync(::std::function<void(const ::Ice::ValuePtr& returnValue)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_SUnknownAsObject(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    virtual void checkSUnknownAsync(::Ice::ValuePtr o, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_checkSUnknown(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    virtual void oneElementCycleAsync(::std::function<void(const BPtr& returnValue)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_oneElementCycle(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    virtual void twoElementCycleAsync(::std::function<void(const BPtr& returnValue)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_twoElementCycle(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    virtual void D1AsBAsync(::std::function<void(const BPtr& returnValue)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_D1AsB(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    virtual void D1AsD1Async(::std::function<void(const D1Ptr& returnValue)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_D1AsD1(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    virtual void D2AsBAsync(::std::function<void(const BPtr& returnValue)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_D2AsB(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    virtual void paramTest1Async(::std::function<void(const BPtr& p1, const BPtr& p2)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_paramTest1(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    virtual void paramTest2Async(::std::function<void(const BPtr& p2, const BPtr& p1)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_paramTest2(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    virtual void paramTest3Async(::std::function<void(const BPtr& returnValue, const BPtr& p1, const BPtr& p2)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_paramTest3(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    virtual void paramTest4Async(::std::function<void(const BPtr& returnValue, const BPtr& p)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_paramTest4(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    virtual void returnTest1Async(::std::function<void(const BPtr& returnValue, const BPtr& p1, const BPtr& p2)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_returnTest1(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    virtual void returnTest2Async(::std::function<void(const BPtr& returnValue, const BPtr& p2, const BPtr& p1)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_returnTest2(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    virtual void returnTest3Async(BPtr p1, BPtr p2, ::std::function<void(const BPtr& returnValue)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_returnTest3(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    virtual void sequenceTestAsync(SS1Ptr p1, SS2Ptr p2, ::std::function<void(const SS3& returnValue)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_sequenceTest(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    virtual void dictionaryTestAsync(BDict bin, ::std::function<void(const BDict& returnValue, const BDict& bout)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_dictionaryTest(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    virtual void exchangePBaseAsync(PBasePtr pb, ::std::function<void(const PBasePtr& returnValue)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_exchangePBase(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    virtual void PBSUnknownAsPreservedAsync(::std::function<void(const PreservedPtr& returnValue)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_PBSUnknownAsPreserved(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    virtual void checkPBSUnknownAsync(PreservedPtr p, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_checkPBSUnknown(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    virtual void PBSUnknownAsPreservedWithGraphAsync(::std::function<void(const PreservedPtr& returnValue)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_PBSUnknownAsPreservedWithGraph(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    virtual void checkPBSUnknownWithGraphAsync(PreservedPtr p, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_checkPBSUnknownWithGraph(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    virtual void PBSUnknown2AsPreservedWithGraphAsync(::std::function<void(const PreservedPtr& returnValue)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_PBSUnknown2AsPreservedWithGraph(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    virtual void checkPBSUnknown2WithGraphAsync(PreservedPtr p, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_checkPBSUnknown2WithGraph(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    virtual void exchangePNodeAsync(PNodePtr pn, ::std::function<void(const PNodePtr& returnValue)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_exchangePNode(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    virtual void throwBaseAsBaseAsync(::std::function<void()> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_throwBaseAsBase(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    virtual void throwDerivedAsBaseAsync(::std::function<void()> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_throwDerivedAsBase(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    virtual void throwDerivedAsDerivedAsync(::std::function<void()> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_throwDerivedAsDerived(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    virtual void throwUnknownDerivedAsBaseAsync(::std::function<void()> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_throwUnknownDerivedAsBase(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    virtual void throwPreservedExceptionAsync(::std::function<void()> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_throwPreservedException(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    /**
     * Use of forward-declared class to verify that code is generated correctly.
     * @param response The response callback.
     * @param exception The exception callback.
     * @param current The Current object for the invocation.
     */
    virtual void useForwardAsync(::std::function<void(const ForwardPtr& f)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_useForward(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    virtual void shutdownAsync(::std::function<void()> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    void _iceD_shutdown(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>);
    /// \endcond

    /// \cond INTERNAL
    void dispatch(::Ice::IncomingRequest&, ::std::function<void(::Ice::OutgoingResponse)>) override;
    /// \endcond
};

using TestIntfPtr = ::std::shared_ptr<TestIntf>;

}

/// \cond STREAM
namespace Ice
{

template<>
struct StreamReader<::Test::SBase>
{
    static void read(InputStream* istr, ::Test::SBase& v)
    {
        istr->readAll(v.sb);
    }
};

template<>
struct StreamWriter<::Test::SBSKnownDerived>
{
    static void write(OutputStream* ostr, const ::Test::SBSKnownDerived& v)
    {
        ostr->writeAll(v.sbskd);
    }
};

template<>
struct StreamReader<::Test::SBSKnownDerived>
{
    static void read(InputStream* istr, ::Test::SBSKnownDerived& v)
    {
        istr->readAll(v.sbskd);
    }
};

template<>
struct StreamReader<::Test::B>
{
    static void read(InputStream* istr, ::Test::B& v)
    {
        istr->readAll(v.sb, v.pb);
    }
};

template<>
struct StreamWriter<::Test::D1>
{
    static void write(OutputStream* ostr, const ::Test::D1& v)
    {
        ostr->writeAll(v.sd1, v.pd1);
    }
};

template<>
struct StreamReader<::Test::D1>
{
    static void read(InputStream* istr, ::Test::D1& v)
    {
        istr->readAll(v.sd1, v.pd1);
    }
};

template<>
struct StreamReader<::Test::SS1>
{
    static void read(InputStream* istr, ::Test::SS1& v)
    {
        istr->readAll(v.s);
    }
};

template<>
struct StreamReader<::Test::SS2>
{
    static void read(InputStream* istr, ::Test::SS2& v)
    {
        istr->readAll(v.s);
    }
};

template<>
struct StreamableTraits<::Test::SS3>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 2;
    static const bool fixedLength = false;
};

template<>
struct StreamReader<::Test::SS3>
{
    static void read(InputStream* istr, ::Test::SS3& v)
    {
        istr->readAll(v.c1, v.c2);
    }
};

template<>
struct StreamReader<::Test::BaseException>
{
    static void read(InputStream* istr, ::Test::BaseException& v)
    {
        istr->readAll(v.sbe, v.pb);
    }
};

template<>
struct StreamWriter<::Test::DerivedException>
{
    static void write(OutputStream* ostr, const ::Test::DerivedException& v)
    {
        ostr->writeAll(v.sde, v.pd1);
    }
};

template<>
struct StreamReader<::Test::DerivedException>
{
    static void read(InputStream* istr, ::Test::DerivedException& v)
    {
        istr->readAll(v.sde, v.pd1);
    }
};

template<>
struct StreamReader<::Test::PBase>
{
    static void read(InputStream* istr, ::Test::PBase& v)
    {
        istr->readAll(v.pi);
    }
};

template<>
struct StreamWriter<::Test::Preserved>
{
    static void write(OutputStream* ostr, const ::Test::Preserved& v)
    {
        ostr->writeAll(v.ps);
    }
};

template<>
struct StreamReader<::Test::Preserved>
{
    static void read(InputStream* istr, ::Test::Preserved& v)
    {
        istr->readAll(v.ps);
    }
};

template<>
struct StreamWriter<::Test::PDerived>
{
    static void write(OutputStream* ostr, const ::Test::PDerived& v)
    {
        ostr->writeAll(v.pb);
    }
};

template<>
struct StreamReader<::Test::PDerived>
{
    static void read(InputStream* istr, ::Test::PDerived& v)
    {
        istr->readAll(v.pb);
    }
};

template<>
struct StreamReader<::Test::PNode>
{
    static void read(InputStream* istr, ::Test::PNode& v)
    {
        istr->readAll(v.next);
    }
};

template<>
struct StreamWriter<::Test::SBSUnknownDerived>
{
    static void write(OutputStream* ostr, const ::Test::SBSUnknownDerived& v)
    {
        ostr->writeAll(v.sbsud);
    }
};

template<>
struct StreamReader<::Test::SBSUnknownDerived>
{
    static void read(InputStream* istr, ::Test::SBSUnknownDerived& v)
    {
        istr->readAll(v.sbsud);
    }
};

template<>
struct StreamReader<::Test::SUnknown>
{
    static void read(InputStream* istr, ::Test::SUnknown& v)
    {
        istr->readAll(v.su, v.cycle);
    }
};

template<>
struct StreamWriter<::Test::D2>
{
    static void write(OutputStream* ostr, const ::Test::D2& v)
    {
        ostr->writeAll(v.sd2, v.pd2);
    }
};

template<>
struct StreamReader<::Test::D2>
{
    static void read(InputStream* istr, ::Test::D2& v)
    {
        istr->readAll(v.sd2, v.pd2);
    }
};

template<>
struct StreamWriter<::Test::D4>
{
    static void write(OutputStream* ostr, const ::Test::D4& v)
    {
        ostr->writeAll(v.p1, v.p2);
    }
};

template<>
struct StreamReader<::Test::D4>
{
    static void read(InputStream* istr, ::Test::D4& v)
    {
        istr->readAll(v.p1, v.p2);
    }
};

template<>
struct StreamWriter<::Test::UnknownDerivedException>
{
    static void write(OutputStream* ostr, const ::Test::UnknownDerivedException& v)
    {
        ostr->writeAll(v.sude, v.pd2);
    }
};

template<>
struct StreamReader<::Test::UnknownDerivedException>
{
    static void read(InputStream* istr, ::Test::UnknownDerivedException& v)
    {
        istr->readAll(v.sude, v.pd2);
    }
};

template<>
struct StreamReader<::Test::MyClass>
{
    static void read(InputStream* istr, ::Test::MyClass& v)
    {
        istr->readAll(v.i);
    }
};

template<>
struct StreamWriter<::Test::PSUnknown>
{
    static void write(OutputStream* ostr, const ::Test::PSUnknown& v)
    {
        ostr->writeAll(v.psu, v.graph, v.cl);
    }
};

template<>
struct StreamReader<::Test::PSUnknown>
{
    static void read(InputStream* istr, ::Test::PSUnknown& v)
    {
        istr->readAll(v.psu, v.graph, v.cl);
    }
};

template<>
struct StreamWriter<::Test::PSUnknown2>
{
    static void write(OutputStream* ostr, const ::Test::PSUnknown2& v)
    {
        ostr->writeAll(v.pb);
    }
};

template<>
struct StreamReader<::Test::PSUnknown2>
{
    static void read(InputStream* istr, ::Test::PSUnknown2& v)
    {
        istr->readAll(v.pb);
    }
};

template<>
struct StreamReader<::Test::PSUnknownException>
{
    static void read(InputStream* istr, ::Test::PSUnknownException& v)
    {
        istr->readAll(v.p);
    }
};

template<>
struct StreamReader<::Test::Hidden>
{
    static void read(InputStream* istr, ::Test::Hidden& v)
    {
        istr->readAll(v.f);
    }
};

template<>
struct StreamReader<::Test::Forward>
{
    static void read(InputStream* istr, ::Test::Forward& v)
    {
        istr->readAll(v.h);
    }
};

}
/// \endcond

#include <Ice/PopDisableWarnings.h>
#endif
