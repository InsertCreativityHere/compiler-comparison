//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.8.0-alpha.0
//
// <auto-generated>
//
// Generated from file `ServerPrivateAMD.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __ServerPrivateAMD_h__
#define __ServerPrivateAMD_h__

#include <IceUtil/PushDisableWarnings.h>
#include <Ice/Ice.h>
#include <IceUtil/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION  != 30850
#       error Ice version mismatch: an exact match is required for beta generated code
#   endif
#endif

namespace Test
{

class SBase;
class SBSKnownDerived;
class B;
class D1;
class SS1;
class SS2;
class Forward;
class PBase;
class Preserved;
class PDerived;
class PNode;
class TestIntf;
class TestIntfPrx;
class SBSUnknownDerived;
class SUnknown;
class D2;
class D4;
class MyClass;
class PSUnknown;
class PSUnknown2;
class Hidden;

}

namespace Test
{

using BSeq = ::std::vector<::std::shared_ptr<B>>;

struct SS3
{
    ::std::shared_ptr<::Test::SS1> c1;
    ::std::shared_ptr<::Test::SS2> c2;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::shared_ptr<::Test::SS1>&, const ::std::shared_ptr<::Test::SS2>&> ice_tuple() const
    {
        return std::tie(c1, c2);
    }
};

using BDict = ::std::map<int, ::std::shared_ptr<B>>;

class BaseException : public ::Ice::UserExceptionHelper<BaseException, ::Ice::UserException>
{
public:

    virtual ~BaseException();

    BaseException(const BaseException&) = default;

    BaseException() = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    BaseException(const ::std::string& sbe, const ::std::shared_ptr<B>& pb) :
        sbe(sbe),
        pb(pb)
    {
    }

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::std::shared_ptr<::Test::B>&> ice_tuple() const
    {
        return std::tie(sbe, pb);
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /// \cond STREAM
    virtual bool _usesClasses() const override;
    /// \endcond

    ::std::string sbe;
    ::std::shared_ptr<::Test::B> pb;
};

/// \cond INTERNAL
static BaseException _iceS_BaseException_init;
/// \endcond

class DerivedException : public ::Ice::UserExceptionHelper<DerivedException, BaseException>
{
public:

    virtual ~DerivedException();

    DerivedException(const DerivedException&) = default;

    DerivedException() = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    DerivedException(const ::std::string& sbe, const ::std::shared_ptr<B>& pb, const ::std::string& sde, const ::std::shared_ptr<D1>& pd1) :
        ::Ice::UserExceptionHelper<DerivedException, BaseException>(sbe, pb),
        sde(sde),
        pd1(pd1)
    {
    }

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::std::shared_ptr<::Test::B>&, const ::std::string&, const ::std::shared_ptr<::Test::D1>&> ice_tuple() const
    {
        return std::tie(sbe, pb, sde, pd1);
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::std::string sde;
    ::std::shared_ptr<::Test::D1> pd1;
};

using PBaseSeq = ::std::vector<::std::shared_ptr<PBase>>;

class PreservedException : public ::Ice::UserExceptionHelper<PreservedException, ::Ice::UserException>
{
public:

    virtual ~PreservedException();

    PreservedException(const PreservedException&) = default;

    PreservedException() = default;

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<> ice_tuple() const
    {
        return std::tie();
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /**
     * Obtains the SlicedData object created when an unknown exception type was marshaled
     * in the sliced format and the Ice run time sliced it to a known type.
     * @return The SlicedData object, or nil if the exception was not sliced or was not
     * marshaled in the sliced format.
     */
    virtual ::std::shared_ptr<::Ice::SlicedData> ice_getSlicedData() const override;

    /// \cond STREAM
    virtual void _write(::Ice::OutputStream*) const override;
    virtual void _read(::Ice::InputStream*) override;

    ::std::shared_ptr<::Ice::SlicedData> _slicedData;
    /// \endcond
};

class UnknownDerivedException : public ::Ice::UserExceptionHelper<UnknownDerivedException, BaseException>
{
public:

    virtual ~UnknownDerivedException();

    UnknownDerivedException(const UnknownDerivedException&) = default;

    UnknownDerivedException() = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    UnknownDerivedException(const ::std::string& sbe, const ::std::shared_ptr<B>& pb, const ::std::string& sude, const ::std::shared_ptr<D2>& pd2) :
        ::Ice::UserExceptionHelper<UnknownDerivedException, BaseException>(sbe, pb),
        sude(sude),
        pd2(pd2)
    {
    }

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::std::shared_ptr<::Test::B>&, const ::std::string&, const ::std::shared_ptr<::Test::D2>&> ice_tuple() const
    {
        return std::tie(sbe, pb, sude, pd2);
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::std::string sude;
    ::std::shared_ptr<::Test::D2> pd2;
};

class PSUnknownException : public ::Ice::UserExceptionHelper<PSUnknownException, PreservedException>
{
public:

    virtual ~PSUnknownException();

    PSUnknownException(const PSUnknownException&) = default;

    PSUnknownException() = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    PSUnknownException(const ::std::shared_ptr<PSUnknown2>& p) :
        ::Ice::UserExceptionHelper<PSUnknownException, PreservedException>(),
        p(p)
    {
    }

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::shared_ptr<::Test::PSUnknown2>&> ice_tuple() const
    {
        return std::tie(p);
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /// \cond STREAM
    virtual bool _usesClasses() const override;
    /// \endcond

    ::std::shared_ptr<::Test::PSUnknown2> p;
};

using Ice::operator<;
using Ice::operator<=;
using Ice::operator>;
using Ice::operator>=;
using Ice::operator==;
using Ice::operator!=;

}

namespace Test
{

class TestIntf : public virtual ::Ice::Object
{
public:

    using ProxyType = TestIntfPrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void SBaseAsObjectAsync(::std::function<void(const ::std::shared_ptr<::Ice::Value>& returnValue)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_SBaseAsObject(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void SBaseAsSBaseAsync(::std::function<void(const ::std::shared_ptr<SBase>& returnValue)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_SBaseAsSBase(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void SBSKnownDerivedAsSBaseAsync(::std::function<void(const ::std::shared_ptr<SBase>& returnValue)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_SBSKnownDerivedAsSBase(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void SBSKnownDerivedAsSBSKnownDerivedAsync(::std::function<void(const ::std::shared_ptr<SBSKnownDerived>& returnValue)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_SBSKnownDerivedAsSBSKnownDerived(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void SBSUnknownDerivedAsSBaseAsync(::std::function<void(const ::std::shared_ptr<SBase>& returnValue)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_SBSUnknownDerivedAsSBase(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void SBSUnknownDerivedAsSBaseCompactAsync(::std::function<void(const ::std::shared_ptr<SBase>& returnValue)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_SBSUnknownDerivedAsSBaseCompact(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void SUnknownAsObjectAsync(::std::function<void(const ::std::shared_ptr<::Ice::Value>& returnValue)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_SUnknownAsObject(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void checkSUnknownAsync(::std::shared_ptr<::Ice::Value> o, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_checkSUnknown(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void oneElementCycleAsync(::std::function<void(const ::std::shared_ptr<B>& returnValue)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_oneElementCycle(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void twoElementCycleAsync(::std::function<void(const ::std::shared_ptr<B>& returnValue)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_twoElementCycle(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void D1AsBAsync(::std::function<void(const ::std::shared_ptr<B>& returnValue)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_D1AsB(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void D1AsD1Async(::std::function<void(const ::std::shared_ptr<D1>& returnValue)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_D1AsD1(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void D2AsBAsync(::std::function<void(const ::std::shared_ptr<B>& returnValue)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_D2AsB(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to paramTest1.
     */
    struct ParamTest1Result
    {
        ::std::shared_ptr<B> p1;
        ::std::shared_ptr<B> p2;
    };

    virtual void paramTest1Async(::std::function<void(const ::std::shared_ptr<B>& p1, const ::std::shared_ptr<B>& p2)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_paramTest1(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to paramTest2.
     */
    struct ParamTest2Result
    {
        ::std::shared_ptr<B> p2;
        ::std::shared_ptr<B> p1;
    };

    virtual void paramTest2Async(::std::function<void(const ::std::shared_ptr<B>& p2, const ::std::shared_ptr<B>& p1)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_paramTest2(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to paramTest3.
     */
    struct ParamTest3Result
    {
        ::std::shared_ptr<B> returnValue;
        ::std::shared_ptr<B> p1;
        ::std::shared_ptr<B> p2;
    };

    virtual void paramTest3Async(::std::function<void(const ::std::shared_ptr<B>& returnValue, const ::std::shared_ptr<B>& p1, const ::std::shared_ptr<B>& p2)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_paramTest3(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to paramTest4.
     */
    struct ParamTest4Result
    {
        ::std::shared_ptr<B> returnValue;
        ::std::shared_ptr<B> p;
    };

    virtual void paramTest4Async(::std::function<void(const ::std::shared_ptr<B>& returnValue, const ::std::shared_ptr<B>& p)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_paramTest4(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to returnTest1.
     */
    struct ReturnTest1Result
    {
        ::std::shared_ptr<B> returnValue;
        ::std::shared_ptr<B> p1;
        ::std::shared_ptr<B> p2;
    };

    virtual void returnTest1Async(::std::function<void(const ::std::shared_ptr<B>& returnValue, const ::std::shared_ptr<B>& p1, const ::std::shared_ptr<B>& p2)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_returnTest1(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to returnTest2.
     */
    struct ReturnTest2Result
    {
        ::std::shared_ptr<B> returnValue;
        ::std::shared_ptr<B> p2;
        ::std::shared_ptr<B> p1;
    };

    virtual void returnTest2Async(::std::function<void(const ::std::shared_ptr<B>& returnValue, const ::std::shared_ptr<B>& p2, const ::std::shared_ptr<B>& p1)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_returnTest2(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void returnTest3Async(::std::shared_ptr<B> p1, ::std::shared_ptr<B> p2, ::std::function<void(const ::std::shared_ptr<B>& returnValue)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_returnTest3(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void sequenceTestAsync(::std::shared_ptr<SS1> p1, ::std::shared_ptr<SS2> p2, ::std::function<void(const SS3& returnValue)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_sequenceTest(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to dictionaryTest.
     */
    struct DictionaryTestResult
    {
        BDict returnValue;
        BDict bout;
    };

    virtual void dictionaryTestAsync(BDict bin, ::std::function<void(const BDict& returnValue, const BDict& bout)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_dictionaryTest(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void exchangePBaseAsync(::std::shared_ptr<PBase> pb, ::std::function<void(const ::std::shared_ptr<PBase>& returnValue)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_exchangePBase(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void PBSUnknownAsPreservedAsync(::std::function<void(const ::std::shared_ptr<Preserved>& returnValue)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_PBSUnknownAsPreserved(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void checkPBSUnknownAsync(::std::shared_ptr<Preserved> p, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_checkPBSUnknown(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void PBSUnknownAsPreservedWithGraphAsync(::std::function<void(const ::std::shared_ptr<Preserved>& returnValue)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_PBSUnknownAsPreservedWithGraph(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void checkPBSUnknownWithGraphAsync(::std::shared_ptr<Preserved> p, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_checkPBSUnknownWithGraph(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void PBSUnknown2AsPreservedWithGraphAsync(::std::function<void(const ::std::shared_ptr<Preserved>& returnValue)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_PBSUnknown2AsPreservedWithGraph(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void checkPBSUnknown2WithGraphAsync(::std::shared_ptr<Preserved> p, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_checkPBSUnknown2WithGraph(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void exchangePNodeAsync(::std::shared_ptr<PNode> pn, ::std::function<void(const ::std::shared_ptr<PNode>& returnValue)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_exchangePNode(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void throwBaseAsBaseAsync(::std::function<void()> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_throwBaseAsBase(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void throwDerivedAsBaseAsync(::std::function<void()> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_throwDerivedAsBase(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void throwDerivedAsDerivedAsync(::std::function<void()> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_throwDerivedAsDerived(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void throwUnknownDerivedAsBaseAsync(::std::function<void()> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_throwUnknownDerivedAsBase(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void throwPreservedExceptionAsync(::std::function<void()> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_throwPreservedException(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Use of forward-declared class to verify that code is generated correctly.
     * @param response The response callback.
     * @param exception The exception callback.
     * @param current The Current object for the invocation.
     */
    virtual void useForwardAsync(::std::function<void(const ::std::shared_ptr<Forward>& f)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_useForward(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void shutdownAsync(::std::function<void()> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_shutdown(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

}

namespace Test
{

class SBase : public ::Ice::ValueHelper<SBase, ::Ice::Value>
{
public:

    virtual ~SBase();

    SBase() = default;

    SBase(const SBase&) = default;
    SBase(SBase&&) = default;
    SBase& operator=(const SBase&) = default;
    SBase& operator=(SBase&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit SBase(const ::std::string& sb) :
        sb(sb)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&> ice_tuple() const
    {
        return std::tie(sb);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::std::string sb;
};

/// \cond INTERNAL
static SBase _iceS_SBase_init;
/// \endcond

class SBSKnownDerived : public ::Ice::ValueHelper<SBSKnownDerived, SBase>
{
public:

    virtual ~SBSKnownDerived();

    SBSKnownDerived() = default;

    SBSKnownDerived(const SBSKnownDerived&) = default;
    SBSKnownDerived(SBSKnownDerived&&) = default;
    SBSKnownDerived& operator=(const SBSKnownDerived&) = default;
    SBSKnownDerived& operator=(SBSKnownDerived&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    SBSKnownDerived(const ::std::string& sb, const ::std::string& sbskd) :
        Ice::ValueHelper<SBSKnownDerived, SBase>(sb),
        sbskd(sbskd)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::std::string&> ice_tuple() const
    {
        return std::tie(sb, sbskd);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::std::string sbskd;
};

class B : public ::Ice::ValueHelper<B, ::Ice::Value>
{
public:

    virtual ~B();

    B() = default;

    B(const B&) = default;
    B(B&&) = default;
    B& operator=(const B&) = default;
    B& operator=(B&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    B(const ::std::string& sb, const ::std::shared_ptr<::Test::B>& pb) :
        sb(sb),
        pb(pb)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::std::shared_ptr<::Test::B>&> ice_tuple() const
    {
        return std::tie(sb, pb);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::std::string sb;
    ::std::shared_ptr<::Test::B> pb;
};

class D1 : public ::Ice::ValueHelper<D1, B>
{
public:

    virtual ~D1();

    D1() = default;

    D1(const D1&) = default;
    D1(D1&&) = default;
    D1& operator=(const D1&) = default;
    D1& operator=(D1&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    D1(const ::std::string& sb, const ::std::shared_ptr<::Test::B>& pb, const ::std::string& sd1, const ::std::shared_ptr<::Test::B>& pd1) :
        Ice::ValueHelper<D1, B>(sb, pb),
        sd1(sd1),
        pd1(pd1)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::std::shared_ptr<::Test::B>&, const ::std::string&, const ::std::shared_ptr<::Test::B>&> ice_tuple() const
    {
        return std::tie(sb, pb, sd1, pd1);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::std::string sd1;
    ::std::shared_ptr<::Test::B> pd1;
};

class SS1 : public ::Ice::ValueHelper<SS1, ::Ice::Value>
{
public:

    virtual ~SS1();

    SS1() = default;

    SS1(const SS1&) = default;
    SS1(SS1&&) = default;
    SS1& operator=(const SS1&) = default;
    SS1& operator=(SS1&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit SS1(const ::Test::BSeq& s) :
        s(s)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::Test::BSeq&> ice_tuple() const
    {
        return std::tie(s);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::Test::BSeq s;
};

class SS2 : public ::Ice::ValueHelper<SS2, ::Ice::Value>
{
public:

    virtual ~SS2();

    SS2() = default;

    SS2(const SS2&) = default;
    SS2(SS2&&) = default;
    SS2& operator=(const SS2&) = default;
    SS2& operator=(SS2&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit SS2(const ::Test::BSeq& s) :
        s(s)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::Test::BSeq&> ice_tuple() const
    {
        return std::tie(s);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::Test::BSeq s;
};

class PBase : public ::Ice::ValueHelper<PBase, ::Ice::Value>
{
public:

    virtual ~PBase();

    PBase() = default;

    PBase(const PBase&) = default;
    PBase(PBase&&) = default;
    PBase& operator=(const PBase&) = default;
    PBase& operator=(PBase&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit PBase(int pi) :
        pi(pi)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const int&> ice_tuple() const
    {
        return std::tie(pi);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    int pi;
};

class Preserved : public ::Ice::ValueHelper<Preserved, PBase>
{
public:

    virtual ~Preserved();

    Preserved() = default;

    Preserved(const Preserved&) = default;
    Preserved(Preserved&&) = default;
    Preserved& operator=(const Preserved&) = default;
    Preserved& operator=(Preserved&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    Preserved(int pi, const ::std::string& ps) :
        Ice::ValueHelper<Preserved, PBase>(pi),
        ps(ps)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const int&, const ::std::string&> ice_tuple() const
    {
        return std::tie(pi, ps);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /**
     * Obtains the SlicedData object created when an unknown value type was marshaled
     * in the sliced format and the Ice run time sliced it to a known type.
     * @return The SlicedData object, or nil if the value was not sliced or was not
     * marshaled in the sliced format.
     */
    virtual ::std::shared_ptr<::Ice::SlicedData> ice_getSlicedData() const override;

    /// \cond STREAM
    virtual void _iceWrite(::Ice::OutputStream*) const override;
    virtual void _iceRead(::Ice::InputStream*) override;
    /// \endcond

    ::std::string ps;

protected:

    /// \cond STREAM
    ::std::shared_ptr<::Ice::SlicedData> _iceSlicedData;
    /// \endcond
};

class PDerived : public ::Ice::ValueHelper<PDerived, Preserved>
{
public:

    virtual ~PDerived();

    PDerived() = default;

    PDerived(const PDerived&) = default;
    PDerived(PDerived&&) = default;
    PDerived& operator=(const PDerived&) = default;
    PDerived& operator=(PDerived&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    PDerived(int pi, const ::std::string& ps, const ::std::shared_ptr<::Test::PBase>& pb) :
        Ice::ValueHelper<PDerived, Preserved>(pi, ps),
        pb(pb)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const int&, const ::std::string&, const ::std::shared_ptr<::Test::PBase>&> ice_tuple() const
    {
        return std::tie(pi, ps, pb);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::std::shared_ptr<::Test::PBase> pb;
};

class PNode : public ::Ice::ValueHelper<PNode, ::Ice::Value>
{
public:

    virtual ~PNode();

    PNode() = default;

    PNode(const PNode&) = default;
    PNode(PNode&&) = default;
    PNode& operator=(const PNode&) = default;
    PNode& operator=(PNode&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit PNode(const ::std::shared_ptr<::Test::PNode>& next) :
        next(next)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::shared_ptr<::Test::PNode>&> ice_tuple() const
    {
        return std::tie(next);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /**
     * Obtains the SlicedData object created when an unknown value type was marshaled
     * in the sliced format and the Ice run time sliced it to a known type.
     * @return The SlicedData object, or nil if the value was not sliced or was not
     * marshaled in the sliced format.
     */
    virtual ::std::shared_ptr<::Ice::SlicedData> ice_getSlicedData() const override;

    /// \cond STREAM
    virtual void _iceWrite(::Ice::OutputStream*) const override;
    virtual void _iceRead(::Ice::InputStream*) override;
    /// \endcond

    ::std::shared_ptr<::Test::PNode> next;

protected:

    /// \cond STREAM
    ::std::shared_ptr<::Ice::SlicedData> _iceSlicedData;
    /// \endcond
};

class SBSUnknownDerived : public ::Ice::ValueHelper<SBSUnknownDerived, SBase>
{
public:

    virtual ~SBSUnknownDerived();

    SBSUnknownDerived() = default;

    SBSUnknownDerived(const SBSUnknownDerived&) = default;
    SBSUnknownDerived(SBSUnknownDerived&&) = default;
    SBSUnknownDerived& operator=(const SBSUnknownDerived&) = default;
    SBSUnknownDerived& operator=(SBSUnknownDerived&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    SBSUnknownDerived(const ::std::string& sb, const ::std::string& sbsud) :
        Ice::ValueHelper<SBSUnknownDerived, SBase>(sb),
        sbsud(sbsud)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::std::string&> ice_tuple() const
    {
        return std::tie(sb, sbsud);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::std::string sbsud;
};

class SUnknown : public ::Ice::ValueHelper<SUnknown, ::Ice::Value>
{
public:

    virtual ~SUnknown();

    SUnknown() = default;

    SUnknown(const SUnknown&) = default;
    SUnknown(SUnknown&&) = default;
    SUnknown& operator=(const SUnknown&) = default;
    SUnknown& operator=(SUnknown&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    SUnknown(const ::std::string& su, const ::std::shared_ptr<::Test::SUnknown>& cycle) :
        su(su),
        cycle(cycle)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::std::shared_ptr<::Test::SUnknown>&> ice_tuple() const
    {
        return std::tie(su, cycle);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::std::string su;
    ::std::shared_ptr<::Test::SUnknown> cycle;
};

class D2 : public ::Ice::ValueHelper<D2, B>
{
public:

    virtual ~D2();

    D2() = default;

    D2(const D2&) = default;
    D2(D2&&) = default;
    D2& operator=(const D2&) = default;
    D2& operator=(D2&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    D2(const ::std::string& sb, const ::std::shared_ptr<::Test::B>& pb, const ::std::string& sd2, const ::std::shared_ptr<::Test::B>& pd2) :
        Ice::ValueHelper<D2, B>(sb, pb),
        sd2(sd2),
        pd2(pd2)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::std::shared_ptr<::Test::B>&, const ::std::string&, const ::std::shared_ptr<::Test::B>&> ice_tuple() const
    {
        return std::tie(sb, pb, sd2, pd2);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::std::string sd2;
    ::std::shared_ptr<::Test::B> pd2;
};

class D4 : public ::Ice::ValueHelper<D4, B>
{
public:

    virtual ~D4();

    D4() = default;

    D4(const D4&) = default;
    D4(D4&&) = default;
    D4& operator=(const D4&) = default;
    D4& operator=(D4&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    D4(const ::std::string& sb, const ::std::shared_ptr<::Test::B>& pb, const ::std::shared_ptr<::Test::B>& p1, const ::std::shared_ptr<::Test::B>& p2) :
        Ice::ValueHelper<D4, B>(sb, pb),
        p1(p1),
        p2(p2)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::std::shared_ptr<::Test::B>&, const ::std::shared_ptr<::Test::B>&, const ::std::shared_ptr<::Test::B>&> ice_tuple() const
    {
        return std::tie(sb, pb, p1, p2);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::std::shared_ptr<::Test::B> p1;
    ::std::shared_ptr<::Test::B> p2;
};

class MyClass : public ::Ice::ValueHelper<MyClass, ::Ice::Value>
{
public:

    virtual ~MyClass();

    MyClass() = default;

    MyClass(const MyClass&) = default;
    MyClass(MyClass&&) = default;
    MyClass& operator=(const MyClass&) = default;
    MyClass& operator=(MyClass&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit MyClass(int i) :
        i(i)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const int&> ice_tuple() const
    {
        return std::tie(i);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    int i;
};

class PSUnknown : public ::Ice::ValueHelper<PSUnknown, Preserved>
{
public:

    virtual ~PSUnknown();

    PSUnknown() = default;

    PSUnknown(const PSUnknown&) = default;
    PSUnknown(PSUnknown&&) = default;
    PSUnknown& operator=(const PSUnknown&) = default;
    PSUnknown& operator=(PSUnknown&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    PSUnknown(int pi, const ::std::string& ps, const ::std::string& psu, const ::std::shared_ptr<::Test::PNode>& graph, const ::std::shared_ptr<::Test::MyClass>& cl) :
        Ice::ValueHelper<PSUnknown, Preserved>(pi, ps),
        psu(psu),
        graph(graph),
        cl(cl)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const int&, const ::std::string&, const ::std::string&, const ::std::shared_ptr<::Test::PNode>&, const ::std::shared_ptr<::Test::MyClass>&> ice_tuple() const
    {
        return std::tie(pi, ps, psu, graph, cl);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::std::string psu;
    ::std::shared_ptr<::Test::PNode> graph;
    ::std::shared_ptr<::Test::MyClass> cl;
};

class PSUnknown2 : public ::Ice::ValueHelper<PSUnknown2, Preserved>
{
public:

    virtual ~PSUnknown2();

    PSUnknown2() = default;

    PSUnknown2(const PSUnknown2&) = default;
    PSUnknown2(PSUnknown2&&) = default;
    PSUnknown2& operator=(const PSUnknown2&) = default;
    PSUnknown2& operator=(PSUnknown2&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    PSUnknown2(int pi, const ::std::string& ps, const ::std::shared_ptr<::Test::PBase>& pb) :
        Ice::ValueHelper<PSUnknown2, Preserved>(pi, ps),
        pb(pb)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const int&, const ::std::string&, const ::std::shared_ptr<::Test::PBase>&> ice_tuple() const
    {
        return std::tie(pi, ps, pb);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::std::shared_ptr<::Test::PBase> pb;
};

class Hidden : public ::Ice::ValueHelper<Hidden, ::Ice::Value>
{
public:

    virtual ~Hidden();

    Hidden() = default;

    Hidden(const Hidden&) = default;
    Hidden(Hidden&&) = default;
    Hidden& operator=(const Hidden&) = default;
    Hidden& operator=(Hidden&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit Hidden(const ::std::shared_ptr<::Test::Forward>& f) :
        f(f)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::shared_ptr<::Test::Forward>&> ice_tuple() const
    {
        return std::tie(f);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::std::shared_ptr<::Test::Forward> f;
};

class Forward : public ::Ice::ValueHelper<Forward, ::Ice::Value>
{
public:

    virtual ~Forward();

    Forward() = default;

    Forward(const Forward&) = default;
    Forward(Forward&&) = default;
    Forward& operator=(const Forward&) = default;
    Forward& operator=(Forward&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit Forward(const ::std::shared_ptr<::Test::Hidden>& h) :
        h(h)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::shared_ptr<::Test::Hidden>&> ice_tuple() const
    {
        return std::tie(h);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::std::shared_ptr<::Test::Hidden> h;
};

}

namespace Test
{

class TestIntfPrx : public virtual ::Ice::Proxy<TestIntfPrx, ::Ice::ObjectPrx>
{
public:

    ::std::shared_ptr<::Ice::Value> SBaseAsObject(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Ice::Value>>(true, this, &TestIntfPrx::_iceI_SBaseAsObject, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto SBaseAsObjectAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::shared_ptr<::Ice::Value>>>().get_future())
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Ice::Value>, P>(false, this, &TestIntfPrx::_iceI_SBaseAsObject, context);
    }

    ::std::function<void()>
    SBaseAsObjectAsync(::std::function<void(::std::shared_ptr<::Ice::Value>)> response,
                       ::std::function<void(::std::exception_ptr)> ex = nullptr,
                       ::std::function<void(bool)> sent = nullptr,
                       const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<::std::shared_ptr<::Ice::Value>>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_SBaseAsObject, context);
    }

    /// \cond INTERNAL
    void _iceI_SBaseAsObject(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Ice::Value>>>&, const ::Ice::Context&);
    /// \endcond

    ::std::shared_ptr<SBase> SBaseAsSBase(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Test::SBase>>(true, this, &TestIntfPrx::_iceI_SBaseAsSBase, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto SBaseAsSBaseAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::shared_ptr<::Test::SBase>>>().get_future())
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Test::SBase>, P>(false, this, &TestIntfPrx::_iceI_SBaseAsSBase, context);
    }

    ::std::function<void()>
    SBaseAsSBaseAsync(::std::function<void(::std::shared_ptr<::Test::SBase>)> response,
                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                      ::std::function<void(bool)> sent = nullptr,
                      const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<::std::shared_ptr<::Test::SBase>>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_SBaseAsSBase, context);
    }

    /// \cond INTERNAL
    void _iceI_SBaseAsSBase(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Test::SBase>>>&, const ::Ice::Context&);
    /// \endcond

    ::std::shared_ptr<SBase> SBSKnownDerivedAsSBase(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Test::SBase>>(true, this, &TestIntfPrx::_iceI_SBSKnownDerivedAsSBase, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto SBSKnownDerivedAsSBaseAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::shared_ptr<::Test::SBase>>>().get_future())
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Test::SBase>, P>(false, this, &TestIntfPrx::_iceI_SBSKnownDerivedAsSBase, context);
    }

    ::std::function<void()>
    SBSKnownDerivedAsSBaseAsync(::std::function<void(::std::shared_ptr<::Test::SBase>)> response,
                                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                                ::std::function<void(bool)> sent = nullptr,
                                const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<::std::shared_ptr<::Test::SBase>>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_SBSKnownDerivedAsSBase, context);
    }

    /// \cond INTERNAL
    void _iceI_SBSKnownDerivedAsSBase(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Test::SBase>>>&, const ::Ice::Context&);
    /// \endcond

    ::std::shared_ptr<SBSKnownDerived> SBSKnownDerivedAsSBSKnownDerived(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Test::SBSKnownDerived>>(true, this, &TestIntfPrx::_iceI_SBSKnownDerivedAsSBSKnownDerived, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto SBSKnownDerivedAsSBSKnownDerivedAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::shared_ptr<::Test::SBSKnownDerived>>>().get_future())
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Test::SBSKnownDerived>, P>(false, this, &TestIntfPrx::_iceI_SBSKnownDerivedAsSBSKnownDerived, context);
    }

    ::std::function<void()>
    SBSKnownDerivedAsSBSKnownDerivedAsync(::std::function<void(::std::shared_ptr<::Test::SBSKnownDerived>)> response,
                                          ::std::function<void(::std::exception_ptr)> ex = nullptr,
                                          ::std::function<void(bool)> sent = nullptr,
                                          const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<::std::shared_ptr<::Test::SBSKnownDerived>>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_SBSKnownDerivedAsSBSKnownDerived, context);
    }

    /// \cond INTERNAL
    void _iceI_SBSKnownDerivedAsSBSKnownDerived(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Test::SBSKnownDerived>>>&, const ::Ice::Context&);
    /// \endcond

    ::std::shared_ptr<SBase> SBSUnknownDerivedAsSBase(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Test::SBase>>(true, this, &TestIntfPrx::_iceI_SBSUnknownDerivedAsSBase, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto SBSUnknownDerivedAsSBaseAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::shared_ptr<::Test::SBase>>>().get_future())
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Test::SBase>, P>(false, this, &TestIntfPrx::_iceI_SBSUnknownDerivedAsSBase, context);
    }

    ::std::function<void()>
    SBSUnknownDerivedAsSBaseAsync(::std::function<void(::std::shared_ptr<::Test::SBase>)> response,
                                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                                  ::std::function<void(bool)> sent = nullptr,
                                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<::std::shared_ptr<::Test::SBase>>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_SBSUnknownDerivedAsSBase, context);
    }

    /// \cond INTERNAL
    void _iceI_SBSUnknownDerivedAsSBase(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Test::SBase>>>&, const ::Ice::Context&);
    /// \endcond

    ::std::shared_ptr<SBase> SBSUnknownDerivedAsSBaseCompact(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Test::SBase>>(true, this, &TestIntfPrx::_iceI_SBSUnknownDerivedAsSBaseCompact, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto SBSUnknownDerivedAsSBaseCompactAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::shared_ptr<::Test::SBase>>>().get_future())
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Test::SBase>, P>(false, this, &TestIntfPrx::_iceI_SBSUnknownDerivedAsSBaseCompact, context);
    }

    ::std::function<void()>
    SBSUnknownDerivedAsSBaseCompactAsync(::std::function<void(::std::shared_ptr<::Test::SBase>)> response,
                                         ::std::function<void(::std::exception_ptr)> ex = nullptr,
                                         ::std::function<void(bool)> sent = nullptr,
                                         const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<::std::shared_ptr<::Test::SBase>>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_SBSUnknownDerivedAsSBaseCompact, context);
    }

    /// \cond INTERNAL
    void _iceI_SBSUnknownDerivedAsSBaseCompact(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Test::SBase>>>&, const ::Ice::Context&);
    /// \endcond

    ::std::shared_ptr<::Ice::Value> SUnknownAsObject(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Ice::Value>>(true, this, &TestIntfPrx::_iceI_SUnknownAsObject, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto SUnknownAsObjectAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::shared_ptr<::Ice::Value>>>().get_future())
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Ice::Value>, P>(false, this, &TestIntfPrx::_iceI_SUnknownAsObject, context);
    }

    ::std::function<void()>
    SUnknownAsObjectAsync(::std::function<void(::std::shared_ptr<::Ice::Value>)> response,
                          ::std::function<void(::std::exception_ptr)> ex = nullptr,
                          ::std::function<void(bool)> sent = nullptr,
                          const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<::std::shared_ptr<::Ice::Value>>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_SUnknownAsObject, context);
    }

    /// \cond INTERNAL
    void _iceI_SUnknownAsObject(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Ice::Value>>>&, const ::Ice::Context&);
    /// \endcond

    void checkSUnknown(const ::std::shared_ptr<::Ice::Value>& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &TestIntfPrx::_iceI_checkSUnknown, o, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto checkSUnknownAsync(const ::std::shared_ptr<::Ice::Value>& o, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &TestIntfPrx::_iceI_checkSUnknown, o, context);
    }

    ::std::function<void()>
    checkSUnknownAsync(const ::std::shared_ptr<::Ice::Value>& o,
                       ::std::function<void()> response,
                       ::std::function<void(::std::exception_ptr)> ex = nullptr,
                       ::std::function<void(bool)> sent = nullptr,
                       const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_checkSUnknown, o, context);
    }

    /// \cond INTERNAL
    void _iceI_checkSUnknown(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::shared_ptr<::Ice::Value>&, const ::Ice::Context&);
    /// \endcond

    ::std::shared_ptr<B> oneElementCycle(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Test::B>>(true, this, &TestIntfPrx::_iceI_oneElementCycle, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto oneElementCycleAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::shared_ptr<::Test::B>>>().get_future())
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Test::B>, P>(false, this, &TestIntfPrx::_iceI_oneElementCycle, context);
    }

    ::std::function<void()>
    oneElementCycleAsync(::std::function<void(::std::shared_ptr<::Test::B>)> response,
                         ::std::function<void(::std::exception_ptr)> ex = nullptr,
                         ::std::function<void(bool)> sent = nullptr,
                         const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<::std::shared_ptr<::Test::B>>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_oneElementCycle, context);
    }

    /// \cond INTERNAL
    void _iceI_oneElementCycle(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Test::B>>>&, const ::Ice::Context&);
    /// \endcond

    ::std::shared_ptr<B> twoElementCycle(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Test::B>>(true, this, &TestIntfPrx::_iceI_twoElementCycle, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto twoElementCycleAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::shared_ptr<::Test::B>>>().get_future())
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Test::B>, P>(false, this, &TestIntfPrx::_iceI_twoElementCycle, context);
    }

    ::std::function<void()>
    twoElementCycleAsync(::std::function<void(::std::shared_ptr<::Test::B>)> response,
                         ::std::function<void(::std::exception_ptr)> ex = nullptr,
                         ::std::function<void(bool)> sent = nullptr,
                         const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<::std::shared_ptr<::Test::B>>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_twoElementCycle, context);
    }

    /// \cond INTERNAL
    void _iceI_twoElementCycle(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Test::B>>>&, const ::Ice::Context&);
    /// \endcond

    ::std::shared_ptr<B> D1AsB(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Test::B>>(true, this, &TestIntfPrx::_iceI_D1AsB, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto D1AsBAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::shared_ptr<::Test::B>>>().get_future())
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Test::B>, P>(false, this, &TestIntfPrx::_iceI_D1AsB, context);
    }

    ::std::function<void()>
    D1AsBAsync(::std::function<void(::std::shared_ptr<::Test::B>)> response,
               ::std::function<void(::std::exception_ptr)> ex = nullptr,
               ::std::function<void(bool)> sent = nullptr,
               const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<::std::shared_ptr<::Test::B>>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_D1AsB, context);
    }

    /// \cond INTERNAL
    void _iceI_D1AsB(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Test::B>>>&, const ::Ice::Context&);
    /// \endcond

    ::std::shared_ptr<D1> D1AsD1(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Test::D1>>(true, this, &TestIntfPrx::_iceI_D1AsD1, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto D1AsD1Async(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::shared_ptr<::Test::D1>>>().get_future())
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Test::D1>, P>(false, this, &TestIntfPrx::_iceI_D1AsD1, context);
    }

    ::std::function<void()>
    D1AsD1Async(::std::function<void(::std::shared_ptr<::Test::D1>)> response,
                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                ::std::function<void(bool)> sent = nullptr,
                const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<::std::shared_ptr<::Test::D1>>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_D1AsD1, context);
    }

    /// \cond INTERNAL
    void _iceI_D1AsD1(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Test::D1>>>&, const ::Ice::Context&);
    /// \endcond

    ::std::shared_ptr<B> D2AsB(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Test::B>>(true, this, &TestIntfPrx::_iceI_D2AsB, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto D2AsBAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::shared_ptr<::Test::B>>>().get_future())
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Test::B>, P>(false, this, &TestIntfPrx::_iceI_D2AsB, context);
    }

    ::std::function<void()>
    D2AsBAsync(::std::function<void(::std::shared_ptr<::Test::B>)> response,
               ::std::function<void(::std::exception_ptr)> ex = nullptr,
               ::std::function<void(bool)> sent = nullptr,
               const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<::std::shared_ptr<::Test::B>>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_D2AsB, context);
    }

    /// \cond INTERNAL
    void _iceI_D2AsB(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Test::B>>>&, const ::Ice::Context&);
    /// \endcond

    void paramTest1(::std::shared_ptr<B>& p1, ::std::shared_ptr<B>& p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::ParamTest1Result>(true, this, &TestIntfPrx::_iceI_paramTest1, context).get();
        p1 = ::std::move(_result.p1);
        p2 = ::std::move(_result.p2);
    }

    template<template<typename> class P = ::std::promise>
    auto paramTest1Async(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::ParamTest1Result>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::ParamTest1Result, P>(false, this, &TestIntfPrx::_iceI_paramTest1, context);
    }

    ::std::function<void()>
    paramTest1Async(::std::function<void(::std::shared_ptr<::Test::B>, ::std::shared_ptr<::Test::B>)> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::ParamTest1Result&& _result)
        {
            response(::std::move(_result.p1), ::std::move(_result.p2));
        };
        return _makeLambdaOutgoing<TestIntf::ParamTest1Result>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_paramTest1, context);
    }

    /// \cond INTERNAL
    void _iceI_paramTest1(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::ParamTest1Result>>&, const ::Ice::Context&);
    /// \endcond

    void paramTest2(::std::shared_ptr<B>& p2, ::std::shared_ptr<B>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::ParamTest2Result>(true, this, &TestIntfPrx::_iceI_paramTest2, context).get();
        p2 = ::std::move(_result.p2);
        p1 = ::std::move(_result.p1);
    }

    template<template<typename> class P = ::std::promise>
    auto paramTest2Async(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::ParamTest2Result>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::ParamTest2Result, P>(false, this, &TestIntfPrx::_iceI_paramTest2, context);
    }

    ::std::function<void()>
    paramTest2Async(::std::function<void(::std::shared_ptr<::Test::B>, ::std::shared_ptr<::Test::B>)> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::ParamTest2Result&& _result)
        {
            response(::std::move(_result.p2), ::std::move(_result.p1));
        };
        return _makeLambdaOutgoing<TestIntf::ParamTest2Result>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_paramTest2, context);
    }

    /// \cond INTERNAL
    void _iceI_paramTest2(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::ParamTest2Result>>&, const ::Ice::Context&);
    /// \endcond

    ::std::shared_ptr<B> paramTest3(::std::shared_ptr<B>& p1, ::std::shared_ptr<B>& p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::ParamTest3Result>(true, this, &TestIntfPrx::_iceI_paramTest3, context).get();
        p1 = ::std::move(_result.p1);
        p2 = ::std::move(_result.p2);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto paramTest3Async(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::ParamTest3Result>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::ParamTest3Result, P>(false, this, &TestIntfPrx::_iceI_paramTest3, context);
    }

    ::std::function<void()>
    paramTest3Async(::std::function<void(::std::shared_ptr<::Test::B>, ::std::shared_ptr<::Test::B>, ::std::shared_ptr<::Test::B>)> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::ParamTest3Result&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.p1), ::std::move(_result.p2));
        };
        return _makeLambdaOutgoing<TestIntf::ParamTest3Result>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_paramTest3, context);
    }

    /// \cond INTERNAL
    void _iceI_paramTest3(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::ParamTest3Result>>&, const ::Ice::Context&);
    /// \endcond

    ::std::shared_ptr<B> paramTest4(::std::shared_ptr<B>& p, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::ParamTest4Result>(true, this, &TestIntfPrx::_iceI_paramTest4, context).get();
        p = ::std::move(_result.p);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto paramTest4Async(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::ParamTest4Result>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::ParamTest4Result, P>(false, this, &TestIntfPrx::_iceI_paramTest4, context);
    }

    ::std::function<void()>
    paramTest4Async(::std::function<void(::std::shared_ptr<::Test::B>, ::std::shared_ptr<::Test::B>)> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::ParamTest4Result&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.p));
        };
        return _makeLambdaOutgoing<TestIntf::ParamTest4Result>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_paramTest4, context);
    }

    /// \cond INTERNAL
    void _iceI_paramTest4(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::ParamTest4Result>>&, const ::Ice::Context&);
    /// \endcond

    ::std::shared_ptr<B> returnTest1(::std::shared_ptr<B>& p1, ::std::shared_ptr<B>& p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::ReturnTest1Result>(true, this, &TestIntfPrx::_iceI_returnTest1, context).get();
        p1 = ::std::move(_result.p1);
        p2 = ::std::move(_result.p2);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto returnTest1Async(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::ReturnTest1Result>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::ReturnTest1Result, P>(false, this, &TestIntfPrx::_iceI_returnTest1, context);
    }

    ::std::function<void()>
    returnTest1Async(::std::function<void(::std::shared_ptr<::Test::B>, ::std::shared_ptr<::Test::B>, ::std::shared_ptr<::Test::B>)> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::ReturnTest1Result&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.p1), ::std::move(_result.p2));
        };
        return _makeLambdaOutgoing<TestIntf::ReturnTest1Result>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_returnTest1, context);
    }

    /// \cond INTERNAL
    void _iceI_returnTest1(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::ReturnTest1Result>>&, const ::Ice::Context&);
    /// \endcond

    ::std::shared_ptr<B> returnTest2(::std::shared_ptr<B>& p2, ::std::shared_ptr<B>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::ReturnTest2Result>(true, this, &TestIntfPrx::_iceI_returnTest2, context).get();
        p2 = ::std::move(_result.p2);
        p1 = ::std::move(_result.p1);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto returnTest2Async(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::ReturnTest2Result>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::ReturnTest2Result, P>(false, this, &TestIntfPrx::_iceI_returnTest2, context);
    }

    ::std::function<void()>
    returnTest2Async(::std::function<void(::std::shared_ptr<::Test::B>, ::std::shared_ptr<::Test::B>, ::std::shared_ptr<::Test::B>)> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::ReturnTest2Result&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.p2), ::std::move(_result.p1));
        };
        return _makeLambdaOutgoing<TestIntf::ReturnTest2Result>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_returnTest2, context);
    }

    /// \cond INTERNAL
    void _iceI_returnTest2(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::ReturnTest2Result>>&, const ::Ice::Context&);
    /// \endcond

    ::std::shared_ptr<B> returnTest3(const ::std::shared_ptr<B>& p1, const ::std::shared_ptr<B>& p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Test::B>>(true, this, &TestIntfPrx::_iceI_returnTest3, p1, p2, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto returnTest3Async(const ::std::shared_ptr<B>& p1, const ::std::shared_ptr<B>& p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::shared_ptr<::Test::B>>>().get_future())
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Test::B>, P>(false, this, &TestIntfPrx::_iceI_returnTest3, p1, p2, context);
    }

    ::std::function<void()>
    returnTest3Async(const ::std::shared_ptr<B>& p1, const ::std::shared_ptr<B>& p2,
                     ::std::function<void(::std::shared_ptr<::Test::B>)> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<::std::shared_ptr<::Test::B>>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_returnTest3, p1, p2, context);
    }

    /// \cond INTERNAL
    void _iceI_returnTest3(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Test::B>>>&, const ::std::shared_ptr<B>&, const ::std::shared_ptr<B>&, const ::Ice::Context&);
    /// \endcond

    SS3 sequenceTest(const ::std::shared_ptr<SS1>& p1, const ::std::shared_ptr<SS2>& p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::Test::SS3>(true, this, &TestIntfPrx::_iceI_sequenceTest, p1, p2, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto sequenceTestAsync(const ::std::shared_ptr<SS1>& p1, const ::std::shared_ptr<SS2>& p2, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::Test::SS3>>().get_future())
    {
        return _makePromiseOutgoing<::Test::SS3, P>(false, this, &TestIntfPrx::_iceI_sequenceTest, p1, p2, context);
    }

    ::std::function<void()>
    sequenceTestAsync(const ::std::shared_ptr<SS1>& p1, const ::std::shared_ptr<SS2>& p2,
                      ::std::function<void(::Test::SS3)> response,
                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                      ::std::function<void(bool)> sent = nullptr,
                      const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<::Test::SS3>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_sequenceTest, p1, p2, context);
    }

    /// \cond INTERNAL
    void _iceI_sequenceTest(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::Test::SS3>>&, const ::std::shared_ptr<SS1>&, const ::std::shared_ptr<SS2>&, const ::Ice::Context&);
    /// \endcond

    BDict dictionaryTest(const BDict& bin, BDict& bout, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::DictionaryTestResult>(true, this, &TestIntfPrx::_iceI_dictionaryTest, bin, context).get();
        bout = ::std::move(_result.bout);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto dictionaryTestAsync(const BDict& bin, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::DictionaryTestResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::DictionaryTestResult, P>(false, this, &TestIntfPrx::_iceI_dictionaryTest, bin, context);
    }

    ::std::function<void()>
    dictionaryTestAsync(const BDict& bin,
                        ::std::function<void(::Test::BDict, ::Test::BDict)> response,
                        ::std::function<void(::std::exception_ptr)> ex = nullptr,
                        ::std::function<void(bool)> sent = nullptr,
                        const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::DictionaryTestResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.bout));
        };
        return _makeLambdaOutgoing<TestIntf::DictionaryTestResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_dictionaryTest, bin, context);
    }

    /// \cond INTERNAL
    void _iceI_dictionaryTest(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::DictionaryTestResult>>&, const BDict&, const ::Ice::Context&);
    /// \endcond

    ::std::shared_ptr<PBase> exchangePBase(const ::std::shared_ptr<PBase>& pb, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Test::PBase>>(true, this, &TestIntfPrx::_iceI_exchangePBase, pb, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto exchangePBaseAsync(const ::std::shared_ptr<PBase>& pb, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::shared_ptr<::Test::PBase>>>().get_future())
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Test::PBase>, P>(false, this, &TestIntfPrx::_iceI_exchangePBase, pb, context);
    }

    ::std::function<void()>
    exchangePBaseAsync(const ::std::shared_ptr<PBase>& pb,
                       ::std::function<void(::std::shared_ptr<::Test::PBase>)> response,
                       ::std::function<void(::std::exception_ptr)> ex = nullptr,
                       ::std::function<void(bool)> sent = nullptr,
                       const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<::std::shared_ptr<::Test::PBase>>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_exchangePBase, pb, context);
    }

    /// \cond INTERNAL
    void _iceI_exchangePBase(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Test::PBase>>>&, const ::std::shared_ptr<PBase>&, const ::Ice::Context&);
    /// \endcond

    ::std::shared_ptr<Preserved> PBSUnknownAsPreserved(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Test::Preserved>>(true, this, &TestIntfPrx::_iceI_PBSUnknownAsPreserved, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto PBSUnknownAsPreservedAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::shared_ptr<::Test::Preserved>>>().get_future())
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Test::Preserved>, P>(false, this, &TestIntfPrx::_iceI_PBSUnknownAsPreserved, context);
    }

    ::std::function<void()>
    PBSUnknownAsPreservedAsync(::std::function<void(::std::shared_ptr<::Test::Preserved>)> response,
                               ::std::function<void(::std::exception_ptr)> ex = nullptr,
                               ::std::function<void(bool)> sent = nullptr,
                               const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<::std::shared_ptr<::Test::Preserved>>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_PBSUnknownAsPreserved, context);
    }

    /// \cond INTERNAL
    void _iceI_PBSUnknownAsPreserved(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Test::Preserved>>>&, const ::Ice::Context&);
    /// \endcond

    void checkPBSUnknown(const ::std::shared_ptr<Preserved>& p, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &TestIntfPrx::_iceI_checkPBSUnknown, p, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto checkPBSUnknownAsync(const ::std::shared_ptr<Preserved>& p, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &TestIntfPrx::_iceI_checkPBSUnknown, p, context);
    }

    ::std::function<void()>
    checkPBSUnknownAsync(const ::std::shared_ptr<Preserved>& p,
                         ::std::function<void()> response,
                         ::std::function<void(::std::exception_ptr)> ex = nullptr,
                         ::std::function<void(bool)> sent = nullptr,
                         const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_checkPBSUnknown, p, context);
    }

    /// \cond INTERNAL
    void _iceI_checkPBSUnknown(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::shared_ptr<Preserved>&, const ::Ice::Context&);
    /// \endcond

    ::std::shared_ptr<Preserved> PBSUnknownAsPreservedWithGraph(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Test::Preserved>>(true, this, &TestIntfPrx::_iceI_PBSUnknownAsPreservedWithGraph, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto PBSUnknownAsPreservedWithGraphAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::shared_ptr<::Test::Preserved>>>().get_future())
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Test::Preserved>, P>(false, this, &TestIntfPrx::_iceI_PBSUnknownAsPreservedWithGraph, context);
    }

    ::std::function<void()>
    PBSUnknownAsPreservedWithGraphAsync(::std::function<void(::std::shared_ptr<::Test::Preserved>)> response,
                                        ::std::function<void(::std::exception_ptr)> ex = nullptr,
                                        ::std::function<void(bool)> sent = nullptr,
                                        const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<::std::shared_ptr<::Test::Preserved>>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_PBSUnknownAsPreservedWithGraph, context);
    }

    /// \cond INTERNAL
    void _iceI_PBSUnknownAsPreservedWithGraph(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Test::Preserved>>>&, const ::Ice::Context&);
    /// \endcond

    void checkPBSUnknownWithGraph(const ::std::shared_ptr<Preserved>& p, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &TestIntfPrx::_iceI_checkPBSUnknownWithGraph, p, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto checkPBSUnknownWithGraphAsync(const ::std::shared_ptr<Preserved>& p, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &TestIntfPrx::_iceI_checkPBSUnknownWithGraph, p, context);
    }

    ::std::function<void()>
    checkPBSUnknownWithGraphAsync(const ::std::shared_ptr<Preserved>& p,
                                  ::std::function<void()> response,
                                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                                  ::std::function<void(bool)> sent = nullptr,
                                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_checkPBSUnknownWithGraph, p, context);
    }

    /// \cond INTERNAL
    void _iceI_checkPBSUnknownWithGraph(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::shared_ptr<Preserved>&, const ::Ice::Context&);
    /// \endcond

    ::std::shared_ptr<Preserved> PBSUnknown2AsPreservedWithGraph(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Test::Preserved>>(true, this, &TestIntfPrx::_iceI_PBSUnknown2AsPreservedWithGraph, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto PBSUnknown2AsPreservedWithGraphAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::shared_ptr<::Test::Preserved>>>().get_future())
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Test::Preserved>, P>(false, this, &TestIntfPrx::_iceI_PBSUnknown2AsPreservedWithGraph, context);
    }

    ::std::function<void()>
    PBSUnknown2AsPreservedWithGraphAsync(::std::function<void(::std::shared_ptr<::Test::Preserved>)> response,
                                         ::std::function<void(::std::exception_ptr)> ex = nullptr,
                                         ::std::function<void(bool)> sent = nullptr,
                                         const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<::std::shared_ptr<::Test::Preserved>>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_PBSUnknown2AsPreservedWithGraph, context);
    }

    /// \cond INTERNAL
    void _iceI_PBSUnknown2AsPreservedWithGraph(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Test::Preserved>>>&, const ::Ice::Context&);
    /// \endcond

    void checkPBSUnknown2WithGraph(const ::std::shared_ptr<Preserved>& p, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &TestIntfPrx::_iceI_checkPBSUnknown2WithGraph, p, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto checkPBSUnknown2WithGraphAsync(const ::std::shared_ptr<Preserved>& p, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &TestIntfPrx::_iceI_checkPBSUnknown2WithGraph, p, context);
    }

    ::std::function<void()>
    checkPBSUnknown2WithGraphAsync(const ::std::shared_ptr<Preserved>& p,
                                   ::std::function<void()> response,
                                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                                   ::std::function<void(bool)> sent = nullptr,
                                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_checkPBSUnknown2WithGraph, p, context);
    }

    /// \cond INTERNAL
    void _iceI_checkPBSUnknown2WithGraph(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::shared_ptr<Preserved>&, const ::Ice::Context&);
    /// \endcond

    ::std::shared_ptr<PNode> exchangePNode(const ::std::shared_ptr<PNode>& pn, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Test::PNode>>(true, this, &TestIntfPrx::_iceI_exchangePNode, pn, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto exchangePNodeAsync(const ::std::shared_ptr<PNode>& pn, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::shared_ptr<::Test::PNode>>>().get_future())
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Test::PNode>, P>(false, this, &TestIntfPrx::_iceI_exchangePNode, pn, context);
    }

    ::std::function<void()>
    exchangePNodeAsync(const ::std::shared_ptr<PNode>& pn,
                       ::std::function<void(::std::shared_ptr<::Test::PNode>)> response,
                       ::std::function<void(::std::exception_ptr)> ex = nullptr,
                       ::std::function<void(bool)> sent = nullptr,
                       const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<::std::shared_ptr<::Test::PNode>>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_exchangePNode, pn, context);
    }

    /// \cond INTERNAL
    void _iceI_exchangePNode(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Test::PNode>>>&, const ::std::shared_ptr<PNode>&, const ::Ice::Context&);
    /// \endcond

    void throwBaseAsBase(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &TestIntfPrx::_iceI_throwBaseAsBase, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto throwBaseAsBaseAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &TestIntfPrx::_iceI_throwBaseAsBase, context);
    }

    ::std::function<void()>
    throwBaseAsBaseAsync(::std::function<void()> response,
                         ::std::function<void(::std::exception_ptr)> ex = nullptr,
                         ::std::function<void(bool)> sent = nullptr,
                         const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_throwBaseAsBase, context);
    }

    /// \cond INTERNAL
    void _iceI_throwBaseAsBase(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    void throwDerivedAsBase(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &TestIntfPrx::_iceI_throwDerivedAsBase, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto throwDerivedAsBaseAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &TestIntfPrx::_iceI_throwDerivedAsBase, context);
    }

    ::std::function<void()>
    throwDerivedAsBaseAsync(::std::function<void()> response,
                            ::std::function<void(::std::exception_ptr)> ex = nullptr,
                            ::std::function<void(bool)> sent = nullptr,
                            const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_throwDerivedAsBase, context);
    }

    /// \cond INTERNAL
    void _iceI_throwDerivedAsBase(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    void throwDerivedAsDerived(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &TestIntfPrx::_iceI_throwDerivedAsDerived, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto throwDerivedAsDerivedAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &TestIntfPrx::_iceI_throwDerivedAsDerived, context);
    }

    ::std::function<void()>
    throwDerivedAsDerivedAsync(::std::function<void()> response,
                               ::std::function<void(::std::exception_ptr)> ex = nullptr,
                               ::std::function<void(bool)> sent = nullptr,
                               const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_throwDerivedAsDerived, context);
    }

    /// \cond INTERNAL
    void _iceI_throwDerivedAsDerived(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    void throwUnknownDerivedAsBase(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &TestIntfPrx::_iceI_throwUnknownDerivedAsBase, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto throwUnknownDerivedAsBaseAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &TestIntfPrx::_iceI_throwUnknownDerivedAsBase, context);
    }

    ::std::function<void()>
    throwUnknownDerivedAsBaseAsync(::std::function<void()> response,
                                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                                   ::std::function<void(bool)> sent = nullptr,
                                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_throwUnknownDerivedAsBase, context);
    }

    /// \cond INTERNAL
    void _iceI_throwUnknownDerivedAsBase(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    void throwPreservedException(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &TestIntfPrx::_iceI_throwPreservedException, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto throwPreservedExceptionAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &TestIntfPrx::_iceI_throwPreservedException, context);
    }

    ::std::function<void()>
    throwPreservedExceptionAsync(::std::function<void()> response,
                                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                                 ::std::function<void(bool)> sent = nullptr,
                                 const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_throwPreservedException, context);
    }

    /// \cond INTERNAL
    void _iceI_throwPreservedException(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    /**
     * Use of forward-declared class to verify that code is generated correctly.
     * @param context The Context map to send with the invocation.
     */
    void useForward(::std::shared_ptr<Forward>& f, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        f = _makePromiseOutgoing<::std::shared_ptr<::Test::Forward>>(true, this, &TestIntfPrx::_iceI_useForward, context).get();
    }

    /**
     * Use of forward-declared class to verify that code is generated correctly.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    template<template<typename> class P = ::std::promise>
    auto useForwardAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::shared_ptr<::Test::Forward>>>().get_future())
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Test::Forward>, P>(false, this, &TestIntfPrx::_iceI_useForward, context);
    }

    /**
     * Use of forward-declared class to verify that code is generated correctly.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    useForwardAsync(::std::function<void(::std::shared_ptr<::Test::Forward>)> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<::std::shared_ptr<::Test::Forward>>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_useForward, context);
    }

    /// \cond INTERNAL
    void _iceI_useForward(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Test::Forward>>>&, const ::Ice::Context&);
    /// \endcond

    void shutdown(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &TestIntfPrx::_iceI_shutdown, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto shutdownAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &TestIntfPrx::_iceI_shutdown, context);
    }

    ::std::function<void()>
    shutdownAsync(::std::function<void()> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_shutdown, context);
    }

    /// \cond INTERNAL
    void _iceI_shutdown(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    TestIntfPrx() = default;
    friend ::std::shared_ptr<TestIntfPrx> IceInternal::createProxy<TestIntfPrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

}

/// \cond STREAM
namespace Ice
{

template<typename S>
struct StreamReader<::Test::SBase, S>
{
    static void read(S* istr, ::Test::SBase& v)
    {
        istr->readAll(v.sb);
    }
};

template<typename S>
struct StreamWriter<::Test::SBSKnownDerived, S>
{
    static void write(S* ostr, const ::Test::SBSKnownDerived& v)
    {
        ostr->writeAll(v.sbskd);
    }
};

template<typename S>
struct StreamReader<::Test::SBSKnownDerived, S>
{
    static void read(S* istr, ::Test::SBSKnownDerived& v)
    {
        istr->readAll(v.sbskd);
    }
};

template<typename S>
struct StreamReader<::Test::B, S>
{
    static void read(S* istr, ::Test::B& v)
    {
        istr->readAll(v.sb, v.pb);
    }
};

template<typename S>
struct StreamWriter<::Test::D1, S>
{
    static void write(S* ostr, const ::Test::D1& v)
    {
        ostr->writeAll(v.sd1, v.pd1);
    }
};

template<typename S>
struct StreamReader<::Test::D1, S>
{
    static void read(S* istr, ::Test::D1& v)
    {
        istr->readAll(v.sd1, v.pd1);
    }
};

template<typename S>
struct StreamReader<::Test::SS1, S>
{
    static void read(S* istr, ::Test::SS1& v)
    {
        istr->readAll(v.s);
    }
};

template<typename S>
struct StreamReader<::Test::SS2, S>
{
    static void read(S* istr, ::Test::SS2& v)
    {
        istr->readAll(v.s);
    }
};

template<>
struct StreamableTraits<::Test::SS3>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 2;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::Test::SS3, S>
{
    static void read(S* istr, ::Test::SS3& v)
    {
        istr->readAll(v.c1, v.c2);
    }
};

template<typename S>
struct StreamReader<::Test::BaseException, S>
{
    static void read(S* istr, ::Test::BaseException& v)
    {
        istr->readAll(v.sbe, v.pb);
    }
};

template<typename S>
struct StreamWriter<::Test::DerivedException, S>
{
    static void write(S* ostr, const ::Test::DerivedException& v)
    {
        ostr->writeAll(v.sde, v.pd1);
    }
};

template<typename S>
struct StreamReader<::Test::DerivedException, S>
{
    static void read(S* istr, ::Test::DerivedException& v)
    {
        istr->readAll(v.sde, v.pd1);
    }
};

template<typename S>
struct StreamReader<::Test::PBase, S>
{
    static void read(S* istr, ::Test::PBase& v)
    {
        istr->readAll(v.pi);
    }
};

template<typename S>
struct StreamWriter<::Test::Preserved, S>
{
    static void write(S* ostr, const ::Test::Preserved& v)
    {
        ostr->writeAll(v.ps);
    }
};

template<typename S>
struct StreamReader<::Test::Preserved, S>
{
    static void read(S* istr, ::Test::Preserved& v)
    {
        istr->readAll(v.ps);
    }
};

template<typename S>
struct StreamWriter<::Test::PDerived, S>
{
    static void write(S* ostr, const ::Test::PDerived& v)
    {
        ostr->writeAll(v.pb);
    }
};

template<typename S>
struct StreamReader<::Test::PDerived, S>
{
    static void read(S* istr, ::Test::PDerived& v)
    {
        istr->readAll(v.pb);
    }
};

template<typename S>
struct StreamReader<::Test::PNode, S>
{
    static void read(S* istr, ::Test::PNode& v)
    {
        istr->readAll(v.next);
    }
};

template<typename S>
struct StreamWriter<::Test::SBSUnknownDerived, S>
{
    static void write(S* ostr, const ::Test::SBSUnknownDerived& v)
    {
        ostr->writeAll(v.sbsud);
    }
};

template<typename S>
struct StreamReader<::Test::SBSUnknownDerived, S>
{
    static void read(S* istr, ::Test::SBSUnknownDerived& v)
    {
        istr->readAll(v.sbsud);
    }
};

template<typename S>
struct StreamReader<::Test::SUnknown, S>
{
    static void read(S* istr, ::Test::SUnknown& v)
    {
        istr->readAll(v.su, v.cycle);
    }
};

template<typename S>
struct StreamWriter<::Test::D2, S>
{
    static void write(S* ostr, const ::Test::D2& v)
    {
        ostr->writeAll(v.sd2, v.pd2);
    }
};

template<typename S>
struct StreamReader<::Test::D2, S>
{
    static void read(S* istr, ::Test::D2& v)
    {
        istr->readAll(v.sd2, v.pd2);
    }
};

template<typename S>
struct StreamWriter<::Test::D4, S>
{
    static void write(S* ostr, const ::Test::D4& v)
    {
        ostr->writeAll(v.p1, v.p2);
    }
};

template<typename S>
struct StreamReader<::Test::D4, S>
{
    static void read(S* istr, ::Test::D4& v)
    {
        istr->readAll(v.p1, v.p2);
    }
};

template<typename S>
struct StreamWriter<::Test::UnknownDerivedException, S>
{
    static void write(S* ostr, const ::Test::UnknownDerivedException& v)
    {
        ostr->writeAll(v.sude, v.pd2);
    }
};

template<typename S>
struct StreamReader<::Test::UnknownDerivedException, S>
{
    static void read(S* istr, ::Test::UnknownDerivedException& v)
    {
        istr->readAll(v.sude, v.pd2);
    }
};

template<typename S>
struct StreamReader<::Test::MyClass, S>
{
    static void read(S* istr, ::Test::MyClass& v)
    {
        istr->readAll(v.i);
    }
};

template<typename S>
struct StreamWriter<::Test::PSUnknown, S>
{
    static void write(S* ostr, const ::Test::PSUnknown& v)
    {
        ostr->writeAll(v.psu, v.graph, v.cl);
    }
};

template<typename S>
struct StreamReader<::Test::PSUnknown, S>
{
    static void read(S* istr, ::Test::PSUnknown& v)
    {
        istr->readAll(v.psu, v.graph, v.cl);
    }
};

template<typename S>
struct StreamWriter<::Test::PSUnknown2, S>
{
    static void write(S* ostr, const ::Test::PSUnknown2& v)
    {
        ostr->writeAll(v.pb);
    }
};

template<typename S>
struct StreamReader<::Test::PSUnknown2, S>
{
    static void read(S* istr, ::Test::PSUnknown2& v)
    {
        istr->readAll(v.pb);
    }
};

template<typename S>
struct StreamReader<::Test::PSUnknownException, S>
{
    static void read(S* istr, ::Test::PSUnknownException& v)
    {
        istr->readAll(v.p);
    }
};

template<typename S>
struct StreamReader<::Test::Hidden, S>
{
    static void read(S* istr, ::Test::Hidden& v)
    {
        istr->readAll(v.f);
    }
};

template<typename S>
struct StreamReader<::Test::Forward, S>
{
    static void read(S* istr, ::Test::Forward& v)
    {
        istr->readAll(v.h);
    }
};

}
/// \endcond

/// \cond INTERNAL
namespace Test
{

using SBasePtr = ::std::shared_ptr<SBase>;

using SBSKnownDerivedPtr = ::std::shared_ptr<SBSKnownDerived>;

using BPtr = ::std::shared_ptr<B>;

using D1Ptr = ::std::shared_ptr<D1>;

using SS1Ptr = ::std::shared_ptr<SS1>;

using SS2Ptr = ::std::shared_ptr<SS2>;

using ForwardPtr = ::std::shared_ptr<Forward>;

using PBasePtr = ::std::shared_ptr<PBase>;

using PreservedPtr = ::std::shared_ptr<Preserved>;

using PDerivedPtr = ::std::shared_ptr<PDerived>;

using PNodePtr = ::std::shared_ptr<PNode>;

using TestIntfPtr = ::std::shared_ptr<TestIntf>;
using TestIntfPrxPtr = ::std::shared_ptr<TestIntfPrx>;

using SBSUnknownDerivedPtr = ::std::shared_ptr<SBSUnknownDerived>;

using SUnknownPtr = ::std::shared_ptr<SUnknown>;

using D2Ptr = ::std::shared_ptr<D2>;

using D4Ptr = ::std::shared_ptr<D4>;

using MyClassPtr = ::std::shared_ptr<MyClass>;

using PSUnknownPtr = ::std::shared_ptr<PSUnknown>;

using PSUnknown2Ptr = ::std::shared_ptr<PSUnknown2>;

using HiddenPtr = ::std::shared_ptr<Hidden>;

}
/// \endcond

#include <IceUtil/PopDisableWarnings.h>
#endif
