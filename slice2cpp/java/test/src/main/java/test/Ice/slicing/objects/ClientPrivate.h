//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.8.0-alpha.0
//
// <auto-generated>
//
// Generated from file `ClientPrivate.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __ClientPrivate_h__
#define __ClientPrivate_h__

#include <IceUtil/PushDisableWarnings.h>
#include <Ice/Ice.h>
#include <IceUtil/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION  != 30850
#       error Ice version mismatch: an exact match is required for beta generated code
#   endif
#endif

namespace Test
{

class SBase;

using SBasePtr = ::std::shared_ptr<SBase>;
class SBSKnownDerived;

using SBSKnownDerivedPtr = ::std::shared_ptr<SBSKnownDerived>;
class B;

using BPtr = ::std::shared_ptr<B>;
class D1;

using D1Ptr = ::std::shared_ptr<D1>;

using BSeq = ::std::vector<::std::shared_ptr<B>>;
class SS1;

using SS1Ptr = ::std::shared_ptr<SS1>;
class SS2;

using SS2Ptr = ::std::shared_ptr<SS2>;
struct SS3;

using BDict = ::std::map<::std::int32_t, ::std::shared_ptr<B>>;
class Forward;

using ForwardPtr = ::std::shared_ptr<Forward>;
class PBase;

using PBasePtr = ::std::shared_ptr<PBase>;

using PBaseSeq = ::std::vector<::std::shared_ptr<PBase>>;
class Preserved;

using PreservedPtr = ::std::shared_ptr<Preserved>;
class PDerived;

using PDerivedPtr = ::std::shared_ptr<PDerived>;
class CompactPDerived;

using CompactPDerivedPtr = ::std::shared_ptr<CompactPDerived>;
class PNode;

using PNodePtr = ::std::shared_ptr<PNode>;
class TestIntfPrx;

using TestIntfPrxPtr = ::std::optional<TestIntfPrx>;
class D3;

using D3Ptr = ::std::shared_ptr<D3>;
class PCUnknown;

using PCUnknownPtr = ::std::shared_ptr<PCUnknown>;
class PCDerived;

using PCDerivedPtr = ::std::shared_ptr<PCDerived>;
class PCDerived2;

using PCDerived2Ptr = ::std::shared_ptr<PCDerived2>;
class PCDerived3;

using PCDerived3Ptr = ::std::shared_ptr<PCDerived3>;
class CompactPCDerived;

using CompactPCDerivedPtr = ::std::shared_ptr<CompactPCDerived>;
class Hidden;

using HiddenPtr = ::std::shared_ptr<Hidden>;

}

namespace Test
{

class TestIntfPrx : public ::Ice::Proxy<TestIntfPrx, ::Ice::ObjectPrx>
{
public:

    ::std::shared_ptr<::Ice::Value> SBaseAsObject(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::shared_ptr<::Ice::Value>> SBaseAsObjectAsync(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    SBaseAsObjectAsync(::std::function<void(::std::shared_ptr<::Ice::Value>)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_SBaseAsObject(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Ice::Value>>>&, const ::Ice::Context&) const;
    /// \endcond

    ::std::shared_ptr<SBase> SBaseAsSBase(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::shared_ptr<SBase>> SBaseAsSBaseAsync(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    SBaseAsSBaseAsync(::std::function<void(::std::shared_ptr<::Test::SBase>)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_SBaseAsSBase(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<SBase>>>&, const ::Ice::Context&) const;
    /// \endcond

    ::std::shared_ptr<SBase> SBSKnownDerivedAsSBase(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::shared_ptr<SBase>> SBSKnownDerivedAsSBaseAsync(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    SBSKnownDerivedAsSBaseAsync(::std::function<void(::std::shared_ptr<::Test::SBase>)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_SBSKnownDerivedAsSBase(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<SBase>>>&, const ::Ice::Context&) const;
    /// \endcond

    ::std::shared_ptr<SBSKnownDerived> SBSKnownDerivedAsSBSKnownDerived(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::shared_ptr<SBSKnownDerived>> SBSKnownDerivedAsSBSKnownDerivedAsync(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    SBSKnownDerivedAsSBSKnownDerivedAsync(::std::function<void(::std::shared_ptr<::Test::SBSKnownDerived>)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_SBSKnownDerivedAsSBSKnownDerived(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<SBSKnownDerived>>>&, const ::Ice::Context&) const;
    /// \endcond

    ::std::shared_ptr<SBase> SBSUnknownDerivedAsSBase(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::shared_ptr<SBase>> SBSUnknownDerivedAsSBaseAsync(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    SBSUnknownDerivedAsSBaseAsync(::std::function<void(::std::shared_ptr<::Test::SBase>)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_SBSUnknownDerivedAsSBase(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<SBase>>>&, const ::Ice::Context&) const;
    /// \endcond

    ::std::shared_ptr<SBase> SBSUnknownDerivedAsSBaseCompact(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::shared_ptr<SBase>> SBSUnknownDerivedAsSBaseCompactAsync(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    SBSUnknownDerivedAsSBaseCompactAsync(::std::function<void(::std::shared_ptr<::Test::SBase>)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_SBSUnknownDerivedAsSBaseCompact(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<SBase>>>&, const ::Ice::Context&) const;
    /// \endcond

    ::std::shared_ptr<::Ice::Value> SUnknownAsObject(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::shared_ptr<::Ice::Value>> SUnknownAsObjectAsync(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    SUnknownAsObjectAsync(::std::function<void(::std::shared_ptr<::Ice::Value>)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_SUnknownAsObject(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Ice::Value>>>&, const ::Ice::Context&) const;
    /// \endcond

    void checkSUnknown(const ::std::shared_ptr<::Ice::Value>& o, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<void> checkSUnknownAsync(const ::std::shared_ptr<::Ice::Value>& o, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    checkSUnknownAsync(const ::std::shared_ptr<::Ice::Value>& o, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_checkSUnknown(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::shared_ptr<::Ice::Value>&, const ::Ice::Context&) const;
    /// \endcond

    ::std::shared_ptr<B> oneElementCycle(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::shared_ptr<B>> oneElementCycleAsync(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    oneElementCycleAsync(::std::function<void(::std::shared_ptr<::Test::B>)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_oneElementCycle(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<B>>>&, const ::Ice::Context&) const;
    /// \endcond

    ::std::shared_ptr<B> twoElementCycle(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::shared_ptr<B>> twoElementCycleAsync(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    twoElementCycleAsync(::std::function<void(::std::shared_ptr<::Test::B>)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_twoElementCycle(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<B>>>&, const ::Ice::Context&) const;
    /// \endcond

    ::std::shared_ptr<B> D1AsB(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::shared_ptr<B>> D1AsBAsync(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    D1AsBAsync(::std::function<void(::std::shared_ptr<::Test::B>)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_D1AsB(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<B>>>&, const ::Ice::Context&) const;
    /// \endcond

    ::std::shared_ptr<D1> D1AsD1(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::shared_ptr<D1>> D1AsD1Async(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    D1AsD1Async(::std::function<void(::std::shared_ptr<::Test::D1>)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_D1AsD1(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<D1>>>&, const ::Ice::Context&) const;
    /// \endcond

    ::std::shared_ptr<B> D2AsB(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::shared_ptr<B>> D2AsBAsync(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    D2AsBAsync(::std::function<void(::std::shared_ptr<::Test::B>)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_D2AsB(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<B>>>&, const ::Ice::Context&) const;
    /// \endcond

    void paramTest1(::std::shared_ptr<B>& p1, ::std::shared_ptr<B>& p2, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<::std::shared_ptr<B>, ::std::shared_ptr<B>>> paramTest1Async(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    paramTest1Async(::std::function<void(::std::shared_ptr<::Test::B>, ::std::shared_ptr<::Test::B>)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_paramTest1(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::shared_ptr<B>, ::std::shared_ptr<B>>>>&, const ::Ice::Context&) const;
    /// \endcond

    void paramTest2(::std::shared_ptr<B>& p2, ::std::shared_ptr<B>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<::std::shared_ptr<B>, ::std::shared_ptr<B>>> paramTest2Async(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    paramTest2Async(::std::function<void(::std::shared_ptr<::Test::B>, ::std::shared_ptr<::Test::B>)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_paramTest2(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::shared_ptr<B>, ::std::shared_ptr<B>>>>&, const ::Ice::Context&) const;
    /// \endcond

    ::std::shared_ptr<B> paramTest3(::std::shared_ptr<B>& p1, ::std::shared_ptr<B>& p2, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<::std::shared_ptr<B>, ::std::shared_ptr<B>, ::std::shared_ptr<B>>> paramTest3Async(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    paramTest3Async(::std::function<void(::std::shared_ptr<::Test::B>, ::std::shared_ptr<::Test::B>, ::std::shared_ptr<::Test::B>)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_paramTest3(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::shared_ptr<B>, ::std::shared_ptr<B>, ::std::shared_ptr<B>>>>&, const ::Ice::Context&) const;
    /// \endcond

    ::std::shared_ptr<B> paramTest4(::std::shared_ptr<B>& p, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<::std::shared_ptr<B>, ::std::shared_ptr<B>>> paramTest4Async(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    paramTest4Async(::std::function<void(::std::shared_ptr<::Test::B>, ::std::shared_ptr<::Test::B>)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_paramTest4(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::shared_ptr<B>, ::std::shared_ptr<B>>>>&, const ::Ice::Context&) const;
    /// \endcond

    ::std::shared_ptr<B> returnTest1(::std::shared_ptr<B>& p1, ::std::shared_ptr<B>& p2, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<::std::shared_ptr<B>, ::std::shared_ptr<B>, ::std::shared_ptr<B>>> returnTest1Async(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    returnTest1Async(::std::function<void(::std::shared_ptr<::Test::B>, ::std::shared_ptr<::Test::B>, ::std::shared_ptr<::Test::B>)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_returnTest1(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::shared_ptr<B>, ::std::shared_ptr<B>, ::std::shared_ptr<B>>>>&, const ::Ice::Context&) const;
    /// \endcond

    ::std::shared_ptr<B> returnTest2(::std::shared_ptr<B>& p2, ::std::shared_ptr<B>& p1, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<::std::shared_ptr<B>, ::std::shared_ptr<B>, ::std::shared_ptr<B>>> returnTest2Async(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    returnTest2Async(::std::function<void(::std::shared_ptr<::Test::B>, ::std::shared_ptr<::Test::B>, ::std::shared_ptr<::Test::B>)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_returnTest2(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::shared_ptr<B>, ::std::shared_ptr<B>, ::std::shared_ptr<B>>>>&, const ::Ice::Context&) const;
    /// \endcond

    ::std::shared_ptr<B> returnTest3(const ::std::shared_ptr<B>& p1, const ::std::shared_ptr<B>& p2, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::shared_ptr<B>> returnTest3Async(const ::std::shared_ptr<B>& p1, const ::std::shared_ptr<B>& p2, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    returnTest3Async(const ::std::shared_ptr<B>& p1, const ::std::shared_ptr<B>& p2, ::std::function<void(::std::shared_ptr<::Test::B>)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_returnTest3(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<B>>>&, const ::std::shared_ptr<B>&, const ::std::shared_ptr<B>&, const ::Ice::Context&) const;
    /// \endcond

    SS3 sequenceTest(const ::std::shared_ptr<SS1>& p1, const ::std::shared_ptr<SS2>& p2, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<SS3> sequenceTestAsync(const ::std::shared_ptr<SS1>& p1, const ::std::shared_ptr<SS2>& p2, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    sequenceTestAsync(const ::std::shared_ptr<SS1>& p1, const ::std::shared_ptr<SS2>& p2, ::std::function<void(::Test::SS3)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_sequenceTest(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<SS3>>&, const ::std::shared_ptr<SS1>&, const ::std::shared_ptr<SS2>&, const ::Ice::Context&) const;
    /// \endcond

    BDict dictionaryTest(const BDict& bin, BDict& bout, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::tuple<BDict, BDict>> dictionaryTestAsync(const BDict& bin, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    dictionaryTestAsync(const BDict& bin, ::std::function<void(::Test::BDict, ::Test::BDict)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_dictionaryTest(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<BDict, BDict>>>&, const BDict&, const ::Ice::Context&) const;
    /// \endcond

    ::std::shared_ptr<PBase> exchangePBase(const ::std::shared_ptr<PBase>& pb, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::shared_ptr<PBase>> exchangePBaseAsync(const ::std::shared_ptr<PBase>& pb, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    exchangePBaseAsync(const ::std::shared_ptr<PBase>& pb, ::std::function<void(::std::shared_ptr<::Test::PBase>)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_exchangePBase(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<PBase>>>&, const ::std::shared_ptr<PBase>&, const ::Ice::Context&) const;
    /// \endcond

    ::std::shared_ptr<Preserved> PBSUnknownAsPreserved(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::shared_ptr<Preserved>> PBSUnknownAsPreservedAsync(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    PBSUnknownAsPreservedAsync(::std::function<void(::std::shared_ptr<::Test::Preserved>)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_PBSUnknownAsPreserved(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<Preserved>>>&, const ::Ice::Context&) const;
    /// \endcond

    void checkPBSUnknown(const ::std::shared_ptr<Preserved>& p, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<void> checkPBSUnknownAsync(const ::std::shared_ptr<Preserved>& p, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    checkPBSUnknownAsync(const ::std::shared_ptr<Preserved>& p, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_checkPBSUnknown(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::shared_ptr<Preserved>&, const ::Ice::Context&) const;
    /// \endcond

    ::std::shared_ptr<Preserved> PBSUnknownAsPreservedWithGraph(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::shared_ptr<Preserved>> PBSUnknownAsPreservedWithGraphAsync(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    PBSUnknownAsPreservedWithGraphAsync(::std::function<void(::std::shared_ptr<::Test::Preserved>)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_PBSUnknownAsPreservedWithGraph(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<Preserved>>>&, const ::Ice::Context&) const;
    /// \endcond

    void checkPBSUnknownWithGraph(const ::std::shared_ptr<Preserved>& p, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<void> checkPBSUnknownWithGraphAsync(const ::std::shared_ptr<Preserved>& p, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    checkPBSUnknownWithGraphAsync(const ::std::shared_ptr<Preserved>& p, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_checkPBSUnknownWithGraph(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::shared_ptr<Preserved>&, const ::Ice::Context&) const;
    /// \endcond

    ::std::shared_ptr<Preserved> PBSUnknown2AsPreservedWithGraph(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::shared_ptr<Preserved>> PBSUnknown2AsPreservedWithGraphAsync(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    PBSUnknown2AsPreservedWithGraphAsync(::std::function<void(::std::shared_ptr<::Test::Preserved>)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_PBSUnknown2AsPreservedWithGraph(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<Preserved>>>&, const ::Ice::Context&) const;
    /// \endcond

    void checkPBSUnknown2WithGraph(const ::std::shared_ptr<Preserved>& p, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<void> checkPBSUnknown2WithGraphAsync(const ::std::shared_ptr<Preserved>& p, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    checkPBSUnknown2WithGraphAsync(const ::std::shared_ptr<Preserved>& p, ::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_checkPBSUnknown2WithGraph(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::shared_ptr<Preserved>&, const ::Ice::Context&) const;
    /// \endcond

    ::std::shared_ptr<PNode> exchangePNode(const ::std::shared_ptr<PNode>& pn, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<::std::shared_ptr<PNode>> exchangePNodeAsync(const ::std::shared_ptr<PNode>& pn, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    exchangePNodeAsync(const ::std::shared_ptr<PNode>& pn, ::std::function<void(::std::shared_ptr<::Test::PNode>)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_exchangePNode(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<PNode>>>&, const ::std::shared_ptr<PNode>&, const ::Ice::Context&) const;
    /// \endcond

    void throwBaseAsBase(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<void> throwBaseAsBaseAsync(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    throwBaseAsBaseAsync(::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_throwBaseAsBase(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&) const;
    /// \endcond

    void throwDerivedAsBase(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<void> throwDerivedAsBaseAsync(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    throwDerivedAsBaseAsync(::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_throwDerivedAsBase(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&) const;
    /// \endcond

    void throwDerivedAsDerived(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<void> throwDerivedAsDerivedAsync(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    throwDerivedAsDerivedAsync(::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_throwDerivedAsDerived(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&) const;
    /// \endcond

    void throwUnknownDerivedAsBase(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<void> throwUnknownDerivedAsBaseAsync(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    throwUnknownDerivedAsBaseAsync(::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_throwUnknownDerivedAsBase(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&) const;
    /// \endcond

    void throwPreservedException(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<void> throwPreservedExceptionAsync(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    throwPreservedExceptionAsync(::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_throwPreservedException(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&) const;
    /// \endcond

    /**
     * Use of forward-declared class to verify that code is generated correctly.
     * @param context The Context map to send with the invocation.
     */
    void useForward(::std::shared_ptr<Forward>& f, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Use of forward-declared class to verify that code is generated correctly.
     * @param context The Context map to send with the invocation.
     * @return The future object for the invocation.
     */
    ::std::future<::std::shared_ptr<Forward>> useForwardAsync(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /**
     * Use of forward-declared class to verify that code is generated correctly.
     * @param response The response callback.
     * @param ex The exception callback.
     * @param sent The sent callback.
     * @param context The Context map to send with the invocation.
     * @return A function that can be called to cancel the invocation locally.
     */
    ::std::function<void()>
    useForwardAsync(::std::function<void(::std::shared_ptr<::Test::Forward>)> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_useForward(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<Forward>>>&, const ::Ice::Context&) const;
    /// \endcond

    void shutdown(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::future<void> shutdownAsync(const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    ::std::function<void()>
    shutdownAsync(::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex = nullptr, ::std::function<void(bool)> sent = nullptr, const ::Ice::Context& context = ::Ice::noExplicitContext) const;

    /// \cond INTERNAL
    void _iceI_shutdown(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&) const;
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId();

    explicit TestIntfPrx(const ::Ice::ObjectPrx& other) : ::Ice::ObjectPrx(other)
    {
    }

    TestIntfPrx(const TestIntfPrx& other) noexcept : ::Ice::ObjectPrx(other)
    {
    }

    TestIntfPrx(TestIntfPrx&& other) noexcept : ::Ice::ObjectPrx(::std::move(other))
    {
    }

    TestIntfPrx(const ::std::shared_ptr<::Ice::Communicator>& communicator, const ::std::string& proxyString) :
        ::Ice::ObjectPrx(communicator, proxyString)
    {
    }

    TestIntfPrx& operator=(const TestIntfPrx& rhs) noexcept
    {
        ::Ice::ObjectPrx::operator=(rhs);
        return *this;
    }

    TestIntfPrx& operator=(TestIntfPrx&& rhs) noexcept
    {
        ::Ice::ObjectPrx::operator=(::std::move(rhs));
        return *this;
    }

    /// \cond INTERNAL
    static TestIntfPrx _fromReference(::IceInternal::ReferencePtr ref) { return TestIntfPrx(::std::move(ref)); }

protected:

    TestIntfPrx() = default;

    explicit TestIntfPrx(::IceInternal::ReferencePtr&& ref) : ::Ice::ObjectPrx(::std::move(ref))
    {
    }
    /// \endcond
};

}

namespace Test
{

class SBase : public ::Ice::ValueHelper<SBase, ::Ice::Value>
{
public:

    virtual ~SBase();

    SBase() = default;

    SBase(const SBase&) = default;
    SBase(SBase&&) = default;
    SBase& operator=(const SBase&) = default;
    SBase& operator=(SBase&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit SBase(::std::string_view sb) :
        sb(sb)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&> ice_tuple() const
    {
        return std::tie(sb);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId();

    ::std::string sb;
};

/// \cond INTERNAL
static SBase _iceS_SBase_init;
/// \endcond

class SBSKnownDerived : public ::Ice::ValueHelper<SBSKnownDerived, SBase>
{
public:

    virtual ~SBSKnownDerived();

    SBSKnownDerived() = default;

    SBSKnownDerived(const SBSKnownDerived&) = default;
    SBSKnownDerived(SBSKnownDerived&&) = default;
    SBSKnownDerived& operator=(const SBSKnownDerived&) = default;
    SBSKnownDerived& operator=(SBSKnownDerived&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    SBSKnownDerived(::std::string_view sb, ::std::string_view sbskd) :
        Ice::ValueHelper<SBSKnownDerived, SBase>(sb),
        sbskd(sbskd)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::std::string&> ice_tuple() const
    {
        return std::tie(sb, sbskd);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId();

    ::std::string sbskd;
};

class B : public ::Ice::ValueHelper<B, ::Ice::Value>
{
public:

    virtual ~B();

    B() = default;

    B(const B&) = default;
    B(B&&) = default;
    B& operator=(const B&) = default;
    B& operator=(B&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    B(::std::string_view sb, const ::std::shared_ptr<::Test::B>& pb) :
        sb(sb),
        pb(pb)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::std::shared_ptr<::Test::B>&> ice_tuple() const
    {
        return std::tie(sb, pb);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId();

    ::std::string sb;
    ::std::shared_ptr<::Test::B> pb;
};

class D1 : public ::Ice::ValueHelper<D1, B>
{
public:

    virtual ~D1();

    D1() = default;

    D1(const D1&) = default;
    D1(D1&&) = default;
    D1& operator=(const D1&) = default;
    D1& operator=(D1&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    D1(::std::string_view sb, const ::std::shared_ptr<::Test::B>& pb, ::std::string_view sd1, const ::std::shared_ptr<::Test::B>& pd1) :
        Ice::ValueHelper<D1, B>(sb, pb),
        sd1(sd1),
        pd1(pd1)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::std::shared_ptr<::Test::B>&, const ::std::string&, const ::std::shared_ptr<::Test::B>&> ice_tuple() const
    {
        return std::tie(sb, pb, sd1, pd1);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId();

    ::std::string sd1;
    ::std::shared_ptr<::Test::B> pd1;
};

class SS1 : public ::Ice::ValueHelper<SS1, ::Ice::Value>
{
public:

    virtual ~SS1();

    SS1() = default;

    SS1(const SS1&) = default;
    SS1(SS1&&) = default;
    SS1& operator=(const SS1&) = default;
    SS1& operator=(SS1&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit SS1(const ::Test::BSeq& s) :
        s(s)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::Test::BSeq&> ice_tuple() const
    {
        return std::tie(s);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId();

    ::Test::BSeq s;
};

class SS2 : public ::Ice::ValueHelper<SS2, ::Ice::Value>
{
public:

    virtual ~SS2();

    SS2() = default;

    SS2(const SS2&) = default;
    SS2(SS2&&) = default;
    SS2& operator=(const SS2&) = default;
    SS2& operator=(SS2&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit SS2(const ::Test::BSeq& s) :
        s(s)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::Test::BSeq&> ice_tuple() const
    {
        return std::tie(s);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId();

    ::Test::BSeq s;
};

struct SS3
{
    ::std::shared_ptr<::Test::SS1> c1;
    ::std::shared_ptr<::Test::SS2> c2;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::shared_ptr<::Test::SS1>&, const ::std::shared_ptr<::Test::SS2>&> ice_tuple() const
    {
        return std::tie(c1, c2);
    }
};

class BaseException : public ::Ice::UserExceptionHelper<BaseException, ::Ice::UserException>
{
public:

    virtual ~BaseException();

    BaseException(const BaseException&) = default;

    BaseException() = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    BaseException(::std::string_view sbe, const ::std::shared_ptr<B>& pb) :
        sbe(sbe),
        pb(pb)
    {
    }

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::std::shared_ptr<::Test::B>&> ice_tuple() const
    {
        return std::tie(sbe, pb);
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId();

    /// \cond STREAM
    virtual bool _usesClasses() const override;
    /// \endcond

    ::std::string sbe;
    ::std::shared_ptr<::Test::B> pb;
};

class DerivedException : public ::Ice::UserExceptionHelper<DerivedException, BaseException>
{
public:

    virtual ~DerivedException();

    DerivedException(const DerivedException&) = default;

    DerivedException() = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    DerivedException(::std::string_view sbe, const ::std::shared_ptr<B>& pb, ::std::string_view sde, const ::std::shared_ptr<D1>& pd1) :
        ::Ice::UserExceptionHelper<DerivedException, BaseException>(sbe, pb),
        sde(sde),
        pd1(pd1)
    {
    }

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::std::shared_ptr<::Test::B>&, const ::std::string&, const ::std::shared_ptr<::Test::D1>&> ice_tuple() const
    {
        return std::tie(sbe, pb, sde, pd1);
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId();

    ::std::string sde;
    ::std::shared_ptr<::Test::D1> pd1;
};

class PBase : public ::Ice::ValueHelper<PBase, ::Ice::Value>
{
public:

    virtual ~PBase();

    PBase() = default;

    PBase(const PBase&) = default;
    PBase(PBase&&) = default;
    PBase& operator=(const PBase&) = default;
    PBase& operator=(PBase&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit PBase(::std::int32_t pi) :
        pi(pi)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::int32_t&> ice_tuple() const
    {
        return std::tie(pi);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId();

    ::std::int32_t pi;
};

class Preserved : public ::Ice::ValueHelper<Preserved, PBase>
{
public:

    virtual ~Preserved();

    Preserved() = default;

    Preserved(const Preserved&) = default;
    Preserved(Preserved&&) = default;
    Preserved& operator=(const Preserved&) = default;
    Preserved& operator=(Preserved&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    Preserved(::std::int32_t pi, ::std::string_view ps) :
        Ice::ValueHelper<Preserved, PBase>(pi),
        ps(ps)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::int32_t&, const ::std::string&> ice_tuple() const
    {
        return std::tie(pi, ps);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId();

    /**
     * Obtains the SlicedData object created when an unknown value type was marshaled
     * in the sliced format and the Ice run time sliced it to a known type.
     * @return The SlicedData object, or nil if the value was not sliced or was not
     * marshaled in the sliced format.
     */
    virtual ::std::shared_ptr<::Ice::SlicedData> ice_getSlicedData() const override;

    /// \cond STREAM
    virtual void _iceWrite(::Ice::OutputStream*) const override;
    virtual void _iceRead(::Ice::InputStream*) override;
    /// \endcond

    ::std::string ps;

protected:

    /// \cond STREAM
    ::std::shared_ptr<::Ice::SlicedData> _iceSlicedData;
    /// \endcond
};

class PDerived : public ::Ice::ValueHelper<PDerived, Preserved>
{
public:

    virtual ~PDerived();

    PDerived() = default;

    PDerived(const PDerived&) = default;
    PDerived(PDerived&&) = default;
    PDerived& operator=(const PDerived&) = default;
    PDerived& operator=(PDerived&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    PDerived(::std::int32_t pi, ::std::string_view ps, const ::std::shared_ptr<::Test::PBase>& pb) :
        Ice::ValueHelper<PDerived, Preserved>(pi, ps),
        pb(pb)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::int32_t&, const ::std::string&, const ::std::shared_ptr<::Test::PBase>&> ice_tuple() const
    {
        return std::tie(pi, ps, pb);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId();

    ::std::shared_ptr<::Test::PBase> pb;
};

class CompactPDerived : public ::Ice::ValueHelper<CompactPDerived, Preserved>
{
public:

    virtual ~CompactPDerived();

    CompactPDerived() = default;

    CompactPDerived(const CompactPDerived&) = default;
    CompactPDerived(CompactPDerived&&) = default;
    CompactPDerived& operator=(const CompactPDerived&) = default;
    CompactPDerived& operator=(CompactPDerived&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    CompactPDerived(::std::int32_t pi, ::std::string_view ps, const ::std::shared_ptr<::Test::PBase>& pb) :
        Ice::ValueHelper<CompactPDerived, Preserved>(pi, ps),
        pb(pb)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::int32_t&, const ::std::string&, const ::std::shared_ptr<::Test::PBase>&> ice_tuple() const
    {
        return std::tie(pi, ps, pb);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId();

    ::std::shared_ptr<::Test::PBase> pb;
};

class PNode : public ::Ice::ValueHelper<PNode, ::Ice::Value>
{
public:

    virtual ~PNode();

    PNode() = default;

    PNode(const PNode&) = default;
    PNode(PNode&&) = default;
    PNode& operator=(const PNode&) = default;
    PNode& operator=(PNode&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit PNode(const ::std::shared_ptr<::Test::PNode>& next) :
        next(next)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::shared_ptr<::Test::PNode>&> ice_tuple() const
    {
        return std::tie(next);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId();

    /**
     * Obtains the SlicedData object created when an unknown value type was marshaled
     * in the sliced format and the Ice run time sliced it to a known type.
     * @return The SlicedData object, or nil if the value was not sliced or was not
     * marshaled in the sliced format.
     */
    virtual ::std::shared_ptr<::Ice::SlicedData> ice_getSlicedData() const override;

    /// \cond STREAM
    virtual void _iceWrite(::Ice::OutputStream*) const override;
    virtual void _iceRead(::Ice::InputStream*) override;
    /// \endcond

    ::std::shared_ptr<::Test::PNode> next;

protected:

    /// \cond STREAM
    ::std::shared_ptr<::Ice::SlicedData> _iceSlicedData;
    /// \endcond
};

class PreservedException : public ::Ice::UserExceptionHelper<PreservedException, ::Ice::UserException>
{
public:

    virtual ~PreservedException();

    PreservedException(const PreservedException&) = default;

    PreservedException() = default;

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<> ice_tuple() const
    {
        return std::tie();
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId();

    /**
     * Obtains the SlicedData object created when an unknown exception type was marshaled
     * in the sliced format and the Ice run time sliced it to a known type.
     * @return The SlicedData object, or nil if the exception was not sliced or was not
     * marshaled in the sliced format.
     */
    virtual ::std::shared_ptr<::Ice::SlicedData> ice_getSlicedData() const override;

    /// \cond STREAM
    virtual void _write(::Ice::OutputStream*) const override;
    virtual void _read(::Ice::InputStream*) override;

    ::std::shared_ptr<::Ice::SlicedData> _slicedData;
    /// \endcond
};

class D3 : public ::Ice::ValueHelper<D3, B>
{
public:

    virtual ~D3();

    D3() = default;

    D3(const D3&) = default;
    D3(D3&&) = default;
    D3& operator=(const D3&) = default;
    D3& operator=(D3&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    D3(::std::string_view sb, const ::std::shared_ptr<::Test::B>& pb, ::std::string_view sd3, const ::std::shared_ptr<::Test::B>& pd3) :
        Ice::ValueHelper<D3, B>(sb, pb),
        sd3(sd3),
        pd3(pd3)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::std::shared_ptr<::Test::B>&, const ::std::string&, const ::std::shared_ptr<::Test::B>&> ice_tuple() const
    {
        return std::tie(sb, pb, sd3, pd3);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId();

    ::std::string sd3;
    ::std::shared_ptr<::Test::B> pd3;
};

class PCUnknown : public ::Ice::ValueHelper<PCUnknown, PBase>
{
public:

    virtual ~PCUnknown();

    PCUnknown() = default;

    PCUnknown(const PCUnknown&) = default;
    PCUnknown(PCUnknown&&) = default;
    PCUnknown& operator=(const PCUnknown&) = default;
    PCUnknown& operator=(PCUnknown&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    PCUnknown(::std::int32_t pi, ::std::string_view pu) :
        Ice::ValueHelper<PCUnknown, PBase>(pi),
        pu(pu)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::int32_t&, const ::std::string&> ice_tuple() const
    {
        return std::tie(pi, pu);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId();

    /**
     * Obtains the SlicedData object created when an unknown value type was marshaled
     * in the sliced format and the Ice run time sliced it to a known type.
     * @return The SlicedData object, or nil if the value was not sliced or was not
     * marshaled in the sliced format.
     */
    virtual ::std::shared_ptr<::Ice::SlicedData> ice_getSlicedData() const override;

    /// \cond STREAM
    virtual void _iceWrite(::Ice::OutputStream*) const override;
    virtual void _iceRead(::Ice::InputStream*) override;
    /// \endcond

    ::std::string pu;

protected:

    /// \cond STREAM
    ::std::shared_ptr<::Ice::SlicedData> _iceSlicedData;
    /// \endcond
};

class PCDerived : public ::Ice::ValueHelper<PCDerived, PDerived>
{
public:

    virtual ~PCDerived();

    PCDerived() = default;

    PCDerived(const PCDerived&) = default;
    PCDerived(PCDerived&&) = default;
    PCDerived& operator=(const PCDerived&) = default;
    PCDerived& operator=(PCDerived&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    PCDerived(::std::int32_t pi, ::std::string_view ps, const ::std::shared_ptr<::Test::PBase>& pb, const ::Test::PBaseSeq& pbs) :
        Ice::ValueHelper<PCDerived, PDerived>(pi, ps, pb),
        pbs(pbs)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::int32_t&, const ::std::string&, const ::std::shared_ptr<::Test::PBase>&, const ::Test::PBaseSeq&> ice_tuple() const
    {
        return std::tie(pi, ps, pb, pbs);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId();

    ::Test::PBaseSeq pbs;
};

class PCDerived2 : public ::Ice::ValueHelper<PCDerived2, PCDerived>
{
public:

    virtual ~PCDerived2();

    PCDerived2() = default;

    PCDerived2(const PCDerived2&) = default;
    PCDerived2(PCDerived2&&) = default;
    PCDerived2& operator=(const PCDerived2&) = default;
    PCDerived2& operator=(PCDerived2&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    PCDerived2(::std::int32_t pi, ::std::string_view ps, const ::std::shared_ptr<::Test::PBase>& pb, const ::Test::PBaseSeq& pbs, ::std::int32_t pcd2) :
        Ice::ValueHelper<PCDerived2, PCDerived>(pi, ps, pb, pbs),
        pcd2(pcd2)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::int32_t&, const ::std::string&, const ::std::shared_ptr<::Test::PBase>&, const ::Test::PBaseSeq&, const ::std::int32_t&> ice_tuple() const
    {
        return std::tie(pi, ps, pb, pbs, pcd2);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId();

    ::std::int32_t pcd2;
};

class PCDerived3 : public ::Ice::ValueHelper<PCDerived3, PCDerived2>
{
public:

    virtual ~PCDerived3();

    PCDerived3() = default;

    PCDerived3(const PCDerived3&) = default;
    PCDerived3(PCDerived3&&) = default;
    PCDerived3& operator=(const PCDerived3&) = default;
    PCDerived3& operator=(PCDerived3&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    PCDerived3(::std::int32_t pi, ::std::string_view ps, const ::std::shared_ptr<::Test::PBase>& pb, const ::Test::PBaseSeq& pbs, ::std::int32_t pcd2, const ::std::shared_ptr<::Ice::Value>& pcd3) :
        Ice::ValueHelper<PCDerived3, PCDerived2>(pi, ps, pb, pbs, pcd2),
        pcd3(pcd3)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::int32_t&, const ::std::string&, const ::std::shared_ptr<::Test::PBase>&, const ::Test::PBaseSeq&, const ::std::int32_t&, const ::std::shared_ptr<::Ice::Value>&> ice_tuple() const
    {
        return std::tie(pi, ps, pb, pbs, pcd2, pcd3);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId();

    ::std::shared_ptr<::Ice::Value> pcd3;
};

class CompactPCDerived : public ::Ice::ValueHelper<CompactPCDerived, CompactPDerived>
{
public:

    virtual ~CompactPCDerived();

    CompactPCDerived() = default;

    CompactPCDerived(const CompactPCDerived&) = default;
    CompactPCDerived(CompactPCDerived&&) = default;
    CompactPCDerived& operator=(const CompactPCDerived&) = default;
    CompactPCDerived& operator=(CompactPCDerived&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    CompactPCDerived(::std::int32_t pi, ::std::string_view ps, const ::std::shared_ptr<::Test::PBase>& pb, const ::Test::PBaseSeq& pbs) :
        Ice::ValueHelper<CompactPCDerived, CompactPDerived>(pi, ps, pb),
        pbs(pbs)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::int32_t&, const ::std::string&, const ::std::shared_ptr<::Test::PBase>&, const ::Test::PBaseSeq&> ice_tuple() const
    {
        return std::tie(pi, ps, pb, pbs);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId();

    ::Test::PBaseSeq pbs;
};

class Hidden : public ::Ice::ValueHelper<Hidden, ::Ice::Value>
{
public:

    virtual ~Hidden();

    Hidden() = default;

    Hidden(const Hidden&) = default;
    Hidden(Hidden&&) = default;
    Hidden& operator=(const Hidden&) = default;
    Hidden& operator=(Hidden&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit Hidden(const ::std::shared_ptr<::Test::Forward>& f) :
        f(f)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::shared_ptr<::Test::Forward>&> ice_tuple() const
    {
        return std::tie(f);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId();

    ::std::shared_ptr<::Test::Forward> f;
};

class Forward : public ::Ice::ValueHelper<Forward, ::Ice::Value>
{
public:

    virtual ~Forward();

    Forward() = default;

    Forward(const Forward&) = default;
    Forward(Forward&&) = default;
    Forward& operator=(const Forward&) = default;
    Forward& operator=(Forward&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit Forward(const ::std::shared_ptr<::Test::Hidden>& h) :
        h(h)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::shared_ptr<::Test::Hidden>&> ice_tuple() const
    {
        return std::tie(h);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId();

    ::std::shared_ptr<::Test::Hidden> h;
};

using Ice::operator<;
using Ice::operator<=;
using Ice::operator>;
using Ice::operator>=;
using Ice::operator==;
using Ice::operator!=;

}

namespace Test
{

class TestIntf : public virtual ::Ice::Object
{
public:

    using ProxyType = TestIntfPrx;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static ::std::string_view ice_staticId();

    virtual ::std::shared_ptr<::Ice::Value> SBaseAsObject(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_SBaseAsObject(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::std::shared_ptr<SBase> SBaseAsSBase(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_SBaseAsSBase(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::std::shared_ptr<SBase> SBSKnownDerivedAsSBase(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_SBSKnownDerivedAsSBase(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::std::shared_ptr<SBSKnownDerived> SBSKnownDerivedAsSBSKnownDerived(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_SBSKnownDerivedAsSBSKnownDerived(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::std::shared_ptr<SBase> SBSUnknownDerivedAsSBase(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_SBSUnknownDerivedAsSBase(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::std::shared_ptr<SBase> SBSUnknownDerivedAsSBaseCompact(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_SBSUnknownDerivedAsSBaseCompact(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::std::shared_ptr<::Ice::Value> SUnknownAsObject(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_SUnknownAsObject(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void checkSUnknown(::std::shared_ptr<::Ice::Value> o, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_checkSUnknown(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::std::shared_ptr<B> oneElementCycle(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_oneElementCycle(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::std::shared_ptr<B> twoElementCycle(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_twoElementCycle(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::std::shared_ptr<B> D1AsB(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_D1AsB(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::std::shared_ptr<D1> D1AsD1(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_D1AsD1(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::std::shared_ptr<B> D2AsB(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_D2AsB(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void paramTest1(::std::shared_ptr<B>& p1, ::std::shared_ptr<B>& p2, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_paramTest1(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void paramTest2(::std::shared_ptr<B>& p2, ::std::shared_ptr<B>& p1, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_paramTest2(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::std::shared_ptr<B> paramTest3(::std::shared_ptr<B>& p1, ::std::shared_ptr<B>& p2, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_paramTest3(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::std::shared_ptr<B> paramTest4(::std::shared_ptr<B>& p, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_paramTest4(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::std::shared_ptr<B> returnTest1(::std::shared_ptr<B>& p1, ::std::shared_ptr<B>& p2, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_returnTest1(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::std::shared_ptr<B> returnTest2(::std::shared_ptr<B>& p2, ::std::shared_ptr<B>& p1, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_returnTest2(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::std::shared_ptr<B> returnTest3(::std::shared_ptr<B> p1, ::std::shared_ptr<B> p2, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_returnTest3(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual SS3 sequenceTest(::std::shared_ptr<SS1> p1, ::std::shared_ptr<SS2> p2, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_sequenceTest(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual BDict dictionaryTest(BDict bin, BDict& bout, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_dictionaryTest(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::std::shared_ptr<PBase> exchangePBase(::std::shared_ptr<PBase> pb, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_exchangePBase(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::std::shared_ptr<Preserved> PBSUnknownAsPreserved(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_PBSUnknownAsPreserved(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void checkPBSUnknown(::std::shared_ptr<Preserved> p, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_checkPBSUnknown(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void PBSUnknownAsPreservedWithGraphAsync(::std::function<void(const ::std::shared_ptr<Preserved>& returnValue)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_PBSUnknownAsPreservedWithGraph(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void checkPBSUnknownWithGraph(::std::shared_ptr<Preserved> p, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_checkPBSUnknownWithGraph(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void PBSUnknown2AsPreservedWithGraphAsync(::std::function<void(const ::std::shared_ptr<Preserved>& returnValue)> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_PBSUnknown2AsPreservedWithGraph(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void checkPBSUnknown2WithGraph(::std::shared_ptr<Preserved> p, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_checkPBSUnknown2WithGraph(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::std::shared_ptr<PNode> exchangePNode(::std::shared_ptr<PNode> pn, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_exchangePNode(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void throwBaseAsBase(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_throwBaseAsBase(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void throwDerivedAsBase(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_throwDerivedAsBase(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void throwDerivedAsDerived(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_throwDerivedAsDerived(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void throwUnknownDerivedAsBase(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_throwUnknownDerivedAsBase(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void throwPreservedExceptionAsync(::std::function<void()> response, ::std::function<void(::std::exception_ptr)> exception, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_throwPreservedException(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Use of forward-declared class to verify that code is generated correctly.
     * @param current The Current object for the invocation.
     */
    virtual void useForward(::std::shared_ptr<Forward>& f, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_useForward(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void shutdown(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_shutdown(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

using TestIntfPtr = ::std::shared_ptr<TestIntf>;

}

/// \cond STREAM
namespace Ice
{

template<typename S>
struct StreamReader<::Test::SBase, S>
{
    static void read(S* istr, ::Test::SBase& v)
    {
        istr->readAll(v.sb);
    }
};

template<typename S>
struct StreamWriter<::Test::SBSKnownDerived, S>
{
    static void write(S* ostr, const ::Test::SBSKnownDerived& v)
    {
        ostr->writeAll(v.sbskd);
    }
};

template<typename S>
struct StreamReader<::Test::SBSKnownDerived, S>
{
    static void read(S* istr, ::Test::SBSKnownDerived& v)
    {
        istr->readAll(v.sbskd);
    }
};

template<typename S>
struct StreamReader<::Test::B, S>
{
    static void read(S* istr, ::Test::B& v)
    {
        istr->readAll(v.sb, v.pb);
    }
};

template<typename S>
struct StreamWriter<::Test::D1, S>
{
    static void write(S* ostr, const ::Test::D1& v)
    {
        ostr->writeAll(v.sd1, v.pd1);
    }
};

template<typename S>
struct StreamReader<::Test::D1, S>
{
    static void read(S* istr, ::Test::D1& v)
    {
        istr->readAll(v.sd1, v.pd1);
    }
};

template<typename S>
struct StreamReader<::Test::SS1, S>
{
    static void read(S* istr, ::Test::SS1& v)
    {
        istr->readAll(v.s);
    }
};

template<typename S>
struct StreamReader<::Test::SS2, S>
{
    static void read(S* istr, ::Test::SS2& v)
    {
        istr->readAll(v.s);
    }
};

template<>
struct StreamableTraits<::Test::SS3>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 2;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::Test::SS3, S>
{
    static void read(S* istr, ::Test::SS3& v)
    {
        istr->readAll(v.c1, v.c2);
    }
};

template<typename S>
struct StreamReader<::Test::BaseException, S>
{
    static void read(S* istr, ::Test::BaseException& v)
    {
        istr->readAll(v.sbe, v.pb);
    }
};

template<typename S>
struct StreamWriter<::Test::DerivedException, S>
{
    static void write(S* ostr, const ::Test::DerivedException& v)
    {
        ostr->writeAll(v.sde, v.pd1);
    }
};

template<typename S>
struct StreamReader<::Test::DerivedException, S>
{
    static void read(S* istr, ::Test::DerivedException& v)
    {
        istr->readAll(v.sde, v.pd1);
    }
};

template<typename S>
struct StreamReader<::Test::PBase, S>
{
    static void read(S* istr, ::Test::PBase& v)
    {
        istr->readAll(v.pi);
    }
};

template<typename S>
struct StreamWriter<::Test::Preserved, S>
{
    static void write(S* ostr, const ::Test::Preserved& v)
    {
        ostr->writeAll(v.ps);
    }
};

template<typename S>
struct StreamReader<::Test::Preserved, S>
{
    static void read(S* istr, ::Test::Preserved& v)
    {
        istr->readAll(v.ps);
    }
};

template<typename S>
struct StreamWriter<::Test::PDerived, S>
{
    static void write(S* ostr, const ::Test::PDerived& v)
    {
        ostr->writeAll(v.pb);
    }
};

template<typename S>
struct StreamReader<::Test::PDerived, S>
{
    static void read(S* istr, ::Test::PDerived& v)
    {
        istr->readAll(v.pb);
    }
};

template<typename S>
struct StreamWriter<::Test::CompactPDerived, S>
{
    static void write(S* ostr, const ::Test::CompactPDerived& v)
    {
        ostr->writeAll(v.pb);
    }
};

template<typename S>
struct StreamReader<::Test::CompactPDerived, S>
{
    static void read(S* istr, ::Test::CompactPDerived& v)
    {
        istr->readAll(v.pb);
    }
};

template<typename S>
struct StreamReader<::Test::PNode, S>
{
    static void read(S* istr, ::Test::PNode& v)
    {
        istr->readAll(v.next);
    }
};

template<typename S>
struct StreamWriter<::Test::D3, S>
{
    static void write(S* ostr, const ::Test::D3& v)
    {
        ostr->writeAll(v.sd3, v.pd3);
    }
};

template<typename S>
struct StreamReader<::Test::D3, S>
{
    static void read(S* istr, ::Test::D3& v)
    {
        istr->readAll(v.sd3, v.pd3);
    }
};

template<typename S>
struct StreamWriter<::Test::PCUnknown, S>
{
    static void write(S* ostr, const ::Test::PCUnknown& v)
    {
        ostr->writeAll(v.pu);
    }
};

template<typename S>
struct StreamReader<::Test::PCUnknown, S>
{
    static void read(S* istr, ::Test::PCUnknown& v)
    {
        istr->readAll(v.pu);
    }
};

template<typename S>
struct StreamWriter<::Test::PCDerived, S>
{
    static void write(S* ostr, const ::Test::PCDerived& v)
    {
        ostr->writeAll(v.pbs);
    }
};

template<typename S>
struct StreamReader<::Test::PCDerived, S>
{
    static void read(S* istr, ::Test::PCDerived& v)
    {
        istr->readAll(v.pbs);
    }
};

template<typename S>
struct StreamWriter<::Test::PCDerived2, S>
{
    static void write(S* ostr, const ::Test::PCDerived2& v)
    {
        ostr->writeAll(v.pcd2);
    }
};

template<typename S>
struct StreamReader<::Test::PCDerived2, S>
{
    static void read(S* istr, ::Test::PCDerived2& v)
    {
        istr->readAll(v.pcd2);
    }
};

template<typename S>
struct StreamWriter<::Test::PCDerived3, S>
{
    static void write(S* ostr, const ::Test::PCDerived3& v)
    {
        ostr->writeAll(v.pcd3);
    }
};

template<typename S>
struct StreamReader<::Test::PCDerived3, S>
{
    static void read(S* istr, ::Test::PCDerived3& v)
    {
        istr->readAll(v.pcd3);
    }
};

template<typename S>
struct StreamWriter<::Test::CompactPCDerived, S>
{
    static void write(S* ostr, const ::Test::CompactPCDerived& v)
    {
        ostr->writeAll(v.pbs);
    }
};

template<typename S>
struct StreamReader<::Test::CompactPCDerived, S>
{
    static void read(S* istr, ::Test::CompactPCDerived& v)
    {
        istr->readAll(v.pbs);
    }
};

template<typename S>
struct StreamReader<::Test::Hidden, S>
{
    static void read(S* istr, ::Test::Hidden& v)
    {
        istr->readAll(v.f);
    }
};

template<typename S>
struct StreamReader<::Test::Forward, S>
{
    static void read(S* istr, ::Test::Forward& v)
    {
        istr->readAll(v.h);
    }
};

}
/// \endcond

#include <IceUtil/PopDisableWarnings.h>
#endif
