//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.8.0-alpha.0
//
// <auto-generated>
//
// Generated from file `Test.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __Test_h__
#define __Test_h__

#include <IceUtil/PushDisableWarnings.h>
#include <Ice/Ice.h>
#include <IceUtil/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION  != 30850
#       error Ice version mismatch: an exact match is required for beta generated code
#   endif
#endif

namespace Test
{


enum class Color : unsigned char
{
    red,
    green,
    blue
};

namespace Nested
{


enum class Color : unsigned char
{
    red,
    green,
    blue
};

}
struct Struct1;

constexpr bool ConstBool = true;

constexpr ::std::uint8_t ConstByte = 254;

constexpr ::std::int16_t ConstShort = 16000;

constexpr ::std::int32_t ConstInt = 3;

constexpr ::std::int64_t ConstLong = INT64_C(4);

constexpr float ConstFloat = 5.1F;

constexpr double ConstDouble = 6.2;

const ::std::string ConstString = "foo \\ \"bar\n \r\n\t\v\f\a\b\? \a \a";

constexpr Color ConstColor1 = ::Test::Color::red;

constexpr Color ConstColor2 = ::Test::Color::green;

constexpr Color ConstColor3 = ::Test::Color::blue;

constexpr ::Test::Nested::Color ConstNestedColor1 = ::Test::Nested::Color::red;

constexpr ::Test::Nested::Color ConstNestedColor2 = ::Test::Nested::Color::green;

constexpr ::Test::Nested::Color ConstNestedColor3 = ::Test::Nested::Color::blue;

constexpr ::std::int32_t ConstZeroI = 0;

constexpr ::std::int64_t ConstZeroL = INT64_C(0);

constexpr float ConstZeroF = 0.0F;

constexpr float ConstZeroDotF = 0.0F;

constexpr double ConstZeroD = 0;

constexpr double ConstZeroDotD = 0;
struct Struct2;
class Base;

using BasePtr = ::std::shared_ptr<Base>;
class Derived;

using DerivedPtr = ::std::shared_ptr<Derived>;

using ByteSeq = ::std::vector<std::byte>;

using IntSeq = ::std::vector<::std::int32_t>;

using IntStringDict = ::std::map<::std::int32_t, ::std::string>;
struct InnerStruct;
struct StructNoDefaults;
class ClassNoDefaultsBase;

using ClassNoDefaultsBasePtr = ::std::shared_ptr<ClassNoDefaultsBase>;
class ClassNoDefaults;

using ClassNoDefaultsPtr = ::std::shared_ptr<ClassNoDefaults>;

}

namespace Test
{

struct Struct1
{
    bool boolFalse = false;
    bool boolTrue = true;
    ::std::uint8_t b = 254;
    ::std::int16_t s = 16000;
    ::std::int32_t i = 3;
    ::std::int64_t l = INT64_C(4);
    float f = 5.1F;
    double d = 6.2;
    ::std::string str = "foo \\ \"bar\n \r\n\t\v\f\a\b\? \a \a";
    ::Test::Color c1 = ::Test::Color::red;
    ::Test::Color c2 = ::Test::Color::green;
    ::Test::Color c3 = ::Test::Color::blue;
    ::Test::Nested::Color nc1 = ::Test::Nested::Color::red;
    ::Test::Nested::Color nc2 = ::Test::Nested::Color::green;
    ::Test::Nested::Color nc3 = ::Test::Nested::Color::blue;
    ::std::string noDefault;
    ::std::int32_t zeroI = 0;
    ::std::int64_t zeroL = INT64_C(0);
    float zeroF = 0.0F;
    float zeroDotF = 0.0F;
    double zeroD = 0;
    double zeroDotD = 0;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const bool&, const bool&, const ::std::uint8_t&, const ::std::int16_t&, const ::std::int32_t&, const ::std::int64_t&, const float&, const double&, const ::std::string&, const ::Test::Color&, const ::Test::Color&, const ::Test::Color&, const ::Test::Nested::Color&, const ::Test::Nested::Color&, const ::Test::Nested::Color&, const ::std::string&, const ::std::int32_t&, const ::std::int64_t&, const float&, const float&, const double&, const double&> ice_tuple() const
    {
        return std::tie(boolFalse, boolTrue, b, s, i, l, f, d, str, c1, c2, c3, nc1, nc2, nc3, noDefault, zeroI, zeroL, zeroF, zeroDotF, zeroD, zeroDotD);
    }
};

struct Struct2
{
    bool boolTrue = ::Test::ConstBool;
    ::std::uint8_t b = ::Test::ConstByte;
    ::std::int16_t s = ::Test::ConstShort;
    ::std::int32_t i = ::Test::ConstInt;
    ::std::int64_t l = ::Test::ConstLong;
    float f = ::Test::ConstFloat;
    double d = ::Test::ConstDouble;
    ::std::string str = ::Test::ConstString;
    ::Test::Color c1 = ::Test::ConstColor1;
    ::Test::Color c2 = ::Test::ConstColor2;
    ::Test::Color c3 = ::Test::ConstColor3;
    ::Test::Nested::Color nc1 = ::Test::ConstNestedColor1;
    ::Test::Nested::Color nc2 = ::Test::ConstNestedColor2;
    ::Test::Nested::Color nc3 = ::Test::ConstNestedColor3;
    ::std::int32_t zeroI = ::Test::ConstZeroI;
    ::std::int64_t zeroL = ::Test::ConstZeroL;
    float zeroF = ::Test::ConstZeroF;
    float zeroDotF = ::Test::ConstZeroDotF;
    double zeroD = ::Test::ConstZeroD;
    double zeroDotD = ::Test::ConstZeroDotD;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const bool&, const ::std::uint8_t&, const ::std::int16_t&, const ::std::int32_t&, const ::std::int64_t&, const float&, const double&, const ::std::string&, const ::Test::Color&, const ::Test::Color&, const ::Test::Color&, const ::Test::Nested::Color&, const ::Test::Nested::Color&, const ::Test::Nested::Color&, const ::std::int32_t&, const ::std::int64_t&, const float&, const float&, const double&, const double&> ice_tuple() const
    {
        return std::tie(boolTrue, b, s, i, l, f, d, str, c1, c2, c3, nc1, nc2, nc3, zeroI, zeroL, zeroF, zeroDotF, zeroD, zeroDotD);
    }
};

class Base : public ::Ice::ValueHelper<Base, ::Ice::Value>
{
public:

    Base() = default;
    Base(const Base&) = default;
    Base(Base&&) = default;
    Base& operator=(const Base&) = default;
    Base& operator=(Base&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    Base(bool boolFalse, bool boolTrue, ::std::uint8_t b, ::std::int16_t s, ::std::int32_t i, ::std::int64_t l, float f, double d, ::std::string str, ::std::string noDefault, ::std::int32_t zeroI, ::std::int64_t zeroL, float zeroF, float zeroDotF, double zeroD, double zeroDotD) :
        boolFalse(boolFalse),
        boolTrue(boolTrue),
        b(b),
        s(s),
        i(i),
        l(l),
        f(f),
        d(d),
        str(::std::move(str)),
        noDefault(::std::move(noDefault)),
        zeroI(zeroI),
        zeroL(zeroL),
        zeroF(zeroF),
        zeroDotF(zeroDotF),
        zeroD(zeroD),
        zeroDotD(zeroDotD)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const bool&, const bool&, const ::std::uint8_t&, const ::std::int16_t&, const ::std::int32_t&, const ::std::int64_t&, const float&, const double&, const ::std::string&, const ::std::string&, const ::std::int32_t&, const ::std::int64_t&, const float&, const float&, const double&, const double&> ice_tuple() const
    {
        return std::tie(boolFalse, boolTrue, b, s, i, l, f, d, str, noDefault, zeroI, zeroL, zeroF, zeroDotF, zeroD, zeroDotD);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId() noexcept;

    bool boolFalse = false;
    bool boolTrue = true;
    ::std::uint8_t b = 1;
    ::std::int16_t s = 2;
    ::std::int32_t i = 3;
    ::std::int64_t l = INT64_C(4);
    float f = 5.1F;
    double d = 6.2;
    ::std::string str = "foo \\ \"bar\n \r\n\t\v\f\a\b\? \a \a";
    ::std::string noDefault;
    ::std::int32_t zeroI = 0;
    ::std::int64_t zeroL = INT64_C(0);
    float zeroF = 0.0F;
    float zeroDotF = 0.0F;
    double zeroD = 0;
    double zeroDotD = 0;
};

/// \cond INTERNAL
static Base _iceS_Base_init;
/// \endcond

class Derived : public ::Ice::ValueHelper<Derived, Base>
{
public:

    Derived() = default;
    Derived(const Derived&) = default;
    Derived(Derived&&) = default;
    Derived& operator=(const Derived&) = default;
    Derived& operator=(Derived&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    Derived(bool boolFalse, bool boolTrue, ::std::uint8_t b, ::std::int16_t s, ::std::int32_t i, ::std::int64_t l, float f, double d, ::std::string str, ::std::string noDefault, ::std::int32_t zeroI, ::std::int64_t zeroL, float zeroF, float zeroDotF, double zeroD, double zeroDotD, ::Test::Color c1, ::Test::Color c2, ::Test::Color c3, ::Test::Nested::Color nc1, ::Test::Nested::Color nc2, ::Test::Nested::Color nc3) :
        Ice::ValueHelper<Derived, Base>(boolFalse, boolTrue, b, s, i, l, f, d, ::std::move(str), ::std::move(noDefault), zeroI, zeroL, zeroF, zeroDotF, zeroD, zeroDotD),
        c1(c1),
        c2(c2),
        c3(c3),
        nc1(nc1),
        nc2(nc2),
        nc3(nc3)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const bool&, const bool&, const ::std::uint8_t&, const ::std::int16_t&, const ::std::int32_t&, const ::std::int64_t&, const float&, const double&, const ::std::string&, const ::std::string&, const ::std::int32_t&, const ::std::int64_t&, const float&, const float&, const double&, const double&, const ::Test::Color&, const ::Test::Color&, const ::Test::Color&, const ::Test::Nested::Color&, const ::Test::Nested::Color&, const ::Test::Nested::Color&> ice_tuple() const
    {
        return std::tie(boolFalse, boolTrue, b, s, i, l, f, d, str, noDefault, zeroI, zeroL, zeroF, zeroDotF, zeroD, zeroDotD, c1, c2, c3, nc1, nc2, nc3);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId() noexcept;

    ::Test::Color c1 = ::Test::Color::red;
    ::Test::Color c2 = ::Test::Color::green;
    ::Test::Color c3 = ::Test::Color::blue;
    ::Test::Nested::Color nc1 = ::Test::Nested::Color::red;
    ::Test::Nested::Color nc2 = ::Test::Nested::Color::green;
    ::Test::Nested::Color nc3 = ::Test::Nested::Color::blue;
};

class BaseEx : public ::Ice::UserException
{
public:
    using ::Ice::UserException::UserException;

    /**
     * One-shot constructor to initialize all data members.
     */
    BaseEx(bool boolFalse, bool boolTrue, ::std::uint8_t b, ::std::int16_t s, ::std::int32_t i, ::std::int64_t l, float f, double d, ::std::string str, ::std::string noDefault, ::std::int32_t zeroI, ::std::int64_t zeroL, float zeroF, float zeroDotF, double zeroD, double zeroDotD) noexcept :
        boolFalse(boolFalse),
        boolTrue(boolTrue),
        b(b),
        s(s),
        i(i),
        l(l),
        f(f),
        d(d),
        str(::std::move(str)),
        noDefault(::std::move(noDefault)),
        zeroI(zeroI),
        zeroL(zeroL),
        zeroF(zeroF),
        zeroDotF(zeroDotF),
        zeroD(zeroD),
        zeroDotD(zeroDotD)
    {
    }

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const bool&, const bool&, const ::std::uint8_t&, const ::std::int16_t&, const ::std::int32_t&, const ::std::int64_t&, const float&, const double&, const ::std::string&, const ::std::string&, const ::std::int32_t&, const ::std::int64_t&, const float&, const float&, const double&, const double&> ice_tuple() const
    {
        return std::tie(boolFalse, boolTrue, b, s, i, l, f, d, str, noDefault, zeroI, zeroL, zeroF, zeroDotF, zeroD, zeroDotD);
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId() noexcept;

    ::std::string ice_id() const override;

    void ice_throw() const override;

    bool boolFalse = false;
    bool boolTrue = true;
    ::std::uint8_t b = 1;
    ::std::int16_t s = 2;
    ::std::int32_t i = 3;
    ::std::int64_t l = INT64_C(4);
    float f = 5.1F;
    double d = 6.2;
    ::std::string str = "foo \\ \"bar\n \r\n\t\v\f\a\b\? \a \a";
    ::std::string noDefault;
    ::std::int32_t zeroI = 0;
    ::std::int64_t zeroL = INT64_C(0);
    float zeroF = 0.0F;
    float zeroDotF = 0.0F;
    double zeroD = 0;
    double zeroDotD = 0;

protected:
    void _writeImpl(::Ice::OutputStream*) const override;

    void _readImpl(::Ice::InputStream*) override;
};

class DerivedEx : public BaseEx
{
public:
    using BaseEx::BaseEx;

    /**
     * One-shot constructor to initialize all data members.
     */
    DerivedEx(bool boolFalse, bool boolTrue, ::std::uint8_t b, ::std::int16_t s, ::std::int32_t i, ::std::int64_t l, float f, double d, ::std::string str, ::std::string noDefault, ::std::int32_t zeroI, ::std::int64_t zeroL, float zeroF, float zeroDotF, double zeroD, double zeroDotD, Color c1, Color c2, Color c3, ::Test::Nested::Color nc1, ::Test::Nested::Color nc2, ::Test::Nested::Color nc3) noexcept :
        BaseEx(boolFalse, boolTrue, b, s, i, l, f, d, ::std::move(str), ::std::move(noDefault), zeroI, zeroL, zeroF, zeroDotF, zeroD, zeroDotD),
        c1(c1),
        c2(c2),
        c3(c3),
        nc1(nc1),
        nc2(nc2),
        nc3(nc3)
    {
    }

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const bool&, const bool&, const ::std::uint8_t&, const ::std::int16_t&, const ::std::int32_t&, const ::std::int64_t&, const float&, const double&, const ::std::string&, const ::std::string&, const ::std::int32_t&, const ::std::int64_t&, const float&, const float&, const double&, const double&, const ::Test::Color&, const ::Test::Color&, const ::Test::Color&, const ::Test::Nested::Color&, const ::Test::Nested::Color&, const ::Test::Nested::Color&> ice_tuple() const
    {
        return std::tie(boolFalse, boolTrue, b, s, i, l, f, d, str, noDefault, zeroI, zeroL, zeroF, zeroDotF, zeroD, zeroDotD, c1, c2, c3, nc1, nc2, nc3);
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId() noexcept;

    ::std::string ice_id() const override;

    void ice_throw() const override;

    ::Test::Color c1 = ::Test::ConstColor1;
    ::Test::Color c2 = ::Test::ConstColor2;
    ::Test::Color c3 = ::Test::ConstColor3;
    ::Test::Nested::Color nc1 = ::Test::ConstNestedColor1;
    ::Test::Nested::Color nc2 = ::Test::ConstNestedColor2;
    ::Test::Nested::Color nc3 = ::Test::ConstNestedColor3;

protected:
    void _writeImpl(::Ice::OutputStream*) const override;

    void _readImpl(::Ice::InputStream*) override;
};

struct InnerStruct
{
    ::std::int32_t a;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::int32_t&> ice_tuple() const
    {
        return std::tie(a);
    }
};

struct StructNoDefaults
{
    bool bo;
    ::std::uint8_t b;
    ::std::int16_t s;
    ::std::int32_t i;
    ::std::int64_t l;
    float f;
    double d;
    ::std::string str;
    ::Test::Color c1;
    ::Test::ByteSeq bs;
    ::Test::IntSeq is;
    ::Test::InnerStruct st;
    ::Test::IntStringDict dict;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const bool&, const ::std::uint8_t&, const ::std::int16_t&, const ::std::int32_t&, const ::std::int64_t&, const float&, const double&, const ::std::string&, const ::Test::Color&, const ::Test::ByteSeq&, const ::Test::IntSeq&, const ::Test::InnerStruct&, const ::Test::IntStringDict&> ice_tuple() const
    {
        return std::tie(bo, b, s, i, l, f, d, str, c1, bs, is, st, dict);
    }
};

class ExceptionNoDefaultsBase : public ::Ice::UserException
{
public:
    using ::Ice::UserException::UserException;

    /**
     * One-shot constructor to initialize all data members.
     */
    ExceptionNoDefaultsBase(::std::string str, Color c1, ByteSeq bs) noexcept :
        str(::std::move(str)),
        c1(c1),
        bs(::std::move(bs))
    {
    }

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::Test::Color&, const ::Test::ByteSeq&> ice_tuple() const
    {
        return std::tie(str, c1, bs);
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId() noexcept;

    ::std::string ice_id() const override;

    void ice_throw() const override;

    ::std::string str;
    ::Test::Color c1;
    ::Test::ByteSeq bs;

protected:
    void _writeImpl(::Ice::OutputStream*) const override;

    void _readImpl(::Ice::InputStream*) override;
};

class ExceptionNoDefaults : public ExceptionNoDefaultsBase
{
public:
    using ExceptionNoDefaultsBase::ExceptionNoDefaultsBase;

    /**
     * One-shot constructor to initialize all data members.
     */
    ExceptionNoDefaults(::std::string str, Color c1, ByteSeq bs, InnerStruct st, IntStringDict dict) noexcept :
        ExceptionNoDefaultsBase(::std::move(str), c1, ::std::move(bs)),
        st(::std::move(st)),
        dict(::std::move(dict))
    {
    }

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::Test::Color&, const ::Test::ByteSeq&, const ::Test::InnerStruct&, const ::Test::IntStringDict&> ice_tuple() const
    {
        return std::tie(str, c1, bs, st, dict);
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId() noexcept;

    ::std::string ice_id() const override;

    void ice_throw() const override;

    ::Test::InnerStruct st;
    ::Test::IntStringDict dict;

protected:
    void _writeImpl(::Ice::OutputStream*) const override;

    void _readImpl(::Ice::InputStream*) override;
};

class ClassNoDefaultsBase : public ::Ice::ValueHelper<ClassNoDefaultsBase, ::Ice::Value>
{
public:

    ClassNoDefaultsBase() = default;
    ClassNoDefaultsBase(const ClassNoDefaultsBase&) = default;
    ClassNoDefaultsBase(ClassNoDefaultsBase&&) = default;
    ClassNoDefaultsBase& operator=(const ClassNoDefaultsBase&) = default;
    ClassNoDefaultsBase& operator=(ClassNoDefaultsBase&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    ClassNoDefaultsBase(::std::string str, ::Test::Color c1, ::Test::ByteSeq bs) :
        str(::std::move(str)),
        c1(c1),
        bs(::std::move(bs))
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::Test::Color&, const ::Test::ByteSeq&> ice_tuple() const
    {
        return std::tie(str, c1, bs);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId() noexcept;

    ::std::string str;
    ::Test::Color c1;
    ::Test::ByteSeq bs;
};

class ClassNoDefaults : public ::Ice::ValueHelper<ClassNoDefaults, ClassNoDefaultsBase>
{
public:

    ClassNoDefaults() = default;
    ClassNoDefaults(const ClassNoDefaults&) = default;
    ClassNoDefaults(ClassNoDefaults&&) = default;
    ClassNoDefaults& operator=(const ClassNoDefaults&) = default;
    ClassNoDefaults& operator=(ClassNoDefaults&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    ClassNoDefaults(::std::string str, ::Test::Color c1, ::Test::ByteSeq bs, ::Test::InnerStruct st, ::Test::IntStringDict dict) :
        Ice::ValueHelper<ClassNoDefaults, ClassNoDefaultsBase>(::std::move(str), c1, ::std::move(bs)),
        st(::std::move(st)),
        dict(::std::move(dict))
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::Test::Color&, const ::Test::ByteSeq&, const ::Test::InnerStruct&, const ::Test::IntStringDict&> ice_tuple() const
    {
        return std::tie(str, c1, bs, st, dict);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static ::std::string_view ice_staticId() noexcept;

    ::Test::InnerStruct st;
    ::Test::IntStringDict dict;
};

using Ice::operator<;
using Ice::operator<=;
using Ice::operator>;
using Ice::operator>=;
using Ice::operator==;
using Ice::operator!=;

}

/// \cond STREAM
namespace Ice
{

template<>
struct StreamableTraits< ::Test::Color>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 2;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits< ::Test::Nested::Color>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 2;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits<::Test::Struct1>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 73;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::Test::Struct1, S>
{
    static void read(S* istr, ::Test::Struct1& v)
    {
        istr->readAll(v.boolFalse, v.boolTrue, v.b, v.s, v.i, v.l, v.f, v.d, v.str, v.c1, v.c2, v.c3, v.nc1, v.nc2, v.nc3, v.noDefault, v.zeroI, v.zeroL, v.zeroF, v.zeroDotF, v.zeroD, v.zeroDotD);
    }
};

template<>
struct StreamableTraits<::Test::Struct2>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 71;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::Test::Struct2, S>
{
    static void read(S* istr, ::Test::Struct2& v)
    {
        istr->readAll(v.boolTrue, v.b, v.s, v.i, v.l, v.f, v.d, v.str, v.c1, v.c2, v.c3, v.nc1, v.nc2, v.nc3, v.zeroI, v.zeroL, v.zeroF, v.zeroDotF, v.zeroD, v.zeroDotD);
    }
};

template<typename S>
struct StreamReader<::Test::Base, S>
{
    static void read(S* istr, ::Test::Base& v)
    {
        istr->readAll(v.boolFalse, v.boolTrue, v.b, v.s, v.i, v.l, v.f, v.d, v.str, v.noDefault, v.zeroI, v.zeroL, v.zeroF, v.zeroDotF, v.zeroD, v.zeroDotD);
    }
};

template<typename S>
struct StreamWriter<::Test::Derived, S>
{
    static void write(S* ostr, const ::Test::Derived& v)
    {
        ostr->writeAll(v.c1, v.c2, v.c3, v.nc1, v.nc2, v.nc3);
    }
};

template<typename S>
struct StreamReader<::Test::Derived, S>
{
    static void read(S* istr, ::Test::Derived& v)
    {
        istr->readAll(v.c1, v.c2, v.c3, v.nc1, v.nc2, v.nc3);
    }
};

template<typename S>
struct StreamReader<::Test::BaseEx, S>
{
    static void read(S* istr, ::Test::BaseEx& v)
    {
        istr->readAll(v.boolFalse, v.boolTrue, v.b, v.s, v.i, v.l, v.f, v.d, v.str, v.noDefault, v.zeroI, v.zeroL, v.zeroF, v.zeroDotF, v.zeroD, v.zeroDotD);
    }
};

template<typename S>
struct StreamWriter<::Test::DerivedEx, S>
{
    static void write(S* ostr, const ::Test::DerivedEx& v)
    {
        ostr->writeAll(v.c1, v.c2, v.c3, v.nc1, v.nc2, v.nc3);
    }
};

template<typename S>
struct StreamReader<::Test::DerivedEx, S>
{
    static void read(S* istr, ::Test::DerivedEx& v)
    {
        istr->readAll(v.c1, v.c2, v.c3, v.nc1, v.nc2, v.nc3);
    }
};

template<>
struct StreamableTraits<::Test::InnerStruct>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 4;
    static const bool fixedLength = true;
};

template<typename S>
struct StreamReader<::Test::InnerStruct, S>
{
    static void read(S* istr, ::Test::InnerStruct& v)
    {
        istr->readAll(v.a);
    }
};

template<>
struct StreamableTraits<::Test::StructNoDefaults>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 37;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::Test::StructNoDefaults, S>
{
    static void read(S* istr, ::Test::StructNoDefaults& v)
    {
        istr->readAll(v.bo, v.b, v.s, v.i, v.l, v.f, v.d, v.str, v.c1, v.bs, v.is, v.st, v.dict);
    }
};

template<typename S>
struct StreamReader<::Test::ExceptionNoDefaultsBase, S>
{
    static void read(S* istr, ::Test::ExceptionNoDefaultsBase& v)
    {
        istr->readAll(v.str, v.c1, v.bs);
    }
};

template<typename S>
struct StreamWriter<::Test::ExceptionNoDefaults, S>
{
    static void write(S* ostr, const ::Test::ExceptionNoDefaults& v)
    {
        ostr->writeAll(v.st, v.dict);
    }
};

template<typename S>
struct StreamReader<::Test::ExceptionNoDefaults, S>
{
    static void read(S* istr, ::Test::ExceptionNoDefaults& v)
    {
        istr->readAll(v.st, v.dict);
    }
};

template<typename S>
struct StreamReader<::Test::ClassNoDefaultsBase, S>
{
    static void read(S* istr, ::Test::ClassNoDefaultsBase& v)
    {
        istr->readAll(v.str, v.c1, v.bs);
    }
};

template<typename S>
struct StreamWriter<::Test::ClassNoDefaults, S>
{
    static void write(S* ostr, const ::Test::ClassNoDefaults& v)
    {
        ostr->writeAll(v.st, v.dict);
    }
};

template<typename S>
struct StreamReader<::Test::ClassNoDefaults, S>
{
    static void read(S* istr, ::Test::ClassNoDefaults& v)
    {
        istr->readAll(v.st, v.dict);
    }
};

}
/// \endcond

#include <IceUtil/PopDisableWarnings.h>
#endif
