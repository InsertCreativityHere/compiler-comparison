//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.8.0-alpha.0
//
// <auto-generated>
//
// Generated from file `Test.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#define ICE_BUILDING_GENERATED_CODE
#include "Test.h"
#include <Ice/AsyncResponseHandler.h>
#include <Ice/FactoryTable.h>
#include <Ice/OutgoingAsync.h>

#if defined(_MSC_VER)
#   pragma warning(disable : 4458) // declaration of ... hides class member
#   pragma warning(disable : 4996) // ... was declared deprecated
#elif defined(__clang__)
#   pragma clang diagnostic ignored "-Wshadow"
#   pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
#   pragma GCC diagnostic ignored "-Wshadow"
#   pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION  != 30850
#       error Ice version mismatch: an exact match is required for beta generated code
#   endif
#endif

::Test::ASeq
Test::TestIntfPrx::opASeq(const ASeq& iceP_inSeq, ASeq& iceP_outSeq, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<ASeq, ASeq>>(true, this, &TestIntfPrx::_iceI_opASeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::ASeq, ::Test::ASeq>>
Test::TestIntfPrx::opASeqAsync(const ASeq& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<ASeq, ASeq>>(false, this, &TestIntfPrx::_iceI_opASeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opASeqAsync(const ASeq& iceP_inSeq, ::std::function<void(::Test::ASeq, ::Test::ASeq)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<ASeq, ASeq>&& result) mutable
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<ASeq, ASeq>>(::std::move(responseCb), ::std::move(ex), ::std::move(sent), this, &Test::TestIntfPrx::_iceI_opASeq, iceP_inSeq, context);
}

void
Test::TestIntfPrx::_iceI_opASeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<ASeq, ASeq>>>& outAsync, const ASeq& iceP_inSeq, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opASeq";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::std::nullopt, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<ASeq, ASeq> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::AArray
Test::TestIntfPrx::opAArray(const AArray& iceP_inSeq, AArray& iceP_outSeq, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<AArray, AArray>>(true, this, &TestIntfPrx::_iceI_opAArray, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::AArray, ::Test::AArray>>
Test::TestIntfPrx::opAArrayAsync(const AArray& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<AArray, AArray>>(false, this, &TestIntfPrx::_iceI_opAArray, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opAArrayAsync(const AArray& iceP_inSeq, ::std::function<void(::Test::AArray, ::Test::AArray)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<AArray, AArray>&& result) mutable
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<AArray, AArray>>(::std::move(responseCb), ::std::move(ex), ::std::move(sent), this, &Test::TestIntfPrx::_iceI_opAArray, iceP_inSeq, context);
}

void
Test::TestIntfPrx::_iceI_opAArray(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<AArray, AArray>>>& outAsync, const AArray& iceP_inSeq, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opAArray";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::std::nullopt, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<AArray, AArray> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::AList
Test::TestIntfPrx::opAList(const AList& iceP_inSeq, AList& iceP_outSeq, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<AList, AList>>(true, this, &TestIntfPrx::_iceI_opAList, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::AList, ::Test::AList>>
Test::TestIntfPrx::opAListAsync(const AList& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<AList, AList>>(false, this, &TestIntfPrx::_iceI_opAList, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opAListAsync(const AList& iceP_inSeq, ::std::function<void(::Test::AList, ::Test::AList)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<AList, AList>&& result) mutable
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<AList, AList>>(::std::move(responseCb), ::std::move(ex), ::std::move(sent), this, &Test::TestIntfPrx::_iceI_opAList, iceP_inSeq, context);
}

void
Test::TestIntfPrx::_iceI_opAList(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<AList, AList>>>& outAsync, const AList& iceP_inSeq, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opAList";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::std::nullopt, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<AList, AList> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::BoolSeq
Test::TestIntfPrx::opBoolSeq(const BoolSeq& iceP_inSeq, BoolSeq& iceP_outSeq, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<BoolSeq, BoolSeq>>(true, this, &TestIntfPrx::_iceI_opBoolSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::BoolSeq, ::Test::BoolSeq>>
Test::TestIntfPrx::opBoolSeqAsync(const BoolSeq& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<BoolSeq, BoolSeq>>(false, this, &TestIntfPrx::_iceI_opBoolSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opBoolSeqAsync(const BoolSeq& iceP_inSeq, ::std::function<void(::Test::BoolSeq, ::Test::BoolSeq)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<BoolSeq, BoolSeq>&& result) mutable
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<BoolSeq, BoolSeq>>(::std::move(responseCb), ::std::move(ex), ::std::move(sent), this, &Test::TestIntfPrx::_iceI_opBoolSeq, iceP_inSeq, context);
}

void
Test::TestIntfPrx::_iceI_opBoolSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<BoolSeq, BoolSeq>>>& outAsync, const BoolSeq& iceP_inSeq, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opBoolSeq";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::std::nullopt, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<BoolSeq, BoolSeq> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::ByteSeq
Test::TestIntfPrx::opByteSeq(const ByteSeq& iceP_inSeq, ByteSeq& iceP_outSeq, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<ByteSeq, ByteSeq>>(true, this, &TestIntfPrx::_iceI_opByteSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::ByteSeq, ::Test::ByteSeq>>
Test::TestIntfPrx::opByteSeqAsync(const ByteSeq& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<ByteSeq, ByteSeq>>(false, this, &TestIntfPrx::_iceI_opByteSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opByteSeqAsync(const ByteSeq& iceP_inSeq, ::std::function<void(::Test::ByteSeq, ::Test::ByteSeq)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<ByteSeq, ByteSeq>&& result) mutable
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<ByteSeq, ByteSeq>>(::std::move(responseCb), ::std::move(ex), ::std::move(sent), this, &Test::TestIntfPrx::_iceI_opByteSeq, iceP_inSeq, context);
}

void
Test::TestIntfPrx::_iceI_opByteSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<ByteSeq, ByteSeq>>>& outAsync, const ByteSeq& iceP_inSeq, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opByteSeq";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::std::nullopt, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<ByteSeq, ByteSeq> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::ShortSeq
Test::TestIntfPrx::opShortSeq(const ShortSeq& iceP_inSeq, ShortSeq& iceP_outSeq, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<ShortSeq, ShortSeq>>(true, this, &TestIntfPrx::_iceI_opShortSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::ShortSeq, ::Test::ShortSeq>>
Test::TestIntfPrx::opShortSeqAsync(const ShortSeq& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<ShortSeq, ShortSeq>>(false, this, &TestIntfPrx::_iceI_opShortSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opShortSeqAsync(const ShortSeq& iceP_inSeq, ::std::function<void(::Test::ShortSeq, ::Test::ShortSeq)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<ShortSeq, ShortSeq>&& result) mutable
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<ShortSeq, ShortSeq>>(::std::move(responseCb), ::std::move(ex), ::std::move(sent), this, &Test::TestIntfPrx::_iceI_opShortSeq, iceP_inSeq, context);
}

void
Test::TestIntfPrx::_iceI_opShortSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<ShortSeq, ShortSeq>>>& outAsync, const ShortSeq& iceP_inSeq, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opShortSeq";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::std::nullopt, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<ShortSeq, ShortSeq> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::IntSeq
Test::TestIntfPrx::opIntSeq(const IntSeq& iceP_inSeq, IntSeq& iceP_outSeq, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<IntSeq, IntSeq>>(true, this, &TestIntfPrx::_iceI_opIntSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::IntSeq, ::Test::IntSeq>>
Test::TestIntfPrx::opIntSeqAsync(const IntSeq& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<IntSeq, IntSeq>>(false, this, &TestIntfPrx::_iceI_opIntSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opIntSeqAsync(const IntSeq& iceP_inSeq, ::std::function<void(::Test::IntSeq, ::Test::IntSeq)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<IntSeq, IntSeq>&& result) mutable
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<IntSeq, IntSeq>>(::std::move(responseCb), ::std::move(ex), ::std::move(sent), this, &Test::TestIntfPrx::_iceI_opIntSeq, iceP_inSeq, context);
}

void
Test::TestIntfPrx::_iceI_opIntSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<IntSeq, IntSeq>>>& outAsync, const IntSeq& iceP_inSeq, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opIntSeq";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::std::nullopt, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<IntSeq, IntSeq> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::LongSeq
Test::TestIntfPrx::opLongSeq(const LongSeq& iceP_inSeq, LongSeq& iceP_outSeq, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<LongSeq, LongSeq>>(true, this, &TestIntfPrx::_iceI_opLongSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::LongSeq, ::Test::LongSeq>>
Test::TestIntfPrx::opLongSeqAsync(const LongSeq& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<LongSeq, LongSeq>>(false, this, &TestIntfPrx::_iceI_opLongSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opLongSeqAsync(const LongSeq& iceP_inSeq, ::std::function<void(::Test::LongSeq, ::Test::LongSeq)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<LongSeq, LongSeq>&& result) mutable
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<LongSeq, LongSeq>>(::std::move(responseCb), ::std::move(ex), ::std::move(sent), this, &Test::TestIntfPrx::_iceI_opLongSeq, iceP_inSeq, context);
}

void
Test::TestIntfPrx::_iceI_opLongSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<LongSeq, LongSeq>>>& outAsync, const LongSeq& iceP_inSeq, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opLongSeq";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::std::nullopt, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<LongSeq, LongSeq> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::FloatSeq
Test::TestIntfPrx::opFloatSeq(const FloatSeq& iceP_inSeq, FloatSeq& iceP_outSeq, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<FloatSeq, FloatSeq>>(true, this, &TestIntfPrx::_iceI_opFloatSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::FloatSeq, ::Test::FloatSeq>>
Test::TestIntfPrx::opFloatSeqAsync(const FloatSeq& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<FloatSeq, FloatSeq>>(false, this, &TestIntfPrx::_iceI_opFloatSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opFloatSeqAsync(const FloatSeq& iceP_inSeq, ::std::function<void(::Test::FloatSeq, ::Test::FloatSeq)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<FloatSeq, FloatSeq>&& result) mutable
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<FloatSeq, FloatSeq>>(::std::move(responseCb), ::std::move(ex), ::std::move(sent), this, &Test::TestIntfPrx::_iceI_opFloatSeq, iceP_inSeq, context);
}

void
Test::TestIntfPrx::_iceI_opFloatSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<FloatSeq, FloatSeq>>>& outAsync, const FloatSeq& iceP_inSeq, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opFloatSeq";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::std::nullopt, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<FloatSeq, FloatSeq> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::DoubleSeq
Test::TestIntfPrx::opDoubleSeq(const DoubleSeq& iceP_inSeq, DoubleSeq& iceP_outSeq, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<DoubleSeq, DoubleSeq>>(true, this, &TestIntfPrx::_iceI_opDoubleSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::DoubleSeq, ::Test::DoubleSeq>>
Test::TestIntfPrx::opDoubleSeqAsync(const DoubleSeq& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<DoubleSeq, DoubleSeq>>(false, this, &TestIntfPrx::_iceI_opDoubleSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opDoubleSeqAsync(const DoubleSeq& iceP_inSeq, ::std::function<void(::Test::DoubleSeq, ::Test::DoubleSeq)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<DoubleSeq, DoubleSeq>&& result) mutable
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<DoubleSeq, DoubleSeq>>(::std::move(responseCb), ::std::move(ex), ::std::move(sent), this, &Test::TestIntfPrx::_iceI_opDoubleSeq, iceP_inSeq, context);
}

void
Test::TestIntfPrx::_iceI_opDoubleSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<DoubleSeq, DoubleSeq>>>& outAsync, const DoubleSeq& iceP_inSeq, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opDoubleSeq";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::std::nullopt, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<DoubleSeq, DoubleSeq> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::StringSeq
Test::TestIntfPrx::opStringSeq(const StringSeq& iceP_inSeq, StringSeq& iceP_outSeq, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<StringSeq, StringSeq>>(true, this, &TestIntfPrx::_iceI_opStringSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::StringSeq, ::Test::StringSeq>>
Test::TestIntfPrx::opStringSeqAsync(const StringSeq& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<StringSeq, StringSeq>>(false, this, &TestIntfPrx::_iceI_opStringSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opStringSeqAsync(const StringSeq& iceP_inSeq, ::std::function<void(::Test::StringSeq, ::Test::StringSeq)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<StringSeq, StringSeq>&& result) mutable
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<StringSeq, StringSeq>>(::std::move(responseCb), ::std::move(ex), ::std::move(sent), this, &Test::TestIntfPrx::_iceI_opStringSeq, iceP_inSeq, context);
}

void
Test::TestIntfPrx::_iceI_opStringSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<StringSeq, StringSeq>>>& outAsync, const StringSeq& iceP_inSeq, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opStringSeq";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::std::nullopt, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<StringSeq, StringSeq> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::ESeq
Test::TestIntfPrx::opESeq(const ESeq& iceP_inSeq, ESeq& iceP_outSeq, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<ESeq, ESeq>>(true, this, &TestIntfPrx::_iceI_opESeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::ESeq, ::Test::ESeq>>
Test::TestIntfPrx::opESeqAsync(const ESeq& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<ESeq, ESeq>>(false, this, &TestIntfPrx::_iceI_opESeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opESeqAsync(const ESeq& iceP_inSeq, ::std::function<void(::Test::ESeq, ::Test::ESeq)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<ESeq, ESeq>&& result) mutable
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<ESeq, ESeq>>(::std::move(responseCb), ::std::move(ex), ::std::move(sent), this, &Test::TestIntfPrx::_iceI_opESeq, iceP_inSeq, context);
}

void
Test::TestIntfPrx::_iceI_opESeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<ESeq, ESeq>>>& outAsync, const ESeq& iceP_inSeq, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opESeq";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::std::nullopt, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<ESeq, ESeq> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::SSeq
Test::TestIntfPrx::opSSeq(const SSeq& iceP_inSeq, SSeq& iceP_outSeq, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<SSeq, SSeq>>(true, this, &TestIntfPrx::_iceI_opSSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::SSeq, ::Test::SSeq>>
Test::TestIntfPrx::opSSeqAsync(const SSeq& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<SSeq, SSeq>>(false, this, &TestIntfPrx::_iceI_opSSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opSSeqAsync(const SSeq& iceP_inSeq, ::std::function<void(::Test::SSeq, ::Test::SSeq)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<SSeq, SSeq>&& result) mutable
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<SSeq, SSeq>>(::std::move(responseCb), ::std::move(ex), ::std::move(sent), this, &Test::TestIntfPrx::_iceI_opSSeq, iceP_inSeq, context);
}

void
Test::TestIntfPrx::_iceI_opSSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<SSeq, SSeq>>>& outAsync, const SSeq& iceP_inSeq, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opSSeq";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::std::nullopt, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<SSeq, SSeq> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::DSeq
Test::TestIntfPrx::opDSeq(const DSeq& iceP_inSeq, DSeq& iceP_outSeq, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<DSeq, DSeq>>(true, this, &TestIntfPrx::_iceI_opDSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::DSeq, ::Test::DSeq>>
Test::TestIntfPrx::opDSeqAsync(const DSeq& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<DSeq, DSeq>>(false, this, &TestIntfPrx::_iceI_opDSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opDSeqAsync(const DSeq& iceP_inSeq, ::std::function<void(::Test::DSeq, ::Test::DSeq)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<DSeq, DSeq>&& result) mutable
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<DSeq, DSeq>>(::std::move(responseCb), ::std::move(ex), ::std::move(sent), this, &Test::TestIntfPrx::_iceI_opDSeq, iceP_inSeq, context);
}

void
Test::TestIntfPrx::_iceI_opDSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<DSeq, DSeq>>>& outAsync, const DSeq& iceP_inSeq, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opDSeq";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::std::nullopt, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<DSeq, DSeq> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::StringSeqSeq
Test::TestIntfPrx::opStringSeqSeq(const StringSeqSeq& iceP_inSeq, StringSeqSeq& iceP_outSeq, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<StringSeqSeq, StringSeqSeq>>(true, this, &TestIntfPrx::_iceI_opStringSeqSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::StringSeqSeq, ::Test::StringSeqSeq>>
Test::TestIntfPrx::opStringSeqSeqAsync(const StringSeqSeq& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<StringSeqSeq, StringSeqSeq>>(false, this, &TestIntfPrx::_iceI_opStringSeqSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opStringSeqSeqAsync(const StringSeqSeq& iceP_inSeq, ::std::function<void(::Test::StringSeqSeq, ::Test::StringSeqSeq)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<StringSeqSeq, StringSeqSeq>&& result) mutable
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<StringSeqSeq, StringSeqSeq>>(::std::move(responseCb), ::std::move(ex), ::std::move(sent), this, &Test::TestIntfPrx::_iceI_opStringSeqSeq, iceP_inSeq, context);
}

void
Test::TestIntfPrx::_iceI_opStringSeqSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<StringSeqSeq, StringSeqSeq>>>& outAsync, const StringSeqSeq& iceP_inSeq, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opStringSeqSeq";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::std::nullopt, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<StringSeqSeq, StringSeqSeq> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::ByteBuffer
Test::TestIntfPrx::opByteBufferSeq(const ByteBuffer& iceP_inSeq, ByteBuffer& iceP_outSeq, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<ByteBuffer, ByteBuffer>>(true, this, &TestIntfPrx::_iceI_opByteBufferSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::ByteBuffer, ::Test::ByteBuffer>>
Test::TestIntfPrx::opByteBufferSeqAsync(const ByteBuffer& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<ByteBuffer, ByteBuffer>>(false, this, &TestIntfPrx::_iceI_opByteBufferSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opByteBufferSeqAsync(const ByteBuffer& iceP_inSeq, ::std::function<void(::Test::ByteBuffer, ::Test::ByteBuffer)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<ByteBuffer, ByteBuffer>&& result) mutable
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<ByteBuffer, ByteBuffer>>(::std::move(responseCb), ::std::move(ex), ::std::move(sent), this, &Test::TestIntfPrx::_iceI_opByteBufferSeq, iceP_inSeq, context);
}

void
Test::TestIntfPrx::_iceI_opByteBufferSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<ByteBuffer, ByteBuffer>>>& outAsync, const ByteBuffer& iceP_inSeq, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opByteBufferSeq";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::std::nullopt, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<ByteBuffer, ByteBuffer> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::ShortBuffer
Test::TestIntfPrx::opShortBufferSeq(const ShortBuffer& iceP_inSeq, ShortBuffer& iceP_outSeq, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<ShortBuffer, ShortBuffer>>(true, this, &TestIntfPrx::_iceI_opShortBufferSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::ShortBuffer, ::Test::ShortBuffer>>
Test::TestIntfPrx::opShortBufferSeqAsync(const ShortBuffer& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<ShortBuffer, ShortBuffer>>(false, this, &TestIntfPrx::_iceI_opShortBufferSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opShortBufferSeqAsync(const ShortBuffer& iceP_inSeq, ::std::function<void(::Test::ShortBuffer, ::Test::ShortBuffer)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<ShortBuffer, ShortBuffer>&& result) mutable
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<ShortBuffer, ShortBuffer>>(::std::move(responseCb), ::std::move(ex), ::std::move(sent), this, &Test::TestIntfPrx::_iceI_opShortBufferSeq, iceP_inSeq, context);
}

void
Test::TestIntfPrx::_iceI_opShortBufferSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<ShortBuffer, ShortBuffer>>>& outAsync, const ShortBuffer& iceP_inSeq, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opShortBufferSeq";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::std::nullopt, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<ShortBuffer, ShortBuffer> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::IntBuffer
Test::TestIntfPrx::opIntBufferSeq(const IntBuffer& iceP_inSeq, IntBuffer& iceP_outSeq, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<IntBuffer, IntBuffer>>(true, this, &TestIntfPrx::_iceI_opIntBufferSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::IntBuffer, ::Test::IntBuffer>>
Test::TestIntfPrx::opIntBufferSeqAsync(const IntBuffer& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<IntBuffer, IntBuffer>>(false, this, &TestIntfPrx::_iceI_opIntBufferSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opIntBufferSeqAsync(const IntBuffer& iceP_inSeq, ::std::function<void(::Test::IntBuffer, ::Test::IntBuffer)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<IntBuffer, IntBuffer>&& result) mutable
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<IntBuffer, IntBuffer>>(::std::move(responseCb), ::std::move(ex), ::std::move(sent), this, &Test::TestIntfPrx::_iceI_opIntBufferSeq, iceP_inSeq, context);
}

void
Test::TestIntfPrx::_iceI_opIntBufferSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<IntBuffer, IntBuffer>>>& outAsync, const IntBuffer& iceP_inSeq, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opIntBufferSeq";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::std::nullopt, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<IntBuffer, IntBuffer> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::LongBuffer
Test::TestIntfPrx::opLongBufferSeq(const LongBuffer& iceP_inSeq, LongBuffer& iceP_outSeq, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<LongBuffer, LongBuffer>>(true, this, &TestIntfPrx::_iceI_opLongBufferSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::LongBuffer, ::Test::LongBuffer>>
Test::TestIntfPrx::opLongBufferSeqAsync(const LongBuffer& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<LongBuffer, LongBuffer>>(false, this, &TestIntfPrx::_iceI_opLongBufferSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opLongBufferSeqAsync(const LongBuffer& iceP_inSeq, ::std::function<void(::Test::LongBuffer, ::Test::LongBuffer)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<LongBuffer, LongBuffer>&& result) mutable
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<LongBuffer, LongBuffer>>(::std::move(responseCb), ::std::move(ex), ::std::move(sent), this, &Test::TestIntfPrx::_iceI_opLongBufferSeq, iceP_inSeq, context);
}

void
Test::TestIntfPrx::_iceI_opLongBufferSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<LongBuffer, LongBuffer>>>& outAsync, const LongBuffer& iceP_inSeq, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opLongBufferSeq";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::std::nullopt, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<LongBuffer, LongBuffer> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::FloatBuffer
Test::TestIntfPrx::opFloatBufferSeq(const FloatBuffer& iceP_inSeq, FloatBuffer& iceP_outSeq, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<FloatBuffer, FloatBuffer>>(true, this, &TestIntfPrx::_iceI_opFloatBufferSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::FloatBuffer, ::Test::FloatBuffer>>
Test::TestIntfPrx::opFloatBufferSeqAsync(const FloatBuffer& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<FloatBuffer, FloatBuffer>>(false, this, &TestIntfPrx::_iceI_opFloatBufferSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opFloatBufferSeqAsync(const FloatBuffer& iceP_inSeq, ::std::function<void(::Test::FloatBuffer, ::Test::FloatBuffer)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<FloatBuffer, FloatBuffer>&& result) mutable
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<FloatBuffer, FloatBuffer>>(::std::move(responseCb), ::std::move(ex), ::std::move(sent), this, &Test::TestIntfPrx::_iceI_opFloatBufferSeq, iceP_inSeq, context);
}

void
Test::TestIntfPrx::_iceI_opFloatBufferSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<FloatBuffer, FloatBuffer>>>& outAsync, const FloatBuffer& iceP_inSeq, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opFloatBufferSeq";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::std::nullopt, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<FloatBuffer, FloatBuffer> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::DoubleBuffer
Test::TestIntfPrx::opDoubleBufferSeq(const DoubleBuffer& iceP_inSeq, DoubleBuffer& iceP_outSeq, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<DoubleBuffer, DoubleBuffer>>(true, this, &TestIntfPrx::_iceI_opDoubleBufferSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::DoubleBuffer, ::Test::DoubleBuffer>>
Test::TestIntfPrx::opDoubleBufferSeqAsync(const DoubleBuffer& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<DoubleBuffer, DoubleBuffer>>(false, this, &TestIntfPrx::_iceI_opDoubleBufferSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opDoubleBufferSeqAsync(const DoubleBuffer& iceP_inSeq, ::std::function<void(::Test::DoubleBuffer, ::Test::DoubleBuffer)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<DoubleBuffer, DoubleBuffer>&& result) mutable
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<DoubleBuffer, DoubleBuffer>>(::std::move(responseCb), ::std::move(ex), ::std::move(sent), this, &Test::TestIntfPrx::_iceI_opDoubleBufferSeq, iceP_inSeq, context);
}

void
Test::TestIntfPrx::_iceI_opDoubleBufferSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<DoubleBuffer, DoubleBuffer>>>& outAsync, const DoubleBuffer& iceP_inSeq, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opDoubleBufferSeq";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::std::nullopt, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<DoubleBuffer, DoubleBuffer> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::std::optional<::Test::ASeq>
Test::TestIntfPrx::opOptASeq(const ::std::optional<ASeq>& iceP_inSeq, ::std::optional<ASeq>& iceP_outSeq, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<::std::optional<ASeq>, ::std::optional<ASeq>>>(true, this, &TestIntfPrx::_iceI_opOptASeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::std::optional<::Test::ASeq>, ::std::optional<::Test::ASeq>>>
Test::TestIntfPrx::opOptASeqAsync(const ::std::optional<ASeq>& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<::std::optional<ASeq>, ::std::optional<ASeq>>>(false, this, &TestIntfPrx::_iceI_opOptASeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opOptASeqAsync(const ::std::optional<ASeq>& iceP_inSeq, ::std::function<void(::std::optional<::Test::ASeq>, ::std::optional<::Test::ASeq>)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<::std::optional<ASeq>, ::std::optional<ASeq>>&& result) mutable
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<::std::optional<ASeq>, ::std::optional<ASeq>>>(::std::move(responseCb), ::std::move(ex), ::std::move(sent), this, &Test::TestIntfPrx::_iceI_opOptASeq, iceP_inSeq, context);
}

void
Test::TestIntfPrx::_iceI_opOptASeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::optional<ASeq>, ::std::optional<ASeq>>>>& outAsync, const ::std::optional<ASeq>& iceP_inSeq, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opOptASeq";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::std::nullopt, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({2}, iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<::std::optional<ASeq>, ::std::optional<ASeq>> v;
            istr->readAll({1, 3}, ::std::get<0>(v), ::std::get<1>(v));
            return v;
        });
}

::std::optional<::Test::AArray>
Test::TestIntfPrx::opOptAArray(const ::std::optional<AArray>& iceP_inSeq, ::std::optional<AArray>& iceP_outSeq, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<::std::optional<AArray>, ::std::optional<AArray>>>(true, this, &TestIntfPrx::_iceI_opOptAArray, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::std::optional<::Test::AArray>, ::std::optional<::Test::AArray>>>
Test::TestIntfPrx::opOptAArrayAsync(const ::std::optional<AArray>& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<::std::optional<AArray>, ::std::optional<AArray>>>(false, this, &TestIntfPrx::_iceI_opOptAArray, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opOptAArrayAsync(const ::std::optional<AArray>& iceP_inSeq, ::std::function<void(::std::optional<::Test::AArray>, ::std::optional<::Test::AArray>)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<::std::optional<AArray>, ::std::optional<AArray>>&& result) mutable
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<::std::optional<AArray>, ::std::optional<AArray>>>(::std::move(responseCb), ::std::move(ex), ::std::move(sent), this, &Test::TestIntfPrx::_iceI_opOptAArray, iceP_inSeq, context);
}

void
Test::TestIntfPrx::_iceI_opOptAArray(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::optional<AArray>, ::std::optional<AArray>>>>& outAsync, const ::std::optional<AArray>& iceP_inSeq, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opOptAArray";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::std::nullopt, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({2}, iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<::std::optional<AArray>, ::std::optional<AArray>> v;
            istr->readAll({1, 3}, ::std::get<0>(v), ::std::get<1>(v));
            return v;
        });
}

::std::optional<::Test::AList>
Test::TestIntfPrx::opOptAList(const ::std::optional<AList>& iceP_inSeq, ::std::optional<AList>& iceP_outSeq, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<::std::optional<AList>, ::std::optional<AList>>>(true, this, &TestIntfPrx::_iceI_opOptAList, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::std::optional<::Test::AList>, ::std::optional<::Test::AList>>>
Test::TestIntfPrx::opOptAListAsync(const ::std::optional<AList>& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<::std::optional<AList>, ::std::optional<AList>>>(false, this, &TestIntfPrx::_iceI_opOptAList, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opOptAListAsync(const ::std::optional<AList>& iceP_inSeq, ::std::function<void(::std::optional<::Test::AList>, ::std::optional<::Test::AList>)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<::std::optional<AList>, ::std::optional<AList>>&& result) mutable
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<::std::optional<AList>, ::std::optional<AList>>>(::std::move(responseCb), ::std::move(ex), ::std::move(sent), this, &Test::TestIntfPrx::_iceI_opOptAList, iceP_inSeq, context);
}

void
Test::TestIntfPrx::_iceI_opOptAList(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::optional<AList>, ::std::optional<AList>>>>& outAsync, const ::std::optional<AList>& iceP_inSeq, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opOptAList";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::std::nullopt, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({2}, iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<::std::optional<AList>, ::std::optional<AList>> v;
            istr->readAll({1, 3}, ::std::get<0>(v), ::std::get<1>(v));
            return v;
        });
}

::std::optional<::Test::BoolSeq>
Test::TestIntfPrx::opOptBoolSeq(const ::std::optional<BoolSeq>& iceP_inSeq, ::std::optional<BoolSeq>& iceP_outSeq, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<::std::optional<BoolSeq>, ::std::optional<BoolSeq>>>(true, this, &TestIntfPrx::_iceI_opOptBoolSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::std::optional<::Test::BoolSeq>, ::std::optional<::Test::BoolSeq>>>
Test::TestIntfPrx::opOptBoolSeqAsync(const ::std::optional<BoolSeq>& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<::std::optional<BoolSeq>, ::std::optional<BoolSeq>>>(false, this, &TestIntfPrx::_iceI_opOptBoolSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opOptBoolSeqAsync(const ::std::optional<BoolSeq>& iceP_inSeq, ::std::function<void(::std::optional<::Test::BoolSeq>, ::std::optional<::Test::BoolSeq>)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<::std::optional<BoolSeq>, ::std::optional<BoolSeq>>&& result) mutable
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<::std::optional<BoolSeq>, ::std::optional<BoolSeq>>>(::std::move(responseCb), ::std::move(ex), ::std::move(sent), this, &Test::TestIntfPrx::_iceI_opOptBoolSeq, iceP_inSeq, context);
}

void
Test::TestIntfPrx::_iceI_opOptBoolSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::optional<BoolSeq>, ::std::optional<BoolSeq>>>>& outAsync, const ::std::optional<BoolSeq>& iceP_inSeq, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opOptBoolSeq";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::std::nullopt, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({2}, iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<::std::optional<BoolSeq>, ::std::optional<BoolSeq>> v;
            istr->readAll({1, 3}, ::std::get<0>(v), ::std::get<1>(v));
            return v;
        });
}

::std::optional<::Test::ByteSeq>
Test::TestIntfPrx::opOptByteSeq(const ::std::optional<ByteSeq>& iceP_inSeq, ::std::optional<ByteSeq>& iceP_outSeq, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<::std::optional<ByteSeq>, ::std::optional<ByteSeq>>>(true, this, &TestIntfPrx::_iceI_opOptByteSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::std::optional<::Test::ByteSeq>, ::std::optional<::Test::ByteSeq>>>
Test::TestIntfPrx::opOptByteSeqAsync(const ::std::optional<ByteSeq>& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<::std::optional<ByteSeq>, ::std::optional<ByteSeq>>>(false, this, &TestIntfPrx::_iceI_opOptByteSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opOptByteSeqAsync(const ::std::optional<ByteSeq>& iceP_inSeq, ::std::function<void(::std::optional<::Test::ByteSeq>, ::std::optional<::Test::ByteSeq>)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<::std::optional<ByteSeq>, ::std::optional<ByteSeq>>&& result) mutable
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<::std::optional<ByteSeq>, ::std::optional<ByteSeq>>>(::std::move(responseCb), ::std::move(ex), ::std::move(sent), this, &Test::TestIntfPrx::_iceI_opOptByteSeq, iceP_inSeq, context);
}

void
Test::TestIntfPrx::_iceI_opOptByteSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::optional<ByteSeq>, ::std::optional<ByteSeq>>>>& outAsync, const ::std::optional<ByteSeq>& iceP_inSeq, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opOptByteSeq";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::std::nullopt, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({2}, iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<::std::optional<ByteSeq>, ::std::optional<ByteSeq>> v;
            istr->readAll({1, 3}, ::std::get<0>(v), ::std::get<1>(v));
            return v;
        });
}

::std::optional<::Test::ShortSeq>
Test::TestIntfPrx::opOptShortSeq(const ::std::optional<ShortSeq>& iceP_inSeq, ::std::optional<ShortSeq>& iceP_outSeq, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<::std::optional<ShortSeq>, ::std::optional<ShortSeq>>>(true, this, &TestIntfPrx::_iceI_opOptShortSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::std::optional<::Test::ShortSeq>, ::std::optional<::Test::ShortSeq>>>
Test::TestIntfPrx::opOptShortSeqAsync(const ::std::optional<ShortSeq>& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<::std::optional<ShortSeq>, ::std::optional<ShortSeq>>>(false, this, &TestIntfPrx::_iceI_opOptShortSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opOptShortSeqAsync(const ::std::optional<ShortSeq>& iceP_inSeq, ::std::function<void(::std::optional<::Test::ShortSeq>, ::std::optional<::Test::ShortSeq>)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<::std::optional<ShortSeq>, ::std::optional<ShortSeq>>&& result) mutable
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<::std::optional<ShortSeq>, ::std::optional<ShortSeq>>>(::std::move(responseCb), ::std::move(ex), ::std::move(sent), this, &Test::TestIntfPrx::_iceI_opOptShortSeq, iceP_inSeq, context);
}

void
Test::TestIntfPrx::_iceI_opOptShortSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::optional<ShortSeq>, ::std::optional<ShortSeq>>>>& outAsync, const ::std::optional<ShortSeq>& iceP_inSeq, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opOptShortSeq";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::std::nullopt, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({2}, iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<::std::optional<ShortSeq>, ::std::optional<ShortSeq>> v;
            istr->readAll({1, 3}, ::std::get<0>(v), ::std::get<1>(v));
            return v;
        });
}

::std::optional<::Test::IntSeq>
Test::TestIntfPrx::opOptIntSeq(const ::std::optional<IntSeq>& iceP_inSeq, ::std::optional<IntSeq>& iceP_outSeq, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<::std::optional<IntSeq>, ::std::optional<IntSeq>>>(true, this, &TestIntfPrx::_iceI_opOptIntSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::std::optional<::Test::IntSeq>, ::std::optional<::Test::IntSeq>>>
Test::TestIntfPrx::opOptIntSeqAsync(const ::std::optional<IntSeq>& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<::std::optional<IntSeq>, ::std::optional<IntSeq>>>(false, this, &TestIntfPrx::_iceI_opOptIntSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opOptIntSeqAsync(const ::std::optional<IntSeq>& iceP_inSeq, ::std::function<void(::std::optional<::Test::IntSeq>, ::std::optional<::Test::IntSeq>)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<::std::optional<IntSeq>, ::std::optional<IntSeq>>&& result) mutable
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<::std::optional<IntSeq>, ::std::optional<IntSeq>>>(::std::move(responseCb), ::std::move(ex), ::std::move(sent), this, &Test::TestIntfPrx::_iceI_opOptIntSeq, iceP_inSeq, context);
}

void
Test::TestIntfPrx::_iceI_opOptIntSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::optional<IntSeq>, ::std::optional<IntSeq>>>>& outAsync, const ::std::optional<IntSeq>& iceP_inSeq, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opOptIntSeq";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::std::nullopt, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({2}, iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<::std::optional<IntSeq>, ::std::optional<IntSeq>> v;
            istr->readAll({1, 3}, ::std::get<0>(v), ::std::get<1>(v));
            return v;
        });
}

::std::optional<::Test::LongSeq>
Test::TestIntfPrx::opOptLongSeq(const ::std::optional<LongSeq>& iceP_inSeq, ::std::optional<LongSeq>& iceP_outSeq, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<::std::optional<LongSeq>, ::std::optional<LongSeq>>>(true, this, &TestIntfPrx::_iceI_opOptLongSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::std::optional<::Test::LongSeq>, ::std::optional<::Test::LongSeq>>>
Test::TestIntfPrx::opOptLongSeqAsync(const ::std::optional<LongSeq>& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<::std::optional<LongSeq>, ::std::optional<LongSeq>>>(false, this, &TestIntfPrx::_iceI_opOptLongSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opOptLongSeqAsync(const ::std::optional<LongSeq>& iceP_inSeq, ::std::function<void(::std::optional<::Test::LongSeq>, ::std::optional<::Test::LongSeq>)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<::std::optional<LongSeq>, ::std::optional<LongSeq>>&& result) mutable
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<::std::optional<LongSeq>, ::std::optional<LongSeq>>>(::std::move(responseCb), ::std::move(ex), ::std::move(sent), this, &Test::TestIntfPrx::_iceI_opOptLongSeq, iceP_inSeq, context);
}

void
Test::TestIntfPrx::_iceI_opOptLongSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::optional<LongSeq>, ::std::optional<LongSeq>>>>& outAsync, const ::std::optional<LongSeq>& iceP_inSeq, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opOptLongSeq";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::std::nullopt, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({2}, iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<::std::optional<LongSeq>, ::std::optional<LongSeq>> v;
            istr->readAll({1, 3}, ::std::get<0>(v), ::std::get<1>(v));
            return v;
        });
}

::std::optional<::Test::FloatSeq>
Test::TestIntfPrx::opOptFloatSeq(const ::std::optional<FloatSeq>& iceP_inSeq, ::std::optional<FloatSeq>& iceP_outSeq, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<::std::optional<FloatSeq>, ::std::optional<FloatSeq>>>(true, this, &TestIntfPrx::_iceI_opOptFloatSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::std::optional<::Test::FloatSeq>, ::std::optional<::Test::FloatSeq>>>
Test::TestIntfPrx::opOptFloatSeqAsync(const ::std::optional<FloatSeq>& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<::std::optional<FloatSeq>, ::std::optional<FloatSeq>>>(false, this, &TestIntfPrx::_iceI_opOptFloatSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opOptFloatSeqAsync(const ::std::optional<FloatSeq>& iceP_inSeq, ::std::function<void(::std::optional<::Test::FloatSeq>, ::std::optional<::Test::FloatSeq>)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<::std::optional<FloatSeq>, ::std::optional<FloatSeq>>&& result) mutable
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<::std::optional<FloatSeq>, ::std::optional<FloatSeq>>>(::std::move(responseCb), ::std::move(ex), ::std::move(sent), this, &Test::TestIntfPrx::_iceI_opOptFloatSeq, iceP_inSeq, context);
}

void
Test::TestIntfPrx::_iceI_opOptFloatSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::optional<FloatSeq>, ::std::optional<FloatSeq>>>>& outAsync, const ::std::optional<FloatSeq>& iceP_inSeq, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opOptFloatSeq";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::std::nullopt, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({2}, iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<::std::optional<FloatSeq>, ::std::optional<FloatSeq>> v;
            istr->readAll({1, 3}, ::std::get<0>(v), ::std::get<1>(v));
            return v;
        });
}

::std::optional<::Test::DoubleSeq>
Test::TestIntfPrx::opOptDoubleSeq(const ::std::optional<DoubleSeq>& iceP_inSeq, ::std::optional<DoubleSeq>& iceP_outSeq, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<::std::optional<DoubleSeq>, ::std::optional<DoubleSeq>>>(true, this, &TestIntfPrx::_iceI_opOptDoubleSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::std::optional<::Test::DoubleSeq>, ::std::optional<::Test::DoubleSeq>>>
Test::TestIntfPrx::opOptDoubleSeqAsync(const ::std::optional<DoubleSeq>& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<::std::optional<DoubleSeq>, ::std::optional<DoubleSeq>>>(false, this, &TestIntfPrx::_iceI_opOptDoubleSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opOptDoubleSeqAsync(const ::std::optional<DoubleSeq>& iceP_inSeq, ::std::function<void(::std::optional<::Test::DoubleSeq>, ::std::optional<::Test::DoubleSeq>)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<::std::optional<DoubleSeq>, ::std::optional<DoubleSeq>>&& result) mutable
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<::std::optional<DoubleSeq>, ::std::optional<DoubleSeq>>>(::std::move(responseCb), ::std::move(ex), ::std::move(sent), this, &Test::TestIntfPrx::_iceI_opOptDoubleSeq, iceP_inSeq, context);
}

void
Test::TestIntfPrx::_iceI_opOptDoubleSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::optional<DoubleSeq>, ::std::optional<DoubleSeq>>>>& outAsync, const ::std::optional<DoubleSeq>& iceP_inSeq, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opOptDoubleSeq";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::std::nullopt, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({2}, iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<::std::optional<DoubleSeq>, ::std::optional<DoubleSeq>> v;
            istr->readAll({1, 3}, ::std::get<0>(v), ::std::get<1>(v));
            return v;
        });
}

::std::optional<::Test::StringSeq>
Test::TestIntfPrx::opOptStringSeq(const ::std::optional<StringSeq>& iceP_inSeq, ::std::optional<StringSeq>& iceP_outSeq, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<::std::optional<StringSeq>, ::std::optional<StringSeq>>>(true, this, &TestIntfPrx::_iceI_opOptStringSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::std::optional<::Test::StringSeq>, ::std::optional<::Test::StringSeq>>>
Test::TestIntfPrx::opOptStringSeqAsync(const ::std::optional<StringSeq>& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<::std::optional<StringSeq>, ::std::optional<StringSeq>>>(false, this, &TestIntfPrx::_iceI_opOptStringSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opOptStringSeqAsync(const ::std::optional<StringSeq>& iceP_inSeq, ::std::function<void(::std::optional<::Test::StringSeq>, ::std::optional<::Test::StringSeq>)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<::std::optional<StringSeq>, ::std::optional<StringSeq>>&& result) mutable
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<::std::optional<StringSeq>, ::std::optional<StringSeq>>>(::std::move(responseCb), ::std::move(ex), ::std::move(sent), this, &Test::TestIntfPrx::_iceI_opOptStringSeq, iceP_inSeq, context);
}

void
Test::TestIntfPrx::_iceI_opOptStringSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::optional<StringSeq>, ::std::optional<StringSeq>>>>& outAsync, const ::std::optional<StringSeq>& iceP_inSeq, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opOptStringSeq";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::std::nullopt, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({2}, iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<::std::optional<StringSeq>, ::std::optional<StringSeq>> v;
            istr->readAll({1, 3}, ::std::get<0>(v), ::std::get<1>(v));
            return v;
        });
}

::std::optional<::Test::ESeq>
Test::TestIntfPrx::opOptESeq(const ::std::optional<ESeq>& iceP_inSeq, ::std::optional<ESeq>& iceP_outSeq, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<::std::optional<ESeq>, ::std::optional<ESeq>>>(true, this, &TestIntfPrx::_iceI_opOptESeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::std::optional<::Test::ESeq>, ::std::optional<::Test::ESeq>>>
Test::TestIntfPrx::opOptESeqAsync(const ::std::optional<ESeq>& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<::std::optional<ESeq>, ::std::optional<ESeq>>>(false, this, &TestIntfPrx::_iceI_opOptESeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opOptESeqAsync(const ::std::optional<ESeq>& iceP_inSeq, ::std::function<void(::std::optional<::Test::ESeq>, ::std::optional<::Test::ESeq>)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<::std::optional<ESeq>, ::std::optional<ESeq>>&& result) mutable
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<::std::optional<ESeq>, ::std::optional<ESeq>>>(::std::move(responseCb), ::std::move(ex), ::std::move(sent), this, &Test::TestIntfPrx::_iceI_opOptESeq, iceP_inSeq, context);
}

void
Test::TestIntfPrx::_iceI_opOptESeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::optional<ESeq>, ::std::optional<ESeq>>>>& outAsync, const ::std::optional<ESeq>& iceP_inSeq, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opOptESeq";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::std::nullopt, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({2}, iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<::std::optional<ESeq>, ::std::optional<ESeq>> v;
            istr->readAll({1, 3}, ::std::get<0>(v), ::std::get<1>(v));
            return v;
        });
}

::std::optional<::Test::SSeq>
Test::TestIntfPrx::opOptSSeq(const ::std::optional<SSeq>& iceP_inSeq, ::std::optional<SSeq>& iceP_outSeq, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<::std::optional<SSeq>, ::std::optional<SSeq>>>(true, this, &TestIntfPrx::_iceI_opOptSSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::std::optional<::Test::SSeq>, ::std::optional<::Test::SSeq>>>
Test::TestIntfPrx::opOptSSeqAsync(const ::std::optional<SSeq>& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<::std::optional<SSeq>, ::std::optional<SSeq>>>(false, this, &TestIntfPrx::_iceI_opOptSSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opOptSSeqAsync(const ::std::optional<SSeq>& iceP_inSeq, ::std::function<void(::std::optional<::Test::SSeq>, ::std::optional<::Test::SSeq>)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<::std::optional<SSeq>, ::std::optional<SSeq>>&& result) mutable
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<::std::optional<SSeq>, ::std::optional<SSeq>>>(::std::move(responseCb), ::std::move(ex), ::std::move(sent), this, &Test::TestIntfPrx::_iceI_opOptSSeq, iceP_inSeq, context);
}

void
Test::TestIntfPrx::_iceI_opOptSSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::optional<SSeq>, ::std::optional<SSeq>>>>& outAsync, const ::std::optional<SSeq>& iceP_inSeq, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opOptSSeq";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::std::nullopt, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({2}, iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<::std::optional<SSeq>, ::std::optional<SSeq>> v;
            istr->readAll({1, 3}, ::std::get<0>(v), ::std::get<1>(v));
            return v;
        });
}

::std::optional<::Test::DSeq>
Test::TestIntfPrx::opOptDSeq(const ::std::optional<DSeq>& iceP_inSeq, ::std::optional<DSeq>& iceP_outSeq, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<::std::optional<DSeq>, ::std::optional<DSeq>>>(true, this, &TestIntfPrx::_iceI_opOptDSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::std::optional<::Test::DSeq>, ::std::optional<::Test::DSeq>>>
Test::TestIntfPrx::opOptDSeqAsync(const ::std::optional<DSeq>& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<::std::optional<DSeq>, ::std::optional<DSeq>>>(false, this, &TestIntfPrx::_iceI_opOptDSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opOptDSeqAsync(const ::std::optional<DSeq>& iceP_inSeq, ::std::function<void(::std::optional<::Test::DSeq>, ::std::optional<::Test::DSeq>)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<::std::optional<DSeq>, ::std::optional<DSeq>>&& result) mutable
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<::std::optional<DSeq>, ::std::optional<DSeq>>>(::std::move(responseCb), ::std::move(ex), ::std::move(sent), this, &Test::TestIntfPrx::_iceI_opOptDSeq, iceP_inSeq, context);
}

void
Test::TestIntfPrx::_iceI_opOptDSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::optional<DSeq>, ::std::optional<DSeq>>>>& outAsync, const ::std::optional<DSeq>& iceP_inSeq, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opOptDSeq";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::std::nullopt, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({2}, iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<::std::optional<DSeq>, ::std::optional<DSeq>> v;
            istr->readAll({1, 3}, ::std::get<0>(v), ::std::get<1>(v));
            return v;
        });
}

::std::optional<::Test::StringSeqSeq>
Test::TestIntfPrx::opOptStringSeqSeq(const ::std::optional<StringSeqSeq>& iceP_inSeq, ::std::optional<StringSeqSeq>& iceP_outSeq, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<::std::optional<StringSeqSeq>, ::std::optional<StringSeqSeq>>>(true, this, &TestIntfPrx::_iceI_opOptStringSeqSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::std::optional<::Test::StringSeqSeq>, ::std::optional<::Test::StringSeqSeq>>>
Test::TestIntfPrx::opOptStringSeqSeqAsync(const ::std::optional<StringSeqSeq>& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<::std::optional<StringSeqSeq>, ::std::optional<StringSeqSeq>>>(false, this, &TestIntfPrx::_iceI_opOptStringSeqSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opOptStringSeqSeqAsync(const ::std::optional<StringSeqSeq>& iceP_inSeq, ::std::function<void(::std::optional<::Test::StringSeqSeq>, ::std::optional<::Test::StringSeqSeq>)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<::std::optional<StringSeqSeq>, ::std::optional<StringSeqSeq>>&& result) mutable
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<::std::optional<StringSeqSeq>, ::std::optional<StringSeqSeq>>>(::std::move(responseCb), ::std::move(ex), ::std::move(sent), this, &Test::TestIntfPrx::_iceI_opOptStringSeqSeq, iceP_inSeq, context);
}

void
Test::TestIntfPrx::_iceI_opOptStringSeqSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::optional<StringSeqSeq>, ::std::optional<StringSeqSeq>>>>& outAsync, const ::std::optional<StringSeqSeq>& iceP_inSeq, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opOptStringSeqSeq";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::std::nullopt, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({2}, iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<::std::optional<StringSeqSeq>, ::std::optional<StringSeqSeq>> v;
            istr->readAll({1, 3}, ::std::get<0>(v), ::std::get<1>(v));
            return v;
        });
}

::std::optional<::Test::ByteBuffer>
Test::TestIntfPrx::opOptByteBufferSeq(const ::std::optional<ByteBuffer>& iceP_inSeq, ::std::optional<ByteBuffer>& iceP_outSeq, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<::std::optional<ByteBuffer>, ::std::optional<ByteBuffer>>>(true, this, &TestIntfPrx::_iceI_opOptByteBufferSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::std::optional<::Test::ByteBuffer>, ::std::optional<::Test::ByteBuffer>>>
Test::TestIntfPrx::opOptByteBufferSeqAsync(const ::std::optional<ByteBuffer>& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<::std::optional<ByteBuffer>, ::std::optional<ByteBuffer>>>(false, this, &TestIntfPrx::_iceI_opOptByteBufferSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opOptByteBufferSeqAsync(const ::std::optional<ByteBuffer>& iceP_inSeq, ::std::function<void(::std::optional<::Test::ByteBuffer>, ::std::optional<::Test::ByteBuffer>)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<::std::optional<ByteBuffer>, ::std::optional<ByteBuffer>>&& result) mutable
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<::std::optional<ByteBuffer>, ::std::optional<ByteBuffer>>>(::std::move(responseCb), ::std::move(ex), ::std::move(sent), this, &Test::TestIntfPrx::_iceI_opOptByteBufferSeq, iceP_inSeq, context);
}

void
Test::TestIntfPrx::_iceI_opOptByteBufferSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::optional<ByteBuffer>, ::std::optional<ByteBuffer>>>>& outAsync, const ::std::optional<ByteBuffer>& iceP_inSeq, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opOptByteBufferSeq";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::std::nullopt, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({2}, iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<::std::optional<ByteBuffer>, ::std::optional<ByteBuffer>> v;
            istr->readAll({1, 3}, ::std::get<0>(v), ::std::get<1>(v));
            return v;
        });
}

::std::optional<::Test::ShortBuffer>
Test::TestIntfPrx::opOptShortBufferSeq(const ::std::optional<ShortBuffer>& iceP_inSeq, ::std::optional<ShortBuffer>& iceP_outSeq, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<::std::optional<ShortBuffer>, ::std::optional<ShortBuffer>>>(true, this, &TestIntfPrx::_iceI_opOptShortBufferSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::std::optional<::Test::ShortBuffer>, ::std::optional<::Test::ShortBuffer>>>
Test::TestIntfPrx::opOptShortBufferSeqAsync(const ::std::optional<ShortBuffer>& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<::std::optional<ShortBuffer>, ::std::optional<ShortBuffer>>>(false, this, &TestIntfPrx::_iceI_opOptShortBufferSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opOptShortBufferSeqAsync(const ::std::optional<ShortBuffer>& iceP_inSeq, ::std::function<void(::std::optional<::Test::ShortBuffer>, ::std::optional<::Test::ShortBuffer>)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<::std::optional<ShortBuffer>, ::std::optional<ShortBuffer>>&& result) mutable
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<::std::optional<ShortBuffer>, ::std::optional<ShortBuffer>>>(::std::move(responseCb), ::std::move(ex), ::std::move(sent), this, &Test::TestIntfPrx::_iceI_opOptShortBufferSeq, iceP_inSeq, context);
}

void
Test::TestIntfPrx::_iceI_opOptShortBufferSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::optional<ShortBuffer>, ::std::optional<ShortBuffer>>>>& outAsync, const ::std::optional<ShortBuffer>& iceP_inSeq, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opOptShortBufferSeq";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::std::nullopt, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({2}, iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<::std::optional<ShortBuffer>, ::std::optional<ShortBuffer>> v;
            istr->readAll({1, 3}, ::std::get<0>(v), ::std::get<1>(v));
            return v;
        });
}

::std::optional<::Test::IntBuffer>
Test::TestIntfPrx::opOptIntBufferSeq(const ::std::optional<IntBuffer>& iceP_inSeq, ::std::optional<IntBuffer>& iceP_outSeq, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<::std::optional<IntBuffer>, ::std::optional<IntBuffer>>>(true, this, &TestIntfPrx::_iceI_opOptIntBufferSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::std::optional<::Test::IntBuffer>, ::std::optional<::Test::IntBuffer>>>
Test::TestIntfPrx::opOptIntBufferSeqAsync(const ::std::optional<IntBuffer>& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<::std::optional<IntBuffer>, ::std::optional<IntBuffer>>>(false, this, &TestIntfPrx::_iceI_opOptIntBufferSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opOptIntBufferSeqAsync(const ::std::optional<IntBuffer>& iceP_inSeq, ::std::function<void(::std::optional<::Test::IntBuffer>, ::std::optional<::Test::IntBuffer>)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<::std::optional<IntBuffer>, ::std::optional<IntBuffer>>&& result) mutable
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<::std::optional<IntBuffer>, ::std::optional<IntBuffer>>>(::std::move(responseCb), ::std::move(ex), ::std::move(sent), this, &Test::TestIntfPrx::_iceI_opOptIntBufferSeq, iceP_inSeq, context);
}

void
Test::TestIntfPrx::_iceI_opOptIntBufferSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::optional<IntBuffer>, ::std::optional<IntBuffer>>>>& outAsync, const ::std::optional<IntBuffer>& iceP_inSeq, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opOptIntBufferSeq";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::std::nullopt, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({2}, iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<::std::optional<IntBuffer>, ::std::optional<IntBuffer>> v;
            istr->readAll({1, 3}, ::std::get<0>(v), ::std::get<1>(v));
            return v;
        });
}

::std::optional<::Test::LongBuffer>
Test::TestIntfPrx::opOptLongBufferSeq(const ::std::optional<LongBuffer>& iceP_inSeq, ::std::optional<LongBuffer>& iceP_outSeq, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<::std::optional<LongBuffer>, ::std::optional<LongBuffer>>>(true, this, &TestIntfPrx::_iceI_opOptLongBufferSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::std::optional<::Test::LongBuffer>, ::std::optional<::Test::LongBuffer>>>
Test::TestIntfPrx::opOptLongBufferSeqAsync(const ::std::optional<LongBuffer>& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<::std::optional<LongBuffer>, ::std::optional<LongBuffer>>>(false, this, &TestIntfPrx::_iceI_opOptLongBufferSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opOptLongBufferSeqAsync(const ::std::optional<LongBuffer>& iceP_inSeq, ::std::function<void(::std::optional<::Test::LongBuffer>, ::std::optional<::Test::LongBuffer>)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<::std::optional<LongBuffer>, ::std::optional<LongBuffer>>&& result) mutable
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<::std::optional<LongBuffer>, ::std::optional<LongBuffer>>>(::std::move(responseCb), ::std::move(ex), ::std::move(sent), this, &Test::TestIntfPrx::_iceI_opOptLongBufferSeq, iceP_inSeq, context);
}

void
Test::TestIntfPrx::_iceI_opOptLongBufferSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::optional<LongBuffer>, ::std::optional<LongBuffer>>>>& outAsync, const ::std::optional<LongBuffer>& iceP_inSeq, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opOptLongBufferSeq";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::std::nullopt, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({2}, iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<::std::optional<LongBuffer>, ::std::optional<LongBuffer>> v;
            istr->readAll({1, 3}, ::std::get<0>(v), ::std::get<1>(v));
            return v;
        });
}

::std::optional<::Test::FloatBuffer>
Test::TestIntfPrx::opOptFloatBufferSeq(const ::std::optional<FloatBuffer>& iceP_inSeq, ::std::optional<FloatBuffer>& iceP_outSeq, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<::std::optional<FloatBuffer>, ::std::optional<FloatBuffer>>>(true, this, &TestIntfPrx::_iceI_opOptFloatBufferSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::std::optional<::Test::FloatBuffer>, ::std::optional<::Test::FloatBuffer>>>
Test::TestIntfPrx::opOptFloatBufferSeqAsync(const ::std::optional<FloatBuffer>& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<::std::optional<FloatBuffer>, ::std::optional<FloatBuffer>>>(false, this, &TestIntfPrx::_iceI_opOptFloatBufferSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opOptFloatBufferSeqAsync(const ::std::optional<FloatBuffer>& iceP_inSeq, ::std::function<void(::std::optional<::Test::FloatBuffer>, ::std::optional<::Test::FloatBuffer>)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<::std::optional<FloatBuffer>, ::std::optional<FloatBuffer>>&& result) mutable
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<::std::optional<FloatBuffer>, ::std::optional<FloatBuffer>>>(::std::move(responseCb), ::std::move(ex), ::std::move(sent), this, &Test::TestIntfPrx::_iceI_opOptFloatBufferSeq, iceP_inSeq, context);
}

void
Test::TestIntfPrx::_iceI_opOptFloatBufferSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::optional<FloatBuffer>, ::std::optional<FloatBuffer>>>>& outAsync, const ::std::optional<FloatBuffer>& iceP_inSeq, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opOptFloatBufferSeq";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::std::nullopt, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({2}, iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<::std::optional<FloatBuffer>, ::std::optional<FloatBuffer>> v;
            istr->readAll({1, 3}, ::std::get<0>(v), ::std::get<1>(v));
            return v;
        });
}

::std::optional<::Test::DoubleBuffer>
Test::TestIntfPrx::opOptDoubleBufferSeq(const ::std::optional<DoubleBuffer>& iceP_inSeq, ::std::optional<DoubleBuffer>& iceP_outSeq, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<::std::optional<DoubleBuffer>, ::std::optional<DoubleBuffer>>>(true, this, &TestIntfPrx::_iceI_opOptDoubleBufferSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::std::optional<::Test::DoubleBuffer>, ::std::optional<::Test::DoubleBuffer>>>
Test::TestIntfPrx::opOptDoubleBufferSeqAsync(const ::std::optional<DoubleBuffer>& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<::std::optional<DoubleBuffer>, ::std::optional<DoubleBuffer>>>(false, this, &TestIntfPrx::_iceI_opOptDoubleBufferSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opOptDoubleBufferSeqAsync(const ::std::optional<DoubleBuffer>& iceP_inSeq, ::std::function<void(::std::optional<::Test::DoubleBuffer>, ::std::optional<::Test::DoubleBuffer>)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<::std::optional<DoubleBuffer>, ::std::optional<DoubleBuffer>>&& result) mutable
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<::std::optional<DoubleBuffer>, ::std::optional<DoubleBuffer>>>(::std::move(responseCb), ::std::move(ex), ::std::move(sent), this, &Test::TestIntfPrx::_iceI_opOptDoubleBufferSeq, iceP_inSeq, context);
}

void
Test::TestIntfPrx::_iceI_opOptDoubleBufferSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::optional<DoubleBuffer>, ::std::optional<DoubleBuffer>>>>& outAsync, const ::std::optional<DoubleBuffer>& iceP_inSeq, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opOptDoubleBufferSeq";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::std::nullopt, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({2}, iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<::std::optional<DoubleBuffer>, ::std::optional<DoubleBuffer>> v;
            istr->readAll({1, 3}, ::std::get<0>(v), ::std::get<1>(v));
            return v;
        });
}

void
Test::TestIntfPrx::shutdown(const ::Ice::Context& context) const
{
    ::IceInternal::makePromiseOutgoing<void>(true, this, &TestIntfPrx::_iceI_shutdown, context).get();
}

::std::future<void>
Test::TestIntfPrx::shutdownAsync(const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<void>(false, this, &TestIntfPrx::_iceI_shutdown, context);
}

::std::function<void()>
Test::TestIntfPrx::shutdownAsync(::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<void>(::std::move(response), ::std::move(ex), ::std::move(sent), this, &Test::TestIntfPrx::_iceI_shutdown, context);
}

void
Test::TestIntfPrx::_iceI_shutdown(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "shutdown";

    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::std::nullopt, context,
        nullptr,
        nullptr);
}

const char*
Test::TestIntfPrx::ice_staticId() noexcept
{
    return "::Test::TestIntf";
}

::std::vector<::std::string>
Test::TestIntf::ice_ids(const ::Ice::Current&) const
{
    static const ::std::vector<::std::string> allTypeIds = {"::Ice::Object", "::Test::TestIntf"};
    return allTypeIds;
}

::std::string
Test::TestIntf::ice_id(const ::Ice::Current&) const
{
    return ::std::string{ice_staticId()};
}

const char*
Test::TestIntf::ice_staticId() noexcept
{
    return "::Test::TestIntf";
}

/// \cond INTERNAL
void
Test::TestIntf::_iceD_opASeq(
    ::Ice::IncomingRequest& request,
    ::std::function<void(::Ice::OutgoingResponse)> sendResponse) // NOLINT:performance-unnecessary-value-param
{
    _iceCheckMode(::Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    ASeq iceP_inSeq;
    istr->readAll(iceP_inSeq);
    istr->endEncapsulation();
    ASeq iceP_outSeq;
    const ASeq ret = this->opASeq(::std::move(iceP_inSeq), iceP_outSeq, request.current());
    sendResponse(::Ice::makeOutgoingResponse([&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_outSeq, ret);
        },
        request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_opAArray(
    ::Ice::IncomingRequest& request,
    ::std::function<void(::Ice::OutgoingResponse)> sendResponse) // NOLINT:performance-unnecessary-value-param
{
    _iceCheckMode(::Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    AArray iceP_inSeq;
    istr->readAll(iceP_inSeq);
    istr->endEncapsulation();
    AArray iceP_outSeq;
    const AArray ret = this->opAArray(::std::move(iceP_inSeq), iceP_outSeq, request.current());
    sendResponse(::Ice::makeOutgoingResponse([&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_outSeq, ret);
        },
        request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_opAList(
    ::Ice::IncomingRequest& request,
    ::std::function<void(::Ice::OutgoingResponse)> sendResponse) // NOLINT:performance-unnecessary-value-param
{
    _iceCheckMode(::Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    AList iceP_inSeq;
    istr->readAll(iceP_inSeq);
    istr->endEncapsulation();
    AList iceP_outSeq;
    const AList ret = this->opAList(::std::move(iceP_inSeq), iceP_outSeq, request.current());
    sendResponse(::Ice::makeOutgoingResponse([&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_outSeq, ret);
        },
        request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_opBoolSeq(
    ::Ice::IncomingRequest& request,
    ::std::function<void(::Ice::OutgoingResponse)> sendResponse) // NOLINT:performance-unnecessary-value-param
{
    _iceCheckMode(::Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    BoolSeq iceP_inSeq;
    istr->readAll(iceP_inSeq);
    istr->endEncapsulation();
    BoolSeq iceP_outSeq;
    const BoolSeq ret = this->opBoolSeq(::std::move(iceP_inSeq), iceP_outSeq, request.current());
    sendResponse(::Ice::makeOutgoingResponse([&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_outSeq, ret);
        },
        request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_opByteSeq(
    ::Ice::IncomingRequest& request,
    ::std::function<void(::Ice::OutgoingResponse)> sendResponse) // NOLINT:performance-unnecessary-value-param
{
    _iceCheckMode(::Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    ByteSeq iceP_inSeq;
    istr->readAll(iceP_inSeq);
    istr->endEncapsulation();
    ByteSeq iceP_outSeq;
    const ByteSeq ret = this->opByteSeq(::std::move(iceP_inSeq), iceP_outSeq, request.current());
    sendResponse(::Ice::makeOutgoingResponse([&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_outSeq, ret);
        },
        request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_opShortSeq(
    ::Ice::IncomingRequest& request,
    ::std::function<void(::Ice::OutgoingResponse)> sendResponse) // NOLINT:performance-unnecessary-value-param
{
    _iceCheckMode(::Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    ShortSeq iceP_inSeq;
    istr->readAll(iceP_inSeq);
    istr->endEncapsulation();
    ShortSeq iceP_outSeq;
    const ShortSeq ret = this->opShortSeq(::std::move(iceP_inSeq), iceP_outSeq, request.current());
    sendResponse(::Ice::makeOutgoingResponse([&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_outSeq, ret);
        },
        request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_opIntSeq(
    ::Ice::IncomingRequest& request,
    ::std::function<void(::Ice::OutgoingResponse)> sendResponse) // NOLINT:performance-unnecessary-value-param
{
    _iceCheckMode(::Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    IntSeq iceP_inSeq;
    istr->readAll(iceP_inSeq);
    istr->endEncapsulation();
    IntSeq iceP_outSeq;
    const IntSeq ret = this->opIntSeq(::std::move(iceP_inSeq), iceP_outSeq, request.current());
    sendResponse(::Ice::makeOutgoingResponse([&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_outSeq, ret);
        },
        request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_opLongSeq(
    ::Ice::IncomingRequest& request,
    ::std::function<void(::Ice::OutgoingResponse)> sendResponse) // NOLINT:performance-unnecessary-value-param
{
    _iceCheckMode(::Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    LongSeq iceP_inSeq;
    istr->readAll(iceP_inSeq);
    istr->endEncapsulation();
    LongSeq iceP_outSeq;
    const LongSeq ret = this->opLongSeq(::std::move(iceP_inSeq), iceP_outSeq, request.current());
    sendResponse(::Ice::makeOutgoingResponse([&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_outSeq, ret);
        },
        request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_opFloatSeq(
    ::Ice::IncomingRequest& request,
    ::std::function<void(::Ice::OutgoingResponse)> sendResponse) // NOLINT:performance-unnecessary-value-param
{
    _iceCheckMode(::Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    FloatSeq iceP_inSeq;
    istr->readAll(iceP_inSeq);
    istr->endEncapsulation();
    FloatSeq iceP_outSeq;
    const FloatSeq ret = this->opFloatSeq(::std::move(iceP_inSeq), iceP_outSeq, request.current());
    sendResponse(::Ice::makeOutgoingResponse([&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_outSeq, ret);
        },
        request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_opDoubleSeq(
    ::Ice::IncomingRequest& request,
    ::std::function<void(::Ice::OutgoingResponse)> sendResponse) // NOLINT:performance-unnecessary-value-param
{
    _iceCheckMode(::Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    DoubleSeq iceP_inSeq;
    istr->readAll(iceP_inSeq);
    istr->endEncapsulation();
    DoubleSeq iceP_outSeq;
    const DoubleSeq ret = this->opDoubleSeq(::std::move(iceP_inSeq), iceP_outSeq, request.current());
    sendResponse(::Ice::makeOutgoingResponse([&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_outSeq, ret);
        },
        request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_opStringSeq(
    ::Ice::IncomingRequest& request,
    ::std::function<void(::Ice::OutgoingResponse)> sendResponse) // NOLINT:performance-unnecessary-value-param
{
    _iceCheckMode(::Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    StringSeq iceP_inSeq;
    istr->readAll(iceP_inSeq);
    istr->endEncapsulation();
    StringSeq iceP_outSeq;
    const StringSeq ret = this->opStringSeq(::std::move(iceP_inSeq), iceP_outSeq, request.current());
    sendResponse(::Ice::makeOutgoingResponse([&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_outSeq, ret);
        },
        request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_opESeq(
    ::Ice::IncomingRequest& request,
    ::std::function<void(::Ice::OutgoingResponse)> sendResponse) // NOLINT:performance-unnecessary-value-param
{
    _iceCheckMode(::Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    ESeq iceP_inSeq;
    istr->readAll(iceP_inSeq);
    istr->endEncapsulation();
    ESeq iceP_outSeq;
    const ESeq ret = this->opESeq(::std::move(iceP_inSeq), iceP_outSeq, request.current());
    sendResponse(::Ice::makeOutgoingResponse([&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_outSeq, ret);
        },
        request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_opSSeq(
    ::Ice::IncomingRequest& request,
    ::std::function<void(::Ice::OutgoingResponse)> sendResponse) // NOLINT:performance-unnecessary-value-param
{
    _iceCheckMode(::Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    SSeq iceP_inSeq;
    istr->readAll(iceP_inSeq);
    istr->endEncapsulation();
    SSeq iceP_outSeq;
    const SSeq ret = this->opSSeq(::std::move(iceP_inSeq), iceP_outSeq, request.current());
    sendResponse(::Ice::makeOutgoingResponse([&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_outSeq, ret);
        },
        request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_opDSeq(
    ::Ice::IncomingRequest& request,
    ::std::function<void(::Ice::OutgoingResponse)> sendResponse) // NOLINT:performance-unnecessary-value-param
{
    _iceCheckMode(::Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    DSeq iceP_inSeq;
    istr->readAll(iceP_inSeq);
    istr->endEncapsulation();
    DSeq iceP_outSeq;
    const DSeq ret = this->opDSeq(::std::move(iceP_inSeq), iceP_outSeq, request.current());
    sendResponse(::Ice::makeOutgoingResponse([&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_outSeq, ret);
        },
        request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_opStringSeqSeq(
    ::Ice::IncomingRequest& request,
    ::std::function<void(::Ice::OutgoingResponse)> sendResponse) // NOLINT:performance-unnecessary-value-param
{
    _iceCheckMode(::Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    StringSeqSeq iceP_inSeq;
    istr->readAll(iceP_inSeq);
    istr->endEncapsulation();
    StringSeqSeq iceP_outSeq;
    const StringSeqSeq ret = this->opStringSeqSeq(::std::move(iceP_inSeq), iceP_outSeq, request.current());
    sendResponse(::Ice::makeOutgoingResponse([&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_outSeq, ret);
        },
        request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_opByteBufferSeq(
    ::Ice::IncomingRequest& request,
    ::std::function<void(::Ice::OutgoingResponse)> sendResponse) // NOLINT:performance-unnecessary-value-param
{
    _iceCheckMode(::Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    ByteBuffer iceP_inSeq;
    istr->readAll(iceP_inSeq);
    istr->endEncapsulation();
    ByteBuffer iceP_outSeq;
    const ByteBuffer ret = this->opByteBufferSeq(::std::move(iceP_inSeq), iceP_outSeq, request.current());
    sendResponse(::Ice::makeOutgoingResponse([&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_outSeq, ret);
        },
        request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_opShortBufferSeq(
    ::Ice::IncomingRequest& request,
    ::std::function<void(::Ice::OutgoingResponse)> sendResponse) // NOLINT:performance-unnecessary-value-param
{
    _iceCheckMode(::Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    ShortBuffer iceP_inSeq;
    istr->readAll(iceP_inSeq);
    istr->endEncapsulation();
    ShortBuffer iceP_outSeq;
    const ShortBuffer ret = this->opShortBufferSeq(::std::move(iceP_inSeq), iceP_outSeq, request.current());
    sendResponse(::Ice::makeOutgoingResponse([&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_outSeq, ret);
        },
        request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_opIntBufferSeq(
    ::Ice::IncomingRequest& request,
    ::std::function<void(::Ice::OutgoingResponse)> sendResponse) // NOLINT:performance-unnecessary-value-param
{
    _iceCheckMode(::Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    IntBuffer iceP_inSeq;
    istr->readAll(iceP_inSeq);
    istr->endEncapsulation();
    IntBuffer iceP_outSeq;
    const IntBuffer ret = this->opIntBufferSeq(::std::move(iceP_inSeq), iceP_outSeq, request.current());
    sendResponse(::Ice::makeOutgoingResponse([&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_outSeq, ret);
        },
        request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_opLongBufferSeq(
    ::Ice::IncomingRequest& request,
    ::std::function<void(::Ice::OutgoingResponse)> sendResponse) // NOLINT:performance-unnecessary-value-param
{
    _iceCheckMode(::Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    LongBuffer iceP_inSeq;
    istr->readAll(iceP_inSeq);
    istr->endEncapsulation();
    LongBuffer iceP_outSeq;
    const LongBuffer ret = this->opLongBufferSeq(::std::move(iceP_inSeq), iceP_outSeq, request.current());
    sendResponse(::Ice::makeOutgoingResponse([&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_outSeq, ret);
        },
        request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_opFloatBufferSeq(
    ::Ice::IncomingRequest& request,
    ::std::function<void(::Ice::OutgoingResponse)> sendResponse) // NOLINT:performance-unnecessary-value-param
{
    _iceCheckMode(::Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    FloatBuffer iceP_inSeq;
    istr->readAll(iceP_inSeq);
    istr->endEncapsulation();
    FloatBuffer iceP_outSeq;
    const FloatBuffer ret = this->opFloatBufferSeq(::std::move(iceP_inSeq), iceP_outSeq, request.current());
    sendResponse(::Ice::makeOutgoingResponse([&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_outSeq, ret);
        },
        request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_opDoubleBufferSeq(
    ::Ice::IncomingRequest& request,
    ::std::function<void(::Ice::OutgoingResponse)> sendResponse) // NOLINT:performance-unnecessary-value-param
{
    _iceCheckMode(::Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    DoubleBuffer iceP_inSeq;
    istr->readAll(iceP_inSeq);
    istr->endEncapsulation();
    DoubleBuffer iceP_outSeq;
    const DoubleBuffer ret = this->opDoubleBufferSeq(::std::move(iceP_inSeq), iceP_outSeq, request.current());
    sendResponse(::Ice::makeOutgoingResponse([&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_outSeq, ret);
        },
        request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_opOptASeq(
    ::Ice::IncomingRequest& request,
    ::std::function<void(::Ice::OutgoingResponse)> sendResponse) // NOLINT:performance-unnecessary-value-param
{
    _iceCheckMode(::Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    ::std::optional<ASeq> iceP_inSeq;
    istr->readAll({2}, iceP_inSeq);
    istr->endEncapsulation();
    ::std::optional<ASeq> iceP_outSeq;
    const ::std::optional<ASeq> ret = this->opOptASeq(::std::move(iceP_inSeq), iceP_outSeq, request.current());
    sendResponse(::Ice::makeOutgoingResponse([&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({1, 3}, ret, iceP_outSeq);
        },
        request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_opOptAArray(
    ::Ice::IncomingRequest& request,
    ::std::function<void(::Ice::OutgoingResponse)> sendResponse) // NOLINT:performance-unnecessary-value-param
{
    _iceCheckMode(::Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    ::std::optional<AArray> iceP_inSeq;
    istr->readAll({2}, iceP_inSeq);
    istr->endEncapsulation();
    ::std::optional<AArray> iceP_outSeq;
    const ::std::optional<AArray> ret = this->opOptAArray(::std::move(iceP_inSeq), iceP_outSeq, request.current());
    sendResponse(::Ice::makeOutgoingResponse([&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({1, 3}, ret, iceP_outSeq);
        },
        request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_opOptAList(
    ::Ice::IncomingRequest& request,
    ::std::function<void(::Ice::OutgoingResponse)> sendResponse) // NOLINT:performance-unnecessary-value-param
{
    _iceCheckMode(::Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    ::std::optional<AList> iceP_inSeq;
    istr->readAll({2}, iceP_inSeq);
    istr->endEncapsulation();
    ::std::optional<AList> iceP_outSeq;
    const ::std::optional<AList> ret = this->opOptAList(::std::move(iceP_inSeq), iceP_outSeq, request.current());
    sendResponse(::Ice::makeOutgoingResponse([&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({1, 3}, ret, iceP_outSeq);
        },
        request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_opOptBoolSeq(
    ::Ice::IncomingRequest& request,
    ::std::function<void(::Ice::OutgoingResponse)> sendResponse) // NOLINT:performance-unnecessary-value-param
{
    _iceCheckMode(::Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    ::std::optional<BoolSeq> iceP_inSeq;
    istr->readAll({2}, iceP_inSeq);
    istr->endEncapsulation();
    ::std::optional<BoolSeq> iceP_outSeq;
    const ::std::optional<BoolSeq> ret = this->opOptBoolSeq(::std::move(iceP_inSeq), iceP_outSeq, request.current());
    sendResponse(::Ice::makeOutgoingResponse([&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({1, 3}, ret, iceP_outSeq);
        },
        request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_opOptByteSeq(
    ::Ice::IncomingRequest& request,
    ::std::function<void(::Ice::OutgoingResponse)> sendResponse) // NOLINT:performance-unnecessary-value-param
{
    _iceCheckMode(::Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    ::std::optional<ByteSeq> iceP_inSeq;
    istr->readAll({2}, iceP_inSeq);
    istr->endEncapsulation();
    ::std::optional<ByteSeq> iceP_outSeq;
    const ::std::optional<ByteSeq> ret = this->opOptByteSeq(::std::move(iceP_inSeq), iceP_outSeq, request.current());
    sendResponse(::Ice::makeOutgoingResponse([&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({1, 3}, ret, iceP_outSeq);
        },
        request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_opOptShortSeq(
    ::Ice::IncomingRequest& request,
    ::std::function<void(::Ice::OutgoingResponse)> sendResponse) // NOLINT:performance-unnecessary-value-param
{
    _iceCheckMode(::Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    ::std::optional<ShortSeq> iceP_inSeq;
    istr->readAll({2}, iceP_inSeq);
    istr->endEncapsulation();
    ::std::optional<ShortSeq> iceP_outSeq;
    const ::std::optional<ShortSeq> ret = this->opOptShortSeq(::std::move(iceP_inSeq), iceP_outSeq, request.current());
    sendResponse(::Ice::makeOutgoingResponse([&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({1, 3}, ret, iceP_outSeq);
        },
        request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_opOptIntSeq(
    ::Ice::IncomingRequest& request,
    ::std::function<void(::Ice::OutgoingResponse)> sendResponse) // NOLINT:performance-unnecessary-value-param
{
    _iceCheckMode(::Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    ::std::optional<IntSeq> iceP_inSeq;
    istr->readAll({2}, iceP_inSeq);
    istr->endEncapsulation();
    ::std::optional<IntSeq> iceP_outSeq;
    const ::std::optional<IntSeq> ret = this->opOptIntSeq(::std::move(iceP_inSeq), iceP_outSeq, request.current());
    sendResponse(::Ice::makeOutgoingResponse([&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({1, 3}, ret, iceP_outSeq);
        },
        request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_opOptLongSeq(
    ::Ice::IncomingRequest& request,
    ::std::function<void(::Ice::OutgoingResponse)> sendResponse) // NOLINT:performance-unnecessary-value-param
{
    _iceCheckMode(::Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    ::std::optional<LongSeq> iceP_inSeq;
    istr->readAll({2}, iceP_inSeq);
    istr->endEncapsulation();
    ::std::optional<LongSeq> iceP_outSeq;
    const ::std::optional<LongSeq> ret = this->opOptLongSeq(::std::move(iceP_inSeq), iceP_outSeq, request.current());
    sendResponse(::Ice::makeOutgoingResponse([&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({1, 3}, ret, iceP_outSeq);
        },
        request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_opOptFloatSeq(
    ::Ice::IncomingRequest& request,
    ::std::function<void(::Ice::OutgoingResponse)> sendResponse) // NOLINT:performance-unnecessary-value-param
{
    _iceCheckMode(::Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    ::std::optional<FloatSeq> iceP_inSeq;
    istr->readAll({2}, iceP_inSeq);
    istr->endEncapsulation();
    ::std::optional<FloatSeq> iceP_outSeq;
    const ::std::optional<FloatSeq> ret = this->opOptFloatSeq(::std::move(iceP_inSeq), iceP_outSeq, request.current());
    sendResponse(::Ice::makeOutgoingResponse([&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({1, 3}, ret, iceP_outSeq);
        },
        request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_opOptDoubleSeq(
    ::Ice::IncomingRequest& request,
    ::std::function<void(::Ice::OutgoingResponse)> sendResponse) // NOLINT:performance-unnecessary-value-param
{
    _iceCheckMode(::Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    ::std::optional<DoubleSeq> iceP_inSeq;
    istr->readAll({2}, iceP_inSeq);
    istr->endEncapsulation();
    ::std::optional<DoubleSeq> iceP_outSeq;
    const ::std::optional<DoubleSeq> ret = this->opOptDoubleSeq(::std::move(iceP_inSeq), iceP_outSeq, request.current());
    sendResponse(::Ice::makeOutgoingResponse([&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({1, 3}, ret, iceP_outSeq);
        },
        request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_opOptStringSeq(
    ::Ice::IncomingRequest& request,
    ::std::function<void(::Ice::OutgoingResponse)> sendResponse) // NOLINT:performance-unnecessary-value-param
{
    _iceCheckMode(::Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    ::std::optional<StringSeq> iceP_inSeq;
    istr->readAll({2}, iceP_inSeq);
    istr->endEncapsulation();
    ::std::optional<StringSeq> iceP_outSeq;
    const ::std::optional<StringSeq> ret = this->opOptStringSeq(::std::move(iceP_inSeq), iceP_outSeq, request.current());
    sendResponse(::Ice::makeOutgoingResponse([&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({1, 3}, ret, iceP_outSeq);
        },
        request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_opOptESeq(
    ::Ice::IncomingRequest& request,
    ::std::function<void(::Ice::OutgoingResponse)> sendResponse) // NOLINT:performance-unnecessary-value-param
{
    _iceCheckMode(::Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    ::std::optional<ESeq> iceP_inSeq;
    istr->readAll({2}, iceP_inSeq);
    istr->endEncapsulation();
    ::std::optional<ESeq> iceP_outSeq;
    const ::std::optional<ESeq> ret = this->opOptESeq(::std::move(iceP_inSeq), iceP_outSeq, request.current());
    sendResponse(::Ice::makeOutgoingResponse([&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({1, 3}, ret, iceP_outSeq);
        },
        request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_opOptSSeq(
    ::Ice::IncomingRequest& request,
    ::std::function<void(::Ice::OutgoingResponse)> sendResponse) // NOLINT:performance-unnecessary-value-param
{
    _iceCheckMode(::Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    ::std::optional<SSeq> iceP_inSeq;
    istr->readAll({2}, iceP_inSeq);
    istr->endEncapsulation();
    ::std::optional<SSeq> iceP_outSeq;
    const ::std::optional<SSeq> ret = this->opOptSSeq(::std::move(iceP_inSeq), iceP_outSeq, request.current());
    sendResponse(::Ice::makeOutgoingResponse([&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({1, 3}, ret, iceP_outSeq);
        },
        request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_opOptDSeq(
    ::Ice::IncomingRequest& request,
    ::std::function<void(::Ice::OutgoingResponse)> sendResponse) // NOLINT:performance-unnecessary-value-param
{
    _iceCheckMode(::Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    ::std::optional<DSeq> iceP_inSeq;
    istr->readAll({2}, iceP_inSeq);
    istr->endEncapsulation();
    ::std::optional<DSeq> iceP_outSeq;
    const ::std::optional<DSeq> ret = this->opOptDSeq(::std::move(iceP_inSeq), iceP_outSeq, request.current());
    sendResponse(::Ice::makeOutgoingResponse([&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({1, 3}, ret, iceP_outSeq);
        },
        request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_opOptStringSeqSeq(
    ::Ice::IncomingRequest& request,
    ::std::function<void(::Ice::OutgoingResponse)> sendResponse) // NOLINT:performance-unnecessary-value-param
{
    _iceCheckMode(::Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    ::std::optional<StringSeqSeq> iceP_inSeq;
    istr->readAll({2}, iceP_inSeq);
    istr->endEncapsulation();
    ::std::optional<StringSeqSeq> iceP_outSeq;
    const ::std::optional<StringSeqSeq> ret = this->opOptStringSeqSeq(::std::move(iceP_inSeq), iceP_outSeq, request.current());
    sendResponse(::Ice::makeOutgoingResponse([&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({1, 3}, ret, iceP_outSeq);
        },
        request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_opOptByteBufferSeq(
    ::Ice::IncomingRequest& request,
    ::std::function<void(::Ice::OutgoingResponse)> sendResponse) // NOLINT:performance-unnecessary-value-param
{
    _iceCheckMode(::Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    ::std::optional<ByteBuffer> iceP_inSeq;
    istr->readAll({2}, iceP_inSeq);
    istr->endEncapsulation();
    ::std::optional<ByteBuffer> iceP_outSeq;
    const ::std::optional<ByteBuffer> ret = this->opOptByteBufferSeq(::std::move(iceP_inSeq), iceP_outSeq, request.current());
    sendResponse(::Ice::makeOutgoingResponse([&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({1, 3}, ret, iceP_outSeq);
        },
        request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_opOptShortBufferSeq(
    ::Ice::IncomingRequest& request,
    ::std::function<void(::Ice::OutgoingResponse)> sendResponse) // NOLINT:performance-unnecessary-value-param
{
    _iceCheckMode(::Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    ::std::optional<ShortBuffer> iceP_inSeq;
    istr->readAll({2}, iceP_inSeq);
    istr->endEncapsulation();
    ::std::optional<ShortBuffer> iceP_outSeq;
    const ::std::optional<ShortBuffer> ret = this->opOptShortBufferSeq(::std::move(iceP_inSeq), iceP_outSeq, request.current());
    sendResponse(::Ice::makeOutgoingResponse([&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({1, 3}, ret, iceP_outSeq);
        },
        request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_opOptIntBufferSeq(
    ::Ice::IncomingRequest& request,
    ::std::function<void(::Ice::OutgoingResponse)> sendResponse) // NOLINT:performance-unnecessary-value-param
{
    _iceCheckMode(::Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    ::std::optional<IntBuffer> iceP_inSeq;
    istr->readAll({2}, iceP_inSeq);
    istr->endEncapsulation();
    ::std::optional<IntBuffer> iceP_outSeq;
    const ::std::optional<IntBuffer> ret = this->opOptIntBufferSeq(::std::move(iceP_inSeq), iceP_outSeq, request.current());
    sendResponse(::Ice::makeOutgoingResponse([&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({1, 3}, ret, iceP_outSeq);
        },
        request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_opOptLongBufferSeq(
    ::Ice::IncomingRequest& request,
    ::std::function<void(::Ice::OutgoingResponse)> sendResponse) // NOLINT:performance-unnecessary-value-param
{
    _iceCheckMode(::Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    ::std::optional<LongBuffer> iceP_inSeq;
    istr->readAll({2}, iceP_inSeq);
    istr->endEncapsulation();
    ::std::optional<LongBuffer> iceP_outSeq;
    const ::std::optional<LongBuffer> ret = this->opOptLongBufferSeq(::std::move(iceP_inSeq), iceP_outSeq, request.current());
    sendResponse(::Ice::makeOutgoingResponse([&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({1, 3}, ret, iceP_outSeq);
        },
        request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_opOptFloatBufferSeq(
    ::Ice::IncomingRequest& request,
    ::std::function<void(::Ice::OutgoingResponse)> sendResponse) // NOLINT:performance-unnecessary-value-param
{
    _iceCheckMode(::Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    ::std::optional<FloatBuffer> iceP_inSeq;
    istr->readAll({2}, iceP_inSeq);
    istr->endEncapsulation();
    ::std::optional<FloatBuffer> iceP_outSeq;
    const ::std::optional<FloatBuffer> ret = this->opOptFloatBufferSeq(::std::move(iceP_inSeq), iceP_outSeq, request.current());
    sendResponse(::Ice::makeOutgoingResponse([&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({1, 3}, ret, iceP_outSeq);
        },
        request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_opOptDoubleBufferSeq(
    ::Ice::IncomingRequest& request,
    ::std::function<void(::Ice::OutgoingResponse)> sendResponse) // NOLINT:performance-unnecessary-value-param
{
    _iceCheckMode(::Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    ::std::optional<DoubleBuffer> iceP_inSeq;
    istr->readAll({2}, iceP_inSeq);
    istr->endEncapsulation();
    ::std::optional<DoubleBuffer> iceP_outSeq;
    const ::std::optional<DoubleBuffer> ret = this->opOptDoubleBufferSeq(::std::move(iceP_inSeq), iceP_outSeq, request.current());
    sendResponse(::Ice::makeOutgoingResponse([&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({1, 3}, ret, iceP_outSeq);
        },
        request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_shutdown(
    ::Ice::IncomingRequest& request,
    ::std::function<void(::Ice::OutgoingResponse)> sendResponse) // NOLINT:performance-unnecessary-value-param
{
    _iceCheckMode(::Ice::OperationMode::Normal, request.current().mode);
    request.inputStream().skipEmptyEncapsulation();
    this->shutdown(request.current());
    sendResponse(::Ice::makeEmptyOutgoingResponse(request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::dispatch(::Ice::IncomingRequest& request, ::std::function<void(::Ice::OutgoingResponse)> sendResponse)
{
    static constexpr ::std::string_view allOperations[] = {"ice_id", "ice_ids", "ice_isA", "ice_ping", "opAArray", "opAList", "opASeq", "opBoolSeq", "opByteBufferSeq", "opByteSeq", "opDSeq", "opDoubleBufferSeq", "opDoubleSeq", "opESeq", "opFloatBufferSeq", "opFloatSeq", "opIntBufferSeq", "opIntSeq", "opLongBufferSeq", "opLongSeq", "opOptAArray", "opOptAList", "opOptASeq", "opOptBoolSeq", "opOptByteBufferSeq", "opOptByteSeq", "opOptDSeq", "opOptDoubleBufferSeq", "opOptDoubleSeq", "opOptESeq", "opOptFloatBufferSeq", "opOptFloatSeq", "opOptIntBufferSeq", "opOptIntSeq", "opOptLongBufferSeq", "opOptLongSeq", "opOptSSeq", "opOptShortBufferSeq", "opOptShortSeq", "opOptStringSeq", "opOptStringSeqSeq", "opSSeq", "opShortBufferSeq", "opShortSeq", "opStringSeq", "opStringSeqSeq", "shutdown"};

    const ::Ice::Current& current = request.current();
    ::std::pair<const ::std::string_view*, const ::std::string_view*> r = ::std::equal_range(allOperations, allOperations + 47, current.operation);
    if(r.first == r.second)
    {
        sendResponse(::Ice::makeOutgoingResponse(::std::make_exception_ptr(::Ice::OperationNotExistException{__FILE__, __LINE__}), current));
        return;
    }

    switch(r.first - allOperations)
    {
        case 0:
        {
            _iceD_ice_id(request, ::std::move(sendResponse));
            break;
        }
        case 1:
        {
            _iceD_ice_ids(request, ::std::move(sendResponse));
            break;
        }
        case 2:
        {
            _iceD_ice_isA(request, ::std::move(sendResponse));
            break;
        }
        case 3:
        {
            _iceD_ice_ping(request, ::std::move(sendResponse));
            break;
        }
        case 4:
        {
            _iceD_opAArray(request, ::std::move(sendResponse));
            break;
        }
        case 5:
        {
            _iceD_opAList(request, ::std::move(sendResponse));
            break;
        }
        case 6:
        {
            _iceD_opASeq(request, ::std::move(sendResponse));
            break;
        }
        case 7:
        {
            _iceD_opBoolSeq(request, ::std::move(sendResponse));
            break;
        }
        case 8:
        {
            _iceD_opByteBufferSeq(request, ::std::move(sendResponse));
            break;
        }
        case 9:
        {
            _iceD_opByteSeq(request, ::std::move(sendResponse));
            break;
        }
        case 10:
        {
            _iceD_opDSeq(request, ::std::move(sendResponse));
            break;
        }
        case 11:
        {
            _iceD_opDoubleBufferSeq(request, ::std::move(sendResponse));
            break;
        }
        case 12:
        {
            _iceD_opDoubleSeq(request, ::std::move(sendResponse));
            break;
        }
        case 13:
        {
            _iceD_opESeq(request, ::std::move(sendResponse));
            break;
        }
        case 14:
        {
            _iceD_opFloatBufferSeq(request, ::std::move(sendResponse));
            break;
        }
        case 15:
        {
            _iceD_opFloatSeq(request, ::std::move(sendResponse));
            break;
        }
        case 16:
        {
            _iceD_opIntBufferSeq(request, ::std::move(sendResponse));
            break;
        }
        case 17:
        {
            _iceD_opIntSeq(request, ::std::move(sendResponse));
            break;
        }
        case 18:
        {
            _iceD_opLongBufferSeq(request, ::std::move(sendResponse));
            break;
        }
        case 19:
        {
            _iceD_opLongSeq(request, ::std::move(sendResponse));
            break;
        }
        case 20:
        {
            _iceD_opOptAArray(request, ::std::move(sendResponse));
            break;
        }
        case 21:
        {
            _iceD_opOptAList(request, ::std::move(sendResponse));
            break;
        }
        case 22:
        {
            _iceD_opOptASeq(request, ::std::move(sendResponse));
            break;
        }
        case 23:
        {
            _iceD_opOptBoolSeq(request, ::std::move(sendResponse));
            break;
        }
        case 24:
        {
            _iceD_opOptByteBufferSeq(request, ::std::move(sendResponse));
            break;
        }
        case 25:
        {
            _iceD_opOptByteSeq(request, ::std::move(sendResponse));
            break;
        }
        case 26:
        {
            _iceD_opOptDSeq(request, ::std::move(sendResponse));
            break;
        }
        case 27:
        {
            _iceD_opOptDoubleBufferSeq(request, ::std::move(sendResponse));
            break;
        }
        case 28:
        {
            _iceD_opOptDoubleSeq(request, ::std::move(sendResponse));
            break;
        }
        case 29:
        {
            _iceD_opOptESeq(request, ::std::move(sendResponse));
            break;
        }
        case 30:
        {
            _iceD_opOptFloatBufferSeq(request, ::std::move(sendResponse));
            break;
        }
        case 31:
        {
            _iceD_opOptFloatSeq(request, ::std::move(sendResponse));
            break;
        }
        case 32:
        {
            _iceD_opOptIntBufferSeq(request, ::std::move(sendResponse));
            break;
        }
        case 33:
        {
            _iceD_opOptIntSeq(request, ::std::move(sendResponse));
            break;
        }
        case 34:
        {
            _iceD_opOptLongBufferSeq(request, ::std::move(sendResponse));
            break;
        }
        case 35:
        {
            _iceD_opOptLongSeq(request, ::std::move(sendResponse));
            break;
        }
        case 36:
        {
            _iceD_opOptSSeq(request, ::std::move(sendResponse));
            break;
        }
        case 37:
        {
            _iceD_opOptShortBufferSeq(request, ::std::move(sendResponse));
            break;
        }
        case 38:
        {
            _iceD_opOptShortSeq(request, ::std::move(sendResponse));
            break;
        }
        case 39:
        {
            _iceD_opOptStringSeq(request, ::std::move(sendResponse));
            break;
        }
        case 40:
        {
            _iceD_opOptStringSeqSeq(request, ::std::move(sendResponse));
            break;
        }
        case 41:
        {
            _iceD_opSSeq(request, ::std::move(sendResponse));
            break;
        }
        case 42:
        {
            _iceD_opShortBufferSeq(request, ::std::move(sendResponse));
            break;
        }
        case 43:
        {
            _iceD_opShortSeq(request, ::std::move(sendResponse));
            break;
        }
        case 44:
        {
            _iceD_opStringSeq(request, ::std::move(sendResponse));
            break;
        }
        case 45:
        {
            _iceD_opStringSeqSeq(request, ::std::move(sendResponse));
            break;
        }
        case 46:
        {
            _iceD_shutdown(request, ::std::move(sendResponse));
            break;
        }
        default:
        {
            assert(false);
            sendResponse(::Ice::makeOutgoingResponse(::std::make_exception_ptr(::Ice::OperationNotExistException{__FILE__, __LINE__}), current));
        }
    }
}
/// \endcond
