//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.7.10
//
// <auto-generated>
//
// Generated from file `Test.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#define ICE_BUILDING_GENERATED_CODE
#include <Test.h>
#include <IceUtil/PushDisableWarnings.h>
#include <IceUtil/PopDisableWarnings.h>

#if defined(_MSC_VER)
#   pragma warning(disable:4458) // declaration of ... hides class member
#elif defined(__clang__)
#   pragma clang diagnostic ignored "-Wshadow"
#elif defined(__GNUC__)
#   pragma GCC diagnostic ignored "-Wshadow"
#endif

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 307
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 >= 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 10
#       error Ice patch level mismatch!
#   endif
#endif

#ifdef ICE_CPP11_MAPPING // C++11 mapping

namespace
{

const ::IceInternal::DefaultValueFactoryInit<::Test::C> iceC_Test_C_init("::Test::C");

const ::std::string iceC_Test_TestIntf_ids[2] =
{
    "::Ice::Object",
    "::Test::TestIntf"
};
const ::std::string iceC_Test_TestIntf_ops[] =
{
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "opBoolSeq",
    "opByteBufferSeq",
    "opByteSeq",
    "opCArray",
    "opCList",
    "opCSeq",
    "opDSeq",
    "opDoubleBufferSeq",
    "opDoubleSeq",
    "opESeq",
    "opFloatBufferSeq",
    "opFloatSeq",
    "opIntBufferSeq",
    "opIntSeq",
    "opLongBufferSeq",
    "opLongSeq",
    "opOptBoolSeq",
    "opOptByteBufferSeq",
    "opOptByteSeq",
    "opOptCArray",
    "opOptCList",
    "opOptCSeq",
    "opOptDSeq",
    "opOptDoubleBufferSeq",
    "opOptDoubleSeq",
    "opOptESeq",
    "opOptFloatBufferSeq",
    "opOptFloatSeq",
    "opOptIntBufferSeq",
    "opOptIntSeq",
    "opOptLongBufferSeq",
    "opOptLongSeq",
    "opOptSSeq",
    "opOptShortBufferSeq",
    "opOptShortSeq",
    "opOptStringSeq",
    "opOptStringSeqSeq",
    "opSSeq",
    "opShortBufferSeq",
    "opShortSeq",
    "opStringSeq",
    "opStringSeqSeq",
    "shutdown"
};
const ::std::string iceC_Test_TestIntf_opCSeq_name = "opCSeq";
const ::std::string iceC_Test_TestIntf_opCArray_name = "opCArray";
const ::std::string iceC_Test_TestIntf_opCList_name = "opCList";
const ::std::string iceC_Test_TestIntf_opBoolSeq_name = "opBoolSeq";
const ::std::string iceC_Test_TestIntf_opByteSeq_name = "opByteSeq";
const ::std::string iceC_Test_TestIntf_opShortSeq_name = "opShortSeq";
const ::std::string iceC_Test_TestIntf_opIntSeq_name = "opIntSeq";
const ::std::string iceC_Test_TestIntf_opLongSeq_name = "opLongSeq";
const ::std::string iceC_Test_TestIntf_opFloatSeq_name = "opFloatSeq";
const ::std::string iceC_Test_TestIntf_opDoubleSeq_name = "opDoubleSeq";
const ::std::string iceC_Test_TestIntf_opStringSeq_name = "opStringSeq";
const ::std::string iceC_Test_TestIntf_opESeq_name = "opESeq";
const ::std::string iceC_Test_TestIntf_opSSeq_name = "opSSeq";
const ::std::string iceC_Test_TestIntf_opDSeq_name = "opDSeq";
const ::std::string iceC_Test_TestIntf_opStringSeqSeq_name = "opStringSeqSeq";
const ::std::string iceC_Test_TestIntf_opByteBufferSeq_name = "opByteBufferSeq";
const ::std::string iceC_Test_TestIntf_opShortBufferSeq_name = "opShortBufferSeq";
const ::std::string iceC_Test_TestIntf_opIntBufferSeq_name = "opIntBufferSeq";
const ::std::string iceC_Test_TestIntf_opLongBufferSeq_name = "opLongBufferSeq";
const ::std::string iceC_Test_TestIntf_opFloatBufferSeq_name = "opFloatBufferSeq";
const ::std::string iceC_Test_TestIntf_opDoubleBufferSeq_name = "opDoubleBufferSeq";
const ::std::string iceC_Test_TestIntf_opOptCSeq_name = "opOptCSeq";
const ::std::string iceC_Test_TestIntf_opOptCArray_name = "opOptCArray";
const ::std::string iceC_Test_TestIntf_opOptCList_name = "opOptCList";
const ::std::string iceC_Test_TestIntf_opOptBoolSeq_name = "opOptBoolSeq";
const ::std::string iceC_Test_TestIntf_opOptByteSeq_name = "opOptByteSeq";
const ::std::string iceC_Test_TestIntf_opOptShortSeq_name = "opOptShortSeq";
const ::std::string iceC_Test_TestIntf_opOptIntSeq_name = "opOptIntSeq";
const ::std::string iceC_Test_TestIntf_opOptLongSeq_name = "opOptLongSeq";
const ::std::string iceC_Test_TestIntf_opOptFloatSeq_name = "opOptFloatSeq";
const ::std::string iceC_Test_TestIntf_opOptDoubleSeq_name = "opOptDoubleSeq";
const ::std::string iceC_Test_TestIntf_opOptStringSeq_name = "opOptStringSeq";
const ::std::string iceC_Test_TestIntf_opOptESeq_name = "opOptESeq";
const ::std::string iceC_Test_TestIntf_opOptSSeq_name = "opOptSSeq";
const ::std::string iceC_Test_TestIntf_opOptDSeq_name = "opOptDSeq";
const ::std::string iceC_Test_TestIntf_opOptStringSeqSeq_name = "opOptStringSeqSeq";
const ::std::string iceC_Test_TestIntf_opOptByteBufferSeq_name = "opOptByteBufferSeq";
const ::std::string iceC_Test_TestIntf_opOptShortBufferSeq_name = "opOptShortBufferSeq";
const ::std::string iceC_Test_TestIntf_opOptIntBufferSeq_name = "opOptIntBufferSeq";
const ::std::string iceC_Test_TestIntf_opOptLongBufferSeq_name = "opOptLongBufferSeq";
const ::std::string iceC_Test_TestIntf_opOptFloatBufferSeq_name = "opOptFloatBufferSeq";
const ::std::string iceC_Test_TestIntf_opOptDoubleBufferSeq_name = "opOptDoubleBufferSeq";
const ::std::string iceC_Test_TestIntf_shutdown_name = "shutdown";

}

bool
Test::TestIntf::ice_isA(::std::string s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_TestIntf_ids, iceC_Test_TestIntf_ids + 2, s);
}

::std::vector<::std::string>
Test::TestIntf::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector<::std::string>(&iceC_Test_TestIntf_ids[0], &iceC_Test_TestIntf_ids[2]);
}

::std::string
Test::TestIntf::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::TestIntf::ice_staticId()
{
    static const ::std::string typeId = "::Test::TestIntf";
    return typeId;
}

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opCSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    CSeq iceP_inSeq;
    istr->readAll(iceP_inSeq);
    istr->readPendingValues();
    inS.endReadParams();
    CSeq iceP_outSeq;
    CSeq ret = this->opCSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_outSeq, ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opCArray(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    CArray iceP_inSeq;
    istr->readAll(iceP_inSeq);
    istr->readPendingValues();
    inS.endReadParams();
    CArray iceP_outSeq;
    CArray ret = this->opCArray(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_outSeq, ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opCList(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    CList iceP_inSeq;
    istr->readAll(iceP_inSeq);
    istr->readPendingValues();
    inS.endReadParams();
    CList iceP_outSeq;
    CList ret = this->opCList(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_outSeq, ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opBoolSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    BoolSeq iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    BoolSeq iceP_outSeq;
    BoolSeq ret = this->opBoolSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_outSeq, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opByteSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ByteSeq iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    ByteSeq iceP_outSeq;
    ByteSeq ret = this->opByteSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_outSeq, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opShortSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ShortSeq iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    ShortSeq iceP_outSeq;
    ShortSeq ret = this->opShortSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_outSeq, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opIntSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    IntSeq iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    IntSeq iceP_outSeq;
    IntSeq ret = this->opIntSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_outSeq, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opLongSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    LongSeq iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    LongSeq iceP_outSeq;
    LongSeq ret = this->opLongSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_outSeq, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opFloatSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    FloatSeq iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    FloatSeq iceP_outSeq;
    FloatSeq ret = this->opFloatSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_outSeq, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opDoubleSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    DoubleSeq iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    DoubleSeq iceP_outSeq;
    DoubleSeq ret = this->opDoubleSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_outSeq, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opStringSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    StringSeq iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    StringSeq iceP_outSeq;
    StringSeq ret = this->opStringSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_outSeq, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opESeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ESeq iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    ESeq iceP_outSeq;
    ESeq ret = this->opESeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_outSeq, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opSSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    SSeq iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    SSeq iceP_outSeq;
    SSeq ret = this->opSSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_outSeq, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opDSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    DSeq iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    DSeq iceP_outSeq;
    DSeq ret = this->opDSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_outSeq, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opStringSeqSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    StringSeqSeq iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    StringSeqSeq iceP_outSeq;
    StringSeqSeq ret = this->opStringSeqSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_outSeq, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opByteBufferSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ByteBuffer iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    ByteBuffer iceP_outSeq;
    ByteBuffer ret = this->opByteBufferSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_outSeq, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opShortBufferSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ShortBuffer iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    ShortBuffer iceP_outSeq;
    ShortBuffer ret = this->opShortBufferSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_outSeq, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opIntBufferSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    IntBuffer iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    IntBuffer iceP_outSeq;
    IntBuffer ret = this->opIntBufferSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_outSeq, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opLongBufferSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    LongBuffer iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    LongBuffer iceP_outSeq;
    LongBuffer ret = this->opLongBufferSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_outSeq, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opFloatBufferSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    FloatBuffer iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    FloatBuffer iceP_outSeq;
    FloatBuffer ret = this->opFloatBufferSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_outSeq, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opDoubleBufferSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    DoubleBuffer iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    DoubleBuffer iceP_outSeq;
    DoubleBuffer ret = this->opDoubleBufferSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_outSeq, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opOptCSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    std::optional<CSeq> iceP_inSeq;
    istr->readAll({2}, iceP_inSeq);
    inS.endReadParams();
    std::optional<CSeq> iceP_outSeq;
    std::optional<CSeq> ret = this->opOptCSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll({1, 3}, ret, iceP_outSeq);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opOptCArray(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    std::optional<CArray> iceP_inSeq;
    istr->readAll({2}, iceP_inSeq);
    inS.endReadParams();
    std::optional<CArray> iceP_outSeq;
    std::optional<CArray> ret = this->opOptCArray(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll({1, 3}, ret, iceP_outSeq);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opOptCList(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    std::optional<CList> iceP_inSeq;
    istr->readAll({2}, iceP_inSeq);
    inS.endReadParams();
    std::optional<CList> iceP_outSeq;
    std::optional<CList> ret = this->opOptCList(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll({1, 3}, ret, iceP_outSeq);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opOptBoolSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    std::optional<BoolSeq> iceP_inSeq;
    istr->readAll({2}, iceP_inSeq);
    inS.endReadParams();
    std::optional<BoolSeq> iceP_outSeq;
    std::optional<BoolSeq> ret = this->opOptBoolSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll({1, 3}, ret, iceP_outSeq);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opOptByteSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    std::optional<ByteSeq> iceP_inSeq;
    istr->readAll({2}, iceP_inSeq);
    inS.endReadParams();
    std::optional<ByteSeq> iceP_outSeq;
    std::optional<ByteSeq> ret = this->opOptByteSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll({1, 3}, ret, iceP_outSeq);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opOptShortSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    std::optional<ShortSeq> iceP_inSeq;
    istr->readAll({2}, iceP_inSeq);
    inS.endReadParams();
    std::optional<ShortSeq> iceP_outSeq;
    std::optional<ShortSeq> ret = this->opOptShortSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll({1, 3}, ret, iceP_outSeq);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opOptIntSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    std::optional<IntSeq> iceP_inSeq;
    istr->readAll({2}, iceP_inSeq);
    inS.endReadParams();
    std::optional<IntSeq> iceP_outSeq;
    std::optional<IntSeq> ret = this->opOptIntSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll({1, 3}, ret, iceP_outSeq);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opOptLongSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    std::optional<LongSeq> iceP_inSeq;
    istr->readAll({2}, iceP_inSeq);
    inS.endReadParams();
    std::optional<LongSeq> iceP_outSeq;
    std::optional<LongSeq> ret = this->opOptLongSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll({1, 3}, ret, iceP_outSeq);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opOptFloatSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    std::optional<FloatSeq> iceP_inSeq;
    istr->readAll({2}, iceP_inSeq);
    inS.endReadParams();
    std::optional<FloatSeq> iceP_outSeq;
    std::optional<FloatSeq> ret = this->opOptFloatSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll({1, 3}, ret, iceP_outSeq);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opOptDoubleSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    std::optional<DoubleSeq> iceP_inSeq;
    istr->readAll({2}, iceP_inSeq);
    inS.endReadParams();
    std::optional<DoubleSeq> iceP_outSeq;
    std::optional<DoubleSeq> ret = this->opOptDoubleSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll({1, 3}, ret, iceP_outSeq);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opOptStringSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    std::optional<StringSeq> iceP_inSeq;
    istr->readAll({2}, iceP_inSeq);
    inS.endReadParams();
    std::optional<StringSeq> iceP_outSeq;
    std::optional<StringSeq> ret = this->opOptStringSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll({1, 3}, ret, iceP_outSeq);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opOptESeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    std::optional<ESeq> iceP_inSeq;
    istr->readAll({2}, iceP_inSeq);
    inS.endReadParams();
    std::optional<ESeq> iceP_outSeq;
    std::optional<ESeq> ret = this->opOptESeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll({1, 3}, ret, iceP_outSeq);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opOptSSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    std::optional<SSeq> iceP_inSeq;
    istr->readAll({2}, iceP_inSeq);
    inS.endReadParams();
    std::optional<SSeq> iceP_outSeq;
    std::optional<SSeq> ret = this->opOptSSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll({1, 3}, ret, iceP_outSeq);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opOptDSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    std::optional<DSeq> iceP_inSeq;
    istr->readAll({2}, iceP_inSeq);
    inS.endReadParams();
    std::optional<DSeq> iceP_outSeq;
    std::optional<DSeq> ret = this->opOptDSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll({1, 3}, ret, iceP_outSeq);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opOptStringSeqSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    std::optional<StringSeqSeq> iceP_inSeq;
    istr->readAll({2}, iceP_inSeq);
    inS.endReadParams();
    std::optional<StringSeqSeq> iceP_outSeq;
    std::optional<StringSeqSeq> ret = this->opOptStringSeqSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll({1, 3}, ret, iceP_outSeq);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opOptByteBufferSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    std::optional<ByteBuffer> iceP_inSeq;
    istr->readAll({2}, iceP_inSeq);
    inS.endReadParams();
    std::optional<ByteBuffer> iceP_outSeq;
    std::optional<ByteBuffer> ret = this->opOptByteBufferSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll({1, 3}, ret, iceP_outSeq);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opOptShortBufferSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    std::optional<ShortBuffer> iceP_inSeq;
    istr->readAll({2}, iceP_inSeq);
    inS.endReadParams();
    std::optional<ShortBuffer> iceP_outSeq;
    std::optional<ShortBuffer> ret = this->opOptShortBufferSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll({1, 3}, ret, iceP_outSeq);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opOptIntBufferSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    std::optional<IntBuffer> iceP_inSeq;
    istr->readAll({2}, iceP_inSeq);
    inS.endReadParams();
    std::optional<IntBuffer> iceP_outSeq;
    std::optional<IntBuffer> ret = this->opOptIntBufferSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll({1, 3}, ret, iceP_outSeq);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opOptLongBufferSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    std::optional<LongBuffer> iceP_inSeq;
    istr->readAll({2}, iceP_inSeq);
    inS.endReadParams();
    std::optional<LongBuffer> iceP_outSeq;
    std::optional<LongBuffer> ret = this->opOptLongBufferSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll({1, 3}, ret, iceP_outSeq);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opOptFloatBufferSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    std::optional<FloatBuffer> iceP_inSeq;
    istr->readAll({2}, iceP_inSeq);
    inS.endReadParams();
    std::optional<FloatBuffer> iceP_outSeq;
    std::optional<FloatBuffer> ret = this->opOptFloatBufferSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll({1, 3}, ret, iceP_outSeq);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opOptDoubleBufferSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    std::optional<DoubleBuffer> iceP_inSeq;
    istr->readAll({2}, iceP_inSeq);
    inS.endReadParams();
    std::optional<DoubleBuffer> iceP_outSeq;
    std::optional<DoubleBuffer> ret = this->opOptDoubleBufferSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll({1, 3}, ret, iceP_outSeq);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_shutdown(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    this->shutdown(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_Test_TestIntf_ops, iceC_Test_TestIntf_ops + 47, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_Test_TestIntf_ops)
    {
        case 0:
        {
            return _iceD_ice_id(in, current);
        }
        case 1:
        {
            return _iceD_ice_ids(in, current);
        }
        case 2:
        {
            return _iceD_ice_isA(in, current);
        }
        case 3:
        {
            return _iceD_ice_ping(in, current);
        }
        case 4:
        {
            return _iceD_opBoolSeq(in, current);
        }
        case 5:
        {
            return _iceD_opByteBufferSeq(in, current);
        }
        case 6:
        {
            return _iceD_opByteSeq(in, current);
        }
        case 7:
        {
            return _iceD_opCArray(in, current);
        }
        case 8:
        {
            return _iceD_opCList(in, current);
        }
        case 9:
        {
            return _iceD_opCSeq(in, current);
        }
        case 10:
        {
            return _iceD_opDSeq(in, current);
        }
        case 11:
        {
            return _iceD_opDoubleBufferSeq(in, current);
        }
        case 12:
        {
            return _iceD_opDoubleSeq(in, current);
        }
        case 13:
        {
            return _iceD_opESeq(in, current);
        }
        case 14:
        {
            return _iceD_opFloatBufferSeq(in, current);
        }
        case 15:
        {
            return _iceD_opFloatSeq(in, current);
        }
        case 16:
        {
            return _iceD_opIntBufferSeq(in, current);
        }
        case 17:
        {
            return _iceD_opIntSeq(in, current);
        }
        case 18:
        {
            return _iceD_opLongBufferSeq(in, current);
        }
        case 19:
        {
            return _iceD_opLongSeq(in, current);
        }
        case 20:
        {
            return _iceD_opOptBoolSeq(in, current);
        }
        case 21:
        {
            return _iceD_opOptByteBufferSeq(in, current);
        }
        case 22:
        {
            return _iceD_opOptByteSeq(in, current);
        }
        case 23:
        {
            return _iceD_opOptCArray(in, current);
        }
        case 24:
        {
            return _iceD_opOptCList(in, current);
        }
        case 25:
        {
            return _iceD_opOptCSeq(in, current);
        }
        case 26:
        {
            return _iceD_opOptDSeq(in, current);
        }
        case 27:
        {
            return _iceD_opOptDoubleBufferSeq(in, current);
        }
        case 28:
        {
            return _iceD_opOptDoubleSeq(in, current);
        }
        case 29:
        {
            return _iceD_opOptESeq(in, current);
        }
        case 30:
        {
            return _iceD_opOptFloatBufferSeq(in, current);
        }
        case 31:
        {
            return _iceD_opOptFloatSeq(in, current);
        }
        case 32:
        {
            return _iceD_opOptIntBufferSeq(in, current);
        }
        case 33:
        {
            return _iceD_opOptIntSeq(in, current);
        }
        case 34:
        {
            return _iceD_opOptLongBufferSeq(in, current);
        }
        case 35:
        {
            return _iceD_opOptLongSeq(in, current);
        }
        case 36:
        {
            return _iceD_opOptSSeq(in, current);
        }
        case 37:
        {
            return _iceD_opOptShortBufferSeq(in, current);
        }
        case 38:
        {
            return _iceD_opOptShortSeq(in, current);
        }
        case 39:
        {
            return _iceD_opOptStringSeq(in, current);
        }
        case 40:
        {
            return _iceD_opOptStringSeqSeq(in, current);
        }
        case 41:
        {
            return _iceD_opSSeq(in, current);
        }
        case 42:
        {
            return _iceD_opShortBufferSeq(in, current);
        }
        case 43:
        {
            return _iceD_opShortSeq(in, current);
        }
        case 44:
        {
            return _iceD_opStringSeq(in, current);
        }
        case 45:
        {
            return _iceD_opStringSeqSeq(in, current);
        }
        case 46:
        {
            return _iceD_shutdown(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

Test::C::~C()
{
}

const ::std::string&
Test::C::ice_staticId()
{
    static const ::std::string typeId = "::Test::C";
    return typeId;
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opCSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpCSeqResult>>& outAsync, const CSeq& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opCSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opCSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
            ostr->writePendingValues();
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpCSeqResult v;
            istr->readAll(v.outSeq, v.returnValue);
            istr->readPendingValues();
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opCArray(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpCArrayResult>>& outAsync, const CArray& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opCArray_name);
    outAsync->invoke(iceC_Test_TestIntf_opCArray_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
            ostr->writePendingValues();
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpCArrayResult v;
            istr->readAll(v.outSeq, v.returnValue);
            istr->readPendingValues();
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opCList(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpCListResult>>& outAsync, const CList& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opCList_name);
    outAsync->invoke(iceC_Test_TestIntf_opCList_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
            ostr->writePendingValues();
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpCListResult v;
            istr->readAll(v.outSeq, v.returnValue);
            istr->readPendingValues();
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opBoolSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpBoolSeqResult>>& outAsync, const BoolSeq& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opBoolSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opBoolSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpBoolSeqResult v;
            istr->readAll(v.outSeq, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opByteSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpByteSeqResult>>& outAsync, const ByteSeq& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opByteSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opByteSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpByteSeqResult v;
            istr->readAll(v.outSeq, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opShortSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpShortSeqResult>>& outAsync, const ShortSeq& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opShortSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opShortSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpShortSeqResult v;
            istr->readAll(v.outSeq, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opIntSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpIntSeqResult>>& outAsync, const IntSeq& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opIntSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opIntSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpIntSeqResult v;
            istr->readAll(v.outSeq, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opLongSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpLongSeqResult>>& outAsync, const LongSeq& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opLongSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opLongSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpLongSeqResult v;
            istr->readAll(v.outSeq, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opFloatSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpFloatSeqResult>>& outAsync, const FloatSeq& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opFloatSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opFloatSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpFloatSeqResult v;
            istr->readAll(v.outSeq, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opDoubleSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpDoubleSeqResult>>& outAsync, const DoubleSeq& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opDoubleSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opDoubleSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpDoubleSeqResult v;
            istr->readAll(v.outSeq, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opStringSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpStringSeqResult>>& outAsync, const StringSeq& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opStringSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opStringSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpStringSeqResult v;
            istr->readAll(v.outSeq, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opESeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpESeqResult>>& outAsync, const ESeq& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opESeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opESeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpESeqResult v;
            istr->readAll(v.outSeq, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opSSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpSSeqResult>>& outAsync, const SSeq& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opSSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opSSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpSSeqResult v;
            istr->readAll(v.outSeq, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opDSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpDSeqResult>>& outAsync, const DSeq& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opDSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opDSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpDSeqResult v;
            istr->readAll(v.outSeq, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opStringSeqSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpStringSeqSeqResult>>& outAsync, const StringSeqSeq& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opStringSeqSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opStringSeqSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpStringSeqSeqResult v;
            istr->readAll(v.outSeq, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opByteBufferSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpByteBufferSeqResult>>& outAsync, const ByteBuffer& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opByteBufferSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opByteBufferSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpByteBufferSeqResult v;
            istr->readAll(v.outSeq, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opShortBufferSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpShortBufferSeqResult>>& outAsync, const ShortBuffer& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opShortBufferSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opShortBufferSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpShortBufferSeqResult v;
            istr->readAll(v.outSeq, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opIntBufferSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpIntBufferSeqResult>>& outAsync, const IntBuffer& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opIntBufferSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opIntBufferSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpIntBufferSeqResult v;
            istr->readAll(v.outSeq, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opLongBufferSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpLongBufferSeqResult>>& outAsync, const LongBuffer& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opLongBufferSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opLongBufferSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpLongBufferSeqResult v;
            istr->readAll(v.outSeq, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opFloatBufferSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpFloatBufferSeqResult>>& outAsync, const FloatBuffer& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opFloatBufferSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opFloatBufferSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpFloatBufferSeqResult v;
            istr->readAll(v.outSeq, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opDoubleBufferSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpDoubleBufferSeqResult>>& outAsync, const DoubleBuffer& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opDoubleBufferSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opDoubleBufferSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpDoubleBufferSeqResult v;
            istr->readAll(v.outSeq, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opOptCSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpOptCSeqResult>>& outAsync, const std::optional<CSeq>& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opOptCSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opOptCSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({2}, iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpOptCSeqResult v;
            istr->readAll({1, 3}, v.returnValue, v.outSeq);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opOptCArray(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpOptCArrayResult>>& outAsync, const std::optional<CArray>& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opOptCArray_name);
    outAsync->invoke(iceC_Test_TestIntf_opOptCArray_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({2}, iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpOptCArrayResult v;
            istr->readAll({1, 3}, v.returnValue, v.outSeq);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opOptCList(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpOptCListResult>>& outAsync, const std::optional<CList>& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opOptCList_name);
    outAsync->invoke(iceC_Test_TestIntf_opOptCList_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({2}, iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpOptCListResult v;
            istr->readAll({1, 3}, v.returnValue, v.outSeq);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opOptBoolSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpOptBoolSeqResult>>& outAsync, const std::optional<BoolSeq>& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opOptBoolSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opOptBoolSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({2}, iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpOptBoolSeqResult v;
            istr->readAll({1, 3}, v.returnValue, v.outSeq);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opOptByteSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpOptByteSeqResult>>& outAsync, const std::optional<ByteSeq>& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opOptByteSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opOptByteSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({2}, iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpOptByteSeqResult v;
            istr->readAll({1, 3}, v.returnValue, v.outSeq);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opOptShortSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpOptShortSeqResult>>& outAsync, const std::optional<ShortSeq>& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opOptShortSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opOptShortSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({2}, iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpOptShortSeqResult v;
            istr->readAll({1, 3}, v.returnValue, v.outSeq);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opOptIntSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpOptIntSeqResult>>& outAsync, const std::optional<IntSeq>& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opOptIntSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opOptIntSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({2}, iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpOptIntSeqResult v;
            istr->readAll({1, 3}, v.returnValue, v.outSeq);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opOptLongSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpOptLongSeqResult>>& outAsync, const std::optional<LongSeq>& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opOptLongSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opOptLongSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({2}, iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpOptLongSeqResult v;
            istr->readAll({1, 3}, v.returnValue, v.outSeq);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opOptFloatSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpOptFloatSeqResult>>& outAsync, const std::optional<FloatSeq>& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opOptFloatSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opOptFloatSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({2}, iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpOptFloatSeqResult v;
            istr->readAll({1, 3}, v.returnValue, v.outSeq);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opOptDoubleSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpOptDoubleSeqResult>>& outAsync, const std::optional<DoubleSeq>& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opOptDoubleSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opOptDoubleSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({2}, iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpOptDoubleSeqResult v;
            istr->readAll({1, 3}, v.returnValue, v.outSeq);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opOptStringSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpOptStringSeqResult>>& outAsync, const std::optional<StringSeq>& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opOptStringSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opOptStringSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({2}, iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpOptStringSeqResult v;
            istr->readAll({1, 3}, v.returnValue, v.outSeq);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opOptESeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpOptESeqResult>>& outAsync, const std::optional<ESeq>& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opOptESeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opOptESeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({2}, iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpOptESeqResult v;
            istr->readAll({1, 3}, v.returnValue, v.outSeq);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opOptSSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpOptSSeqResult>>& outAsync, const std::optional<SSeq>& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opOptSSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opOptSSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({2}, iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpOptSSeqResult v;
            istr->readAll({1, 3}, v.returnValue, v.outSeq);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opOptDSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpOptDSeqResult>>& outAsync, const std::optional<DSeq>& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opOptDSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opOptDSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({2}, iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpOptDSeqResult v;
            istr->readAll({1, 3}, v.returnValue, v.outSeq);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opOptStringSeqSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpOptStringSeqSeqResult>>& outAsync, const std::optional<StringSeqSeq>& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opOptStringSeqSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opOptStringSeqSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({2}, iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpOptStringSeqSeqResult v;
            istr->readAll({1, 3}, v.returnValue, v.outSeq);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opOptByteBufferSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpOptByteBufferSeqResult>>& outAsync, const std::optional<ByteBuffer>& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opOptByteBufferSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opOptByteBufferSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({2}, iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpOptByteBufferSeqResult v;
            istr->readAll({1, 3}, v.returnValue, v.outSeq);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opOptShortBufferSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpOptShortBufferSeqResult>>& outAsync, const std::optional<ShortBuffer>& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opOptShortBufferSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opOptShortBufferSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({2}, iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpOptShortBufferSeqResult v;
            istr->readAll({1, 3}, v.returnValue, v.outSeq);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opOptIntBufferSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpOptIntBufferSeqResult>>& outAsync, const std::optional<IntBuffer>& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opOptIntBufferSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opOptIntBufferSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({2}, iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpOptIntBufferSeqResult v;
            istr->readAll({1, 3}, v.returnValue, v.outSeq);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opOptLongBufferSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpOptLongBufferSeqResult>>& outAsync, const std::optional<LongBuffer>& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opOptLongBufferSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opOptLongBufferSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({2}, iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpOptLongBufferSeqResult v;
            istr->readAll({1, 3}, v.returnValue, v.outSeq);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opOptFloatBufferSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpOptFloatBufferSeqResult>>& outAsync, const std::optional<FloatBuffer>& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opOptFloatBufferSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opOptFloatBufferSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({2}, iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpOptFloatBufferSeqResult v;
            istr->readAll({1, 3}, v.returnValue, v.outSeq);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opOptDoubleBufferSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpOptDoubleBufferSeqResult>>& outAsync, const std::optional<DoubleBuffer>& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opOptDoubleBufferSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opOptDoubleBufferSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({2}, iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpOptDoubleBufferSeqResult v;
            istr->readAll({1, 3}, v.returnValue, v.outSeq);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_shutdown(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_Test_TestIntf_shutdown_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

/// \cond INTERNAL
::std::shared_ptr<::Ice::ObjectPrx>
Test::TestIntfPrx::_newInstance() const
{
    return ::IceInternal::createProxy<TestIntfPrx>();
}
/// \endcond

const ::std::string&
Test::TestIntfPrx::ice_staticId()
{
    return TestIntf::ice_staticId();
}

namespace Ice
{
}

#else // C++98 mapping

namespace
{

const ::std::string iceC_Test_TestIntf_opCSeq_name = "opCSeq";

const ::std::string iceC_Test_TestIntf_opCArray_name = "opCArray";

const ::std::string iceC_Test_TestIntf_opCList_name = "opCList";

const ::std::string iceC_Test_TestIntf_opBoolSeq_name = "opBoolSeq";

const ::std::string iceC_Test_TestIntf_opByteSeq_name = "opByteSeq";

const ::std::string iceC_Test_TestIntf_opShortSeq_name = "opShortSeq";

const ::std::string iceC_Test_TestIntf_opIntSeq_name = "opIntSeq";

const ::std::string iceC_Test_TestIntf_opLongSeq_name = "opLongSeq";

const ::std::string iceC_Test_TestIntf_opFloatSeq_name = "opFloatSeq";

const ::std::string iceC_Test_TestIntf_opDoubleSeq_name = "opDoubleSeq";

const ::std::string iceC_Test_TestIntf_opStringSeq_name = "opStringSeq";

const ::std::string iceC_Test_TestIntf_opESeq_name = "opESeq";

const ::std::string iceC_Test_TestIntf_opSSeq_name = "opSSeq";

const ::std::string iceC_Test_TestIntf_opDSeq_name = "opDSeq";

const ::std::string iceC_Test_TestIntf_opStringSeqSeq_name = "opStringSeqSeq";

const ::std::string iceC_Test_TestIntf_opByteBufferSeq_name = "opByteBufferSeq";

const ::std::string iceC_Test_TestIntf_opShortBufferSeq_name = "opShortBufferSeq";

const ::std::string iceC_Test_TestIntf_opIntBufferSeq_name = "opIntBufferSeq";

const ::std::string iceC_Test_TestIntf_opLongBufferSeq_name = "opLongBufferSeq";

const ::std::string iceC_Test_TestIntf_opFloatBufferSeq_name = "opFloatBufferSeq";

const ::std::string iceC_Test_TestIntf_opDoubleBufferSeq_name = "opDoubleBufferSeq";

const ::std::string iceC_Test_TestIntf_opOptCSeq_name = "opOptCSeq";

const ::std::string iceC_Test_TestIntf_opOptCArray_name = "opOptCArray";

const ::std::string iceC_Test_TestIntf_opOptCList_name = "opOptCList";

const ::std::string iceC_Test_TestIntf_opOptBoolSeq_name = "opOptBoolSeq";

const ::std::string iceC_Test_TestIntf_opOptByteSeq_name = "opOptByteSeq";

const ::std::string iceC_Test_TestIntf_opOptShortSeq_name = "opOptShortSeq";

const ::std::string iceC_Test_TestIntf_opOptIntSeq_name = "opOptIntSeq";

const ::std::string iceC_Test_TestIntf_opOptLongSeq_name = "opOptLongSeq";

const ::std::string iceC_Test_TestIntf_opOptFloatSeq_name = "opOptFloatSeq";

const ::std::string iceC_Test_TestIntf_opOptDoubleSeq_name = "opOptDoubleSeq";

const ::std::string iceC_Test_TestIntf_opOptStringSeq_name = "opOptStringSeq";

const ::std::string iceC_Test_TestIntf_opOptESeq_name = "opOptESeq";

const ::std::string iceC_Test_TestIntf_opOptSSeq_name = "opOptSSeq";

const ::std::string iceC_Test_TestIntf_opOptDSeq_name = "opOptDSeq";

const ::std::string iceC_Test_TestIntf_opOptStringSeqSeq_name = "opOptStringSeqSeq";

const ::std::string iceC_Test_TestIntf_opOptByteBufferSeq_name = "opOptByteBufferSeq";

const ::std::string iceC_Test_TestIntf_opOptShortBufferSeq_name = "opOptShortBufferSeq";

const ::std::string iceC_Test_TestIntf_opOptIntBufferSeq_name = "opOptIntBufferSeq";

const ::std::string iceC_Test_TestIntf_opOptLongBufferSeq_name = "opOptLongBufferSeq";

const ::std::string iceC_Test_TestIntf_opOptFloatBufferSeq_name = "opOptFloatBufferSeq";

const ::std::string iceC_Test_TestIntf_opOptDoubleBufferSeq_name = "opOptDoubleBufferSeq";

const ::std::string iceC_Test_TestIntf_shutdown_name = "shutdown";

}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(C* p) { return p; }

void
::IceProxy::Test::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< C>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new C;
        v->_copyFrom(proxy);
    }
}
/// \endcond

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::Test::C::_newInstance() const
{
    return new C;
}
/// \endcond

const ::std::string&
IceProxy::Test::C::ice_staticId()
{
    return ::Test::C::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(TestIntf* p) { return p; }

void
::IceProxy::Test::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< TestIntf>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new TestIntf;
        v->_copyFrom(proxy);
    }
}
/// \endcond

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_opCSeq(const ::Test::CSeq& iceP_inSeq, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opCSeq_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_opCSeq_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_opCSeq_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_inSeq);
        ostr->writePendingValues();
        result->endWriteParams();
        result->invoke(iceC_Test_TestIntf_opCSeq_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::CSeq
IceProxy::Test::TestIntf::end_opCSeq(::Test::CSeq& iceP_outSeq, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opCSeq_name);
    ::Test::CSeq ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_outSeq);
    istr->read(ret);
    istr->readPendingValues();
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::TestIntf::_iceI_end_opCSeq(::Test::CSeq& iceP_outSeq, ::Test::CSeq& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opCSeq_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_outSeq);
    istr->read(ret);
    istr->readPendingValues();
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_opCArray(const ::Test::CArray& iceP_inSeq, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opCArray_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_opCArray_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_opCArray_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_inSeq);
        ostr->writePendingValues();
        result->endWriteParams();
        result->invoke(iceC_Test_TestIntf_opCArray_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::CArray
IceProxy::Test::TestIntf::end_opCArray(::Test::CArray& iceP_outSeq, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opCArray_name);
    ::Test::CArray ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_outSeq);
    istr->read(ret);
    istr->readPendingValues();
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::TestIntf::_iceI_end_opCArray(::Test::CArray& iceP_outSeq, ::Test::CArray& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opCArray_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_outSeq);
    istr->read(ret);
    istr->readPendingValues();
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_opCList(const ::Test::CList& iceP_inSeq, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opCList_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_opCList_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_opCList_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_inSeq);
        ostr->writePendingValues();
        result->endWriteParams();
        result->invoke(iceC_Test_TestIntf_opCList_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::CList
IceProxy::Test::TestIntf::end_opCList(::Test::CList& iceP_outSeq, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opCList_name);
    ::Test::CList ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_outSeq);
    istr->read(ret);
    istr->readPendingValues();
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::TestIntf::_iceI_end_opCList(::Test::CList& iceP_outSeq, ::Test::CList& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opCList_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_outSeq);
    istr->read(ret);
    istr->readPendingValues();
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_opBoolSeq(const ::Test::BoolSeq& iceP_inSeq, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opBoolSeq_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_opBoolSeq_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_opBoolSeq_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_inSeq);
        result->endWriteParams();
        result->invoke(iceC_Test_TestIntf_opBoolSeq_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::BoolSeq
IceProxy::Test::TestIntf::end_opBoolSeq(::Test::BoolSeq& iceP_outSeq, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opBoolSeq_name);
    ::Test::BoolSeq ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_outSeq);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::TestIntf::_iceI_end_opBoolSeq(::Test::BoolSeq& iceP_outSeq, ::Test::BoolSeq& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opBoolSeq_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_outSeq);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_opByteSeq(const ::Test::ByteSeq& iceP_inSeq, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opByteSeq_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_opByteSeq_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_opByteSeq_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_inSeq);
        result->endWriteParams();
        result->invoke(iceC_Test_TestIntf_opByteSeq_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::ByteSeq
IceProxy::Test::TestIntf::end_opByteSeq(::Test::ByteSeq& iceP_outSeq, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opByteSeq_name);
    ::Test::ByteSeq ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_outSeq);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::TestIntf::_iceI_end_opByteSeq(::Test::ByteSeq& iceP_outSeq, ::Test::ByteSeq& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opByteSeq_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_outSeq);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_opShortSeq(const ::Test::ShortSeq& iceP_inSeq, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opShortSeq_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_opShortSeq_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_opShortSeq_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_inSeq);
        result->endWriteParams();
        result->invoke(iceC_Test_TestIntf_opShortSeq_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::ShortSeq
IceProxy::Test::TestIntf::end_opShortSeq(::Test::ShortSeq& iceP_outSeq, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opShortSeq_name);
    ::Test::ShortSeq ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_outSeq);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::TestIntf::_iceI_end_opShortSeq(::Test::ShortSeq& iceP_outSeq, ::Test::ShortSeq& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opShortSeq_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_outSeq);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_opIntSeq(const ::Test::IntSeq& iceP_inSeq, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opIntSeq_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_opIntSeq_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_opIntSeq_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_inSeq);
        result->endWriteParams();
        result->invoke(iceC_Test_TestIntf_opIntSeq_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::IntSeq
IceProxy::Test::TestIntf::end_opIntSeq(::Test::IntSeq& iceP_outSeq, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opIntSeq_name);
    ::Test::IntSeq ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_outSeq);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::TestIntf::_iceI_end_opIntSeq(::Test::IntSeq& iceP_outSeq, ::Test::IntSeq& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opIntSeq_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_outSeq);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_opLongSeq(const ::Test::LongSeq& iceP_inSeq, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opLongSeq_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_opLongSeq_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_opLongSeq_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_inSeq);
        result->endWriteParams();
        result->invoke(iceC_Test_TestIntf_opLongSeq_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::LongSeq
IceProxy::Test::TestIntf::end_opLongSeq(::Test::LongSeq& iceP_outSeq, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opLongSeq_name);
    ::Test::LongSeq ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_outSeq);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::TestIntf::_iceI_end_opLongSeq(::Test::LongSeq& iceP_outSeq, ::Test::LongSeq& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opLongSeq_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_outSeq);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_opFloatSeq(const ::Test::FloatSeq& iceP_inSeq, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opFloatSeq_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_opFloatSeq_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_opFloatSeq_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_inSeq);
        result->endWriteParams();
        result->invoke(iceC_Test_TestIntf_opFloatSeq_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::FloatSeq
IceProxy::Test::TestIntf::end_opFloatSeq(::Test::FloatSeq& iceP_outSeq, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opFloatSeq_name);
    ::Test::FloatSeq ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_outSeq);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::TestIntf::_iceI_end_opFloatSeq(::Test::FloatSeq& iceP_outSeq, ::Test::FloatSeq& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opFloatSeq_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_outSeq);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_opDoubleSeq(const ::Test::DoubleSeq& iceP_inSeq, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opDoubleSeq_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_opDoubleSeq_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_opDoubleSeq_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_inSeq);
        result->endWriteParams();
        result->invoke(iceC_Test_TestIntf_opDoubleSeq_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::DoubleSeq
IceProxy::Test::TestIntf::end_opDoubleSeq(::Test::DoubleSeq& iceP_outSeq, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opDoubleSeq_name);
    ::Test::DoubleSeq ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_outSeq);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::TestIntf::_iceI_end_opDoubleSeq(::Test::DoubleSeq& iceP_outSeq, ::Test::DoubleSeq& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opDoubleSeq_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_outSeq);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_opStringSeq(const ::Test::StringSeq& iceP_inSeq, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opStringSeq_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_opStringSeq_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_opStringSeq_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_inSeq);
        result->endWriteParams();
        result->invoke(iceC_Test_TestIntf_opStringSeq_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::StringSeq
IceProxy::Test::TestIntf::end_opStringSeq(::Test::StringSeq& iceP_outSeq, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opStringSeq_name);
    ::Test::StringSeq ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_outSeq);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::TestIntf::_iceI_end_opStringSeq(::Test::StringSeq& iceP_outSeq, ::Test::StringSeq& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opStringSeq_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_outSeq);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_opESeq(const ::Test::ESeq& iceP_inSeq, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opESeq_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_opESeq_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_opESeq_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_inSeq);
        result->endWriteParams();
        result->invoke(iceC_Test_TestIntf_opESeq_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::ESeq
IceProxy::Test::TestIntf::end_opESeq(::Test::ESeq& iceP_outSeq, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opESeq_name);
    ::Test::ESeq ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_outSeq);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::TestIntf::_iceI_end_opESeq(::Test::ESeq& iceP_outSeq, ::Test::ESeq& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opESeq_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_outSeq);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_opSSeq(const ::Test::SSeq& iceP_inSeq, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opSSeq_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_opSSeq_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_opSSeq_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_inSeq);
        result->endWriteParams();
        result->invoke(iceC_Test_TestIntf_opSSeq_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::SSeq
IceProxy::Test::TestIntf::end_opSSeq(::Test::SSeq& iceP_outSeq, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opSSeq_name);
    ::Test::SSeq ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_outSeq);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::TestIntf::_iceI_end_opSSeq(::Test::SSeq& iceP_outSeq, ::Test::SSeq& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opSSeq_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_outSeq);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_opDSeq(const ::Test::DSeq& iceP_inSeq, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opDSeq_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_opDSeq_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_opDSeq_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_inSeq);
        result->endWriteParams();
        result->invoke(iceC_Test_TestIntf_opDSeq_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::DSeq
IceProxy::Test::TestIntf::end_opDSeq(::Test::DSeq& iceP_outSeq, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opDSeq_name);
    ::Test::DSeq ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_outSeq);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::TestIntf::_iceI_end_opDSeq(::Test::DSeq& iceP_outSeq, ::Test::DSeq& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opDSeq_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_outSeq);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_opStringSeqSeq(const ::Test::StringSeqSeq& iceP_inSeq, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opStringSeqSeq_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_opStringSeqSeq_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_opStringSeqSeq_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_inSeq);
        result->endWriteParams();
        result->invoke(iceC_Test_TestIntf_opStringSeqSeq_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::StringSeqSeq
IceProxy::Test::TestIntf::end_opStringSeqSeq(::Test::StringSeqSeq& iceP_outSeq, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opStringSeqSeq_name);
    ::Test::StringSeqSeq ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_outSeq);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::TestIntf::_iceI_end_opStringSeqSeq(::Test::StringSeqSeq& iceP_outSeq, ::Test::StringSeqSeq& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opStringSeqSeq_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_outSeq);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_opByteBufferSeq(const ::Test::ByteBuffer& iceP_inSeq, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opByteBufferSeq_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_opByteBufferSeq_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_opByteBufferSeq_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_inSeq);
        result->endWriteParams();
        result->invoke(iceC_Test_TestIntf_opByteBufferSeq_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::ByteBuffer
IceProxy::Test::TestIntf::end_opByteBufferSeq(::Test::ByteBuffer& iceP_outSeq, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opByteBufferSeq_name);
    ::Test::ByteBuffer ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_outSeq);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::TestIntf::_iceI_end_opByteBufferSeq(::Test::ByteBuffer& iceP_outSeq, ::Test::ByteBuffer& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opByteBufferSeq_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_outSeq);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_opShortBufferSeq(const ::Test::ShortBuffer& iceP_inSeq, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opShortBufferSeq_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_opShortBufferSeq_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_opShortBufferSeq_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_inSeq);
        result->endWriteParams();
        result->invoke(iceC_Test_TestIntf_opShortBufferSeq_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::ShortBuffer
IceProxy::Test::TestIntf::end_opShortBufferSeq(::Test::ShortBuffer& iceP_outSeq, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opShortBufferSeq_name);
    ::Test::ShortBuffer ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_outSeq);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::TestIntf::_iceI_end_opShortBufferSeq(::Test::ShortBuffer& iceP_outSeq, ::Test::ShortBuffer& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opShortBufferSeq_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_outSeq);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_opIntBufferSeq(const ::Test::IntBuffer& iceP_inSeq, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opIntBufferSeq_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_opIntBufferSeq_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_opIntBufferSeq_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_inSeq);
        result->endWriteParams();
        result->invoke(iceC_Test_TestIntf_opIntBufferSeq_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::IntBuffer
IceProxy::Test::TestIntf::end_opIntBufferSeq(::Test::IntBuffer& iceP_outSeq, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opIntBufferSeq_name);
    ::Test::IntBuffer ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_outSeq);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::TestIntf::_iceI_end_opIntBufferSeq(::Test::IntBuffer& iceP_outSeq, ::Test::IntBuffer& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opIntBufferSeq_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_outSeq);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_opLongBufferSeq(const ::Test::LongBuffer& iceP_inSeq, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opLongBufferSeq_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_opLongBufferSeq_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_opLongBufferSeq_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_inSeq);
        result->endWriteParams();
        result->invoke(iceC_Test_TestIntf_opLongBufferSeq_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::LongBuffer
IceProxy::Test::TestIntf::end_opLongBufferSeq(::Test::LongBuffer& iceP_outSeq, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opLongBufferSeq_name);
    ::Test::LongBuffer ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_outSeq);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::TestIntf::_iceI_end_opLongBufferSeq(::Test::LongBuffer& iceP_outSeq, ::Test::LongBuffer& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opLongBufferSeq_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_outSeq);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_opFloatBufferSeq(const ::Test::FloatBuffer& iceP_inSeq, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opFloatBufferSeq_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_opFloatBufferSeq_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_opFloatBufferSeq_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_inSeq);
        result->endWriteParams();
        result->invoke(iceC_Test_TestIntf_opFloatBufferSeq_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::FloatBuffer
IceProxy::Test::TestIntf::end_opFloatBufferSeq(::Test::FloatBuffer& iceP_outSeq, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opFloatBufferSeq_name);
    ::Test::FloatBuffer ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_outSeq);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::TestIntf::_iceI_end_opFloatBufferSeq(::Test::FloatBuffer& iceP_outSeq, ::Test::FloatBuffer& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opFloatBufferSeq_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_outSeq);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_opDoubleBufferSeq(const ::Test::DoubleBuffer& iceP_inSeq, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opDoubleBufferSeq_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_opDoubleBufferSeq_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_opDoubleBufferSeq_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_inSeq);
        result->endWriteParams();
        result->invoke(iceC_Test_TestIntf_opDoubleBufferSeq_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::DoubleBuffer
IceProxy::Test::TestIntf::end_opDoubleBufferSeq(::Test::DoubleBuffer& iceP_outSeq, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opDoubleBufferSeq_name);
    ::Test::DoubleBuffer ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_outSeq);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::TestIntf::_iceI_end_opDoubleBufferSeq(::Test::DoubleBuffer& iceP_outSeq, ::Test::DoubleBuffer& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opDoubleBufferSeq_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_outSeq);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_opOptCSeq(const std::optional< ::Test::CSeq>& iceP_inSeq, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opOptCSeq_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_opOptCSeq_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_opOptCSeq_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(2, iceP_inSeq);
        result->endWriteParams();
        result->invoke(iceC_Test_TestIntf_opOptCSeq_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

std::optional< ::Test::CSeq>
IceProxy::Test::TestIntf::end_opOptCSeq(std::optional< ::Test::CSeq>& iceP_outSeq, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opOptCSeq_name);
    std::optional< ::Test::CSeq> ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(1, ret);
    istr->read(3, iceP_outSeq);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::TestIntf::_iceI_end_opOptCSeq(std::optional< ::Test::CSeq>& iceP_outSeq, std::optional< ::Test::CSeq>& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opOptCSeq_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(1, ret);
    istr->read(3, iceP_outSeq);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_opOptCArray(const std::optional< ::Test::CArray>& iceP_inSeq, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opOptCArray_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_opOptCArray_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_opOptCArray_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(2, iceP_inSeq);
        result->endWriteParams();
        result->invoke(iceC_Test_TestIntf_opOptCArray_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

std::optional< ::Test::CArray>
IceProxy::Test::TestIntf::end_opOptCArray(std::optional< ::Test::CArray>& iceP_outSeq, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opOptCArray_name);
    std::optional< ::Test::CArray> ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(1, ret);
    istr->read(3, iceP_outSeq);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::TestIntf::_iceI_end_opOptCArray(std::optional< ::Test::CArray>& iceP_outSeq, std::optional< ::Test::CArray>& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opOptCArray_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(1, ret);
    istr->read(3, iceP_outSeq);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_opOptCList(const std::optional< ::Test::CList>& iceP_inSeq, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opOptCList_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_opOptCList_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_opOptCList_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(2, iceP_inSeq);
        result->endWriteParams();
        result->invoke(iceC_Test_TestIntf_opOptCList_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

std::optional< ::Test::CList>
IceProxy::Test::TestIntf::end_opOptCList(std::optional< ::Test::CList>& iceP_outSeq, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opOptCList_name);
    std::optional< ::Test::CList> ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(1, ret);
    istr->read(3, iceP_outSeq);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::TestIntf::_iceI_end_opOptCList(std::optional< ::Test::CList>& iceP_outSeq, std::optional< ::Test::CList>& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opOptCList_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(1, ret);
    istr->read(3, iceP_outSeq);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_opOptBoolSeq(const std::optional< ::Test::BoolSeq>& iceP_inSeq, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opOptBoolSeq_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_opOptBoolSeq_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_opOptBoolSeq_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(2, iceP_inSeq);
        result->endWriteParams();
        result->invoke(iceC_Test_TestIntf_opOptBoolSeq_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

std::optional< ::Test::BoolSeq>
IceProxy::Test::TestIntf::end_opOptBoolSeq(std::optional< ::Test::BoolSeq>& iceP_outSeq, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opOptBoolSeq_name);
    std::optional< ::Test::BoolSeq> ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(1, ret);
    istr->read(3, iceP_outSeq);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::TestIntf::_iceI_end_opOptBoolSeq(std::optional< ::Test::BoolSeq>& iceP_outSeq, std::optional< ::Test::BoolSeq>& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opOptBoolSeq_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(1, ret);
    istr->read(3, iceP_outSeq);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_opOptByteSeq(const std::optional< ::Test::ByteSeq>& iceP_inSeq, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opOptByteSeq_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_opOptByteSeq_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_opOptByteSeq_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(2, iceP_inSeq);
        result->endWriteParams();
        result->invoke(iceC_Test_TestIntf_opOptByteSeq_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

std::optional< ::Test::ByteSeq>
IceProxy::Test::TestIntf::end_opOptByteSeq(std::optional< ::Test::ByteSeq>& iceP_outSeq, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opOptByteSeq_name);
    std::optional< ::Test::ByteSeq> ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(1, ret);
    istr->read(3, iceP_outSeq);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::TestIntf::_iceI_end_opOptByteSeq(std::optional< ::Test::ByteSeq>& iceP_outSeq, std::optional< ::Test::ByteSeq>& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opOptByteSeq_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(1, ret);
    istr->read(3, iceP_outSeq);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_opOptShortSeq(const std::optional< ::Test::ShortSeq>& iceP_inSeq, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opOptShortSeq_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_opOptShortSeq_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_opOptShortSeq_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(2, iceP_inSeq);
        result->endWriteParams();
        result->invoke(iceC_Test_TestIntf_opOptShortSeq_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

std::optional< ::Test::ShortSeq>
IceProxy::Test::TestIntf::end_opOptShortSeq(std::optional< ::Test::ShortSeq>& iceP_outSeq, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opOptShortSeq_name);
    std::optional< ::Test::ShortSeq> ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(1, ret);
    istr->read(3, iceP_outSeq);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::TestIntf::_iceI_end_opOptShortSeq(std::optional< ::Test::ShortSeq>& iceP_outSeq, std::optional< ::Test::ShortSeq>& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opOptShortSeq_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(1, ret);
    istr->read(3, iceP_outSeq);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_opOptIntSeq(const std::optional< ::Test::IntSeq>& iceP_inSeq, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opOptIntSeq_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_opOptIntSeq_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_opOptIntSeq_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(2, iceP_inSeq);
        result->endWriteParams();
        result->invoke(iceC_Test_TestIntf_opOptIntSeq_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

std::optional< ::Test::IntSeq>
IceProxy::Test::TestIntf::end_opOptIntSeq(std::optional< ::Test::IntSeq>& iceP_outSeq, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opOptIntSeq_name);
    std::optional< ::Test::IntSeq> ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(1, ret);
    istr->read(3, iceP_outSeq);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::TestIntf::_iceI_end_opOptIntSeq(std::optional< ::Test::IntSeq>& iceP_outSeq, std::optional< ::Test::IntSeq>& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opOptIntSeq_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(1, ret);
    istr->read(3, iceP_outSeq);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_opOptLongSeq(const std::optional< ::Test::LongSeq>& iceP_inSeq, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opOptLongSeq_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_opOptLongSeq_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_opOptLongSeq_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(2, iceP_inSeq);
        result->endWriteParams();
        result->invoke(iceC_Test_TestIntf_opOptLongSeq_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

std::optional< ::Test::LongSeq>
IceProxy::Test::TestIntf::end_opOptLongSeq(std::optional< ::Test::LongSeq>& iceP_outSeq, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opOptLongSeq_name);
    std::optional< ::Test::LongSeq> ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(1, ret);
    istr->read(3, iceP_outSeq);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::TestIntf::_iceI_end_opOptLongSeq(std::optional< ::Test::LongSeq>& iceP_outSeq, std::optional< ::Test::LongSeq>& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opOptLongSeq_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(1, ret);
    istr->read(3, iceP_outSeq);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_opOptFloatSeq(const std::optional< ::Test::FloatSeq>& iceP_inSeq, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opOptFloatSeq_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_opOptFloatSeq_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_opOptFloatSeq_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(2, iceP_inSeq);
        result->endWriteParams();
        result->invoke(iceC_Test_TestIntf_opOptFloatSeq_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

std::optional< ::Test::FloatSeq>
IceProxy::Test::TestIntf::end_opOptFloatSeq(std::optional< ::Test::FloatSeq>& iceP_outSeq, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opOptFloatSeq_name);
    std::optional< ::Test::FloatSeq> ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(1, ret);
    istr->read(3, iceP_outSeq);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::TestIntf::_iceI_end_opOptFloatSeq(std::optional< ::Test::FloatSeq>& iceP_outSeq, std::optional< ::Test::FloatSeq>& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opOptFloatSeq_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(1, ret);
    istr->read(3, iceP_outSeq);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_opOptDoubleSeq(const std::optional< ::Test::DoubleSeq>& iceP_inSeq, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opOptDoubleSeq_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_opOptDoubleSeq_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_opOptDoubleSeq_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(2, iceP_inSeq);
        result->endWriteParams();
        result->invoke(iceC_Test_TestIntf_opOptDoubleSeq_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

std::optional< ::Test::DoubleSeq>
IceProxy::Test::TestIntf::end_opOptDoubleSeq(std::optional< ::Test::DoubleSeq>& iceP_outSeq, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opOptDoubleSeq_name);
    std::optional< ::Test::DoubleSeq> ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(1, ret);
    istr->read(3, iceP_outSeq);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::TestIntf::_iceI_end_opOptDoubleSeq(std::optional< ::Test::DoubleSeq>& iceP_outSeq, std::optional< ::Test::DoubleSeq>& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opOptDoubleSeq_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(1, ret);
    istr->read(3, iceP_outSeq);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_opOptStringSeq(const std::optional< ::Test::StringSeq>& iceP_inSeq, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opOptStringSeq_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_opOptStringSeq_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_opOptStringSeq_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(2, iceP_inSeq);
        result->endWriteParams();
        result->invoke(iceC_Test_TestIntf_opOptStringSeq_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

std::optional< ::Test::StringSeq>
IceProxy::Test::TestIntf::end_opOptStringSeq(std::optional< ::Test::StringSeq>& iceP_outSeq, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opOptStringSeq_name);
    std::optional< ::Test::StringSeq> ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(1, ret);
    istr->read(3, iceP_outSeq);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::TestIntf::_iceI_end_opOptStringSeq(std::optional< ::Test::StringSeq>& iceP_outSeq, std::optional< ::Test::StringSeq>& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opOptStringSeq_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(1, ret);
    istr->read(3, iceP_outSeq);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_opOptESeq(const std::optional< ::Test::ESeq>& iceP_inSeq, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opOptESeq_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_opOptESeq_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_opOptESeq_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(2, iceP_inSeq);
        result->endWriteParams();
        result->invoke(iceC_Test_TestIntf_opOptESeq_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

std::optional< ::Test::ESeq>
IceProxy::Test::TestIntf::end_opOptESeq(std::optional< ::Test::ESeq>& iceP_outSeq, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opOptESeq_name);
    std::optional< ::Test::ESeq> ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(1, ret);
    istr->read(3, iceP_outSeq);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::TestIntf::_iceI_end_opOptESeq(std::optional< ::Test::ESeq>& iceP_outSeq, std::optional< ::Test::ESeq>& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opOptESeq_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(1, ret);
    istr->read(3, iceP_outSeq);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_opOptSSeq(const std::optional< ::Test::SSeq>& iceP_inSeq, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opOptSSeq_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_opOptSSeq_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_opOptSSeq_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(2, iceP_inSeq);
        result->endWriteParams();
        result->invoke(iceC_Test_TestIntf_opOptSSeq_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

std::optional< ::Test::SSeq>
IceProxy::Test::TestIntf::end_opOptSSeq(std::optional< ::Test::SSeq>& iceP_outSeq, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opOptSSeq_name);
    std::optional< ::Test::SSeq> ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(1, ret);
    istr->read(3, iceP_outSeq);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::TestIntf::_iceI_end_opOptSSeq(std::optional< ::Test::SSeq>& iceP_outSeq, std::optional< ::Test::SSeq>& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opOptSSeq_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(1, ret);
    istr->read(3, iceP_outSeq);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_opOptDSeq(const std::optional< ::Test::DSeq>& iceP_inSeq, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opOptDSeq_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_opOptDSeq_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_opOptDSeq_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(2, iceP_inSeq);
        result->endWriteParams();
        result->invoke(iceC_Test_TestIntf_opOptDSeq_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

std::optional< ::Test::DSeq>
IceProxy::Test::TestIntf::end_opOptDSeq(std::optional< ::Test::DSeq>& iceP_outSeq, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opOptDSeq_name);
    std::optional< ::Test::DSeq> ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(1, ret);
    istr->read(3, iceP_outSeq);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::TestIntf::_iceI_end_opOptDSeq(std::optional< ::Test::DSeq>& iceP_outSeq, std::optional< ::Test::DSeq>& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opOptDSeq_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(1, ret);
    istr->read(3, iceP_outSeq);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_opOptStringSeqSeq(const std::optional< ::Test::StringSeqSeq>& iceP_inSeq, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opOptStringSeqSeq_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_opOptStringSeqSeq_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_opOptStringSeqSeq_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(2, iceP_inSeq);
        result->endWriteParams();
        result->invoke(iceC_Test_TestIntf_opOptStringSeqSeq_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

std::optional< ::Test::StringSeqSeq>
IceProxy::Test::TestIntf::end_opOptStringSeqSeq(std::optional< ::Test::StringSeqSeq>& iceP_outSeq, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opOptStringSeqSeq_name);
    std::optional< ::Test::StringSeqSeq> ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(1, ret);
    istr->read(3, iceP_outSeq);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::TestIntf::_iceI_end_opOptStringSeqSeq(std::optional< ::Test::StringSeqSeq>& iceP_outSeq, std::optional< ::Test::StringSeqSeq>& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opOptStringSeqSeq_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(1, ret);
    istr->read(3, iceP_outSeq);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_opOptByteBufferSeq(const std::optional< ::Test::ByteBuffer>& iceP_inSeq, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opOptByteBufferSeq_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_opOptByteBufferSeq_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_opOptByteBufferSeq_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(2, iceP_inSeq);
        result->endWriteParams();
        result->invoke(iceC_Test_TestIntf_opOptByteBufferSeq_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

std::optional< ::Test::ByteBuffer>
IceProxy::Test::TestIntf::end_opOptByteBufferSeq(std::optional< ::Test::ByteBuffer>& iceP_outSeq, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opOptByteBufferSeq_name);
    std::optional< ::Test::ByteBuffer> ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(1, ret);
    istr->read(3, iceP_outSeq);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::TestIntf::_iceI_end_opOptByteBufferSeq(std::optional< ::Test::ByteBuffer>& iceP_outSeq, std::optional< ::Test::ByteBuffer>& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opOptByteBufferSeq_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(1, ret);
    istr->read(3, iceP_outSeq);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_opOptShortBufferSeq(const std::optional< ::Test::ShortBuffer>& iceP_inSeq, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opOptShortBufferSeq_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_opOptShortBufferSeq_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_opOptShortBufferSeq_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(2, iceP_inSeq);
        result->endWriteParams();
        result->invoke(iceC_Test_TestIntf_opOptShortBufferSeq_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

std::optional< ::Test::ShortBuffer>
IceProxy::Test::TestIntf::end_opOptShortBufferSeq(std::optional< ::Test::ShortBuffer>& iceP_outSeq, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opOptShortBufferSeq_name);
    std::optional< ::Test::ShortBuffer> ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(1, ret);
    istr->read(3, iceP_outSeq);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::TestIntf::_iceI_end_opOptShortBufferSeq(std::optional< ::Test::ShortBuffer>& iceP_outSeq, std::optional< ::Test::ShortBuffer>& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opOptShortBufferSeq_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(1, ret);
    istr->read(3, iceP_outSeq);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_opOptIntBufferSeq(const std::optional< ::Test::IntBuffer>& iceP_inSeq, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opOptIntBufferSeq_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_opOptIntBufferSeq_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_opOptIntBufferSeq_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(2, iceP_inSeq);
        result->endWriteParams();
        result->invoke(iceC_Test_TestIntf_opOptIntBufferSeq_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

std::optional< ::Test::IntBuffer>
IceProxy::Test::TestIntf::end_opOptIntBufferSeq(std::optional< ::Test::IntBuffer>& iceP_outSeq, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opOptIntBufferSeq_name);
    std::optional< ::Test::IntBuffer> ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(1, ret);
    istr->read(3, iceP_outSeq);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::TestIntf::_iceI_end_opOptIntBufferSeq(std::optional< ::Test::IntBuffer>& iceP_outSeq, std::optional< ::Test::IntBuffer>& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opOptIntBufferSeq_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(1, ret);
    istr->read(3, iceP_outSeq);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_opOptLongBufferSeq(const std::optional< ::Test::LongBuffer>& iceP_inSeq, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opOptLongBufferSeq_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_opOptLongBufferSeq_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_opOptLongBufferSeq_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(2, iceP_inSeq);
        result->endWriteParams();
        result->invoke(iceC_Test_TestIntf_opOptLongBufferSeq_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

std::optional< ::Test::LongBuffer>
IceProxy::Test::TestIntf::end_opOptLongBufferSeq(std::optional< ::Test::LongBuffer>& iceP_outSeq, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opOptLongBufferSeq_name);
    std::optional< ::Test::LongBuffer> ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(1, ret);
    istr->read(3, iceP_outSeq);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::TestIntf::_iceI_end_opOptLongBufferSeq(std::optional< ::Test::LongBuffer>& iceP_outSeq, std::optional< ::Test::LongBuffer>& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opOptLongBufferSeq_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(1, ret);
    istr->read(3, iceP_outSeq);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_opOptFloatBufferSeq(const std::optional< ::Test::FloatBuffer>& iceP_inSeq, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opOptFloatBufferSeq_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_opOptFloatBufferSeq_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_opOptFloatBufferSeq_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(2, iceP_inSeq);
        result->endWriteParams();
        result->invoke(iceC_Test_TestIntf_opOptFloatBufferSeq_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

std::optional< ::Test::FloatBuffer>
IceProxy::Test::TestIntf::end_opOptFloatBufferSeq(std::optional< ::Test::FloatBuffer>& iceP_outSeq, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opOptFloatBufferSeq_name);
    std::optional< ::Test::FloatBuffer> ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(1, ret);
    istr->read(3, iceP_outSeq);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::TestIntf::_iceI_end_opOptFloatBufferSeq(std::optional< ::Test::FloatBuffer>& iceP_outSeq, std::optional< ::Test::FloatBuffer>& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opOptFloatBufferSeq_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(1, ret);
    istr->read(3, iceP_outSeq);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_opOptDoubleBufferSeq(const std::optional< ::Test::DoubleBuffer>& iceP_inSeq, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opOptDoubleBufferSeq_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_opOptDoubleBufferSeq_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_opOptDoubleBufferSeq_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(2, iceP_inSeq);
        result->endWriteParams();
        result->invoke(iceC_Test_TestIntf_opOptDoubleBufferSeq_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

std::optional< ::Test::DoubleBuffer>
IceProxy::Test::TestIntf::end_opOptDoubleBufferSeq(std::optional< ::Test::DoubleBuffer>& iceP_outSeq, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opOptDoubleBufferSeq_name);
    std::optional< ::Test::DoubleBuffer> ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(1, ret);
    istr->read(3, iceP_outSeq);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::TestIntf::_iceI_end_opOptDoubleBufferSeq(std::optional< ::Test::DoubleBuffer>& iceP_outSeq, std::optional< ::Test::DoubleBuffer>& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_TestIntf_opOptDoubleBufferSeq_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(1, ret);
    istr->read(3, iceP_outSeq);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::TestIntf::_iceI_begin_shutdown(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_TestIntf_shutdown_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_TestIntf_shutdown_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Test_TestIntf_shutdown_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Test::TestIntf::end_shutdown(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_Test_TestIntf_shutdown_name);
}

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::Test::TestIntf::_newInstance() const
{
    return new TestIntf;
}
/// \endcond

const ::std::string&
IceProxy::Test::TestIntf::ice_staticId()
{
    return ::Test::TestIntf::ice_staticId();
}

Test::C::~C()
{
}

/// \cond INTERNAL
::Ice::Object* Test::upCast(C* p) { return p; }

/// \endcond
::Ice::ObjectPtr
Test::C::ice_clone() const
{
    ::Ice::Object* p = new C(*this);
    return p;
}

namespace
{
const ::std::string iceC_Test_C_ids[2] =
{
    "::Ice::Object",
    "::Test::C"
};

}

bool
Test::C::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_C_ids, iceC_Test_C_ids + 2, s);
}

::std::vector< ::std::string>
Test::C::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Test_C_ids[0], &iceC_Test_C_ids[2]);
}

const ::std::string&
Test::C::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::C::ice_staticId()
{
    static const ::std::string typeId = "::Test::C";
    return typeId;
}

/// \cond STREAM
void
Test::C::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< C, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Test::C::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< C, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

namespace
{
const ::IceInternal::DefaultValueFactoryInit< ::Test::C> iceC_Test_C_init("::Test::C");
}

::Ice::ValueFactoryPtr
Test::C::ice_factory()
{
    return ::IceInternal::factoryTable->getValueFactory(::Test::C::ice_staticId());
}

/// \cond INTERNAL
void
Test::_icePatchObjectPtr(CPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = CPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(C::ice_staticId(), v);
    }
}
/// \endcond

Test::TestIntf::~TestIntf()
{
}

/// \cond INTERNAL
::Ice::Object* Test::upCast(TestIntf* p) { return p; }

/// \endcond

namespace
{
const ::std::string iceC_Test_TestIntf_ids[2] =
{
    "::Ice::Object",
    "::Test::TestIntf"
};

}

bool
Test::TestIntf::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_TestIntf_ids, iceC_Test_TestIntf_ids + 2, s);
}

::std::vector< ::std::string>
Test::TestIntf::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Test_TestIntf_ids[0], &iceC_Test_TestIntf_ids[2]);
}

const ::std::string&
Test::TestIntf::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::TestIntf::ice_staticId()
{
    static const ::std::string typeId = "::Test::TestIntf";
    return typeId;
}

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opCSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    CSeq iceP_inSeq;
    istr->read(iceP_inSeq);
    istr->readPendingValues();
    inS.endReadParams();
    CSeq iceP_outSeq;
    CSeq ret = this->opCSeq(iceP_inSeq, iceP_outSeq, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_outSeq);
    ostr->write(ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opCArray(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    CArray iceP_inSeq;
    istr->read(iceP_inSeq);
    istr->readPendingValues();
    inS.endReadParams();
    CArray iceP_outSeq;
    CArray ret = this->opCArray(iceP_inSeq, iceP_outSeq, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_outSeq);
    ostr->write(ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opCList(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    CList iceP_inSeq;
    istr->read(iceP_inSeq);
    istr->readPendingValues();
    inS.endReadParams();
    CList iceP_outSeq;
    CList ret = this->opCList(iceP_inSeq, iceP_outSeq, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_outSeq);
    ostr->write(ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opBoolSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    BoolSeq iceP_inSeq;
    istr->read(iceP_inSeq);
    inS.endReadParams();
    BoolSeq iceP_outSeq;
    BoolSeq ret = this->opBoolSeq(iceP_inSeq, iceP_outSeq, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_outSeq);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opByteSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ByteSeq iceP_inSeq;
    istr->read(iceP_inSeq);
    inS.endReadParams();
    ByteSeq iceP_outSeq;
    ByteSeq ret = this->opByteSeq(iceP_inSeq, iceP_outSeq, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_outSeq);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opShortSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ShortSeq iceP_inSeq;
    istr->read(iceP_inSeq);
    inS.endReadParams();
    ShortSeq iceP_outSeq;
    ShortSeq ret = this->opShortSeq(iceP_inSeq, iceP_outSeq, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_outSeq);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opIntSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    IntSeq iceP_inSeq;
    istr->read(iceP_inSeq);
    inS.endReadParams();
    IntSeq iceP_outSeq;
    IntSeq ret = this->opIntSeq(iceP_inSeq, iceP_outSeq, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_outSeq);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opLongSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    LongSeq iceP_inSeq;
    istr->read(iceP_inSeq);
    inS.endReadParams();
    LongSeq iceP_outSeq;
    LongSeq ret = this->opLongSeq(iceP_inSeq, iceP_outSeq, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_outSeq);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opFloatSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    FloatSeq iceP_inSeq;
    istr->read(iceP_inSeq);
    inS.endReadParams();
    FloatSeq iceP_outSeq;
    FloatSeq ret = this->opFloatSeq(iceP_inSeq, iceP_outSeq, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_outSeq);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opDoubleSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    DoubleSeq iceP_inSeq;
    istr->read(iceP_inSeq);
    inS.endReadParams();
    DoubleSeq iceP_outSeq;
    DoubleSeq ret = this->opDoubleSeq(iceP_inSeq, iceP_outSeq, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_outSeq);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opStringSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    StringSeq iceP_inSeq;
    istr->read(iceP_inSeq);
    inS.endReadParams();
    StringSeq iceP_outSeq;
    StringSeq ret = this->opStringSeq(iceP_inSeq, iceP_outSeq, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_outSeq);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opESeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ESeq iceP_inSeq;
    istr->read(iceP_inSeq);
    inS.endReadParams();
    ESeq iceP_outSeq;
    ESeq ret = this->opESeq(iceP_inSeq, iceP_outSeq, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_outSeq);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opSSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    SSeq iceP_inSeq;
    istr->read(iceP_inSeq);
    inS.endReadParams();
    SSeq iceP_outSeq;
    SSeq ret = this->opSSeq(iceP_inSeq, iceP_outSeq, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_outSeq);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opDSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    DSeq iceP_inSeq;
    istr->read(iceP_inSeq);
    inS.endReadParams();
    DSeq iceP_outSeq;
    DSeq ret = this->opDSeq(iceP_inSeq, iceP_outSeq, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_outSeq);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opStringSeqSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    StringSeqSeq iceP_inSeq;
    istr->read(iceP_inSeq);
    inS.endReadParams();
    StringSeqSeq iceP_outSeq;
    StringSeqSeq ret = this->opStringSeqSeq(iceP_inSeq, iceP_outSeq, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_outSeq);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opByteBufferSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ByteBuffer iceP_inSeq;
    istr->read(iceP_inSeq);
    inS.endReadParams();
    ByteBuffer iceP_outSeq;
    ByteBuffer ret = this->opByteBufferSeq(iceP_inSeq, iceP_outSeq, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_outSeq);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opShortBufferSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ShortBuffer iceP_inSeq;
    istr->read(iceP_inSeq);
    inS.endReadParams();
    ShortBuffer iceP_outSeq;
    ShortBuffer ret = this->opShortBufferSeq(iceP_inSeq, iceP_outSeq, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_outSeq);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opIntBufferSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    IntBuffer iceP_inSeq;
    istr->read(iceP_inSeq);
    inS.endReadParams();
    IntBuffer iceP_outSeq;
    IntBuffer ret = this->opIntBufferSeq(iceP_inSeq, iceP_outSeq, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_outSeq);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opLongBufferSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    LongBuffer iceP_inSeq;
    istr->read(iceP_inSeq);
    inS.endReadParams();
    LongBuffer iceP_outSeq;
    LongBuffer ret = this->opLongBufferSeq(iceP_inSeq, iceP_outSeq, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_outSeq);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opFloatBufferSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    FloatBuffer iceP_inSeq;
    istr->read(iceP_inSeq);
    inS.endReadParams();
    FloatBuffer iceP_outSeq;
    FloatBuffer ret = this->opFloatBufferSeq(iceP_inSeq, iceP_outSeq, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_outSeq);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opDoubleBufferSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    DoubleBuffer iceP_inSeq;
    istr->read(iceP_inSeq);
    inS.endReadParams();
    DoubleBuffer iceP_outSeq;
    DoubleBuffer ret = this->opDoubleBufferSeq(iceP_inSeq, iceP_outSeq, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_outSeq);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opOptCSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    std::optional<CSeq> iceP_inSeq;
    istr->read(2, iceP_inSeq);
    inS.endReadParams();
    std::optional<CSeq> iceP_outSeq;
    std::optional<CSeq> ret = this->opOptCSeq(iceP_inSeq, iceP_outSeq, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(1, ret);
    ostr->write(3, iceP_outSeq);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opOptCArray(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    std::optional<CArray> iceP_inSeq;
    istr->read(2, iceP_inSeq);
    inS.endReadParams();
    std::optional<CArray> iceP_outSeq;
    std::optional<CArray> ret = this->opOptCArray(iceP_inSeq, iceP_outSeq, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(1, ret);
    ostr->write(3, iceP_outSeq);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opOptCList(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    std::optional<CList> iceP_inSeq;
    istr->read(2, iceP_inSeq);
    inS.endReadParams();
    std::optional<CList> iceP_outSeq;
    std::optional<CList> ret = this->opOptCList(iceP_inSeq, iceP_outSeq, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(1, ret);
    ostr->write(3, iceP_outSeq);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opOptBoolSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    std::optional<BoolSeq> iceP_inSeq;
    istr->read(2, iceP_inSeq);
    inS.endReadParams();
    std::optional<BoolSeq> iceP_outSeq;
    std::optional<BoolSeq> ret = this->opOptBoolSeq(iceP_inSeq, iceP_outSeq, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(1, ret);
    ostr->write(3, iceP_outSeq);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opOptByteSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    std::optional<ByteSeq> iceP_inSeq;
    istr->read(2, iceP_inSeq);
    inS.endReadParams();
    std::optional<ByteSeq> iceP_outSeq;
    std::optional<ByteSeq> ret = this->opOptByteSeq(iceP_inSeq, iceP_outSeq, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(1, ret);
    ostr->write(3, iceP_outSeq);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opOptShortSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    std::optional<ShortSeq> iceP_inSeq;
    istr->read(2, iceP_inSeq);
    inS.endReadParams();
    std::optional<ShortSeq> iceP_outSeq;
    std::optional<ShortSeq> ret = this->opOptShortSeq(iceP_inSeq, iceP_outSeq, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(1, ret);
    ostr->write(3, iceP_outSeq);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opOptIntSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    std::optional<IntSeq> iceP_inSeq;
    istr->read(2, iceP_inSeq);
    inS.endReadParams();
    std::optional<IntSeq> iceP_outSeq;
    std::optional<IntSeq> ret = this->opOptIntSeq(iceP_inSeq, iceP_outSeq, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(1, ret);
    ostr->write(3, iceP_outSeq);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opOptLongSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    std::optional<LongSeq> iceP_inSeq;
    istr->read(2, iceP_inSeq);
    inS.endReadParams();
    std::optional<LongSeq> iceP_outSeq;
    std::optional<LongSeq> ret = this->opOptLongSeq(iceP_inSeq, iceP_outSeq, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(1, ret);
    ostr->write(3, iceP_outSeq);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opOptFloatSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    std::optional<FloatSeq> iceP_inSeq;
    istr->read(2, iceP_inSeq);
    inS.endReadParams();
    std::optional<FloatSeq> iceP_outSeq;
    std::optional<FloatSeq> ret = this->opOptFloatSeq(iceP_inSeq, iceP_outSeq, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(1, ret);
    ostr->write(3, iceP_outSeq);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opOptDoubleSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    std::optional<DoubleSeq> iceP_inSeq;
    istr->read(2, iceP_inSeq);
    inS.endReadParams();
    std::optional<DoubleSeq> iceP_outSeq;
    std::optional<DoubleSeq> ret = this->opOptDoubleSeq(iceP_inSeq, iceP_outSeq, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(1, ret);
    ostr->write(3, iceP_outSeq);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opOptStringSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    std::optional<StringSeq> iceP_inSeq;
    istr->read(2, iceP_inSeq);
    inS.endReadParams();
    std::optional<StringSeq> iceP_outSeq;
    std::optional<StringSeq> ret = this->opOptStringSeq(iceP_inSeq, iceP_outSeq, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(1, ret);
    ostr->write(3, iceP_outSeq);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opOptESeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    std::optional<ESeq> iceP_inSeq;
    istr->read(2, iceP_inSeq);
    inS.endReadParams();
    std::optional<ESeq> iceP_outSeq;
    std::optional<ESeq> ret = this->opOptESeq(iceP_inSeq, iceP_outSeq, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(1, ret);
    ostr->write(3, iceP_outSeq);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opOptSSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    std::optional<SSeq> iceP_inSeq;
    istr->read(2, iceP_inSeq);
    inS.endReadParams();
    std::optional<SSeq> iceP_outSeq;
    std::optional<SSeq> ret = this->opOptSSeq(iceP_inSeq, iceP_outSeq, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(1, ret);
    ostr->write(3, iceP_outSeq);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opOptDSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    std::optional<DSeq> iceP_inSeq;
    istr->read(2, iceP_inSeq);
    inS.endReadParams();
    std::optional<DSeq> iceP_outSeq;
    std::optional<DSeq> ret = this->opOptDSeq(iceP_inSeq, iceP_outSeq, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(1, ret);
    ostr->write(3, iceP_outSeq);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opOptStringSeqSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    std::optional<StringSeqSeq> iceP_inSeq;
    istr->read(2, iceP_inSeq);
    inS.endReadParams();
    std::optional<StringSeqSeq> iceP_outSeq;
    std::optional<StringSeqSeq> ret = this->opOptStringSeqSeq(iceP_inSeq, iceP_outSeq, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(1, ret);
    ostr->write(3, iceP_outSeq);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opOptByteBufferSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    std::optional<ByteBuffer> iceP_inSeq;
    istr->read(2, iceP_inSeq);
    inS.endReadParams();
    std::optional<ByteBuffer> iceP_outSeq;
    std::optional<ByteBuffer> ret = this->opOptByteBufferSeq(iceP_inSeq, iceP_outSeq, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(1, ret);
    ostr->write(3, iceP_outSeq);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opOptShortBufferSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    std::optional<ShortBuffer> iceP_inSeq;
    istr->read(2, iceP_inSeq);
    inS.endReadParams();
    std::optional<ShortBuffer> iceP_outSeq;
    std::optional<ShortBuffer> ret = this->opOptShortBufferSeq(iceP_inSeq, iceP_outSeq, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(1, ret);
    ostr->write(3, iceP_outSeq);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opOptIntBufferSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    std::optional<IntBuffer> iceP_inSeq;
    istr->read(2, iceP_inSeq);
    inS.endReadParams();
    std::optional<IntBuffer> iceP_outSeq;
    std::optional<IntBuffer> ret = this->opOptIntBufferSeq(iceP_inSeq, iceP_outSeq, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(1, ret);
    ostr->write(3, iceP_outSeq);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opOptLongBufferSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    std::optional<LongBuffer> iceP_inSeq;
    istr->read(2, iceP_inSeq);
    inS.endReadParams();
    std::optional<LongBuffer> iceP_outSeq;
    std::optional<LongBuffer> ret = this->opOptLongBufferSeq(iceP_inSeq, iceP_outSeq, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(1, ret);
    ostr->write(3, iceP_outSeq);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opOptFloatBufferSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    std::optional<FloatBuffer> iceP_inSeq;
    istr->read(2, iceP_inSeq);
    inS.endReadParams();
    std::optional<FloatBuffer> iceP_outSeq;
    std::optional<FloatBuffer> ret = this->opOptFloatBufferSeq(iceP_inSeq, iceP_outSeq, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(1, ret);
    ostr->write(3, iceP_outSeq);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opOptDoubleBufferSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    std::optional<DoubleBuffer> iceP_inSeq;
    istr->read(2, iceP_inSeq);
    inS.endReadParams();
    std::optional<DoubleBuffer> iceP_outSeq;
    std::optional<DoubleBuffer> ret = this->opOptDoubleBufferSeq(iceP_inSeq, iceP_outSeq, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(1, ret);
    ostr->write(3, iceP_outSeq);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_shutdown(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    this->shutdown(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

namespace
{
const ::std::string iceC_Test_TestIntf_all[] =
{
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "opBoolSeq",
    "opByteBufferSeq",
    "opByteSeq",
    "opCArray",
    "opCList",
    "opCSeq",
    "opDSeq",
    "opDoubleBufferSeq",
    "opDoubleSeq",
    "opESeq",
    "opFloatBufferSeq",
    "opFloatSeq",
    "opIntBufferSeq",
    "opIntSeq",
    "opLongBufferSeq",
    "opLongSeq",
    "opOptBoolSeq",
    "opOptByteBufferSeq",
    "opOptByteSeq",
    "opOptCArray",
    "opOptCList",
    "opOptCSeq",
    "opOptDSeq",
    "opOptDoubleBufferSeq",
    "opOptDoubleSeq",
    "opOptESeq",
    "opOptFloatBufferSeq",
    "opOptFloatSeq",
    "opOptIntBufferSeq",
    "opOptIntSeq",
    "opOptLongBufferSeq",
    "opOptLongSeq",
    "opOptSSeq",
    "opOptShortBufferSeq",
    "opOptShortSeq",
    "opOptStringSeq",
    "opOptStringSeqSeq",
    "opSSeq",
    "opShortBufferSeq",
    "opShortSeq",
    "opStringSeq",
    "opStringSeqSeq",
    "shutdown"
};

}

/// \cond INTERNAL
bool
Test::TestIntf::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_Test_TestIntf_all, iceC_Test_TestIntf_all + 47, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_Test_TestIntf_all)
    {
        case 0:
        {
            return _iceD_ice_id(in, current);
        }
        case 1:
        {
            return _iceD_ice_ids(in, current);
        }
        case 2:
        {
            return _iceD_ice_isA(in, current);
        }
        case 3:
        {
            return _iceD_ice_ping(in, current);
        }
        case 4:
        {
            return _iceD_opBoolSeq(in, current);
        }
        case 5:
        {
            return _iceD_opByteBufferSeq(in, current);
        }
        case 6:
        {
            return _iceD_opByteSeq(in, current);
        }
        case 7:
        {
            return _iceD_opCArray(in, current);
        }
        case 8:
        {
            return _iceD_opCList(in, current);
        }
        case 9:
        {
            return _iceD_opCSeq(in, current);
        }
        case 10:
        {
            return _iceD_opDSeq(in, current);
        }
        case 11:
        {
            return _iceD_opDoubleBufferSeq(in, current);
        }
        case 12:
        {
            return _iceD_opDoubleSeq(in, current);
        }
        case 13:
        {
            return _iceD_opESeq(in, current);
        }
        case 14:
        {
            return _iceD_opFloatBufferSeq(in, current);
        }
        case 15:
        {
            return _iceD_opFloatSeq(in, current);
        }
        case 16:
        {
            return _iceD_opIntBufferSeq(in, current);
        }
        case 17:
        {
            return _iceD_opIntSeq(in, current);
        }
        case 18:
        {
            return _iceD_opLongBufferSeq(in, current);
        }
        case 19:
        {
            return _iceD_opLongSeq(in, current);
        }
        case 20:
        {
            return _iceD_opOptBoolSeq(in, current);
        }
        case 21:
        {
            return _iceD_opOptByteBufferSeq(in, current);
        }
        case 22:
        {
            return _iceD_opOptByteSeq(in, current);
        }
        case 23:
        {
            return _iceD_opOptCArray(in, current);
        }
        case 24:
        {
            return _iceD_opOptCList(in, current);
        }
        case 25:
        {
            return _iceD_opOptCSeq(in, current);
        }
        case 26:
        {
            return _iceD_opOptDSeq(in, current);
        }
        case 27:
        {
            return _iceD_opOptDoubleBufferSeq(in, current);
        }
        case 28:
        {
            return _iceD_opOptDoubleSeq(in, current);
        }
        case 29:
        {
            return _iceD_opOptESeq(in, current);
        }
        case 30:
        {
            return _iceD_opOptFloatBufferSeq(in, current);
        }
        case 31:
        {
            return _iceD_opOptFloatSeq(in, current);
        }
        case 32:
        {
            return _iceD_opOptIntBufferSeq(in, current);
        }
        case 33:
        {
            return _iceD_opOptIntSeq(in, current);
        }
        case 34:
        {
            return _iceD_opOptLongBufferSeq(in, current);
        }
        case 35:
        {
            return _iceD_opOptLongSeq(in, current);
        }
        case 36:
        {
            return _iceD_opOptSSeq(in, current);
        }
        case 37:
        {
            return _iceD_opOptShortBufferSeq(in, current);
        }
        case 38:
        {
            return _iceD_opOptShortSeq(in, current);
        }
        case 39:
        {
            return _iceD_opOptStringSeq(in, current);
        }
        case 40:
        {
            return _iceD_opOptStringSeqSeq(in, current);
        }
        case 41:
        {
            return _iceD_opSSeq(in, current);
        }
        case 42:
        {
            return _iceD_opShortBufferSeq(in, current);
        }
        case 43:
        {
            return _iceD_opShortSeq(in, current);
        }
        case 44:
        {
            return _iceD_opStringSeq(in, current);
        }
        case 45:
        {
            return _iceD_opStringSeqSeq(in, current);
        }
        case 46:
        {
            return _iceD_shutdown(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

/// \cond STREAM
void
Test::TestIntf::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< TestIntf, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Test::TestIntf::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< TestIntf, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

/// \cond INTERNAL
void
Test::_icePatchObjectPtr(TestIntfPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = TestIntfPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(TestIntf::ice_staticId(), v);
    }
}
/// \endcond

namespace Ice
{
}

#endif
