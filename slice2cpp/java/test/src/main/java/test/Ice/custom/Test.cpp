//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.8.0-alpha.0
//
// <auto-generated>
//
// Generated from file `Test.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#define ICE_BUILDING_GENERATED_CODE
#include <Test.h>
#include <IceUtil/PushDisableWarnings.h>
#include <IceUtil/PopDisableWarnings.h>

#if defined(_MSC_VER)
#   pragma warning(disable:4458) // declaration of ... hides class member
#elif defined(__clang__)
#   pragma clang diagnostic ignored "-Wshadow"
#elif defined(__GNUC__)
#   pragma GCC diagnostic ignored "-Wshadow"
#endif

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION  != 30850
#       error Ice version mismatch: an exact match is required for beta generated code
#   endif
#endif

namespace
{

const ::IceInternal::DefaultValueFactoryInit<::Test::C> iceC_Test_C_init("::Test::C");

const ::std::string iceC_Test_TestIntf_ids[2] =
{
    "::Ice::Object",
    "::Test::TestIntf"
};
const ::std::string iceC_Test_TestIntf_ops[] =
{
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "opBoolSeq",
    "opByteBufferSeq",
    "opByteSeq",
    "opCArray",
    "opCList",
    "opCSeq",
    "opDSeq",
    "opDoubleBufferSeq",
    "opDoubleSeq",
    "opESeq",
    "opFloatBufferSeq",
    "opFloatSeq",
    "opIntBufferSeq",
    "opIntSeq",
    "opLongBufferSeq",
    "opLongSeq",
    "opOptBoolSeq",
    "opOptByteBufferSeq",
    "opOptByteSeq",
    "opOptCArray",
    "opOptCList",
    "opOptCSeq",
    "opOptDSeq",
    "opOptDoubleBufferSeq",
    "opOptDoubleSeq",
    "opOptESeq",
    "opOptFloatBufferSeq",
    "opOptFloatSeq",
    "opOptIntBufferSeq",
    "opOptIntSeq",
    "opOptLongBufferSeq",
    "opOptLongSeq",
    "opOptSSeq",
    "opOptShortBufferSeq",
    "opOptShortSeq",
    "opOptStringSeq",
    "opOptStringSeqSeq",
    "opSSeq",
    "opShortBufferSeq",
    "opShortSeq",
    "opStringSeq",
    "opStringSeqSeq",
    "shutdown"
};
const ::std::string iceC_Test_TestIntf_opCSeq_name = "opCSeq";
const ::std::string iceC_Test_TestIntf_opCArray_name = "opCArray";
const ::std::string iceC_Test_TestIntf_opCList_name = "opCList";
const ::std::string iceC_Test_TestIntf_opBoolSeq_name = "opBoolSeq";
const ::std::string iceC_Test_TestIntf_opByteSeq_name = "opByteSeq";
const ::std::string iceC_Test_TestIntf_opShortSeq_name = "opShortSeq";
const ::std::string iceC_Test_TestIntf_opIntSeq_name = "opIntSeq";
const ::std::string iceC_Test_TestIntf_opLongSeq_name = "opLongSeq";
const ::std::string iceC_Test_TestIntf_opFloatSeq_name = "opFloatSeq";
const ::std::string iceC_Test_TestIntf_opDoubleSeq_name = "opDoubleSeq";
const ::std::string iceC_Test_TestIntf_opStringSeq_name = "opStringSeq";
const ::std::string iceC_Test_TestIntf_opESeq_name = "opESeq";
const ::std::string iceC_Test_TestIntf_opSSeq_name = "opSSeq";
const ::std::string iceC_Test_TestIntf_opDSeq_name = "opDSeq";
const ::std::string iceC_Test_TestIntf_opStringSeqSeq_name = "opStringSeqSeq";
const ::std::string iceC_Test_TestIntf_opByteBufferSeq_name = "opByteBufferSeq";
const ::std::string iceC_Test_TestIntf_opShortBufferSeq_name = "opShortBufferSeq";
const ::std::string iceC_Test_TestIntf_opIntBufferSeq_name = "opIntBufferSeq";
const ::std::string iceC_Test_TestIntf_opLongBufferSeq_name = "opLongBufferSeq";
const ::std::string iceC_Test_TestIntf_opFloatBufferSeq_name = "opFloatBufferSeq";
const ::std::string iceC_Test_TestIntf_opDoubleBufferSeq_name = "opDoubleBufferSeq";
const ::std::string iceC_Test_TestIntf_opOptCSeq_name = "opOptCSeq";
const ::std::string iceC_Test_TestIntf_opOptCArray_name = "opOptCArray";
const ::std::string iceC_Test_TestIntf_opOptCList_name = "opOptCList";
const ::std::string iceC_Test_TestIntf_opOptBoolSeq_name = "opOptBoolSeq";
const ::std::string iceC_Test_TestIntf_opOptByteSeq_name = "opOptByteSeq";
const ::std::string iceC_Test_TestIntf_opOptShortSeq_name = "opOptShortSeq";
const ::std::string iceC_Test_TestIntf_opOptIntSeq_name = "opOptIntSeq";
const ::std::string iceC_Test_TestIntf_opOptLongSeq_name = "opOptLongSeq";
const ::std::string iceC_Test_TestIntf_opOptFloatSeq_name = "opOptFloatSeq";
const ::std::string iceC_Test_TestIntf_opOptDoubleSeq_name = "opOptDoubleSeq";
const ::std::string iceC_Test_TestIntf_opOptStringSeq_name = "opOptStringSeq";
const ::std::string iceC_Test_TestIntf_opOptESeq_name = "opOptESeq";
const ::std::string iceC_Test_TestIntf_opOptSSeq_name = "opOptSSeq";
const ::std::string iceC_Test_TestIntf_opOptDSeq_name = "opOptDSeq";
const ::std::string iceC_Test_TestIntf_opOptStringSeqSeq_name = "opOptStringSeqSeq";
const ::std::string iceC_Test_TestIntf_opOptByteBufferSeq_name = "opOptByteBufferSeq";
const ::std::string iceC_Test_TestIntf_opOptShortBufferSeq_name = "opOptShortBufferSeq";
const ::std::string iceC_Test_TestIntf_opOptIntBufferSeq_name = "opOptIntBufferSeq";
const ::std::string iceC_Test_TestIntf_opOptLongBufferSeq_name = "opOptLongBufferSeq";
const ::std::string iceC_Test_TestIntf_opOptFloatBufferSeq_name = "opOptFloatBufferSeq";
const ::std::string iceC_Test_TestIntf_opOptDoubleBufferSeq_name = "opOptDoubleBufferSeq";
const ::std::string iceC_Test_TestIntf_shutdown_name = "shutdown";

}

::Test::CSeq
Test::TestIntfPrx::opCSeq(const CSeq& iceP_inSeq, CSeq& iceP_outSeq, const ::Ice::Context& context) const
{
    auto _result = _makePromiseOutgoing<::std::tuple<CSeq, CSeq>>(true, this, &TestIntfPrx::_iceI_opCSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::CSeq, ::Test::CSeq>>
Test::TestIntfPrx::opCSeqAsync(const CSeq& iceP_inSeq, const ::Ice::Context& context) const
{
    return _makePromiseOutgoing<::std::tuple<CSeq, CSeq>, ::std::promise>(false, this, &TestIntfPrx::_iceI_opCSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opCSeqAsync(const CSeq& iceP_inSeq,
                               ::std::function<void (::Test::CSeq, ::Test::CSeq)> response,
                               ::std::function<void(::std::exception_ptr)> ex,
                               ::std::function<void(bool)> sent,
                               const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<CSeq, CSeq>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return _makeLambdaOutgoing<::std::tuple<CSeq, CSeq>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opCSeq, iceP_inSeq, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opCSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<CSeq, CSeq>>>& outAsync, const CSeq& iceP_inSeq, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_TestIntf_opCSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opCSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
            ostr->writePendingValues();
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<CSeq, CSeq> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            istr->readPendingValues();
            return v;
        });
}
/// \endcond

::Test::CArray
Test::TestIntfPrx::opCArray(const CArray& iceP_inSeq, CArray& iceP_outSeq, const ::Ice::Context& context) const
{
    auto _result = _makePromiseOutgoing<::std::tuple<CArray, CArray>>(true, this, &TestIntfPrx::_iceI_opCArray, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::CArray, ::Test::CArray>>
Test::TestIntfPrx::opCArrayAsync(const CArray& iceP_inSeq, const ::Ice::Context& context) const
{
    return _makePromiseOutgoing<::std::tuple<CArray, CArray>, ::std::promise>(false, this, &TestIntfPrx::_iceI_opCArray, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opCArrayAsync(const CArray& iceP_inSeq,
                                 ::std::function<void (::Test::CArray, ::Test::CArray)> response,
                                 ::std::function<void(::std::exception_ptr)> ex,
                                 ::std::function<void(bool)> sent,
                                 const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<CArray, CArray>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return _makeLambdaOutgoing<::std::tuple<CArray, CArray>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opCArray, iceP_inSeq, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opCArray(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<CArray, CArray>>>& outAsync, const CArray& iceP_inSeq, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_TestIntf_opCArray_name);
    outAsync->invoke(iceC_Test_TestIntf_opCArray_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
            ostr->writePendingValues();
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<CArray, CArray> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            istr->readPendingValues();
            return v;
        });
}
/// \endcond

::Test::CList
Test::TestIntfPrx::opCList(const CList& iceP_inSeq, CList& iceP_outSeq, const ::Ice::Context& context) const
{
    auto _result = _makePromiseOutgoing<::std::tuple<CList, CList>>(true, this, &TestIntfPrx::_iceI_opCList, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::CList, ::Test::CList>>
Test::TestIntfPrx::opCListAsync(const CList& iceP_inSeq, const ::Ice::Context& context) const
{
    return _makePromiseOutgoing<::std::tuple<CList, CList>, ::std::promise>(false, this, &TestIntfPrx::_iceI_opCList, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opCListAsync(const CList& iceP_inSeq,
                                ::std::function<void (::Test::CList, ::Test::CList)> response,
                                ::std::function<void(::std::exception_ptr)> ex,
                                ::std::function<void(bool)> sent,
                                const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<CList, CList>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return _makeLambdaOutgoing<::std::tuple<CList, CList>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opCList, iceP_inSeq, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opCList(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<CList, CList>>>& outAsync, const CList& iceP_inSeq, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_TestIntf_opCList_name);
    outAsync->invoke(iceC_Test_TestIntf_opCList_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
            ostr->writePendingValues();
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<CList, CList> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            istr->readPendingValues();
            return v;
        });
}
/// \endcond

::Test::BoolSeq
Test::TestIntfPrx::opBoolSeq(const BoolSeq& iceP_inSeq, BoolSeq& iceP_outSeq, const ::Ice::Context& context) const
{
    auto _result = _makePromiseOutgoing<::std::tuple<BoolSeq, BoolSeq>>(true, this, &TestIntfPrx::_iceI_opBoolSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::BoolSeq, ::Test::BoolSeq>>
Test::TestIntfPrx::opBoolSeqAsync(const BoolSeq& iceP_inSeq, const ::Ice::Context& context) const
{
    return _makePromiseOutgoing<::std::tuple<BoolSeq, BoolSeq>, ::std::promise>(false, this, &TestIntfPrx::_iceI_opBoolSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opBoolSeqAsync(const BoolSeq& iceP_inSeq,
                                  ::std::function<void (::Test::BoolSeq, ::Test::BoolSeq)> response,
                                  ::std::function<void(::std::exception_ptr)> ex,
                                  ::std::function<void(bool)> sent,
                                  const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<BoolSeq, BoolSeq>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return _makeLambdaOutgoing<::std::tuple<BoolSeq, BoolSeq>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opBoolSeq, iceP_inSeq, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opBoolSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<BoolSeq, BoolSeq>>>& outAsync, const BoolSeq& iceP_inSeq, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_TestIntf_opBoolSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opBoolSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<BoolSeq, BoolSeq> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::ByteSeq
Test::TestIntfPrx::opByteSeq(const ByteSeq& iceP_inSeq, ByteSeq& iceP_outSeq, const ::Ice::Context& context) const
{
    auto _result = _makePromiseOutgoing<::std::tuple<ByteSeq, ByteSeq>>(true, this, &TestIntfPrx::_iceI_opByteSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::ByteSeq, ::Test::ByteSeq>>
Test::TestIntfPrx::opByteSeqAsync(const ByteSeq& iceP_inSeq, const ::Ice::Context& context) const
{
    return _makePromiseOutgoing<::std::tuple<ByteSeq, ByteSeq>, ::std::promise>(false, this, &TestIntfPrx::_iceI_opByteSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opByteSeqAsync(const ByteSeq& iceP_inSeq,
                                  ::std::function<void (::Test::ByteSeq, ::Test::ByteSeq)> response,
                                  ::std::function<void(::std::exception_ptr)> ex,
                                  ::std::function<void(bool)> sent,
                                  const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<ByteSeq, ByteSeq>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return _makeLambdaOutgoing<::std::tuple<ByteSeq, ByteSeq>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opByteSeq, iceP_inSeq, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opByteSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<ByteSeq, ByteSeq>>>& outAsync, const ByteSeq& iceP_inSeq, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_TestIntf_opByteSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opByteSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<ByteSeq, ByteSeq> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::ShortSeq
Test::TestIntfPrx::opShortSeq(const ShortSeq& iceP_inSeq, ShortSeq& iceP_outSeq, const ::Ice::Context& context) const
{
    auto _result = _makePromiseOutgoing<::std::tuple<ShortSeq, ShortSeq>>(true, this, &TestIntfPrx::_iceI_opShortSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::ShortSeq, ::Test::ShortSeq>>
Test::TestIntfPrx::opShortSeqAsync(const ShortSeq& iceP_inSeq, const ::Ice::Context& context) const
{
    return _makePromiseOutgoing<::std::tuple<ShortSeq, ShortSeq>, ::std::promise>(false, this, &TestIntfPrx::_iceI_opShortSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opShortSeqAsync(const ShortSeq& iceP_inSeq,
                                   ::std::function<void (::Test::ShortSeq, ::Test::ShortSeq)> response,
                                   ::std::function<void(::std::exception_ptr)> ex,
                                   ::std::function<void(bool)> sent,
                                   const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<ShortSeq, ShortSeq>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return _makeLambdaOutgoing<::std::tuple<ShortSeq, ShortSeq>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opShortSeq, iceP_inSeq, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opShortSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<ShortSeq, ShortSeq>>>& outAsync, const ShortSeq& iceP_inSeq, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_TestIntf_opShortSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opShortSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<ShortSeq, ShortSeq> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::IntSeq
Test::TestIntfPrx::opIntSeq(const IntSeq& iceP_inSeq, IntSeq& iceP_outSeq, const ::Ice::Context& context) const
{
    auto _result = _makePromiseOutgoing<::std::tuple<IntSeq, IntSeq>>(true, this, &TestIntfPrx::_iceI_opIntSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::IntSeq, ::Test::IntSeq>>
Test::TestIntfPrx::opIntSeqAsync(const IntSeq& iceP_inSeq, const ::Ice::Context& context) const
{
    return _makePromiseOutgoing<::std::tuple<IntSeq, IntSeq>, ::std::promise>(false, this, &TestIntfPrx::_iceI_opIntSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opIntSeqAsync(const IntSeq& iceP_inSeq,
                                 ::std::function<void (::Test::IntSeq, ::Test::IntSeq)> response,
                                 ::std::function<void(::std::exception_ptr)> ex,
                                 ::std::function<void(bool)> sent,
                                 const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<IntSeq, IntSeq>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return _makeLambdaOutgoing<::std::tuple<IntSeq, IntSeq>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opIntSeq, iceP_inSeq, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opIntSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<IntSeq, IntSeq>>>& outAsync, const IntSeq& iceP_inSeq, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_TestIntf_opIntSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opIntSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<IntSeq, IntSeq> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::LongSeq
Test::TestIntfPrx::opLongSeq(const LongSeq& iceP_inSeq, LongSeq& iceP_outSeq, const ::Ice::Context& context) const
{
    auto _result = _makePromiseOutgoing<::std::tuple<LongSeq, LongSeq>>(true, this, &TestIntfPrx::_iceI_opLongSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::LongSeq, ::Test::LongSeq>>
Test::TestIntfPrx::opLongSeqAsync(const LongSeq& iceP_inSeq, const ::Ice::Context& context) const
{
    return _makePromiseOutgoing<::std::tuple<LongSeq, LongSeq>, ::std::promise>(false, this, &TestIntfPrx::_iceI_opLongSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opLongSeqAsync(const LongSeq& iceP_inSeq,
                                  ::std::function<void (::Test::LongSeq, ::Test::LongSeq)> response,
                                  ::std::function<void(::std::exception_ptr)> ex,
                                  ::std::function<void(bool)> sent,
                                  const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<LongSeq, LongSeq>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return _makeLambdaOutgoing<::std::tuple<LongSeq, LongSeq>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opLongSeq, iceP_inSeq, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opLongSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<LongSeq, LongSeq>>>& outAsync, const LongSeq& iceP_inSeq, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_TestIntf_opLongSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opLongSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<LongSeq, LongSeq> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::FloatSeq
Test::TestIntfPrx::opFloatSeq(const FloatSeq& iceP_inSeq, FloatSeq& iceP_outSeq, const ::Ice::Context& context) const
{
    auto _result = _makePromiseOutgoing<::std::tuple<FloatSeq, FloatSeq>>(true, this, &TestIntfPrx::_iceI_opFloatSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::FloatSeq, ::Test::FloatSeq>>
Test::TestIntfPrx::opFloatSeqAsync(const FloatSeq& iceP_inSeq, const ::Ice::Context& context) const
{
    return _makePromiseOutgoing<::std::tuple<FloatSeq, FloatSeq>, ::std::promise>(false, this, &TestIntfPrx::_iceI_opFloatSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opFloatSeqAsync(const FloatSeq& iceP_inSeq,
                                   ::std::function<void (::Test::FloatSeq, ::Test::FloatSeq)> response,
                                   ::std::function<void(::std::exception_ptr)> ex,
                                   ::std::function<void(bool)> sent,
                                   const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<FloatSeq, FloatSeq>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return _makeLambdaOutgoing<::std::tuple<FloatSeq, FloatSeq>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opFloatSeq, iceP_inSeq, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opFloatSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<FloatSeq, FloatSeq>>>& outAsync, const FloatSeq& iceP_inSeq, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_TestIntf_opFloatSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opFloatSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<FloatSeq, FloatSeq> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::DoubleSeq
Test::TestIntfPrx::opDoubleSeq(const DoubleSeq& iceP_inSeq, DoubleSeq& iceP_outSeq, const ::Ice::Context& context) const
{
    auto _result = _makePromiseOutgoing<::std::tuple<DoubleSeq, DoubleSeq>>(true, this, &TestIntfPrx::_iceI_opDoubleSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::DoubleSeq, ::Test::DoubleSeq>>
Test::TestIntfPrx::opDoubleSeqAsync(const DoubleSeq& iceP_inSeq, const ::Ice::Context& context) const
{
    return _makePromiseOutgoing<::std::tuple<DoubleSeq, DoubleSeq>, ::std::promise>(false, this, &TestIntfPrx::_iceI_opDoubleSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opDoubleSeqAsync(const DoubleSeq& iceP_inSeq,
                                    ::std::function<void (::Test::DoubleSeq, ::Test::DoubleSeq)> response,
                                    ::std::function<void(::std::exception_ptr)> ex,
                                    ::std::function<void(bool)> sent,
                                    const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<DoubleSeq, DoubleSeq>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return _makeLambdaOutgoing<::std::tuple<DoubleSeq, DoubleSeq>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opDoubleSeq, iceP_inSeq, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opDoubleSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<DoubleSeq, DoubleSeq>>>& outAsync, const DoubleSeq& iceP_inSeq, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_TestIntf_opDoubleSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opDoubleSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<DoubleSeq, DoubleSeq> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::StringSeq
Test::TestIntfPrx::opStringSeq(const StringSeq& iceP_inSeq, StringSeq& iceP_outSeq, const ::Ice::Context& context) const
{
    auto _result = _makePromiseOutgoing<::std::tuple<StringSeq, StringSeq>>(true, this, &TestIntfPrx::_iceI_opStringSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::StringSeq, ::Test::StringSeq>>
Test::TestIntfPrx::opStringSeqAsync(const StringSeq& iceP_inSeq, const ::Ice::Context& context) const
{
    return _makePromiseOutgoing<::std::tuple<StringSeq, StringSeq>, ::std::promise>(false, this, &TestIntfPrx::_iceI_opStringSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opStringSeqAsync(const StringSeq& iceP_inSeq,
                                    ::std::function<void (::Test::StringSeq, ::Test::StringSeq)> response,
                                    ::std::function<void(::std::exception_ptr)> ex,
                                    ::std::function<void(bool)> sent,
                                    const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<StringSeq, StringSeq>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return _makeLambdaOutgoing<::std::tuple<StringSeq, StringSeq>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opStringSeq, iceP_inSeq, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opStringSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<StringSeq, StringSeq>>>& outAsync, const StringSeq& iceP_inSeq, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_TestIntf_opStringSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opStringSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<StringSeq, StringSeq> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::ESeq
Test::TestIntfPrx::opESeq(const ESeq& iceP_inSeq, ESeq& iceP_outSeq, const ::Ice::Context& context) const
{
    auto _result = _makePromiseOutgoing<::std::tuple<ESeq, ESeq>>(true, this, &TestIntfPrx::_iceI_opESeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::ESeq, ::Test::ESeq>>
Test::TestIntfPrx::opESeqAsync(const ESeq& iceP_inSeq, const ::Ice::Context& context) const
{
    return _makePromiseOutgoing<::std::tuple<ESeq, ESeq>, ::std::promise>(false, this, &TestIntfPrx::_iceI_opESeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opESeqAsync(const ESeq& iceP_inSeq,
                               ::std::function<void (::Test::ESeq, ::Test::ESeq)> response,
                               ::std::function<void(::std::exception_ptr)> ex,
                               ::std::function<void(bool)> sent,
                               const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<ESeq, ESeq>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return _makeLambdaOutgoing<::std::tuple<ESeq, ESeq>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opESeq, iceP_inSeq, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opESeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<ESeq, ESeq>>>& outAsync, const ESeq& iceP_inSeq, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_TestIntf_opESeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opESeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<ESeq, ESeq> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::SSeq
Test::TestIntfPrx::opSSeq(const SSeq& iceP_inSeq, SSeq& iceP_outSeq, const ::Ice::Context& context) const
{
    auto _result = _makePromiseOutgoing<::std::tuple<SSeq, SSeq>>(true, this, &TestIntfPrx::_iceI_opSSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::SSeq, ::Test::SSeq>>
Test::TestIntfPrx::opSSeqAsync(const SSeq& iceP_inSeq, const ::Ice::Context& context) const
{
    return _makePromiseOutgoing<::std::tuple<SSeq, SSeq>, ::std::promise>(false, this, &TestIntfPrx::_iceI_opSSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opSSeqAsync(const SSeq& iceP_inSeq,
                               ::std::function<void (::Test::SSeq, ::Test::SSeq)> response,
                               ::std::function<void(::std::exception_ptr)> ex,
                               ::std::function<void(bool)> sent,
                               const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<SSeq, SSeq>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return _makeLambdaOutgoing<::std::tuple<SSeq, SSeq>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opSSeq, iceP_inSeq, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opSSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<SSeq, SSeq>>>& outAsync, const SSeq& iceP_inSeq, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_TestIntf_opSSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opSSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<SSeq, SSeq> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::DSeq
Test::TestIntfPrx::opDSeq(const DSeq& iceP_inSeq, DSeq& iceP_outSeq, const ::Ice::Context& context) const
{
    auto _result = _makePromiseOutgoing<::std::tuple<DSeq, DSeq>>(true, this, &TestIntfPrx::_iceI_opDSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::DSeq, ::Test::DSeq>>
Test::TestIntfPrx::opDSeqAsync(const DSeq& iceP_inSeq, const ::Ice::Context& context) const
{
    return _makePromiseOutgoing<::std::tuple<DSeq, DSeq>, ::std::promise>(false, this, &TestIntfPrx::_iceI_opDSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opDSeqAsync(const DSeq& iceP_inSeq,
                               ::std::function<void (::Test::DSeq, ::Test::DSeq)> response,
                               ::std::function<void(::std::exception_ptr)> ex,
                               ::std::function<void(bool)> sent,
                               const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<DSeq, DSeq>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return _makeLambdaOutgoing<::std::tuple<DSeq, DSeq>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opDSeq, iceP_inSeq, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opDSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<DSeq, DSeq>>>& outAsync, const DSeq& iceP_inSeq, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_TestIntf_opDSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opDSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<DSeq, DSeq> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::StringSeqSeq
Test::TestIntfPrx::opStringSeqSeq(const StringSeqSeq& iceP_inSeq, StringSeqSeq& iceP_outSeq, const ::Ice::Context& context) const
{
    auto _result = _makePromiseOutgoing<::std::tuple<StringSeqSeq, StringSeqSeq>>(true, this, &TestIntfPrx::_iceI_opStringSeqSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::StringSeqSeq, ::Test::StringSeqSeq>>
Test::TestIntfPrx::opStringSeqSeqAsync(const StringSeqSeq& iceP_inSeq, const ::Ice::Context& context) const
{
    return _makePromiseOutgoing<::std::tuple<StringSeqSeq, StringSeqSeq>, ::std::promise>(false, this, &TestIntfPrx::_iceI_opStringSeqSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opStringSeqSeqAsync(const StringSeqSeq& iceP_inSeq,
                                       ::std::function<void (::Test::StringSeqSeq, ::Test::StringSeqSeq)> response,
                                       ::std::function<void(::std::exception_ptr)> ex,
                                       ::std::function<void(bool)> sent,
                                       const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<StringSeqSeq, StringSeqSeq>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return _makeLambdaOutgoing<::std::tuple<StringSeqSeq, StringSeqSeq>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opStringSeqSeq, iceP_inSeq, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opStringSeqSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<StringSeqSeq, StringSeqSeq>>>& outAsync, const StringSeqSeq& iceP_inSeq, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_TestIntf_opStringSeqSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opStringSeqSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<StringSeqSeq, StringSeqSeq> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::ByteBuffer
Test::TestIntfPrx::opByteBufferSeq(const ByteBuffer& iceP_inSeq, ByteBuffer& iceP_outSeq, const ::Ice::Context& context) const
{
    auto _result = _makePromiseOutgoing<::std::tuple<ByteBuffer, ByteBuffer>>(true, this, &TestIntfPrx::_iceI_opByteBufferSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::ByteBuffer, ::Test::ByteBuffer>>
Test::TestIntfPrx::opByteBufferSeqAsync(const ByteBuffer& iceP_inSeq, const ::Ice::Context& context) const
{
    return _makePromiseOutgoing<::std::tuple<ByteBuffer, ByteBuffer>, ::std::promise>(false, this, &TestIntfPrx::_iceI_opByteBufferSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opByteBufferSeqAsync(const ByteBuffer& iceP_inSeq,
                                        ::std::function<void (::Test::ByteBuffer, ::Test::ByteBuffer)> response,
                                        ::std::function<void(::std::exception_ptr)> ex,
                                        ::std::function<void(bool)> sent,
                                        const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<ByteBuffer, ByteBuffer>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return _makeLambdaOutgoing<::std::tuple<ByteBuffer, ByteBuffer>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opByteBufferSeq, iceP_inSeq, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opByteBufferSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<ByteBuffer, ByteBuffer>>>& outAsync, const ByteBuffer& iceP_inSeq, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_TestIntf_opByteBufferSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opByteBufferSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<ByteBuffer, ByteBuffer> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::ShortBuffer
Test::TestIntfPrx::opShortBufferSeq(const ShortBuffer& iceP_inSeq, ShortBuffer& iceP_outSeq, const ::Ice::Context& context) const
{
    auto _result = _makePromiseOutgoing<::std::tuple<ShortBuffer, ShortBuffer>>(true, this, &TestIntfPrx::_iceI_opShortBufferSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::ShortBuffer, ::Test::ShortBuffer>>
Test::TestIntfPrx::opShortBufferSeqAsync(const ShortBuffer& iceP_inSeq, const ::Ice::Context& context) const
{
    return _makePromiseOutgoing<::std::tuple<ShortBuffer, ShortBuffer>, ::std::promise>(false, this, &TestIntfPrx::_iceI_opShortBufferSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opShortBufferSeqAsync(const ShortBuffer& iceP_inSeq,
                                         ::std::function<void (::Test::ShortBuffer, ::Test::ShortBuffer)> response,
                                         ::std::function<void(::std::exception_ptr)> ex,
                                         ::std::function<void(bool)> sent,
                                         const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<ShortBuffer, ShortBuffer>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return _makeLambdaOutgoing<::std::tuple<ShortBuffer, ShortBuffer>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opShortBufferSeq, iceP_inSeq, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opShortBufferSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<ShortBuffer, ShortBuffer>>>& outAsync, const ShortBuffer& iceP_inSeq, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_TestIntf_opShortBufferSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opShortBufferSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<ShortBuffer, ShortBuffer> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::IntBuffer
Test::TestIntfPrx::opIntBufferSeq(const IntBuffer& iceP_inSeq, IntBuffer& iceP_outSeq, const ::Ice::Context& context) const
{
    auto _result = _makePromiseOutgoing<::std::tuple<IntBuffer, IntBuffer>>(true, this, &TestIntfPrx::_iceI_opIntBufferSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::IntBuffer, ::Test::IntBuffer>>
Test::TestIntfPrx::opIntBufferSeqAsync(const IntBuffer& iceP_inSeq, const ::Ice::Context& context) const
{
    return _makePromiseOutgoing<::std::tuple<IntBuffer, IntBuffer>, ::std::promise>(false, this, &TestIntfPrx::_iceI_opIntBufferSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opIntBufferSeqAsync(const IntBuffer& iceP_inSeq,
                                       ::std::function<void (::Test::IntBuffer, ::Test::IntBuffer)> response,
                                       ::std::function<void(::std::exception_ptr)> ex,
                                       ::std::function<void(bool)> sent,
                                       const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<IntBuffer, IntBuffer>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return _makeLambdaOutgoing<::std::tuple<IntBuffer, IntBuffer>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opIntBufferSeq, iceP_inSeq, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opIntBufferSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<IntBuffer, IntBuffer>>>& outAsync, const IntBuffer& iceP_inSeq, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_TestIntf_opIntBufferSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opIntBufferSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<IntBuffer, IntBuffer> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::LongBuffer
Test::TestIntfPrx::opLongBufferSeq(const LongBuffer& iceP_inSeq, LongBuffer& iceP_outSeq, const ::Ice::Context& context) const
{
    auto _result = _makePromiseOutgoing<::std::tuple<LongBuffer, LongBuffer>>(true, this, &TestIntfPrx::_iceI_opLongBufferSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::LongBuffer, ::Test::LongBuffer>>
Test::TestIntfPrx::opLongBufferSeqAsync(const LongBuffer& iceP_inSeq, const ::Ice::Context& context) const
{
    return _makePromiseOutgoing<::std::tuple<LongBuffer, LongBuffer>, ::std::promise>(false, this, &TestIntfPrx::_iceI_opLongBufferSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opLongBufferSeqAsync(const LongBuffer& iceP_inSeq,
                                        ::std::function<void (::Test::LongBuffer, ::Test::LongBuffer)> response,
                                        ::std::function<void(::std::exception_ptr)> ex,
                                        ::std::function<void(bool)> sent,
                                        const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<LongBuffer, LongBuffer>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return _makeLambdaOutgoing<::std::tuple<LongBuffer, LongBuffer>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opLongBufferSeq, iceP_inSeq, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opLongBufferSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<LongBuffer, LongBuffer>>>& outAsync, const LongBuffer& iceP_inSeq, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_TestIntf_opLongBufferSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opLongBufferSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<LongBuffer, LongBuffer> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::FloatBuffer
Test::TestIntfPrx::opFloatBufferSeq(const FloatBuffer& iceP_inSeq, FloatBuffer& iceP_outSeq, const ::Ice::Context& context) const
{
    auto _result = _makePromiseOutgoing<::std::tuple<FloatBuffer, FloatBuffer>>(true, this, &TestIntfPrx::_iceI_opFloatBufferSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::FloatBuffer, ::Test::FloatBuffer>>
Test::TestIntfPrx::opFloatBufferSeqAsync(const FloatBuffer& iceP_inSeq, const ::Ice::Context& context) const
{
    return _makePromiseOutgoing<::std::tuple<FloatBuffer, FloatBuffer>, ::std::promise>(false, this, &TestIntfPrx::_iceI_opFloatBufferSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opFloatBufferSeqAsync(const FloatBuffer& iceP_inSeq,
                                         ::std::function<void (::Test::FloatBuffer, ::Test::FloatBuffer)> response,
                                         ::std::function<void(::std::exception_ptr)> ex,
                                         ::std::function<void(bool)> sent,
                                         const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<FloatBuffer, FloatBuffer>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return _makeLambdaOutgoing<::std::tuple<FloatBuffer, FloatBuffer>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opFloatBufferSeq, iceP_inSeq, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opFloatBufferSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<FloatBuffer, FloatBuffer>>>& outAsync, const FloatBuffer& iceP_inSeq, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_TestIntf_opFloatBufferSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opFloatBufferSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<FloatBuffer, FloatBuffer> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::DoubleBuffer
Test::TestIntfPrx::opDoubleBufferSeq(const DoubleBuffer& iceP_inSeq, DoubleBuffer& iceP_outSeq, const ::Ice::Context& context) const
{
    auto _result = _makePromiseOutgoing<::std::tuple<DoubleBuffer, DoubleBuffer>>(true, this, &TestIntfPrx::_iceI_opDoubleBufferSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::DoubleBuffer, ::Test::DoubleBuffer>>
Test::TestIntfPrx::opDoubleBufferSeqAsync(const DoubleBuffer& iceP_inSeq, const ::Ice::Context& context) const
{
    return _makePromiseOutgoing<::std::tuple<DoubleBuffer, DoubleBuffer>, ::std::promise>(false, this, &TestIntfPrx::_iceI_opDoubleBufferSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opDoubleBufferSeqAsync(const DoubleBuffer& iceP_inSeq,
                                          ::std::function<void (::Test::DoubleBuffer, ::Test::DoubleBuffer)> response,
                                          ::std::function<void(::std::exception_ptr)> ex,
                                          ::std::function<void(bool)> sent,
                                          const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<DoubleBuffer, DoubleBuffer>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return _makeLambdaOutgoing<::std::tuple<DoubleBuffer, DoubleBuffer>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opDoubleBufferSeq, iceP_inSeq, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opDoubleBufferSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<DoubleBuffer, DoubleBuffer>>>& outAsync, const DoubleBuffer& iceP_inSeq, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_TestIntf_opDoubleBufferSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opDoubleBufferSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<DoubleBuffer, DoubleBuffer> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

std::optional<::Test::CSeq>
Test::TestIntfPrx::opOptCSeq(const std::optional<CSeq>& iceP_inSeq, std::optional<CSeq>& iceP_outSeq, const ::Ice::Context& context) const
{
    auto _result = _makePromiseOutgoing<::std::tuple<std::optional<CSeq>, std::optional<CSeq>>>(true, this, &TestIntfPrx::_iceI_opOptCSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<std::optional<::Test::CSeq>, std::optional<::Test::CSeq>>>
Test::TestIntfPrx::opOptCSeqAsync(const std::optional<CSeq>& iceP_inSeq, const ::Ice::Context& context) const
{
    return _makePromiseOutgoing<::std::tuple<std::optional<CSeq>, std::optional<CSeq>>, ::std::promise>(false, this, &TestIntfPrx::_iceI_opOptCSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opOptCSeqAsync(const std::optional<CSeq>& iceP_inSeq,
                                  ::std::function<void (std::optional<::Test::CSeq>, std::optional<::Test::CSeq>)> response,
                                  ::std::function<void(::std::exception_ptr)> ex,
                                  ::std::function<void(bool)> sent,
                                  const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<std::optional<CSeq>, std::optional<CSeq>>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return _makeLambdaOutgoing<::std::tuple<std::optional<CSeq>, std::optional<CSeq>>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opOptCSeq, iceP_inSeq, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opOptCSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<std::optional<CSeq>, std::optional<CSeq>>>>& outAsync, const std::optional<CSeq>& iceP_inSeq, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_TestIntf_opOptCSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opOptCSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({2}, iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<std::optional<CSeq>, std::optional<CSeq>> v;
            istr->readAll({1, 3}, ::std::get<0>(v), ::std::get<1>(v));
            return v;
        });
}
/// \endcond

std::optional<::Test::CArray>
Test::TestIntfPrx::opOptCArray(const std::optional<CArray>& iceP_inSeq, std::optional<CArray>& iceP_outSeq, const ::Ice::Context& context) const
{
    auto _result = _makePromiseOutgoing<::std::tuple<std::optional<CArray>, std::optional<CArray>>>(true, this, &TestIntfPrx::_iceI_opOptCArray, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<std::optional<::Test::CArray>, std::optional<::Test::CArray>>>
Test::TestIntfPrx::opOptCArrayAsync(const std::optional<CArray>& iceP_inSeq, const ::Ice::Context& context) const
{
    return _makePromiseOutgoing<::std::tuple<std::optional<CArray>, std::optional<CArray>>, ::std::promise>(false, this, &TestIntfPrx::_iceI_opOptCArray, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opOptCArrayAsync(const std::optional<CArray>& iceP_inSeq,
                                    ::std::function<void (std::optional<::Test::CArray>, std::optional<::Test::CArray>)> response,
                                    ::std::function<void(::std::exception_ptr)> ex,
                                    ::std::function<void(bool)> sent,
                                    const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<std::optional<CArray>, std::optional<CArray>>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return _makeLambdaOutgoing<::std::tuple<std::optional<CArray>, std::optional<CArray>>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opOptCArray, iceP_inSeq, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opOptCArray(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<std::optional<CArray>, std::optional<CArray>>>>& outAsync, const std::optional<CArray>& iceP_inSeq, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_TestIntf_opOptCArray_name);
    outAsync->invoke(iceC_Test_TestIntf_opOptCArray_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({2}, iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<std::optional<CArray>, std::optional<CArray>> v;
            istr->readAll({1, 3}, ::std::get<0>(v), ::std::get<1>(v));
            return v;
        });
}
/// \endcond

std::optional<::Test::CList>
Test::TestIntfPrx::opOptCList(const std::optional<CList>& iceP_inSeq, std::optional<CList>& iceP_outSeq, const ::Ice::Context& context) const
{
    auto _result = _makePromiseOutgoing<::std::tuple<std::optional<CList>, std::optional<CList>>>(true, this, &TestIntfPrx::_iceI_opOptCList, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<std::optional<::Test::CList>, std::optional<::Test::CList>>>
Test::TestIntfPrx::opOptCListAsync(const std::optional<CList>& iceP_inSeq, const ::Ice::Context& context) const
{
    return _makePromiseOutgoing<::std::tuple<std::optional<CList>, std::optional<CList>>, ::std::promise>(false, this, &TestIntfPrx::_iceI_opOptCList, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opOptCListAsync(const std::optional<CList>& iceP_inSeq,
                                   ::std::function<void (std::optional<::Test::CList>, std::optional<::Test::CList>)> response,
                                   ::std::function<void(::std::exception_ptr)> ex,
                                   ::std::function<void(bool)> sent,
                                   const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<std::optional<CList>, std::optional<CList>>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return _makeLambdaOutgoing<::std::tuple<std::optional<CList>, std::optional<CList>>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opOptCList, iceP_inSeq, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opOptCList(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<std::optional<CList>, std::optional<CList>>>>& outAsync, const std::optional<CList>& iceP_inSeq, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_TestIntf_opOptCList_name);
    outAsync->invoke(iceC_Test_TestIntf_opOptCList_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({2}, iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<std::optional<CList>, std::optional<CList>> v;
            istr->readAll({1, 3}, ::std::get<0>(v), ::std::get<1>(v));
            return v;
        });
}
/// \endcond

std::optional<::Test::BoolSeq>
Test::TestIntfPrx::opOptBoolSeq(const std::optional<BoolSeq>& iceP_inSeq, std::optional<BoolSeq>& iceP_outSeq, const ::Ice::Context& context) const
{
    auto _result = _makePromiseOutgoing<::std::tuple<std::optional<BoolSeq>, std::optional<BoolSeq>>>(true, this, &TestIntfPrx::_iceI_opOptBoolSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<std::optional<::Test::BoolSeq>, std::optional<::Test::BoolSeq>>>
Test::TestIntfPrx::opOptBoolSeqAsync(const std::optional<BoolSeq>& iceP_inSeq, const ::Ice::Context& context) const
{
    return _makePromiseOutgoing<::std::tuple<std::optional<BoolSeq>, std::optional<BoolSeq>>, ::std::promise>(false, this, &TestIntfPrx::_iceI_opOptBoolSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opOptBoolSeqAsync(const std::optional<BoolSeq>& iceP_inSeq,
                                     ::std::function<void (std::optional<::Test::BoolSeq>, std::optional<::Test::BoolSeq>)> response,
                                     ::std::function<void(::std::exception_ptr)> ex,
                                     ::std::function<void(bool)> sent,
                                     const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<std::optional<BoolSeq>, std::optional<BoolSeq>>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return _makeLambdaOutgoing<::std::tuple<std::optional<BoolSeq>, std::optional<BoolSeq>>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opOptBoolSeq, iceP_inSeq, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opOptBoolSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<std::optional<BoolSeq>, std::optional<BoolSeq>>>>& outAsync, const std::optional<BoolSeq>& iceP_inSeq, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_TestIntf_opOptBoolSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opOptBoolSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({2}, iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<std::optional<BoolSeq>, std::optional<BoolSeq>> v;
            istr->readAll({1, 3}, ::std::get<0>(v), ::std::get<1>(v));
            return v;
        });
}
/// \endcond

std::optional<::Test::ByteSeq>
Test::TestIntfPrx::opOptByteSeq(const std::optional<ByteSeq>& iceP_inSeq, std::optional<ByteSeq>& iceP_outSeq, const ::Ice::Context& context) const
{
    auto _result = _makePromiseOutgoing<::std::tuple<std::optional<ByteSeq>, std::optional<ByteSeq>>>(true, this, &TestIntfPrx::_iceI_opOptByteSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<std::optional<::Test::ByteSeq>, std::optional<::Test::ByteSeq>>>
Test::TestIntfPrx::opOptByteSeqAsync(const std::optional<ByteSeq>& iceP_inSeq, const ::Ice::Context& context) const
{
    return _makePromiseOutgoing<::std::tuple<std::optional<ByteSeq>, std::optional<ByteSeq>>, ::std::promise>(false, this, &TestIntfPrx::_iceI_opOptByteSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opOptByteSeqAsync(const std::optional<ByteSeq>& iceP_inSeq,
                                     ::std::function<void (std::optional<::Test::ByteSeq>, std::optional<::Test::ByteSeq>)> response,
                                     ::std::function<void(::std::exception_ptr)> ex,
                                     ::std::function<void(bool)> sent,
                                     const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<std::optional<ByteSeq>, std::optional<ByteSeq>>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return _makeLambdaOutgoing<::std::tuple<std::optional<ByteSeq>, std::optional<ByteSeq>>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opOptByteSeq, iceP_inSeq, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opOptByteSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<std::optional<ByteSeq>, std::optional<ByteSeq>>>>& outAsync, const std::optional<ByteSeq>& iceP_inSeq, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_TestIntf_opOptByteSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opOptByteSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({2}, iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<std::optional<ByteSeq>, std::optional<ByteSeq>> v;
            istr->readAll({1, 3}, ::std::get<0>(v), ::std::get<1>(v));
            return v;
        });
}
/// \endcond

std::optional<::Test::ShortSeq>
Test::TestIntfPrx::opOptShortSeq(const std::optional<ShortSeq>& iceP_inSeq, std::optional<ShortSeq>& iceP_outSeq, const ::Ice::Context& context) const
{
    auto _result = _makePromiseOutgoing<::std::tuple<std::optional<ShortSeq>, std::optional<ShortSeq>>>(true, this, &TestIntfPrx::_iceI_opOptShortSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<std::optional<::Test::ShortSeq>, std::optional<::Test::ShortSeq>>>
Test::TestIntfPrx::opOptShortSeqAsync(const std::optional<ShortSeq>& iceP_inSeq, const ::Ice::Context& context) const
{
    return _makePromiseOutgoing<::std::tuple<std::optional<ShortSeq>, std::optional<ShortSeq>>, ::std::promise>(false, this, &TestIntfPrx::_iceI_opOptShortSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opOptShortSeqAsync(const std::optional<ShortSeq>& iceP_inSeq,
                                      ::std::function<void (std::optional<::Test::ShortSeq>, std::optional<::Test::ShortSeq>)> response,
                                      ::std::function<void(::std::exception_ptr)> ex,
                                      ::std::function<void(bool)> sent,
                                      const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<std::optional<ShortSeq>, std::optional<ShortSeq>>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return _makeLambdaOutgoing<::std::tuple<std::optional<ShortSeq>, std::optional<ShortSeq>>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opOptShortSeq, iceP_inSeq, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opOptShortSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<std::optional<ShortSeq>, std::optional<ShortSeq>>>>& outAsync, const std::optional<ShortSeq>& iceP_inSeq, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_TestIntf_opOptShortSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opOptShortSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({2}, iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<std::optional<ShortSeq>, std::optional<ShortSeq>> v;
            istr->readAll({1, 3}, ::std::get<0>(v), ::std::get<1>(v));
            return v;
        });
}
/// \endcond

std::optional<::Test::IntSeq>
Test::TestIntfPrx::opOptIntSeq(const std::optional<IntSeq>& iceP_inSeq, std::optional<IntSeq>& iceP_outSeq, const ::Ice::Context& context) const
{
    auto _result = _makePromiseOutgoing<::std::tuple<std::optional<IntSeq>, std::optional<IntSeq>>>(true, this, &TestIntfPrx::_iceI_opOptIntSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<std::optional<::Test::IntSeq>, std::optional<::Test::IntSeq>>>
Test::TestIntfPrx::opOptIntSeqAsync(const std::optional<IntSeq>& iceP_inSeq, const ::Ice::Context& context) const
{
    return _makePromiseOutgoing<::std::tuple<std::optional<IntSeq>, std::optional<IntSeq>>, ::std::promise>(false, this, &TestIntfPrx::_iceI_opOptIntSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opOptIntSeqAsync(const std::optional<IntSeq>& iceP_inSeq,
                                    ::std::function<void (std::optional<::Test::IntSeq>, std::optional<::Test::IntSeq>)> response,
                                    ::std::function<void(::std::exception_ptr)> ex,
                                    ::std::function<void(bool)> sent,
                                    const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<std::optional<IntSeq>, std::optional<IntSeq>>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return _makeLambdaOutgoing<::std::tuple<std::optional<IntSeq>, std::optional<IntSeq>>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opOptIntSeq, iceP_inSeq, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opOptIntSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<std::optional<IntSeq>, std::optional<IntSeq>>>>& outAsync, const std::optional<IntSeq>& iceP_inSeq, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_TestIntf_opOptIntSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opOptIntSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({2}, iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<std::optional<IntSeq>, std::optional<IntSeq>> v;
            istr->readAll({1, 3}, ::std::get<0>(v), ::std::get<1>(v));
            return v;
        });
}
/// \endcond

std::optional<::Test::LongSeq>
Test::TestIntfPrx::opOptLongSeq(const std::optional<LongSeq>& iceP_inSeq, std::optional<LongSeq>& iceP_outSeq, const ::Ice::Context& context) const
{
    auto _result = _makePromiseOutgoing<::std::tuple<std::optional<LongSeq>, std::optional<LongSeq>>>(true, this, &TestIntfPrx::_iceI_opOptLongSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<std::optional<::Test::LongSeq>, std::optional<::Test::LongSeq>>>
Test::TestIntfPrx::opOptLongSeqAsync(const std::optional<LongSeq>& iceP_inSeq, const ::Ice::Context& context) const
{
    return _makePromiseOutgoing<::std::tuple<std::optional<LongSeq>, std::optional<LongSeq>>, ::std::promise>(false, this, &TestIntfPrx::_iceI_opOptLongSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opOptLongSeqAsync(const std::optional<LongSeq>& iceP_inSeq,
                                     ::std::function<void (std::optional<::Test::LongSeq>, std::optional<::Test::LongSeq>)> response,
                                     ::std::function<void(::std::exception_ptr)> ex,
                                     ::std::function<void(bool)> sent,
                                     const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<std::optional<LongSeq>, std::optional<LongSeq>>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return _makeLambdaOutgoing<::std::tuple<std::optional<LongSeq>, std::optional<LongSeq>>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opOptLongSeq, iceP_inSeq, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opOptLongSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<std::optional<LongSeq>, std::optional<LongSeq>>>>& outAsync, const std::optional<LongSeq>& iceP_inSeq, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_TestIntf_opOptLongSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opOptLongSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({2}, iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<std::optional<LongSeq>, std::optional<LongSeq>> v;
            istr->readAll({1, 3}, ::std::get<0>(v), ::std::get<1>(v));
            return v;
        });
}
/// \endcond

std::optional<::Test::FloatSeq>
Test::TestIntfPrx::opOptFloatSeq(const std::optional<FloatSeq>& iceP_inSeq, std::optional<FloatSeq>& iceP_outSeq, const ::Ice::Context& context) const
{
    auto _result = _makePromiseOutgoing<::std::tuple<std::optional<FloatSeq>, std::optional<FloatSeq>>>(true, this, &TestIntfPrx::_iceI_opOptFloatSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<std::optional<::Test::FloatSeq>, std::optional<::Test::FloatSeq>>>
Test::TestIntfPrx::opOptFloatSeqAsync(const std::optional<FloatSeq>& iceP_inSeq, const ::Ice::Context& context) const
{
    return _makePromiseOutgoing<::std::tuple<std::optional<FloatSeq>, std::optional<FloatSeq>>, ::std::promise>(false, this, &TestIntfPrx::_iceI_opOptFloatSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opOptFloatSeqAsync(const std::optional<FloatSeq>& iceP_inSeq,
                                      ::std::function<void (std::optional<::Test::FloatSeq>, std::optional<::Test::FloatSeq>)> response,
                                      ::std::function<void(::std::exception_ptr)> ex,
                                      ::std::function<void(bool)> sent,
                                      const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<std::optional<FloatSeq>, std::optional<FloatSeq>>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return _makeLambdaOutgoing<::std::tuple<std::optional<FloatSeq>, std::optional<FloatSeq>>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opOptFloatSeq, iceP_inSeq, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opOptFloatSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<std::optional<FloatSeq>, std::optional<FloatSeq>>>>& outAsync, const std::optional<FloatSeq>& iceP_inSeq, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_TestIntf_opOptFloatSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opOptFloatSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({2}, iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<std::optional<FloatSeq>, std::optional<FloatSeq>> v;
            istr->readAll({1, 3}, ::std::get<0>(v), ::std::get<1>(v));
            return v;
        });
}
/// \endcond

std::optional<::Test::DoubleSeq>
Test::TestIntfPrx::opOptDoubleSeq(const std::optional<DoubleSeq>& iceP_inSeq, std::optional<DoubleSeq>& iceP_outSeq, const ::Ice::Context& context) const
{
    auto _result = _makePromiseOutgoing<::std::tuple<std::optional<DoubleSeq>, std::optional<DoubleSeq>>>(true, this, &TestIntfPrx::_iceI_opOptDoubleSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<std::optional<::Test::DoubleSeq>, std::optional<::Test::DoubleSeq>>>
Test::TestIntfPrx::opOptDoubleSeqAsync(const std::optional<DoubleSeq>& iceP_inSeq, const ::Ice::Context& context) const
{
    return _makePromiseOutgoing<::std::tuple<std::optional<DoubleSeq>, std::optional<DoubleSeq>>, ::std::promise>(false, this, &TestIntfPrx::_iceI_opOptDoubleSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opOptDoubleSeqAsync(const std::optional<DoubleSeq>& iceP_inSeq,
                                       ::std::function<void (std::optional<::Test::DoubleSeq>, std::optional<::Test::DoubleSeq>)> response,
                                       ::std::function<void(::std::exception_ptr)> ex,
                                       ::std::function<void(bool)> sent,
                                       const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<std::optional<DoubleSeq>, std::optional<DoubleSeq>>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return _makeLambdaOutgoing<::std::tuple<std::optional<DoubleSeq>, std::optional<DoubleSeq>>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opOptDoubleSeq, iceP_inSeq, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opOptDoubleSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<std::optional<DoubleSeq>, std::optional<DoubleSeq>>>>& outAsync, const std::optional<DoubleSeq>& iceP_inSeq, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_TestIntf_opOptDoubleSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opOptDoubleSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({2}, iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<std::optional<DoubleSeq>, std::optional<DoubleSeq>> v;
            istr->readAll({1, 3}, ::std::get<0>(v), ::std::get<1>(v));
            return v;
        });
}
/// \endcond

std::optional<::Test::StringSeq>
Test::TestIntfPrx::opOptStringSeq(const std::optional<StringSeq>& iceP_inSeq, std::optional<StringSeq>& iceP_outSeq, const ::Ice::Context& context) const
{
    auto _result = _makePromiseOutgoing<::std::tuple<std::optional<StringSeq>, std::optional<StringSeq>>>(true, this, &TestIntfPrx::_iceI_opOptStringSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<std::optional<::Test::StringSeq>, std::optional<::Test::StringSeq>>>
Test::TestIntfPrx::opOptStringSeqAsync(const std::optional<StringSeq>& iceP_inSeq, const ::Ice::Context& context) const
{
    return _makePromiseOutgoing<::std::tuple<std::optional<StringSeq>, std::optional<StringSeq>>, ::std::promise>(false, this, &TestIntfPrx::_iceI_opOptStringSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opOptStringSeqAsync(const std::optional<StringSeq>& iceP_inSeq,
                                       ::std::function<void (std::optional<::Test::StringSeq>, std::optional<::Test::StringSeq>)> response,
                                       ::std::function<void(::std::exception_ptr)> ex,
                                       ::std::function<void(bool)> sent,
                                       const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<std::optional<StringSeq>, std::optional<StringSeq>>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return _makeLambdaOutgoing<::std::tuple<std::optional<StringSeq>, std::optional<StringSeq>>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opOptStringSeq, iceP_inSeq, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opOptStringSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<std::optional<StringSeq>, std::optional<StringSeq>>>>& outAsync, const std::optional<StringSeq>& iceP_inSeq, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_TestIntf_opOptStringSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opOptStringSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({2}, iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<std::optional<StringSeq>, std::optional<StringSeq>> v;
            istr->readAll({1, 3}, ::std::get<0>(v), ::std::get<1>(v));
            return v;
        });
}
/// \endcond

std::optional<::Test::ESeq>
Test::TestIntfPrx::opOptESeq(const std::optional<ESeq>& iceP_inSeq, std::optional<ESeq>& iceP_outSeq, const ::Ice::Context& context) const
{
    auto _result = _makePromiseOutgoing<::std::tuple<std::optional<ESeq>, std::optional<ESeq>>>(true, this, &TestIntfPrx::_iceI_opOptESeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<std::optional<::Test::ESeq>, std::optional<::Test::ESeq>>>
Test::TestIntfPrx::opOptESeqAsync(const std::optional<ESeq>& iceP_inSeq, const ::Ice::Context& context) const
{
    return _makePromiseOutgoing<::std::tuple<std::optional<ESeq>, std::optional<ESeq>>, ::std::promise>(false, this, &TestIntfPrx::_iceI_opOptESeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opOptESeqAsync(const std::optional<ESeq>& iceP_inSeq,
                                  ::std::function<void (std::optional<::Test::ESeq>, std::optional<::Test::ESeq>)> response,
                                  ::std::function<void(::std::exception_ptr)> ex,
                                  ::std::function<void(bool)> sent,
                                  const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<std::optional<ESeq>, std::optional<ESeq>>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return _makeLambdaOutgoing<::std::tuple<std::optional<ESeq>, std::optional<ESeq>>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opOptESeq, iceP_inSeq, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opOptESeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<std::optional<ESeq>, std::optional<ESeq>>>>& outAsync, const std::optional<ESeq>& iceP_inSeq, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_TestIntf_opOptESeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opOptESeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({2}, iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<std::optional<ESeq>, std::optional<ESeq>> v;
            istr->readAll({1, 3}, ::std::get<0>(v), ::std::get<1>(v));
            return v;
        });
}
/// \endcond

std::optional<::Test::SSeq>
Test::TestIntfPrx::opOptSSeq(const std::optional<SSeq>& iceP_inSeq, std::optional<SSeq>& iceP_outSeq, const ::Ice::Context& context) const
{
    auto _result = _makePromiseOutgoing<::std::tuple<std::optional<SSeq>, std::optional<SSeq>>>(true, this, &TestIntfPrx::_iceI_opOptSSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<std::optional<::Test::SSeq>, std::optional<::Test::SSeq>>>
Test::TestIntfPrx::opOptSSeqAsync(const std::optional<SSeq>& iceP_inSeq, const ::Ice::Context& context) const
{
    return _makePromiseOutgoing<::std::tuple<std::optional<SSeq>, std::optional<SSeq>>, ::std::promise>(false, this, &TestIntfPrx::_iceI_opOptSSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opOptSSeqAsync(const std::optional<SSeq>& iceP_inSeq,
                                  ::std::function<void (std::optional<::Test::SSeq>, std::optional<::Test::SSeq>)> response,
                                  ::std::function<void(::std::exception_ptr)> ex,
                                  ::std::function<void(bool)> sent,
                                  const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<std::optional<SSeq>, std::optional<SSeq>>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return _makeLambdaOutgoing<::std::tuple<std::optional<SSeq>, std::optional<SSeq>>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opOptSSeq, iceP_inSeq, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opOptSSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<std::optional<SSeq>, std::optional<SSeq>>>>& outAsync, const std::optional<SSeq>& iceP_inSeq, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_TestIntf_opOptSSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opOptSSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({2}, iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<std::optional<SSeq>, std::optional<SSeq>> v;
            istr->readAll({1, 3}, ::std::get<0>(v), ::std::get<1>(v));
            return v;
        });
}
/// \endcond

std::optional<::Test::DSeq>
Test::TestIntfPrx::opOptDSeq(const std::optional<DSeq>& iceP_inSeq, std::optional<DSeq>& iceP_outSeq, const ::Ice::Context& context) const
{
    auto _result = _makePromiseOutgoing<::std::tuple<std::optional<DSeq>, std::optional<DSeq>>>(true, this, &TestIntfPrx::_iceI_opOptDSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<std::optional<::Test::DSeq>, std::optional<::Test::DSeq>>>
Test::TestIntfPrx::opOptDSeqAsync(const std::optional<DSeq>& iceP_inSeq, const ::Ice::Context& context) const
{
    return _makePromiseOutgoing<::std::tuple<std::optional<DSeq>, std::optional<DSeq>>, ::std::promise>(false, this, &TestIntfPrx::_iceI_opOptDSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opOptDSeqAsync(const std::optional<DSeq>& iceP_inSeq,
                                  ::std::function<void (std::optional<::Test::DSeq>, std::optional<::Test::DSeq>)> response,
                                  ::std::function<void(::std::exception_ptr)> ex,
                                  ::std::function<void(bool)> sent,
                                  const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<std::optional<DSeq>, std::optional<DSeq>>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return _makeLambdaOutgoing<::std::tuple<std::optional<DSeq>, std::optional<DSeq>>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opOptDSeq, iceP_inSeq, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opOptDSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<std::optional<DSeq>, std::optional<DSeq>>>>& outAsync, const std::optional<DSeq>& iceP_inSeq, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_TestIntf_opOptDSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opOptDSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({2}, iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<std::optional<DSeq>, std::optional<DSeq>> v;
            istr->readAll({1, 3}, ::std::get<0>(v), ::std::get<1>(v));
            return v;
        });
}
/// \endcond

std::optional<::Test::StringSeqSeq>
Test::TestIntfPrx::opOptStringSeqSeq(const std::optional<StringSeqSeq>& iceP_inSeq, std::optional<StringSeqSeq>& iceP_outSeq, const ::Ice::Context& context) const
{
    auto _result = _makePromiseOutgoing<::std::tuple<std::optional<StringSeqSeq>, std::optional<StringSeqSeq>>>(true, this, &TestIntfPrx::_iceI_opOptStringSeqSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<std::optional<::Test::StringSeqSeq>, std::optional<::Test::StringSeqSeq>>>
Test::TestIntfPrx::opOptStringSeqSeqAsync(const std::optional<StringSeqSeq>& iceP_inSeq, const ::Ice::Context& context) const
{
    return _makePromiseOutgoing<::std::tuple<std::optional<StringSeqSeq>, std::optional<StringSeqSeq>>, ::std::promise>(false, this, &TestIntfPrx::_iceI_opOptStringSeqSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opOptStringSeqSeqAsync(const std::optional<StringSeqSeq>& iceP_inSeq,
                                          ::std::function<void (std::optional<::Test::StringSeqSeq>, std::optional<::Test::StringSeqSeq>)> response,
                                          ::std::function<void(::std::exception_ptr)> ex,
                                          ::std::function<void(bool)> sent,
                                          const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<std::optional<StringSeqSeq>, std::optional<StringSeqSeq>>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return _makeLambdaOutgoing<::std::tuple<std::optional<StringSeqSeq>, std::optional<StringSeqSeq>>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opOptStringSeqSeq, iceP_inSeq, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opOptStringSeqSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<std::optional<StringSeqSeq>, std::optional<StringSeqSeq>>>>& outAsync, const std::optional<StringSeqSeq>& iceP_inSeq, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_TestIntf_opOptStringSeqSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opOptStringSeqSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({2}, iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<std::optional<StringSeqSeq>, std::optional<StringSeqSeq>> v;
            istr->readAll({1, 3}, ::std::get<0>(v), ::std::get<1>(v));
            return v;
        });
}
/// \endcond

std::optional<::Test::ByteBuffer>
Test::TestIntfPrx::opOptByteBufferSeq(const std::optional<ByteBuffer>& iceP_inSeq, std::optional<ByteBuffer>& iceP_outSeq, const ::Ice::Context& context) const
{
    auto _result = _makePromiseOutgoing<::std::tuple<std::optional<ByteBuffer>, std::optional<ByteBuffer>>>(true, this, &TestIntfPrx::_iceI_opOptByteBufferSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<std::optional<::Test::ByteBuffer>, std::optional<::Test::ByteBuffer>>>
Test::TestIntfPrx::opOptByteBufferSeqAsync(const std::optional<ByteBuffer>& iceP_inSeq, const ::Ice::Context& context) const
{
    return _makePromiseOutgoing<::std::tuple<std::optional<ByteBuffer>, std::optional<ByteBuffer>>, ::std::promise>(false, this, &TestIntfPrx::_iceI_opOptByteBufferSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opOptByteBufferSeqAsync(const std::optional<ByteBuffer>& iceP_inSeq,
                                           ::std::function<void (std::optional<::Test::ByteBuffer>, std::optional<::Test::ByteBuffer>)> response,
                                           ::std::function<void(::std::exception_ptr)> ex,
                                           ::std::function<void(bool)> sent,
                                           const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<std::optional<ByteBuffer>, std::optional<ByteBuffer>>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return _makeLambdaOutgoing<::std::tuple<std::optional<ByteBuffer>, std::optional<ByteBuffer>>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opOptByteBufferSeq, iceP_inSeq, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opOptByteBufferSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<std::optional<ByteBuffer>, std::optional<ByteBuffer>>>>& outAsync, const std::optional<ByteBuffer>& iceP_inSeq, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_TestIntf_opOptByteBufferSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opOptByteBufferSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({2}, iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<std::optional<ByteBuffer>, std::optional<ByteBuffer>> v;
            istr->readAll({1, 3}, ::std::get<0>(v), ::std::get<1>(v));
            return v;
        });
}
/// \endcond

std::optional<::Test::ShortBuffer>
Test::TestIntfPrx::opOptShortBufferSeq(const std::optional<ShortBuffer>& iceP_inSeq, std::optional<ShortBuffer>& iceP_outSeq, const ::Ice::Context& context) const
{
    auto _result = _makePromiseOutgoing<::std::tuple<std::optional<ShortBuffer>, std::optional<ShortBuffer>>>(true, this, &TestIntfPrx::_iceI_opOptShortBufferSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<std::optional<::Test::ShortBuffer>, std::optional<::Test::ShortBuffer>>>
Test::TestIntfPrx::opOptShortBufferSeqAsync(const std::optional<ShortBuffer>& iceP_inSeq, const ::Ice::Context& context) const
{
    return _makePromiseOutgoing<::std::tuple<std::optional<ShortBuffer>, std::optional<ShortBuffer>>, ::std::promise>(false, this, &TestIntfPrx::_iceI_opOptShortBufferSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opOptShortBufferSeqAsync(const std::optional<ShortBuffer>& iceP_inSeq,
                                            ::std::function<void (std::optional<::Test::ShortBuffer>, std::optional<::Test::ShortBuffer>)> response,
                                            ::std::function<void(::std::exception_ptr)> ex,
                                            ::std::function<void(bool)> sent,
                                            const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<std::optional<ShortBuffer>, std::optional<ShortBuffer>>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return _makeLambdaOutgoing<::std::tuple<std::optional<ShortBuffer>, std::optional<ShortBuffer>>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opOptShortBufferSeq, iceP_inSeq, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opOptShortBufferSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<std::optional<ShortBuffer>, std::optional<ShortBuffer>>>>& outAsync, const std::optional<ShortBuffer>& iceP_inSeq, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_TestIntf_opOptShortBufferSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opOptShortBufferSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({2}, iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<std::optional<ShortBuffer>, std::optional<ShortBuffer>> v;
            istr->readAll({1, 3}, ::std::get<0>(v), ::std::get<1>(v));
            return v;
        });
}
/// \endcond

std::optional<::Test::IntBuffer>
Test::TestIntfPrx::opOptIntBufferSeq(const std::optional<IntBuffer>& iceP_inSeq, std::optional<IntBuffer>& iceP_outSeq, const ::Ice::Context& context) const
{
    auto _result = _makePromiseOutgoing<::std::tuple<std::optional<IntBuffer>, std::optional<IntBuffer>>>(true, this, &TestIntfPrx::_iceI_opOptIntBufferSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<std::optional<::Test::IntBuffer>, std::optional<::Test::IntBuffer>>>
Test::TestIntfPrx::opOptIntBufferSeqAsync(const std::optional<IntBuffer>& iceP_inSeq, const ::Ice::Context& context) const
{
    return _makePromiseOutgoing<::std::tuple<std::optional<IntBuffer>, std::optional<IntBuffer>>, ::std::promise>(false, this, &TestIntfPrx::_iceI_opOptIntBufferSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opOptIntBufferSeqAsync(const std::optional<IntBuffer>& iceP_inSeq,
                                          ::std::function<void (std::optional<::Test::IntBuffer>, std::optional<::Test::IntBuffer>)> response,
                                          ::std::function<void(::std::exception_ptr)> ex,
                                          ::std::function<void(bool)> sent,
                                          const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<std::optional<IntBuffer>, std::optional<IntBuffer>>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return _makeLambdaOutgoing<::std::tuple<std::optional<IntBuffer>, std::optional<IntBuffer>>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opOptIntBufferSeq, iceP_inSeq, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opOptIntBufferSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<std::optional<IntBuffer>, std::optional<IntBuffer>>>>& outAsync, const std::optional<IntBuffer>& iceP_inSeq, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_TestIntf_opOptIntBufferSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opOptIntBufferSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({2}, iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<std::optional<IntBuffer>, std::optional<IntBuffer>> v;
            istr->readAll({1, 3}, ::std::get<0>(v), ::std::get<1>(v));
            return v;
        });
}
/// \endcond

std::optional<::Test::LongBuffer>
Test::TestIntfPrx::opOptLongBufferSeq(const std::optional<LongBuffer>& iceP_inSeq, std::optional<LongBuffer>& iceP_outSeq, const ::Ice::Context& context) const
{
    auto _result = _makePromiseOutgoing<::std::tuple<std::optional<LongBuffer>, std::optional<LongBuffer>>>(true, this, &TestIntfPrx::_iceI_opOptLongBufferSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<std::optional<::Test::LongBuffer>, std::optional<::Test::LongBuffer>>>
Test::TestIntfPrx::opOptLongBufferSeqAsync(const std::optional<LongBuffer>& iceP_inSeq, const ::Ice::Context& context) const
{
    return _makePromiseOutgoing<::std::tuple<std::optional<LongBuffer>, std::optional<LongBuffer>>, ::std::promise>(false, this, &TestIntfPrx::_iceI_opOptLongBufferSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opOptLongBufferSeqAsync(const std::optional<LongBuffer>& iceP_inSeq,
                                           ::std::function<void (std::optional<::Test::LongBuffer>, std::optional<::Test::LongBuffer>)> response,
                                           ::std::function<void(::std::exception_ptr)> ex,
                                           ::std::function<void(bool)> sent,
                                           const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<std::optional<LongBuffer>, std::optional<LongBuffer>>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return _makeLambdaOutgoing<::std::tuple<std::optional<LongBuffer>, std::optional<LongBuffer>>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opOptLongBufferSeq, iceP_inSeq, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opOptLongBufferSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<std::optional<LongBuffer>, std::optional<LongBuffer>>>>& outAsync, const std::optional<LongBuffer>& iceP_inSeq, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_TestIntf_opOptLongBufferSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opOptLongBufferSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({2}, iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<std::optional<LongBuffer>, std::optional<LongBuffer>> v;
            istr->readAll({1, 3}, ::std::get<0>(v), ::std::get<1>(v));
            return v;
        });
}
/// \endcond

std::optional<::Test::FloatBuffer>
Test::TestIntfPrx::opOptFloatBufferSeq(const std::optional<FloatBuffer>& iceP_inSeq, std::optional<FloatBuffer>& iceP_outSeq, const ::Ice::Context& context) const
{
    auto _result = _makePromiseOutgoing<::std::tuple<std::optional<FloatBuffer>, std::optional<FloatBuffer>>>(true, this, &TestIntfPrx::_iceI_opOptFloatBufferSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<std::optional<::Test::FloatBuffer>, std::optional<::Test::FloatBuffer>>>
Test::TestIntfPrx::opOptFloatBufferSeqAsync(const std::optional<FloatBuffer>& iceP_inSeq, const ::Ice::Context& context) const
{
    return _makePromiseOutgoing<::std::tuple<std::optional<FloatBuffer>, std::optional<FloatBuffer>>, ::std::promise>(false, this, &TestIntfPrx::_iceI_opOptFloatBufferSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opOptFloatBufferSeqAsync(const std::optional<FloatBuffer>& iceP_inSeq,
                                            ::std::function<void (std::optional<::Test::FloatBuffer>, std::optional<::Test::FloatBuffer>)> response,
                                            ::std::function<void(::std::exception_ptr)> ex,
                                            ::std::function<void(bool)> sent,
                                            const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<std::optional<FloatBuffer>, std::optional<FloatBuffer>>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return _makeLambdaOutgoing<::std::tuple<std::optional<FloatBuffer>, std::optional<FloatBuffer>>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opOptFloatBufferSeq, iceP_inSeq, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opOptFloatBufferSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<std::optional<FloatBuffer>, std::optional<FloatBuffer>>>>& outAsync, const std::optional<FloatBuffer>& iceP_inSeq, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_TestIntf_opOptFloatBufferSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opOptFloatBufferSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({2}, iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<std::optional<FloatBuffer>, std::optional<FloatBuffer>> v;
            istr->readAll({1, 3}, ::std::get<0>(v), ::std::get<1>(v));
            return v;
        });
}
/// \endcond

std::optional<::Test::DoubleBuffer>
Test::TestIntfPrx::opOptDoubleBufferSeq(const std::optional<DoubleBuffer>& iceP_inSeq, std::optional<DoubleBuffer>& iceP_outSeq, const ::Ice::Context& context) const
{
    auto _result = _makePromiseOutgoing<::std::tuple<std::optional<DoubleBuffer>, std::optional<DoubleBuffer>>>(true, this, &TestIntfPrx::_iceI_opOptDoubleBufferSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<std::optional<::Test::DoubleBuffer>, std::optional<::Test::DoubleBuffer>>>
Test::TestIntfPrx::opOptDoubleBufferSeqAsync(const std::optional<DoubleBuffer>& iceP_inSeq, const ::Ice::Context& context) const
{
    return _makePromiseOutgoing<::std::tuple<std::optional<DoubleBuffer>, std::optional<DoubleBuffer>>, ::std::promise>(false, this, &TestIntfPrx::_iceI_opOptDoubleBufferSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opOptDoubleBufferSeqAsync(const std::optional<DoubleBuffer>& iceP_inSeq,
                                             ::std::function<void (std::optional<::Test::DoubleBuffer>, std::optional<::Test::DoubleBuffer>)> response,
                                             ::std::function<void(::std::exception_ptr)> ex,
                                             ::std::function<void(bool)> sent,
                                             const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<std::optional<DoubleBuffer>, std::optional<DoubleBuffer>>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return _makeLambdaOutgoing<::std::tuple<std::optional<DoubleBuffer>, std::optional<DoubleBuffer>>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opOptDoubleBufferSeq, iceP_inSeq, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opOptDoubleBufferSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<std::optional<DoubleBuffer>, std::optional<DoubleBuffer>>>>& outAsync, const std::optional<DoubleBuffer>& iceP_inSeq, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_TestIntf_opOptDoubleBufferSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opOptDoubleBufferSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({2}, iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<std::optional<DoubleBuffer>, std::optional<DoubleBuffer>> v;
            istr->readAll({1, 3}, ::std::get<0>(v), ::std::get<1>(v));
            return v;
        });
}
/// \endcond

void
Test::TestIntfPrx::shutdown(const ::Ice::Context& context) const
{
    _makePromiseOutgoing<void>(true, this, &TestIntfPrx::_iceI_shutdown, context).get();
}

::std::future<void>
Test::TestIntfPrx::shutdownAsync(const ::Ice::Context& context) const
{
    return _makePromiseOutgoing<void, ::std::promise>(false, this, &TestIntfPrx::_iceI_shutdown, context);
}

::std::function<void()>
Test::TestIntfPrx::shutdownAsync(::std::function<void ()> response,
                                 ::std::function<void(::std::exception_ptr)> ex,
                                 ::std::function<void(bool)> sent,
                                 const ::Ice::Context& context) const
{
    return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_shutdown, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_shutdown(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::Ice::Context& context) const
{
    outAsync->invoke(iceC_Test_TestIntf_shutdown_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

const ::std::string&
Test::TestIntfPrx::ice_staticId()
{
    return TestIntf::ice_staticId();
}

Test::C::~C()
{
}

const ::std::string&
Test::C::ice_staticId()
{
    static const ::std::string typeId = "::Test::C";
    return typeId;
}

bool
Test::TestIntf::ice_isA(::std::string s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_TestIntf_ids, iceC_Test_TestIntf_ids + 2, s);
}

::std::vector<::std::string>
Test::TestIntf::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector<::std::string>(&iceC_Test_TestIntf_ids[0], &iceC_Test_TestIntf_ids[2]);
}

::std::string
Test::TestIntf::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::TestIntf::ice_staticId()
{
    static const ::std::string typeId = "::Test::TestIntf";
    return typeId;
}

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opCSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    CSeq iceP_inSeq;
    istr->readAll(iceP_inSeq);
    istr->readPendingValues();
    inS.endReadParams();
    CSeq iceP_outSeq;
    CSeq ret = this->opCSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_outSeq, ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opCArray(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    CArray iceP_inSeq;
    istr->readAll(iceP_inSeq);
    istr->readPendingValues();
    inS.endReadParams();
    CArray iceP_outSeq;
    CArray ret = this->opCArray(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_outSeq, ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opCList(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    CList iceP_inSeq;
    istr->readAll(iceP_inSeq);
    istr->readPendingValues();
    inS.endReadParams();
    CList iceP_outSeq;
    CList ret = this->opCList(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_outSeq, ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opBoolSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    BoolSeq iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    BoolSeq iceP_outSeq;
    BoolSeq ret = this->opBoolSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_outSeq, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opByteSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ByteSeq iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    ByteSeq iceP_outSeq;
    ByteSeq ret = this->opByteSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_outSeq, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opShortSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ShortSeq iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    ShortSeq iceP_outSeq;
    ShortSeq ret = this->opShortSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_outSeq, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opIntSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    IntSeq iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    IntSeq iceP_outSeq;
    IntSeq ret = this->opIntSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_outSeq, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opLongSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    LongSeq iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    LongSeq iceP_outSeq;
    LongSeq ret = this->opLongSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_outSeq, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opFloatSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    FloatSeq iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    FloatSeq iceP_outSeq;
    FloatSeq ret = this->opFloatSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_outSeq, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opDoubleSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    DoubleSeq iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    DoubleSeq iceP_outSeq;
    DoubleSeq ret = this->opDoubleSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_outSeq, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opStringSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    StringSeq iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    StringSeq iceP_outSeq;
    StringSeq ret = this->opStringSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_outSeq, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opESeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ESeq iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    ESeq iceP_outSeq;
    ESeq ret = this->opESeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_outSeq, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opSSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    SSeq iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    SSeq iceP_outSeq;
    SSeq ret = this->opSSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_outSeq, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opDSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    DSeq iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    DSeq iceP_outSeq;
    DSeq ret = this->opDSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_outSeq, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opStringSeqSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    StringSeqSeq iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    StringSeqSeq iceP_outSeq;
    StringSeqSeq ret = this->opStringSeqSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_outSeq, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opByteBufferSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ByteBuffer iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    ByteBuffer iceP_outSeq;
    ByteBuffer ret = this->opByteBufferSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_outSeq, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opShortBufferSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ShortBuffer iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    ShortBuffer iceP_outSeq;
    ShortBuffer ret = this->opShortBufferSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_outSeq, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opIntBufferSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    IntBuffer iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    IntBuffer iceP_outSeq;
    IntBuffer ret = this->opIntBufferSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_outSeq, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opLongBufferSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    LongBuffer iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    LongBuffer iceP_outSeq;
    LongBuffer ret = this->opLongBufferSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_outSeq, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opFloatBufferSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    FloatBuffer iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    FloatBuffer iceP_outSeq;
    FloatBuffer ret = this->opFloatBufferSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_outSeq, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opDoubleBufferSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    DoubleBuffer iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    DoubleBuffer iceP_outSeq;
    DoubleBuffer ret = this->opDoubleBufferSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_outSeq, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opOptCSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    std::optional<CSeq> iceP_inSeq;
    istr->readAll({2}, iceP_inSeq);
    inS.endReadParams();
    std::optional<CSeq> iceP_outSeq;
    std::optional<CSeq> ret = this->opOptCSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll({1, 3}, ret, iceP_outSeq);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opOptCArray(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    std::optional<CArray> iceP_inSeq;
    istr->readAll({2}, iceP_inSeq);
    inS.endReadParams();
    std::optional<CArray> iceP_outSeq;
    std::optional<CArray> ret = this->opOptCArray(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll({1, 3}, ret, iceP_outSeq);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opOptCList(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    std::optional<CList> iceP_inSeq;
    istr->readAll({2}, iceP_inSeq);
    inS.endReadParams();
    std::optional<CList> iceP_outSeq;
    std::optional<CList> ret = this->opOptCList(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll({1, 3}, ret, iceP_outSeq);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opOptBoolSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    std::optional<BoolSeq> iceP_inSeq;
    istr->readAll({2}, iceP_inSeq);
    inS.endReadParams();
    std::optional<BoolSeq> iceP_outSeq;
    std::optional<BoolSeq> ret = this->opOptBoolSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll({1, 3}, ret, iceP_outSeq);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opOptByteSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    std::optional<ByteSeq> iceP_inSeq;
    istr->readAll({2}, iceP_inSeq);
    inS.endReadParams();
    std::optional<ByteSeq> iceP_outSeq;
    std::optional<ByteSeq> ret = this->opOptByteSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll({1, 3}, ret, iceP_outSeq);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opOptShortSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    std::optional<ShortSeq> iceP_inSeq;
    istr->readAll({2}, iceP_inSeq);
    inS.endReadParams();
    std::optional<ShortSeq> iceP_outSeq;
    std::optional<ShortSeq> ret = this->opOptShortSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll({1, 3}, ret, iceP_outSeq);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opOptIntSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    std::optional<IntSeq> iceP_inSeq;
    istr->readAll({2}, iceP_inSeq);
    inS.endReadParams();
    std::optional<IntSeq> iceP_outSeq;
    std::optional<IntSeq> ret = this->opOptIntSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll({1, 3}, ret, iceP_outSeq);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opOptLongSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    std::optional<LongSeq> iceP_inSeq;
    istr->readAll({2}, iceP_inSeq);
    inS.endReadParams();
    std::optional<LongSeq> iceP_outSeq;
    std::optional<LongSeq> ret = this->opOptLongSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll({1, 3}, ret, iceP_outSeq);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opOptFloatSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    std::optional<FloatSeq> iceP_inSeq;
    istr->readAll({2}, iceP_inSeq);
    inS.endReadParams();
    std::optional<FloatSeq> iceP_outSeq;
    std::optional<FloatSeq> ret = this->opOptFloatSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll({1, 3}, ret, iceP_outSeq);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opOptDoubleSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    std::optional<DoubleSeq> iceP_inSeq;
    istr->readAll({2}, iceP_inSeq);
    inS.endReadParams();
    std::optional<DoubleSeq> iceP_outSeq;
    std::optional<DoubleSeq> ret = this->opOptDoubleSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll({1, 3}, ret, iceP_outSeq);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opOptStringSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    std::optional<StringSeq> iceP_inSeq;
    istr->readAll({2}, iceP_inSeq);
    inS.endReadParams();
    std::optional<StringSeq> iceP_outSeq;
    std::optional<StringSeq> ret = this->opOptStringSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll({1, 3}, ret, iceP_outSeq);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opOptESeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    std::optional<ESeq> iceP_inSeq;
    istr->readAll({2}, iceP_inSeq);
    inS.endReadParams();
    std::optional<ESeq> iceP_outSeq;
    std::optional<ESeq> ret = this->opOptESeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll({1, 3}, ret, iceP_outSeq);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opOptSSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    std::optional<SSeq> iceP_inSeq;
    istr->readAll({2}, iceP_inSeq);
    inS.endReadParams();
    std::optional<SSeq> iceP_outSeq;
    std::optional<SSeq> ret = this->opOptSSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll({1, 3}, ret, iceP_outSeq);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opOptDSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    std::optional<DSeq> iceP_inSeq;
    istr->readAll({2}, iceP_inSeq);
    inS.endReadParams();
    std::optional<DSeq> iceP_outSeq;
    std::optional<DSeq> ret = this->opOptDSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll({1, 3}, ret, iceP_outSeq);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opOptStringSeqSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    std::optional<StringSeqSeq> iceP_inSeq;
    istr->readAll({2}, iceP_inSeq);
    inS.endReadParams();
    std::optional<StringSeqSeq> iceP_outSeq;
    std::optional<StringSeqSeq> ret = this->opOptStringSeqSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll({1, 3}, ret, iceP_outSeq);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opOptByteBufferSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    std::optional<ByteBuffer> iceP_inSeq;
    istr->readAll({2}, iceP_inSeq);
    inS.endReadParams();
    std::optional<ByteBuffer> iceP_outSeq;
    std::optional<ByteBuffer> ret = this->opOptByteBufferSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll({1, 3}, ret, iceP_outSeq);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opOptShortBufferSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    std::optional<ShortBuffer> iceP_inSeq;
    istr->readAll({2}, iceP_inSeq);
    inS.endReadParams();
    std::optional<ShortBuffer> iceP_outSeq;
    std::optional<ShortBuffer> ret = this->opOptShortBufferSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll({1, 3}, ret, iceP_outSeq);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opOptIntBufferSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    std::optional<IntBuffer> iceP_inSeq;
    istr->readAll({2}, iceP_inSeq);
    inS.endReadParams();
    std::optional<IntBuffer> iceP_outSeq;
    std::optional<IntBuffer> ret = this->opOptIntBufferSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll({1, 3}, ret, iceP_outSeq);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opOptLongBufferSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    std::optional<LongBuffer> iceP_inSeq;
    istr->readAll({2}, iceP_inSeq);
    inS.endReadParams();
    std::optional<LongBuffer> iceP_outSeq;
    std::optional<LongBuffer> ret = this->opOptLongBufferSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll({1, 3}, ret, iceP_outSeq);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opOptFloatBufferSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    std::optional<FloatBuffer> iceP_inSeq;
    istr->readAll({2}, iceP_inSeq);
    inS.endReadParams();
    std::optional<FloatBuffer> iceP_outSeq;
    std::optional<FloatBuffer> ret = this->opOptFloatBufferSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll({1, 3}, ret, iceP_outSeq);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opOptDoubleBufferSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    std::optional<DoubleBuffer> iceP_inSeq;
    istr->readAll({2}, iceP_inSeq);
    inS.endReadParams();
    std::optional<DoubleBuffer> iceP_outSeq;
    std::optional<DoubleBuffer> ret = this->opOptDoubleBufferSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll({1, 3}, ret, iceP_outSeq);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_shutdown(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    this->shutdown(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_Test_TestIntf_ops, iceC_Test_TestIntf_ops + 47, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_Test_TestIntf_ops)
    {
        case 0:
        {
            return _iceD_ice_id(in, current);
        }
        case 1:
        {
            return _iceD_ice_ids(in, current);
        }
        case 2:
        {
            return _iceD_ice_isA(in, current);
        }
        case 3:
        {
            return _iceD_ice_ping(in, current);
        }
        case 4:
        {
            return _iceD_opBoolSeq(in, current);
        }
        case 5:
        {
            return _iceD_opByteBufferSeq(in, current);
        }
        case 6:
        {
            return _iceD_opByteSeq(in, current);
        }
        case 7:
        {
            return _iceD_opCArray(in, current);
        }
        case 8:
        {
            return _iceD_opCList(in, current);
        }
        case 9:
        {
            return _iceD_opCSeq(in, current);
        }
        case 10:
        {
            return _iceD_opDSeq(in, current);
        }
        case 11:
        {
            return _iceD_opDoubleBufferSeq(in, current);
        }
        case 12:
        {
            return _iceD_opDoubleSeq(in, current);
        }
        case 13:
        {
            return _iceD_opESeq(in, current);
        }
        case 14:
        {
            return _iceD_opFloatBufferSeq(in, current);
        }
        case 15:
        {
            return _iceD_opFloatSeq(in, current);
        }
        case 16:
        {
            return _iceD_opIntBufferSeq(in, current);
        }
        case 17:
        {
            return _iceD_opIntSeq(in, current);
        }
        case 18:
        {
            return _iceD_opLongBufferSeq(in, current);
        }
        case 19:
        {
            return _iceD_opLongSeq(in, current);
        }
        case 20:
        {
            return _iceD_opOptBoolSeq(in, current);
        }
        case 21:
        {
            return _iceD_opOptByteBufferSeq(in, current);
        }
        case 22:
        {
            return _iceD_opOptByteSeq(in, current);
        }
        case 23:
        {
            return _iceD_opOptCArray(in, current);
        }
        case 24:
        {
            return _iceD_opOptCList(in, current);
        }
        case 25:
        {
            return _iceD_opOptCSeq(in, current);
        }
        case 26:
        {
            return _iceD_opOptDSeq(in, current);
        }
        case 27:
        {
            return _iceD_opOptDoubleBufferSeq(in, current);
        }
        case 28:
        {
            return _iceD_opOptDoubleSeq(in, current);
        }
        case 29:
        {
            return _iceD_opOptESeq(in, current);
        }
        case 30:
        {
            return _iceD_opOptFloatBufferSeq(in, current);
        }
        case 31:
        {
            return _iceD_opOptFloatSeq(in, current);
        }
        case 32:
        {
            return _iceD_opOptIntBufferSeq(in, current);
        }
        case 33:
        {
            return _iceD_opOptIntSeq(in, current);
        }
        case 34:
        {
            return _iceD_opOptLongBufferSeq(in, current);
        }
        case 35:
        {
            return _iceD_opOptLongSeq(in, current);
        }
        case 36:
        {
            return _iceD_opOptSSeq(in, current);
        }
        case 37:
        {
            return _iceD_opOptShortBufferSeq(in, current);
        }
        case 38:
        {
            return _iceD_opOptShortSeq(in, current);
        }
        case 39:
        {
            return _iceD_opOptStringSeq(in, current);
        }
        case 40:
        {
            return _iceD_opOptStringSeqSeq(in, current);
        }
        case 41:
        {
            return _iceD_opSSeq(in, current);
        }
        case 42:
        {
            return _iceD_opShortBufferSeq(in, current);
        }
        case 43:
        {
            return _iceD_opShortSeq(in, current);
        }
        case 44:
        {
            return _iceD_opStringSeq(in, current);
        }
        case 45:
        {
            return _iceD_opStringSeqSeq(in, current);
        }
        case 46:
        {
            return _iceD_shutdown(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

namespace Ice
{
}
