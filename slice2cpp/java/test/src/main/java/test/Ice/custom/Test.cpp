//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.8.0-alpha.0
//
// <auto-generated>
//
// Generated from file `Test.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#define ICE_BUILDING_GENERATED_CODE
#include <Test.h>
#include <IceUtil/PushDisableWarnings.h>
#include <IceUtil/PopDisableWarnings.h>

#if defined(_MSC_VER)
#   pragma warning(disable:4458) // declaration of ... hides class member
#elif defined(__clang__)
#   pragma clang diagnostic ignored "-Wshadow"
#elif defined(__GNUC__)
#   pragma GCC diagnostic ignored "-Wshadow"
#endif

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION  != 30850
#       error Ice version mismatch: an exact match is required for beta generated code
#   endif
#endif

namespace
{

const ::IceInternal::DefaultValueFactoryInit<::Test::C> iceC_Test_C_init("::Test::C");

const ::std::string iceC_Test_TestIntf_ids[2] =
{
    "::Ice::Object",
    "::Test::TestIntf"
};
const ::std::string iceC_Test_TestIntf_ops[] =
{
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "opBoolSeq",
    "opByteBufferSeq",
    "opByteSeq",
    "opCArray",
    "opCList",
    "opCSeq",
    "opDSeq",
    "opDoubleBufferSeq",
    "opDoubleSeq",
    "opESeq",
    "opFloatBufferSeq",
    "opFloatSeq",
    "opIntBufferSeq",
    "opIntSeq",
    "opLongBufferSeq",
    "opLongSeq",
    "opOptBoolSeq",
    "opOptByteBufferSeq",
    "opOptByteSeq",
    "opOptCArray",
    "opOptCList",
    "opOptCSeq",
    "opOptDSeq",
    "opOptDoubleBufferSeq",
    "opOptDoubleSeq",
    "opOptESeq",
    "opOptFloatBufferSeq",
    "opOptFloatSeq",
    "opOptIntBufferSeq",
    "opOptIntSeq",
    "opOptLongBufferSeq",
    "opOptLongSeq",
    "opOptSSeq",
    "opOptShortBufferSeq",
    "opOptShortSeq",
    "opOptStringSeq",
    "opOptStringSeqSeq",
    "opSSeq",
    "opShortBufferSeq",
    "opShortSeq",
    "opStringSeq",
    "opStringSeqSeq",
    "shutdown"
};
const ::std::string iceC_Test_TestIntf_opCSeq_name = "opCSeq";
const ::std::string iceC_Test_TestIntf_opCArray_name = "opCArray";
const ::std::string iceC_Test_TestIntf_opCList_name = "opCList";
const ::std::string iceC_Test_TestIntf_opBoolSeq_name = "opBoolSeq";
const ::std::string iceC_Test_TestIntf_opByteSeq_name = "opByteSeq";
const ::std::string iceC_Test_TestIntf_opShortSeq_name = "opShortSeq";
const ::std::string iceC_Test_TestIntf_opIntSeq_name = "opIntSeq";
const ::std::string iceC_Test_TestIntf_opLongSeq_name = "opLongSeq";
const ::std::string iceC_Test_TestIntf_opFloatSeq_name = "opFloatSeq";
const ::std::string iceC_Test_TestIntf_opDoubleSeq_name = "opDoubleSeq";
const ::std::string iceC_Test_TestIntf_opStringSeq_name = "opStringSeq";
const ::std::string iceC_Test_TestIntf_opESeq_name = "opESeq";
const ::std::string iceC_Test_TestIntf_opSSeq_name = "opSSeq";
const ::std::string iceC_Test_TestIntf_opDSeq_name = "opDSeq";
const ::std::string iceC_Test_TestIntf_opStringSeqSeq_name = "opStringSeqSeq";
const ::std::string iceC_Test_TestIntf_opByteBufferSeq_name = "opByteBufferSeq";
const ::std::string iceC_Test_TestIntf_opShortBufferSeq_name = "opShortBufferSeq";
const ::std::string iceC_Test_TestIntf_opIntBufferSeq_name = "opIntBufferSeq";
const ::std::string iceC_Test_TestIntf_opLongBufferSeq_name = "opLongBufferSeq";
const ::std::string iceC_Test_TestIntf_opFloatBufferSeq_name = "opFloatBufferSeq";
const ::std::string iceC_Test_TestIntf_opDoubleBufferSeq_name = "opDoubleBufferSeq";
const ::std::string iceC_Test_TestIntf_opOptCSeq_name = "opOptCSeq";
const ::std::string iceC_Test_TestIntf_opOptCArray_name = "opOptCArray";
const ::std::string iceC_Test_TestIntf_opOptCList_name = "opOptCList";
const ::std::string iceC_Test_TestIntf_opOptBoolSeq_name = "opOptBoolSeq";
const ::std::string iceC_Test_TestIntf_opOptByteSeq_name = "opOptByteSeq";
const ::std::string iceC_Test_TestIntf_opOptShortSeq_name = "opOptShortSeq";
const ::std::string iceC_Test_TestIntf_opOptIntSeq_name = "opOptIntSeq";
const ::std::string iceC_Test_TestIntf_opOptLongSeq_name = "opOptLongSeq";
const ::std::string iceC_Test_TestIntf_opOptFloatSeq_name = "opOptFloatSeq";
const ::std::string iceC_Test_TestIntf_opOptDoubleSeq_name = "opOptDoubleSeq";
const ::std::string iceC_Test_TestIntf_opOptStringSeq_name = "opOptStringSeq";
const ::std::string iceC_Test_TestIntf_opOptESeq_name = "opOptESeq";
const ::std::string iceC_Test_TestIntf_opOptSSeq_name = "opOptSSeq";
const ::std::string iceC_Test_TestIntf_opOptDSeq_name = "opOptDSeq";
const ::std::string iceC_Test_TestIntf_opOptStringSeqSeq_name = "opOptStringSeqSeq";
const ::std::string iceC_Test_TestIntf_opOptByteBufferSeq_name = "opOptByteBufferSeq";
const ::std::string iceC_Test_TestIntf_opOptShortBufferSeq_name = "opOptShortBufferSeq";
const ::std::string iceC_Test_TestIntf_opOptIntBufferSeq_name = "opOptIntBufferSeq";
const ::std::string iceC_Test_TestIntf_opOptLongBufferSeq_name = "opOptLongBufferSeq";
const ::std::string iceC_Test_TestIntf_opOptFloatBufferSeq_name = "opOptFloatBufferSeq";
const ::std::string iceC_Test_TestIntf_opOptDoubleBufferSeq_name = "opOptDoubleBufferSeq";
const ::std::string iceC_Test_TestIntf_shutdown_name = "shutdown";

}

bool
Test::TestIntf::ice_isA(::std::string s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_TestIntf_ids, iceC_Test_TestIntf_ids + 2, s);
}

::std::vector<::std::string>
Test::TestIntf::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector<::std::string>(&iceC_Test_TestIntf_ids[0], &iceC_Test_TestIntf_ids[2]);
}

::std::string
Test::TestIntf::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::TestIntf::ice_staticId()
{
    static const ::std::string typeId = "::Test::TestIntf";
    return typeId;
}

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opCSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    CSeq iceP_inSeq;
    istr->readAll(iceP_inSeq);
    istr->readPendingValues();
    inS.endReadParams();
    CSeq iceP_outSeq;
    CSeq ret = this->opCSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_outSeq, ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opCArray(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    CArray iceP_inSeq;
    istr->readAll(iceP_inSeq);
    istr->readPendingValues();
    inS.endReadParams();
    CArray iceP_outSeq;
    CArray ret = this->opCArray(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_outSeq, ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opCList(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    CList iceP_inSeq;
    istr->readAll(iceP_inSeq);
    istr->readPendingValues();
    inS.endReadParams();
    CList iceP_outSeq;
    CList ret = this->opCList(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_outSeq, ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opBoolSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    BoolSeq iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    BoolSeq iceP_outSeq;
    BoolSeq ret = this->opBoolSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_outSeq, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opByteSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ByteSeq iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    ByteSeq iceP_outSeq;
    ByteSeq ret = this->opByteSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_outSeq, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opShortSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ShortSeq iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    ShortSeq iceP_outSeq;
    ShortSeq ret = this->opShortSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_outSeq, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opIntSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    IntSeq iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    IntSeq iceP_outSeq;
    IntSeq ret = this->opIntSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_outSeq, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opLongSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    LongSeq iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    LongSeq iceP_outSeq;
    LongSeq ret = this->opLongSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_outSeq, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opFloatSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    FloatSeq iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    FloatSeq iceP_outSeq;
    FloatSeq ret = this->opFloatSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_outSeq, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opDoubleSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    DoubleSeq iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    DoubleSeq iceP_outSeq;
    DoubleSeq ret = this->opDoubleSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_outSeq, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opStringSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    StringSeq iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    StringSeq iceP_outSeq;
    StringSeq ret = this->opStringSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_outSeq, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opESeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ESeq iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    ESeq iceP_outSeq;
    ESeq ret = this->opESeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_outSeq, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opSSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    SSeq iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    SSeq iceP_outSeq;
    SSeq ret = this->opSSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_outSeq, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opDSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    DSeq iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    DSeq iceP_outSeq;
    DSeq ret = this->opDSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_outSeq, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opStringSeqSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    StringSeqSeq iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    StringSeqSeq iceP_outSeq;
    StringSeqSeq ret = this->opStringSeqSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_outSeq, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opByteBufferSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ByteBuffer iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    ByteBuffer iceP_outSeq;
    ByteBuffer ret = this->opByteBufferSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_outSeq, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opShortBufferSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ShortBuffer iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    ShortBuffer iceP_outSeq;
    ShortBuffer ret = this->opShortBufferSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_outSeq, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opIntBufferSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    IntBuffer iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    IntBuffer iceP_outSeq;
    IntBuffer ret = this->opIntBufferSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_outSeq, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opLongBufferSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    LongBuffer iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    LongBuffer iceP_outSeq;
    LongBuffer ret = this->opLongBufferSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_outSeq, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opFloatBufferSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    FloatBuffer iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    FloatBuffer iceP_outSeq;
    FloatBuffer ret = this->opFloatBufferSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_outSeq, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opDoubleBufferSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    DoubleBuffer iceP_inSeq;
    istr->readAll(iceP_inSeq);
    inS.endReadParams();
    DoubleBuffer iceP_outSeq;
    DoubleBuffer ret = this->opDoubleBufferSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_outSeq, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opOptCSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    std::optional<CSeq> iceP_inSeq;
    istr->readAll({2}, iceP_inSeq);
    inS.endReadParams();
    std::optional<CSeq> iceP_outSeq;
    std::optional<CSeq> ret = this->opOptCSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll({1, 3}, ret, iceP_outSeq);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opOptCArray(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    std::optional<CArray> iceP_inSeq;
    istr->readAll({2}, iceP_inSeq);
    inS.endReadParams();
    std::optional<CArray> iceP_outSeq;
    std::optional<CArray> ret = this->opOptCArray(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll({1, 3}, ret, iceP_outSeq);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opOptCList(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    std::optional<CList> iceP_inSeq;
    istr->readAll({2}, iceP_inSeq);
    inS.endReadParams();
    std::optional<CList> iceP_outSeq;
    std::optional<CList> ret = this->opOptCList(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll({1, 3}, ret, iceP_outSeq);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opOptBoolSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    std::optional<BoolSeq> iceP_inSeq;
    istr->readAll({2}, iceP_inSeq);
    inS.endReadParams();
    std::optional<BoolSeq> iceP_outSeq;
    std::optional<BoolSeq> ret = this->opOptBoolSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll({1, 3}, ret, iceP_outSeq);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opOptByteSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    std::optional<ByteSeq> iceP_inSeq;
    istr->readAll({2}, iceP_inSeq);
    inS.endReadParams();
    std::optional<ByteSeq> iceP_outSeq;
    std::optional<ByteSeq> ret = this->opOptByteSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll({1, 3}, ret, iceP_outSeq);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opOptShortSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    std::optional<ShortSeq> iceP_inSeq;
    istr->readAll({2}, iceP_inSeq);
    inS.endReadParams();
    std::optional<ShortSeq> iceP_outSeq;
    std::optional<ShortSeq> ret = this->opOptShortSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll({1, 3}, ret, iceP_outSeq);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opOptIntSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    std::optional<IntSeq> iceP_inSeq;
    istr->readAll({2}, iceP_inSeq);
    inS.endReadParams();
    std::optional<IntSeq> iceP_outSeq;
    std::optional<IntSeq> ret = this->opOptIntSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll({1, 3}, ret, iceP_outSeq);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opOptLongSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    std::optional<LongSeq> iceP_inSeq;
    istr->readAll({2}, iceP_inSeq);
    inS.endReadParams();
    std::optional<LongSeq> iceP_outSeq;
    std::optional<LongSeq> ret = this->opOptLongSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll({1, 3}, ret, iceP_outSeq);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opOptFloatSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    std::optional<FloatSeq> iceP_inSeq;
    istr->readAll({2}, iceP_inSeq);
    inS.endReadParams();
    std::optional<FloatSeq> iceP_outSeq;
    std::optional<FloatSeq> ret = this->opOptFloatSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll({1, 3}, ret, iceP_outSeq);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opOptDoubleSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    std::optional<DoubleSeq> iceP_inSeq;
    istr->readAll({2}, iceP_inSeq);
    inS.endReadParams();
    std::optional<DoubleSeq> iceP_outSeq;
    std::optional<DoubleSeq> ret = this->opOptDoubleSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll({1, 3}, ret, iceP_outSeq);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opOptStringSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    std::optional<StringSeq> iceP_inSeq;
    istr->readAll({2}, iceP_inSeq);
    inS.endReadParams();
    std::optional<StringSeq> iceP_outSeq;
    std::optional<StringSeq> ret = this->opOptStringSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll({1, 3}, ret, iceP_outSeq);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opOptESeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    std::optional<ESeq> iceP_inSeq;
    istr->readAll({2}, iceP_inSeq);
    inS.endReadParams();
    std::optional<ESeq> iceP_outSeq;
    std::optional<ESeq> ret = this->opOptESeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll({1, 3}, ret, iceP_outSeq);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opOptSSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    std::optional<SSeq> iceP_inSeq;
    istr->readAll({2}, iceP_inSeq);
    inS.endReadParams();
    std::optional<SSeq> iceP_outSeq;
    std::optional<SSeq> ret = this->opOptSSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll({1, 3}, ret, iceP_outSeq);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opOptDSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    std::optional<DSeq> iceP_inSeq;
    istr->readAll({2}, iceP_inSeq);
    inS.endReadParams();
    std::optional<DSeq> iceP_outSeq;
    std::optional<DSeq> ret = this->opOptDSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll({1, 3}, ret, iceP_outSeq);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opOptStringSeqSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    std::optional<StringSeqSeq> iceP_inSeq;
    istr->readAll({2}, iceP_inSeq);
    inS.endReadParams();
    std::optional<StringSeqSeq> iceP_outSeq;
    std::optional<StringSeqSeq> ret = this->opOptStringSeqSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll({1, 3}, ret, iceP_outSeq);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opOptByteBufferSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    std::optional<ByteBuffer> iceP_inSeq;
    istr->readAll({2}, iceP_inSeq);
    inS.endReadParams();
    std::optional<ByteBuffer> iceP_outSeq;
    std::optional<ByteBuffer> ret = this->opOptByteBufferSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll({1, 3}, ret, iceP_outSeq);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opOptShortBufferSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    std::optional<ShortBuffer> iceP_inSeq;
    istr->readAll({2}, iceP_inSeq);
    inS.endReadParams();
    std::optional<ShortBuffer> iceP_outSeq;
    std::optional<ShortBuffer> ret = this->opOptShortBufferSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll({1, 3}, ret, iceP_outSeq);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opOptIntBufferSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    std::optional<IntBuffer> iceP_inSeq;
    istr->readAll({2}, iceP_inSeq);
    inS.endReadParams();
    std::optional<IntBuffer> iceP_outSeq;
    std::optional<IntBuffer> ret = this->opOptIntBufferSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll({1, 3}, ret, iceP_outSeq);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opOptLongBufferSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    std::optional<LongBuffer> iceP_inSeq;
    istr->readAll({2}, iceP_inSeq);
    inS.endReadParams();
    std::optional<LongBuffer> iceP_outSeq;
    std::optional<LongBuffer> ret = this->opOptLongBufferSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll({1, 3}, ret, iceP_outSeq);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opOptFloatBufferSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    std::optional<FloatBuffer> iceP_inSeq;
    istr->readAll({2}, iceP_inSeq);
    inS.endReadParams();
    std::optional<FloatBuffer> iceP_outSeq;
    std::optional<FloatBuffer> ret = this->opOptFloatBufferSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll({1, 3}, ret, iceP_outSeq);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_opOptDoubleBufferSeq(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    std::optional<DoubleBuffer> iceP_inSeq;
    istr->readAll({2}, iceP_inSeq);
    inS.endReadParams();
    std::optional<DoubleBuffer> iceP_outSeq;
    std::optional<DoubleBuffer> ret = this->opOptDoubleBufferSeq(::std::move(iceP_inSeq), iceP_outSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll({1, 3}, ret, iceP_outSeq);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_shutdown(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    this->shutdown(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_Test_TestIntf_ops, iceC_Test_TestIntf_ops + 47, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_Test_TestIntf_ops)
    {
        case 0:
        {
            return _iceD_ice_id(in, current);
        }
        case 1:
        {
            return _iceD_ice_ids(in, current);
        }
        case 2:
        {
            return _iceD_ice_isA(in, current);
        }
        case 3:
        {
            return _iceD_ice_ping(in, current);
        }
        case 4:
        {
            return _iceD_opBoolSeq(in, current);
        }
        case 5:
        {
            return _iceD_opByteBufferSeq(in, current);
        }
        case 6:
        {
            return _iceD_opByteSeq(in, current);
        }
        case 7:
        {
            return _iceD_opCArray(in, current);
        }
        case 8:
        {
            return _iceD_opCList(in, current);
        }
        case 9:
        {
            return _iceD_opCSeq(in, current);
        }
        case 10:
        {
            return _iceD_opDSeq(in, current);
        }
        case 11:
        {
            return _iceD_opDoubleBufferSeq(in, current);
        }
        case 12:
        {
            return _iceD_opDoubleSeq(in, current);
        }
        case 13:
        {
            return _iceD_opESeq(in, current);
        }
        case 14:
        {
            return _iceD_opFloatBufferSeq(in, current);
        }
        case 15:
        {
            return _iceD_opFloatSeq(in, current);
        }
        case 16:
        {
            return _iceD_opIntBufferSeq(in, current);
        }
        case 17:
        {
            return _iceD_opIntSeq(in, current);
        }
        case 18:
        {
            return _iceD_opLongBufferSeq(in, current);
        }
        case 19:
        {
            return _iceD_opLongSeq(in, current);
        }
        case 20:
        {
            return _iceD_opOptBoolSeq(in, current);
        }
        case 21:
        {
            return _iceD_opOptByteBufferSeq(in, current);
        }
        case 22:
        {
            return _iceD_opOptByteSeq(in, current);
        }
        case 23:
        {
            return _iceD_opOptCArray(in, current);
        }
        case 24:
        {
            return _iceD_opOptCList(in, current);
        }
        case 25:
        {
            return _iceD_opOptCSeq(in, current);
        }
        case 26:
        {
            return _iceD_opOptDSeq(in, current);
        }
        case 27:
        {
            return _iceD_opOptDoubleBufferSeq(in, current);
        }
        case 28:
        {
            return _iceD_opOptDoubleSeq(in, current);
        }
        case 29:
        {
            return _iceD_opOptESeq(in, current);
        }
        case 30:
        {
            return _iceD_opOptFloatBufferSeq(in, current);
        }
        case 31:
        {
            return _iceD_opOptFloatSeq(in, current);
        }
        case 32:
        {
            return _iceD_opOptIntBufferSeq(in, current);
        }
        case 33:
        {
            return _iceD_opOptIntSeq(in, current);
        }
        case 34:
        {
            return _iceD_opOptLongBufferSeq(in, current);
        }
        case 35:
        {
            return _iceD_opOptLongSeq(in, current);
        }
        case 36:
        {
            return _iceD_opOptSSeq(in, current);
        }
        case 37:
        {
            return _iceD_opOptShortBufferSeq(in, current);
        }
        case 38:
        {
            return _iceD_opOptShortSeq(in, current);
        }
        case 39:
        {
            return _iceD_opOptStringSeq(in, current);
        }
        case 40:
        {
            return _iceD_opOptStringSeqSeq(in, current);
        }
        case 41:
        {
            return _iceD_opSSeq(in, current);
        }
        case 42:
        {
            return _iceD_opShortBufferSeq(in, current);
        }
        case 43:
        {
            return _iceD_opShortSeq(in, current);
        }
        case 44:
        {
            return _iceD_opStringSeq(in, current);
        }
        case 45:
        {
            return _iceD_opStringSeqSeq(in, current);
        }
        case 46:
        {
            return _iceD_shutdown(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

Test::C::~C()
{
}

const ::std::string&
Test::C::ice_staticId()
{
    static const ::std::string typeId = "::Test::C";
    return typeId;
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opCSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpCSeqResult>>& outAsync, const CSeq& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opCSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opCSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
            ostr->writePendingValues();
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpCSeqResult v;
            istr->readAll(v.outSeq, v.returnValue);
            istr->readPendingValues();
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opCArray(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpCArrayResult>>& outAsync, const CArray& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opCArray_name);
    outAsync->invoke(iceC_Test_TestIntf_opCArray_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
            ostr->writePendingValues();
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpCArrayResult v;
            istr->readAll(v.outSeq, v.returnValue);
            istr->readPendingValues();
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opCList(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpCListResult>>& outAsync, const CList& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opCList_name);
    outAsync->invoke(iceC_Test_TestIntf_opCList_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
            ostr->writePendingValues();
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpCListResult v;
            istr->readAll(v.outSeq, v.returnValue);
            istr->readPendingValues();
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opBoolSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpBoolSeqResult>>& outAsync, const BoolSeq& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opBoolSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opBoolSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpBoolSeqResult v;
            istr->readAll(v.outSeq, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opByteSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpByteSeqResult>>& outAsync, const ByteSeq& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opByteSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opByteSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpByteSeqResult v;
            istr->readAll(v.outSeq, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opShortSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpShortSeqResult>>& outAsync, const ShortSeq& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opShortSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opShortSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpShortSeqResult v;
            istr->readAll(v.outSeq, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opIntSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpIntSeqResult>>& outAsync, const IntSeq& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opIntSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opIntSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpIntSeqResult v;
            istr->readAll(v.outSeq, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opLongSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpLongSeqResult>>& outAsync, const LongSeq& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opLongSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opLongSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpLongSeqResult v;
            istr->readAll(v.outSeq, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opFloatSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpFloatSeqResult>>& outAsync, const FloatSeq& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opFloatSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opFloatSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpFloatSeqResult v;
            istr->readAll(v.outSeq, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opDoubleSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpDoubleSeqResult>>& outAsync, const DoubleSeq& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opDoubleSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opDoubleSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpDoubleSeqResult v;
            istr->readAll(v.outSeq, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opStringSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpStringSeqResult>>& outAsync, const StringSeq& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opStringSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opStringSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpStringSeqResult v;
            istr->readAll(v.outSeq, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opESeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpESeqResult>>& outAsync, const ESeq& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opESeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opESeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpESeqResult v;
            istr->readAll(v.outSeq, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opSSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpSSeqResult>>& outAsync, const SSeq& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opSSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opSSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpSSeqResult v;
            istr->readAll(v.outSeq, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opDSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpDSeqResult>>& outAsync, const DSeq& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opDSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opDSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpDSeqResult v;
            istr->readAll(v.outSeq, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opStringSeqSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpStringSeqSeqResult>>& outAsync, const StringSeqSeq& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opStringSeqSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opStringSeqSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpStringSeqSeqResult v;
            istr->readAll(v.outSeq, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opByteBufferSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpByteBufferSeqResult>>& outAsync, const ByteBuffer& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opByteBufferSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opByteBufferSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpByteBufferSeqResult v;
            istr->readAll(v.outSeq, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opShortBufferSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpShortBufferSeqResult>>& outAsync, const ShortBuffer& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opShortBufferSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opShortBufferSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpShortBufferSeqResult v;
            istr->readAll(v.outSeq, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opIntBufferSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpIntBufferSeqResult>>& outAsync, const IntBuffer& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opIntBufferSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opIntBufferSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpIntBufferSeqResult v;
            istr->readAll(v.outSeq, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opLongBufferSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpLongBufferSeqResult>>& outAsync, const LongBuffer& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opLongBufferSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opLongBufferSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpLongBufferSeqResult v;
            istr->readAll(v.outSeq, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opFloatBufferSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpFloatBufferSeqResult>>& outAsync, const FloatBuffer& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opFloatBufferSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opFloatBufferSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpFloatBufferSeqResult v;
            istr->readAll(v.outSeq, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opDoubleBufferSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpDoubleBufferSeqResult>>& outAsync, const DoubleBuffer& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opDoubleBufferSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opDoubleBufferSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpDoubleBufferSeqResult v;
            istr->readAll(v.outSeq, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opOptCSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpOptCSeqResult>>& outAsync, const std::optional<CSeq>& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opOptCSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opOptCSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({2}, iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpOptCSeqResult v;
            istr->readAll({1, 3}, v.returnValue, v.outSeq);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opOptCArray(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpOptCArrayResult>>& outAsync, const std::optional<CArray>& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opOptCArray_name);
    outAsync->invoke(iceC_Test_TestIntf_opOptCArray_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({2}, iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpOptCArrayResult v;
            istr->readAll({1, 3}, v.returnValue, v.outSeq);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opOptCList(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpOptCListResult>>& outAsync, const std::optional<CList>& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opOptCList_name);
    outAsync->invoke(iceC_Test_TestIntf_opOptCList_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({2}, iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpOptCListResult v;
            istr->readAll({1, 3}, v.returnValue, v.outSeq);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opOptBoolSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpOptBoolSeqResult>>& outAsync, const std::optional<BoolSeq>& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opOptBoolSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opOptBoolSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({2}, iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpOptBoolSeqResult v;
            istr->readAll({1, 3}, v.returnValue, v.outSeq);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opOptByteSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpOptByteSeqResult>>& outAsync, const std::optional<ByteSeq>& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opOptByteSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opOptByteSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({2}, iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpOptByteSeqResult v;
            istr->readAll({1, 3}, v.returnValue, v.outSeq);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opOptShortSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpOptShortSeqResult>>& outAsync, const std::optional<ShortSeq>& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opOptShortSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opOptShortSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({2}, iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpOptShortSeqResult v;
            istr->readAll({1, 3}, v.returnValue, v.outSeq);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opOptIntSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpOptIntSeqResult>>& outAsync, const std::optional<IntSeq>& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opOptIntSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opOptIntSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({2}, iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpOptIntSeqResult v;
            istr->readAll({1, 3}, v.returnValue, v.outSeq);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opOptLongSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpOptLongSeqResult>>& outAsync, const std::optional<LongSeq>& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opOptLongSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opOptLongSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({2}, iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpOptLongSeqResult v;
            istr->readAll({1, 3}, v.returnValue, v.outSeq);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opOptFloatSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpOptFloatSeqResult>>& outAsync, const std::optional<FloatSeq>& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opOptFloatSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opOptFloatSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({2}, iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpOptFloatSeqResult v;
            istr->readAll({1, 3}, v.returnValue, v.outSeq);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opOptDoubleSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpOptDoubleSeqResult>>& outAsync, const std::optional<DoubleSeq>& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opOptDoubleSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opOptDoubleSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({2}, iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpOptDoubleSeqResult v;
            istr->readAll({1, 3}, v.returnValue, v.outSeq);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opOptStringSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpOptStringSeqResult>>& outAsync, const std::optional<StringSeq>& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opOptStringSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opOptStringSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({2}, iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpOptStringSeqResult v;
            istr->readAll({1, 3}, v.returnValue, v.outSeq);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opOptESeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpOptESeqResult>>& outAsync, const std::optional<ESeq>& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opOptESeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opOptESeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({2}, iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpOptESeqResult v;
            istr->readAll({1, 3}, v.returnValue, v.outSeq);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opOptSSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpOptSSeqResult>>& outAsync, const std::optional<SSeq>& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opOptSSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opOptSSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({2}, iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpOptSSeqResult v;
            istr->readAll({1, 3}, v.returnValue, v.outSeq);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opOptDSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpOptDSeqResult>>& outAsync, const std::optional<DSeq>& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opOptDSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opOptDSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({2}, iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpOptDSeqResult v;
            istr->readAll({1, 3}, v.returnValue, v.outSeq);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opOptStringSeqSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpOptStringSeqSeqResult>>& outAsync, const std::optional<StringSeqSeq>& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opOptStringSeqSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opOptStringSeqSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({2}, iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpOptStringSeqSeqResult v;
            istr->readAll({1, 3}, v.returnValue, v.outSeq);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opOptByteBufferSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpOptByteBufferSeqResult>>& outAsync, const std::optional<ByteBuffer>& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opOptByteBufferSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opOptByteBufferSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({2}, iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpOptByteBufferSeqResult v;
            istr->readAll({1, 3}, v.returnValue, v.outSeq);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opOptShortBufferSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpOptShortBufferSeqResult>>& outAsync, const std::optional<ShortBuffer>& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opOptShortBufferSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opOptShortBufferSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({2}, iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpOptShortBufferSeqResult v;
            istr->readAll({1, 3}, v.returnValue, v.outSeq);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opOptIntBufferSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpOptIntBufferSeqResult>>& outAsync, const std::optional<IntBuffer>& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opOptIntBufferSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opOptIntBufferSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({2}, iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpOptIntBufferSeqResult v;
            istr->readAll({1, 3}, v.returnValue, v.outSeq);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opOptLongBufferSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpOptLongBufferSeqResult>>& outAsync, const std::optional<LongBuffer>& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opOptLongBufferSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opOptLongBufferSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({2}, iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpOptLongBufferSeqResult v;
            istr->readAll({1, 3}, v.returnValue, v.outSeq);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opOptFloatBufferSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpOptFloatBufferSeqResult>>& outAsync, const std::optional<FloatBuffer>& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opOptFloatBufferSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opOptFloatBufferSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({2}, iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpOptFloatBufferSeqResult v;
            istr->readAll({1, 3}, v.returnValue, v.outSeq);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_opOptDoubleBufferSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpOptDoubleBufferSeqResult>>& outAsync, const std::optional<DoubleBuffer>& iceP_inSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_TestIntf_opOptDoubleBufferSeq_name);
    outAsync->invoke(iceC_Test_TestIntf_opOptDoubleBufferSeq_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({2}, iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            TestIntf::OpOptDoubleBufferSeqResult v;
            istr->readAll({1, 3}, v.returnValue, v.outSeq);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_shutdown(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_Test_TestIntf_shutdown_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

const ::std::string&
Test::TestIntfPrx::ice_staticId()
{
    return TestIntf::ice_staticId();
}

namespace Ice
{
}
