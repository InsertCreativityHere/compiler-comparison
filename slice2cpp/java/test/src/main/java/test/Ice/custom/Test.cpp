//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.8.0-alpha.0
//
// <auto-generated>
//
// Generated from file `Test.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#define ICE_BUILDING_GENERATED_CODE
#include <Test.h>
#include <Ice/AsyncResponseHandler.h>
#include <Ice/FactoryTable.h>
#include <Ice/OutgoingAsync.h>

#if defined(_MSC_VER)
#   pragma warning(disable:4458) // declaration of ... hides class member
#elif defined(__clang__)
#   pragma clang diagnostic ignored "-Wshadow"
#elif defined(__GNUC__)
#   pragma GCC diagnostic ignored "-Wshadow"
#endif

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION  != 30850
#       error Ice version mismatch: an exact match is required for beta generated code
#   endif
#endif

namespace
{
    const ::IceInternal::FactoryTableInit iceC_factoryTableInit;
    const ::IceInternal::DefaultValueFactoryInit<::Test::C> iceC_Test_C_init("::Test::C");
}

::Test::CSeq
Test::TestIntfPrx::opCSeq(const CSeq& iceP_inSeq, CSeq& iceP_outSeq, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<CSeq, CSeq>>(true, this, &TestIntfPrx::_iceI_opCSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::CSeq, ::Test::CSeq>>
Test::TestIntfPrx::opCSeqAsync(const CSeq& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<CSeq, CSeq>>(false, this, &TestIntfPrx::_iceI_opCSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opCSeqAsync(const CSeq& iceP_inSeq, ::std::function<void(::Test::CSeq, ::Test::CSeq)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<CSeq, CSeq>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<CSeq, CSeq>>(::std::move(responseCb), ::std::move(ex), ::std::move(sent), this, &Test::TestIntfPrx::_iceI_opCSeq, iceP_inSeq, context);
}

void
Test::TestIntfPrx::_iceI_opCSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<CSeq, CSeq>>>& outAsync, const CSeq& iceP_inSeq, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opCSeq";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
            ostr->writePendingValues();
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<CSeq, CSeq> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            istr->readPendingValues();
            return v;
        });
}

::Test::CArray
Test::TestIntfPrx::opCArray(const CArray& iceP_inSeq, CArray& iceP_outSeq, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<CArray, CArray>>(true, this, &TestIntfPrx::_iceI_opCArray, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::CArray, ::Test::CArray>>
Test::TestIntfPrx::opCArrayAsync(const CArray& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<CArray, CArray>>(false, this, &TestIntfPrx::_iceI_opCArray, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opCArrayAsync(const CArray& iceP_inSeq, ::std::function<void(::Test::CArray, ::Test::CArray)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<CArray, CArray>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<CArray, CArray>>(::std::move(responseCb), ::std::move(ex), ::std::move(sent), this, &Test::TestIntfPrx::_iceI_opCArray, iceP_inSeq, context);
}

void
Test::TestIntfPrx::_iceI_opCArray(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<CArray, CArray>>>& outAsync, const CArray& iceP_inSeq, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opCArray";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
            ostr->writePendingValues();
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<CArray, CArray> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            istr->readPendingValues();
            return v;
        });
}

::Test::CList
Test::TestIntfPrx::opCList(const CList& iceP_inSeq, CList& iceP_outSeq, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<CList, CList>>(true, this, &TestIntfPrx::_iceI_opCList, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::CList, ::Test::CList>>
Test::TestIntfPrx::opCListAsync(const CList& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<CList, CList>>(false, this, &TestIntfPrx::_iceI_opCList, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opCListAsync(const CList& iceP_inSeq, ::std::function<void(::Test::CList, ::Test::CList)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<CList, CList>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<CList, CList>>(::std::move(responseCb), ::std::move(ex), ::std::move(sent), this, &Test::TestIntfPrx::_iceI_opCList, iceP_inSeq, context);
}

void
Test::TestIntfPrx::_iceI_opCList(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<CList, CList>>>& outAsync, const CList& iceP_inSeq, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opCList";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
            ostr->writePendingValues();
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<CList, CList> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            istr->readPendingValues();
            return v;
        });
}

::Test::BoolSeq
Test::TestIntfPrx::opBoolSeq(const BoolSeq& iceP_inSeq, BoolSeq& iceP_outSeq, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<BoolSeq, BoolSeq>>(true, this, &TestIntfPrx::_iceI_opBoolSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::BoolSeq, ::Test::BoolSeq>>
Test::TestIntfPrx::opBoolSeqAsync(const BoolSeq& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<BoolSeq, BoolSeq>>(false, this, &TestIntfPrx::_iceI_opBoolSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opBoolSeqAsync(const BoolSeq& iceP_inSeq, ::std::function<void(::Test::BoolSeq, ::Test::BoolSeq)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<BoolSeq, BoolSeq>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<BoolSeq, BoolSeq>>(::std::move(responseCb), ::std::move(ex), ::std::move(sent), this, &Test::TestIntfPrx::_iceI_opBoolSeq, iceP_inSeq, context);
}

void
Test::TestIntfPrx::_iceI_opBoolSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<BoolSeq, BoolSeq>>>& outAsync, const BoolSeq& iceP_inSeq, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opBoolSeq";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<BoolSeq, BoolSeq> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::ByteSeq
Test::TestIntfPrx::opByteSeq(const ByteSeq& iceP_inSeq, ByteSeq& iceP_outSeq, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<ByteSeq, ByteSeq>>(true, this, &TestIntfPrx::_iceI_opByteSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::ByteSeq, ::Test::ByteSeq>>
Test::TestIntfPrx::opByteSeqAsync(const ByteSeq& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<ByteSeq, ByteSeq>>(false, this, &TestIntfPrx::_iceI_opByteSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opByteSeqAsync(const ByteSeq& iceP_inSeq, ::std::function<void(::Test::ByteSeq, ::Test::ByteSeq)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<ByteSeq, ByteSeq>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<ByteSeq, ByteSeq>>(::std::move(responseCb), ::std::move(ex), ::std::move(sent), this, &Test::TestIntfPrx::_iceI_opByteSeq, iceP_inSeq, context);
}

void
Test::TestIntfPrx::_iceI_opByteSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<ByteSeq, ByteSeq>>>& outAsync, const ByteSeq& iceP_inSeq, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opByteSeq";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<ByteSeq, ByteSeq> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::ShortSeq
Test::TestIntfPrx::opShortSeq(const ShortSeq& iceP_inSeq, ShortSeq& iceP_outSeq, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<ShortSeq, ShortSeq>>(true, this, &TestIntfPrx::_iceI_opShortSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::ShortSeq, ::Test::ShortSeq>>
Test::TestIntfPrx::opShortSeqAsync(const ShortSeq& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<ShortSeq, ShortSeq>>(false, this, &TestIntfPrx::_iceI_opShortSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opShortSeqAsync(const ShortSeq& iceP_inSeq, ::std::function<void(::Test::ShortSeq, ::Test::ShortSeq)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<ShortSeq, ShortSeq>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<ShortSeq, ShortSeq>>(::std::move(responseCb), ::std::move(ex), ::std::move(sent), this, &Test::TestIntfPrx::_iceI_opShortSeq, iceP_inSeq, context);
}

void
Test::TestIntfPrx::_iceI_opShortSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<ShortSeq, ShortSeq>>>& outAsync, const ShortSeq& iceP_inSeq, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opShortSeq";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<ShortSeq, ShortSeq> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::IntSeq
Test::TestIntfPrx::opIntSeq(const IntSeq& iceP_inSeq, IntSeq& iceP_outSeq, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<IntSeq, IntSeq>>(true, this, &TestIntfPrx::_iceI_opIntSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::IntSeq, ::Test::IntSeq>>
Test::TestIntfPrx::opIntSeqAsync(const IntSeq& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<IntSeq, IntSeq>>(false, this, &TestIntfPrx::_iceI_opIntSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opIntSeqAsync(const IntSeq& iceP_inSeq, ::std::function<void(::Test::IntSeq, ::Test::IntSeq)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<IntSeq, IntSeq>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<IntSeq, IntSeq>>(::std::move(responseCb), ::std::move(ex), ::std::move(sent), this, &Test::TestIntfPrx::_iceI_opIntSeq, iceP_inSeq, context);
}

void
Test::TestIntfPrx::_iceI_opIntSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<IntSeq, IntSeq>>>& outAsync, const IntSeq& iceP_inSeq, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opIntSeq";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<IntSeq, IntSeq> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::LongSeq
Test::TestIntfPrx::opLongSeq(const LongSeq& iceP_inSeq, LongSeq& iceP_outSeq, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<LongSeq, LongSeq>>(true, this, &TestIntfPrx::_iceI_opLongSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::LongSeq, ::Test::LongSeq>>
Test::TestIntfPrx::opLongSeqAsync(const LongSeq& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<LongSeq, LongSeq>>(false, this, &TestIntfPrx::_iceI_opLongSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opLongSeqAsync(const LongSeq& iceP_inSeq, ::std::function<void(::Test::LongSeq, ::Test::LongSeq)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<LongSeq, LongSeq>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<LongSeq, LongSeq>>(::std::move(responseCb), ::std::move(ex), ::std::move(sent), this, &Test::TestIntfPrx::_iceI_opLongSeq, iceP_inSeq, context);
}

void
Test::TestIntfPrx::_iceI_opLongSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<LongSeq, LongSeq>>>& outAsync, const LongSeq& iceP_inSeq, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opLongSeq";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<LongSeq, LongSeq> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::FloatSeq
Test::TestIntfPrx::opFloatSeq(const FloatSeq& iceP_inSeq, FloatSeq& iceP_outSeq, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<FloatSeq, FloatSeq>>(true, this, &TestIntfPrx::_iceI_opFloatSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::FloatSeq, ::Test::FloatSeq>>
Test::TestIntfPrx::opFloatSeqAsync(const FloatSeq& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<FloatSeq, FloatSeq>>(false, this, &TestIntfPrx::_iceI_opFloatSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opFloatSeqAsync(const FloatSeq& iceP_inSeq, ::std::function<void(::Test::FloatSeq, ::Test::FloatSeq)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<FloatSeq, FloatSeq>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<FloatSeq, FloatSeq>>(::std::move(responseCb), ::std::move(ex), ::std::move(sent), this, &Test::TestIntfPrx::_iceI_opFloatSeq, iceP_inSeq, context);
}

void
Test::TestIntfPrx::_iceI_opFloatSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<FloatSeq, FloatSeq>>>& outAsync, const FloatSeq& iceP_inSeq, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opFloatSeq";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<FloatSeq, FloatSeq> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::DoubleSeq
Test::TestIntfPrx::opDoubleSeq(const DoubleSeq& iceP_inSeq, DoubleSeq& iceP_outSeq, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<DoubleSeq, DoubleSeq>>(true, this, &TestIntfPrx::_iceI_opDoubleSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::DoubleSeq, ::Test::DoubleSeq>>
Test::TestIntfPrx::opDoubleSeqAsync(const DoubleSeq& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<DoubleSeq, DoubleSeq>>(false, this, &TestIntfPrx::_iceI_opDoubleSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opDoubleSeqAsync(const DoubleSeq& iceP_inSeq, ::std::function<void(::Test::DoubleSeq, ::Test::DoubleSeq)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<DoubleSeq, DoubleSeq>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<DoubleSeq, DoubleSeq>>(::std::move(responseCb), ::std::move(ex), ::std::move(sent), this, &Test::TestIntfPrx::_iceI_opDoubleSeq, iceP_inSeq, context);
}

void
Test::TestIntfPrx::_iceI_opDoubleSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<DoubleSeq, DoubleSeq>>>& outAsync, const DoubleSeq& iceP_inSeq, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opDoubleSeq";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<DoubleSeq, DoubleSeq> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::StringSeq
Test::TestIntfPrx::opStringSeq(const StringSeq& iceP_inSeq, StringSeq& iceP_outSeq, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<StringSeq, StringSeq>>(true, this, &TestIntfPrx::_iceI_opStringSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::StringSeq, ::Test::StringSeq>>
Test::TestIntfPrx::opStringSeqAsync(const StringSeq& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<StringSeq, StringSeq>>(false, this, &TestIntfPrx::_iceI_opStringSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opStringSeqAsync(const StringSeq& iceP_inSeq, ::std::function<void(::Test::StringSeq, ::Test::StringSeq)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<StringSeq, StringSeq>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<StringSeq, StringSeq>>(::std::move(responseCb), ::std::move(ex), ::std::move(sent), this, &Test::TestIntfPrx::_iceI_opStringSeq, iceP_inSeq, context);
}

void
Test::TestIntfPrx::_iceI_opStringSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<StringSeq, StringSeq>>>& outAsync, const StringSeq& iceP_inSeq, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opStringSeq";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<StringSeq, StringSeq> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::ESeq
Test::TestIntfPrx::opESeq(const ESeq& iceP_inSeq, ESeq& iceP_outSeq, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<ESeq, ESeq>>(true, this, &TestIntfPrx::_iceI_opESeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::ESeq, ::Test::ESeq>>
Test::TestIntfPrx::opESeqAsync(const ESeq& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<ESeq, ESeq>>(false, this, &TestIntfPrx::_iceI_opESeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opESeqAsync(const ESeq& iceP_inSeq, ::std::function<void(::Test::ESeq, ::Test::ESeq)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<ESeq, ESeq>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<ESeq, ESeq>>(::std::move(responseCb), ::std::move(ex), ::std::move(sent), this, &Test::TestIntfPrx::_iceI_opESeq, iceP_inSeq, context);
}

void
Test::TestIntfPrx::_iceI_opESeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<ESeq, ESeq>>>& outAsync, const ESeq& iceP_inSeq, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opESeq";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<ESeq, ESeq> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::SSeq
Test::TestIntfPrx::opSSeq(const SSeq& iceP_inSeq, SSeq& iceP_outSeq, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<SSeq, SSeq>>(true, this, &TestIntfPrx::_iceI_opSSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::SSeq, ::Test::SSeq>>
Test::TestIntfPrx::opSSeqAsync(const SSeq& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<SSeq, SSeq>>(false, this, &TestIntfPrx::_iceI_opSSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opSSeqAsync(const SSeq& iceP_inSeq, ::std::function<void(::Test::SSeq, ::Test::SSeq)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<SSeq, SSeq>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<SSeq, SSeq>>(::std::move(responseCb), ::std::move(ex), ::std::move(sent), this, &Test::TestIntfPrx::_iceI_opSSeq, iceP_inSeq, context);
}

void
Test::TestIntfPrx::_iceI_opSSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<SSeq, SSeq>>>& outAsync, const SSeq& iceP_inSeq, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opSSeq";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<SSeq, SSeq> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::DSeq
Test::TestIntfPrx::opDSeq(const DSeq& iceP_inSeq, DSeq& iceP_outSeq, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<DSeq, DSeq>>(true, this, &TestIntfPrx::_iceI_opDSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::DSeq, ::Test::DSeq>>
Test::TestIntfPrx::opDSeqAsync(const DSeq& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<DSeq, DSeq>>(false, this, &TestIntfPrx::_iceI_opDSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opDSeqAsync(const DSeq& iceP_inSeq, ::std::function<void(::Test::DSeq, ::Test::DSeq)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<DSeq, DSeq>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<DSeq, DSeq>>(::std::move(responseCb), ::std::move(ex), ::std::move(sent), this, &Test::TestIntfPrx::_iceI_opDSeq, iceP_inSeq, context);
}

void
Test::TestIntfPrx::_iceI_opDSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<DSeq, DSeq>>>& outAsync, const DSeq& iceP_inSeq, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opDSeq";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<DSeq, DSeq> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::StringSeqSeq
Test::TestIntfPrx::opStringSeqSeq(const StringSeqSeq& iceP_inSeq, StringSeqSeq& iceP_outSeq, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<StringSeqSeq, StringSeqSeq>>(true, this, &TestIntfPrx::_iceI_opStringSeqSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::StringSeqSeq, ::Test::StringSeqSeq>>
Test::TestIntfPrx::opStringSeqSeqAsync(const StringSeqSeq& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<StringSeqSeq, StringSeqSeq>>(false, this, &TestIntfPrx::_iceI_opStringSeqSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opStringSeqSeqAsync(const StringSeqSeq& iceP_inSeq, ::std::function<void(::Test::StringSeqSeq, ::Test::StringSeqSeq)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<StringSeqSeq, StringSeqSeq>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<StringSeqSeq, StringSeqSeq>>(::std::move(responseCb), ::std::move(ex), ::std::move(sent), this, &Test::TestIntfPrx::_iceI_opStringSeqSeq, iceP_inSeq, context);
}

void
Test::TestIntfPrx::_iceI_opStringSeqSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<StringSeqSeq, StringSeqSeq>>>& outAsync, const StringSeqSeq& iceP_inSeq, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opStringSeqSeq";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<StringSeqSeq, StringSeqSeq> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::ByteBuffer
Test::TestIntfPrx::opByteBufferSeq(const ByteBuffer& iceP_inSeq, ByteBuffer& iceP_outSeq, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<ByteBuffer, ByteBuffer>>(true, this, &TestIntfPrx::_iceI_opByteBufferSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::ByteBuffer, ::Test::ByteBuffer>>
Test::TestIntfPrx::opByteBufferSeqAsync(const ByteBuffer& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<ByteBuffer, ByteBuffer>>(false, this, &TestIntfPrx::_iceI_opByteBufferSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opByteBufferSeqAsync(const ByteBuffer& iceP_inSeq, ::std::function<void(::Test::ByteBuffer, ::Test::ByteBuffer)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<ByteBuffer, ByteBuffer>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<ByteBuffer, ByteBuffer>>(::std::move(responseCb), ::std::move(ex), ::std::move(sent), this, &Test::TestIntfPrx::_iceI_opByteBufferSeq, iceP_inSeq, context);
}

void
Test::TestIntfPrx::_iceI_opByteBufferSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<ByteBuffer, ByteBuffer>>>& outAsync, const ByteBuffer& iceP_inSeq, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opByteBufferSeq";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<ByteBuffer, ByteBuffer> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::ShortBuffer
Test::TestIntfPrx::opShortBufferSeq(const ShortBuffer& iceP_inSeq, ShortBuffer& iceP_outSeq, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<ShortBuffer, ShortBuffer>>(true, this, &TestIntfPrx::_iceI_opShortBufferSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::ShortBuffer, ::Test::ShortBuffer>>
Test::TestIntfPrx::opShortBufferSeqAsync(const ShortBuffer& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<ShortBuffer, ShortBuffer>>(false, this, &TestIntfPrx::_iceI_opShortBufferSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opShortBufferSeqAsync(const ShortBuffer& iceP_inSeq, ::std::function<void(::Test::ShortBuffer, ::Test::ShortBuffer)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<ShortBuffer, ShortBuffer>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<ShortBuffer, ShortBuffer>>(::std::move(responseCb), ::std::move(ex), ::std::move(sent), this, &Test::TestIntfPrx::_iceI_opShortBufferSeq, iceP_inSeq, context);
}

void
Test::TestIntfPrx::_iceI_opShortBufferSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<ShortBuffer, ShortBuffer>>>& outAsync, const ShortBuffer& iceP_inSeq, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opShortBufferSeq";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<ShortBuffer, ShortBuffer> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::IntBuffer
Test::TestIntfPrx::opIntBufferSeq(const IntBuffer& iceP_inSeq, IntBuffer& iceP_outSeq, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<IntBuffer, IntBuffer>>(true, this, &TestIntfPrx::_iceI_opIntBufferSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::IntBuffer, ::Test::IntBuffer>>
Test::TestIntfPrx::opIntBufferSeqAsync(const IntBuffer& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<IntBuffer, IntBuffer>>(false, this, &TestIntfPrx::_iceI_opIntBufferSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opIntBufferSeqAsync(const IntBuffer& iceP_inSeq, ::std::function<void(::Test::IntBuffer, ::Test::IntBuffer)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<IntBuffer, IntBuffer>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<IntBuffer, IntBuffer>>(::std::move(responseCb), ::std::move(ex), ::std::move(sent), this, &Test::TestIntfPrx::_iceI_opIntBufferSeq, iceP_inSeq, context);
}

void
Test::TestIntfPrx::_iceI_opIntBufferSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<IntBuffer, IntBuffer>>>& outAsync, const IntBuffer& iceP_inSeq, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opIntBufferSeq";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<IntBuffer, IntBuffer> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::LongBuffer
Test::TestIntfPrx::opLongBufferSeq(const LongBuffer& iceP_inSeq, LongBuffer& iceP_outSeq, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<LongBuffer, LongBuffer>>(true, this, &TestIntfPrx::_iceI_opLongBufferSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::LongBuffer, ::Test::LongBuffer>>
Test::TestIntfPrx::opLongBufferSeqAsync(const LongBuffer& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<LongBuffer, LongBuffer>>(false, this, &TestIntfPrx::_iceI_opLongBufferSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opLongBufferSeqAsync(const LongBuffer& iceP_inSeq, ::std::function<void(::Test::LongBuffer, ::Test::LongBuffer)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<LongBuffer, LongBuffer>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<LongBuffer, LongBuffer>>(::std::move(responseCb), ::std::move(ex), ::std::move(sent), this, &Test::TestIntfPrx::_iceI_opLongBufferSeq, iceP_inSeq, context);
}

void
Test::TestIntfPrx::_iceI_opLongBufferSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<LongBuffer, LongBuffer>>>& outAsync, const LongBuffer& iceP_inSeq, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opLongBufferSeq";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<LongBuffer, LongBuffer> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::FloatBuffer
Test::TestIntfPrx::opFloatBufferSeq(const FloatBuffer& iceP_inSeq, FloatBuffer& iceP_outSeq, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<FloatBuffer, FloatBuffer>>(true, this, &TestIntfPrx::_iceI_opFloatBufferSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::FloatBuffer, ::Test::FloatBuffer>>
Test::TestIntfPrx::opFloatBufferSeqAsync(const FloatBuffer& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<FloatBuffer, FloatBuffer>>(false, this, &TestIntfPrx::_iceI_opFloatBufferSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opFloatBufferSeqAsync(const FloatBuffer& iceP_inSeq, ::std::function<void(::Test::FloatBuffer, ::Test::FloatBuffer)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<FloatBuffer, FloatBuffer>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<FloatBuffer, FloatBuffer>>(::std::move(responseCb), ::std::move(ex), ::std::move(sent), this, &Test::TestIntfPrx::_iceI_opFloatBufferSeq, iceP_inSeq, context);
}

void
Test::TestIntfPrx::_iceI_opFloatBufferSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<FloatBuffer, FloatBuffer>>>& outAsync, const FloatBuffer& iceP_inSeq, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opFloatBufferSeq";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<FloatBuffer, FloatBuffer> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::DoubleBuffer
Test::TestIntfPrx::opDoubleBufferSeq(const DoubleBuffer& iceP_inSeq, DoubleBuffer& iceP_outSeq, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<DoubleBuffer, DoubleBuffer>>(true, this, &TestIntfPrx::_iceI_opDoubleBufferSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::DoubleBuffer, ::Test::DoubleBuffer>>
Test::TestIntfPrx::opDoubleBufferSeqAsync(const DoubleBuffer& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<DoubleBuffer, DoubleBuffer>>(false, this, &TestIntfPrx::_iceI_opDoubleBufferSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opDoubleBufferSeqAsync(const DoubleBuffer& iceP_inSeq, ::std::function<void(::Test::DoubleBuffer, ::Test::DoubleBuffer)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<DoubleBuffer, DoubleBuffer>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<DoubleBuffer, DoubleBuffer>>(::std::move(responseCb), ::std::move(ex), ::std::move(sent), this, &Test::TestIntfPrx::_iceI_opDoubleBufferSeq, iceP_inSeq, context);
}

void
Test::TestIntfPrx::_iceI_opDoubleBufferSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<DoubleBuffer, DoubleBuffer>>>& outAsync, const DoubleBuffer& iceP_inSeq, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opDoubleBufferSeq";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<DoubleBuffer, DoubleBuffer> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::std::optional<::Test::CSeq>
Test::TestIntfPrx::opOptCSeq(const ::std::optional<CSeq>& iceP_inSeq, ::std::optional<CSeq>& iceP_outSeq, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<::std::optional<CSeq>, ::std::optional<CSeq>>>(true, this, &TestIntfPrx::_iceI_opOptCSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::std::optional<::Test::CSeq>, ::std::optional<::Test::CSeq>>>
Test::TestIntfPrx::opOptCSeqAsync(const ::std::optional<CSeq>& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<::std::optional<CSeq>, ::std::optional<CSeq>>>(false, this, &TestIntfPrx::_iceI_opOptCSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opOptCSeqAsync(const ::std::optional<CSeq>& iceP_inSeq, ::std::function<void(::std::optional<::Test::CSeq>, ::std::optional<::Test::CSeq>)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<::std::optional<CSeq>, ::std::optional<CSeq>>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<::std::optional<CSeq>, ::std::optional<CSeq>>>(::std::move(responseCb), ::std::move(ex), ::std::move(sent), this, &Test::TestIntfPrx::_iceI_opOptCSeq, iceP_inSeq, context);
}

void
Test::TestIntfPrx::_iceI_opOptCSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::optional<CSeq>, ::std::optional<CSeq>>>>& outAsync, const ::std::optional<CSeq>& iceP_inSeq, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opOptCSeq";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({2}, iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<::std::optional<CSeq>, ::std::optional<CSeq>> v;
            istr->readAll({1, 3}, ::std::get<0>(v), ::std::get<1>(v));
            return v;
        });
}

::std::optional<::Test::CArray>
Test::TestIntfPrx::opOptCArray(const ::std::optional<CArray>& iceP_inSeq, ::std::optional<CArray>& iceP_outSeq, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<::std::optional<CArray>, ::std::optional<CArray>>>(true, this, &TestIntfPrx::_iceI_opOptCArray, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::std::optional<::Test::CArray>, ::std::optional<::Test::CArray>>>
Test::TestIntfPrx::opOptCArrayAsync(const ::std::optional<CArray>& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<::std::optional<CArray>, ::std::optional<CArray>>>(false, this, &TestIntfPrx::_iceI_opOptCArray, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opOptCArrayAsync(const ::std::optional<CArray>& iceP_inSeq, ::std::function<void(::std::optional<::Test::CArray>, ::std::optional<::Test::CArray>)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<::std::optional<CArray>, ::std::optional<CArray>>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<::std::optional<CArray>, ::std::optional<CArray>>>(::std::move(responseCb), ::std::move(ex), ::std::move(sent), this, &Test::TestIntfPrx::_iceI_opOptCArray, iceP_inSeq, context);
}

void
Test::TestIntfPrx::_iceI_opOptCArray(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::optional<CArray>, ::std::optional<CArray>>>>& outAsync, const ::std::optional<CArray>& iceP_inSeq, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opOptCArray";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({2}, iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<::std::optional<CArray>, ::std::optional<CArray>> v;
            istr->readAll({1, 3}, ::std::get<0>(v), ::std::get<1>(v));
            return v;
        });
}

::std::optional<::Test::CList>
Test::TestIntfPrx::opOptCList(const ::std::optional<CList>& iceP_inSeq, ::std::optional<CList>& iceP_outSeq, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<::std::optional<CList>, ::std::optional<CList>>>(true, this, &TestIntfPrx::_iceI_opOptCList, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::std::optional<::Test::CList>, ::std::optional<::Test::CList>>>
Test::TestIntfPrx::opOptCListAsync(const ::std::optional<CList>& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<::std::optional<CList>, ::std::optional<CList>>>(false, this, &TestIntfPrx::_iceI_opOptCList, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opOptCListAsync(const ::std::optional<CList>& iceP_inSeq, ::std::function<void(::std::optional<::Test::CList>, ::std::optional<::Test::CList>)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<::std::optional<CList>, ::std::optional<CList>>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<::std::optional<CList>, ::std::optional<CList>>>(::std::move(responseCb), ::std::move(ex), ::std::move(sent), this, &Test::TestIntfPrx::_iceI_opOptCList, iceP_inSeq, context);
}

void
Test::TestIntfPrx::_iceI_opOptCList(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::optional<CList>, ::std::optional<CList>>>>& outAsync, const ::std::optional<CList>& iceP_inSeq, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opOptCList";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({2}, iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<::std::optional<CList>, ::std::optional<CList>> v;
            istr->readAll({1, 3}, ::std::get<0>(v), ::std::get<1>(v));
            return v;
        });
}

::std::optional<::Test::BoolSeq>
Test::TestIntfPrx::opOptBoolSeq(const ::std::optional<BoolSeq>& iceP_inSeq, ::std::optional<BoolSeq>& iceP_outSeq, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<::std::optional<BoolSeq>, ::std::optional<BoolSeq>>>(true, this, &TestIntfPrx::_iceI_opOptBoolSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::std::optional<::Test::BoolSeq>, ::std::optional<::Test::BoolSeq>>>
Test::TestIntfPrx::opOptBoolSeqAsync(const ::std::optional<BoolSeq>& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<::std::optional<BoolSeq>, ::std::optional<BoolSeq>>>(false, this, &TestIntfPrx::_iceI_opOptBoolSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opOptBoolSeqAsync(const ::std::optional<BoolSeq>& iceP_inSeq, ::std::function<void(::std::optional<::Test::BoolSeq>, ::std::optional<::Test::BoolSeq>)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<::std::optional<BoolSeq>, ::std::optional<BoolSeq>>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<::std::optional<BoolSeq>, ::std::optional<BoolSeq>>>(::std::move(responseCb), ::std::move(ex), ::std::move(sent), this, &Test::TestIntfPrx::_iceI_opOptBoolSeq, iceP_inSeq, context);
}

void
Test::TestIntfPrx::_iceI_opOptBoolSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::optional<BoolSeq>, ::std::optional<BoolSeq>>>>& outAsync, const ::std::optional<BoolSeq>& iceP_inSeq, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opOptBoolSeq";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({2}, iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<::std::optional<BoolSeq>, ::std::optional<BoolSeq>> v;
            istr->readAll({1, 3}, ::std::get<0>(v), ::std::get<1>(v));
            return v;
        });
}

::std::optional<::Test::ByteSeq>
Test::TestIntfPrx::opOptByteSeq(const ::std::optional<ByteSeq>& iceP_inSeq, ::std::optional<ByteSeq>& iceP_outSeq, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<::std::optional<ByteSeq>, ::std::optional<ByteSeq>>>(true, this, &TestIntfPrx::_iceI_opOptByteSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::std::optional<::Test::ByteSeq>, ::std::optional<::Test::ByteSeq>>>
Test::TestIntfPrx::opOptByteSeqAsync(const ::std::optional<ByteSeq>& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<::std::optional<ByteSeq>, ::std::optional<ByteSeq>>>(false, this, &TestIntfPrx::_iceI_opOptByteSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opOptByteSeqAsync(const ::std::optional<ByteSeq>& iceP_inSeq, ::std::function<void(::std::optional<::Test::ByteSeq>, ::std::optional<::Test::ByteSeq>)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<::std::optional<ByteSeq>, ::std::optional<ByteSeq>>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<::std::optional<ByteSeq>, ::std::optional<ByteSeq>>>(::std::move(responseCb), ::std::move(ex), ::std::move(sent), this, &Test::TestIntfPrx::_iceI_opOptByteSeq, iceP_inSeq, context);
}

void
Test::TestIntfPrx::_iceI_opOptByteSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::optional<ByteSeq>, ::std::optional<ByteSeq>>>>& outAsync, const ::std::optional<ByteSeq>& iceP_inSeq, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opOptByteSeq";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({2}, iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<::std::optional<ByteSeq>, ::std::optional<ByteSeq>> v;
            istr->readAll({1, 3}, ::std::get<0>(v), ::std::get<1>(v));
            return v;
        });
}

::std::optional<::Test::ShortSeq>
Test::TestIntfPrx::opOptShortSeq(const ::std::optional<ShortSeq>& iceP_inSeq, ::std::optional<ShortSeq>& iceP_outSeq, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<::std::optional<ShortSeq>, ::std::optional<ShortSeq>>>(true, this, &TestIntfPrx::_iceI_opOptShortSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::std::optional<::Test::ShortSeq>, ::std::optional<::Test::ShortSeq>>>
Test::TestIntfPrx::opOptShortSeqAsync(const ::std::optional<ShortSeq>& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<::std::optional<ShortSeq>, ::std::optional<ShortSeq>>>(false, this, &TestIntfPrx::_iceI_opOptShortSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opOptShortSeqAsync(const ::std::optional<ShortSeq>& iceP_inSeq, ::std::function<void(::std::optional<::Test::ShortSeq>, ::std::optional<::Test::ShortSeq>)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<::std::optional<ShortSeq>, ::std::optional<ShortSeq>>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<::std::optional<ShortSeq>, ::std::optional<ShortSeq>>>(::std::move(responseCb), ::std::move(ex), ::std::move(sent), this, &Test::TestIntfPrx::_iceI_opOptShortSeq, iceP_inSeq, context);
}

void
Test::TestIntfPrx::_iceI_opOptShortSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::optional<ShortSeq>, ::std::optional<ShortSeq>>>>& outAsync, const ::std::optional<ShortSeq>& iceP_inSeq, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opOptShortSeq";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({2}, iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<::std::optional<ShortSeq>, ::std::optional<ShortSeq>> v;
            istr->readAll({1, 3}, ::std::get<0>(v), ::std::get<1>(v));
            return v;
        });
}

::std::optional<::Test::IntSeq>
Test::TestIntfPrx::opOptIntSeq(const ::std::optional<IntSeq>& iceP_inSeq, ::std::optional<IntSeq>& iceP_outSeq, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<::std::optional<IntSeq>, ::std::optional<IntSeq>>>(true, this, &TestIntfPrx::_iceI_opOptIntSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::std::optional<::Test::IntSeq>, ::std::optional<::Test::IntSeq>>>
Test::TestIntfPrx::opOptIntSeqAsync(const ::std::optional<IntSeq>& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<::std::optional<IntSeq>, ::std::optional<IntSeq>>>(false, this, &TestIntfPrx::_iceI_opOptIntSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opOptIntSeqAsync(const ::std::optional<IntSeq>& iceP_inSeq, ::std::function<void(::std::optional<::Test::IntSeq>, ::std::optional<::Test::IntSeq>)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<::std::optional<IntSeq>, ::std::optional<IntSeq>>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<::std::optional<IntSeq>, ::std::optional<IntSeq>>>(::std::move(responseCb), ::std::move(ex), ::std::move(sent), this, &Test::TestIntfPrx::_iceI_opOptIntSeq, iceP_inSeq, context);
}

void
Test::TestIntfPrx::_iceI_opOptIntSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::optional<IntSeq>, ::std::optional<IntSeq>>>>& outAsync, const ::std::optional<IntSeq>& iceP_inSeq, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opOptIntSeq";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({2}, iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<::std::optional<IntSeq>, ::std::optional<IntSeq>> v;
            istr->readAll({1, 3}, ::std::get<0>(v), ::std::get<1>(v));
            return v;
        });
}

::std::optional<::Test::LongSeq>
Test::TestIntfPrx::opOptLongSeq(const ::std::optional<LongSeq>& iceP_inSeq, ::std::optional<LongSeq>& iceP_outSeq, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<::std::optional<LongSeq>, ::std::optional<LongSeq>>>(true, this, &TestIntfPrx::_iceI_opOptLongSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::std::optional<::Test::LongSeq>, ::std::optional<::Test::LongSeq>>>
Test::TestIntfPrx::opOptLongSeqAsync(const ::std::optional<LongSeq>& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<::std::optional<LongSeq>, ::std::optional<LongSeq>>>(false, this, &TestIntfPrx::_iceI_opOptLongSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opOptLongSeqAsync(const ::std::optional<LongSeq>& iceP_inSeq, ::std::function<void(::std::optional<::Test::LongSeq>, ::std::optional<::Test::LongSeq>)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<::std::optional<LongSeq>, ::std::optional<LongSeq>>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<::std::optional<LongSeq>, ::std::optional<LongSeq>>>(::std::move(responseCb), ::std::move(ex), ::std::move(sent), this, &Test::TestIntfPrx::_iceI_opOptLongSeq, iceP_inSeq, context);
}

void
Test::TestIntfPrx::_iceI_opOptLongSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::optional<LongSeq>, ::std::optional<LongSeq>>>>& outAsync, const ::std::optional<LongSeq>& iceP_inSeq, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opOptLongSeq";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({2}, iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<::std::optional<LongSeq>, ::std::optional<LongSeq>> v;
            istr->readAll({1, 3}, ::std::get<0>(v), ::std::get<1>(v));
            return v;
        });
}

::std::optional<::Test::FloatSeq>
Test::TestIntfPrx::opOptFloatSeq(const ::std::optional<FloatSeq>& iceP_inSeq, ::std::optional<FloatSeq>& iceP_outSeq, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<::std::optional<FloatSeq>, ::std::optional<FloatSeq>>>(true, this, &TestIntfPrx::_iceI_opOptFloatSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::std::optional<::Test::FloatSeq>, ::std::optional<::Test::FloatSeq>>>
Test::TestIntfPrx::opOptFloatSeqAsync(const ::std::optional<FloatSeq>& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<::std::optional<FloatSeq>, ::std::optional<FloatSeq>>>(false, this, &TestIntfPrx::_iceI_opOptFloatSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opOptFloatSeqAsync(const ::std::optional<FloatSeq>& iceP_inSeq, ::std::function<void(::std::optional<::Test::FloatSeq>, ::std::optional<::Test::FloatSeq>)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<::std::optional<FloatSeq>, ::std::optional<FloatSeq>>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<::std::optional<FloatSeq>, ::std::optional<FloatSeq>>>(::std::move(responseCb), ::std::move(ex), ::std::move(sent), this, &Test::TestIntfPrx::_iceI_opOptFloatSeq, iceP_inSeq, context);
}

void
Test::TestIntfPrx::_iceI_opOptFloatSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::optional<FloatSeq>, ::std::optional<FloatSeq>>>>& outAsync, const ::std::optional<FloatSeq>& iceP_inSeq, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opOptFloatSeq";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({2}, iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<::std::optional<FloatSeq>, ::std::optional<FloatSeq>> v;
            istr->readAll({1, 3}, ::std::get<0>(v), ::std::get<1>(v));
            return v;
        });
}

::std::optional<::Test::DoubleSeq>
Test::TestIntfPrx::opOptDoubleSeq(const ::std::optional<DoubleSeq>& iceP_inSeq, ::std::optional<DoubleSeq>& iceP_outSeq, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<::std::optional<DoubleSeq>, ::std::optional<DoubleSeq>>>(true, this, &TestIntfPrx::_iceI_opOptDoubleSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::std::optional<::Test::DoubleSeq>, ::std::optional<::Test::DoubleSeq>>>
Test::TestIntfPrx::opOptDoubleSeqAsync(const ::std::optional<DoubleSeq>& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<::std::optional<DoubleSeq>, ::std::optional<DoubleSeq>>>(false, this, &TestIntfPrx::_iceI_opOptDoubleSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opOptDoubleSeqAsync(const ::std::optional<DoubleSeq>& iceP_inSeq, ::std::function<void(::std::optional<::Test::DoubleSeq>, ::std::optional<::Test::DoubleSeq>)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<::std::optional<DoubleSeq>, ::std::optional<DoubleSeq>>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<::std::optional<DoubleSeq>, ::std::optional<DoubleSeq>>>(::std::move(responseCb), ::std::move(ex), ::std::move(sent), this, &Test::TestIntfPrx::_iceI_opOptDoubleSeq, iceP_inSeq, context);
}

void
Test::TestIntfPrx::_iceI_opOptDoubleSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::optional<DoubleSeq>, ::std::optional<DoubleSeq>>>>& outAsync, const ::std::optional<DoubleSeq>& iceP_inSeq, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opOptDoubleSeq";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({2}, iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<::std::optional<DoubleSeq>, ::std::optional<DoubleSeq>> v;
            istr->readAll({1, 3}, ::std::get<0>(v), ::std::get<1>(v));
            return v;
        });
}

::std::optional<::Test::StringSeq>
Test::TestIntfPrx::opOptStringSeq(const ::std::optional<StringSeq>& iceP_inSeq, ::std::optional<StringSeq>& iceP_outSeq, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<::std::optional<StringSeq>, ::std::optional<StringSeq>>>(true, this, &TestIntfPrx::_iceI_opOptStringSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::std::optional<::Test::StringSeq>, ::std::optional<::Test::StringSeq>>>
Test::TestIntfPrx::opOptStringSeqAsync(const ::std::optional<StringSeq>& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<::std::optional<StringSeq>, ::std::optional<StringSeq>>>(false, this, &TestIntfPrx::_iceI_opOptStringSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opOptStringSeqAsync(const ::std::optional<StringSeq>& iceP_inSeq, ::std::function<void(::std::optional<::Test::StringSeq>, ::std::optional<::Test::StringSeq>)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<::std::optional<StringSeq>, ::std::optional<StringSeq>>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<::std::optional<StringSeq>, ::std::optional<StringSeq>>>(::std::move(responseCb), ::std::move(ex), ::std::move(sent), this, &Test::TestIntfPrx::_iceI_opOptStringSeq, iceP_inSeq, context);
}

void
Test::TestIntfPrx::_iceI_opOptStringSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::optional<StringSeq>, ::std::optional<StringSeq>>>>& outAsync, const ::std::optional<StringSeq>& iceP_inSeq, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opOptStringSeq";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({2}, iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<::std::optional<StringSeq>, ::std::optional<StringSeq>> v;
            istr->readAll({1, 3}, ::std::get<0>(v), ::std::get<1>(v));
            return v;
        });
}

::std::optional<::Test::ESeq>
Test::TestIntfPrx::opOptESeq(const ::std::optional<ESeq>& iceP_inSeq, ::std::optional<ESeq>& iceP_outSeq, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<::std::optional<ESeq>, ::std::optional<ESeq>>>(true, this, &TestIntfPrx::_iceI_opOptESeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::std::optional<::Test::ESeq>, ::std::optional<::Test::ESeq>>>
Test::TestIntfPrx::opOptESeqAsync(const ::std::optional<ESeq>& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<::std::optional<ESeq>, ::std::optional<ESeq>>>(false, this, &TestIntfPrx::_iceI_opOptESeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opOptESeqAsync(const ::std::optional<ESeq>& iceP_inSeq, ::std::function<void(::std::optional<::Test::ESeq>, ::std::optional<::Test::ESeq>)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<::std::optional<ESeq>, ::std::optional<ESeq>>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<::std::optional<ESeq>, ::std::optional<ESeq>>>(::std::move(responseCb), ::std::move(ex), ::std::move(sent), this, &Test::TestIntfPrx::_iceI_opOptESeq, iceP_inSeq, context);
}

void
Test::TestIntfPrx::_iceI_opOptESeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::optional<ESeq>, ::std::optional<ESeq>>>>& outAsync, const ::std::optional<ESeq>& iceP_inSeq, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opOptESeq";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({2}, iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<::std::optional<ESeq>, ::std::optional<ESeq>> v;
            istr->readAll({1, 3}, ::std::get<0>(v), ::std::get<1>(v));
            return v;
        });
}

::std::optional<::Test::SSeq>
Test::TestIntfPrx::opOptSSeq(const ::std::optional<SSeq>& iceP_inSeq, ::std::optional<SSeq>& iceP_outSeq, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<::std::optional<SSeq>, ::std::optional<SSeq>>>(true, this, &TestIntfPrx::_iceI_opOptSSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::std::optional<::Test::SSeq>, ::std::optional<::Test::SSeq>>>
Test::TestIntfPrx::opOptSSeqAsync(const ::std::optional<SSeq>& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<::std::optional<SSeq>, ::std::optional<SSeq>>>(false, this, &TestIntfPrx::_iceI_opOptSSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opOptSSeqAsync(const ::std::optional<SSeq>& iceP_inSeq, ::std::function<void(::std::optional<::Test::SSeq>, ::std::optional<::Test::SSeq>)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<::std::optional<SSeq>, ::std::optional<SSeq>>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<::std::optional<SSeq>, ::std::optional<SSeq>>>(::std::move(responseCb), ::std::move(ex), ::std::move(sent), this, &Test::TestIntfPrx::_iceI_opOptSSeq, iceP_inSeq, context);
}

void
Test::TestIntfPrx::_iceI_opOptSSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::optional<SSeq>, ::std::optional<SSeq>>>>& outAsync, const ::std::optional<SSeq>& iceP_inSeq, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opOptSSeq";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({2}, iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<::std::optional<SSeq>, ::std::optional<SSeq>> v;
            istr->readAll({1, 3}, ::std::get<0>(v), ::std::get<1>(v));
            return v;
        });
}

::std::optional<::Test::DSeq>
Test::TestIntfPrx::opOptDSeq(const ::std::optional<DSeq>& iceP_inSeq, ::std::optional<DSeq>& iceP_outSeq, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<::std::optional<DSeq>, ::std::optional<DSeq>>>(true, this, &TestIntfPrx::_iceI_opOptDSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::std::optional<::Test::DSeq>, ::std::optional<::Test::DSeq>>>
Test::TestIntfPrx::opOptDSeqAsync(const ::std::optional<DSeq>& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<::std::optional<DSeq>, ::std::optional<DSeq>>>(false, this, &TestIntfPrx::_iceI_opOptDSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opOptDSeqAsync(const ::std::optional<DSeq>& iceP_inSeq, ::std::function<void(::std::optional<::Test::DSeq>, ::std::optional<::Test::DSeq>)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<::std::optional<DSeq>, ::std::optional<DSeq>>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<::std::optional<DSeq>, ::std::optional<DSeq>>>(::std::move(responseCb), ::std::move(ex), ::std::move(sent), this, &Test::TestIntfPrx::_iceI_opOptDSeq, iceP_inSeq, context);
}

void
Test::TestIntfPrx::_iceI_opOptDSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::optional<DSeq>, ::std::optional<DSeq>>>>& outAsync, const ::std::optional<DSeq>& iceP_inSeq, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opOptDSeq";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({2}, iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<::std::optional<DSeq>, ::std::optional<DSeq>> v;
            istr->readAll({1, 3}, ::std::get<0>(v), ::std::get<1>(v));
            return v;
        });
}

::std::optional<::Test::StringSeqSeq>
Test::TestIntfPrx::opOptStringSeqSeq(const ::std::optional<StringSeqSeq>& iceP_inSeq, ::std::optional<StringSeqSeq>& iceP_outSeq, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<::std::optional<StringSeqSeq>, ::std::optional<StringSeqSeq>>>(true, this, &TestIntfPrx::_iceI_opOptStringSeqSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::std::optional<::Test::StringSeqSeq>, ::std::optional<::Test::StringSeqSeq>>>
Test::TestIntfPrx::opOptStringSeqSeqAsync(const ::std::optional<StringSeqSeq>& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<::std::optional<StringSeqSeq>, ::std::optional<StringSeqSeq>>>(false, this, &TestIntfPrx::_iceI_opOptStringSeqSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opOptStringSeqSeqAsync(const ::std::optional<StringSeqSeq>& iceP_inSeq, ::std::function<void(::std::optional<::Test::StringSeqSeq>, ::std::optional<::Test::StringSeqSeq>)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<::std::optional<StringSeqSeq>, ::std::optional<StringSeqSeq>>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<::std::optional<StringSeqSeq>, ::std::optional<StringSeqSeq>>>(::std::move(responseCb), ::std::move(ex), ::std::move(sent), this, &Test::TestIntfPrx::_iceI_opOptStringSeqSeq, iceP_inSeq, context);
}

void
Test::TestIntfPrx::_iceI_opOptStringSeqSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::optional<StringSeqSeq>, ::std::optional<StringSeqSeq>>>>& outAsync, const ::std::optional<StringSeqSeq>& iceP_inSeq, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opOptStringSeqSeq";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({2}, iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<::std::optional<StringSeqSeq>, ::std::optional<StringSeqSeq>> v;
            istr->readAll({1, 3}, ::std::get<0>(v), ::std::get<1>(v));
            return v;
        });
}

::std::optional<::Test::ByteBuffer>
Test::TestIntfPrx::opOptByteBufferSeq(const ::std::optional<ByteBuffer>& iceP_inSeq, ::std::optional<ByteBuffer>& iceP_outSeq, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<::std::optional<ByteBuffer>, ::std::optional<ByteBuffer>>>(true, this, &TestIntfPrx::_iceI_opOptByteBufferSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::std::optional<::Test::ByteBuffer>, ::std::optional<::Test::ByteBuffer>>>
Test::TestIntfPrx::opOptByteBufferSeqAsync(const ::std::optional<ByteBuffer>& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<::std::optional<ByteBuffer>, ::std::optional<ByteBuffer>>>(false, this, &TestIntfPrx::_iceI_opOptByteBufferSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opOptByteBufferSeqAsync(const ::std::optional<ByteBuffer>& iceP_inSeq, ::std::function<void(::std::optional<::Test::ByteBuffer>, ::std::optional<::Test::ByteBuffer>)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<::std::optional<ByteBuffer>, ::std::optional<ByteBuffer>>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<::std::optional<ByteBuffer>, ::std::optional<ByteBuffer>>>(::std::move(responseCb), ::std::move(ex), ::std::move(sent), this, &Test::TestIntfPrx::_iceI_opOptByteBufferSeq, iceP_inSeq, context);
}

void
Test::TestIntfPrx::_iceI_opOptByteBufferSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::optional<ByteBuffer>, ::std::optional<ByteBuffer>>>>& outAsync, const ::std::optional<ByteBuffer>& iceP_inSeq, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opOptByteBufferSeq";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({2}, iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<::std::optional<ByteBuffer>, ::std::optional<ByteBuffer>> v;
            istr->readAll({1, 3}, ::std::get<0>(v), ::std::get<1>(v));
            return v;
        });
}

::std::optional<::Test::ShortBuffer>
Test::TestIntfPrx::opOptShortBufferSeq(const ::std::optional<ShortBuffer>& iceP_inSeq, ::std::optional<ShortBuffer>& iceP_outSeq, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<::std::optional<ShortBuffer>, ::std::optional<ShortBuffer>>>(true, this, &TestIntfPrx::_iceI_opOptShortBufferSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::std::optional<::Test::ShortBuffer>, ::std::optional<::Test::ShortBuffer>>>
Test::TestIntfPrx::opOptShortBufferSeqAsync(const ::std::optional<ShortBuffer>& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<::std::optional<ShortBuffer>, ::std::optional<ShortBuffer>>>(false, this, &TestIntfPrx::_iceI_opOptShortBufferSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opOptShortBufferSeqAsync(const ::std::optional<ShortBuffer>& iceP_inSeq, ::std::function<void(::std::optional<::Test::ShortBuffer>, ::std::optional<::Test::ShortBuffer>)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<::std::optional<ShortBuffer>, ::std::optional<ShortBuffer>>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<::std::optional<ShortBuffer>, ::std::optional<ShortBuffer>>>(::std::move(responseCb), ::std::move(ex), ::std::move(sent), this, &Test::TestIntfPrx::_iceI_opOptShortBufferSeq, iceP_inSeq, context);
}

void
Test::TestIntfPrx::_iceI_opOptShortBufferSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::optional<ShortBuffer>, ::std::optional<ShortBuffer>>>>& outAsync, const ::std::optional<ShortBuffer>& iceP_inSeq, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opOptShortBufferSeq";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({2}, iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<::std::optional<ShortBuffer>, ::std::optional<ShortBuffer>> v;
            istr->readAll({1, 3}, ::std::get<0>(v), ::std::get<1>(v));
            return v;
        });
}

::std::optional<::Test::IntBuffer>
Test::TestIntfPrx::opOptIntBufferSeq(const ::std::optional<IntBuffer>& iceP_inSeq, ::std::optional<IntBuffer>& iceP_outSeq, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<::std::optional<IntBuffer>, ::std::optional<IntBuffer>>>(true, this, &TestIntfPrx::_iceI_opOptIntBufferSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::std::optional<::Test::IntBuffer>, ::std::optional<::Test::IntBuffer>>>
Test::TestIntfPrx::opOptIntBufferSeqAsync(const ::std::optional<IntBuffer>& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<::std::optional<IntBuffer>, ::std::optional<IntBuffer>>>(false, this, &TestIntfPrx::_iceI_opOptIntBufferSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opOptIntBufferSeqAsync(const ::std::optional<IntBuffer>& iceP_inSeq, ::std::function<void(::std::optional<::Test::IntBuffer>, ::std::optional<::Test::IntBuffer>)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<::std::optional<IntBuffer>, ::std::optional<IntBuffer>>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<::std::optional<IntBuffer>, ::std::optional<IntBuffer>>>(::std::move(responseCb), ::std::move(ex), ::std::move(sent), this, &Test::TestIntfPrx::_iceI_opOptIntBufferSeq, iceP_inSeq, context);
}

void
Test::TestIntfPrx::_iceI_opOptIntBufferSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::optional<IntBuffer>, ::std::optional<IntBuffer>>>>& outAsync, const ::std::optional<IntBuffer>& iceP_inSeq, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opOptIntBufferSeq";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({2}, iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<::std::optional<IntBuffer>, ::std::optional<IntBuffer>> v;
            istr->readAll({1, 3}, ::std::get<0>(v), ::std::get<1>(v));
            return v;
        });
}

::std::optional<::Test::LongBuffer>
Test::TestIntfPrx::opOptLongBufferSeq(const ::std::optional<LongBuffer>& iceP_inSeq, ::std::optional<LongBuffer>& iceP_outSeq, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<::std::optional<LongBuffer>, ::std::optional<LongBuffer>>>(true, this, &TestIntfPrx::_iceI_opOptLongBufferSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::std::optional<::Test::LongBuffer>, ::std::optional<::Test::LongBuffer>>>
Test::TestIntfPrx::opOptLongBufferSeqAsync(const ::std::optional<LongBuffer>& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<::std::optional<LongBuffer>, ::std::optional<LongBuffer>>>(false, this, &TestIntfPrx::_iceI_opOptLongBufferSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opOptLongBufferSeqAsync(const ::std::optional<LongBuffer>& iceP_inSeq, ::std::function<void(::std::optional<::Test::LongBuffer>, ::std::optional<::Test::LongBuffer>)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<::std::optional<LongBuffer>, ::std::optional<LongBuffer>>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<::std::optional<LongBuffer>, ::std::optional<LongBuffer>>>(::std::move(responseCb), ::std::move(ex), ::std::move(sent), this, &Test::TestIntfPrx::_iceI_opOptLongBufferSeq, iceP_inSeq, context);
}

void
Test::TestIntfPrx::_iceI_opOptLongBufferSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::optional<LongBuffer>, ::std::optional<LongBuffer>>>>& outAsync, const ::std::optional<LongBuffer>& iceP_inSeq, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opOptLongBufferSeq";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({2}, iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<::std::optional<LongBuffer>, ::std::optional<LongBuffer>> v;
            istr->readAll({1, 3}, ::std::get<0>(v), ::std::get<1>(v));
            return v;
        });
}

::std::optional<::Test::FloatBuffer>
Test::TestIntfPrx::opOptFloatBufferSeq(const ::std::optional<FloatBuffer>& iceP_inSeq, ::std::optional<FloatBuffer>& iceP_outSeq, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<::std::optional<FloatBuffer>, ::std::optional<FloatBuffer>>>(true, this, &TestIntfPrx::_iceI_opOptFloatBufferSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::std::optional<::Test::FloatBuffer>, ::std::optional<::Test::FloatBuffer>>>
Test::TestIntfPrx::opOptFloatBufferSeqAsync(const ::std::optional<FloatBuffer>& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<::std::optional<FloatBuffer>, ::std::optional<FloatBuffer>>>(false, this, &TestIntfPrx::_iceI_opOptFloatBufferSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opOptFloatBufferSeqAsync(const ::std::optional<FloatBuffer>& iceP_inSeq, ::std::function<void(::std::optional<::Test::FloatBuffer>, ::std::optional<::Test::FloatBuffer>)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<::std::optional<FloatBuffer>, ::std::optional<FloatBuffer>>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<::std::optional<FloatBuffer>, ::std::optional<FloatBuffer>>>(::std::move(responseCb), ::std::move(ex), ::std::move(sent), this, &Test::TestIntfPrx::_iceI_opOptFloatBufferSeq, iceP_inSeq, context);
}

void
Test::TestIntfPrx::_iceI_opOptFloatBufferSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::optional<FloatBuffer>, ::std::optional<FloatBuffer>>>>& outAsync, const ::std::optional<FloatBuffer>& iceP_inSeq, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opOptFloatBufferSeq";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({2}, iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<::std::optional<FloatBuffer>, ::std::optional<FloatBuffer>> v;
            istr->readAll({1, 3}, ::std::get<0>(v), ::std::get<1>(v));
            return v;
        });
}

::std::optional<::Test::DoubleBuffer>
Test::TestIntfPrx::opOptDoubleBufferSeq(const ::std::optional<DoubleBuffer>& iceP_inSeq, ::std::optional<DoubleBuffer>& iceP_outSeq, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<::std::optional<DoubleBuffer>, ::std::optional<DoubleBuffer>>>(true, this, &TestIntfPrx::_iceI_opOptDoubleBufferSeq, iceP_inSeq, context).get();
    iceP_outSeq = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::std::optional<::Test::DoubleBuffer>, ::std::optional<::Test::DoubleBuffer>>>
Test::TestIntfPrx::opOptDoubleBufferSeqAsync(const ::std::optional<DoubleBuffer>& iceP_inSeq, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<::std::optional<DoubleBuffer>, ::std::optional<DoubleBuffer>>>(false, this, &TestIntfPrx::_iceI_opOptDoubleBufferSeq, iceP_inSeq, context);
}

::std::function<void()>
Test::TestIntfPrx::opOptDoubleBufferSeqAsync(const ::std::optional<DoubleBuffer>& iceP_inSeq, ::std::function<void(::std::optional<::Test::DoubleBuffer>, ::std::optional<::Test::DoubleBuffer>)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<::std::optional<DoubleBuffer>, ::std::optional<DoubleBuffer>>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<::std::optional<DoubleBuffer>, ::std::optional<DoubleBuffer>>>(::std::move(responseCb), ::std::move(ex), ::std::move(sent), this, &Test::TestIntfPrx::_iceI_opOptDoubleBufferSeq, iceP_inSeq, context);
}

void
Test::TestIntfPrx::_iceI_opOptDoubleBufferSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::optional<DoubleBuffer>, ::std::optional<DoubleBuffer>>>>& outAsync, const ::std::optional<DoubleBuffer>& iceP_inSeq, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opOptDoubleBufferSeq";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({2}, iceP_inSeq);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<::std::optional<DoubleBuffer>, ::std::optional<DoubleBuffer>> v;
            istr->readAll({1, 3}, ::std::get<0>(v), ::std::get<1>(v));
            return v;
        });
}

void
Test::TestIntfPrx::shutdown(const ::Ice::Context& context) const
{
    ::IceInternal::makePromiseOutgoing<void>(true, this, &TestIntfPrx::_iceI_shutdown, context).get();
}

::std::future<void>
Test::TestIntfPrx::shutdownAsync(const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<void>(false, this, &TestIntfPrx::_iceI_shutdown, context);
}

::std::function<void()>
Test::TestIntfPrx::shutdownAsync(::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<void>(::std::move(response), ::std::move(ex), ::std::move(sent), this, &Test::TestIntfPrx::_iceI_shutdown, context);
}

void
Test::TestIntfPrx::_iceI_shutdown(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "shutdown";

    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}

::std::string_view
Test::TestIntfPrx::ice_staticId() noexcept
{
    static constexpr ::std::string_view typeId = "::Test::TestIntf";
    return typeId;
}

::std::string
Test::C::ice_id() const
{
    return ::std::string{ice_staticId()};
}

::std::string_view
Test::C::ice_staticId() noexcept
{
    static constexpr ::std::string_view typeId = "::Test::C";
    return typeId;
}

::std::shared_ptr<::Ice::Value>
Test::C::_iceCloneImpl() const
{
    return CloneEnabler<C>::clone(*this);
}

void
Test::C::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ostr->endSlice();
}

void
Test::C::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    istr->endSlice();
}

::std::vector<::std::string>
Test::TestIntf::ice_ids(const ::Ice::Current&) const
{
    static const ::std::vector<::std::string> allTypeIds = {"::Ice::Object", "::Test::TestIntf"};
    return allTypeIds;
}

::std::string
Test::TestIntf::ice_id(const ::Ice::Current&) const
{
    return ::std::string{ice_staticId()};
}

::std::string_view
Test::TestIntf::ice_staticId() noexcept
{
    static constexpr ::std::string_view typeId = "::Test::TestIntf";
    return typeId;
}

/// \cond INTERNAL
void
Test::TestIntf::_iceD_opCSeq(::Ice::IncomingRequest& request, ::std::function<void(::Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(::Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    CSeq iceP_inSeq;
    istr->readAll(iceP_inSeq);
    istr->readPendingValues();
    istr->endEncapsulation();
    CSeq iceP_outSeq;
    CSeq ret = this->opCSeq(::std::move(iceP_inSeq), iceP_outSeq, request.current());
    sendResponse(::Ice::makeOutgoingResponse([&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_outSeq, ret);
            ostr->writePendingValues();
        },
        request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_opCArray(::Ice::IncomingRequest& request, ::std::function<void(::Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(::Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    CArray iceP_inSeq;
    istr->readAll(iceP_inSeq);
    istr->readPendingValues();
    istr->endEncapsulation();
    CArray iceP_outSeq;
    CArray ret = this->opCArray(::std::move(iceP_inSeq), iceP_outSeq, request.current());
    sendResponse(::Ice::makeOutgoingResponse([&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_outSeq, ret);
            ostr->writePendingValues();
        },
        request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_opCList(::Ice::IncomingRequest& request, ::std::function<void(::Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(::Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    CList iceP_inSeq;
    istr->readAll(iceP_inSeq);
    istr->readPendingValues();
    istr->endEncapsulation();
    CList iceP_outSeq;
    CList ret = this->opCList(::std::move(iceP_inSeq), iceP_outSeq, request.current());
    sendResponse(::Ice::makeOutgoingResponse([&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_outSeq, ret);
            ostr->writePendingValues();
        },
        request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_opBoolSeq(::Ice::IncomingRequest& request, ::std::function<void(::Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(::Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    BoolSeq iceP_inSeq;
    istr->readAll(iceP_inSeq);
    istr->endEncapsulation();
    BoolSeq iceP_outSeq;
    BoolSeq ret = this->opBoolSeq(::std::move(iceP_inSeq), iceP_outSeq, request.current());
    sendResponse(::Ice::makeOutgoingResponse([&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_outSeq, ret);
        },
        request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_opByteSeq(::Ice::IncomingRequest& request, ::std::function<void(::Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(::Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    ByteSeq iceP_inSeq;
    istr->readAll(iceP_inSeq);
    istr->endEncapsulation();
    ByteSeq iceP_outSeq;
    ByteSeq ret = this->opByteSeq(::std::move(iceP_inSeq), iceP_outSeq, request.current());
    sendResponse(::Ice::makeOutgoingResponse([&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_outSeq, ret);
        },
        request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_opShortSeq(::Ice::IncomingRequest& request, ::std::function<void(::Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(::Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    ShortSeq iceP_inSeq;
    istr->readAll(iceP_inSeq);
    istr->endEncapsulation();
    ShortSeq iceP_outSeq;
    ShortSeq ret = this->opShortSeq(::std::move(iceP_inSeq), iceP_outSeq, request.current());
    sendResponse(::Ice::makeOutgoingResponse([&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_outSeq, ret);
        },
        request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_opIntSeq(::Ice::IncomingRequest& request, ::std::function<void(::Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(::Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    IntSeq iceP_inSeq;
    istr->readAll(iceP_inSeq);
    istr->endEncapsulation();
    IntSeq iceP_outSeq;
    IntSeq ret = this->opIntSeq(::std::move(iceP_inSeq), iceP_outSeq, request.current());
    sendResponse(::Ice::makeOutgoingResponse([&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_outSeq, ret);
        },
        request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_opLongSeq(::Ice::IncomingRequest& request, ::std::function<void(::Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(::Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    LongSeq iceP_inSeq;
    istr->readAll(iceP_inSeq);
    istr->endEncapsulation();
    LongSeq iceP_outSeq;
    LongSeq ret = this->opLongSeq(::std::move(iceP_inSeq), iceP_outSeq, request.current());
    sendResponse(::Ice::makeOutgoingResponse([&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_outSeq, ret);
        },
        request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_opFloatSeq(::Ice::IncomingRequest& request, ::std::function<void(::Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(::Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    FloatSeq iceP_inSeq;
    istr->readAll(iceP_inSeq);
    istr->endEncapsulation();
    FloatSeq iceP_outSeq;
    FloatSeq ret = this->opFloatSeq(::std::move(iceP_inSeq), iceP_outSeq, request.current());
    sendResponse(::Ice::makeOutgoingResponse([&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_outSeq, ret);
        },
        request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_opDoubleSeq(::Ice::IncomingRequest& request, ::std::function<void(::Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(::Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    DoubleSeq iceP_inSeq;
    istr->readAll(iceP_inSeq);
    istr->endEncapsulation();
    DoubleSeq iceP_outSeq;
    DoubleSeq ret = this->opDoubleSeq(::std::move(iceP_inSeq), iceP_outSeq, request.current());
    sendResponse(::Ice::makeOutgoingResponse([&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_outSeq, ret);
        },
        request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_opStringSeq(::Ice::IncomingRequest& request, ::std::function<void(::Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(::Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    StringSeq iceP_inSeq;
    istr->readAll(iceP_inSeq);
    istr->endEncapsulation();
    StringSeq iceP_outSeq;
    StringSeq ret = this->opStringSeq(::std::move(iceP_inSeq), iceP_outSeq, request.current());
    sendResponse(::Ice::makeOutgoingResponse([&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_outSeq, ret);
        },
        request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_opESeq(::Ice::IncomingRequest& request, ::std::function<void(::Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(::Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    ESeq iceP_inSeq;
    istr->readAll(iceP_inSeq);
    istr->endEncapsulation();
    ESeq iceP_outSeq;
    ESeq ret = this->opESeq(::std::move(iceP_inSeq), iceP_outSeq, request.current());
    sendResponse(::Ice::makeOutgoingResponse([&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_outSeq, ret);
        },
        request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_opSSeq(::Ice::IncomingRequest& request, ::std::function<void(::Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(::Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    SSeq iceP_inSeq;
    istr->readAll(iceP_inSeq);
    istr->endEncapsulation();
    SSeq iceP_outSeq;
    SSeq ret = this->opSSeq(::std::move(iceP_inSeq), iceP_outSeq, request.current());
    sendResponse(::Ice::makeOutgoingResponse([&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_outSeq, ret);
        },
        request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_opDSeq(::Ice::IncomingRequest& request, ::std::function<void(::Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(::Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    DSeq iceP_inSeq;
    istr->readAll(iceP_inSeq);
    istr->endEncapsulation();
    DSeq iceP_outSeq;
    DSeq ret = this->opDSeq(::std::move(iceP_inSeq), iceP_outSeq, request.current());
    sendResponse(::Ice::makeOutgoingResponse([&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_outSeq, ret);
        },
        request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_opStringSeqSeq(::Ice::IncomingRequest& request, ::std::function<void(::Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(::Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    StringSeqSeq iceP_inSeq;
    istr->readAll(iceP_inSeq);
    istr->endEncapsulation();
    StringSeqSeq iceP_outSeq;
    StringSeqSeq ret = this->opStringSeqSeq(::std::move(iceP_inSeq), iceP_outSeq, request.current());
    sendResponse(::Ice::makeOutgoingResponse([&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_outSeq, ret);
        },
        request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_opByteBufferSeq(::Ice::IncomingRequest& request, ::std::function<void(::Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(::Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    ByteBuffer iceP_inSeq;
    istr->readAll(iceP_inSeq);
    istr->endEncapsulation();
    ByteBuffer iceP_outSeq;
    ByteBuffer ret = this->opByteBufferSeq(::std::move(iceP_inSeq), iceP_outSeq, request.current());
    sendResponse(::Ice::makeOutgoingResponse([&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_outSeq, ret);
        },
        request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_opShortBufferSeq(::Ice::IncomingRequest& request, ::std::function<void(::Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(::Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    ShortBuffer iceP_inSeq;
    istr->readAll(iceP_inSeq);
    istr->endEncapsulation();
    ShortBuffer iceP_outSeq;
    ShortBuffer ret = this->opShortBufferSeq(::std::move(iceP_inSeq), iceP_outSeq, request.current());
    sendResponse(::Ice::makeOutgoingResponse([&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_outSeq, ret);
        },
        request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_opIntBufferSeq(::Ice::IncomingRequest& request, ::std::function<void(::Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(::Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    IntBuffer iceP_inSeq;
    istr->readAll(iceP_inSeq);
    istr->endEncapsulation();
    IntBuffer iceP_outSeq;
    IntBuffer ret = this->opIntBufferSeq(::std::move(iceP_inSeq), iceP_outSeq, request.current());
    sendResponse(::Ice::makeOutgoingResponse([&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_outSeq, ret);
        },
        request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_opLongBufferSeq(::Ice::IncomingRequest& request, ::std::function<void(::Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(::Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    LongBuffer iceP_inSeq;
    istr->readAll(iceP_inSeq);
    istr->endEncapsulation();
    LongBuffer iceP_outSeq;
    LongBuffer ret = this->opLongBufferSeq(::std::move(iceP_inSeq), iceP_outSeq, request.current());
    sendResponse(::Ice::makeOutgoingResponse([&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_outSeq, ret);
        },
        request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_opFloatBufferSeq(::Ice::IncomingRequest& request, ::std::function<void(::Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(::Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    FloatBuffer iceP_inSeq;
    istr->readAll(iceP_inSeq);
    istr->endEncapsulation();
    FloatBuffer iceP_outSeq;
    FloatBuffer ret = this->opFloatBufferSeq(::std::move(iceP_inSeq), iceP_outSeq, request.current());
    sendResponse(::Ice::makeOutgoingResponse([&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_outSeq, ret);
        },
        request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_opDoubleBufferSeq(::Ice::IncomingRequest& request, ::std::function<void(::Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(::Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    DoubleBuffer iceP_inSeq;
    istr->readAll(iceP_inSeq);
    istr->endEncapsulation();
    DoubleBuffer iceP_outSeq;
    DoubleBuffer ret = this->opDoubleBufferSeq(::std::move(iceP_inSeq), iceP_outSeq, request.current());
    sendResponse(::Ice::makeOutgoingResponse([&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_outSeq, ret);
        },
        request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_opOptCSeq(::Ice::IncomingRequest& request, ::std::function<void(::Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(::Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    ::std::optional<CSeq> iceP_inSeq;
    istr->readAll({2}, iceP_inSeq);
    istr->endEncapsulation();
    ::std::optional<CSeq> iceP_outSeq;
    ::std::optional<CSeq> ret = this->opOptCSeq(::std::move(iceP_inSeq), iceP_outSeq, request.current());
    sendResponse(::Ice::makeOutgoingResponse([&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({1, 3}, ret, iceP_outSeq);
        },
        request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_opOptCArray(::Ice::IncomingRequest& request, ::std::function<void(::Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(::Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    ::std::optional<CArray> iceP_inSeq;
    istr->readAll({2}, iceP_inSeq);
    istr->endEncapsulation();
    ::std::optional<CArray> iceP_outSeq;
    ::std::optional<CArray> ret = this->opOptCArray(::std::move(iceP_inSeq), iceP_outSeq, request.current());
    sendResponse(::Ice::makeOutgoingResponse([&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({1, 3}, ret, iceP_outSeq);
        },
        request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_opOptCList(::Ice::IncomingRequest& request, ::std::function<void(::Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(::Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    ::std::optional<CList> iceP_inSeq;
    istr->readAll({2}, iceP_inSeq);
    istr->endEncapsulation();
    ::std::optional<CList> iceP_outSeq;
    ::std::optional<CList> ret = this->opOptCList(::std::move(iceP_inSeq), iceP_outSeq, request.current());
    sendResponse(::Ice::makeOutgoingResponse([&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({1, 3}, ret, iceP_outSeq);
        },
        request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_opOptBoolSeq(::Ice::IncomingRequest& request, ::std::function<void(::Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(::Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    ::std::optional<BoolSeq> iceP_inSeq;
    istr->readAll({2}, iceP_inSeq);
    istr->endEncapsulation();
    ::std::optional<BoolSeq> iceP_outSeq;
    ::std::optional<BoolSeq> ret = this->opOptBoolSeq(::std::move(iceP_inSeq), iceP_outSeq, request.current());
    sendResponse(::Ice::makeOutgoingResponse([&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({1, 3}, ret, iceP_outSeq);
        },
        request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_opOptByteSeq(::Ice::IncomingRequest& request, ::std::function<void(::Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(::Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    ::std::optional<ByteSeq> iceP_inSeq;
    istr->readAll({2}, iceP_inSeq);
    istr->endEncapsulation();
    ::std::optional<ByteSeq> iceP_outSeq;
    ::std::optional<ByteSeq> ret = this->opOptByteSeq(::std::move(iceP_inSeq), iceP_outSeq, request.current());
    sendResponse(::Ice::makeOutgoingResponse([&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({1, 3}, ret, iceP_outSeq);
        },
        request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_opOptShortSeq(::Ice::IncomingRequest& request, ::std::function<void(::Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(::Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    ::std::optional<ShortSeq> iceP_inSeq;
    istr->readAll({2}, iceP_inSeq);
    istr->endEncapsulation();
    ::std::optional<ShortSeq> iceP_outSeq;
    ::std::optional<ShortSeq> ret = this->opOptShortSeq(::std::move(iceP_inSeq), iceP_outSeq, request.current());
    sendResponse(::Ice::makeOutgoingResponse([&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({1, 3}, ret, iceP_outSeq);
        },
        request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_opOptIntSeq(::Ice::IncomingRequest& request, ::std::function<void(::Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(::Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    ::std::optional<IntSeq> iceP_inSeq;
    istr->readAll({2}, iceP_inSeq);
    istr->endEncapsulation();
    ::std::optional<IntSeq> iceP_outSeq;
    ::std::optional<IntSeq> ret = this->opOptIntSeq(::std::move(iceP_inSeq), iceP_outSeq, request.current());
    sendResponse(::Ice::makeOutgoingResponse([&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({1, 3}, ret, iceP_outSeq);
        },
        request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_opOptLongSeq(::Ice::IncomingRequest& request, ::std::function<void(::Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(::Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    ::std::optional<LongSeq> iceP_inSeq;
    istr->readAll({2}, iceP_inSeq);
    istr->endEncapsulation();
    ::std::optional<LongSeq> iceP_outSeq;
    ::std::optional<LongSeq> ret = this->opOptLongSeq(::std::move(iceP_inSeq), iceP_outSeq, request.current());
    sendResponse(::Ice::makeOutgoingResponse([&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({1, 3}, ret, iceP_outSeq);
        },
        request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_opOptFloatSeq(::Ice::IncomingRequest& request, ::std::function<void(::Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(::Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    ::std::optional<FloatSeq> iceP_inSeq;
    istr->readAll({2}, iceP_inSeq);
    istr->endEncapsulation();
    ::std::optional<FloatSeq> iceP_outSeq;
    ::std::optional<FloatSeq> ret = this->opOptFloatSeq(::std::move(iceP_inSeq), iceP_outSeq, request.current());
    sendResponse(::Ice::makeOutgoingResponse([&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({1, 3}, ret, iceP_outSeq);
        },
        request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_opOptDoubleSeq(::Ice::IncomingRequest& request, ::std::function<void(::Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(::Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    ::std::optional<DoubleSeq> iceP_inSeq;
    istr->readAll({2}, iceP_inSeq);
    istr->endEncapsulation();
    ::std::optional<DoubleSeq> iceP_outSeq;
    ::std::optional<DoubleSeq> ret = this->opOptDoubleSeq(::std::move(iceP_inSeq), iceP_outSeq, request.current());
    sendResponse(::Ice::makeOutgoingResponse([&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({1, 3}, ret, iceP_outSeq);
        },
        request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_opOptStringSeq(::Ice::IncomingRequest& request, ::std::function<void(::Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(::Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    ::std::optional<StringSeq> iceP_inSeq;
    istr->readAll({2}, iceP_inSeq);
    istr->endEncapsulation();
    ::std::optional<StringSeq> iceP_outSeq;
    ::std::optional<StringSeq> ret = this->opOptStringSeq(::std::move(iceP_inSeq), iceP_outSeq, request.current());
    sendResponse(::Ice::makeOutgoingResponse([&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({1, 3}, ret, iceP_outSeq);
        },
        request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_opOptESeq(::Ice::IncomingRequest& request, ::std::function<void(::Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(::Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    ::std::optional<ESeq> iceP_inSeq;
    istr->readAll({2}, iceP_inSeq);
    istr->endEncapsulation();
    ::std::optional<ESeq> iceP_outSeq;
    ::std::optional<ESeq> ret = this->opOptESeq(::std::move(iceP_inSeq), iceP_outSeq, request.current());
    sendResponse(::Ice::makeOutgoingResponse([&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({1, 3}, ret, iceP_outSeq);
        },
        request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_opOptSSeq(::Ice::IncomingRequest& request, ::std::function<void(::Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(::Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    ::std::optional<SSeq> iceP_inSeq;
    istr->readAll({2}, iceP_inSeq);
    istr->endEncapsulation();
    ::std::optional<SSeq> iceP_outSeq;
    ::std::optional<SSeq> ret = this->opOptSSeq(::std::move(iceP_inSeq), iceP_outSeq, request.current());
    sendResponse(::Ice::makeOutgoingResponse([&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({1, 3}, ret, iceP_outSeq);
        },
        request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_opOptDSeq(::Ice::IncomingRequest& request, ::std::function<void(::Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(::Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    ::std::optional<DSeq> iceP_inSeq;
    istr->readAll({2}, iceP_inSeq);
    istr->endEncapsulation();
    ::std::optional<DSeq> iceP_outSeq;
    ::std::optional<DSeq> ret = this->opOptDSeq(::std::move(iceP_inSeq), iceP_outSeq, request.current());
    sendResponse(::Ice::makeOutgoingResponse([&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({1, 3}, ret, iceP_outSeq);
        },
        request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_opOptStringSeqSeq(::Ice::IncomingRequest& request, ::std::function<void(::Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(::Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    ::std::optional<StringSeqSeq> iceP_inSeq;
    istr->readAll({2}, iceP_inSeq);
    istr->endEncapsulation();
    ::std::optional<StringSeqSeq> iceP_outSeq;
    ::std::optional<StringSeqSeq> ret = this->opOptStringSeqSeq(::std::move(iceP_inSeq), iceP_outSeq, request.current());
    sendResponse(::Ice::makeOutgoingResponse([&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({1, 3}, ret, iceP_outSeq);
        },
        request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_opOptByteBufferSeq(::Ice::IncomingRequest& request, ::std::function<void(::Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(::Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    ::std::optional<ByteBuffer> iceP_inSeq;
    istr->readAll({2}, iceP_inSeq);
    istr->endEncapsulation();
    ::std::optional<ByteBuffer> iceP_outSeq;
    ::std::optional<ByteBuffer> ret = this->opOptByteBufferSeq(::std::move(iceP_inSeq), iceP_outSeq, request.current());
    sendResponse(::Ice::makeOutgoingResponse([&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({1, 3}, ret, iceP_outSeq);
        },
        request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_opOptShortBufferSeq(::Ice::IncomingRequest& request, ::std::function<void(::Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(::Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    ::std::optional<ShortBuffer> iceP_inSeq;
    istr->readAll({2}, iceP_inSeq);
    istr->endEncapsulation();
    ::std::optional<ShortBuffer> iceP_outSeq;
    ::std::optional<ShortBuffer> ret = this->opOptShortBufferSeq(::std::move(iceP_inSeq), iceP_outSeq, request.current());
    sendResponse(::Ice::makeOutgoingResponse([&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({1, 3}, ret, iceP_outSeq);
        },
        request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_opOptIntBufferSeq(::Ice::IncomingRequest& request, ::std::function<void(::Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(::Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    ::std::optional<IntBuffer> iceP_inSeq;
    istr->readAll({2}, iceP_inSeq);
    istr->endEncapsulation();
    ::std::optional<IntBuffer> iceP_outSeq;
    ::std::optional<IntBuffer> ret = this->opOptIntBufferSeq(::std::move(iceP_inSeq), iceP_outSeq, request.current());
    sendResponse(::Ice::makeOutgoingResponse([&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({1, 3}, ret, iceP_outSeq);
        },
        request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_opOptLongBufferSeq(::Ice::IncomingRequest& request, ::std::function<void(::Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(::Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    ::std::optional<LongBuffer> iceP_inSeq;
    istr->readAll({2}, iceP_inSeq);
    istr->endEncapsulation();
    ::std::optional<LongBuffer> iceP_outSeq;
    ::std::optional<LongBuffer> ret = this->opOptLongBufferSeq(::std::move(iceP_inSeq), iceP_outSeq, request.current());
    sendResponse(::Ice::makeOutgoingResponse([&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({1, 3}, ret, iceP_outSeq);
        },
        request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_opOptFloatBufferSeq(::Ice::IncomingRequest& request, ::std::function<void(::Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(::Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    ::std::optional<FloatBuffer> iceP_inSeq;
    istr->readAll({2}, iceP_inSeq);
    istr->endEncapsulation();
    ::std::optional<FloatBuffer> iceP_outSeq;
    ::std::optional<FloatBuffer> ret = this->opOptFloatBufferSeq(::std::move(iceP_inSeq), iceP_outSeq, request.current());
    sendResponse(::Ice::makeOutgoingResponse([&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({1, 3}, ret, iceP_outSeq);
        },
        request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_opOptDoubleBufferSeq(::Ice::IncomingRequest& request, ::std::function<void(::Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(::Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    ::std::optional<DoubleBuffer> iceP_inSeq;
    istr->readAll({2}, iceP_inSeq);
    istr->endEncapsulation();
    ::std::optional<DoubleBuffer> iceP_outSeq;
    ::std::optional<DoubleBuffer> ret = this->opOptDoubleBufferSeq(::std::move(iceP_inSeq), iceP_outSeq, request.current());
    sendResponse(::Ice::makeOutgoingResponse([&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll({1, 3}, ret, iceP_outSeq);
        },
        request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::_iceD_shutdown(::Ice::IncomingRequest& request, ::std::function<void(::Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(::Ice::OperationMode::Normal, request.current().mode);
    request.inputStream().skipEmptyEncapsulation();
    this->shutdown(request.current());
    sendResponse(::Ice::makeEmptyOutgoingResponse(request.current()));
}
/// \endcond

/// \cond INTERNAL
void
Test::TestIntf::dispatch(::Ice::IncomingRequest& request, ::std::function<void(::Ice::OutgoingResponse)> sendResponse)
{
    static constexpr ::std::string_view allOperations[] = {"ice_id", "ice_ids", "ice_isA", "ice_ping", "opBoolSeq", "opByteBufferSeq", "opByteSeq", "opCArray", "opCList", "opCSeq", "opDSeq", "opDoubleBufferSeq", "opDoubleSeq", "opESeq", "opFloatBufferSeq", "opFloatSeq", "opIntBufferSeq", "opIntSeq", "opLongBufferSeq", "opLongSeq", "opOptBoolSeq", "opOptByteBufferSeq", "opOptByteSeq", "opOptCArray", "opOptCList", "opOptCSeq", "opOptDSeq", "opOptDoubleBufferSeq", "opOptDoubleSeq", "opOptESeq", "opOptFloatBufferSeq", "opOptFloatSeq", "opOptIntBufferSeq", "opOptIntSeq", "opOptLongBufferSeq", "opOptLongSeq", "opOptSSeq", "opOptShortBufferSeq", "opOptShortSeq", "opOptStringSeq", "opOptStringSeqSeq", "opSSeq", "opShortBufferSeq", "opShortSeq", "opStringSeq", "opStringSeqSeq", "shutdown"};

    const ::Ice::Current& current = request.current();
    ::std::pair<const ::std::string_view*, const ::std::string_view*> r = ::std::equal_range(allOperations, allOperations + 47, current.operation);
    if(r.first == r.second)
    {
        sendResponse(::Ice::makeOutgoingResponse(::std::make_exception_ptr(::Ice::OperationNotExistException(__FILE__, __LINE__)), current));
        return;
    }

    switch(r.first - allOperations)
    {
        case 0:
        {
            _iceD_ice_id(request, ::std::move(sendResponse));
            break;
        }
        case 1:
        {
            _iceD_ice_ids(request, ::std::move(sendResponse));
            break;
        }
        case 2:
        {
            _iceD_ice_isA(request, ::std::move(sendResponse));
            break;
        }
        case 3:
        {
            _iceD_ice_ping(request, ::std::move(sendResponse));
            break;
        }
        case 4:
        {
            _iceD_opBoolSeq(request, ::std::move(sendResponse));
            break;
        }
        case 5:
        {
            _iceD_opByteBufferSeq(request, ::std::move(sendResponse));
            break;
        }
        case 6:
        {
            _iceD_opByteSeq(request, ::std::move(sendResponse));
            break;
        }
        case 7:
        {
            _iceD_opCArray(request, ::std::move(sendResponse));
            break;
        }
        case 8:
        {
            _iceD_opCList(request, ::std::move(sendResponse));
            break;
        }
        case 9:
        {
            _iceD_opCSeq(request, ::std::move(sendResponse));
            break;
        }
        case 10:
        {
            _iceD_opDSeq(request, ::std::move(sendResponse));
            break;
        }
        case 11:
        {
            _iceD_opDoubleBufferSeq(request, ::std::move(sendResponse));
            break;
        }
        case 12:
        {
            _iceD_opDoubleSeq(request, ::std::move(sendResponse));
            break;
        }
        case 13:
        {
            _iceD_opESeq(request, ::std::move(sendResponse));
            break;
        }
        case 14:
        {
            _iceD_opFloatBufferSeq(request, ::std::move(sendResponse));
            break;
        }
        case 15:
        {
            _iceD_opFloatSeq(request, ::std::move(sendResponse));
            break;
        }
        case 16:
        {
            _iceD_opIntBufferSeq(request, ::std::move(sendResponse));
            break;
        }
        case 17:
        {
            _iceD_opIntSeq(request, ::std::move(sendResponse));
            break;
        }
        case 18:
        {
            _iceD_opLongBufferSeq(request, ::std::move(sendResponse));
            break;
        }
        case 19:
        {
            _iceD_opLongSeq(request, ::std::move(sendResponse));
            break;
        }
        case 20:
        {
            _iceD_opOptBoolSeq(request, ::std::move(sendResponse));
            break;
        }
        case 21:
        {
            _iceD_opOptByteBufferSeq(request, ::std::move(sendResponse));
            break;
        }
        case 22:
        {
            _iceD_opOptByteSeq(request, ::std::move(sendResponse));
            break;
        }
        case 23:
        {
            _iceD_opOptCArray(request, ::std::move(sendResponse));
            break;
        }
        case 24:
        {
            _iceD_opOptCList(request, ::std::move(sendResponse));
            break;
        }
        case 25:
        {
            _iceD_opOptCSeq(request, ::std::move(sendResponse));
            break;
        }
        case 26:
        {
            _iceD_opOptDSeq(request, ::std::move(sendResponse));
            break;
        }
        case 27:
        {
            _iceD_opOptDoubleBufferSeq(request, ::std::move(sendResponse));
            break;
        }
        case 28:
        {
            _iceD_opOptDoubleSeq(request, ::std::move(sendResponse));
            break;
        }
        case 29:
        {
            _iceD_opOptESeq(request, ::std::move(sendResponse));
            break;
        }
        case 30:
        {
            _iceD_opOptFloatBufferSeq(request, ::std::move(sendResponse));
            break;
        }
        case 31:
        {
            _iceD_opOptFloatSeq(request, ::std::move(sendResponse));
            break;
        }
        case 32:
        {
            _iceD_opOptIntBufferSeq(request, ::std::move(sendResponse));
            break;
        }
        case 33:
        {
            _iceD_opOptIntSeq(request, ::std::move(sendResponse));
            break;
        }
        case 34:
        {
            _iceD_opOptLongBufferSeq(request, ::std::move(sendResponse));
            break;
        }
        case 35:
        {
            _iceD_opOptLongSeq(request, ::std::move(sendResponse));
            break;
        }
        case 36:
        {
            _iceD_opOptSSeq(request, ::std::move(sendResponse));
            break;
        }
        case 37:
        {
            _iceD_opOptShortBufferSeq(request, ::std::move(sendResponse));
            break;
        }
        case 38:
        {
            _iceD_opOptShortSeq(request, ::std::move(sendResponse));
            break;
        }
        case 39:
        {
            _iceD_opOptStringSeq(request, ::std::move(sendResponse));
            break;
        }
        case 40:
        {
            _iceD_opOptStringSeqSeq(request, ::std::move(sendResponse));
            break;
        }
        case 41:
        {
            _iceD_opSSeq(request, ::std::move(sendResponse));
            break;
        }
        case 42:
        {
            _iceD_opShortBufferSeq(request, ::std::move(sendResponse));
            break;
        }
        case 43:
        {
            _iceD_opShortSeq(request, ::std::move(sendResponse));
            break;
        }
        case 44:
        {
            _iceD_opStringSeq(request, ::std::move(sendResponse));
            break;
        }
        case 45:
        {
            _iceD_opStringSeqSeq(request, ::std::move(sendResponse));
            break;
        }
        case 46:
        {
            _iceD_shutdown(request, ::std::move(sendResponse));
            break;
        }
        default:
        {
            assert(false);
            sendResponse(::Ice::makeOutgoingResponse(::std::make_exception_ptr(::Ice::OperationNotExistException(__FILE__, __LINE__)), current));
        }
    }
}
/// \endcond
