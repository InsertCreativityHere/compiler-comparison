//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.8.0-alpha.0
//
// <auto-generated>
//
// Generated from file `Test.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __Test_h__
#define __Test_h__

#include <IceUtil/PushDisableWarnings.h>
#include <Ice/Ice.h>
#include <Ice/BuiltinSequences.h>
#include <IceUtil/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION  != 30850
#       error Ice version mismatch: an exact match is required for beta generated code
#   endif
#endif

namespace Test
{

class C;
class TestIntf;
class TestIntfPrx;

}

namespace Test
{

using CSeq = ::std::vector<::std::shared_ptr<C>>;

using CArray = ::std::vector<::std::shared_ptr<C>>;

using CList = ::std::vector<::std::shared_ptr<C>>;

using BoolSeq = ::std::vector<bool>;

using ByteSeq = ::std::vector<::Ice::Byte>;

using ShortSeq = ::std::vector<short>;

using IntSeq = ::std::vector<int>;

using LongSeq = ::std::vector<long long int>;

using FloatSeq = ::std::vector<float>;

using DoubleSeq = ::std::vector<double>;

using StringSeq = ::std::vector<::std::string>;

using ByteBuffer = ::std::vector<::Ice::Byte>;

using ShortBuffer = ::std::vector<short>;

using IntBuffer = ::std::vector<int>;

using LongBuffer = ::std::vector<long long int>;

using FloatBuffer = ::std::vector<float>;

using DoubleBuffer = ::std::vector<double>;

enum class E : unsigned char
{
    E1,
    E2,
    E3
};

using ESeq = ::std::vector<E>;

struct S
{
    ::Test::E en;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::Test::E&> ice_tuple() const
    {
        return std::tie(en);
    }
};

using SSeq = ::std::vector<S>;

using D = ::std::map<int, ::std::string>;

using DSeq = ::std::vector<D>;

using StringSeqSeq = ::std::vector<StringSeq>;

using Ice::operator<;
using Ice::operator<=;
using Ice::operator>;
using Ice::operator>=;
using Ice::operator==;
using Ice::operator!=;

}

namespace Test
{

class TestIntf : public virtual ::Ice::Object
{
public:

    using ProxyType = TestIntfPrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /**
     * Encapsulates the results of a call to opCSeq.
     */
    struct OpCSeqResult
    {
        CSeq returnValue;
        CSeq outSeq;
    };

    virtual CSeq opCSeq(CSeq inSeq, CSeq& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opCSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opCArray.
     */
    struct OpCArrayResult
    {
        CArray returnValue;
        CArray outSeq;
    };

    virtual CArray opCArray(CArray inSeq, CArray& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opCArray(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opCList.
     */
    struct OpCListResult
    {
        CList returnValue;
        CList outSeq;
    };

    virtual CList opCList(CList inSeq, CList& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opCList(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opBoolSeq.
     */
    struct OpBoolSeqResult
    {
        BoolSeq returnValue;
        BoolSeq outSeq;
    };

    virtual BoolSeq opBoolSeq(BoolSeq inSeq, BoolSeq& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opBoolSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opByteSeq.
     */
    struct OpByteSeqResult
    {
        ByteSeq returnValue;
        ByteSeq outSeq;
    };

    virtual ByteSeq opByteSeq(ByteSeq inSeq, ByteSeq& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opByteSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opShortSeq.
     */
    struct OpShortSeqResult
    {
        ShortSeq returnValue;
        ShortSeq outSeq;
    };

    virtual ShortSeq opShortSeq(ShortSeq inSeq, ShortSeq& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opShortSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opIntSeq.
     */
    struct OpIntSeqResult
    {
        IntSeq returnValue;
        IntSeq outSeq;
    };

    virtual IntSeq opIntSeq(IntSeq inSeq, IntSeq& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opIntSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opLongSeq.
     */
    struct OpLongSeqResult
    {
        LongSeq returnValue;
        LongSeq outSeq;
    };

    virtual LongSeq opLongSeq(LongSeq inSeq, LongSeq& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opLongSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opFloatSeq.
     */
    struct OpFloatSeqResult
    {
        FloatSeq returnValue;
        FloatSeq outSeq;
    };

    virtual FloatSeq opFloatSeq(FloatSeq inSeq, FloatSeq& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opFloatSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opDoubleSeq.
     */
    struct OpDoubleSeqResult
    {
        DoubleSeq returnValue;
        DoubleSeq outSeq;
    };

    virtual DoubleSeq opDoubleSeq(DoubleSeq inSeq, DoubleSeq& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opDoubleSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opStringSeq.
     */
    struct OpStringSeqResult
    {
        StringSeq returnValue;
        StringSeq outSeq;
    };

    virtual StringSeq opStringSeq(StringSeq inSeq, StringSeq& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opStringSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opESeq.
     */
    struct OpESeqResult
    {
        ESeq returnValue;
        ESeq outSeq;
    };

    virtual ESeq opESeq(ESeq inSeq, ESeq& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opESeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opSSeq.
     */
    struct OpSSeqResult
    {
        SSeq returnValue;
        SSeq outSeq;
    };

    virtual SSeq opSSeq(SSeq inSeq, SSeq& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opSSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opDSeq.
     */
    struct OpDSeqResult
    {
        DSeq returnValue;
        DSeq outSeq;
    };

    virtual DSeq opDSeq(DSeq inSeq, DSeq& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opDSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opStringSeqSeq.
     */
    struct OpStringSeqSeqResult
    {
        StringSeqSeq returnValue;
        StringSeqSeq outSeq;
    };

    virtual StringSeqSeq opStringSeqSeq(StringSeqSeq inSeq, StringSeqSeq& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opStringSeqSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opByteBufferSeq.
     */
    struct OpByteBufferSeqResult
    {
        ByteBuffer returnValue;
        ByteBuffer outSeq;
    };

    virtual ByteBuffer opByteBufferSeq(ByteBuffer inSeq, ByteBuffer& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opByteBufferSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opShortBufferSeq.
     */
    struct OpShortBufferSeqResult
    {
        ShortBuffer returnValue;
        ShortBuffer outSeq;
    };

    virtual ShortBuffer opShortBufferSeq(ShortBuffer inSeq, ShortBuffer& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opShortBufferSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opIntBufferSeq.
     */
    struct OpIntBufferSeqResult
    {
        IntBuffer returnValue;
        IntBuffer outSeq;
    };

    virtual IntBuffer opIntBufferSeq(IntBuffer inSeq, IntBuffer& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opIntBufferSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opLongBufferSeq.
     */
    struct OpLongBufferSeqResult
    {
        LongBuffer returnValue;
        LongBuffer outSeq;
    };

    virtual LongBuffer opLongBufferSeq(LongBuffer inSeq, LongBuffer& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opLongBufferSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opFloatBufferSeq.
     */
    struct OpFloatBufferSeqResult
    {
        FloatBuffer returnValue;
        FloatBuffer outSeq;
    };

    virtual FloatBuffer opFloatBufferSeq(FloatBuffer inSeq, FloatBuffer& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opFloatBufferSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opDoubleBufferSeq.
     */
    struct OpDoubleBufferSeqResult
    {
        DoubleBuffer returnValue;
        DoubleBuffer outSeq;
    };

    virtual DoubleBuffer opDoubleBufferSeq(DoubleBuffer inSeq, DoubleBuffer& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opDoubleBufferSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opOptCSeq.
     */
    struct OpOptCSeqResult
    {
        std::optional<CSeq> returnValue;
        std::optional<CSeq> outSeq;
    };

    virtual std::optional<CSeq> opOptCSeq(std::optional<CSeq> inSeq, std::optional<CSeq>& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opOptCSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opOptCArray.
     */
    struct OpOptCArrayResult
    {
        std::optional<CArray> returnValue;
        std::optional<CArray> outSeq;
    };

    virtual std::optional<CArray> opOptCArray(std::optional<CArray> inSeq, std::optional<CArray>& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opOptCArray(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opOptCList.
     */
    struct OpOptCListResult
    {
        std::optional<CList> returnValue;
        std::optional<CList> outSeq;
    };

    virtual std::optional<CList> opOptCList(std::optional<CList> inSeq, std::optional<CList>& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opOptCList(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opOptBoolSeq.
     */
    struct OpOptBoolSeqResult
    {
        std::optional<BoolSeq> returnValue;
        std::optional<BoolSeq> outSeq;
    };

    virtual std::optional<BoolSeq> opOptBoolSeq(std::optional<BoolSeq> inSeq, std::optional<BoolSeq>& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opOptBoolSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opOptByteSeq.
     */
    struct OpOptByteSeqResult
    {
        std::optional<ByteSeq> returnValue;
        std::optional<ByteSeq> outSeq;
    };

    virtual std::optional<ByteSeq> opOptByteSeq(std::optional<ByteSeq> inSeq, std::optional<ByteSeq>& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opOptByteSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opOptShortSeq.
     */
    struct OpOptShortSeqResult
    {
        std::optional<ShortSeq> returnValue;
        std::optional<ShortSeq> outSeq;
    };

    virtual std::optional<ShortSeq> opOptShortSeq(std::optional<ShortSeq> inSeq, std::optional<ShortSeq>& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opOptShortSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opOptIntSeq.
     */
    struct OpOptIntSeqResult
    {
        std::optional<IntSeq> returnValue;
        std::optional<IntSeq> outSeq;
    };

    virtual std::optional<IntSeq> opOptIntSeq(std::optional<IntSeq> inSeq, std::optional<IntSeq>& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opOptIntSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opOptLongSeq.
     */
    struct OpOptLongSeqResult
    {
        std::optional<LongSeq> returnValue;
        std::optional<LongSeq> outSeq;
    };

    virtual std::optional<LongSeq> opOptLongSeq(std::optional<LongSeq> inSeq, std::optional<LongSeq>& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opOptLongSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opOptFloatSeq.
     */
    struct OpOptFloatSeqResult
    {
        std::optional<FloatSeq> returnValue;
        std::optional<FloatSeq> outSeq;
    };

    virtual std::optional<FloatSeq> opOptFloatSeq(std::optional<FloatSeq> inSeq, std::optional<FloatSeq>& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opOptFloatSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opOptDoubleSeq.
     */
    struct OpOptDoubleSeqResult
    {
        std::optional<DoubleSeq> returnValue;
        std::optional<DoubleSeq> outSeq;
    };

    virtual std::optional<DoubleSeq> opOptDoubleSeq(std::optional<DoubleSeq> inSeq, std::optional<DoubleSeq>& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opOptDoubleSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opOptStringSeq.
     */
    struct OpOptStringSeqResult
    {
        std::optional<StringSeq> returnValue;
        std::optional<StringSeq> outSeq;
    };

    virtual std::optional<StringSeq> opOptStringSeq(std::optional<StringSeq> inSeq, std::optional<StringSeq>& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opOptStringSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opOptESeq.
     */
    struct OpOptESeqResult
    {
        std::optional<ESeq> returnValue;
        std::optional<ESeq> outSeq;
    };

    virtual std::optional<ESeq> opOptESeq(std::optional<ESeq> inSeq, std::optional<ESeq>& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opOptESeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opOptSSeq.
     */
    struct OpOptSSeqResult
    {
        std::optional<SSeq> returnValue;
        std::optional<SSeq> outSeq;
    };

    virtual std::optional<SSeq> opOptSSeq(std::optional<SSeq> inSeq, std::optional<SSeq>& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opOptSSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opOptDSeq.
     */
    struct OpOptDSeqResult
    {
        std::optional<DSeq> returnValue;
        std::optional<DSeq> outSeq;
    };

    virtual std::optional<DSeq> opOptDSeq(std::optional<DSeq> inSeq, std::optional<DSeq>& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opOptDSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opOptStringSeqSeq.
     */
    struct OpOptStringSeqSeqResult
    {
        std::optional<StringSeqSeq> returnValue;
        std::optional<StringSeqSeq> outSeq;
    };

    virtual std::optional<StringSeqSeq> opOptStringSeqSeq(std::optional<StringSeqSeq> inSeq, std::optional<StringSeqSeq>& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opOptStringSeqSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opOptByteBufferSeq.
     */
    struct OpOptByteBufferSeqResult
    {
        std::optional<ByteBuffer> returnValue;
        std::optional<ByteBuffer> outSeq;
    };

    virtual std::optional<ByteBuffer> opOptByteBufferSeq(std::optional<ByteBuffer> inSeq, std::optional<ByteBuffer>& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opOptByteBufferSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opOptShortBufferSeq.
     */
    struct OpOptShortBufferSeqResult
    {
        std::optional<ShortBuffer> returnValue;
        std::optional<ShortBuffer> outSeq;
    };

    virtual std::optional<ShortBuffer> opOptShortBufferSeq(std::optional<ShortBuffer> inSeq, std::optional<ShortBuffer>& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opOptShortBufferSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opOptIntBufferSeq.
     */
    struct OpOptIntBufferSeqResult
    {
        std::optional<IntBuffer> returnValue;
        std::optional<IntBuffer> outSeq;
    };

    virtual std::optional<IntBuffer> opOptIntBufferSeq(std::optional<IntBuffer> inSeq, std::optional<IntBuffer>& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opOptIntBufferSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opOptLongBufferSeq.
     */
    struct OpOptLongBufferSeqResult
    {
        std::optional<LongBuffer> returnValue;
        std::optional<LongBuffer> outSeq;
    };

    virtual std::optional<LongBuffer> opOptLongBufferSeq(std::optional<LongBuffer> inSeq, std::optional<LongBuffer>& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opOptLongBufferSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opOptFloatBufferSeq.
     */
    struct OpOptFloatBufferSeqResult
    {
        std::optional<FloatBuffer> returnValue;
        std::optional<FloatBuffer> outSeq;
    };

    virtual std::optional<FloatBuffer> opOptFloatBufferSeq(std::optional<FloatBuffer> inSeq, std::optional<FloatBuffer>& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opOptFloatBufferSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opOptDoubleBufferSeq.
     */
    struct OpOptDoubleBufferSeqResult
    {
        std::optional<DoubleBuffer> returnValue;
        std::optional<DoubleBuffer> outSeq;
    };

    virtual std::optional<DoubleBuffer> opOptDoubleBufferSeq(std::optional<DoubleBuffer> inSeq, std::optional<DoubleBuffer>& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opOptDoubleBufferSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void shutdown(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_shutdown(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

}

namespace Test
{

class C : public ::Ice::ValueHelper<C, ::Ice::Value>
{
public:

    virtual ~C();

    C() = default;

    C(const C&) = default;
    C(C&&) = default;
    C& operator=(const C&) = default;
    C& operator=(C&&) = default;

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<> ice_tuple() const
    {
        return std::tie();
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();
};

/// \cond INTERNAL
static C _iceS_C_init;
/// \endcond

}

namespace Test
{

class TestIntfPrx : public virtual ::Ice::Proxy<TestIntfPrx, ::Ice::ObjectPrx>
{
public:

    CSeq opCSeq(const CSeq& inSeq, CSeq& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpCSeqResult>(true, this, &TestIntfPrx::_iceI_opCSeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opCSeqAsync(const CSeq& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpCSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpCSeqResult, P>(false, this, &TestIntfPrx::_iceI_opCSeq, inSeq, context);
    }

    ::std::function<void()>
    opCSeqAsync(const CSeq& inSeq,
                ::std::function<void(::Test::CSeq, ::Test::CSeq)> response,
                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                ::std::function<void(bool)> sent = nullptr,
                const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpCSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpCSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opCSeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opCSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpCSeqResult>>&, const CSeq&, const ::Ice::Context&);
    /// \endcond

    CArray opCArray(const CArray& inSeq, CArray& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpCArrayResult>(true, this, &TestIntfPrx::_iceI_opCArray, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opCArrayAsync(const CArray& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpCArrayResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpCArrayResult, P>(false, this, &TestIntfPrx::_iceI_opCArray, inSeq, context);
    }

    ::std::function<void()>
    opCArrayAsync(const CArray& inSeq,
                  ::std::function<void(::Test::CArray, ::Test::CArray)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpCArrayResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpCArrayResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opCArray, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opCArray(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpCArrayResult>>&, const CArray&, const ::Ice::Context&);
    /// \endcond

    CList opCList(const CList& inSeq, CList& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpCListResult>(true, this, &TestIntfPrx::_iceI_opCList, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opCListAsync(const CList& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpCListResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpCListResult, P>(false, this, &TestIntfPrx::_iceI_opCList, inSeq, context);
    }

    ::std::function<void()>
    opCListAsync(const CList& inSeq,
                 ::std::function<void(::Test::CList, ::Test::CList)> response,
                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                 ::std::function<void(bool)> sent = nullptr,
                 const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpCListResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpCListResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opCList, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opCList(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpCListResult>>&, const CList&, const ::Ice::Context&);
    /// \endcond

    BoolSeq opBoolSeq(const BoolSeq& inSeq, BoolSeq& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpBoolSeqResult>(true, this, &TestIntfPrx::_iceI_opBoolSeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opBoolSeqAsync(const BoolSeq& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpBoolSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpBoolSeqResult, P>(false, this, &TestIntfPrx::_iceI_opBoolSeq, inSeq, context);
    }

    ::std::function<void()>
    opBoolSeqAsync(const BoolSeq& inSeq,
                   ::std::function<void(::Test::BoolSeq, ::Test::BoolSeq)> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpBoolSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpBoolSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opBoolSeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opBoolSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpBoolSeqResult>>&, const BoolSeq&, const ::Ice::Context&);
    /// \endcond

    ByteSeq opByteSeq(const ByteSeq& inSeq, ByteSeq& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpByteSeqResult>(true, this, &TestIntfPrx::_iceI_opByteSeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opByteSeqAsync(const ByteSeq& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpByteSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpByteSeqResult, P>(false, this, &TestIntfPrx::_iceI_opByteSeq, inSeq, context);
    }

    ::std::function<void()>
    opByteSeqAsync(const ByteSeq& inSeq,
                   ::std::function<void(::Test::ByteSeq, ::Test::ByteSeq)> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpByteSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpByteSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opByteSeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opByteSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpByteSeqResult>>&, const ByteSeq&, const ::Ice::Context&);
    /// \endcond

    ShortSeq opShortSeq(const ShortSeq& inSeq, ShortSeq& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpShortSeqResult>(true, this, &TestIntfPrx::_iceI_opShortSeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opShortSeqAsync(const ShortSeq& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpShortSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpShortSeqResult, P>(false, this, &TestIntfPrx::_iceI_opShortSeq, inSeq, context);
    }

    ::std::function<void()>
    opShortSeqAsync(const ShortSeq& inSeq,
                    ::std::function<void(::Test::ShortSeq, ::Test::ShortSeq)> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpShortSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpShortSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opShortSeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opShortSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpShortSeqResult>>&, const ShortSeq&, const ::Ice::Context&);
    /// \endcond

    IntSeq opIntSeq(const IntSeq& inSeq, IntSeq& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpIntSeqResult>(true, this, &TestIntfPrx::_iceI_opIntSeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opIntSeqAsync(const IntSeq& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpIntSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpIntSeqResult, P>(false, this, &TestIntfPrx::_iceI_opIntSeq, inSeq, context);
    }

    ::std::function<void()>
    opIntSeqAsync(const IntSeq& inSeq,
                  ::std::function<void(::Test::IntSeq, ::Test::IntSeq)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpIntSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpIntSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opIntSeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opIntSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpIntSeqResult>>&, const IntSeq&, const ::Ice::Context&);
    /// \endcond

    LongSeq opLongSeq(const LongSeq& inSeq, LongSeq& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpLongSeqResult>(true, this, &TestIntfPrx::_iceI_opLongSeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opLongSeqAsync(const LongSeq& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpLongSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpLongSeqResult, P>(false, this, &TestIntfPrx::_iceI_opLongSeq, inSeq, context);
    }

    ::std::function<void()>
    opLongSeqAsync(const LongSeq& inSeq,
                   ::std::function<void(::Test::LongSeq, ::Test::LongSeq)> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpLongSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpLongSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opLongSeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opLongSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpLongSeqResult>>&, const LongSeq&, const ::Ice::Context&);
    /// \endcond

    FloatSeq opFloatSeq(const FloatSeq& inSeq, FloatSeq& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpFloatSeqResult>(true, this, &TestIntfPrx::_iceI_opFloatSeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opFloatSeqAsync(const FloatSeq& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpFloatSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpFloatSeqResult, P>(false, this, &TestIntfPrx::_iceI_opFloatSeq, inSeq, context);
    }

    ::std::function<void()>
    opFloatSeqAsync(const FloatSeq& inSeq,
                    ::std::function<void(::Test::FloatSeq, ::Test::FloatSeq)> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpFloatSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpFloatSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opFloatSeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opFloatSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpFloatSeqResult>>&, const FloatSeq&, const ::Ice::Context&);
    /// \endcond

    DoubleSeq opDoubleSeq(const DoubleSeq& inSeq, DoubleSeq& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpDoubleSeqResult>(true, this, &TestIntfPrx::_iceI_opDoubleSeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opDoubleSeqAsync(const DoubleSeq& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpDoubleSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpDoubleSeqResult, P>(false, this, &TestIntfPrx::_iceI_opDoubleSeq, inSeq, context);
    }

    ::std::function<void()>
    opDoubleSeqAsync(const DoubleSeq& inSeq,
                     ::std::function<void(::Test::DoubleSeq, ::Test::DoubleSeq)> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpDoubleSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpDoubleSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opDoubleSeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opDoubleSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpDoubleSeqResult>>&, const DoubleSeq&, const ::Ice::Context&);
    /// \endcond

    StringSeq opStringSeq(const StringSeq& inSeq, StringSeq& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpStringSeqResult>(true, this, &TestIntfPrx::_iceI_opStringSeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opStringSeqAsync(const StringSeq& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpStringSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpStringSeqResult, P>(false, this, &TestIntfPrx::_iceI_opStringSeq, inSeq, context);
    }

    ::std::function<void()>
    opStringSeqAsync(const StringSeq& inSeq,
                     ::std::function<void(::Test::StringSeq, ::Test::StringSeq)> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpStringSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpStringSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opStringSeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opStringSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpStringSeqResult>>&, const StringSeq&, const ::Ice::Context&);
    /// \endcond

    ESeq opESeq(const ESeq& inSeq, ESeq& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpESeqResult>(true, this, &TestIntfPrx::_iceI_opESeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opESeqAsync(const ESeq& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpESeqResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpESeqResult, P>(false, this, &TestIntfPrx::_iceI_opESeq, inSeq, context);
    }

    ::std::function<void()>
    opESeqAsync(const ESeq& inSeq,
                ::std::function<void(::Test::ESeq, ::Test::ESeq)> response,
                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                ::std::function<void(bool)> sent = nullptr,
                const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpESeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpESeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opESeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opESeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpESeqResult>>&, const ESeq&, const ::Ice::Context&);
    /// \endcond

    SSeq opSSeq(const SSeq& inSeq, SSeq& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpSSeqResult>(true, this, &TestIntfPrx::_iceI_opSSeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opSSeqAsync(const SSeq& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpSSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpSSeqResult, P>(false, this, &TestIntfPrx::_iceI_opSSeq, inSeq, context);
    }

    ::std::function<void()>
    opSSeqAsync(const SSeq& inSeq,
                ::std::function<void(::Test::SSeq, ::Test::SSeq)> response,
                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                ::std::function<void(bool)> sent = nullptr,
                const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpSSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpSSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opSSeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opSSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpSSeqResult>>&, const SSeq&, const ::Ice::Context&);
    /// \endcond

    DSeq opDSeq(const DSeq& inSeq, DSeq& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpDSeqResult>(true, this, &TestIntfPrx::_iceI_opDSeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opDSeqAsync(const DSeq& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpDSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpDSeqResult, P>(false, this, &TestIntfPrx::_iceI_opDSeq, inSeq, context);
    }

    ::std::function<void()>
    opDSeqAsync(const DSeq& inSeq,
                ::std::function<void(::Test::DSeq, ::Test::DSeq)> response,
                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                ::std::function<void(bool)> sent = nullptr,
                const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpDSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpDSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opDSeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opDSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpDSeqResult>>&, const DSeq&, const ::Ice::Context&);
    /// \endcond

    StringSeqSeq opStringSeqSeq(const StringSeqSeq& inSeq, StringSeqSeq& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpStringSeqSeqResult>(true, this, &TestIntfPrx::_iceI_opStringSeqSeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opStringSeqSeqAsync(const StringSeqSeq& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpStringSeqSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpStringSeqSeqResult, P>(false, this, &TestIntfPrx::_iceI_opStringSeqSeq, inSeq, context);
    }

    ::std::function<void()>
    opStringSeqSeqAsync(const StringSeqSeq& inSeq,
                        ::std::function<void(::Test::StringSeqSeq, ::Test::StringSeqSeq)> response,
                        ::std::function<void(::std::exception_ptr)> ex = nullptr,
                        ::std::function<void(bool)> sent = nullptr,
                        const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpStringSeqSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpStringSeqSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opStringSeqSeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opStringSeqSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpStringSeqSeqResult>>&, const StringSeqSeq&, const ::Ice::Context&);
    /// \endcond

    ByteBuffer opByteBufferSeq(const ByteBuffer& inSeq, ByteBuffer& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpByteBufferSeqResult>(true, this, &TestIntfPrx::_iceI_opByteBufferSeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opByteBufferSeqAsync(const ByteBuffer& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpByteBufferSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpByteBufferSeqResult, P>(false, this, &TestIntfPrx::_iceI_opByteBufferSeq, inSeq, context);
    }

    ::std::function<void()>
    opByteBufferSeqAsync(const ByteBuffer& inSeq,
                         ::std::function<void(::Test::ByteBuffer, ::Test::ByteBuffer)> response,
                         ::std::function<void(::std::exception_ptr)> ex = nullptr,
                         ::std::function<void(bool)> sent = nullptr,
                         const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpByteBufferSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpByteBufferSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opByteBufferSeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opByteBufferSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpByteBufferSeqResult>>&, const ByteBuffer&, const ::Ice::Context&);
    /// \endcond

    ShortBuffer opShortBufferSeq(const ShortBuffer& inSeq, ShortBuffer& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpShortBufferSeqResult>(true, this, &TestIntfPrx::_iceI_opShortBufferSeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opShortBufferSeqAsync(const ShortBuffer& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpShortBufferSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpShortBufferSeqResult, P>(false, this, &TestIntfPrx::_iceI_opShortBufferSeq, inSeq, context);
    }

    ::std::function<void()>
    opShortBufferSeqAsync(const ShortBuffer& inSeq,
                          ::std::function<void(::Test::ShortBuffer, ::Test::ShortBuffer)> response,
                          ::std::function<void(::std::exception_ptr)> ex = nullptr,
                          ::std::function<void(bool)> sent = nullptr,
                          const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpShortBufferSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpShortBufferSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opShortBufferSeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opShortBufferSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpShortBufferSeqResult>>&, const ShortBuffer&, const ::Ice::Context&);
    /// \endcond

    IntBuffer opIntBufferSeq(const IntBuffer& inSeq, IntBuffer& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpIntBufferSeqResult>(true, this, &TestIntfPrx::_iceI_opIntBufferSeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opIntBufferSeqAsync(const IntBuffer& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpIntBufferSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpIntBufferSeqResult, P>(false, this, &TestIntfPrx::_iceI_opIntBufferSeq, inSeq, context);
    }

    ::std::function<void()>
    opIntBufferSeqAsync(const IntBuffer& inSeq,
                        ::std::function<void(::Test::IntBuffer, ::Test::IntBuffer)> response,
                        ::std::function<void(::std::exception_ptr)> ex = nullptr,
                        ::std::function<void(bool)> sent = nullptr,
                        const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpIntBufferSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpIntBufferSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opIntBufferSeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opIntBufferSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpIntBufferSeqResult>>&, const IntBuffer&, const ::Ice::Context&);
    /// \endcond

    LongBuffer opLongBufferSeq(const LongBuffer& inSeq, LongBuffer& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpLongBufferSeqResult>(true, this, &TestIntfPrx::_iceI_opLongBufferSeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opLongBufferSeqAsync(const LongBuffer& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpLongBufferSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpLongBufferSeqResult, P>(false, this, &TestIntfPrx::_iceI_opLongBufferSeq, inSeq, context);
    }

    ::std::function<void()>
    opLongBufferSeqAsync(const LongBuffer& inSeq,
                         ::std::function<void(::Test::LongBuffer, ::Test::LongBuffer)> response,
                         ::std::function<void(::std::exception_ptr)> ex = nullptr,
                         ::std::function<void(bool)> sent = nullptr,
                         const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpLongBufferSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpLongBufferSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opLongBufferSeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opLongBufferSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpLongBufferSeqResult>>&, const LongBuffer&, const ::Ice::Context&);
    /// \endcond

    FloatBuffer opFloatBufferSeq(const FloatBuffer& inSeq, FloatBuffer& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpFloatBufferSeqResult>(true, this, &TestIntfPrx::_iceI_opFloatBufferSeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opFloatBufferSeqAsync(const FloatBuffer& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpFloatBufferSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpFloatBufferSeqResult, P>(false, this, &TestIntfPrx::_iceI_opFloatBufferSeq, inSeq, context);
    }

    ::std::function<void()>
    opFloatBufferSeqAsync(const FloatBuffer& inSeq,
                          ::std::function<void(::Test::FloatBuffer, ::Test::FloatBuffer)> response,
                          ::std::function<void(::std::exception_ptr)> ex = nullptr,
                          ::std::function<void(bool)> sent = nullptr,
                          const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpFloatBufferSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpFloatBufferSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opFloatBufferSeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opFloatBufferSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpFloatBufferSeqResult>>&, const FloatBuffer&, const ::Ice::Context&);
    /// \endcond

    DoubleBuffer opDoubleBufferSeq(const DoubleBuffer& inSeq, DoubleBuffer& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpDoubleBufferSeqResult>(true, this, &TestIntfPrx::_iceI_opDoubleBufferSeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opDoubleBufferSeqAsync(const DoubleBuffer& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpDoubleBufferSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpDoubleBufferSeqResult, P>(false, this, &TestIntfPrx::_iceI_opDoubleBufferSeq, inSeq, context);
    }

    ::std::function<void()>
    opDoubleBufferSeqAsync(const DoubleBuffer& inSeq,
                           ::std::function<void(::Test::DoubleBuffer, ::Test::DoubleBuffer)> response,
                           ::std::function<void(::std::exception_ptr)> ex = nullptr,
                           ::std::function<void(bool)> sent = nullptr,
                           const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpDoubleBufferSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpDoubleBufferSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opDoubleBufferSeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opDoubleBufferSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpDoubleBufferSeqResult>>&, const DoubleBuffer&, const ::Ice::Context&);
    /// \endcond

    std::optional<CSeq> opOptCSeq(const std::optional<CSeq>& inSeq, std::optional<CSeq>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpOptCSeqResult>(true, this, &TestIntfPrx::_iceI_opOptCSeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opOptCSeqAsync(const std::optional<CSeq>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpOptCSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpOptCSeqResult, P>(false, this, &TestIntfPrx::_iceI_opOptCSeq, inSeq, context);
    }

    ::std::function<void()>
    opOptCSeqAsync(const std::optional<CSeq>& inSeq,
                   ::std::function<void(std::optional<::Test::CSeq>, std::optional<::Test::CSeq>)> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpOptCSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpOptCSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opOptCSeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opOptCSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpOptCSeqResult>>&, const std::optional<CSeq>&, const ::Ice::Context&);
    /// \endcond

    std::optional<CArray> opOptCArray(const std::optional<CArray>& inSeq, std::optional<CArray>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpOptCArrayResult>(true, this, &TestIntfPrx::_iceI_opOptCArray, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opOptCArrayAsync(const std::optional<CArray>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpOptCArrayResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpOptCArrayResult, P>(false, this, &TestIntfPrx::_iceI_opOptCArray, inSeq, context);
    }

    ::std::function<void()>
    opOptCArrayAsync(const std::optional<CArray>& inSeq,
                     ::std::function<void(std::optional<::Test::CArray>, std::optional<::Test::CArray>)> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpOptCArrayResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpOptCArrayResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opOptCArray, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opOptCArray(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpOptCArrayResult>>&, const std::optional<CArray>&, const ::Ice::Context&);
    /// \endcond

    std::optional<CList> opOptCList(const std::optional<CList>& inSeq, std::optional<CList>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpOptCListResult>(true, this, &TestIntfPrx::_iceI_opOptCList, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opOptCListAsync(const std::optional<CList>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpOptCListResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpOptCListResult, P>(false, this, &TestIntfPrx::_iceI_opOptCList, inSeq, context);
    }

    ::std::function<void()>
    opOptCListAsync(const std::optional<CList>& inSeq,
                    ::std::function<void(std::optional<::Test::CList>, std::optional<::Test::CList>)> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpOptCListResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpOptCListResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opOptCList, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opOptCList(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpOptCListResult>>&, const std::optional<CList>&, const ::Ice::Context&);
    /// \endcond

    std::optional<BoolSeq> opOptBoolSeq(const std::optional<BoolSeq>& inSeq, std::optional<BoolSeq>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpOptBoolSeqResult>(true, this, &TestIntfPrx::_iceI_opOptBoolSeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opOptBoolSeqAsync(const std::optional<BoolSeq>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpOptBoolSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpOptBoolSeqResult, P>(false, this, &TestIntfPrx::_iceI_opOptBoolSeq, inSeq, context);
    }

    ::std::function<void()>
    opOptBoolSeqAsync(const std::optional<BoolSeq>& inSeq,
                      ::std::function<void(std::optional<::Test::BoolSeq>, std::optional<::Test::BoolSeq>)> response,
                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                      ::std::function<void(bool)> sent = nullptr,
                      const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpOptBoolSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpOptBoolSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opOptBoolSeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opOptBoolSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpOptBoolSeqResult>>&, const std::optional<BoolSeq>&, const ::Ice::Context&);
    /// \endcond

    std::optional<ByteSeq> opOptByteSeq(const std::optional<ByteSeq>& inSeq, std::optional<ByteSeq>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpOptByteSeqResult>(true, this, &TestIntfPrx::_iceI_opOptByteSeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opOptByteSeqAsync(const std::optional<ByteSeq>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpOptByteSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpOptByteSeqResult, P>(false, this, &TestIntfPrx::_iceI_opOptByteSeq, inSeq, context);
    }

    ::std::function<void()>
    opOptByteSeqAsync(const std::optional<ByteSeq>& inSeq,
                      ::std::function<void(std::optional<::Test::ByteSeq>, std::optional<::Test::ByteSeq>)> response,
                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                      ::std::function<void(bool)> sent = nullptr,
                      const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpOptByteSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpOptByteSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opOptByteSeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opOptByteSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpOptByteSeqResult>>&, const std::optional<ByteSeq>&, const ::Ice::Context&);
    /// \endcond

    std::optional<ShortSeq> opOptShortSeq(const std::optional<ShortSeq>& inSeq, std::optional<ShortSeq>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpOptShortSeqResult>(true, this, &TestIntfPrx::_iceI_opOptShortSeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opOptShortSeqAsync(const std::optional<ShortSeq>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpOptShortSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpOptShortSeqResult, P>(false, this, &TestIntfPrx::_iceI_opOptShortSeq, inSeq, context);
    }

    ::std::function<void()>
    opOptShortSeqAsync(const std::optional<ShortSeq>& inSeq,
                       ::std::function<void(std::optional<::Test::ShortSeq>, std::optional<::Test::ShortSeq>)> response,
                       ::std::function<void(::std::exception_ptr)> ex = nullptr,
                       ::std::function<void(bool)> sent = nullptr,
                       const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpOptShortSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpOptShortSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opOptShortSeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opOptShortSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpOptShortSeqResult>>&, const std::optional<ShortSeq>&, const ::Ice::Context&);
    /// \endcond

    std::optional<IntSeq> opOptIntSeq(const std::optional<IntSeq>& inSeq, std::optional<IntSeq>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpOptIntSeqResult>(true, this, &TestIntfPrx::_iceI_opOptIntSeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opOptIntSeqAsync(const std::optional<IntSeq>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpOptIntSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpOptIntSeqResult, P>(false, this, &TestIntfPrx::_iceI_opOptIntSeq, inSeq, context);
    }

    ::std::function<void()>
    opOptIntSeqAsync(const std::optional<IntSeq>& inSeq,
                     ::std::function<void(std::optional<::Test::IntSeq>, std::optional<::Test::IntSeq>)> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpOptIntSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpOptIntSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opOptIntSeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opOptIntSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpOptIntSeqResult>>&, const std::optional<IntSeq>&, const ::Ice::Context&);
    /// \endcond

    std::optional<LongSeq> opOptLongSeq(const std::optional<LongSeq>& inSeq, std::optional<LongSeq>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpOptLongSeqResult>(true, this, &TestIntfPrx::_iceI_opOptLongSeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opOptLongSeqAsync(const std::optional<LongSeq>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpOptLongSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpOptLongSeqResult, P>(false, this, &TestIntfPrx::_iceI_opOptLongSeq, inSeq, context);
    }

    ::std::function<void()>
    opOptLongSeqAsync(const std::optional<LongSeq>& inSeq,
                      ::std::function<void(std::optional<::Test::LongSeq>, std::optional<::Test::LongSeq>)> response,
                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                      ::std::function<void(bool)> sent = nullptr,
                      const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpOptLongSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpOptLongSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opOptLongSeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opOptLongSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpOptLongSeqResult>>&, const std::optional<LongSeq>&, const ::Ice::Context&);
    /// \endcond

    std::optional<FloatSeq> opOptFloatSeq(const std::optional<FloatSeq>& inSeq, std::optional<FloatSeq>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpOptFloatSeqResult>(true, this, &TestIntfPrx::_iceI_opOptFloatSeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opOptFloatSeqAsync(const std::optional<FloatSeq>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpOptFloatSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpOptFloatSeqResult, P>(false, this, &TestIntfPrx::_iceI_opOptFloatSeq, inSeq, context);
    }

    ::std::function<void()>
    opOptFloatSeqAsync(const std::optional<FloatSeq>& inSeq,
                       ::std::function<void(std::optional<::Test::FloatSeq>, std::optional<::Test::FloatSeq>)> response,
                       ::std::function<void(::std::exception_ptr)> ex = nullptr,
                       ::std::function<void(bool)> sent = nullptr,
                       const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpOptFloatSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpOptFloatSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opOptFloatSeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opOptFloatSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpOptFloatSeqResult>>&, const std::optional<FloatSeq>&, const ::Ice::Context&);
    /// \endcond

    std::optional<DoubleSeq> opOptDoubleSeq(const std::optional<DoubleSeq>& inSeq, std::optional<DoubleSeq>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpOptDoubleSeqResult>(true, this, &TestIntfPrx::_iceI_opOptDoubleSeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opOptDoubleSeqAsync(const std::optional<DoubleSeq>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpOptDoubleSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpOptDoubleSeqResult, P>(false, this, &TestIntfPrx::_iceI_opOptDoubleSeq, inSeq, context);
    }

    ::std::function<void()>
    opOptDoubleSeqAsync(const std::optional<DoubleSeq>& inSeq,
                        ::std::function<void(std::optional<::Test::DoubleSeq>, std::optional<::Test::DoubleSeq>)> response,
                        ::std::function<void(::std::exception_ptr)> ex = nullptr,
                        ::std::function<void(bool)> sent = nullptr,
                        const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpOptDoubleSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpOptDoubleSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opOptDoubleSeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opOptDoubleSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpOptDoubleSeqResult>>&, const std::optional<DoubleSeq>&, const ::Ice::Context&);
    /// \endcond

    std::optional<StringSeq> opOptStringSeq(const std::optional<StringSeq>& inSeq, std::optional<StringSeq>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpOptStringSeqResult>(true, this, &TestIntfPrx::_iceI_opOptStringSeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opOptStringSeqAsync(const std::optional<StringSeq>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpOptStringSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpOptStringSeqResult, P>(false, this, &TestIntfPrx::_iceI_opOptStringSeq, inSeq, context);
    }

    ::std::function<void()>
    opOptStringSeqAsync(const std::optional<StringSeq>& inSeq,
                        ::std::function<void(std::optional<::Test::StringSeq>, std::optional<::Test::StringSeq>)> response,
                        ::std::function<void(::std::exception_ptr)> ex = nullptr,
                        ::std::function<void(bool)> sent = nullptr,
                        const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpOptStringSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpOptStringSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opOptStringSeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opOptStringSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpOptStringSeqResult>>&, const std::optional<StringSeq>&, const ::Ice::Context&);
    /// \endcond

    std::optional<ESeq> opOptESeq(const std::optional<ESeq>& inSeq, std::optional<ESeq>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpOptESeqResult>(true, this, &TestIntfPrx::_iceI_opOptESeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opOptESeqAsync(const std::optional<ESeq>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpOptESeqResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpOptESeqResult, P>(false, this, &TestIntfPrx::_iceI_opOptESeq, inSeq, context);
    }

    ::std::function<void()>
    opOptESeqAsync(const std::optional<ESeq>& inSeq,
                   ::std::function<void(std::optional<::Test::ESeq>, std::optional<::Test::ESeq>)> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpOptESeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpOptESeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opOptESeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opOptESeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpOptESeqResult>>&, const std::optional<ESeq>&, const ::Ice::Context&);
    /// \endcond

    std::optional<SSeq> opOptSSeq(const std::optional<SSeq>& inSeq, std::optional<SSeq>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpOptSSeqResult>(true, this, &TestIntfPrx::_iceI_opOptSSeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opOptSSeqAsync(const std::optional<SSeq>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpOptSSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpOptSSeqResult, P>(false, this, &TestIntfPrx::_iceI_opOptSSeq, inSeq, context);
    }

    ::std::function<void()>
    opOptSSeqAsync(const std::optional<SSeq>& inSeq,
                   ::std::function<void(std::optional<::Test::SSeq>, std::optional<::Test::SSeq>)> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpOptSSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpOptSSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opOptSSeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opOptSSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpOptSSeqResult>>&, const std::optional<SSeq>&, const ::Ice::Context&);
    /// \endcond

    std::optional<DSeq> opOptDSeq(const std::optional<DSeq>& inSeq, std::optional<DSeq>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpOptDSeqResult>(true, this, &TestIntfPrx::_iceI_opOptDSeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opOptDSeqAsync(const std::optional<DSeq>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpOptDSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpOptDSeqResult, P>(false, this, &TestIntfPrx::_iceI_opOptDSeq, inSeq, context);
    }

    ::std::function<void()>
    opOptDSeqAsync(const std::optional<DSeq>& inSeq,
                   ::std::function<void(std::optional<::Test::DSeq>, std::optional<::Test::DSeq>)> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpOptDSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpOptDSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opOptDSeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opOptDSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpOptDSeqResult>>&, const std::optional<DSeq>&, const ::Ice::Context&);
    /// \endcond

    std::optional<StringSeqSeq> opOptStringSeqSeq(const std::optional<StringSeqSeq>& inSeq, std::optional<StringSeqSeq>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpOptStringSeqSeqResult>(true, this, &TestIntfPrx::_iceI_opOptStringSeqSeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opOptStringSeqSeqAsync(const std::optional<StringSeqSeq>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpOptStringSeqSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpOptStringSeqSeqResult, P>(false, this, &TestIntfPrx::_iceI_opOptStringSeqSeq, inSeq, context);
    }

    ::std::function<void()>
    opOptStringSeqSeqAsync(const std::optional<StringSeqSeq>& inSeq,
                           ::std::function<void(std::optional<::Test::StringSeqSeq>, std::optional<::Test::StringSeqSeq>)> response,
                           ::std::function<void(::std::exception_ptr)> ex = nullptr,
                           ::std::function<void(bool)> sent = nullptr,
                           const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpOptStringSeqSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpOptStringSeqSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opOptStringSeqSeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opOptStringSeqSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpOptStringSeqSeqResult>>&, const std::optional<StringSeqSeq>&, const ::Ice::Context&);
    /// \endcond

    std::optional<ByteBuffer> opOptByteBufferSeq(const std::optional<ByteBuffer>& inSeq, std::optional<ByteBuffer>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpOptByteBufferSeqResult>(true, this, &TestIntfPrx::_iceI_opOptByteBufferSeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opOptByteBufferSeqAsync(const std::optional<ByteBuffer>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpOptByteBufferSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpOptByteBufferSeqResult, P>(false, this, &TestIntfPrx::_iceI_opOptByteBufferSeq, inSeq, context);
    }

    ::std::function<void()>
    opOptByteBufferSeqAsync(const std::optional<ByteBuffer>& inSeq,
                            ::std::function<void(std::optional<::Test::ByteBuffer>, std::optional<::Test::ByteBuffer>)> response,
                            ::std::function<void(::std::exception_ptr)> ex = nullptr,
                            ::std::function<void(bool)> sent = nullptr,
                            const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpOptByteBufferSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpOptByteBufferSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opOptByteBufferSeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opOptByteBufferSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpOptByteBufferSeqResult>>&, const std::optional<ByteBuffer>&, const ::Ice::Context&);
    /// \endcond

    std::optional<ShortBuffer> opOptShortBufferSeq(const std::optional<ShortBuffer>& inSeq, std::optional<ShortBuffer>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpOptShortBufferSeqResult>(true, this, &TestIntfPrx::_iceI_opOptShortBufferSeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opOptShortBufferSeqAsync(const std::optional<ShortBuffer>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpOptShortBufferSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpOptShortBufferSeqResult, P>(false, this, &TestIntfPrx::_iceI_opOptShortBufferSeq, inSeq, context);
    }

    ::std::function<void()>
    opOptShortBufferSeqAsync(const std::optional<ShortBuffer>& inSeq,
                             ::std::function<void(std::optional<::Test::ShortBuffer>, std::optional<::Test::ShortBuffer>)> response,
                             ::std::function<void(::std::exception_ptr)> ex = nullptr,
                             ::std::function<void(bool)> sent = nullptr,
                             const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpOptShortBufferSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpOptShortBufferSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opOptShortBufferSeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opOptShortBufferSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpOptShortBufferSeqResult>>&, const std::optional<ShortBuffer>&, const ::Ice::Context&);
    /// \endcond

    std::optional<IntBuffer> opOptIntBufferSeq(const std::optional<IntBuffer>& inSeq, std::optional<IntBuffer>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpOptIntBufferSeqResult>(true, this, &TestIntfPrx::_iceI_opOptIntBufferSeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opOptIntBufferSeqAsync(const std::optional<IntBuffer>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpOptIntBufferSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpOptIntBufferSeqResult, P>(false, this, &TestIntfPrx::_iceI_opOptIntBufferSeq, inSeq, context);
    }

    ::std::function<void()>
    opOptIntBufferSeqAsync(const std::optional<IntBuffer>& inSeq,
                           ::std::function<void(std::optional<::Test::IntBuffer>, std::optional<::Test::IntBuffer>)> response,
                           ::std::function<void(::std::exception_ptr)> ex = nullptr,
                           ::std::function<void(bool)> sent = nullptr,
                           const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpOptIntBufferSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpOptIntBufferSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opOptIntBufferSeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opOptIntBufferSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpOptIntBufferSeqResult>>&, const std::optional<IntBuffer>&, const ::Ice::Context&);
    /// \endcond

    std::optional<LongBuffer> opOptLongBufferSeq(const std::optional<LongBuffer>& inSeq, std::optional<LongBuffer>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpOptLongBufferSeqResult>(true, this, &TestIntfPrx::_iceI_opOptLongBufferSeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opOptLongBufferSeqAsync(const std::optional<LongBuffer>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpOptLongBufferSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpOptLongBufferSeqResult, P>(false, this, &TestIntfPrx::_iceI_opOptLongBufferSeq, inSeq, context);
    }

    ::std::function<void()>
    opOptLongBufferSeqAsync(const std::optional<LongBuffer>& inSeq,
                            ::std::function<void(std::optional<::Test::LongBuffer>, std::optional<::Test::LongBuffer>)> response,
                            ::std::function<void(::std::exception_ptr)> ex = nullptr,
                            ::std::function<void(bool)> sent = nullptr,
                            const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpOptLongBufferSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpOptLongBufferSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opOptLongBufferSeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opOptLongBufferSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpOptLongBufferSeqResult>>&, const std::optional<LongBuffer>&, const ::Ice::Context&);
    /// \endcond

    std::optional<FloatBuffer> opOptFloatBufferSeq(const std::optional<FloatBuffer>& inSeq, std::optional<FloatBuffer>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpOptFloatBufferSeqResult>(true, this, &TestIntfPrx::_iceI_opOptFloatBufferSeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opOptFloatBufferSeqAsync(const std::optional<FloatBuffer>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpOptFloatBufferSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpOptFloatBufferSeqResult, P>(false, this, &TestIntfPrx::_iceI_opOptFloatBufferSeq, inSeq, context);
    }

    ::std::function<void()>
    opOptFloatBufferSeqAsync(const std::optional<FloatBuffer>& inSeq,
                             ::std::function<void(std::optional<::Test::FloatBuffer>, std::optional<::Test::FloatBuffer>)> response,
                             ::std::function<void(::std::exception_ptr)> ex = nullptr,
                             ::std::function<void(bool)> sent = nullptr,
                             const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpOptFloatBufferSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpOptFloatBufferSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opOptFloatBufferSeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opOptFloatBufferSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpOptFloatBufferSeqResult>>&, const std::optional<FloatBuffer>&, const ::Ice::Context&);
    /// \endcond

    std::optional<DoubleBuffer> opOptDoubleBufferSeq(const std::optional<DoubleBuffer>& inSeq, std::optional<DoubleBuffer>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpOptDoubleBufferSeqResult>(true, this, &TestIntfPrx::_iceI_opOptDoubleBufferSeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opOptDoubleBufferSeqAsync(const std::optional<DoubleBuffer>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpOptDoubleBufferSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpOptDoubleBufferSeqResult, P>(false, this, &TestIntfPrx::_iceI_opOptDoubleBufferSeq, inSeq, context);
    }

    ::std::function<void()>
    opOptDoubleBufferSeqAsync(const std::optional<DoubleBuffer>& inSeq,
                              ::std::function<void(std::optional<::Test::DoubleBuffer>, std::optional<::Test::DoubleBuffer>)> response,
                              ::std::function<void(::std::exception_ptr)> ex = nullptr,
                              ::std::function<void(bool)> sent = nullptr,
                              const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpOptDoubleBufferSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpOptDoubleBufferSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opOptDoubleBufferSeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opOptDoubleBufferSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpOptDoubleBufferSeqResult>>&, const std::optional<DoubleBuffer>&, const ::Ice::Context&);
    /// \endcond

    void shutdown(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &TestIntfPrx::_iceI_shutdown, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto shutdownAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &TestIntfPrx::_iceI_shutdown, context);
    }

    ::std::function<void()>
    shutdownAsync(::std::function<void()> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_shutdown, context);
    }

    /// \cond INTERNAL
    void _iceI_shutdown(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    TestIntfPrx() = default;
    friend ::std::shared_ptr<TestIntfPrx> IceInternal::createProxy<TestIntfPrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

}

/// \cond STREAM
namespace Ice
{

template<>
struct StreamableTraits< ::Test::E>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 2;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits<::Test::S>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::Test::S, S>
{
    static void read(S* istr, ::Test::S& v)
    {
        istr->readAll(v.en);
    }
};

}
/// \endcond

/// \cond INTERNAL
namespace Test
{

using CPtr = ::std::shared_ptr<C>;

using TestIntfPtr = ::std::shared_ptr<TestIntf>;
using TestIntfPrxPtr = ::std::shared_ptr<TestIntfPrx>;

}
/// \endcond

#include <IceUtil/PopDisableWarnings.h>
#endif
