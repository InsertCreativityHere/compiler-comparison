//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.7.10
//
// <auto-generated>
//
// Generated from file `Test.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __Test_h__
#define __Test_h__

#include <IceUtil/PushDisableWarnings.h>
#include <Ice/Ice.h>
#include <Ice/BuiltinSequences.h>
#include <IceUtil/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 307
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 >= 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 10
#       error Ice patch level mismatch!
#   endif
#endif

#ifdef ICE_CPP11_MAPPING // C++11 mapping

namespace Test
{

class C;
class TestIntf;
class TestIntfPrx;

}

namespace Test
{

using CSeq = ::std::vector<::std::shared_ptr<C>>;

using CArray = ::std::vector<::std::shared_ptr<C>>;

using CList = ::std::vector<::std::shared_ptr<C>>;

using BoolSeq = ::std::vector<bool>;

using ByteSeq = ::std::vector<::Ice::Byte>;

using ShortSeq = ::std::vector<short>;

using IntSeq = ::std::vector<int>;

using LongSeq = ::std::vector<long long int>;

using FloatSeq = ::std::vector<float>;

using DoubleSeq = ::std::vector<double>;

using StringSeq = ::std::vector<::std::string>;

using ByteBuffer = ::std::vector<::Ice::Byte>;

using ShortBuffer = ::std::vector<short>;

using IntBuffer = ::std::vector<int>;

using LongBuffer = ::std::vector<long long int>;

using FloatBuffer = ::std::vector<float>;

using DoubleBuffer = ::std::vector<double>;

enum class E : unsigned char
{
    E1,
    E2,
    E3
};

using ESeq = ::std::vector<E>;

struct S
{
    ::Test::E en;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::Test::E&> ice_tuple() const
    {
        return std::tie(en);
    }
};

using SSeq = ::std::vector<S>;

using D = ::std::map<int, ::std::string>;

using DSeq = ::std::vector<D>;

using StringSeqSeq = ::std::vector<StringSeq>;

using Ice::operator<;
using Ice::operator<=;
using Ice::operator>;
using Ice::operator>=;
using Ice::operator==;
using Ice::operator!=;

}

namespace Test
{

class TestIntf : public virtual ::Ice::Object
{
public:

    using ProxyType = TestIntfPrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /**
     * Encapsulates the results of a call to opCSeq.
     */
    struct OpCSeqResult
    {
        CSeq returnValue;
        CSeq outSeq;
    };

    virtual CSeq opCSeq(CSeq inSeq, CSeq& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opCSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opCArray.
     */
    struct OpCArrayResult
    {
        CArray returnValue;
        CArray outSeq;
    };

    virtual CArray opCArray(CArray inSeq, CArray& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opCArray(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opCList.
     */
    struct OpCListResult
    {
        CList returnValue;
        CList outSeq;
    };

    virtual CList opCList(CList inSeq, CList& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opCList(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opBoolSeq.
     */
    struct OpBoolSeqResult
    {
        BoolSeq returnValue;
        BoolSeq outSeq;
    };

    virtual BoolSeq opBoolSeq(BoolSeq inSeq, BoolSeq& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opBoolSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opByteSeq.
     */
    struct OpByteSeqResult
    {
        ByteSeq returnValue;
        ByteSeq outSeq;
    };

    virtual ByteSeq opByteSeq(ByteSeq inSeq, ByteSeq& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opByteSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opShortSeq.
     */
    struct OpShortSeqResult
    {
        ShortSeq returnValue;
        ShortSeq outSeq;
    };

    virtual ShortSeq opShortSeq(ShortSeq inSeq, ShortSeq& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opShortSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opIntSeq.
     */
    struct OpIntSeqResult
    {
        IntSeq returnValue;
        IntSeq outSeq;
    };

    virtual IntSeq opIntSeq(IntSeq inSeq, IntSeq& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opIntSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opLongSeq.
     */
    struct OpLongSeqResult
    {
        LongSeq returnValue;
        LongSeq outSeq;
    };

    virtual LongSeq opLongSeq(LongSeq inSeq, LongSeq& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opLongSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opFloatSeq.
     */
    struct OpFloatSeqResult
    {
        FloatSeq returnValue;
        FloatSeq outSeq;
    };

    virtual FloatSeq opFloatSeq(FloatSeq inSeq, FloatSeq& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opFloatSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opDoubleSeq.
     */
    struct OpDoubleSeqResult
    {
        DoubleSeq returnValue;
        DoubleSeq outSeq;
    };

    virtual DoubleSeq opDoubleSeq(DoubleSeq inSeq, DoubleSeq& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opDoubleSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opStringSeq.
     */
    struct OpStringSeqResult
    {
        StringSeq returnValue;
        StringSeq outSeq;
    };

    virtual StringSeq opStringSeq(StringSeq inSeq, StringSeq& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opStringSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opESeq.
     */
    struct OpESeqResult
    {
        ESeq returnValue;
        ESeq outSeq;
    };

    virtual ESeq opESeq(ESeq inSeq, ESeq& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opESeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opSSeq.
     */
    struct OpSSeqResult
    {
        SSeq returnValue;
        SSeq outSeq;
    };

    virtual SSeq opSSeq(SSeq inSeq, SSeq& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opSSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opDSeq.
     */
    struct OpDSeqResult
    {
        DSeq returnValue;
        DSeq outSeq;
    };

    virtual DSeq opDSeq(DSeq inSeq, DSeq& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opDSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opStringSeqSeq.
     */
    struct OpStringSeqSeqResult
    {
        StringSeqSeq returnValue;
        StringSeqSeq outSeq;
    };

    virtual StringSeqSeq opStringSeqSeq(StringSeqSeq inSeq, StringSeqSeq& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opStringSeqSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opByteBufferSeq.
     */
    struct OpByteBufferSeqResult
    {
        ByteBuffer returnValue;
        ByteBuffer outSeq;
    };

    virtual ByteBuffer opByteBufferSeq(ByteBuffer inSeq, ByteBuffer& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opByteBufferSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opShortBufferSeq.
     */
    struct OpShortBufferSeqResult
    {
        ShortBuffer returnValue;
        ShortBuffer outSeq;
    };

    virtual ShortBuffer opShortBufferSeq(ShortBuffer inSeq, ShortBuffer& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opShortBufferSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opIntBufferSeq.
     */
    struct OpIntBufferSeqResult
    {
        IntBuffer returnValue;
        IntBuffer outSeq;
    };

    virtual IntBuffer opIntBufferSeq(IntBuffer inSeq, IntBuffer& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opIntBufferSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opLongBufferSeq.
     */
    struct OpLongBufferSeqResult
    {
        LongBuffer returnValue;
        LongBuffer outSeq;
    };

    virtual LongBuffer opLongBufferSeq(LongBuffer inSeq, LongBuffer& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opLongBufferSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opFloatBufferSeq.
     */
    struct OpFloatBufferSeqResult
    {
        FloatBuffer returnValue;
        FloatBuffer outSeq;
    };

    virtual FloatBuffer opFloatBufferSeq(FloatBuffer inSeq, FloatBuffer& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opFloatBufferSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opDoubleBufferSeq.
     */
    struct OpDoubleBufferSeqResult
    {
        DoubleBuffer returnValue;
        DoubleBuffer outSeq;
    };

    virtual DoubleBuffer opDoubleBufferSeq(DoubleBuffer inSeq, DoubleBuffer& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opDoubleBufferSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opOptCSeq.
     */
    struct OpOptCSeqResult
    {
        std::optional<CSeq> returnValue;
        std::optional<CSeq> outSeq;
    };

    virtual std::optional<CSeq> opOptCSeq(std::optional<CSeq> inSeq, std::optional<CSeq>& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opOptCSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opOptCArray.
     */
    struct OpOptCArrayResult
    {
        std::optional<CArray> returnValue;
        std::optional<CArray> outSeq;
    };

    virtual std::optional<CArray> opOptCArray(std::optional<CArray> inSeq, std::optional<CArray>& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opOptCArray(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opOptCList.
     */
    struct OpOptCListResult
    {
        std::optional<CList> returnValue;
        std::optional<CList> outSeq;
    };

    virtual std::optional<CList> opOptCList(std::optional<CList> inSeq, std::optional<CList>& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opOptCList(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opOptBoolSeq.
     */
    struct OpOptBoolSeqResult
    {
        std::optional<BoolSeq> returnValue;
        std::optional<BoolSeq> outSeq;
    };

    virtual std::optional<BoolSeq> opOptBoolSeq(std::optional<BoolSeq> inSeq, std::optional<BoolSeq>& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opOptBoolSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opOptByteSeq.
     */
    struct OpOptByteSeqResult
    {
        std::optional<ByteSeq> returnValue;
        std::optional<ByteSeq> outSeq;
    };

    virtual std::optional<ByteSeq> opOptByteSeq(std::optional<ByteSeq> inSeq, std::optional<ByteSeq>& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opOptByteSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opOptShortSeq.
     */
    struct OpOptShortSeqResult
    {
        std::optional<ShortSeq> returnValue;
        std::optional<ShortSeq> outSeq;
    };

    virtual std::optional<ShortSeq> opOptShortSeq(std::optional<ShortSeq> inSeq, std::optional<ShortSeq>& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opOptShortSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opOptIntSeq.
     */
    struct OpOptIntSeqResult
    {
        std::optional<IntSeq> returnValue;
        std::optional<IntSeq> outSeq;
    };

    virtual std::optional<IntSeq> opOptIntSeq(std::optional<IntSeq> inSeq, std::optional<IntSeq>& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opOptIntSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opOptLongSeq.
     */
    struct OpOptLongSeqResult
    {
        std::optional<LongSeq> returnValue;
        std::optional<LongSeq> outSeq;
    };

    virtual std::optional<LongSeq> opOptLongSeq(std::optional<LongSeq> inSeq, std::optional<LongSeq>& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opOptLongSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opOptFloatSeq.
     */
    struct OpOptFloatSeqResult
    {
        std::optional<FloatSeq> returnValue;
        std::optional<FloatSeq> outSeq;
    };

    virtual std::optional<FloatSeq> opOptFloatSeq(std::optional<FloatSeq> inSeq, std::optional<FloatSeq>& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opOptFloatSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opOptDoubleSeq.
     */
    struct OpOptDoubleSeqResult
    {
        std::optional<DoubleSeq> returnValue;
        std::optional<DoubleSeq> outSeq;
    };

    virtual std::optional<DoubleSeq> opOptDoubleSeq(std::optional<DoubleSeq> inSeq, std::optional<DoubleSeq>& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opOptDoubleSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opOptStringSeq.
     */
    struct OpOptStringSeqResult
    {
        std::optional<StringSeq> returnValue;
        std::optional<StringSeq> outSeq;
    };

    virtual std::optional<StringSeq> opOptStringSeq(std::optional<StringSeq> inSeq, std::optional<StringSeq>& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opOptStringSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opOptESeq.
     */
    struct OpOptESeqResult
    {
        std::optional<ESeq> returnValue;
        std::optional<ESeq> outSeq;
    };

    virtual std::optional<ESeq> opOptESeq(std::optional<ESeq> inSeq, std::optional<ESeq>& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opOptESeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opOptSSeq.
     */
    struct OpOptSSeqResult
    {
        std::optional<SSeq> returnValue;
        std::optional<SSeq> outSeq;
    };

    virtual std::optional<SSeq> opOptSSeq(std::optional<SSeq> inSeq, std::optional<SSeq>& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opOptSSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opOptDSeq.
     */
    struct OpOptDSeqResult
    {
        std::optional<DSeq> returnValue;
        std::optional<DSeq> outSeq;
    };

    virtual std::optional<DSeq> opOptDSeq(std::optional<DSeq> inSeq, std::optional<DSeq>& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opOptDSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opOptStringSeqSeq.
     */
    struct OpOptStringSeqSeqResult
    {
        std::optional<StringSeqSeq> returnValue;
        std::optional<StringSeqSeq> outSeq;
    };

    virtual std::optional<StringSeqSeq> opOptStringSeqSeq(std::optional<StringSeqSeq> inSeq, std::optional<StringSeqSeq>& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opOptStringSeqSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opOptByteBufferSeq.
     */
    struct OpOptByteBufferSeqResult
    {
        std::optional<ByteBuffer> returnValue;
        std::optional<ByteBuffer> outSeq;
    };

    virtual std::optional<ByteBuffer> opOptByteBufferSeq(std::optional<ByteBuffer> inSeq, std::optional<ByteBuffer>& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opOptByteBufferSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opOptShortBufferSeq.
     */
    struct OpOptShortBufferSeqResult
    {
        std::optional<ShortBuffer> returnValue;
        std::optional<ShortBuffer> outSeq;
    };

    virtual std::optional<ShortBuffer> opOptShortBufferSeq(std::optional<ShortBuffer> inSeq, std::optional<ShortBuffer>& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opOptShortBufferSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opOptIntBufferSeq.
     */
    struct OpOptIntBufferSeqResult
    {
        std::optional<IntBuffer> returnValue;
        std::optional<IntBuffer> outSeq;
    };

    virtual std::optional<IntBuffer> opOptIntBufferSeq(std::optional<IntBuffer> inSeq, std::optional<IntBuffer>& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opOptIntBufferSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opOptLongBufferSeq.
     */
    struct OpOptLongBufferSeqResult
    {
        std::optional<LongBuffer> returnValue;
        std::optional<LongBuffer> outSeq;
    };

    virtual std::optional<LongBuffer> opOptLongBufferSeq(std::optional<LongBuffer> inSeq, std::optional<LongBuffer>& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opOptLongBufferSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opOptFloatBufferSeq.
     */
    struct OpOptFloatBufferSeqResult
    {
        std::optional<FloatBuffer> returnValue;
        std::optional<FloatBuffer> outSeq;
    };

    virtual std::optional<FloatBuffer> opOptFloatBufferSeq(std::optional<FloatBuffer> inSeq, std::optional<FloatBuffer>& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opOptFloatBufferSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to opOptDoubleBufferSeq.
     */
    struct OpOptDoubleBufferSeqResult
    {
        std::optional<DoubleBuffer> returnValue;
        std::optional<DoubleBuffer> outSeq;
    };

    virtual std::optional<DoubleBuffer> opOptDoubleBufferSeq(std::optional<DoubleBuffer> inSeq, std::optional<DoubleBuffer>& outSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_opOptDoubleBufferSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void shutdown(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_shutdown(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

}

namespace Test
{

class C : public ::Ice::ValueHelper<C, ::Ice::Value>
{
public:

    virtual ~C();

    C() = default;

    C(const C&) = default;
    C(C&&) = default;
    C& operator=(const C&) = default;
    C& operator=(C&&) = default;

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<> ice_tuple() const
    {
        return std::tie();
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();
};

/// \cond INTERNAL
static C _iceS_C_init;
/// \endcond

}

namespace Test
{

class TestIntfPrx : public virtual ::Ice::Proxy<TestIntfPrx, ::Ice::ObjectPrx>
{
public:

    CSeq opCSeq(const CSeq& inSeq, CSeq& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpCSeqResult>(true, this, &TestIntfPrx::_iceI_opCSeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opCSeqAsync(const CSeq& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpCSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpCSeqResult, P>(false, this, &TestIntfPrx::_iceI_opCSeq, inSeq, context);
    }

    ::std::function<void()>
    opCSeqAsync(const CSeq& inSeq,
                ::std::function<void(::Test::CSeq, ::Test::CSeq)> response,
                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                ::std::function<void(bool)> sent = nullptr,
                const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpCSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpCSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opCSeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opCSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpCSeqResult>>&, const CSeq&, const ::Ice::Context&);
    /// \endcond

    CArray opCArray(const CArray& inSeq, CArray& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpCArrayResult>(true, this, &TestIntfPrx::_iceI_opCArray, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opCArrayAsync(const CArray& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpCArrayResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpCArrayResult, P>(false, this, &TestIntfPrx::_iceI_opCArray, inSeq, context);
    }

    ::std::function<void()>
    opCArrayAsync(const CArray& inSeq,
                  ::std::function<void(::Test::CArray, ::Test::CArray)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpCArrayResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpCArrayResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opCArray, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opCArray(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpCArrayResult>>&, const CArray&, const ::Ice::Context&);
    /// \endcond

    CList opCList(const CList& inSeq, CList& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpCListResult>(true, this, &TestIntfPrx::_iceI_opCList, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opCListAsync(const CList& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpCListResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpCListResult, P>(false, this, &TestIntfPrx::_iceI_opCList, inSeq, context);
    }

    ::std::function<void()>
    opCListAsync(const CList& inSeq,
                 ::std::function<void(::Test::CList, ::Test::CList)> response,
                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                 ::std::function<void(bool)> sent = nullptr,
                 const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpCListResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpCListResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opCList, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opCList(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpCListResult>>&, const CList&, const ::Ice::Context&);
    /// \endcond

    BoolSeq opBoolSeq(const BoolSeq& inSeq, BoolSeq& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpBoolSeqResult>(true, this, &TestIntfPrx::_iceI_opBoolSeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opBoolSeqAsync(const BoolSeq& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpBoolSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpBoolSeqResult, P>(false, this, &TestIntfPrx::_iceI_opBoolSeq, inSeq, context);
    }

    ::std::function<void()>
    opBoolSeqAsync(const BoolSeq& inSeq,
                   ::std::function<void(::Test::BoolSeq, ::Test::BoolSeq)> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpBoolSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpBoolSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opBoolSeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opBoolSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpBoolSeqResult>>&, const BoolSeq&, const ::Ice::Context&);
    /// \endcond

    ByteSeq opByteSeq(const ByteSeq& inSeq, ByteSeq& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpByteSeqResult>(true, this, &TestIntfPrx::_iceI_opByteSeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opByteSeqAsync(const ByteSeq& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpByteSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpByteSeqResult, P>(false, this, &TestIntfPrx::_iceI_opByteSeq, inSeq, context);
    }

    ::std::function<void()>
    opByteSeqAsync(const ByteSeq& inSeq,
                   ::std::function<void(::Test::ByteSeq, ::Test::ByteSeq)> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpByteSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpByteSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opByteSeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opByteSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpByteSeqResult>>&, const ByteSeq&, const ::Ice::Context&);
    /// \endcond

    ShortSeq opShortSeq(const ShortSeq& inSeq, ShortSeq& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpShortSeqResult>(true, this, &TestIntfPrx::_iceI_opShortSeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opShortSeqAsync(const ShortSeq& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpShortSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpShortSeqResult, P>(false, this, &TestIntfPrx::_iceI_opShortSeq, inSeq, context);
    }

    ::std::function<void()>
    opShortSeqAsync(const ShortSeq& inSeq,
                    ::std::function<void(::Test::ShortSeq, ::Test::ShortSeq)> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpShortSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpShortSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opShortSeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opShortSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpShortSeqResult>>&, const ShortSeq&, const ::Ice::Context&);
    /// \endcond

    IntSeq opIntSeq(const IntSeq& inSeq, IntSeq& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpIntSeqResult>(true, this, &TestIntfPrx::_iceI_opIntSeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opIntSeqAsync(const IntSeq& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpIntSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpIntSeqResult, P>(false, this, &TestIntfPrx::_iceI_opIntSeq, inSeq, context);
    }

    ::std::function<void()>
    opIntSeqAsync(const IntSeq& inSeq,
                  ::std::function<void(::Test::IntSeq, ::Test::IntSeq)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpIntSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpIntSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opIntSeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opIntSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpIntSeqResult>>&, const IntSeq&, const ::Ice::Context&);
    /// \endcond

    LongSeq opLongSeq(const LongSeq& inSeq, LongSeq& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpLongSeqResult>(true, this, &TestIntfPrx::_iceI_opLongSeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opLongSeqAsync(const LongSeq& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpLongSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpLongSeqResult, P>(false, this, &TestIntfPrx::_iceI_opLongSeq, inSeq, context);
    }

    ::std::function<void()>
    opLongSeqAsync(const LongSeq& inSeq,
                   ::std::function<void(::Test::LongSeq, ::Test::LongSeq)> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpLongSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpLongSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opLongSeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opLongSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpLongSeqResult>>&, const LongSeq&, const ::Ice::Context&);
    /// \endcond

    FloatSeq opFloatSeq(const FloatSeq& inSeq, FloatSeq& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpFloatSeqResult>(true, this, &TestIntfPrx::_iceI_opFloatSeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opFloatSeqAsync(const FloatSeq& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpFloatSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpFloatSeqResult, P>(false, this, &TestIntfPrx::_iceI_opFloatSeq, inSeq, context);
    }

    ::std::function<void()>
    opFloatSeqAsync(const FloatSeq& inSeq,
                    ::std::function<void(::Test::FloatSeq, ::Test::FloatSeq)> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpFloatSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpFloatSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opFloatSeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opFloatSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpFloatSeqResult>>&, const FloatSeq&, const ::Ice::Context&);
    /// \endcond

    DoubleSeq opDoubleSeq(const DoubleSeq& inSeq, DoubleSeq& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpDoubleSeqResult>(true, this, &TestIntfPrx::_iceI_opDoubleSeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opDoubleSeqAsync(const DoubleSeq& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpDoubleSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpDoubleSeqResult, P>(false, this, &TestIntfPrx::_iceI_opDoubleSeq, inSeq, context);
    }

    ::std::function<void()>
    opDoubleSeqAsync(const DoubleSeq& inSeq,
                     ::std::function<void(::Test::DoubleSeq, ::Test::DoubleSeq)> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpDoubleSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpDoubleSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opDoubleSeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opDoubleSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpDoubleSeqResult>>&, const DoubleSeq&, const ::Ice::Context&);
    /// \endcond

    StringSeq opStringSeq(const StringSeq& inSeq, StringSeq& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpStringSeqResult>(true, this, &TestIntfPrx::_iceI_opStringSeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opStringSeqAsync(const StringSeq& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpStringSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpStringSeqResult, P>(false, this, &TestIntfPrx::_iceI_opStringSeq, inSeq, context);
    }

    ::std::function<void()>
    opStringSeqAsync(const StringSeq& inSeq,
                     ::std::function<void(::Test::StringSeq, ::Test::StringSeq)> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpStringSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpStringSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opStringSeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opStringSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpStringSeqResult>>&, const StringSeq&, const ::Ice::Context&);
    /// \endcond

    ESeq opESeq(const ESeq& inSeq, ESeq& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpESeqResult>(true, this, &TestIntfPrx::_iceI_opESeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opESeqAsync(const ESeq& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpESeqResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpESeqResult, P>(false, this, &TestIntfPrx::_iceI_opESeq, inSeq, context);
    }

    ::std::function<void()>
    opESeqAsync(const ESeq& inSeq,
                ::std::function<void(::Test::ESeq, ::Test::ESeq)> response,
                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                ::std::function<void(bool)> sent = nullptr,
                const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpESeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpESeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opESeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opESeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpESeqResult>>&, const ESeq&, const ::Ice::Context&);
    /// \endcond

    SSeq opSSeq(const SSeq& inSeq, SSeq& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpSSeqResult>(true, this, &TestIntfPrx::_iceI_opSSeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opSSeqAsync(const SSeq& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpSSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpSSeqResult, P>(false, this, &TestIntfPrx::_iceI_opSSeq, inSeq, context);
    }

    ::std::function<void()>
    opSSeqAsync(const SSeq& inSeq,
                ::std::function<void(::Test::SSeq, ::Test::SSeq)> response,
                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                ::std::function<void(bool)> sent = nullptr,
                const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpSSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpSSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opSSeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opSSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpSSeqResult>>&, const SSeq&, const ::Ice::Context&);
    /// \endcond

    DSeq opDSeq(const DSeq& inSeq, DSeq& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpDSeqResult>(true, this, &TestIntfPrx::_iceI_opDSeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opDSeqAsync(const DSeq& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpDSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpDSeqResult, P>(false, this, &TestIntfPrx::_iceI_opDSeq, inSeq, context);
    }

    ::std::function<void()>
    opDSeqAsync(const DSeq& inSeq,
                ::std::function<void(::Test::DSeq, ::Test::DSeq)> response,
                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                ::std::function<void(bool)> sent = nullptr,
                const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpDSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpDSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opDSeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opDSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpDSeqResult>>&, const DSeq&, const ::Ice::Context&);
    /// \endcond

    StringSeqSeq opStringSeqSeq(const StringSeqSeq& inSeq, StringSeqSeq& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpStringSeqSeqResult>(true, this, &TestIntfPrx::_iceI_opStringSeqSeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opStringSeqSeqAsync(const StringSeqSeq& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpStringSeqSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpStringSeqSeqResult, P>(false, this, &TestIntfPrx::_iceI_opStringSeqSeq, inSeq, context);
    }

    ::std::function<void()>
    opStringSeqSeqAsync(const StringSeqSeq& inSeq,
                        ::std::function<void(::Test::StringSeqSeq, ::Test::StringSeqSeq)> response,
                        ::std::function<void(::std::exception_ptr)> ex = nullptr,
                        ::std::function<void(bool)> sent = nullptr,
                        const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpStringSeqSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpStringSeqSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opStringSeqSeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opStringSeqSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpStringSeqSeqResult>>&, const StringSeqSeq&, const ::Ice::Context&);
    /// \endcond

    ByteBuffer opByteBufferSeq(const ByteBuffer& inSeq, ByteBuffer& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpByteBufferSeqResult>(true, this, &TestIntfPrx::_iceI_opByteBufferSeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opByteBufferSeqAsync(const ByteBuffer& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpByteBufferSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpByteBufferSeqResult, P>(false, this, &TestIntfPrx::_iceI_opByteBufferSeq, inSeq, context);
    }

    ::std::function<void()>
    opByteBufferSeqAsync(const ByteBuffer& inSeq,
                         ::std::function<void(::Test::ByteBuffer, ::Test::ByteBuffer)> response,
                         ::std::function<void(::std::exception_ptr)> ex = nullptr,
                         ::std::function<void(bool)> sent = nullptr,
                         const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpByteBufferSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpByteBufferSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opByteBufferSeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opByteBufferSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpByteBufferSeqResult>>&, const ByteBuffer&, const ::Ice::Context&);
    /// \endcond

    ShortBuffer opShortBufferSeq(const ShortBuffer& inSeq, ShortBuffer& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpShortBufferSeqResult>(true, this, &TestIntfPrx::_iceI_opShortBufferSeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opShortBufferSeqAsync(const ShortBuffer& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpShortBufferSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpShortBufferSeqResult, P>(false, this, &TestIntfPrx::_iceI_opShortBufferSeq, inSeq, context);
    }

    ::std::function<void()>
    opShortBufferSeqAsync(const ShortBuffer& inSeq,
                          ::std::function<void(::Test::ShortBuffer, ::Test::ShortBuffer)> response,
                          ::std::function<void(::std::exception_ptr)> ex = nullptr,
                          ::std::function<void(bool)> sent = nullptr,
                          const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpShortBufferSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpShortBufferSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opShortBufferSeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opShortBufferSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpShortBufferSeqResult>>&, const ShortBuffer&, const ::Ice::Context&);
    /// \endcond

    IntBuffer opIntBufferSeq(const IntBuffer& inSeq, IntBuffer& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpIntBufferSeqResult>(true, this, &TestIntfPrx::_iceI_opIntBufferSeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opIntBufferSeqAsync(const IntBuffer& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpIntBufferSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpIntBufferSeqResult, P>(false, this, &TestIntfPrx::_iceI_opIntBufferSeq, inSeq, context);
    }

    ::std::function<void()>
    opIntBufferSeqAsync(const IntBuffer& inSeq,
                        ::std::function<void(::Test::IntBuffer, ::Test::IntBuffer)> response,
                        ::std::function<void(::std::exception_ptr)> ex = nullptr,
                        ::std::function<void(bool)> sent = nullptr,
                        const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpIntBufferSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpIntBufferSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opIntBufferSeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opIntBufferSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpIntBufferSeqResult>>&, const IntBuffer&, const ::Ice::Context&);
    /// \endcond

    LongBuffer opLongBufferSeq(const LongBuffer& inSeq, LongBuffer& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpLongBufferSeqResult>(true, this, &TestIntfPrx::_iceI_opLongBufferSeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opLongBufferSeqAsync(const LongBuffer& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpLongBufferSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpLongBufferSeqResult, P>(false, this, &TestIntfPrx::_iceI_opLongBufferSeq, inSeq, context);
    }

    ::std::function<void()>
    opLongBufferSeqAsync(const LongBuffer& inSeq,
                         ::std::function<void(::Test::LongBuffer, ::Test::LongBuffer)> response,
                         ::std::function<void(::std::exception_ptr)> ex = nullptr,
                         ::std::function<void(bool)> sent = nullptr,
                         const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpLongBufferSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpLongBufferSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opLongBufferSeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opLongBufferSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpLongBufferSeqResult>>&, const LongBuffer&, const ::Ice::Context&);
    /// \endcond

    FloatBuffer opFloatBufferSeq(const FloatBuffer& inSeq, FloatBuffer& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpFloatBufferSeqResult>(true, this, &TestIntfPrx::_iceI_opFloatBufferSeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opFloatBufferSeqAsync(const FloatBuffer& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpFloatBufferSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpFloatBufferSeqResult, P>(false, this, &TestIntfPrx::_iceI_opFloatBufferSeq, inSeq, context);
    }

    ::std::function<void()>
    opFloatBufferSeqAsync(const FloatBuffer& inSeq,
                          ::std::function<void(::Test::FloatBuffer, ::Test::FloatBuffer)> response,
                          ::std::function<void(::std::exception_ptr)> ex = nullptr,
                          ::std::function<void(bool)> sent = nullptr,
                          const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpFloatBufferSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpFloatBufferSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opFloatBufferSeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opFloatBufferSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpFloatBufferSeqResult>>&, const FloatBuffer&, const ::Ice::Context&);
    /// \endcond

    DoubleBuffer opDoubleBufferSeq(const DoubleBuffer& inSeq, DoubleBuffer& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpDoubleBufferSeqResult>(true, this, &TestIntfPrx::_iceI_opDoubleBufferSeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opDoubleBufferSeqAsync(const DoubleBuffer& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpDoubleBufferSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpDoubleBufferSeqResult, P>(false, this, &TestIntfPrx::_iceI_opDoubleBufferSeq, inSeq, context);
    }

    ::std::function<void()>
    opDoubleBufferSeqAsync(const DoubleBuffer& inSeq,
                           ::std::function<void(::Test::DoubleBuffer, ::Test::DoubleBuffer)> response,
                           ::std::function<void(::std::exception_ptr)> ex = nullptr,
                           ::std::function<void(bool)> sent = nullptr,
                           const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpDoubleBufferSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpDoubleBufferSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opDoubleBufferSeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opDoubleBufferSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpDoubleBufferSeqResult>>&, const DoubleBuffer&, const ::Ice::Context&);
    /// \endcond

    std::optional<CSeq> opOptCSeq(const std::optional<CSeq>& inSeq, std::optional<CSeq>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpOptCSeqResult>(true, this, &TestIntfPrx::_iceI_opOptCSeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opOptCSeqAsync(const std::optional<CSeq>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpOptCSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpOptCSeqResult, P>(false, this, &TestIntfPrx::_iceI_opOptCSeq, inSeq, context);
    }

    ::std::function<void()>
    opOptCSeqAsync(const std::optional<CSeq>& inSeq,
                   ::std::function<void(std::optional<::Test::CSeq>, std::optional<::Test::CSeq>)> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpOptCSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpOptCSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opOptCSeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opOptCSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpOptCSeqResult>>&, const std::optional<CSeq>&, const ::Ice::Context&);
    /// \endcond

    std::optional<CArray> opOptCArray(const std::optional<CArray>& inSeq, std::optional<CArray>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpOptCArrayResult>(true, this, &TestIntfPrx::_iceI_opOptCArray, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opOptCArrayAsync(const std::optional<CArray>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpOptCArrayResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpOptCArrayResult, P>(false, this, &TestIntfPrx::_iceI_opOptCArray, inSeq, context);
    }

    ::std::function<void()>
    opOptCArrayAsync(const std::optional<CArray>& inSeq,
                     ::std::function<void(std::optional<::Test::CArray>, std::optional<::Test::CArray>)> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpOptCArrayResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpOptCArrayResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opOptCArray, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opOptCArray(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpOptCArrayResult>>&, const std::optional<CArray>&, const ::Ice::Context&);
    /// \endcond

    std::optional<CList> opOptCList(const std::optional<CList>& inSeq, std::optional<CList>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpOptCListResult>(true, this, &TestIntfPrx::_iceI_opOptCList, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opOptCListAsync(const std::optional<CList>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpOptCListResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpOptCListResult, P>(false, this, &TestIntfPrx::_iceI_opOptCList, inSeq, context);
    }

    ::std::function<void()>
    opOptCListAsync(const std::optional<CList>& inSeq,
                    ::std::function<void(std::optional<::Test::CList>, std::optional<::Test::CList>)> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpOptCListResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpOptCListResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opOptCList, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opOptCList(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpOptCListResult>>&, const std::optional<CList>&, const ::Ice::Context&);
    /// \endcond

    std::optional<BoolSeq> opOptBoolSeq(const std::optional<BoolSeq>& inSeq, std::optional<BoolSeq>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpOptBoolSeqResult>(true, this, &TestIntfPrx::_iceI_opOptBoolSeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opOptBoolSeqAsync(const std::optional<BoolSeq>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpOptBoolSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpOptBoolSeqResult, P>(false, this, &TestIntfPrx::_iceI_opOptBoolSeq, inSeq, context);
    }

    ::std::function<void()>
    opOptBoolSeqAsync(const std::optional<BoolSeq>& inSeq,
                      ::std::function<void(std::optional<::Test::BoolSeq>, std::optional<::Test::BoolSeq>)> response,
                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                      ::std::function<void(bool)> sent = nullptr,
                      const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpOptBoolSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpOptBoolSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opOptBoolSeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opOptBoolSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpOptBoolSeqResult>>&, const std::optional<BoolSeq>&, const ::Ice::Context&);
    /// \endcond

    std::optional<ByteSeq> opOptByteSeq(const std::optional<ByteSeq>& inSeq, std::optional<ByteSeq>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpOptByteSeqResult>(true, this, &TestIntfPrx::_iceI_opOptByteSeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opOptByteSeqAsync(const std::optional<ByteSeq>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpOptByteSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpOptByteSeqResult, P>(false, this, &TestIntfPrx::_iceI_opOptByteSeq, inSeq, context);
    }

    ::std::function<void()>
    opOptByteSeqAsync(const std::optional<ByteSeq>& inSeq,
                      ::std::function<void(std::optional<::Test::ByteSeq>, std::optional<::Test::ByteSeq>)> response,
                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                      ::std::function<void(bool)> sent = nullptr,
                      const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpOptByteSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpOptByteSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opOptByteSeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opOptByteSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpOptByteSeqResult>>&, const std::optional<ByteSeq>&, const ::Ice::Context&);
    /// \endcond

    std::optional<ShortSeq> opOptShortSeq(const std::optional<ShortSeq>& inSeq, std::optional<ShortSeq>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpOptShortSeqResult>(true, this, &TestIntfPrx::_iceI_opOptShortSeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opOptShortSeqAsync(const std::optional<ShortSeq>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpOptShortSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpOptShortSeqResult, P>(false, this, &TestIntfPrx::_iceI_opOptShortSeq, inSeq, context);
    }

    ::std::function<void()>
    opOptShortSeqAsync(const std::optional<ShortSeq>& inSeq,
                       ::std::function<void(std::optional<::Test::ShortSeq>, std::optional<::Test::ShortSeq>)> response,
                       ::std::function<void(::std::exception_ptr)> ex = nullptr,
                       ::std::function<void(bool)> sent = nullptr,
                       const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpOptShortSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpOptShortSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opOptShortSeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opOptShortSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpOptShortSeqResult>>&, const std::optional<ShortSeq>&, const ::Ice::Context&);
    /// \endcond

    std::optional<IntSeq> opOptIntSeq(const std::optional<IntSeq>& inSeq, std::optional<IntSeq>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpOptIntSeqResult>(true, this, &TestIntfPrx::_iceI_opOptIntSeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opOptIntSeqAsync(const std::optional<IntSeq>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpOptIntSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpOptIntSeqResult, P>(false, this, &TestIntfPrx::_iceI_opOptIntSeq, inSeq, context);
    }

    ::std::function<void()>
    opOptIntSeqAsync(const std::optional<IntSeq>& inSeq,
                     ::std::function<void(std::optional<::Test::IntSeq>, std::optional<::Test::IntSeq>)> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpOptIntSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpOptIntSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opOptIntSeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opOptIntSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpOptIntSeqResult>>&, const std::optional<IntSeq>&, const ::Ice::Context&);
    /// \endcond

    std::optional<LongSeq> opOptLongSeq(const std::optional<LongSeq>& inSeq, std::optional<LongSeq>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpOptLongSeqResult>(true, this, &TestIntfPrx::_iceI_opOptLongSeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opOptLongSeqAsync(const std::optional<LongSeq>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpOptLongSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpOptLongSeqResult, P>(false, this, &TestIntfPrx::_iceI_opOptLongSeq, inSeq, context);
    }

    ::std::function<void()>
    opOptLongSeqAsync(const std::optional<LongSeq>& inSeq,
                      ::std::function<void(std::optional<::Test::LongSeq>, std::optional<::Test::LongSeq>)> response,
                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                      ::std::function<void(bool)> sent = nullptr,
                      const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpOptLongSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpOptLongSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opOptLongSeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opOptLongSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpOptLongSeqResult>>&, const std::optional<LongSeq>&, const ::Ice::Context&);
    /// \endcond

    std::optional<FloatSeq> opOptFloatSeq(const std::optional<FloatSeq>& inSeq, std::optional<FloatSeq>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpOptFloatSeqResult>(true, this, &TestIntfPrx::_iceI_opOptFloatSeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opOptFloatSeqAsync(const std::optional<FloatSeq>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpOptFloatSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpOptFloatSeqResult, P>(false, this, &TestIntfPrx::_iceI_opOptFloatSeq, inSeq, context);
    }

    ::std::function<void()>
    opOptFloatSeqAsync(const std::optional<FloatSeq>& inSeq,
                       ::std::function<void(std::optional<::Test::FloatSeq>, std::optional<::Test::FloatSeq>)> response,
                       ::std::function<void(::std::exception_ptr)> ex = nullptr,
                       ::std::function<void(bool)> sent = nullptr,
                       const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpOptFloatSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpOptFloatSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opOptFloatSeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opOptFloatSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpOptFloatSeqResult>>&, const std::optional<FloatSeq>&, const ::Ice::Context&);
    /// \endcond

    std::optional<DoubleSeq> opOptDoubleSeq(const std::optional<DoubleSeq>& inSeq, std::optional<DoubleSeq>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpOptDoubleSeqResult>(true, this, &TestIntfPrx::_iceI_opOptDoubleSeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opOptDoubleSeqAsync(const std::optional<DoubleSeq>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpOptDoubleSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpOptDoubleSeqResult, P>(false, this, &TestIntfPrx::_iceI_opOptDoubleSeq, inSeq, context);
    }

    ::std::function<void()>
    opOptDoubleSeqAsync(const std::optional<DoubleSeq>& inSeq,
                        ::std::function<void(std::optional<::Test::DoubleSeq>, std::optional<::Test::DoubleSeq>)> response,
                        ::std::function<void(::std::exception_ptr)> ex = nullptr,
                        ::std::function<void(bool)> sent = nullptr,
                        const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpOptDoubleSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpOptDoubleSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opOptDoubleSeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opOptDoubleSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpOptDoubleSeqResult>>&, const std::optional<DoubleSeq>&, const ::Ice::Context&);
    /// \endcond

    std::optional<StringSeq> opOptStringSeq(const std::optional<StringSeq>& inSeq, std::optional<StringSeq>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpOptStringSeqResult>(true, this, &TestIntfPrx::_iceI_opOptStringSeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opOptStringSeqAsync(const std::optional<StringSeq>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpOptStringSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpOptStringSeqResult, P>(false, this, &TestIntfPrx::_iceI_opOptStringSeq, inSeq, context);
    }

    ::std::function<void()>
    opOptStringSeqAsync(const std::optional<StringSeq>& inSeq,
                        ::std::function<void(std::optional<::Test::StringSeq>, std::optional<::Test::StringSeq>)> response,
                        ::std::function<void(::std::exception_ptr)> ex = nullptr,
                        ::std::function<void(bool)> sent = nullptr,
                        const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpOptStringSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpOptStringSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opOptStringSeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opOptStringSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpOptStringSeqResult>>&, const std::optional<StringSeq>&, const ::Ice::Context&);
    /// \endcond

    std::optional<ESeq> opOptESeq(const std::optional<ESeq>& inSeq, std::optional<ESeq>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpOptESeqResult>(true, this, &TestIntfPrx::_iceI_opOptESeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opOptESeqAsync(const std::optional<ESeq>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpOptESeqResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpOptESeqResult, P>(false, this, &TestIntfPrx::_iceI_opOptESeq, inSeq, context);
    }

    ::std::function<void()>
    opOptESeqAsync(const std::optional<ESeq>& inSeq,
                   ::std::function<void(std::optional<::Test::ESeq>, std::optional<::Test::ESeq>)> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpOptESeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpOptESeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opOptESeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opOptESeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpOptESeqResult>>&, const std::optional<ESeq>&, const ::Ice::Context&);
    /// \endcond

    std::optional<SSeq> opOptSSeq(const std::optional<SSeq>& inSeq, std::optional<SSeq>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpOptSSeqResult>(true, this, &TestIntfPrx::_iceI_opOptSSeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opOptSSeqAsync(const std::optional<SSeq>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpOptSSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpOptSSeqResult, P>(false, this, &TestIntfPrx::_iceI_opOptSSeq, inSeq, context);
    }

    ::std::function<void()>
    opOptSSeqAsync(const std::optional<SSeq>& inSeq,
                   ::std::function<void(std::optional<::Test::SSeq>, std::optional<::Test::SSeq>)> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpOptSSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpOptSSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opOptSSeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opOptSSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpOptSSeqResult>>&, const std::optional<SSeq>&, const ::Ice::Context&);
    /// \endcond

    std::optional<DSeq> opOptDSeq(const std::optional<DSeq>& inSeq, std::optional<DSeq>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpOptDSeqResult>(true, this, &TestIntfPrx::_iceI_opOptDSeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opOptDSeqAsync(const std::optional<DSeq>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpOptDSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpOptDSeqResult, P>(false, this, &TestIntfPrx::_iceI_opOptDSeq, inSeq, context);
    }

    ::std::function<void()>
    opOptDSeqAsync(const std::optional<DSeq>& inSeq,
                   ::std::function<void(std::optional<::Test::DSeq>, std::optional<::Test::DSeq>)> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpOptDSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpOptDSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opOptDSeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opOptDSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpOptDSeqResult>>&, const std::optional<DSeq>&, const ::Ice::Context&);
    /// \endcond

    std::optional<StringSeqSeq> opOptStringSeqSeq(const std::optional<StringSeqSeq>& inSeq, std::optional<StringSeqSeq>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpOptStringSeqSeqResult>(true, this, &TestIntfPrx::_iceI_opOptStringSeqSeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opOptStringSeqSeqAsync(const std::optional<StringSeqSeq>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpOptStringSeqSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpOptStringSeqSeqResult, P>(false, this, &TestIntfPrx::_iceI_opOptStringSeqSeq, inSeq, context);
    }

    ::std::function<void()>
    opOptStringSeqSeqAsync(const std::optional<StringSeqSeq>& inSeq,
                           ::std::function<void(std::optional<::Test::StringSeqSeq>, std::optional<::Test::StringSeqSeq>)> response,
                           ::std::function<void(::std::exception_ptr)> ex = nullptr,
                           ::std::function<void(bool)> sent = nullptr,
                           const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpOptStringSeqSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpOptStringSeqSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opOptStringSeqSeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opOptStringSeqSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpOptStringSeqSeqResult>>&, const std::optional<StringSeqSeq>&, const ::Ice::Context&);
    /// \endcond

    std::optional<ByteBuffer> opOptByteBufferSeq(const std::optional<ByteBuffer>& inSeq, std::optional<ByteBuffer>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpOptByteBufferSeqResult>(true, this, &TestIntfPrx::_iceI_opOptByteBufferSeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opOptByteBufferSeqAsync(const std::optional<ByteBuffer>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpOptByteBufferSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpOptByteBufferSeqResult, P>(false, this, &TestIntfPrx::_iceI_opOptByteBufferSeq, inSeq, context);
    }

    ::std::function<void()>
    opOptByteBufferSeqAsync(const std::optional<ByteBuffer>& inSeq,
                            ::std::function<void(std::optional<::Test::ByteBuffer>, std::optional<::Test::ByteBuffer>)> response,
                            ::std::function<void(::std::exception_ptr)> ex = nullptr,
                            ::std::function<void(bool)> sent = nullptr,
                            const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpOptByteBufferSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpOptByteBufferSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opOptByteBufferSeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opOptByteBufferSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpOptByteBufferSeqResult>>&, const std::optional<ByteBuffer>&, const ::Ice::Context&);
    /// \endcond

    std::optional<ShortBuffer> opOptShortBufferSeq(const std::optional<ShortBuffer>& inSeq, std::optional<ShortBuffer>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpOptShortBufferSeqResult>(true, this, &TestIntfPrx::_iceI_opOptShortBufferSeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opOptShortBufferSeqAsync(const std::optional<ShortBuffer>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpOptShortBufferSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpOptShortBufferSeqResult, P>(false, this, &TestIntfPrx::_iceI_opOptShortBufferSeq, inSeq, context);
    }

    ::std::function<void()>
    opOptShortBufferSeqAsync(const std::optional<ShortBuffer>& inSeq,
                             ::std::function<void(std::optional<::Test::ShortBuffer>, std::optional<::Test::ShortBuffer>)> response,
                             ::std::function<void(::std::exception_ptr)> ex = nullptr,
                             ::std::function<void(bool)> sent = nullptr,
                             const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpOptShortBufferSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpOptShortBufferSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opOptShortBufferSeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opOptShortBufferSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpOptShortBufferSeqResult>>&, const std::optional<ShortBuffer>&, const ::Ice::Context&);
    /// \endcond

    std::optional<IntBuffer> opOptIntBufferSeq(const std::optional<IntBuffer>& inSeq, std::optional<IntBuffer>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpOptIntBufferSeqResult>(true, this, &TestIntfPrx::_iceI_opOptIntBufferSeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opOptIntBufferSeqAsync(const std::optional<IntBuffer>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpOptIntBufferSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpOptIntBufferSeqResult, P>(false, this, &TestIntfPrx::_iceI_opOptIntBufferSeq, inSeq, context);
    }

    ::std::function<void()>
    opOptIntBufferSeqAsync(const std::optional<IntBuffer>& inSeq,
                           ::std::function<void(std::optional<::Test::IntBuffer>, std::optional<::Test::IntBuffer>)> response,
                           ::std::function<void(::std::exception_ptr)> ex = nullptr,
                           ::std::function<void(bool)> sent = nullptr,
                           const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpOptIntBufferSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpOptIntBufferSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opOptIntBufferSeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opOptIntBufferSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpOptIntBufferSeqResult>>&, const std::optional<IntBuffer>&, const ::Ice::Context&);
    /// \endcond

    std::optional<LongBuffer> opOptLongBufferSeq(const std::optional<LongBuffer>& inSeq, std::optional<LongBuffer>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpOptLongBufferSeqResult>(true, this, &TestIntfPrx::_iceI_opOptLongBufferSeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opOptLongBufferSeqAsync(const std::optional<LongBuffer>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpOptLongBufferSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpOptLongBufferSeqResult, P>(false, this, &TestIntfPrx::_iceI_opOptLongBufferSeq, inSeq, context);
    }

    ::std::function<void()>
    opOptLongBufferSeqAsync(const std::optional<LongBuffer>& inSeq,
                            ::std::function<void(std::optional<::Test::LongBuffer>, std::optional<::Test::LongBuffer>)> response,
                            ::std::function<void(::std::exception_ptr)> ex = nullptr,
                            ::std::function<void(bool)> sent = nullptr,
                            const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpOptLongBufferSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpOptLongBufferSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opOptLongBufferSeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opOptLongBufferSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpOptLongBufferSeqResult>>&, const std::optional<LongBuffer>&, const ::Ice::Context&);
    /// \endcond

    std::optional<FloatBuffer> opOptFloatBufferSeq(const std::optional<FloatBuffer>& inSeq, std::optional<FloatBuffer>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpOptFloatBufferSeqResult>(true, this, &TestIntfPrx::_iceI_opOptFloatBufferSeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opOptFloatBufferSeqAsync(const std::optional<FloatBuffer>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpOptFloatBufferSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpOptFloatBufferSeqResult, P>(false, this, &TestIntfPrx::_iceI_opOptFloatBufferSeq, inSeq, context);
    }

    ::std::function<void()>
    opOptFloatBufferSeqAsync(const std::optional<FloatBuffer>& inSeq,
                             ::std::function<void(std::optional<::Test::FloatBuffer>, std::optional<::Test::FloatBuffer>)> response,
                             ::std::function<void(::std::exception_ptr)> ex = nullptr,
                             ::std::function<void(bool)> sent = nullptr,
                             const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpOptFloatBufferSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpOptFloatBufferSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opOptFloatBufferSeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opOptFloatBufferSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpOptFloatBufferSeqResult>>&, const std::optional<FloatBuffer>&, const ::Ice::Context&);
    /// \endcond

    std::optional<DoubleBuffer> opOptDoubleBufferSeq(const std::optional<DoubleBuffer>& inSeq, std::optional<DoubleBuffer>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<TestIntf::OpOptDoubleBufferSeqResult>(true, this, &TestIntfPrx::_iceI_opOptDoubleBufferSeq, inSeq, context).get();
        outSeq = ::std::move(_result.outSeq);
        return ::std::move(_result.returnValue);
    }

    template<template<typename> class P = ::std::promise>
    auto opOptDoubleBufferSeqAsync(const std::optional<DoubleBuffer>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<TestIntf::OpOptDoubleBufferSeqResult>>().get_future())
    {
        return _makePromiseOutgoing<TestIntf::OpOptDoubleBufferSeqResult, P>(false, this, &TestIntfPrx::_iceI_opOptDoubleBufferSeq, inSeq, context);
    }

    ::std::function<void()>
    opOptDoubleBufferSeqAsync(const std::optional<DoubleBuffer>& inSeq,
                              ::std::function<void(std::optional<::Test::DoubleBuffer>, std::optional<::Test::DoubleBuffer>)> response,
                              ::std::function<void(::std::exception_ptr)> ex = nullptr,
                              ::std::function<void(bool)> sent = nullptr,
                              const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](TestIntf::OpOptDoubleBufferSeqResult&& _result)
        {
            response(::std::move(_result.returnValue), ::std::move(_result.outSeq));
        };
        return _makeLambdaOutgoing<TestIntf::OpOptDoubleBufferSeqResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_opOptDoubleBufferSeq, inSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_opOptDoubleBufferSeq(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<TestIntf::OpOptDoubleBufferSeqResult>>&, const std::optional<DoubleBuffer>&, const ::Ice::Context&);
    /// \endcond

    void shutdown(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &TestIntfPrx::_iceI_shutdown, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto shutdownAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &TestIntfPrx::_iceI_shutdown, context);
    }

    ::std::function<void()>
    shutdownAsync(::std::function<void()> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_shutdown, context);
    }

    /// \cond INTERNAL
    void _iceI_shutdown(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    TestIntfPrx() = default;
    friend ::std::shared_ptr<TestIntfPrx> IceInternal::createProxy<TestIntfPrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

}

/// \cond STREAM
namespace Ice
{

template<>
struct StreamableTraits< ::Test::E>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 2;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits<::Test::S>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::Test::S, S>
{
    static void read(S* istr, ::Test::S& v)
    {
        istr->readAll(v.en);
    }
};

}
/// \endcond

/// \cond INTERNAL
namespace Test
{

using CPtr = ::std::shared_ptr<C>;

using TestIntfPtr = ::std::shared_ptr<TestIntf>;
using TestIntfPrxPtr = ::std::shared_ptr<TestIntfPrx>;

}
/// \endcond

#else // C++98 mapping

namespace IceProxy
{

namespace Test
{

class C;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< C>&);
::IceProxy::Ice::Object* upCast(C*);
/// \endcond

class TestIntf;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< TestIntf>&);
::IceProxy::Ice::Object* upCast(TestIntf*);
/// \endcond

}

}

namespace Test
{

class C;
/// \cond INTERNAL
::Ice::Object* upCast(C*);
/// \endcond
typedef ::IceInternal::Handle< C> CPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::C> CPrx;
typedef CPrx CPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(CPtr&, const ::Ice::ObjectPtr&);
/// \endcond

class TestIntf;
/// \cond INTERNAL
::Ice::Object* upCast(TestIntf*);
/// \endcond
typedef ::IceInternal::Handle< TestIntf> TestIntfPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::TestIntf> TestIntfPrx;
typedef TestIntfPrx TestIntfPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(TestIntfPtr&, const ::Ice::ObjectPtr&);
/// \endcond

}

namespace Test
{

typedef ::std::vector<CPtr> CSeq;

typedef ::std::vector<CPtr> CArray;

typedef ::std::vector<CPtr> CList;

typedef ::std::vector<bool> BoolSeq;

typedef ::std::vector< ::Ice::Byte> ByteSeq;

typedef ::std::vector< ::Ice::Short> ShortSeq;

typedef ::std::vector< ::Ice::Int> IntSeq;

typedef ::std::vector< ::Ice::Long> LongSeq;

typedef ::std::vector< ::Ice::Float> FloatSeq;

typedef ::std::vector< ::Ice::Double> DoubleSeq;

typedef ::std::vector< ::std::string> StringSeq;

typedef ::std::vector< ::Ice::Byte> ByteBuffer;

typedef ::std::vector< ::Ice::Short> ShortBuffer;

typedef ::std::vector< ::Ice::Int> IntBuffer;

typedef ::std::vector< ::Ice::Long> LongBuffer;

typedef ::std::vector< ::Ice::Float> FloatBuffer;

typedef ::std::vector< ::Ice::Double> DoubleBuffer;

enum E
{
    E1,
    E2,
    E3
};

typedef ::std::vector<E> ESeq;

struct S
{
    ::Test::E en;

    bool operator==(const S& rhs_) const
    {
        if(this == &rhs_)
        {
            return true;
        }
        if(en != rhs_.en)
        {
            return false;
        }
        return true;
    }

    bool operator<(const S& rhs_) const
    {
        if(this == &rhs_)
        {
            return false;
        }
        if(en < rhs_.en)
        {
            return true;
        }
        else if(rhs_.en < en)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const S& rhs_) const
    {
        return !operator==(rhs_);
    }
    bool operator<=(const S& rhs_) const
    {
        return operator<(rhs_) || operator==(rhs_);
    }
    bool operator>(const S& rhs_) const
    {
        return !operator<(rhs_) && !operator==(rhs_);
    }
    bool operator>=(const S& rhs_) const
    {
        return !operator<(rhs_);
    }
};

typedef ::std::vector<S> SSeq;

typedef ::std::map< ::Ice::Int, ::std::string> D;

typedef ::std::vector<D> DSeq;

typedef ::std::vector<StringSeq> StringSeqSeq;

}

namespace Test
{

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opCSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opCSeq.
 */
class Callback_TestIntf_opCSeq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opCSeq_Base> Callback_TestIntf_opCSeqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opCArray.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opCArray.
 */
class Callback_TestIntf_opCArray_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opCArray_Base> Callback_TestIntf_opCArrayPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opCList.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opCList.
 */
class Callback_TestIntf_opCList_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opCList_Base> Callback_TestIntf_opCListPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opBoolSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opBoolSeq.
 */
class Callback_TestIntf_opBoolSeq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opBoolSeq_Base> Callback_TestIntf_opBoolSeqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opByteSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opByteSeq.
 */
class Callback_TestIntf_opByteSeq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opByteSeq_Base> Callback_TestIntf_opByteSeqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opShortSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opShortSeq.
 */
class Callback_TestIntf_opShortSeq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opShortSeq_Base> Callback_TestIntf_opShortSeqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opIntSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opIntSeq.
 */
class Callback_TestIntf_opIntSeq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opIntSeq_Base> Callback_TestIntf_opIntSeqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opLongSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opLongSeq.
 */
class Callback_TestIntf_opLongSeq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opLongSeq_Base> Callback_TestIntf_opLongSeqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opFloatSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opFloatSeq.
 */
class Callback_TestIntf_opFloatSeq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opFloatSeq_Base> Callback_TestIntf_opFloatSeqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opDoubleSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opDoubleSeq.
 */
class Callback_TestIntf_opDoubleSeq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opDoubleSeq_Base> Callback_TestIntf_opDoubleSeqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opStringSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opStringSeq.
 */
class Callback_TestIntf_opStringSeq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opStringSeq_Base> Callback_TestIntf_opStringSeqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opESeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opESeq.
 */
class Callback_TestIntf_opESeq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opESeq_Base> Callback_TestIntf_opESeqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opSSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opSSeq.
 */
class Callback_TestIntf_opSSeq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opSSeq_Base> Callback_TestIntf_opSSeqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opDSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opDSeq.
 */
class Callback_TestIntf_opDSeq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opDSeq_Base> Callback_TestIntf_opDSeqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opStringSeqSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opStringSeqSeq.
 */
class Callback_TestIntf_opStringSeqSeq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opStringSeqSeq_Base> Callback_TestIntf_opStringSeqSeqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opByteBufferSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opByteBufferSeq.
 */
class Callback_TestIntf_opByteBufferSeq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opByteBufferSeq_Base> Callback_TestIntf_opByteBufferSeqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opShortBufferSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opShortBufferSeq.
 */
class Callback_TestIntf_opShortBufferSeq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opShortBufferSeq_Base> Callback_TestIntf_opShortBufferSeqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opIntBufferSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opIntBufferSeq.
 */
class Callback_TestIntf_opIntBufferSeq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opIntBufferSeq_Base> Callback_TestIntf_opIntBufferSeqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opLongBufferSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opLongBufferSeq.
 */
class Callback_TestIntf_opLongBufferSeq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opLongBufferSeq_Base> Callback_TestIntf_opLongBufferSeqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opFloatBufferSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opFloatBufferSeq.
 */
class Callback_TestIntf_opFloatBufferSeq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opFloatBufferSeq_Base> Callback_TestIntf_opFloatBufferSeqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opDoubleBufferSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opDoubleBufferSeq.
 */
class Callback_TestIntf_opDoubleBufferSeq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opDoubleBufferSeq_Base> Callback_TestIntf_opDoubleBufferSeqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opOptCSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opOptCSeq.
 */
class Callback_TestIntf_opOptCSeq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opOptCSeq_Base> Callback_TestIntf_opOptCSeqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opOptCArray.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opOptCArray.
 */
class Callback_TestIntf_opOptCArray_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opOptCArray_Base> Callback_TestIntf_opOptCArrayPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opOptCList.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opOptCList.
 */
class Callback_TestIntf_opOptCList_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opOptCList_Base> Callback_TestIntf_opOptCListPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opOptBoolSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opOptBoolSeq.
 */
class Callback_TestIntf_opOptBoolSeq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opOptBoolSeq_Base> Callback_TestIntf_opOptBoolSeqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opOptByteSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opOptByteSeq.
 */
class Callback_TestIntf_opOptByteSeq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opOptByteSeq_Base> Callback_TestIntf_opOptByteSeqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opOptShortSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opOptShortSeq.
 */
class Callback_TestIntf_opOptShortSeq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opOptShortSeq_Base> Callback_TestIntf_opOptShortSeqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opOptIntSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opOptIntSeq.
 */
class Callback_TestIntf_opOptIntSeq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opOptIntSeq_Base> Callback_TestIntf_opOptIntSeqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opOptLongSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opOptLongSeq.
 */
class Callback_TestIntf_opOptLongSeq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opOptLongSeq_Base> Callback_TestIntf_opOptLongSeqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opOptFloatSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opOptFloatSeq.
 */
class Callback_TestIntf_opOptFloatSeq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opOptFloatSeq_Base> Callback_TestIntf_opOptFloatSeqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opOptDoubleSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opOptDoubleSeq.
 */
class Callback_TestIntf_opOptDoubleSeq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opOptDoubleSeq_Base> Callback_TestIntf_opOptDoubleSeqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opOptStringSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opOptStringSeq.
 */
class Callback_TestIntf_opOptStringSeq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opOptStringSeq_Base> Callback_TestIntf_opOptStringSeqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opOptESeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opOptESeq.
 */
class Callback_TestIntf_opOptESeq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opOptESeq_Base> Callback_TestIntf_opOptESeqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opOptSSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opOptSSeq.
 */
class Callback_TestIntf_opOptSSeq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opOptSSeq_Base> Callback_TestIntf_opOptSSeqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opOptDSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opOptDSeq.
 */
class Callback_TestIntf_opOptDSeq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opOptDSeq_Base> Callback_TestIntf_opOptDSeqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opOptStringSeqSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opOptStringSeqSeq.
 */
class Callback_TestIntf_opOptStringSeqSeq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opOptStringSeqSeq_Base> Callback_TestIntf_opOptStringSeqSeqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opOptByteBufferSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opOptByteBufferSeq.
 */
class Callback_TestIntf_opOptByteBufferSeq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opOptByteBufferSeq_Base> Callback_TestIntf_opOptByteBufferSeqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opOptShortBufferSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opOptShortBufferSeq.
 */
class Callback_TestIntf_opOptShortBufferSeq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opOptShortBufferSeq_Base> Callback_TestIntf_opOptShortBufferSeqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opOptIntBufferSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opOptIntBufferSeq.
 */
class Callback_TestIntf_opOptIntBufferSeq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opOptIntBufferSeq_Base> Callback_TestIntf_opOptIntBufferSeqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opOptLongBufferSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opOptLongBufferSeq.
 */
class Callback_TestIntf_opOptLongBufferSeq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opOptLongBufferSeq_Base> Callback_TestIntf_opOptLongBufferSeqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opOptFloatBufferSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opOptFloatBufferSeq.
 */
class Callback_TestIntf_opOptFloatBufferSeq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opOptFloatBufferSeq_Base> Callback_TestIntf_opOptFloatBufferSeqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_opOptDoubleBufferSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opOptDoubleBufferSeq.
 */
class Callback_TestIntf_opOptDoubleBufferSeq_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_opOptDoubleBufferSeq_Base> Callback_TestIntf_opOptDoubleBufferSeqPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::TestIntf::begin_shutdown.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_shutdown.
 */
class Callback_TestIntf_shutdown_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_TestIntf_shutdown_Base> Callback_TestIntf_shutdownPtr;

}

namespace IceProxy
{

namespace Test
{

class C : public virtual ::Ice::Proxy<C, ::IceProxy::Ice::Object>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class TestIntf : public virtual ::Ice::Proxy<TestIntf, ::IceProxy::Ice::Object>
{
public:

    ::Test::CSeq opCSeq(const ::Test::CSeq& inSeq, ::Test::CSeq& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opCSeq(outSeq, _iceI_begin_opCSeq(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opCSeq(const ::Test::CSeq& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opCSeq(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opCSeq(const ::Test::CSeq& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opCSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opCSeq(const ::Test::CSeq& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opCSeq(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opCSeq(const ::Test::CSeq& inSeq, const ::Test::Callback_TestIntf_opCSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opCSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opCSeq(const ::Test::CSeq& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opCSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opCSeq(inSeq, context, cb, cookie);
    }

    ::Test::CSeq end_opCSeq(::Test::CSeq& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opCSeq(::Test::CSeq& iceP_outSeq, ::Test::CSeq& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opCSeq(const ::Test::CSeq&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::CArray opCArray(const ::Test::CArray& inSeq, ::Test::CArray& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opCArray(outSeq, _iceI_begin_opCArray(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opCArray(const ::Test::CArray& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opCArray(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opCArray(const ::Test::CArray& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opCArray(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opCArray(const ::Test::CArray& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opCArray(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opCArray(const ::Test::CArray& inSeq, const ::Test::Callback_TestIntf_opCArrayPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opCArray(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opCArray(const ::Test::CArray& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opCArrayPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opCArray(inSeq, context, cb, cookie);
    }

    ::Test::CArray end_opCArray(::Test::CArray& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opCArray(::Test::CArray& iceP_outSeq, ::Test::CArray& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opCArray(const ::Test::CArray&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::CList opCList(const ::Test::CList& inSeq, ::Test::CList& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opCList(outSeq, _iceI_begin_opCList(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opCList(const ::Test::CList& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opCList(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opCList(const ::Test::CList& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opCList(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opCList(const ::Test::CList& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opCList(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opCList(const ::Test::CList& inSeq, const ::Test::Callback_TestIntf_opCListPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opCList(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opCList(const ::Test::CList& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opCListPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opCList(inSeq, context, cb, cookie);
    }

    ::Test::CList end_opCList(::Test::CList& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opCList(::Test::CList& iceP_outSeq, ::Test::CList& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opCList(const ::Test::CList&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::BoolSeq opBoolSeq(const ::Test::BoolSeq& inSeq, ::Test::BoolSeq& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opBoolSeq(outSeq, _iceI_begin_opBoolSeq(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opBoolSeq(const ::Test::BoolSeq& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opBoolSeq(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opBoolSeq(const ::Test::BoolSeq& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opBoolSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opBoolSeq(const ::Test::BoolSeq& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opBoolSeq(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opBoolSeq(const ::Test::BoolSeq& inSeq, const ::Test::Callback_TestIntf_opBoolSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opBoolSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opBoolSeq(const ::Test::BoolSeq& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opBoolSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opBoolSeq(inSeq, context, cb, cookie);
    }

    ::Test::BoolSeq end_opBoolSeq(::Test::BoolSeq& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opBoolSeq(::Test::BoolSeq& iceP_outSeq, ::Test::BoolSeq& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opBoolSeq(const ::Test::BoolSeq&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::ByteSeq opByteSeq(const ::Test::ByteSeq& inSeq, ::Test::ByteSeq& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opByteSeq(outSeq, _iceI_begin_opByteSeq(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opByteSeq(const ::Test::ByteSeq& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opByteSeq(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opByteSeq(const ::Test::ByteSeq& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByteSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opByteSeq(const ::Test::ByteSeq& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByteSeq(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opByteSeq(const ::Test::ByteSeq& inSeq, const ::Test::Callback_TestIntf_opByteSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByteSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opByteSeq(const ::Test::ByteSeq& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opByteSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByteSeq(inSeq, context, cb, cookie);
    }

    ::Test::ByteSeq end_opByteSeq(::Test::ByteSeq& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opByteSeq(::Test::ByteSeq& iceP_outSeq, ::Test::ByteSeq& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opByteSeq(const ::Test::ByteSeq&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::ShortSeq opShortSeq(const ::Test::ShortSeq& inSeq, ::Test::ShortSeq& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opShortSeq(outSeq, _iceI_begin_opShortSeq(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opShortSeq(const ::Test::ShortSeq& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opShortSeq(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opShortSeq(const ::Test::ShortSeq& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opShortSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opShortSeq(const ::Test::ShortSeq& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opShortSeq(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opShortSeq(const ::Test::ShortSeq& inSeq, const ::Test::Callback_TestIntf_opShortSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opShortSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opShortSeq(const ::Test::ShortSeq& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opShortSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opShortSeq(inSeq, context, cb, cookie);
    }

    ::Test::ShortSeq end_opShortSeq(::Test::ShortSeq& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opShortSeq(::Test::ShortSeq& iceP_outSeq, ::Test::ShortSeq& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opShortSeq(const ::Test::ShortSeq&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::IntSeq opIntSeq(const ::Test::IntSeq& inSeq, ::Test::IntSeq& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opIntSeq(outSeq, _iceI_begin_opIntSeq(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opIntSeq(const ::Test::IntSeq& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opIntSeq(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opIntSeq(const ::Test::IntSeq& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opIntSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opIntSeq(const ::Test::IntSeq& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opIntSeq(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opIntSeq(const ::Test::IntSeq& inSeq, const ::Test::Callback_TestIntf_opIntSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opIntSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opIntSeq(const ::Test::IntSeq& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opIntSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opIntSeq(inSeq, context, cb, cookie);
    }

    ::Test::IntSeq end_opIntSeq(::Test::IntSeq& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opIntSeq(::Test::IntSeq& iceP_outSeq, ::Test::IntSeq& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opIntSeq(const ::Test::IntSeq&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::LongSeq opLongSeq(const ::Test::LongSeq& inSeq, ::Test::LongSeq& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opLongSeq(outSeq, _iceI_begin_opLongSeq(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opLongSeq(const ::Test::LongSeq& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opLongSeq(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opLongSeq(const ::Test::LongSeq& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opLongSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opLongSeq(const ::Test::LongSeq& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opLongSeq(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opLongSeq(const ::Test::LongSeq& inSeq, const ::Test::Callback_TestIntf_opLongSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opLongSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opLongSeq(const ::Test::LongSeq& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opLongSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opLongSeq(inSeq, context, cb, cookie);
    }

    ::Test::LongSeq end_opLongSeq(::Test::LongSeq& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opLongSeq(::Test::LongSeq& iceP_outSeq, ::Test::LongSeq& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opLongSeq(const ::Test::LongSeq&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::FloatSeq opFloatSeq(const ::Test::FloatSeq& inSeq, ::Test::FloatSeq& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opFloatSeq(outSeq, _iceI_begin_opFloatSeq(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opFloatSeq(const ::Test::FloatSeq& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opFloatSeq(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opFloatSeq(const ::Test::FloatSeq& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opFloatSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opFloatSeq(const ::Test::FloatSeq& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opFloatSeq(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opFloatSeq(const ::Test::FloatSeq& inSeq, const ::Test::Callback_TestIntf_opFloatSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opFloatSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opFloatSeq(const ::Test::FloatSeq& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opFloatSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opFloatSeq(inSeq, context, cb, cookie);
    }

    ::Test::FloatSeq end_opFloatSeq(::Test::FloatSeq& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opFloatSeq(::Test::FloatSeq& iceP_outSeq, ::Test::FloatSeq& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opFloatSeq(const ::Test::FloatSeq&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::DoubleSeq opDoubleSeq(const ::Test::DoubleSeq& inSeq, ::Test::DoubleSeq& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opDoubleSeq(outSeq, _iceI_begin_opDoubleSeq(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opDoubleSeq(const ::Test::DoubleSeq& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opDoubleSeq(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opDoubleSeq(const ::Test::DoubleSeq& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opDoubleSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opDoubleSeq(const ::Test::DoubleSeq& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opDoubleSeq(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opDoubleSeq(const ::Test::DoubleSeq& inSeq, const ::Test::Callback_TestIntf_opDoubleSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opDoubleSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opDoubleSeq(const ::Test::DoubleSeq& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opDoubleSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opDoubleSeq(inSeq, context, cb, cookie);
    }

    ::Test::DoubleSeq end_opDoubleSeq(::Test::DoubleSeq& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opDoubleSeq(::Test::DoubleSeq& iceP_outSeq, ::Test::DoubleSeq& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opDoubleSeq(const ::Test::DoubleSeq&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::StringSeq opStringSeq(const ::Test::StringSeq& inSeq, ::Test::StringSeq& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opStringSeq(outSeq, _iceI_begin_opStringSeq(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opStringSeq(const ::Test::StringSeq& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opStringSeq(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opStringSeq(const ::Test::StringSeq& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringSeq(const ::Test::StringSeq& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringSeq(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringSeq(const ::Test::StringSeq& inSeq, const ::Test::Callback_TestIntf_opStringSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringSeq(const ::Test::StringSeq& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opStringSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringSeq(inSeq, context, cb, cookie);
    }

    ::Test::StringSeq end_opStringSeq(::Test::StringSeq& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opStringSeq(::Test::StringSeq& iceP_outSeq, ::Test::StringSeq& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opStringSeq(const ::Test::StringSeq&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::ESeq opESeq(const ::Test::ESeq& inSeq, ::Test::ESeq& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opESeq(outSeq, _iceI_begin_opESeq(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opESeq(const ::Test::ESeq& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opESeq(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opESeq(const ::Test::ESeq& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opESeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opESeq(const ::Test::ESeq& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opESeq(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opESeq(const ::Test::ESeq& inSeq, const ::Test::Callback_TestIntf_opESeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opESeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opESeq(const ::Test::ESeq& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opESeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opESeq(inSeq, context, cb, cookie);
    }

    ::Test::ESeq end_opESeq(::Test::ESeq& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opESeq(::Test::ESeq& iceP_outSeq, ::Test::ESeq& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opESeq(const ::Test::ESeq&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::SSeq opSSeq(const ::Test::SSeq& inSeq, ::Test::SSeq& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opSSeq(outSeq, _iceI_begin_opSSeq(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opSSeq(const ::Test::SSeq& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opSSeq(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opSSeq(const ::Test::SSeq& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opSSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opSSeq(const ::Test::SSeq& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opSSeq(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opSSeq(const ::Test::SSeq& inSeq, const ::Test::Callback_TestIntf_opSSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opSSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opSSeq(const ::Test::SSeq& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opSSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opSSeq(inSeq, context, cb, cookie);
    }

    ::Test::SSeq end_opSSeq(::Test::SSeq& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opSSeq(::Test::SSeq& iceP_outSeq, ::Test::SSeq& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opSSeq(const ::Test::SSeq&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::DSeq opDSeq(const ::Test::DSeq& inSeq, ::Test::DSeq& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opDSeq(outSeq, _iceI_begin_opDSeq(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opDSeq(const ::Test::DSeq& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opDSeq(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opDSeq(const ::Test::DSeq& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opDSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opDSeq(const ::Test::DSeq& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opDSeq(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opDSeq(const ::Test::DSeq& inSeq, const ::Test::Callback_TestIntf_opDSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opDSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opDSeq(const ::Test::DSeq& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opDSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opDSeq(inSeq, context, cb, cookie);
    }

    ::Test::DSeq end_opDSeq(::Test::DSeq& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opDSeq(::Test::DSeq& iceP_outSeq, ::Test::DSeq& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opDSeq(const ::Test::DSeq&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::StringSeqSeq opStringSeqSeq(const ::Test::StringSeqSeq& inSeq, ::Test::StringSeqSeq& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opStringSeqSeq(outSeq, _iceI_begin_opStringSeqSeq(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opStringSeqSeq(const ::Test::StringSeqSeq& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opStringSeqSeq(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opStringSeqSeq(const ::Test::StringSeqSeq& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringSeqSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringSeqSeq(const ::Test::StringSeqSeq& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringSeqSeq(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringSeqSeq(const ::Test::StringSeqSeq& inSeq, const ::Test::Callback_TestIntf_opStringSeqSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringSeqSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opStringSeqSeq(const ::Test::StringSeqSeq& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opStringSeqSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opStringSeqSeq(inSeq, context, cb, cookie);
    }

    ::Test::StringSeqSeq end_opStringSeqSeq(::Test::StringSeqSeq& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opStringSeqSeq(::Test::StringSeqSeq& iceP_outSeq, ::Test::StringSeqSeq& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opStringSeqSeq(const ::Test::StringSeqSeq&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::ByteBuffer opByteBufferSeq(const ::Test::ByteBuffer& inSeq, ::Test::ByteBuffer& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opByteBufferSeq(outSeq, _iceI_begin_opByteBufferSeq(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opByteBufferSeq(const ::Test::ByteBuffer& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opByteBufferSeq(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opByteBufferSeq(const ::Test::ByteBuffer& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByteBufferSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opByteBufferSeq(const ::Test::ByteBuffer& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByteBufferSeq(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opByteBufferSeq(const ::Test::ByteBuffer& inSeq, const ::Test::Callback_TestIntf_opByteBufferSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByteBufferSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opByteBufferSeq(const ::Test::ByteBuffer& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opByteBufferSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opByteBufferSeq(inSeq, context, cb, cookie);
    }

    ::Test::ByteBuffer end_opByteBufferSeq(::Test::ByteBuffer& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opByteBufferSeq(::Test::ByteBuffer& iceP_outSeq, ::Test::ByteBuffer& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opByteBufferSeq(const ::Test::ByteBuffer&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::ShortBuffer opShortBufferSeq(const ::Test::ShortBuffer& inSeq, ::Test::ShortBuffer& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opShortBufferSeq(outSeq, _iceI_begin_opShortBufferSeq(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opShortBufferSeq(const ::Test::ShortBuffer& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opShortBufferSeq(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opShortBufferSeq(const ::Test::ShortBuffer& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opShortBufferSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opShortBufferSeq(const ::Test::ShortBuffer& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opShortBufferSeq(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opShortBufferSeq(const ::Test::ShortBuffer& inSeq, const ::Test::Callback_TestIntf_opShortBufferSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opShortBufferSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opShortBufferSeq(const ::Test::ShortBuffer& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opShortBufferSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opShortBufferSeq(inSeq, context, cb, cookie);
    }

    ::Test::ShortBuffer end_opShortBufferSeq(::Test::ShortBuffer& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opShortBufferSeq(::Test::ShortBuffer& iceP_outSeq, ::Test::ShortBuffer& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opShortBufferSeq(const ::Test::ShortBuffer&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::IntBuffer opIntBufferSeq(const ::Test::IntBuffer& inSeq, ::Test::IntBuffer& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opIntBufferSeq(outSeq, _iceI_begin_opIntBufferSeq(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opIntBufferSeq(const ::Test::IntBuffer& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opIntBufferSeq(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opIntBufferSeq(const ::Test::IntBuffer& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opIntBufferSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opIntBufferSeq(const ::Test::IntBuffer& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opIntBufferSeq(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opIntBufferSeq(const ::Test::IntBuffer& inSeq, const ::Test::Callback_TestIntf_opIntBufferSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opIntBufferSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opIntBufferSeq(const ::Test::IntBuffer& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opIntBufferSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opIntBufferSeq(inSeq, context, cb, cookie);
    }

    ::Test::IntBuffer end_opIntBufferSeq(::Test::IntBuffer& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opIntBufferSeq(::Test::IntBuffer& iceP_outSeq, ::Test::IntBuffer& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opIntBufferSeq(const ::Test::IntBuffer&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::LongBuffer opLongBufferSeq(const ::Test::LongBuffer& inSeq, ::Test::LongBuffer& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opLongBufferSeq(outSeq, _iceI_begin_opLongBufferSeq(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opLongBufferSeq(const ::Test::LongBuffer& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opLongBufferSeq(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opLongBufferSeq(const ::Test::LongBuffer& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opLongBufferSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opLongBufferSeq(const ::Test::LongBuffer& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opLongBufferSeq(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opLongBufferSeq(const ::Test::LongBuffer& inSeq, const ::Test::Callback_TestIntf_opLongBufferSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opLongBufferSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opLongBufferSeq(const ::Test::LongBuffer& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opLongBufferSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opLongBufferSeq(inSeq, context, cb, cookie);
    }

    ::Test::LongBuffer end_opLongBufferSeq(::Test::LongBuffer& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opLongBufferSeq(::Test::LongBuffer& iceP_outSeq, ::Test::LongBuffer& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opLongBufferSeq(const ::Test::LongBuffer&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::FloatBuffer opFloatBufferSeq(const ::Test::FloatBuffer& inSeq, ::Test::FloatBuffer& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opFloatBufferSeq(outSeq, _iceI_begin_opFloatBufferSeq(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opFloatBufferSeq(const ::Test::FloatBuffer& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opFloatBufferSeq(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opFloatBufferSeq(const ::Test::FloatBuffer& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opFloatBufferSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opFloatBufferSeq(const ::Test::FloatBuffer& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opFloatBufferSeq(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opFloatBufferSeq(const ::Test::FloatBuffer& inSeq, const ::Test::Callback_TestIntf_opFloatBufferSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opFloatBufferSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opFloatBufferSeq(const ::Test::FloatBuffer& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opFloatBufferSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opFloatBufferSeq(inSeq, context, cb, cookie);
    }

    ::Test::FloatBuffer end_opFloatBufferSeq(::Test::FloatBuffer& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opFloatBufferSeq(::Test::FloatBuffer& iceP_outSeq, ::Test::FloatBuffer& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opFloatBufferSeq(const ::Test::FloatBuffer&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Test::DoubleBuffer opDoubleBufferSeq(const ::Test::DoubleBuffer& inSeq, ::Test::DoubleBuffer& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opDoubleBufferSeq(outSeq, _iceI_begin_opDoubleBufferSeq(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opDoubleBufferSeq(const ::Test::DoubleBuffer& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opDoubleBufferSeq(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opDoubleBufferSeq(const ::Test::DoubleBuffer& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opDoubleBufferSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opDoubleBufferSeq(const ::Test::DoubleBuffer& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opDoubleBufferSeq(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opDoubleBufferSeq(const ::Test::DoubleBuffer& inSeq, const ::Test::Callback_TestIntf_opDoubleBufferSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opDoubleBufferSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opDoubleBufferSeq(const ::Test::DoubleBuffer& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opDoubleBufferSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opDoubleBufferSeq(inSeq, context, cb, cookie);
    }

    ::Test::DoubleBuffer end_opDoubleBufferSeq(::Test::DoubleBuffer& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opDoubleBufferSeq(::Test::DoubleBuffer& iceP_outSeq, ::Test::DoubleBuffer& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opDoubleBufferSeq(const ::Test::DoubleBuffer&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    std::optional< ::Test::CSeq> opOptCSeq(const std::optional< ::Test::CSeq>& inSeq, std::optional< ::Test::CSeq>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opOptCSeq(outSeq, _iceI_begin_opOptCSeq(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opOptCSeq(const std::optional< ::Test::CSeq>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opOptCSeq(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opOptCSeq(const std::optional< ::Test::CSeq>& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOptCSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opOptCSeq(const std::optional< ::Test::CSeq>& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOptCSeq(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opOptCSeq(const std::optional< ::Test::CSeq>& inSeq, const ::Test::Callback_TestIntf_opOptCSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOptCSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opOptCSeq(const std::optional< ::Test::CSeq>& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opOptCSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOptCSeq(inSeq, context, cb, cookie);
    }

    std::optional< ::Test::CSeq> end_opOptCSeq(std::optional< ::Test::CSeq>& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opOptCSeq(std::optional< ::Test::CSeq>& iceP_outSeq, std::optional< ::Test::CSeq>& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opOptCSeq(const std::optional< ::Test::CSeq>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    std::optional< ::Test::CArray> opOptCArray(const std::optional< ::Test::CArray>& inSeq, std::optional< ::Test::CArray>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opOptCArray(outSeq, _iceI_begin_opOptCArray(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opOptCArray(const std::optional< ::Test::CArray>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opOptCArray(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opOptCArray(const std::optional< ::Test::CArray>& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOptCArray(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opOptCArray(const std::optional< ::Test::CArray>& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOptCArray(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opOptCArray(const std::optional< ::Test::CArray>& inSeq, const ::Test::Callback_TestIntf_opOptCArrayPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOptCArray(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opOptCArray(const std::optional< ::Test::CArray>& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opOptCArrayPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOptCArray(inSeq, context, cb, cookie);
    }

    std::optional< ::Test::CArray> end_opOptCArray(std::optional< ::Test::CArray>& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opOptCArray(std::optional< ::Test::CArray>& iceP_outSeq, std::optional< ::Test::CArray>& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opOptCArray(const std::optional< ::Test::CArray>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    std::optional< ::Test::CList> opOptCList(const std::optional< ::Test::CList>& inSeq, std::optional< ::Test::CList>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opOptCList(outSeq, _iceI_begin_opOptCList(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opOptCList(const std::optional< ::Test::CList>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opOptCList(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opOptCList(const std::optional< ::Test::CList>& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOptCList(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opOptCList(const std::optional< ::Test::CList>& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOptCList(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opOptCList(const std::optional< ::Test::CList>& inSeq, const ::Test::Callback_TestIntf_opOptCListPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOptCList(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opOptCList(const std::optional< ::Test::CList>& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opOptCListPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOptCList(inSeq, context, cb, cookie);
    }

    std::optional< ::Test::CList> end_opOptCList(std::optional< ::Test::CList>& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opOptCList(std::optional< ::Test::CList>& iceP_outSeq, std::optional< ::Test::CList>& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opOptCList(const std::optional< ::Test::CList>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    std::optional< ::Test::BoolSeq> opOptBoolSeq(const std::optional< ::Test::BoolSeq>& inSeq, std::optional< ::Test::BoolSeq>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opOptBoolSeq(outSeq, _iceI_begin_opOptBoolSeq(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opOptBoolSeq(const std::optional< ::Test::BoolSeq>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opOptBoolSeq(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opOptBoolSeq(const std::optional< ::Test::BoolSeq>& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOptBoolSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opOptBoolSeq(const std::optional< ::Test::BoolSeq>& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOptBoolSeq(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opOptBoolSeq(const std::optional< ::Test::BoolSeq>& inSeq, const ::Test::Callback_TestIntf_opOptBoolSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOptBoolSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opOptBoolSeq(const std::optional< ::Test::BoolSeq>& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opOptBoolSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOptBoolSeq(inSeq, context, cb, cookie);
    }

    std::optional< ::Test::BoolSeq> end_opOptBoolSeq(std::optional< ::Test::BoolSeq>& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opOptBoolSeq(std::optional< ::Test::BoolSeq>& iceP_outSeq, std::optional< ::Test::BoolSeq>& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opOptBoolSeq(const std::optional< ::Test::BoolSeq>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    std::optional< ::Test::ByteSeq> opOptByteSeq(const std::optional< ::Test::ByteSeq>& inSeq, std::optional< ::Test::ByteSeq>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opOptByteSeq(outSeq, _iceI_begin_opOptByteSeq(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opOptByteSeq(const std::optional< ::Test::ByteSeq>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opOptByteSeq(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opOptByteSeq(const std::optional< ::Test::ByteSeq>& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOptByteSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opOptByteSeq(const std::optional< ::Test::ByteSeq>& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOptByteSeq(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opOptByteSeq(const std::optional< ::Test::ByteSeq>& inSeq, const ::Test::Callback_TestIntf_opOptByteSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOptByteSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opOptByteSeq(const std::optional< ::Test::ByteSeq>& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opOptByteSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOptByteSeq(inSeq, context, cb, cookie);
    }

    std::optional< ::Test::ByteSeq> end_opOptByteSeq(std::optional< ::Test::ByteSeq>& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opOptByteSeq(std::optional< ::Test::ByteSeq>& iceP_outSeq, std::optional< ::Test::ByteSeq>& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opOptByteSeq(const std::optional< ::Test::ByteSeq>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    std::optional< ::Test::ShortSeq> opOptShortSeq(const std::optional< ::Test::ShortSeq>& inSeq, std::optional< ::Test::ShortSeq>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opOptShortSeq(outSeq, _iceI_begin_opOptShortSeq(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opOptShortSeq(const std::optional< ::Test::ShortSeq>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opOptShortSeq(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opOptShortSeq(const std::optional< ::Test::ShortSeq>& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOptShortSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opOptShortSeq(const std::optional< ::Test::ShortSeq>& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOptShortSeq(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opOptShortSeq(const std::optional< ::Test::ShortSeq>& inSeq, const ::Test::Callback_TestIntf_opOptShortSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOptShortSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opOptShortSeq(const std::optional< ::Test::ShortSeq>& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opOptShortSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOptShortSeq(inSeq, context, cb, cookie);
    }

    std::optional< ::Test::ShortSeq> end_opOptShortSeq(std::optional< ::Test::ShortSeq>& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opOptShortSeq(std::optional< ::Test::ShortSeq>& iceP_outSeq, std::optional< ::Test::ShortSeq>& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opOptShortSeq(const std::optional< ::Test::ShortSeq>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    std::optional< ::Test::IntSeq> opOptIntSeq(const std::optional< ::Test::IntSeq>& inSeq, std::optional< ::Test::IntSeq>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opOptIntSeq(outSeq, _iceI_begin_opOptIntSeq(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opOptIntSeq(const std::optional< ::Test::IntSeq>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opOptIntSeq(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opOptIntSeq(const std::optional< ::Test::IntSeq>& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOptIntSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opOptIntSeq(const std::optional< ::Test::IntSeq>& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOptIntSeq(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opOptIntSeq(const std::optional< ::Test::IntSeq>& inSeq, const ::Test::Callback_TestIntf_opOptIntSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOptIntSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opOptIntSeq(const std::optional< ::Test::IntSeq>& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opOptIntSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOptIntSeq(inSeq, context, cb, cookie);
    }

    std::optional< ::Test::IntSeq> end_opOptIntSeq(std::optional< ::Test::IntSeq>& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opOptIntSeq(std::optional< ::Test::IntSeq>& iceP_outSeq, std::optional< ::Test::IntSeq>& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opOptIntSeq(const std::optional< ::Test::IntSeq>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    std::optional< ::Test::LongSeq> opOptLongSeq(const std::optional< ::Test::LongSeq>& inSeq, std::optional< ::Test::LongSeq>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opOptLongSeq(outSeq, _iceI_begin_opOptLongSeq(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opOptLongSeq(const std::optional< ::Test::LongSeq>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opOptLongSeq(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opOptLongSeq(const std::optional< ::Test::LongSeq>& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOptLongSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opOptLongSeq(const std::optional< ::Test::LongSeq>& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOptLongSeq(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opOptLongSeq(const std::optional< ::Test::LongSeq>& inSeq, const ::Test::Callback_TestIntf_opOptLongSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOptLongSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opOptLongSeq(const std::optional< ::Test::LongSeq>& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opOptLongSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOptLongSeq(inSeq, context, cb, cookie);
    }

    std::optional< ::Test::LongSeq> end_opOptLongSeq(std::optional< ::Test::LongSeq>& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opOptLongSeq(std::optional< ::Test::LongSeq>& iceP_outSeq, std::optional< ::Test::LongSeq>& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opOptLongSeq(const std::optional< ::Test::LongSeq>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    std::optional< ::Test::FloatSeq> opOptFloatSeq(const std::optional< ::Test::FloatSeq>& inSeq, std::optional< ::Test::FloatSeq>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opOptFloatSeq(outSeq, _iceI_begin_opOptFloatSeq(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opOptFloatSeq(const std::optional< ::Test::FloatSeq>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opOptFloatSeq(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opOptFloatSeq(const std::optional< ::Test::FloatSeq>& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOptFloatSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opOptFloatSeq(const std::optional< ::Test::FloatSeq>& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOptFloatSeq(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opOptFloatSeq(const std::optional< ::Test::FloatSeq>& inSeq, const ::Test::Callback_TestIntf_opOptFloatSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOptFloatSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opOptFloatSeq(const std::optional< ::Test::FloatSeq>& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opOptFloatSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOptFloatSeq(inSeq, context, cb, cookie);
    }

    std::optional< ::Test::FloatSeq> end_opOptFloatSeq(std::optional< ::Test::FloatSeq>& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opOptFloatSeq(std::optional< ::Test::FloatSeq>& iceP_outSeq, std::optional< ::Test::FloatSeq>& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opOptFloatSeq(const std::optional< ::Test::FloatSeq>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    std::optional< ::Test::DoubleSeq> opOptDoubleSeq(const std::optional< ::Test::DoubleSeq>& inSeq, std::optional< ::Test::DoubleSeq>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opOptDoubleSeq(outSeq, _iceI_begin_opOptDoubleSeq(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opOptDoubleSeq(const std::optional< ::Test::DoubleSeq>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opOptDoubleSeq(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opOptDoubleSeq(const std::optional< ::Test::DoubleSeq>& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOptDoubleSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opOptDoubleSeq(const std::optional< ::Test::DoubleSeq>& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOptDoubleSeq(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opOptDoubleSeq(const std::optional< ::Test::DoubleSeq>& inSeq, const ::Test::Callback_TestIntf_opOptDoubleSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOptDoubleSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opOptDoubleSeq(const std::optional< ::Test::DoubleSeq>& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opOptDoubleSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOptDoubleSeq(inSeq, context, cb, cookie);
    }

    std::optional< ::Test::DoubleSeq> end_opOptDoubleSeq(std::optional< ::Test::DoubleSeq>& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opOptDoubleSeq(std::optional< ::Test::DoubleSeq>& iceP_outSeq, std::optional< ::Test::DoubleSeq>& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opOptDoubleSeq(const std::optional< ::Test::DoubleSeq>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    std::optional< ::Test::StringSeq> opOptStringSeq(const std::optional< ::Test::StringSeq>& inSeq, std::optional< ::Test::StringSeq>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opOptStringSeq(outSeq, _iceI_begin_opOptStringSeq(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opOptStringSeq(const std::optional< ::Test::StringSeq>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opOptStringSeq(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opOptStringSeq(const std::optional< ::Test::StringSeq>& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOptStringSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opOptStringSeq(const std::optional< ::Test::StringSeq>& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOptStringSeq(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opOptStringSeq(const std::optional< ::Test::StringSeq>& inSeq, const ::Test::Callback_TestIntf_opOptStringSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOptStringSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opOptStringSeq(const std::optional< ::Test::StringSeq>& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opOptStringSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOptStringSeq(inSeq, context, cb, cookie);
    }

    std::optional< ::Test::StringSeq> end_opOptStringSeq(std::optional< ::Test::StringSeq>& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opOptStringSeq(std::optional< ::Test::StringSeq>& iceP_outSeq, std::optional< ::Test::StringSeq>& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opOptStringSeq(const std::optional< ::Test::StringSeq>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    std::optional< ::Test::ESeq> opOptESeq(const std::optional< ::Test::ESeq>& inSeq, std::optional< ::Test::ESeq>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opOptESeq(outSeq, _iceI_begin_opOptESeq(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opOptESeq(const std::optional< ::Test::ESeq>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opOptESeq(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opOptESeq(const std::optional< ::Test::ESeq>& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOptESeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opOptESeq(const std::optional< ::Test::ESeq>& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOptESeq(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opOptESeq(const std::optional< ::Test::ESeq>& inSeq, const ::Test::Callback_TestIntf_opOptESeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOptESeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opOptESeq(const std::optional< ::Test::ESeq>& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opOptESeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOptESeq(inSeq, context, cb, cookie);
    }

    std::optional< ::Test::ESeq> end_opOptESeq(std::optional< ::Test::ESeq>& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opOptESeq(std::optional< ::Test::ESeq>& iceP_outSeq, std::optional< ::Test::ESeq>& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opOptESeq(const std::optional< ::Test::ESeq>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    std::optional< ::Test::SSeq> opOptSSeq(const std::optional< ::Test::SSeq>& inSeq, std::optional< ::Test::SSeq>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opOptSSeq(outSeq, _iceI_begin_opOptSSeq(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opOptSSeq(const std::optional< ::Test::SSeq>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opOptSSeq(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opOptSSeq(const std::optional< ::Test::SSeq>& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOptSSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opOptSSeq(const std::optional< ::Test::SSeq>& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOptSSeq(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opOptSSeq(const std::optional< ::Test::SSeq>& inSeq, const ::Test::Callback_TestIntf_opOptSSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOptSSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opOptSSeq(const std::optional< ::Test::SSeq>& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opOptSSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOptSSeq(inSeq, context, cb, cookie);
    }

    std::optional< ::Test::SSeq> end_opOptSSeq(std::optional< ::Test::SSeq>& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opOptSSeq(std::optional< ::Test::SSeq>& iceP_outSeq, std::optional< ::Test::SSeq>& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opOptSSeq(const std::optional< ::Test::SSeq>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    std::optional< ::Test::DSeq> opOptDSeq(const std::optional< ::Test::DSeq>& inSeq, std::optional< ::Test::DSeq>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opOptDSeq(outSeq, _iceI_begin_opOptDSeq(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opOptDSeq(const std::optional< ::Test::DSeq>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opOptDSeq(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opOptDSeq(const std::optional< ::Test::DSeq>& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOptDSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opOptDSeq(const std::optional< ::Test::DSeq>& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOptDSeq(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opOptDSeq(const std::optional< ::Test::DSeq>& inSeq, const ::Test::Callback_TestIntf_opOptDSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOptDSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opOptDSeq(const std::optional< ::Test::DSeq>& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opOptDSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOptDSeq(inSeq, context, cb, cookie);
    }

    std::optional< ::Test::DSeq> end_opOptDSeq(std::optional< ::Test::DSeq>& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opOptDSeq(std::optional< ::Test::DSeq>& iceP_outSeq, std::optional< ::Test::DSeq>& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opOptDSeq(const std::optional< ::Test::DSeq>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    std::optional< ::Test::StringSeqSeq> opOptStringSeqSeq(const std::optional< ::Test::StringSeqSeq>& inSeq, std::optional< ::Test::StringSeqSeq>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opOptStringSeqSeq(outSeq, _iceI_begin_opOptStringSeqSeq(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opOptStringSeqSeq(const std::optional< ::Test::StringSeqSeq>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opOptStringSeqSeq(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opOptStringSeqSeq(const std::optional< ::Test::StringSeqSeq>& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOptStringSeqSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opOptStringSeqSeq(const std::optional< ::Test::StringSeqSeq>& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOptStringSeqSeq(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opOptStringSeqSeq(const std::optional< ::Test::StringSeqSeq>& inSeq, const ::Test::Callback_TestIntf_opOptStringSeqSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOptStringSeqSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opOptStringSeqSeq(const std::optional< ::Test::StringSeqSeq>& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opOptStringSeqSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOptStringSeqSeq(inSeq, context, cb, cookie);
    }

    std::optional< ::Test::StringSeqSeq> end_opOptStringSeqSeq(std::optional< ::Test::StringSeqSeq>& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opOptStringSeqSeq(std::optional< ::Test::StringSeqSeq>& iceP_outSeq, std::optional< ::Test::StringSeqSeq>& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opOptStringSeqSeq(const std::optional< ::Test::StringSeqSeq>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    std::optional< ::Test::ByteBuffer> opOptByteBufferSeq(const std::optional< ::Test::ByteBuffer>& inSeq, std::optional< ::Test::ByteBuffer>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opOptByteBufferSeq(outSeq, _iceI_begin_opOptByteBufferSeq(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opOptByteBufferSeq(const std::optional< ::Test::ByteBuffer>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opOptByteBufferSeq(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opOptByteBufferSeq(const std::optional< ::Test::ByteBuffer>& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOptByteBufferSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opOptByteBufferSeq(const std::optional< ::Test::ByteBuffer>& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOptByteBufferSeq(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opOptByteBufferSeq(const std::optional< ::Test::ByteBuffer>& inSeq, const ::Test::Callback_TestIntf_opOptByteBufferSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOptByteBufferSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opOptByteBufferSeq(const std::optional< ::Test::ByteBuffer>& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opOptByteBufferSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOptByteBufferSeq(inSeq, context, cb, cookie);
    }

    std::optional< ::Test::ByteBuffer> end_opOptByteBufferSeq(std::optional< ::Test::ByteBuffer>& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opOptByteBufferSeq(std::optional< ::Test::ByteBuffer>& iceP_outSeq, std::optional< ::Test::ByteBuffer>& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opOptByteBufferSeq(const std::optional< ::Test::ByteBuffer>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    std::optional< ::Test::ShortBuffer> opOptShortBufferSeq(const std::optional< ::Test::ShortBuffer>& inSeq, std::optional< ::Test::ShortBuffer>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opOptShortBufferSeq(outSeq, _iceI_begin_opOptShortBufferSeq(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opOptShortBufferSeq(const std::optional< ::Test::ShortBuffer>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opOptShortBufferSeq(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opOptShortBufferSeq(const std::optional< ::Test::ShortBuffer>& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOptShortBufferSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opOptShortBufferSeq(const std::optional< ::Test::ShortBuffer>& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOptShortBufferSeq(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opOptShortBufferSeq(const std::optional< ::Test::ShortBuffer>& inSeq, const ::Test::Callback_TestIntf_opOptShortBufferSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOptShortBufferSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opOptShortBufferSeq(const std::optional< ::Test::ShortBuffer>& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opOptShortBufferSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOptShortBufferSeq(inSeq, context, cb, cookie);
    }

    std::optional< ::Test::ShortBuffer> end_opOptShortBufferSeq(std::optional< ::Test::ShortBuffer>& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opOptShortBufferSeq(std::optional< ::Test::ShortBuffer>& iceP_outSeq, std::optional< ::Test::ShortBuffer>& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opOptShortBufferSeq(const std::optional< ::Test::ShortBuffer>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    std::optional< ::Test::IntBuffer> opOptIntBufferSeq(const std::optional< ::Test::IntBuffer>& inSeq, std::optional< ::Test::IntBuffer>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opOptIntBufferSeq(outSeq, _iceI_begin_opOptIntBufferSeq(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opOptIntBufferSeq(const std::optional< ::Test::IntBuffer>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opOptIntBufferSeq(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opOptIntBufferSeq(const std::optional< ::Test::IntBuffer>& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOptIntBufferSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opOptIntBufferSeq(const std::optional< ::Test::IntBuffer>& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOptIntBufferSeq(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opOptIntBufferSeq(const std::optional< ::Test::IntBuffer>& inSeq, const ::Test::Callback_TestIntf_opOptIntBufferSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOptIntBufferSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opOptIntBufferSeq(const std::optional< ::Test::IntBuffer>& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opOptIntBufferSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOptIntBufferSeq(inSeq, context, cb, cookie);
    }

    std::optional< ::Test::IntBuffer> end_opOptIntBufferSeq(std::optional< ::Test::IntBuffer>& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opOptIntBufferSeq(std::optional< ::Test::IntBuffer>& iceP_outSeq, std::optional< ::Test::IntBuffer>& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opOptIntBufferSeq(const std::optional< ::Test::IntBuffer>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    std::optional< ::Test::LongBuffer> opOptLongBufferSeq(const std::optional< ::Test::LongBuffer>& inSeq, std::optional< ::Test::LongBuffer>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opOptLongBufferSeq(outSeq, _iceI_begin_opOptLongBufferSeq(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opOptLongBufferSeq(const std::optional< ::Test::LongBuffer>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opOptLongBufferSeq(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opOptLongBufferSeq(const std::optional< ::Test::LongBuffer>& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOptLongBufferSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opOptLongBufferSeq(const std::optional< ::Test::LongBuffer>& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOptLongBufferSeq(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opOptLongBufferSeq(const std::optional< ::Test::LongBuffer>& inSeq, const ::Test::Callback_TestIntf_opOptLongBufferSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOptLongBufferSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opOptLongBufferSeq(const std::optional< ::Test::LongBuffer>& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opOptLongBufferSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOptLongBufferSeq(inSeq, context, cb, cookie);
    }

    std::optional< ::Test::LongBuffer> end_opOptLongBufferSeq(std::optional< ::Test::LongBuffer>& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opOptLongBufferSeq(std::optional< ::Test::LongBuffer>& iceP_outSeq, std::optional< ::Test::LongBuffer>& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opOptLongBufferSeq(const std::optional< ::Test::LongBuffer>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    std::optional< ::Test::FloatBuffer> opOptFloatBufferSeq(const std::optional< ::Test::FloatBuffer>& inSeq, std::optional< ::Test::FloatBuffer>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opOptFloatBufferSeq(outSeq, _iceI_begin_opOptFloatBufferSeq(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opOptFloatBufferSeq(const std::optional< ::Test::FloatBuffer>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opOptFloatBufferSeq(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opOptFloatBufferSeq(const std::optional< ::Test::FloatBuffer>& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOptFloatBufferSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opOptFloatBufferSeq(const std::optional< ::Test::FloatBuffer>& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOptFloatBufferSeq(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opOptFloatBufferSeq(const std::optional< ::Test::FloatBuffer>& inSeq, const ::Test::Callback_TestIntf_opOptFloatBufferSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOptFloatBufferSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opOptFloatBufferSeq(const std::optional< ::Test::FloatBuffer>& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opOptFloatBufferSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOptFloatBufferSeq(inSeq, context, cb, cookie);
    }

    std::optional< ::Test::FloatBuffer> end_opOptFloatBufferSeq(std::optional< ::Test::FloatBuffer>& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opOptFloatBufferSeq(std::optional< ::Test::FloatBuffer>& iceP_outSeq, std::optional< ::Test::FloatBuffer>& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opOptFloatBufferSeq(const std::optional< ::Test::FloatBuffer>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    std::optional< ::Test::DoubleBuffer> opOptDoubleBufferSeq(const std::optional< ::Test::DoubleBuffer>& inSeq, std::optional< ::Test::DoubleBuffer>& outSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_opOptDoubleBufferSeq(outSeq, _iceI_begin_opOptDoubleBufferSeq(inSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_opOptDoubleBufferSeq(const std::optional< ::Test::DoubleBuffer>& inSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_opOptDoubleBufferSeq(inSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_opOptDoubleBufferSeq(const std::optional< ::Test::DoubleBuffer>& inSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOptDoubleBufferSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opOptDoubleBufferSeq(const std::optional< ::Test::DoubleBuffer>& inSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOptDoubleBufferSeq(inSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opOptDoubleBufferSeq(const std::optional< ::Test::DoubleBuffer>& inSeq, const ::Test::Callback_TestIntf_opOptDoubleBufferSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOptDoubleBufferSeq(inSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_opOptDoubleBufferSeq(const std::optional< ::Test::DoubleBuffer>& inSeq, const ::Ice::Context& context, const ::Test::Callback_TestIntf_opOptDoubleBufferSeqPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_opOptDoubleBufferSeq(inSeq, context, cb, cookie);
    }

    std::optional< ::Test::DoubleBuffer> end_opOptDoubleBufferSeq(std::optional< ::Test::DoubleBuffer>& outSeq, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_opOptDoubleBufferSeq(std::optional< ::Test::DoubleBuffer>& iceP_outSeq, std::optional< ::Test::DoubleBuffer>& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_opOptDoubleBufferSeq(const std::optional< ::Test::DoubleBuffer>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void shutdown(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_shutdown(_iceI_begin_shutdown(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_shutdown(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_shutdown(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_shutdown(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_shutdown(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_shutdown(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_shutdown(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_shutdown(const ::Test::Callback_TestIntf_shutdownPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_shutdown(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_shutdown(const ::Ice::Context& context, const ::Test::Callback_TestIntf_shutdownPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_shutdown(context, cb, cookie);
    }

    void end_shutdown(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_shutdown(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

}

}

namespace Test
{

class C : public virtual ::Ice::Object
{
public:

    typedef CPrx ProxyType;
    typedef CPtr PointerType;

    virtual ~C();

    C()
    {
    }
    C(const C&) = default;
    C& operator=(const C&) = default;

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_C_init = ::Test::C::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const C& lhs, const C& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const C& lhs, const C& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class TestIntf : public virtual ::Ice::Object
{
public:

    typedef TestIntfPrx ProxyType;
    typedef TestIntfPtr PointerType;

    virtual ~TestIntf();
    TestIntf() = default;
    TestIntf(const TestIntf&) = default;
    TestIntf& operator=(const TestIntf&) = default;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual CSeq opCSeq(const CSeq& inSeq, CSeq& outSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opCSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual CArray opCArray(const CArray& inSeq, CArray& outSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opCArray(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual CList opCList(const CList& inSeq, CList& outSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opCList(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual BoolSeq opBoolSeq(const BoolSeq& inSeq, BoolSeq& outSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opBoolSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ByteSeq opByteSeq(const ByteSeq& inSeq, ByteSeq& outSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opByteSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ShortSeq opShortSeq(const ShortSeq& inSeq, ShortSeq& outSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opShortSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual IntSeq opIntSeq(const IntSeq& inSeq, IntSeq& outSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opIntSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual LongSeq opLongSeq(const LongSeq& inSeq, LongSeq& outSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opLongSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual FloatSeq opFloatSeq(const FloatSeq& inSeq, FloatSeq& outSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opFloatSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual DoubleSeq opDoubleSeq(const DoubleSeq& inSeq, DoubleSeq& outSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opDoubleSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual StringSeq opStringSeq(const StringSeq& inSeq, StringSeq& outSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opStringSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ESeq opESeq(const ESeq& inSeq, ESeq& outSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opESeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual SSeq opSSeq(const SSeq& inSeq, SSeq& outSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opSSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual DSeq opDSeq(const DSeq& inSeq, DSeq& outSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opDSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual StringSeqSeq opStringSeqSeq(const StringSeqSeq& inSeq, StringSeqSeq& outSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opStringSeqSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ByteBuffer opByteBufferSeq(const ByteBuffer& inSeq, ByteBuffer& outSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opByteBufferSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ShortBuffer opShortBufferSeq(const ShortBuffer& inSeq, ShortBuffer& outSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opShortBufferSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual IntBuffer opIntBufferSeq(const IntBuffer& inSeq, IntBuffer& outSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opIntBufferSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual LongBuffer opLongBufferSeq(const LongBuffer& inSeq, LongBuffer& outSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opLongBufferSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual FloatBuffer opFloatBufferSeq(const FloatBuffer& inSeq, FloatBuffer& outSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opFloatBufferSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual DoubleBuffer opDoubleBufferSeq(const DoubleBuffer& inSeq, DoubleBuffer& outSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opDoubleBufferSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual std::optional<CSeq> opOptCSeq(const std::optional<CSeq>& inSeq, std::optional<CSeq>& outSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opOptCSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual std::optional<CArray> opOptCArray(const std::optional<CArray>& inSeq, std::optional<CArray>& outSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opOptCArray(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual std::optional<CList> opOptCList(const std::optional<CList>& inSeq, std::optional<CList>& outSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opOptCList(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual std::optional<BoolSeq> opOptBoolSeq(const std::optional<BoolSeq>& inSeq, std::optional<BoolSeq>& outSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opOptBoolSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual std::optional<ByteSeq> opOptByteSeq(const std::optional<ByteSeq>& inSeq, std::optional<ByteSeq>& outSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opOptByteSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual std::optional<ShortSeq> opOptShortSeq(const std::optional<ShortSeq>& inSeq, std::optional<ShortSeq>& outSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opOptShortSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual std::optional<IntSeq> opOptIntSeq(const std::optional<IntSeq>& inSeq, std::optional<IntSeq>& outSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opOptIntSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual std::optional<LongSeq> opOptLongSeq(const std::optional<LongSeq>& inSeq, std::optional<LongSeq>& outSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opOptLongSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual std::optional<FloatSeq> opOptFloatSeq(const std::optional<FloatSeq>& inSeq, std::optional<FloatSeq>& outSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opOptFloatSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual std::optional<DoubleSeq> opOptDoubleSeq(const std::optional<DoubleSeq>& inSeq, std::optional<DoubleSeq>& outSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opOptDoubleSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual std::optional<StringSeq> opOptStringSeq(const std::optional<StringSeq>& inSeq, std::optional<StringSeq>& outSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opOptStringSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual std::optional<ESeq> opOptESeq(const std::optional<ESeq>& inSeq, std::optional<ESeq>& outSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opOptESeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual std::optional<SSeq> opOptSSeq(const std::optional<SSeq>& inSeq, std::optional<SSeq>& outSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opOptSSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual std::optional<DSeq> opOptDSeq(const std::optional<DSeq>& inSeq, std::optional<DSeq>& outSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opOptDSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual std::optional<StringSeqSeq> opOptStringSeqSeq(const std::optional<StringSeqSeq>& inSeq, std::optional<StringSeqSeq>& outSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opOptStringSeqSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual std::optional<ByteBuffer> opOptByteBufferSeq(const std::optional<ByteBuffer>& inSeq, std::optional<ByteBuffer>& outSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opOptByteBufferSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual std::optional<ShortBuffer> opOptShortBufferSeq(const std::optional<ShortBuffer>& inSeq, std::optional<ShortBuffer>& outSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opOptShortBufferSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual std::optional<IntBuffer> opOptIntBufferSeq(const std::optional<IntBuffer>& inSeq, std::optional<IntBuffer>& outSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opOptIntBufferSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual std::optional<LongBuffer> opOptLongBufferSeq(const std::optional<LongBuffer>& inSeq, std::optional<LongBuffer>& outSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opOptLongBufferSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual std::optional<FloatBuffer> opOptFloatBufferSeq(const std::optional<FloatBuffer>& inSeq, std::optional<FloatBuffer>& outSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opOptFloatBufferSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual std::optional<DoubleBuffer> opOptDoubleBufferSeq(const std::optional<DoubleBuffer>& inSeq, std::optional<DoubleBuffer>& outSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_opOptDoubleBufferSeq(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void shutdown(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_shutdown(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
inline bool operator==(const TestIntf& lhs, const TestIntf& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const TestIntf& lhs, const TestIntf& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

}

/// \cond STREAM
namespace Ice
{

template<>
struct StreamableTraits< ::Test::E>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 2;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits< ::Test::S>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::Test::S, S>
{
    static void write(S* ostr, const ::Test::S& v)
    {
        ostr->write(v.en);
    }
};

template<typename S>
struct StreamReader< ::Test::S, S>
{
    static void read(S* istr, ::Test::S& v)
    {
        istr->read(v.en);
    }
};

}
/// \endcond

namespace Test
{

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opCSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opCSeq.
 */
template<class T>
class CallbackNC_TestIntf_opCSeq : public Callback_TestIntf_opCSeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const CSeq&, const CSeq&);

    CallbackNC_TestIntf_opCSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        CSeq iceP_outSeq;
        CSeq ret;
        try
        {
            ret = proxy->end_opCSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opCSeq.
 */
template<class T> Callback_TestIntf_opCSeqPtr
newCallback_TestIntf_opCSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const CSeq&, const CSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opCSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opCSeq.
 */
template<class T> Callback_TestIntf_opCSeqPtr
newCallback_TestIntf_opCSeq(T* instance, void (T::*cb)(const CSeq&, const CSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opCSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opCSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opCSeq.
 */
template<class T, typename CT>
class Callback_TestIntf_opCSeq : public Callback_TestIntf_opCSeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CSeq&, const CSeq&, const CT&);

    Callback_TestIntf_opCSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        CSeq iceP_outSeq;
        CSeq ret;
        try
        {
            ret = proxy->end_opCSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opCSeq.
 */
template<class T, typename CT> Callback_TestIntf_opCSeqPtr
newCallback_TestIntf_opCSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const CSeq&, const CSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opCSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opCSeq.
 */
template<class T, typename CT> Callback_TestIntf_opCSeqPtr
newCallback_TestIntf_opCSeq(T* instance, void (T::*cb)(const CSeq&, const CSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opCSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opCArray.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opCArray.
 */
template<class T>
class CallbackNC_TestIntf_opCArray : public Callback_TestIntf_opCArray_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const CArray&, const CArray&);

    CallbackNC_TestIntf_opCArray(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        CArray iceP_outSeq;
        CArray ret;
        try
        {
            ret = proxy->end_opCArray(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opCArray.
 */
template<class T> Callback_TestIntf_opCArrayPtr
newCallback_TestIntf_opCArray(const IceUtil::Handle<T>& instance, void (T::*cb)(const CArray&, const CArray&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opCArray<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opCArray.
 */
template<class T> Callback_TestIntf_opCArrayPtr
newCallback_TestIntf_opCArray(T* instance, void (T::*cb)(const CArray&, const CArray&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opCArray<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opCArray.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opCArray.
 */
template<class T, typename CT>
class Callback_TestIntf_opCArray : public Callback_TestIntf_opCArray_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CArray&, const CArray&, const CT&);

    Callback_TestIntf_opCArray(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        CArray iceP_outSeq;
        CArray ret;
        try
        {
            ret = proxy->end_opCArray(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opCArray.
 */
template<class T, typename CT> Callback_TestIntf_opCArrayPtr
newCallback_TestIntf_opCArray(const IceUtil::Handle<T>& instance, void (T::*cb)(const CArray&, const CArray&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opCArray<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opCArray.
 */
template<class T, typename CT> Callback_TestIntf_opCArrayPtr
newCallback_TestIntf_opCArray(T* instance, void (T::*cb)(const CArray&, const CArray&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opCArray<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opCList.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opCList.
 */
template<class T>
class CallbackNC_TestIntf_opCList : public Callback_TestIntf_opCList_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const CList&, const CList&);

    CallbackNC_TestIntf_opCList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        CList iceP_outSeq;
        CList ret;
        try
        {
            ret = proxy->end_opCList(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opCList.
 */
template<class T> Callback_TestIntf_opCListPtr
newCallback_TestIntf_opCList(const IceUtil::Handle<T>& instance, void (T::*cb)(const CList&, const CList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opCList<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opCList.
 */
template<class T> Callback_TestIntf_opCListPtr
newCallback_TestIntf_opCList(T* instance, void (T::*cb)(const CList&, const CList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opCList<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opCList.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opCList.
 */
template<class T, typename CT>
class Callback_TestIntf_opCList : public Callback_TestIntf_opCList_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CList&, const CList&, const CT&);

    Callback_TestIntf_opCList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        CList iceP_outSeq;
        CList ret;
        try
        {
            ret = proxy->end_opCList(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opCList.
 */
template<class T, typename CT> Callback_TestIntf_opCListPtr
newCallback_TestIntf_opCList(const IceUtil::Handle<T>& instance, void (T::*cb)(const CList&, const CList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opCList<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opCList.
 */
template<class T, typename CT> Callback_TestIntf_opCListPtr
newCallback_TestIntf_opCList(T* instance, void (T::*cb)(const CList&, const CList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opCList<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opBoolSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opBoolSeq.
 */
template<class T>
class CallbackNC_TestIntf_opBoolSeq : public Callback_TestIntf_opBoolSeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const BoolSeq&, const BoolSeq&);

    CallbackNC_TestIntf_opBoolSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        BoolSeq iceP_outSeq;
        BoolSeq ret;
        try
        {
            ret = proxy->end_opBoolSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opBoolSeq.
 */
template<class T> Callback_TestIntf_opBoolSeqPtr
newCallback_TestIntf_opBoolSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const BoolSeq&, const BoolSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opBoolSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opBoolSeq.
 */
template<class T> Callback_TestIntf_opBoolSeqPtr
newCallback_TestIntf_opBoolSeq(T* instance, void (T::*cb)(const BoolSeq&, const BoolSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opBoolSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opBoolSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opBoolSeq.
 */
template<class T, typename CT>
class Callback_TestIntf_opBoolSeq : public Callback_TestIntf_opBoolSeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const BoolSeq&, const BoolSeq&, const CT&);

    Callback_TestIntf_opBoolSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        BoolSeq iceP_outSeq;
        BoolSeq ret;
        try
        {
            ret = proxy->end_opBoolSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opBoolSeq.
 */
template<class T, typename CT> Callback_TestIntf_opBoolSeqPtr
newCallback_TestIntf_opBoolSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const BoolSeq&, const BoolSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opBoolSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opBoolSeq.
 */
template<class T, typename CT> Callback_TestIntf_opBoolSeqPtr
newCallback_TestIntf_opBoolSeq(T* instance, void (T::*cb)(const BoolSeq&, const BoolSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opBoolSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opByteSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opByteSeq.
 */
template<class T>
class CallbackNC_TestIntf_opByteSeq : public Callback_TestIntf_opByteSeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ByteSeq&, const ByteSeq&);

    CallbackNC_TestIntf_opByteSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        ByteSeq iceP_outSeq;
        ByteSeq ret;
        try
        {
            ret = proxy->end_opByteSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opByteSeq.
 */
template<class T> Callback_TestIntf_opByteSeqPtr
newCallback_TestIntf_opByteSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const ByteSeq&, const ByteSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opByteSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opByteSeq.
 */
template<class T> Callback_TestIntf_opByteSeqPtr
newCallback_TestIntf_opByteSeq(T* instance, void (T::*cb)(const ByteSeq&, const ByteSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opByteSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opByteSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opByteSeq.
 */
template<class T, typename CT>
class Callback_TestIntf_opByteSeq : public Callback_TestIntf_opByteSeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ByteSeq&, const ByteSeq&, const CT&);

    Callback_TestIntf_opByteSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        ByteSeq iceP_outSeq;
        ByteSeq ret;
        try
        {
            ret = proxy->end_opByteSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opByteSeq.
 */
template<class T, typename CT> Callback_TestIntf_opByteSeqPtr
newCallback_TestIntf_opByteSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const ByteSeq&, const ByteSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opByteSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opByteSeq.
 */
template<class T, typename CT> Callback_TestIntf_opByteSeqPtr
newCallback_TestIntf_opByteSeq(T* instance, void (T::*cb)(const ByteSeq&, const ByteSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opByteSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opShortSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opShortSeq.
 */
template<class T>
class CallbackNC_TestIntf_opShortSeq : public Callback_TestIntf_opShortSeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ShortSeq&, const ShortSeq&);

    CallbackNC_TestIntf_opShortSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        ShortSeq iceP_outSeq;
        ShortSeq ret;
        try
        {
            ret = proxy->end_opShortSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opShortSeq.
 */
template<class T> Callback_TestIntf_opShortSeqPtr
newCallback_TestIntf_opShortSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const ShortSeq&, const ShortSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opShortSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opShortSeq.
 */
template<class T> Callback_TestIntf_opShortSeqPtr
newCallback_TestIntf_opShortSeq(T* instance, void (T::*cb)(const ShortSeq&, const ShortSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opShortSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opShortSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opShortSeq.
 */
template<class T, typename CT>
class Callback_TestIntf_opShortSeq : public Callback_TestIntf_opShortSeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ShortSeq&, const ShortSeq&, const CT&);

    Callback_TestIntf_opShortSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        ShortSeq iceP_outSeq;
        ShortSeq ret;
        try
        {
            ret = proxy->end_opShortSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opShortSeq.
 */
template<class T, typename CT> Callback_TestIntf_opShortSeqPtr
newCallback_TestIntf_opShortSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const ShortSeq&, const ShortSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opShortSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opShortSeq.
 */
template<class T, typename CT> Callback_TestIntf_opShortSeqPtr
newCallback_TestIntf_opShortSeq(T* instance, void (T::*cb)(const ShortSeq&, const ShortSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opShortSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opIntSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opIntSeq.
 */
template<class T>
class CallbackNC_TestIntf_opIntSeq : public Callback_TestIntf_opIntSeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IntSeq&, const IntSeq&);

    CallbackNC_TestIntf_opIntSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        IntSeq iceP_outSeq;
        IntSeq ret;
        try
        {
            ret = proxy->end_opIntSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opIntSeq.
 */
template<class T> Callback_TestIntf_opIntSeqPtr
newCallback_TestIntf_opIntSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const IntSeq&, const IntSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opIntSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opIntSeq.
 */
template<class T> Callback_TestIntf_opIntSeqPtr
newCallback_TestIntf_opIntSeq(T* instance, void (T::*cb)(const IntSeq&, const IntSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opIntSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opIntSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opIntSeq.
 */
template<class T, typename CT>
class Callback_TestIntf_opIntSeq : public Callback_TestIntf_opIntSeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IntSeq&, const IntSeq&, const CT&);

    Callback_TestIntf_opIntSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        IntSeq iceP_outSeq;
        IntSeq ret;
        try
        {
            ret = proxy->end_opIntSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opIntSeq.
 */
template<class T, typename CT> Callback_TestIntf_opIntSeqPtr
newCallback_TestIntf_opIntSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const IntSeq&, const IntSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opIntSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opIntSeq.
 */
template<class T, typename CT> Callback_TestIntf_opIntSeqPtr
newCallback_TestIntf_opIntSeq(T* instance, void (T::*cb)(const IntSeq&, const IntSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opIntSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opLongSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opLongSeq.
 */
template<class T>
class CallbackNC_TestIntf_opLongSeq : public Callback_TestIntf_opLongSeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const LongSeq&, const LongSeq&);

    CallbackNC_TestIntf_opLongSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        LongSeq iceP_outSeq;
        LongSeq ret;
        try
        {
            ret = proxy->end_opLongSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opLongSeq.
 */
template<class T> Callback_TestIntf_opLongSeqPtr
newCallback_TestIntf_opLongSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const LongSeq&, const LongSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opLongSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opLongSeq.
 */
template<class T> Callback_TestIntf_opLongSeqPtr
newCallback_TestIntf_opLongSeq(T* instance, void (T::*cb)(const LongSeq&, const LongSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opLongSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opLongSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opLongSeq.
 */
template<class T, typename CT>
class Callback_TestIntf_opLongSeq : public Callback_TestIntf_opLongSeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const LongSeq&, const LongSeq&, const CT&);

    Callback_TestIntf_opLongSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        LongSeq iceP_outSeq;
        LongSeq ret;
        try
        {
            ret = proxy->end_opLongSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opLongSeq.
 */
template<class T, typename CT> Callback_TestIntf_opLongSeqPtr
newCallback_TestIntf_opLongSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const LongSeq&, const LongSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opLongSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opLongSeq.
 */
template<class T, typename CT> Callback_TestIntf_opLongSeqPtr
newCallback_TestIntf_opLongSeq(T* instance, void (T::*cb)(const LongSeq&, const LongSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opLongSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opFloatSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opFloatSeq.
 */
template<class T>
class CallbackNC_TestIntf_opFloatSeq : public Callback_TestIntf_opFloatSeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const FloatSeq&, const FloatSeq&);

    CallbackNC_TestIntf_opFloatSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        FloatSeq iceP_outSeq;
        FloatSeq ret;
        try
        {
            ret = proxy->end_opFloatSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opFloatSeq.
 */
template<class T> Callback_TestIntf_opFloatSeqPtr
newCallback_TestIntf_opFloatSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const FloatSeq&, const FloatSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opFloatSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opFloatSeq.
 */
template<class T> Callback_TestIntf_opFloatSeqPtr
newCallback_TestIntf_opFloatSeq(T* instance, void (T::*cb)(const FloatSeq&, const FloatSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opFloatSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opFloatSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opFloatSeq.
 */
template<class T, typename CT>
class Callback_TestIntf_opFloatSeq : public Callback_TestIntf_opFloatSeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const FloatSeq&, const FloatSeq&, const CT&);

    Callback_TestIntf_opFloatSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        FloatSeq iceP_outSeq;
        FloatSeq ret;
        try
        {
            ret = proxy->end_opFloatSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opFloatSeq.
 */
template<class T, typename CT> Callback_TestIntf_opFloatSeqPtr
newCallback_TestIntf_opFloatSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const FloatSeq&, const FloatSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opFloatSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opFloatSeq.
 */
template<class T, typename CT> Callback_TestIntf_opFloatSeqPtr
newCallback_TestIntf_opFloatSeq(T* instance, void (T::*cb)(const FloatSeq&, const FloatSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opFloatSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opDoubleSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opDoubleSeq.
 */
template<class T>
class CallbackNC_TestIntf_opDoubleSeq : public Callback_TestIntf_opDoubleSeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const DoubleSeq&, const DoubleSeq&);

    CallbackNC_TestIntf_opDoubleSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        DoubleSeq iceP_outSeq;
        DoubleSeq ret;
        try
        {
            ret = proxy->end_opDoubleSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opDoubleSeq.
 */
template<class T> Callback_TestIntf_opDoubleSeqPtr
newCallback_TestIntf_opDoubleSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const DoubleSeq&, const DoubleSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opDoubleSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opDoubleSeq.
 */
template<class T> Callback_TestIntf_opDoubleSeqPtr
newCallback_TestIntf_opDoubleSeq(T* instance, void (T::*cb)(const DoubleSeq&, const DoubleSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opDoubleSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opDoubleSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opDoubleSeq.
 */
template<class T, typename CT>
class Callback_TestIntf_opDoubleSeq : public Callback_TestIntf_opDoubleSeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const DoubleSeq&, const DoubleSeq&, const CT&);

    Callback_TestIntf_opDoubleSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        DoubleSeq iceP_outSeq;
        DoubleSeq ret;
        try
        {
            ret = proxy->end_opDoubleSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opDoubleSeq.
 */
template<class T, typename CT> Callback_TestIntf_opDoubleSeqPtr
newCallback_TestIntf_opDoubleSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const DoubleSeq&, const DoubleSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opDoubleSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opDoubleSeq.
 */
template<class T, typename CT> Callback_TestIntf_opDoubleSeqPtr
newCallback_TestIntf_opDoubleSeq(T* instance, void (T::*cb)(const DoubleSeq&, const DoubleSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opDoubleSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opStringSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opStringSeq.
 */
template<class T>
class CallbackNC_TestIntf_opStringSeq : public Callback_TestIntf_opStringSeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const StringSeq&, const StringSeq&);

    CallbackNC_TestIntf_opStringSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        StringSeq iceP_outSeq;
        StringSeq ret;
        try
        {
            ret = proxy->end_opStringSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opStringSeq.
 */
template<class T> Callback_TestIntf_opStringSeqPtr
newCallback_TestIntf_opStringSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const StringSeq&, const StringSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opStringSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opStringSeq.
 */
template<class T> Callback_TestIntf_opStringSeqPtr
newCallback_TestIntf_opStringSeq(T* instance, void (T::*cb)(const StringSeq&, const StringSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opStringSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opStringSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opStringSeq.
 */
template<class T, typename CT>
class Callback_TestIntf_opStringSeq : public Callback_TestIntf_opStringSeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const StringSeq&, const StringSeq&, const CT&);

    Callback_TestIntf_opStringSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        StringSeq iceP_outSeq;
        StringSeq ret;
        try
        {
            ret = proxy->end_opStringSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opStringSeq.
 */
template<class T, typename CT> Callback_TestIntf_opStringSeqPtr
newCallback_TestIntf_opStringSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const StringSeq&, const StringSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opStringSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opStringSeq.
 */
template<class T, typename CT> Callback_TestIntf_opStringSeqPtr
newCallback_TestIntf_opStringSeq(T* instance, void (T::*cb)(const StringSeq&, const StringSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opStringSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opESeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opESeq.
 */
template<class T>
class CallbackNC_TestIntf_opESeq : public Callback_TestIntf_opESeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ESeq&, const ESeq&);

    CallbackNC_TestIntf_opESeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        ESeq iceP_outSeq;
        ESeq ret;
        try
        {
            ret = proxy->end_opESeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opESeq.
 */
template<class T> Callback_TestIntf_opESeqPtr
newCallback_TestIntf_opESeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const ESeq&, const ESeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opESeq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opESeq.
 */
template<class T> Callback_TestIntf_opESeqPtr
newCallback_TestIntf_opESeq(T* instance, void (T::*cb)(const ESeq&, const ESeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opESeq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opESeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opESeq.
 */
template<class T, typename CT>
class Callback_TestIntf_opESeq : public Callback_TestIntf_opESeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ESeq&, const ESeq&, const CT&);

    Callback_TestIntf_opESeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        ESeq iceP_outSeq;
        ESeq ret;
        try
        {
            ret = proxy->end_opESeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opESeq.
 */
template<class T, typename CT> Callback_TestIntf_opESeqPtr
newCallback_TestIntf_opESeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const ESeq&, const ESeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opESeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opESeq.
 */
template<class T, typename CT> Callback_TestIntf_opESeqPtr
newCallback_TestIntf_opESeq(T* instance, void (T::*cb)(const ESeq&, const ESeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opESeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opSSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opSSeq.
 */
template<class T>
class CallbackNC_TestIntf_opSSeq : public Callback_TestIntf_opSSeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const SSeq&, const SSeq&);

    CallbackNC_TestIntf_opSSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        SSeq iceP_outSeq;
        SSeq ret;
        try
        {
            ret = proxy->end_opSSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opSSeq.
 */
template<class T> Callback_TestIntf_opSSeqPtr
newCallback_TestIntf_opSSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const SSeq&, const SSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opSSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opSSeq.
 */
template<class T> Callback_TestIntf_opSSeqPtr
newCallback_TestIntf_opSSeq(T* instance, void (T::*cb)(const SSeq&, const SSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opSSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opSSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opSSeq.
 */
template<class T, typename CT>
class Callback_TestIntf_opSSeq : public Callback_TestIntf_opSSeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const SSeq&, const SSeq&, const CT&);

    Callback_TestIntf_opSSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        SSeq iceP_outSeq;
        SSeq ret;
        try
        {
            ret = proxy->end_opSSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opSSeq.
 */
template<class T, typename CT> Callback_TestIntf_opSSeqPtr
newCallback_TestIntf_opSSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const SSeq&, const SSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opSSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opSSeq.
 */
template<class T, typename CT> Callback_TestIntf_opSSeqPtr
newCallback_TestIntf_opSSeq(T* instance, void (T::*cb)(const SSeq&, const SSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opSSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opDSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opDSeq.
 */
template<class T>
class CallbackNC_TestIntf_opDSeq : public Callback_TestIntf_opDSeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const DSeq&, const DSeq&);

    CallbackNC_TestIntf_opDSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        DSeq iceP_outSeq;
        DSeq ret;
        try
        {
            ret = proxy->end_opDSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opDSeq.
 */
template<class T> Callback_TestIntf_opDSeqPtr
newCallback_TestIntf_opDSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const DSeq&, const DSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opDSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opDSeq.
 */
template<class T> Callback_TestIntf_opDSeqPtr
newCallback_TestIntf_opDSeq(T* instance, void (T::*cb)(const DSeq&, const DSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opDSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opDSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opDSeq.
 */
template<class T, typename CT>
class Callback_TestIntf_opDSeq : public Callback_TestIntf_opDSeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const DSeq&, const DSeq&, const CT&);

    Callback_TestIntf_opDSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        DSeq iceP_outSeq;
        DSeq ret;
        try
        {
            ret = proxy->end_opDSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opDSeq.
 */
template<class T, typename CT> Callback_TestIntf_opDSeqPtr
newCallback_TestIntf_opDSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const DSeq&, const DSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opDSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opDSeq.
 */
template<class T, typename CT> Callback_TestIntf_opDSeqPtr
newCallback_TestIntf_opDSeq(T* instance, void (T::*cb)(const DSeq&, const DSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opDSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opStringSeqSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opStringSeqSeq.
 */
template<class T>
class CallbackNC_TestIntf_opStringSeqSeq : public Callback_TestIntf_opStringSeqSeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const StringSeqSeq&, const StringSeqSeq&);

    CallbackNC_TestIntf_opStringSeqSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        StringSeqSeq iceP_outSeq;
        StringSeqSeq ret;
        try
        {
            ret = proxy->end_opStringSeqSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opStringSeqSeq.
 */
template<class T> Callback_TestIntf_opStringSeqSeqPtr
newCallback_TestIntf_opStringSeqSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const StringSeqSeq&, const StringSeqSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opStringSeqSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opStringSeqSeq.
 */
template<class T> Callback_TestIntf_opStringSeqSeqPtr
newCallback_TestIntf_opStringSeqSeq(T* instance, void (T::*cb)(const StringSeqSeq&, const StringSeqSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opStringSeqSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opStringSeqSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opStringSeqSeq.
 */
template<class T, typename CT>
class Callback_TestIntf_opStringSeqSeq : public Callback_TestIntf_opStringSeqSeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const StringSeqSeq&, const StringSeqSeq&, const CT&);

    Callback_TestIntf_opStringSeqSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        StringSeqSeq iceP_outSeq;
        StringSeqSeq ret;
        try
        {
            ret = proxy->end_opStringSeqSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opStringSeqSeq.
 */
template<class T, typename CT> Callback_TestIntf_opStringSeqSeqPtr
newCallback_TestIntf_opStringSeqSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const StringSeqSeq&, const StringSeqSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opStringSeqSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opStringSeqSeq.
 */
template<class T, typename CT> Callback_TestIntf_opStringSeqSeqPtr
newCallback_TestIntf_opStringSeqSeq(T* instance, void (T::*cb)(const StringSeqSeq&, const StringSeqSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opStringSeqSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opByteBufferSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opByteBufferSeq.
 */
template<class T>
class CallbackNC_TestIntf_opByteBufferSeq : public Callback_TestIntf_opByteBufferSeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ByteBuffer&, const ByteBuffer&);

    CallbackNC_TestIntf_opByteBufferSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        ByteBuffer iceP_outSeq;
        ByteBuffer ret;
        try
        {
            ret = proxy->end_opByteBufferSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opByteBufferSeq.
 */
template<class T> Callback_TestIntf_opByteBufferSeqPtr
newCallback_TestIntf_opByteBufferSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const ByteBuffer&, const ByteBuffer&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opByteBufferSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opByteBufferSeq.
 */
template<class T> Callback_TestIntf_opByteBufferSeqPtr
newCallback_TestIntf_opByteBufferSeq(T* instance, void (T::*cb)(const ByteBuffer&, const ByteBuffer&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opByteBufferSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opByteBufferSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opByteBufferSeq.
 */
template<class T, typename CT>
class Callback_TestIntf_opByteBufferSeq : public Callback_TestIntf_opByteBufferSeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ByteBuffer&, const ByteBuffer&, const CT&);

    Callback_TestIntf_opByteBufferSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        ByteBuffer iceP_outSeq;
        ByteBuffer ret;
        try
        {
            ret = proxy->end_opByteBufferSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opByteBufferSeq.
 */
template<class T, typename CT> Callback_TestIntf_opByteBufferSeqPtr
newCallback_TestIntf_opByteBufferSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const ByteBuffer&, const ByteBuffer&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opByteBufferSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opByteBufferSeq.
 */
template<class T, typename CT> Callback_TestIntf_opByteBufferSeqPtr
newCallback_TestIntf_opByteBufferSeq(T* instance, void (T::*cb)(const ByteBuffer&, const ByteBuffer&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opByteBufferSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opShortBufferSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opShortBufferSeq.
 */
template<class T>
class CallbackNC_TestIntf_opShortBufferSeq : public Callback_TestIntf_opShortBufferSeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ShortBuffer&, const ShortBuffer&);

    CallbackNC_TestIntf_opShortBufferSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        ShortBuffer iceP_outSeq;
        ShortBuffer ret;
        try
        {
            ret = proxy->end_opShortBufferSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opShortBufferSeq.
 */
template<class T> Callback_TestIntf_opShortBufferSeqPtr
newCallback_TestIntf_opShortBufferSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const ShortBuffer&, const ShortBuffer&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opShortBufferSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opShortBufferSeq.
 */
template<class T> Callback_TestIntf_opShortBufferSeqPtr
newCallback_TestIntf_opShortBufferSeq(T* instance, void (T::*cb)(const ShortBuffer&, const ShortBuffer&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opShortBufferSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opShortBufferSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opShortBufferSeq.
 */
template<class T, typename CT>
class Callback_TestIntf_opShortBufferSeq : public Callback_TestIntf_opShortBufferSeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ShortBuffer&, const ShortBuffer&, const CT&);

    Callback_TestIntf_opShortBufferSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        ShortBuffer iceP_outSeq;
        ShortBuffer ret;
        try
        {
            ret = proxy->end_opShortBufferSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opShortBufferSeq.
 */
template<class T, typename CT> Callback_TestIntf_opShortBufferSeqPtr
newCallback_TestIntf_opShortBufferSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const ShortBuffer&, const ShortBuffer&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opShortBufferSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opShortBufferSeq.
 */
template<class T, typename CT> Callback_TestIntf_opShortBufferSeqPtr
newCallback_TestIntf_opShortBufferSeq(T* instance, void (T::*cb)(const ShortBuffer&, const ShortBuffer&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opShortBufferSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opIntBufferSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opIntBufferSeq.
 */
template<class T>
class CallbackNC_TestIntf_opIntBufferSeq : public Callback_TestIntf_opIntBufferSeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IntBuffer&, const IntBuffer&);

    CallbackNC_TestIntf_opIntBufferSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        IntBuffer iceP_outSeq;
        IntBuffer ret;
        try
        {
            ret = proxy->end_opIntBufferSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opIntBufferSeq.
 */
template<class T> Callback_TestIntf_opIntBufferSeqPtr
newCallback_TestIntf_opIntBufferSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const IntBuffer&, const IntBuffer&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opIntBufferSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opIntBufferSeq.
 */
template<class T> Callback_TestIntf_opIntBufferSeqPtr
newCallback_TestIntf_opIntBufferSeq(T* instance, void (T::*cb)(const IntBuffer&, const IntBuffer&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opIntBufferSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opIntBufferSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opIntBufferSeq.
 */
template<class T, typename CT>
class Callback_TestIntf_opIntBufferSeq : public Callback_TestIntf_opIntBufferSeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IntBuffer&, const IntBuffer&, const CT&);

    Callback_TestIntf_opIntBufferSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        IntBuffer iceP_outSeq;
        IntBuffer ret;
        try
        {
            ret = proxy->end_opIntBufferSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opIntBufferSeq.
 */
template<class T, typename CT> Callback_TestIntf_opIntBufferSeqPtr
newCallback_TestIntf_opIntBufferSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const IntBuffer&, const IntBuffer&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opIntBufferSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opIntBufferSeq.
 */
template<class T, typename CT> Callback_TestIntf_opIntBufferSeqPtr
newCallback_TestIntf_opIntBufferSeq(T* instance, void (T::*cb)(const IntBuffer&, const IntBuffer&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opIntBufferSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opLongBufferSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opLongBufferSeq.
 */
template<class T>
class CallbackNC_TestIntf_opLongBufferSeq : public Callback_TestIntf_opLongBufferSeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const LongBuffer&, const LongBuffer&);

    CallbackNC_TestIntf_opLongBufferSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        LongBuffer iceP_outSeq;
        LongBuffer ret;
        try
        {
            ret = proxy->end_opLongBufferSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opLongBufferSeq.
 */
template<class T> Callback_TestIntf_opLongBufferSeqPtr
newCallback_TestIntf_opLongBufferSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const LongBuffer&, const LongBuffer&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opLongBufferSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opLongBufferSeq.
 */
template<class T> Callback_TestIntf_opLongBufferSeqPtr
newCallback_TestIntf_opLongBufferSeq(T* instance, void (T::*cb)(const LongBuffer&, const LongBuffer&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opLongBufferSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opLongBufferSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opLongBufferSeq.
 */
template<class T, typename CT>
class Callback_TestIntf_opLongBufferSeq : public Callback_TestIntf_opLongBufferSeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const LongBuffer&, const LongBuffer&, const CT&);

    Callback_TestIntf_opLongBufferSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        LongBuffer iceP_outSeq;
        LongBuffer ret;
        try
        {
            ret = proxy->end_opLongBufferSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opLongBufferSeq.
 */
template<class T, typename CT> Callback_TestIntf_opLongBufferSeqPtr
newCallback_TestIntf_opLongBufferSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const LongBuffer&, const LongBuffer&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opLongBufferSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opLongBufferSeq.
 */
template<class T, typename CT> Callback_TestIntf_opLongBufferSeqPtr
newCallback_TestIntf_opLongBufferSeq(T* instance, void (T::*cb)(const LongBuffer&, const LongBuffer&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opLongBufferSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opFloatBufferSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opFloatBufferSeq.
 */
template<class T>
class CallbackNC_TestIntf_opFloatBufferSeq : public Callback_TestIntf_opFloatBufferSeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const FloatBuffer&, const FloatBuffer&);

    CallbackNC_TestIntf_opFloatBufferSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        FloatBuffer iceP_outSeq;
        FloatBuffer ret;
        try
        {
            ret = proxy->end_opFloatBufferSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opFloatBufferSeq.
 */
template<class T> Callback_TestIntf_opFloatBufferSeqPtr
newCallback_TestIntf_opFloatBufferSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const FloatBuffer&, const FloatBuffer&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opFloatBufferSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opFloatBufferSeq.
 */
template<class T> Callback_TestIntf_opFloatBufferSeqPtr
newCallback_TestIntf_opFloatBufferSeq(T* instance, void (T::*cb)(const FloatBuffer&, const FloatBuffer&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opFloatBufferSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opFloatBufferSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opFloatBufferSeq.
 */
template<class T, typename CT>
class Callback_TestIntf_opFloatBufferSeq : public Callback_TestIntf_opFloatBufferSeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const FloatBuffer&, const FloatBuffer&, const CT&);

    Callback_TestIntf_opFloatBufferSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        FloatBuffer iceP_outSeq;
        FloatBuffer ret;
        try
        {
            ret = proxy->end_opFloatBufferSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opFloatBufferSeq.
 */
template<class T, typename CT> Callback_TestIntf_opFloatBufferSeqPtr
newCallback_TestIntf_opFloatBufferSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const FloatBuffer&, const FloatBuffer&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opFloatBufferSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opFloatBufferSeq.
 */
template<class T, typename CT> Callback_TestIntf_opFloatBufferSeqPtr
newCallback_TestIntf_opFloatBufferSeq(T* instance, void (T::*cb)(const FloatBuffer&, const FloatBuffer&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opFloatBufferSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opDoubleBufferSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opDoubleBufferSeq.
 */
template<class T>
class CallbackNC_TestIntf_opDoubleBufferSeq : public Callback_TestIntf_opDoubleBufferSeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const DoubleBuffer&, const DoubleBuffer&);

    CallbackNC_TestIntf_opDoubleBufferSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        DoubleBuffer iceP_outSeq;
        DoubleBuffer ret;
        try
        {
            ret = proxy->end_opDoubleBufferSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opDoubleBufferSeq.
 */
template<class T> Callback_TestIntf_opDoubleBufferSeqPtr
newCallback_TestIntf_opDoubleBufferSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const DoubleBuffer&, const DoubleBuffer&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opDoubleBufferSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opDoubleBufferSeq.
 */
template<class T> Callback_TestIntf_opDoubleBufferSeqPtr
newCallback_TestIntf_opDoubleBufferSeq(T* instance, void (T::*cb)(const DoubleBuffer&, const DoubleBuffer&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opDoubleBufferSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opDoubleBufferSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opDoubleBufferSeq.
 */
template<class T, typename CT>
class Callback_TestIntf_opDoubleBufferSeq : public Callback_TestIntf_opDoubleBufferSeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const DoubleBuffer&, const DoubleBuffer&, const CT&);

    Callback_TestIntf_opDoubleBufferSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        DoubleBuffer iceP_outSeq;
        DoubleBuffer ret;
        try
        {
            ret = proxy->end_opDoubleBufferSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opDoubleBufferSeq.
 */
template<class T, typename CT> Callback_TestIntf_opDoubleBufferSeqPtr
newCallback_TestIntf_opDoubleBufferSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const DoubleBuffer&, const DoubleBuffer&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opDoubleBufferSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opDoubleBufferSeq.
 */
template<class T, typename CT> Callback_TestIntf_opDoubleBufferSeqPtr
newCallback_TestIntf_opDoubleBufferSeq(T* instance, void (T::*cb)(const DoubleBuffer&, const DoubleBuffer&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opDoubleBufferSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opOptCSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opOptCSeq.
 */
template<class T>
class CallbackNC_TestIntf_opOptCSeq : public Callback_TestIntf_opOptCSeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const std::optional<CSeq>&, const std::optional<CSeq>&);

    CallbackNC_TestIntf_opOptCSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        std::optional<CSeq> iceP_outSeq;
        std::optional<CSeq> ret;
        try
        {
            ret = proxy->end_opOptCSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opOptCSeq.
 */
template<class T> Callback_TestIntf_opOptCSeqPtr
newCallback_TestIntf_opOptCSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const std::optional<CSeq>&, const std::optional<CSeq>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opOptCSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opOptCSeq.
 */
template<class T> Callback_TestIntf_opOptCSeqPtr
newCallback_TestIntf_opOptCSeq(T* instance, void (T::*cb)(const std::optional<CSeq>&, const std::optional<CSeq>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opOptCSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opOptCSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opOptCSeq.
 */
template<class T, typename CT>
class Callback_TestIntf_opOptCSeq : public Callback_TestIntf_opOptCSeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const std::optional<CSeq>&, const std::optional<CSeq>&, const CT&);

    Callback_TestIntf_opOptCSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        std::optional<CSeq> iceP_outSeq;
        std::optional<CSeq> ret;
        try
        {
            ret = proxy->end_opOptCSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opOptCSeq.
 */
template<class T, typename CT> Callback_TestIntf_opOptCSeqPtr
newCallback_TestIntf_opOptCSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const std::optional<CSeq>&, const std::optional<CSeq>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opOptCSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opOptCSeq.
 */
template<class T, typename CT> Callback_TestIntf_opOptCSeqPtr
newCallback_TestIntf_opOptCSeq(T* instance, void (T::*cb)(const std::optional<CSeq>&, const std::optional<CSeq>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opOptCSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opOptCArray.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opOptCArray.
 */
template<class T>
class CallbackNC_TestIntf_opOptCArray : public Callback_TestIntf_opOptCArray_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const std::optional<CArray>&, const std::optional<CArray>&);

    CallbackNC_TestIntf_opOptCArray(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        std::optional<CArray> iceP_outSeq;
        std::optional<CArray> ret;
        try
        {
            ret = proxy->end_opOptCArray(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opOptCArray.
 */
template<class T> Callback_TestIntf_opOptCArrayPtr
newCallback_TestIntf_opOptCArray(const IceUtil::Handle<T>& instance, void (T::*cb)(const std::optional<CArray>&, const std::optional<CArray>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opOptCArray<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opOptCArray.
 */
template<class T> Callback_TestIntf_opOptCArrayPtr
newCallback_TestIntf_opOptCArray(T* instance, void (T::*cb)(const std::optional<CArray>&, const std::optional<CArray>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opOptCArray<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opOptCArray.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opOptCArray.
 */
template<class T, typename CT>
class Callback_TestIntf_opOptCArray : public Callback_TestIntf_opOptCArray_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const std::optional<CArray>&, const std::optional<CArray>&, const CT&);

    Callback_TestIntf_opOptCArray(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        std::optional<CArray> iceP_outSeq;
        std::optional<CArray> ret;
        try
        {
            ret = proxy->end_opOptCArray(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opOptCArray.
 */
template<class T, typename CT> Callback_TestIntf_opOptCArrayPtr
newCallback_TestIntf_opOptCArray(const IceUtil::Handle<T>& instance, void (T::*cb)(const std::optional<CArray>&, const std::optional<CArray>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opOptCArray<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opOptCArray.
 */
template<class T, typename CT> Callback_TestIntf_opOptCArrayPtr
newCallback_TestIntf_opOptCArray(T* instance, void (T::*cb)(const std::optional<CArray>&, const std::optional<CArray>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opOptCArray<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opOptCList.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opOptCList.
 */
template<class T>
class CallbackNC_TestIntf_opOptCList : public Callback_TestIntf_opOptCList_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const std::optional<CList>&, const std::optional<CList>&);

    CallbackNC_TestIntf_opOptCList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        std::optional<CList> iceP_outSeq;
        std::optional<CList> ret;
        try
        {
            ret = proxy->end_opOptCList(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opOptCList.
 */
template<class T> Callback_TestIntf_opOptCListPtr
newCallback_TestIntf_opOptCList(const IceUtil::Handle<T>& instance, void (T::*cb)(const std::optional<CList>&, const std::optional<CList>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opOptCList<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opOptCList.
 */
template<class T> Callback_TestIntf_opOptCListPtr
newCallback_TestIntf_opOptCList(T* instance, void (T::*cb)(const std::optional<CList>&, const std::optional<CList>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opOptCList<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opOptCList.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opOptCList.
 */
template<class T, typename CT>
class Callback_TestIntf_opOptCList : public Callback_TestIntf_opOptCList_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const std::optional<CList>&, const std::optional<CList>&, const CT&);

    Callback_TestIntf_opOptCList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        std::optional<CList> iceP_outSeq;
        std::optional<CList> ret;
        try
        {
            ret = proxy->end_opOptCList(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opOptCList.
 */
template<class T, typename CT> Callback_TestIntf_opOptCListPtr
newCallback_TestIntf_opOptCList(const IceUtil::Handle<T>& instance, void (T::*cb)(const std::optional<CList>&, const std::optional<CList>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opOptCList<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opOptCList.
 */
template<class T, typename CT> Callback_TestIntf_opOptCListPtr
newCallback_TestIntf_opOptCList(T* instance, void (T::*cb)(const std::optional<CList>&, const std::optional<CList>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opOptCList<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opOptBoolSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opOptBoolSeq.
 */
template<class T>
class CallbackNC_TestIntf_opOptBoolSeq : public Callback_TestIntf_opOptBoolSeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const std::optional<BoolSeq>&, const std::optional<BoolSeq>&);

    CallbackNC_TestIntf_opOptBoolSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        std::optional<BoolSeq> iceP_outSeq;
        std::optional<BoolSeq> ret;
        try
        {
            ret = proxy->end_opOptBoolSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opOptBoolSeq.
 */
template<class T> Callback_TestIntf_opOptBoolSeqPtr
newCallback_TestIntf_opOptBoolSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const std::optional<BoolSeq>&, const std::optional<BoolSeq>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opOptBoolSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opOptBoolSeq.
 */
template<class T> Callback_TestIntf_opOptBoolSeqPtr
newCallback_TestIntf_opOptBoolSeq(T* instance, void (T::*cb)(const std::optional<BoolSeq>&, const std::optional<BoolSeq>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opOptBoolSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opOptBoolSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opOptBoolSeq.
 */
template<class T, typename CT>
class Callback_TestIntf_opOptBoolSeq : public Callback_TestIntf_opOptBoolSeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const std::optional<BoolSeq>&, const std::optional<BoolSeq>&, const CT&);

    Callback_TestIntf_opOptBoolSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        std::optional<BoolSeq> iceP_outSeq;
        std::optional<BoolSeq> ret;
        try
        {
            ret = proxy->end_opOptBoolSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opOptBoolSeq.
 */
template<class T, typename CT> Callback_TestIntf_opOptBoolSeqPtr
newCallback_TestIntf_opOptBoolSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const std::optional<BoolSeq>&, const std::optional<BoolSeq>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opOptBoolSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opOptBoolSeq.
 */
template<class T, typename CT> Callback_TestIntf_opOptBoolSeqPtr
newCallback_TestIntf_opOptBoolSeq(T* instance, void (T::*cb)(const std::optional<BoolSeq>&, const std::optional<BoolSeq>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opOptBoolSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opOptByteSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opOptByteSeq.
 */
template<class T>
class CallbackNC_TestIntf_opOptByteSeq : public Callback_TestIntf_opOptByteSeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const std::optional<ByteSeq>&, const std::optional<ByteSeq>&);

    CallbackNC_TestIntf_opOptByteSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        std::optional<ByteSeq> iceP_outSeq;
        std::optional<ByteSeq> ret;
        try
        {
            ret = proxy->end_opOptByteSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opOptByteSeq.
 */
template<class T> Callback_TestIntf_opOptByteSeqPtr
newCallback_TestIntf_opOptByteSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const std::optional<ByteSeq>&, const std::optional<ByteSeq>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opOptByteSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opOptByteSeq.
 */
template<class T> Callback_TestIntf_opOptByteSeqPtr
newCallback_TestIntf_opOptByteSeq(T* instance, void (T::*cb)(const std::optional<ByteSeq>&, const std::optional<ByteSeq>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opOptByteSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opOptByteSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opOptByteSeq.
 */
template<class T, typename CT>
class Callback_TestIntf_opOptByteSeq : public Callback_TestIntf_opOptByteSeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const std::optional<ByteSeq>&, const std::optional<ByteSeq>&, const CT&);

    Callback_TestIntf_opOptByteSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        std::optional<ByteSeq> iceP_outSeq;
        std::optional<ByteSeq> ret;
        try
        {
            ret = proxy->end_opOptByteSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opOptByteSeq.
 */
template<class T, typename CT> Callback_TestIntf_opOptByteSeqPtr
newCallback_TestIntf_opOptByteSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const std::optional<ByteSeq>&, const std::optional<ByteSeq>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opOptByteSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opOptByteSeq.
 */
template<class T, typename CT> Callback_TestIntf_opOptByteSeqPtr
newCallback_TestIntf_opOptByteSeq(T* instance, void (T::*cb)(const std::optional<ByteSeq>&, const std::optional<ByteSeq>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opOptByteSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opOptShortSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opOptShortSeq.
 */
template<class T>
class CallbackNC_TestIntf_opOptShortSeq : public Callback_TestIntf_opOptShortSeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const std::optional<ShortSeq>&, const std::optional<ShortSeq>&);

    CallbackNC_TestIntf_opOptShortSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        std::optional<ShortSeq> iceP_outSeq;
        std::optional<ShortSeq> ret;
        try
        {
            ret = proxy->end_opOptShortSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opOptShortSeq.
 */
template<class T> Callback_TestIntf_opOptShortSeqPtr
newCallback_TestIntf_opOptShortSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const std::optional<ShortSeq>&, const std::optional<ShortSeq>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opOptShortSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opOptShortSeq.
 */
template<class T> Callback_TestIntf_opOptShortSeqPtr
newCallback_TestIntf_opOptShortSeq(T* instance, void (T::*cb)(const std::optional<ShortSeq>&, const std::optional<ShortSeq>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opOptShortSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opOptShortSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opOptShortSeq.
 */
template<class T, typename CT>
class Callback_TestIntf_opOptShortSeq : public Callback_TestIntf_opOptShortSeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const std::optional<ShortSeq>&, const std::optional<ShortSeq>&, const CT&);

    Callback_TestIntf_opOptShortSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        std::optional<ShortSeq> iceP_outSeq;
        std::optional<ShortSeq> ret;
        try
        {
            ret = proxy->end_opOptShortSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opOptShortSeq.
 */
template<class T, typename CT> Callback_TestIntf_opOptShortSeqPtr
newCallback_TestIntf_opOptShortSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const std::optional<ShortSeq>&, const std::optional<ShortSeq>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opOptShortSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opOptShortSeq.
 */
template<class T, typename CT> Callback_TestIntf_opOptShortSeqPtr
newCallback_TestIntf_opOptShortSeq(T* instance, void (T::*cb)(const std::optional<ShortSeq>&, const std::optional<ShortSeq>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opOptShortSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opOptIntSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opOptIntSeq.
 */
template<class T>
class CallbackNC_TestIntf_opOptIntSeq : public Callback_TestIntf_opOptIntSeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const std::optional<IntSeq>&, const std::optional<IntSeq>&);

    CallbackNC_TestIntf_opOptIntSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        std::optional<IntSeq> iceP_outSeq;
        std::optional<IntSeq> ret;
        try
        {
            ret = proxy->end_opOptIntSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opOptIntSeq.
 */
template<class T> Callback_TestIntf_opOptIntSeqPtr
newCallback_TestIntf_opOptIntSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const std::optional<IntSeq>&, const std::optional<IntSeq>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opOptIntSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opOptIntSeq.
 */
template<class T> Callback_TestIntf_opOptIntSeqPtr
newCallback_TestIntf_opOptIntSeq(T* instance, void (T::*cb)(const std::optional<IntSeq>&, const std::optional<IntSeq>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opOptIntSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opOptIntSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opOptIntSeq.
 */
template<class T, typename CT>
class Callback_TestIntf_opOptIntSeq : public Callback_TestIntf_opOptIntSeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const std::optional<IntSeq>&, const std::optional<IntSeq>&, const CT&);

    Callback_TestIntf_opOptIntSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        std::optional<IntSeq> iceP_outSeq;
        std::optional<IntSeq> ret;
        try
        {
            ret = proxy->end_opOptIntSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opOptIntSeq.
 */
template<class T, typename CT> Callback_TestIntf_opOptIntSeqPtr
newCallback_TestIntf_opOptIntSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const std::optional<IntSeq>&, const std::optional<IntSeq>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opOptIntSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opOptIntSeq.
 */
template<class T, typename CT> Callback_TestIntf_opOptIntSeqPtr
newCallback_TestIntf_opOptIntSeq(T* instance, void (T::*cb)(const std::optional<IntSeq>&, const std::optional<IntSeq>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opOptIntSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opOptLongSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opOptLongSeq.
 */
template<class T>
class CallbackNC_TestIntf_opOptLongSeq : public Callback_TestIntf_opOptLongSeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const std::optional<LongSeq>&, const std::optional<LongSeq>&);

    CallbackNC_TestIntf_opOptLongSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        std::optional<LongSeq> iceP_outSeq;
        std::optional<LongSeq> ret;
        try
        {
            ret = proxy->end_opOptLongSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opOptLongSeq.
 */
template<class T> Callback_TestIntf_opOptLongSeqPtr
newCallback_TestIntf_opOptLongSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const std::optional<LongSeq>&, const std::optional<LongSeq>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opOptLongSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opOptLongSeq.
 */
template<class T> Callback_TestIntf_opOptLongSeqPtr
newCallback_TestIntf_opOptLongSeq(T* instance, void (T::*cb)(const std::optional<LongSeq>&, const std::optional<LongSeq>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opOptLongSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opOptLongSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opOptLongSeq.
 */
template<class T, typename CT>
class Callback_TestIntf_opOptLongSeq : public Callback_TestIntf_opOptLongSeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const std::optional<LongSeq>&, const std::optional<LongSeq>&, const CT&);

    Callback_TestIntf_opOptLongSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        std::optional<LongSeq> iceP_outSeq;
        std::optional<LongSeq> ret;
        try
        {
            ret = proxy->end_opOptLongSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opOptLongSeq.
 */
template<class T, typename CT> Callback_TestIntf_opOptLongSeqPtr
newCallback_TestIntf_opOptLongSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const std::optional<LongSeq>&, const std::optional<LongSeq>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opOptLongSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opOptLongSeq.
 */
template<class T, typename CT> Callback_TestIntf_opOptLongSeqPtr
newCallback_TestIntf_opOptLongSeq(T* instance, void (T::*cb)(const std::optional<LongSeq>&, const std::optional<LongSeq>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opOptLongSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opOptFloatSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opOptFloatSeq.
 */
template<class T>
class CallbackNC_TestIntf_opOptFloatSeq : public Callback_TestIntf_opOptFloatSeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const std::optional<FloatSeq>&, const std::optional<FloatSeq>&);

    CallbackNC_TestIntf_opOptFloatSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        std::optional<FloatSeq> iceP_outSeq;
        std::optional<FloatSeq> ret;
        try
        {
            ret = proxy->end_opOptFloatSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opOptFloatSeq.
 */
template<class T> Callback_TestIntf_opOptFloatSeqPtr
newCallback_TestIntf_opOptFloatSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const std::optional<FloatSeq>&, const std::optional<FloatSeq>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opOptFloatSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opOptFloatSeq.
 */
template<class T> Callback_TestIntf_opOptFloatSeqPtr
newCallback_TestIntf_opOptFloatSeq(T* instance, void (T::*cb)(const std::optional<FloatSeq>&, const std::optional<FloatSeq>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opOptFloatSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opOptFloatSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opOptFloatSeq.
 */
template<class T, typename CT>
class Callback_TestIntf_opOptFloatSeq : public Callback_TestIntf_opOptFloatSeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const std::optional<FloatSeq>&, const std::optional<FloatSeq>&, const CT&);

    Callback_TestIntf_opOptFloatSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        std::optional<FloatSeq> iceP_outSeq;
        std::optional<FloatSeq> ret;
        try
        {
            ret = proxy->end_opOptFloatSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opOptFloatSeq.
 */
template<class T, typename CT> Callback_TestIntf_opOptFloatSeqPtr
newCallback_TestIntf_opOptFloatSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const std::optional<FloatSeq>&, const std::optional<FloatSeq>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opOptFloatSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opOptFloatSeq.
 */
template<class T, typename CT> Callback_TestIntf_opOptFloatSeqPtr
newCallback_TestIntf_opOptFloatSeq(T* instance, void (T::*cb)(const std::optional<FloatSeq>&, const std::optional<FloatSeq>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opOptFloatSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opOptDoubleSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opOptDoubleSeq.
 */
template<class T>
class CallbackNC_TestIntf_opOptDoubleSeq : public Callback_TestIntf_opOptDoubleSeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const std::optional<DoubleSeq>&, const std::optional<DoubleSeq>&);

    CallbackNC_TestIntf_opOptDoubleSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        std::optional<DoubleSeq> iceP_outSeq;
        std::optional<DoubleSeq> ret;
        try
        {
            ret = proxy->end_opOptDoubleSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opOptDoubleSeq.
 */
template<class T> Callback_TestIntf_opOptDoubleSeqPtr
newCallback_TestIntf_opOptDoubleSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const std::optional<DoubleSeq>&, const std::optional<DoubleSeq>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opOptDoubleSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opOptDoubleSeq.
 */
template<class T> Callback_TestIntf_opOptDoubleSeqPtr
newCallback_TestIntf_opOptDoubleSeq(T* instance, void (T::*cb)(const std::optional<DoubleSeq>&, const std::optional<DoubleSeq>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opOptDoubleSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opOptDoubleSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opOptDoubleSeq.
 */
template<class T, typename CT>
class Callback_TestIntf_opOptDoubleSeq : public Callback_TestIntf_opOptDoubleSeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const std::optional<DoubleSeq>&, const std::optional<DoubleSeq>&, const CT&);

    Callback_TestIntf_opOptDoubleSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        std::optional<DoubleSeq> iceP_outSeq;
        std::optional<DoubleSeq> ret;
        try
        {
            ret = proxy->end_opOptDoubleSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opOptDoubleSeq.
 */
template<class T, typename CT> Callback_TestIntf_opOptDoubleSeqPtr
newCallback_TestIntf_opOptDoubleSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const std::optional<DoubleSeq>&, const std::optional<DoubleSeq>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opOptDoubleSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opOptDoubleSeq.
 */
template<class T, typename CT> Callback_TestIntf_opOptDoubleSeqPtr
newCallback_TestIntf_opOptDoubleSeq(T* instance, void (T::*cb)(const std::optional<DoubleSeq>&, const std::optional<DoubleSeq>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opOptDoubleSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opOptStringSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opOptStringSeq.
 */
template<class T>
class CallbackNC_TestIntf_opOptStringSeq : public Callback_TestIntf_opOptStringSeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const std::optional<StringSeq>&, const std::optional<StringSeq>&);

    CallbackNC_TestIntf_opOptStringSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        std::optional<StringSeq> iceP_outSeq;
        std::optional<StringSeq> ret;
        try
        {
            ret = proxy->end_opOptStringSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opOptStringSeq.
 */
template<class T> Callback_TestIntf_opOptStringSeqPtr
newCallback_TestIntf_opOptStringSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const std::optional<StringSeq>&, const std::optional<StringSeq>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opOptStringSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opOptStringSeq.
 */
template<class T> Callback_TestIntf_opOptStringSeqPtr
newCallback_TestIntf_opOptStringSeq(T* instance, void (T::*cb)(const std::optional<StringSeq>&, const std::optional<StringSeq>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opOptStringSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opOptStringSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opOptStringSeq.
 */
template<class T, typename CT>
class Callback_TestIntf_opOptStringSeq : public Callback_TestIntf_opOptStringSeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const std::optional<StringSeq>&, const std::optional<StringSeq>&, const CT&);

    Callback_TestIntf_opOptStringSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        std::optional<StringSeq> iceP_outSeq;
        std::optional<StringSeq> ret;
        try
        {
            ret = proxy->end_opOptStringSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opOptStringSeq.
 */
template<class T, typename CT> Callback_TestIntf_opOptStringSeqPtr
newCallback_TestIntf_opOptStringSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const std::optional<StringSeq>&, const std::optional<StringSeq>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opOptStringSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opOptStringSeq.
 */
template<class T, typename CT> Callback_TestIntf_opOptStringSeqPtr
newCallback_TestIntf_opOptStringSeq(T* instance, void (T::*cb)(const std::optional<StringSeq>&, const std::optional<StringSeq>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opOptStringSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opOptESeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opOptESeq.
 */
template<class T>
class CallbackNC_TestIntf_opOptESeq : public Callback_TestIntf_opOptESeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const std::optional<ESeq>&, const std::optional<ESeq>&);

    CallbackNC_TestIntf_opOptESeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        std::optional<ESeq> iceP_outSeq;
        std::optional<ESeq> ret;
        try
        {
            ret = proxy->end_opOptESeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opOptESeq.
 */
template<class T> Callback_TestIntf_opOptESeqPtr
newCallback_TestIntf_opOptESeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const std::optional<ESeq>&, const std::optional<ESeq>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opOptESeq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opOptESeq.
 */
template<class T> Callback_TestIntf_opOptESeqPtr
newCallback_TestIntf_opOptESeq(T* instance, void (T::*cb)(const std::optional<ESeq>&, const std::optional<ESeq>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opOptESeq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opOptESeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opOptESeq.
 */
template<class T, typename CT>
class Callback_TestIntf_opOptESeq : public Callback_TestIntf_opOptESeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const std::optional<ESeq>&, const std::optional<ESeq>&, const CT&);

    Callback_TestIntf_opOptESeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        std::optional<ESeq> iceP_outSeq;
        std::optional<ESeq> ret;
        try
        {
            ret = proxy->end_opOptESeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opOptESeq.
 */
template<class T, typename CT> Callback_TestIntf_opOptESeqPtr
newCallback_TestIntf_opOptESeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const std::optional<ESeq>&, const std::optional<ESeq>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opOptESeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opOptESeq.
 */
template<class T, typename CT> Callback_TestIntf_opOptESeqPtr
newCallback_TestIntf_opOptESeq(T* instance, void (T::*cb)(const std::optional<ESeq>&, const std::optional<ESeq>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opOptESeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opOptSSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opOptSSeq.
 */
template<class T>
class CallbackNC_TestIntf_opOptSSeq : public Callback_TestIntf_opOptSSeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const std::optional<SSeq>&, const std::optional<SSeq>&);

    CallbackNC_TestIntf_opOptSSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        std::optional<SSeq> iceP_outSeq;
        std::optional<SSeq> ret;
        try
        {
            ret = proxy->end_opOptSSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opOptSSeq.
 */
template<class T> Callback_TestIntf_opOptSSeqPtr
newCallback_TestIntf_opOptSSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const std::optional<SSeq>&, const std::optional<SSeq>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opOptSSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opOptSSeq.
 */
template<class T> Callback_TestIntf_opOptSSeqPtr
newCallback_TestIntf_opOptSSeq(T* instance, void (T::*cb)(const std::optional<SSeq>&, const std::optional<SSeq>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opOptSSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opOptSSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opOptSSeq.
 */
template<class T, typename CT>
class Callback_TestIntf_opOptSSeq : public Callback_TestIntf_opOptSSeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const std::optional<SSeq>&, const std::optional<SSeq>&, const CT&);

    Callback_TestIntf_opOptSSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        std::optional<SSeq> iceP_outSeq;
        std::optional<SSeq> ret;
        try
        {
            ret = proxy->end_opOptSSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opOptSSeq.
 */
template<class T, typename CT> Callback_TestIntf_opOptSSeqPtr
newCallback_TestIntf_opOptSSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const std::optional<SSeq>&, const std::optional<SSeq>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opOptSSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opOptSSeq.
 */
template<class T, typename CT> Callback_TestIntf_opOptSSeqPtr
newCallback_TestIntf_opOptSSeq(T* instance, void (T::*cb)(const std::optional<SSeq>&, const std::optional<SSeq>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opOptSSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opOptDSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opOptDSeq.
 */
template<class T>
class CallbackNC_TestIntf_opOptDSeq : public Callback_TestIntf_opOptDSeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const std::optional<DSeq>&, const std::optional<DSeq>&);

    CallbackNC_TestIntf_opOptDSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        std::optional<DSeq> iceP_outSeq;
        std::optional<DSeq> ret;
        try
        {
            ret = proxy->end_opOptDSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opOptDSeq.
 */
template<class T> Callback_TestIntf_opOptDSeqPtr
newCallback_TestIntf_opOptDSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const std::optional<DSeq>&, const std::optional<DSeq>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opOptDSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opOptDSeq.
 */
template<class T> Callback_TestIntf_opOptDSeqPtr
newCallback_TestIntf_opOptDSeq(T* instance, void (T::*cb)(const std::optional<DSeq>&, const std::optional<DSeq>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opOptDSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opOptDSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opOptDSeq.
 */
template<class T, typename CT>
class Callback_TestIntf_opOptDSeq : public Callback_TestIntf_opOptDSeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const std::optional<DSeq>&, const std::optional<DSeq>&, const CT&);

    Callback_TestIntf_opOptDSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        std::optional<DSeq> iceP_outSeq;
        std::optional<DSeq> ret;
        try
        {
            ret = proxy->end_opOptDSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opOptDSeq.
 */
template<class T, typename CT> Callback_TestIntf_opOptDSeqPtr
newCallback_TestIntf_opOptDSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const std::optional<DSeq>&, const std::optional<DSeq>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opOptDSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opOptDSeq.
 */
template<class T, typename CT> Callback_TestIntf_opOptDSeqPtr
newCallback_TestIntf_opOptDSeq(T* instance, void (T::*cb)(const std::optional<DSeq>&, const std::optional<DSeq>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opOptDSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opOptStringSeqSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opOptStringSeqSeq.
 */
template<class T>
class CallbackNC_TestIntf_opOptStringSeqSeq : public Callback_TestIntf_opOptStringSeqSeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const std::optional<StringSeqSeq>&, const std::optional<StringSeqSeq>&);

    CallbackNC_TestIntf_opOptStringSeqSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        std::optional<StringSeqSeq> iceP_outSeq;
        std::optional<StringSeqSeq> ret;
        try
        {
            ret = proxy->end_opOptStringSeqSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opOptStringSeqSeq.
 */
template<class T> Callback_TestIntf_opOptStringSeqSeqPtr
newCallback_TestIntf_opOptStringSeqSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const std::optional<StringSeqSeq>&, const std::optional<StringSeqSeq>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opOptStringSeqSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opOptStringSeqSeq.
 */
template<class T> Callback_TestIntf_opOptStringSeqSeqPtr
newCallback_TestIntf_opOptStringSeqSeq(T* instance, void (T::*cb)(const std::optional<StringSeqSeq>&, const std::optional<StringSeqSeq>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opOptStringSeqSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opOptStringSeqSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opOptStringSeqSeq.
 */
template<class T, typename CT>
class Callback_TestIntf_opOptStringSeqSeq : public Callback_TestIntf_opOptStringSeqSeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const std::optional<StringSeqSeq>&, const std::optional<StringSeqSeq>&, const CT&);

    Callback_TestIntf_opOptStringSeqSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        std::optional<StringSeqSeq> iceP_outSeq;
        std::optional<StringSeqSeq> ret;
        try
        {
            ret = proxy->end_opOptStringSeqSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opOptStringSeqSeq.
 */
template<class T, typename CT> Callback_TestIntf_opOptStringSeqSeqPtr
newCallback_TestIntf_opOptStringSeqSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const std::optional<StringSeqSeq>&, const std::optional<StringSeqSeq>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opOptStringSeqSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opOptStringSeqSeq.
 */
template<class T, typename CT> Callback_TestIntf_opOptStringSeqSeqPtr
newCallback_TestIntf_opOptStringSeqSeq(T* instance, void (T::*cb)(const std::optional<StringSeqSeq>&, const std::optional<StringSeqSeq>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opOptStringSeqSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opOptByteBufferSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opOptByteBufferSeq.
 */
template<class T>
class CallbackNC_TestIntf_opOptByteBufferSeq : public Callback_TestIntf_opOptByteBufferSeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const std::optional<ByteBuffer>&, const std::optional<ByteBuffer>&);

    CallbackNC_TestIntf_opOptByteBufferSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        std::optional<ByteBuffer> iceP_outSeq;
        std::optional<ByteBuffer> ret;
        try
        {
            ret = proxy->end_opOptByteBufferSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opOptByteBufferSeq.
 */
template<class T> Callback_TestIntf_opOptByteBufferSeqPtr
newCallback_TestIntf_opOptByteBufferSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const std::optional<ByteBuffer>&, const std::optional<ByteBuffer>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opOptByteBufferSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opOptByteBufferSeq.
 */
template<class T> Callback_TestIntf_opOptByteBufferSeqPtr
newCallback_TestIntf_opOptByteBufferSeq(T* instance, void (T::*cb)(const std::optional<ByteBuffer>&, const std::optional<ByteBuffer>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opOptByteBufferSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opOptByteBufferSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opOptByteBufferSeq.
 */
template<class T, typename CT>
class Callback_TestIntf_opOptByteBufferSeq : public Callback_TestIntf_opOptByteBufferSeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const std::optional<ByteBuffer>&, const std::optional<ByteBuffer>&, const CT&);

    Callback_TestIntf_opOptByteBufferSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        std::optional<ByteBuffer> iceP_outSeq;
        std::optional<ByteBuffer> ret;
        try
        {
            ret = proxy->end_opOptByteBufferSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opOptByteBufferSeq.
 */
template<class T, typename CT> Callback_TestIntf_opOptByteBufferSeqPtr
newCallback_TestIntf_opOptByteBufferSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const std::optional<ByteBuffer>&, const std::optional<ByteBuffer>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opOptByteBufferSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opOptByteBufferSeq.
 */
template<class T, typename CT> Callback_TestIntf_opOptByteBufferSeqPtr
newCallback_TestIntf_opOptByteBufferSeq(T* instance, void (T::*cb)(const std::optional<ByteBuffer>&, const std::optional<ByteBuffer>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opOptByteBufferSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opOptShortBufferSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opOptShortBufferSeq.
 */
template<class T>
class CallbackNC_TestIntf_opOptShortBufferSeq : public Callback_TestIntf_opOptShortBufferSeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const std::optional<ShortBuffer>&, const std::optional<ShortBuffer>&);

    CallbackNC_TestIntf_opOptShortBufferSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        std::optional<ShortBuffer> iceP_outSeq;
        std::optional<ShortBuffer> ret;
        try
        {
            ret = proxy->end_opOptShortBufferSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opOptShortBufferSeq.
 */
template<class T> Callback_TestIntf_opOptShortBufferSeqPtr
newCallback_TestIntf_opOptShortBufferSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const std::optional<ShortBuffer>&, const std::optional<ShortBuffer>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opOptShortBufferSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opOptShortBufferSeq.
 */
template<class T> Callback_TestIntf_opOptShortBufferSeqPtr
newCallback_TestIntf_opOptShortBufferSeq(T* instance, void (T::*cb)(const std::optional<ShortBuffer>&, const std::optional<ShortBuffer>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opOptShortBufferSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opOptShortBufferSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opOptShortBufferSeq.
 */
template<class T, typename CT>
class Callback_TestIntf_opOptShortBufferSeq : public Callback_TestIntf_opOptShortBufferSeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const std::optional<ShortBuffer>&, const std::optional<ShortBuffer>&, const CT&);

    Callback_TestIntf_opOptShortBufferSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        std::optional<ShortBuffer> iceP_outSeq;
        std::optional<ShortBuffer> ret;
        try
        {
            ret = proxy->end_opOptShortBufferSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opOptShortBufferSeq.
 */
template<class T, typename CT> Callback_TestIntf_opOptShortBufferSeqPtr
newCallback_TestIntf_opOptShortBufferSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const std::optional<ShortBuffer>&, const std::optional<ShortBuffer>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opOptShortBufferSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opOptShortBufferSeq.
 */
template<class T, typename CT> Callback_TestIntf_opOptShortBufferSeqPtr
newCallback_TestIntf_opOptShortBufferSeq(T* instance, void (T::*cb)(const std::optional<ShortBuffer>&, const std::optional<ShortBuffer>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opOptShortBufferSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opOptIntBufferSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opOptIntBufferSeq.
 */
template<class T>
class CallbackNC_TestIntf_opOptIntBufferSeq : public Callback_TestIntf_opOptIntBufferSeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const std::optional<IntBuffer>&, const std::optional<IntBuffer>&);

    CallbackNC_TestIntf_opOptIntBufferSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        std::optional<IntBuffer> iceP_outSeq;
        std::optional<IntBuffer> ret;
        try
        {
            ret = proxy->end_opOptIntBufferSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opOptIntBufferSeq.
 */
template<class T> Callback_TestIntf_opOptIntBufferSeqPtr
newCallback_TestIntf_opOptIntBufferSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const std::optional<IntBuffer>&, const std::optional<IntBuffer>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opOptIntBufferSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opOptIntBufferSeq.
 */
template<class T> Callback_TestIntf_opOptIntBufferSeqPtr
newCallback_TestIntf_opOptIntBufferSeq(T* instance, void (T::*cb)(const std::optional<IntBuffer>&, const std::optional<IntBuffer>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opOptIntBufferSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opOptIntBufferSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opOptIntBufferSeq.
 */
template<class T, typename CT>
class Callback_TestIntf_opOptIntBufferSeq : public Callback_TestIntf_opOptIntBufferSeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const std::optional<IntBuffer>&, const std::optional<IntBuffer>&, const CT&);

    Callback_TestIntf_opOptIntBufferSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        std::optional<IntBuffer> iceP_outSeq;
        std::optional<IntBuffer> ret;
        try
        {
            ret = proxy->end_opOptIntBufferSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opOptIntBufferSeq.
 */
template<class T, typename CT> Callback_TestIntf_opOptIntBufferSeqPtr
newCallback_TestIntf_opOptIntBufferSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const std::optional<IntBuffer>&, const std::optional<IntBuffer>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opOptIntBufferSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opOptIntBufferSeq.
 */
template<class T, typename CT> Callback_TestIntf_opOptIntBufferSeqPtr
newCallback_TestIntf_opOptIntBufferSeq(T* instance, void (T::*cb)(const std::optional<IntBuffer>&, const std::optional<IntBuffer>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opOptIntBufferSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opOptLongBufferSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opOptLongBufferSeq.
 */
template<class T>
class CallbackNC_TestIntf_opOptLongBufferSeq : public Callback_TestIntf_opOptLongBufferSeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const std::optional<LongBuffer>&, const std::optional<LongBuffer>&);

    CallbackNC_TestIntf_opOptLongBufferSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        std::optional<LongBuffer> iceP_outSeq;
        std::optional<LongBuffer> ret;
        try
        {
            ret = proxy->end_opOptLongBufferSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opOptLongBufferSeq.
 */
template<class T> Callback_TestIntf_opOptLongBufferSeqPtr
newCallback_TestIntf_opOptLongBufferSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const std::optional<LongBuffer>&, const std::optional<LongBuffer>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opOptLongBufferSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opOptLongBufferSeq.
 */
template<class T> Callback_TestIntf_opOptLongBufferSeqPtr
newCallback_TestIntf_opOptLongBufferSeq(T* instance, void (T::*cb)(const std::optional<LongBuffer>&, const std::optional<LongBuffer>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opOptLongBufferSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opOptLongBufferSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opOptLongBufferSeq.
 */
template<class T, typename CT>
class Callback_TestIntf_opOptLongBufferSeq : public Callback_TestIntf_opOptLongBufferSeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const std::optional<LongBuffer>&, const std::optional<LongBuffer>&, const CT&);

    Callback_TestIntf_opOptLongBufferSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        std::optional<LongBuffer> iceP_outSeq;
        std::optional<LongBuffer> ret;
        try
        {
            ret = proxy->end_opOptLongBufferSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opOptLongBufferSeq.
 */
template<class T, typename CT> Callback_TestIntf_opOptLongBufferSeqPtr
newCallback_TestIntf_opOptLongBufferSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const std::optional<LongBuffer>&, const std::optional<LongBuffer>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opOptLongBufferSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opOptLongBufferSeq.
 */
template<class T, typename CT> Callback_TestIntf_opOptLongBufferSeqPtr
newCallback_TestIntf_opOptLongBufferSeq(T* instance, void (T::*cb)(const std::optional<LongBuffer>&, const std::optional<LongBuffer>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opOptLongBufferSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opOptFloatBufferSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opOptFloatBufferSeq.
 */
template<class T>
class CallbackNC_TestIntf_opOptFloatBufferSeq : public Callback_TestIntf_opOptFloatBufferSeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const std::optional<FloatBuffer>&, const std::optional<FloatBuffer>&);

    CallbackNC_TestIntf_opOptFloatBufferSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        std::optional<FloatBuffer> iceP_outSeq;
        std::optional<FloatBuffer> ret;
        try
        {
            ret = proxy->end_opOptFloatBufferSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opOptFloatBufferSeq.
 */
template<class T> Callback_TestIntf_opOptFloatBufferSeqPtr
newCallback_TestIntf_opOptFloatBufferSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const std::optional<FloatBuffer>&, const std::optional<FloatBuffer>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opOptFloatBufferSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opOptFloatBufferSeq.
 */
template<class T> Callback_TestIntf_opOptFloatBufferSeqPtr
newCallback_TestIntf_opOptFloatBufferSeq(T* instance, void (T::*cb)(const std::optional<FloatBuffer>&, const std::optional<FloatBuffer>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opOptFloatBufferSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opOptFloatBufferSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opOptFloatBufferSeq.
 */
template<class T, typename CT>
class Callback_TestIntf_opOptFloatBufferSeq : public Callback_TestIntf_opOptFloatBufferSeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const std::optional<FloatBuffer>&, const std::optional<FloatBuffer>&, const CT&);

    Callback_TestIntf_opOptFloatBufferSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        std::optional<FloatBuffer> iceP_outSeq;
        std::optional<FloatBuffer> ret;
        try
        {
            ret = proxy->end_opOptFloatBufferSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opOptFloatBufferSeq.
 */
template<class T, typename CT> Callback_TestIntf_opOptFloatBufferSeqPtr
newCallback_TestIntf_opOptFloatBufferSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const std::optional<FloatBuffer>&, const std::optional<FloatBuffer>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opOptFloatBufferSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opOptFloatBufferSeq.
 */
template<class T, typename CT> Callback_TestIntf_opOptFloatBufferSeqPtr
newCallback_TestIntf_opOptFloatBufferSeq(T* instance, void (T::*cb)(const std::optional<FloatBuffer>&, const std::optional<FloatBuffer>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opOptFloatBufferSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_opOptDoubleBufferSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opOptDoubleBufferSeq.
 */
template<class T>
class CallbackNC_TestIntf_opOptDoubleBufferSeq : public Callback_TestIntf_opOptDoubleBufferSeq_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const std::optional<DoubleBuffer>&, const std::optional<DoubleBuffer>&);

    CallbackNC_TestIntf_opOptDoubleBufferSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        std::optional<DoubleBuffer> iceP_outSeq;
        std::optional<DoubleBuffer> ret;
        try
        {
            ret = proxy->end_opOptDoubleBufferSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_outSeq);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opOptDoubleBufferSeq.
 */
template<class T> Callback_TestIntf_opOptDoubleBufferSeqPtr
newCallback_TestIntf_opOptDoubleBufferSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const std::optional<DoubleBuffer>&, const std::optional<DoubleBuffer>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opOptDoubleBufferSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opOptDoubleBufferSeq.
 */
template<class T> Callback_TestIntf_opOptDoubleBufferSeqPtr
newCallback_TestIntf_opOptDoubleBufferSeq(T* instance, void (T::*cb)(const std::optional<DoubleBuffer>&, const std::optional<DoubleBuffer>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_opOptDoubleBufferSeq<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_opOptDoubleBufferSeq.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_opOptDoubleBufferSeq.
 */
template<class T, typename CT>
class Callback_TestIntf_opOptDoubleBufferSeq : public Callback_TestIntf_opOptDoubleBufferSeq_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const std::optional<DoubleBuffer>&, const std::optional<DoubleBuffer>&, const CT&);

    Callback_TestIntf_opOptDoubleBufferSeq(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TestIntfPrx proxy = TestIntfPrx::uncheckedCast(result->getProxy());
        std::optional<DoubleBuffer> iceP_outSeq;
        std::optional<DoubleBuffer> ret;
        try
        {
            ret = proxy->end_opOptDoubleBufferSeq(iceP_outSeq, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_outSeq, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opOptDoubleBufferSeq.
 */
template<class T, typename CT> Callback_TestIntf_opOptDoubleBufferSeqPtr
newCallback_TestIntf_opOptDoubleBufferSeq(const IceUtil::Handle<T>& instance, void (T::*cb)(const std::optional<DoubleBuffer>&, const std::optional<DoubleBuffer>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opOptDoubleBufferSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_opOptDoubleBufferSeq.
 */
template<class T, typename CT> Callback_TestIntf_opOptDoubleBufferSeqPtr
newCallback_TestIntf_opOptDoubleBufferSeq(T* instance, void (T::*cb)(const std::optional<DoubleBuffer>&, const std::optional<DoubleBuffer>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_opOptDoubleBufferSeq<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::TestIntf::begin_shutdown.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_shutdown.
 */
template<class T>
class CallbackNC_TestIntf_shutdown : public Callback_TestIntf_shutdown_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_TestIntf_shutdown(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_shutdown.
 */
template<class T> Callback_TestIntf_shutdownPtr
newCallback_TestIntf_shutdown(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_shutdown<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_shutdown.
 */
template<class T> Callback_TestIntf_shutdownPtr
newCallback_TestIntf_shutdown(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_shutdown<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_shutdown.
 */
template<class T> Callback_TestIntf_shutdownPtr
newCallback_TestIntf_shutdown(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_shutdown<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_shutdown.
 */
template<class T> Callback_TestIntf_shutdownPtr
newCallback_TestIntf_shutdown(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_TestIntf_shutdown<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::TestIntf::begin_shutdown.
 * Create a wrapper instance by calling ::Test::newCallback_TestIntf_shutdown.
 */
template<class T, typename CT>
class Callback_TestIntf_shutdown : public Callback_TestIntf_shutdown_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_TestIntf_shutdown(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_shutdown.
 */
template<class T, typename CT> Callback_TestIntf_shutdownPtr
newCallback_TestIntf_shutdown(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_shutdown<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_shutdown.
 */
template<class T, typename CT> Callback_TestIntf_shutdownPtr
newCallback_TestIntf_shutdown(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_shutdown<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_shutdown.
 */
template<class T, typename CT> Callback_TestIntf_shutdownPtr
newCallback_TestIntf_shutdown(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_shutdown<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::TestIntf::begin_shutdown.
 */
template<class T, typename CT> Callback_TestIntf_shutdownPtr
newCallback_TestIntf_shutdown(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_TestIntf_shutdown<T, CT>(instance, 0, excb, sentcb);
}

}

#endif

#include <IceUtil/PopDisableWarnings.h>
#endif
