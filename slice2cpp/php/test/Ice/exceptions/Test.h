//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.7.10
//
// <auto-generated>
//
// Generated from file `Test.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __Test_h__
#define __Test_h__

#include <IceUtil/PushDisableWarnings.h>
#include <Ice/Ice.h>
#include <Ice/BuiltinSequences.h>
#include <IceUtil/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 307
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 >= 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 10
#       error Ice patch level mismatch!
#   endif
#endif

#ifdef ICE_CPP11_MAPPING // C++11 mapping

namespace Test
{

class Empty;
class EmptyPrx;
class Thrower;
class ThrowerPrx;
class WrongOperation;
class WrongOperationPrx;

}

namespace Test
{

class A : public ::Ice::UserExceptionHelper<A, ::Ice::UserException>
{
public:

    virtual ~A();

    A(const A&) = default;

    A() = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    A(int aMem) :
        aMem(aMem)
    {
    }

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const int&> ice_tuple() const
    {
        return std::tie(aMem);
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    int aMem;
};

/// \cond INTERNAL
static A _iceS_A_init;
/// \endcond

class B : public ::Ice::UserExceptionHelper<B, A>
{
public:

    virtual ~B();

    B(const B&) = default;

    B() = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    B(int aMem, int bMem) :
        ::Ice::UserExceptionHelper<B, A>(aMem),
        bMem(bMem)
    {
    }

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const int&, const int&> ice_tuple() const
    {
        return std::tie(aMem, bMem);
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    int bMem;
};

class C : public ::Ice::UserExceptionHelper<C, B>
{
public:

    virtual ~C();

    C(const C&) = default;

    C() = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    C(int aMem, int bMem, int cMem) :
        ::Ice::UserExceptionHelper<C, B>(aMem, bMem),
        cMem(cMem)
    {
    }

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const int&, const int&, const int&> ice_tuple() const
    {
        return std::tie(aMem, bMem, cMem);
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    int cMem;
};

class D : public ::Ice::UserExceptionHelper<D, ::Ice::UserException>
{
public:

    virtual ~D();

    D(const D&) = default;

    D() = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    D(int dMem) :
        dMem(dMem)
    {
    }

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const int&> ice_tuple() const
    {
        return std::tie(dMem);
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    int dMem;
};

}

namespace Test
{

class Empty : public virtual ::Ice::Object
{
public:

    using ProxyType = EmptyPrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();
};

class Thrower : public virtual ::Ice::Object
{
public:

    using ProxyType = ThrowerPrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void shutdown(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_shutdown(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool supportsUndeclaredExceptions(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_supportsUndeclaredExceptions(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void throwAasA(int a, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_throwAasA(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void throwAorDasAorD(int a, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_throwAorDasAorD(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void throwBasA(int a, int b, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_throwBasA(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void throwCasA(int a, int b, int c, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_throwCasA(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void throwBasB(int a, int b, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_throwBasB(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void throwCasB(int a, int b, int c, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_throwCasB(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void throwCasC(int a, int b, int c, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_throwCasC(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void throwUndeclaredA(int a, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_throwUndeclaredA(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void throwUndeclaredB(int a, int b, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_throwUndeclaredB(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void throwUndeclaredC(int a, int b, int c, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_throwUndeclaredC(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void throwLocalException(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_throwLocalException(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void throwNonIceException(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_throwNonIceException(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::Ice::ByteSeq throwMemoryLimitException(::Ice::ByteSeq seq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_throwMemoryLimitException(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void throwLocalExceptionIdempotent(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_throwLocalExceptionIdempotent(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

class WrongOperation : public virtual ::Ice::Object
{
public:

    using ProxyType = WrongOperationPrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void noSuchOperation(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_noSuchOperation(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

}

namespace Test
{

class EmptyPrx : public virtual ::Ice::Proxy<EmptyPrx, ::Ice::ObjectPrx>
{
public:

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    EmptyPrx() = default;
    friend ::std::shared_ptr<EmptyPrx> IceInternal::createProxy<EmptyPrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

class ThrowerPrx : public virtual ::Ice::Proxy<ThrowerPrx, ::Ice::ObjectPrx>
{
public:

    void shutdown(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &ThrowerPrx::_iceI_shutdown, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto shutdownAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &ThrowerPrx::_iceI_shutdown, context);
    }

    ::std::function<void()>
    shutdownAsync(::std::function<void()> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::ThrowerPrx::_iceI_shutdown, context);
    }

    /// \cond INTERNAL
    void _iceI_shutdown(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    bool supportsUndeclaredExceptions(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<bool>(true, this, &ThrowerPrx::_iceI_supportsUndeclaredExceptions, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto supportsUndeclaredExceptionsAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<bool>>().get_future())
    {
        return _makePromiseOutgoing<bool, P>(false, this, &ThrowerPrx::_iceI_supportsUndeclaredExceptions, context);
    }

    ::std::function<void()>
    supportsUndeclaredExceptionsAsync(::std::function<void(bool)> response,
                                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                                      ::std::function<void(bool)> sent = nullptr,
                                      const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<bool>(std::move(response), std::move(ex), std::move(sent), this, &Test::ThrowerPrx::_iceI_supportsUndeclaredExceptions, context);
    }

    /// \cond INTERNAL
    void _iceI_supportsUndeclaredExceptions(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>&, const ::Ice::Context&);
    /// \endcond

    void throwAasA(int a, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &ThrowerPrx::_iceI_throwAasA, a, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto throwAasAAsync(int a, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &ThrowerPrx::_iceI_throwAasA, a, context);
    }

    ::std::function<void()>
    throwAasAAsync(int a,
                   ::std::function<void()> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::ThrowerPrx::_iceI_throwAasA, a, context);
    }

    /// \cond INTERNAL
    void _iceI_throwAasA(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, int, const ::Ice::Context&);
    /// \endcond

    void throwAorDasAorD(int a, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &ThrowerPrx::_iceI_throwAorDasAorD, a, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto throwAorDasAorDAsync(int a, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &ThrowerPrx::_iceI_throwAorDasAorD, a, context);
    }

    ::std::function<void()>
    throwAorDasAorDAsync(int a,
                         ::std::function<void()> response,
                         ::std::function<void(::std::exception_ptr)> ex = nullptr,
                         ::std::function<void(bool)> sent = nullptr,
                         const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::ThrowerPrx::_iceI_throwAorDasAorD, a, context);
    }

    /// \cond INTERNAL
    void _iceI_throwAorDasAorD(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, int, const ::Ice::Context&);
    /// \endcond

    void throwBasA(int a, int b, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &ThrowerPrx::_iceI_throwBasA, a, b, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto throwBasAAsync(int a, int b, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &ThrowerPrx::_iceI_throwBasA, a, b, context);
    }

    ::std::function<void()>
    throwBasAAsync(int a, int b,
                   ::std::function<void()> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::ThrowerPrx::_iceI_throwBasA, a, b, context);
    }

    /// \cond INTERNAL
    void _iceI_throwBasA(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, int, int, const ::Ice::Context&);
    /// \endcond

    void throwCasA(int a, int b, int c, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &ThrowerPrx::_iceI_throwCasA, a, b, c, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto throwCasAAsync(int a, int b, int c, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &ThrowerPrx::_iceI_throwCasA, a, b, c, context);
    }

    ::std::function<void()>
    throwCasAAsync(int a, int b, int c,
                   ::std::function<void()> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::ThrowerPrx::_iceI_throwCasA, a, b, c, context);
    }

    /// \cond INTERNAL
    void _iceI_throwCasA(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, int, int, int, const ::Ice::Context&);
    /// \endcond

    void throwBasB(int a, int b, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &ThrowerPrx::_iceI_throwBasB, a, b, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto throwBasBAsync(int a, int b, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &ThrowerPrx::_iceI_throwBasB, a, b, context);
    }

    ::std::function<void()>
    throwBasBAsync(int a, int b,
                   ::std::function<void()> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::ThrowerPrx::_iceI_throwBasB, a, b, context);
    }

    /// \cond INTERNAL
    void _iceI_throwBasB(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, int, int, const ::Ice::Context&);
    /// \endcond

    void throwCasB(int a, int b, int c, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &ThrowerPrx::_iceI_throwCasB, a, b, c, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto throwCasBAsync(int a, int b, int c, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &ThrowerPrx::_iceI_throwCasB, a, b, c, context);
    }

    ::std::function<void()>
    throwCasBAsync(int a, int b, int c,
                   ::std::function<void()> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::ThrowerPrx::_iceI_throwCasB, a, b, c, context);
    }

    /// \cond INTERNAL
    void _iceI_throwCasB(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, int, int, int, const ::Ice::Context&);
    /// \endcond

    void throwCasC(int a, int b, int c, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &ThrowerPrx::_iceI_throwCasC, a, b, c, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto throwCasCAsync(int a, int b, int c, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &ThrowerPrx::_iceI_throwCasC, a, b, c, context);
    }

    ::std::function<void()>
    throwCasCAsync(int a, int b, int c,
                   ::std::function<void()> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::ThrowerPrx::_iceI_throwCasC, a, b, c, context);
    }

    /// \cond INTERNAL
    void _iceI_throwCasC(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, int, int, int, const ::Ice::Context&);
    /// \endcond

    void throwUndeclaredA(int a, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &ThrowerPrx::_iceI_throwUndeclaredA, a, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto throwUndeclaredAAsync(int a, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &ThrowerPrx::_iceI_throwUndeclaredA, a, context);
    }

    ::std::function<void()>
    throwUndeclaredAAsync(int a,
                          ::std::function<void()> response,
                          ::std::function<void(::std::exception_ptr)> ex = nullptr,
                          ::std::function<void(bool)> sent = nullptr,
                          const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::ThrowerPrx::_iceI_throwUndeclaredA, a, context);
    }

    /// \cond INTERNAL
    void _iceI_throwUndeclaredA(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, int, const ::Ice::Context&);
    /// \endcond

    void throwUndeclaredB(int a, int b, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &ThrowerPrx::_iceI_throwUndeclaredB, a, b, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto throwUndeclaredBAsync(int a, int b, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &ThrowerPrx::_iceI_throwUndeclaredB, a, b, context);
    }

    ::std::function<void()>
    throwUndeclaredBAsync(int a, int b,
                          ::std::function<void()> response,
                          ::std::function<void(::std::exception_ptr)> ex = nullptr,
                          ::std::function<void(bool)> sent = nullptr,
                          const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::ThrowerPrx::_iceI_throwUndeclaredB, a, b, context);
    }

    /// \cond INTERNAL
    void _iceI_throwUndeclaredB(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, int, int, const ::Ice::Context&);
    /// \endcond

    void throwUndeclaredC(int a, int b, int c, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &ThrowerPrx::_iceI_throwUndeclaredC, a, b, c, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto throwUndeclaredCAsync(int a, int b, int c, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &ThrowerPrx::_iceI_throwUndeclaredC, a, b, c, context);
    }

    ::std::function<void()>
    throwUndeclaredCAsync(int a, int b, int c,
                          ::std::function<void()> response,
                          ::std::function<void(::std::exception_ptr)> ex = nullptr,
                          ::std::function<void(bool)> sent = nullptr,
                          const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::ThrowerPrx::_iceI_throwUndeclaredC, a, b, c, context);
    }

    /// \cond INTERNAL
    void _iceI_throwUndeclaredC(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, int, int, int, const ::Ice::Context&);
    /// \endcond

    void throwLocalException(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &ThrowerPrx::_iceI_throwLocalException, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto throwLocalExceptionAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &ThrowerPrx::_iceI_throwLocalException, context);
    }

    ::std::function<void()>
    throwLocalExceptionAsync(::std::function<void()> response,
                             ::std::function<void(::std::exception_ptr)> ex = nullptr,
                             ::std::function<void(bool)> sent = nullptr,
                             const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::ThrowerPrx::_iceI_throwLocalException, context);
    }

    /// \cond INTERNAL
    void _iceI_throwLocalException(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    void throwNonIceException(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &ThrowerPrx::_iceI_throwNonIceException, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto throwNonIceExceptionAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &ThrowerPrx::_iceI_throwNonIceException, context);
    }

    ::std::function<void()>
    throwNonIceExceptionAsync(::std::function<void()> response,
                              ::std::function<void(::std::exception_ptr)> ex = nullptr,
                              ::std::function<void(bool)> sent = nullptr,
                              const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::ThrowerPrx::_iceI_throwNonIceException, context);
    }

    /// \cond INTERNAL
    void _iceI_throwNonIceException(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    ::Ice::ByteSeq throwMemoryLimitException(const ::Ice::ByteSeq& seq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::Ice::ByteSeq>(true, this, &ThrowerPrx::_iceI_throwMemoryLimitException, seq, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto throwMemoryLimitExceptionAsync(const ::Ice::ByteSeq& seq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::Ice::ByteSeq>>().get_future())
    {
        return _makePromiseOutgoing<::Ice::ByteSeq, P>(false, this, &ThrowerPrx::_iceI_throwMemoryLimitException, seq, context);
    }

    ::std::function<void()>
    throwMemoryLimitExceptionAsync(const ::Ice::ByteSeq& seq,
                                   ::std::function<void(::Ice::ByteSeq)> response,
                                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                                   ::std::function<void(bool)> sent = nullptr,
                                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<::Ice::ByteSeq>(std::move(response), std::move(ex), std::move(sent), this, &Test::ThrowerPrx::_iceI_throwMemoryLimitException, seq, context);
    }

    /// \cond INTERNAL
    void _iceI_throwMemoryLimitException(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::Ice::ByteSeq>>&, const ::Ice::ByteSeq&, const ::Ice::Context&);
    /// \endcond

    void throwLocalExceptionIdempotent(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &ThrowerPrx::_iceI_throwLocalExceptionIdempotent, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto throwLocalExceptionIdempotentAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &ThrowerPrx::_iceI_throwLocalExceptionIdempotent, context);
    }

    ::std::function<void()>
    throwLocalExceptionIdempotentAsync(::std::function<void()> response,
                                       ::std::function<void(::std::exception_ptr)> ex = nullptr,
                                       ::std::function<void(bool)> sent = nullptr,
                                       const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::ThrowerPrx::_iceI_throwLocalExceptionIdempotent, context);
    }

    /// \cond INTERNAL
    void _iceI_throwLocalExceptionIdempotent(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    ThrowerPrx() = default;
    friend ::std::shared_ptr<ThrowerPrx> IceInternal::createProxy<ThrowerPrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

class WrongOperationPrx : public virtual ::Ice::Proxy<WrongOperationPrx, ::Ice::ObjectPrx>
{
public:

    void noSuchOperation(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &WrongOperationPrx::_iceI_noSuchOperation, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto noSuchOperationAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &WrongOperationPrx::_iceI_noSuchOperation, context);
    }

    ::std::function<void()>
    noSuchOperationAsync(::std::function<void()> response,
                         ::std::function<void(::std::exception_ptr)> ex = nullptr,
                         ::std::function<void(bool)> sent = nullptr,
                         const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::WrongOperationPrx::_iceI_noSuchOperation, context);
    }

    /// \cond INTERNAL
    void _iceI_noSuchOperation(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    WrongOperationPrx() = default;
    friend ::std::shared_ptr<WrongOperationPrx> IceInternal::createProxy<WrongOperationPrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

}

/// \cond STREAM
namespace Ice
{

template<typename S>
struct StreamReader<::Test::A, S>
{
    static void read(S* istr, ::Test::A& v)
    {
        istr->readAll(v.aMem);
    }
};

template<typename S>
struct StreamWriter<::Test::B, S>
{
    static void write(S* ostr, const ::Test::B& v)
    {
        ostr->writeAll(v.bMem);
    }
};

template<typename S>
struct StreamReader<::Test::B, S>
{
    static void read(S* istr, ::Test::B& v)
    {
        istr->readAll(v.bMem);
    }
};

template<typename S>
struct StreamWriter<::Test::C, S>
{
    static void write(S* ostr, const ::Test::C& v)
    {
        ostr->writeAll(v.cMem);
    }
};

template<typename S>
struct StreamReader<::Test::C, S>
{
    static void read(S* istr, ::Test::C& v)
    {
        istr->readAll(v.cMem);
    }
};

template<typename S>
struct StreamReader<::Test::D, S>
{
    static void read(S* istr, ::Test::D& v)
    {
        istr->readAll(v.dMem);
    }
};

}
/// \endcond

/// \cond INTERNAL
namespace Test
{

using EmptyPtr = ::std::shared_ptr<Empty>;
using EmptyPrxPtr = ::std::shared_ptr<EmptyPrx>;

using ThrowerPtr = ::std::shared_ptr<Thrower>;
using ThrowerPrxPtr = ::std::shared_ptr<ThrowerPrx>;

using WrongOperationPtr = ::std::shared_ptr<WrongOperation>;
using WrongOperationPrxPtr = ::std::shared_ptr<WrongOperationPrx>;

}
/// \endcond

#else // C++98 mapping

namespace IceProxy
{

namespace Test
{

class Empty;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< Empty>&);
::IceProxy::Ice::Object* upCast(Empty*);
/// \endcond

class Thrower;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< Thrower>&);
::IceProxy::Ice::Object* upCast(Thrower*);
/// \endcond

class WrongOperation;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< WrongOperation>&);
::IceProxy::Ice::Object* upCast(WrongOperation*);
/// \endcond

}

}

namespace Test
{

class Empty;
/// \cond INTERNAL
::Ice::Object* upCast(Empty*);
/// \endcond
typedef ::IceInternal::Handle< Empty> EmptyPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::Empty> EmptyPrx;
typedef EmptyPrx EmptyPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(EmptyPtr&, const ::Ice::ObjectPtr&);
/// \endcond

class Thrower;
/// \cond INTERNAL
::Ice::Object* upCast(Thrower*);
/// \endcond
typedef ::IceInternal::Handle< Thrower> ThrowerPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::Thrower> ThrowerPrx;
typedef ThrowerPrx ThrowerPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(ThrowerPtr&, const ::Ice::ObjectPtr&);
/// \endcond

class WrongOperation;
/// \cond INTERNAL
::Ice::Object* upCast(WrongOperation*);
/// \endcond
typedef ::IceInternal::Handle< WrongOperation> WrongOperationPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::WrongOperation> WrongOperationPrx;
typedef WrongOperationPrx WrongOperationPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(WrongOperationPtr&, const ::Ice::ObjectPtr&);
/// \endcond

}

namespace Test
{

class A : public ::Ice::UserException
{
public:

    A() {}
    /**
     * One-shot constructor to initialize all data members.
     */
    explicit A(::Ice::Int aMem);

#ifdef ICE_CPP11_COMPILER
    A(const A&) = default;
    virtual ~A();
#else
    virtual ~A() throw();
#endif

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    virtual ::std::string ice_id() const;
    /**
     * Polymorphically clones this exception.
     * @return A shallow copy of this exception.
     */
    virtual A* ice_clone() const;
    /**
     * Throws this exception.
     */
    virtual void ice_throw() const;

    ::Ice::Int aMem;

protected:

    /// \cond STREAM
    virtual void _writeImpl(::Ice::OutputStream*) const;
    virtual void _readImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
static A _iceS_A_init;
/// \endcond

class B : public A
{
public:

    B() {}
    /**
     * One-shot constructor to initialize all data members.
     */
    B(::Ice::Int aMem, ::Ice::Int bMem);

#ifdef ICE_CPP11_COMPILER
    B(const B&) = default;
    virtual ~B();
#else
    virtual ~B() throw();
#endif

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    virtual ::std::string ice_id() const;
    /**
     * Polymorphically clones this exception.
     * @return A shallow copy of this exception.
     */
    virtual B* ice_clone() const;
    /**
     * Throws this exception.
     */
    virtual void ice_throw() const;

    ::Ice::Int bMem;

protected:

    /// \cond STREAM
    virtual void _writeImpl(::Ice::OutputStream*) const;
    virtual void _readImpl(::Ice::InputStream*);
    /// \endcond
};

class C : public B
{
public:

    C() {}
    /**
     * One-shot constructor to initialize all data members.
     */
    C(::Ice::Int aMem, ::Ice::Int bMem, ::Ice::Int cMem);

#ifdef ICE_CPP11_COMPILER
    C(const C&) = default;
    virtual ~C();
#else
    virtual ~C() throw();
#endif

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    virtual ::std::string ice_id() const;
    /**
     * Polymorphically clones this exception.
     * @return A shallow copy of this exception.
     */
    virtual C* ice_clone() const;
    /**
     * Throws this exception.
     */
    virtual void ice_throw() const;

    ::Ice::Int cMem;

protected:

    /// \cond STREAM
    virtual void _writeImpl(::Ice::OutputStream*) const;
    virtual void _readImpl(::Ice::InputStream*);
    /// \endcond
};

class D : public ::Ice::UserException
{
public:

    D() {}
    /**
     * One-shot constructor to initialize all data members.
     */
    explicit D(::Ice::Int dMem);

#ifdef ICE_CPP11_COMPILER
    D(const D&) = default;
    virtual ~D();
#else
    virtual ~D() throw();
#endif

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    virtual ::std::string ice_id() const;
    /**
     * Polymorphically clones this exception.
     * @return A shallow copy of this exception.
     */
    virtual D* ice_clone() const;
    /**
     * Throws this exception.
     */
    virtual void ice_throw() const;

    ::Ice::Int dMem;

protected:

    /// \cond STREAM
    virtual void _writeImpl(::Ice::OutputStream*) const;
    virtual void _readImpl(::Ice::InputStream*);
    /// \endcond
};

}

namespace Test
{

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Thrower::begin_shutdown.
 * Create a wrapper instance by calling ::Test::newCallback_Thrower_shutdown.
 */
class Callback_Thrower_shutdown_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Thrower_shutdown_Base> Callback_Thrower_shutdownPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Thrower::begin_supportsUndeclaredExceptions.
 * Create a wrapper instance by calling ::Test::newCallback_Thrower_supportsUndeclaredExceptions.
 */
class Callback_Thrower_supportsUndeclaredExceptions_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Thrower_supportsUndeclaredExceptions_Base> Callback_Thrower_supportsUndeclaredExceptionsPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Thrower::begin_throwAasA.
 * Create a wrapper instance by calling ::Test::newCallback_Thrower_throwAasA.
 */
class Callback_Thrower_throwAasA_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Thrower_throwAasA_Base> Callback_Thrower_throwAasAPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Thrower::begin_throwAorDasAorD.
 * Create a wrapper instance by calling ::Test::newCallback_Thrower_throwAorDasAorD.
 */
class Callback_Thrower_throwAorDasAorD_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Thrower_throwAorDasAorD_Base> Callback_Thrower_throwAorDasAorDPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Thrower::begin_throwBasA.
 * Create a wrapper instance by calling ::Test::newCallback_Thrower_throwBasA.
 */
class Callback_Thrower_throwBasA_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Thrower_throwBasA_Base> Callback_Thrower_throwBasAPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Thrower::begin_throwCasA.
 * Create a wrapper instance by calling ::Test::newCallback_Thrower_throwCasA.
 */
class Callback_Thrower_throwCasA_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Thrower_throwCasA_Base> Callback_Thrower_throwCasAPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Thrower::begin_throwBasB.
 * Create a wrapper instance by calling ::Test::newCallback_Thrower_throwBasB.
 */
class Callback_Thrower_throwBasB_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Thrower_throwBasB_Base> Callback_Thrower_throwBasBPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Thrower::begin_throwCasB.
 * Create a wrapper instance by calling ::Test::newCallback_Thrower_throwCasB.
 */
class Callback_Thrower_throwCasB_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Thrower_throwCasB_Base> Callback_Thrower_throwCasBPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Thrower::begin_throwCasC.
 * Create a wrapper instance by calling ::Test::newCallback_Thrower_throwCasC.
 */
class Callback_Thrower_throwCasC_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Thrower_throwCasC_Base> Callback_Thrower_throwCasCPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Thrower::begin_throwUndeclaredA.
 * Create a wrapper instance by calling ::Test::newCallback_Thrower_throwUndeclaredA.
 */
class Callback_Thrower_throwUndeclaredA_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Thrower_throwUndeclaredA_Base> Callback_Thrower_throwUndeclaredAPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Thrower::begin_throwUndeclaredB.
 * Create a wrapper instance by calling ::Test::newCallback_Thrower_throwUndeclaredB.
 */
class Callback_Thrower_throwUndeclaredB_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Thrower_throwUndeclaredB_Base> Callback_Thrower_throwUndeclaredBPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Thrower::begin_throwUndeclaredC.
 * Create a wrapper instance by calling ::Test::newCallback_Thrower_throwUndeclaredC.
 */
class Callback_Thrower_throwUndeclaredC_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Thrower_throwUndeclaredC_Base> Callback_Thrower_throwUndeclaredCPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Thrower::begin_throwLocalException.
 * Create a wrapper instance by calling ::Test::newCallback_Thrower_throwLocalException.
 */
class Callback_Thrower_throwLocalException_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Thrower_throwLocalException_Base> Callback_Thrower_throwLocalExceptionPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Thrower::begin_throwNonIceException.
 * Create a wrapper instance by calling ::Test::newCallback_Thrower_throwNonIceException.
 */
class Callback_Thrower_throwNonIceException_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Thrower_throwNonIceException_Base> Callback_Thrower_throwNonIceExceptionPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Thrower::begin_throwMemoryLimitException.
 * Create a wrapper instance by calling ::Test::newCallback_Thrower_throwMemoryLimitException.
 */
class Callback_Thrower_throwMemoryLimitException_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Thrower_throwMemoryLimitException_Base> Callback_Thrower_throwMemoryLimitExceptionPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::Thrower::begin_throwLocalExceptionIdempotent.
 * Create a wrapper instance by calling ::Test::newCallback_Thrower_throwLocalExceptionIdempotent.
 */
class Callback_Thrower_throwLocalExceptionIdempotent_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Thrower_throwLocalExceptionIdempotent_Base> Callback_Thrower_throwLocalExceptionIdempotentPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::WrongOperation::begin_noSuchOperation.
 * Create a wrapper instance by calling ::Test::newCallback_WrongOperation_noSuchOperation.
 */
class Callback_WrongOperation_noSuchOperation_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_WrongOperation_noSuchOperation_Base> Callback_WrongOperation_noSuchOperationPtr;

}

namespace IceProxy
{

namespace Test
{

class Empty : public virtual ::Ice::Proxy<Empty, ::IceProxy::Ice::Object>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class Thrower : public virtual ::Ice::Proxy<Thrower, ::IceProxy::Ice::Object>
{
public:

    void shutdown(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_shutdown(_iceI_begin_shutdown(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_shutdown(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_shutdown(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_shutdown(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_shutdown(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_shutdown(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_shutdown(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_shutdown(const ::Test::Callback_Thrower_shutdownPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_shutdown(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_shutdown(const ::Ice::Context& context, const ::Test::Callback_Thrower_shutdownPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_shutdown(context, cb, cookie);
    }

    void end_shutdown(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_shutdown(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    bool supportsUndeclaredExceptions(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_supportsUndeclaredExceptions(_iceI_begin_supportsUndeclaredExceptions(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_supportsUndeclaredExceptions(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_supportsUndeclaredExceptions(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_supportsUndeclaredExceptions(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_supportsUndeclaredExceptions(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_supportsUndeclaredExceptions(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_supportsUndeclaredExceptions(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_supportsUndeclaredExceptions(const ::Test::Callback_Thrower_supportsUndeclaredExceptionsPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_supportsUndeclaredExceptions(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_supportsUndeclaredExceptions(const ::Ice::Context& context, const ::Test::Callback_Thrower_supportsUndeclaredExceptionsPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_supportsUndeclaredExceptions(context, cb, cookie);
    }

    bool end_supportsUndeclaredExceptions(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_supportsUndeclaredExceptions(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void throwAasA(::Ice::Int a, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_throwAasA(_iceI_begin_throwAasA(a, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_throwAasA(::Ice::Int a, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_throwAasA(a, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_throwAasA(::Ice::Int a, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwAasA(a, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwAasA(::Ice::Int a, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwAasA(a, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwAasA(::Ice::Int a, const ::Test::Callback_Thrower_throwAasAPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwAasA(a, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwAasA(::Ice::Int a, const ::Ice::Context& context, const ::Test::Callback_Thrower_throwAasAPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwAasA(a, context, cb, cookie);
    }

    void end_throwAasA(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_throwAasA(::Ice::Int, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void throwAorDasAorD(::Ice::Int a, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_throwAorDasAorD(_iceI_begin_throwAorDasAorD(a, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_throwAorDasAorD(::Ice::Int a, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_throwAorDasAorD(a, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_throwAorDasAorD(::Ice::Int a, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwAorDasAorD(a, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwAorDasAorD(::Ice::Int a, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwAorDasAorD(a, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwAorDasAorD(::Ice::Int a, const ::Test::Callback_Thrower_throwAorDasAorDPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwAorDasAorD(a, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwAorDasAorD(::Ice::Int a, const ::Ice::Context& context, const ::Test::Callback_Thrower_throwAorDasAorDPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwAorDasAorD(a, context, cb, cookie);
    }

    void end_throwAorDasAorD(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_throwAorDasAorD(::Ice::Int, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void throwBasA(::Ice::Int a, ::Ice::Int b, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_throwBasA(_iceI_begin_throwBasA(a, b, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_throwBasA(::Ice::Int a, ::Ice::Int b, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_throwBasA(a, b, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_throwBasA(::Ice::Int a, ::Ice::Int b, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwBasA(a, b, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwBasA(::Ice::Int a, ::Ice::Int b, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwBasA(a, b, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwBasA(::Ice::Int a, ::Ice::Int b, const ::Test::Callback_Thrower_throwBasAPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwBasA(a, b, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwBasA(::Ice::Int a, ::Ice::Int b, const ::Ice::Context& context, const ::Test::Callback_Thrower_throwBasAPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwBasA(a, b, context, cb, cookie);
    }

    void end_throwBasA(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_throwBasA(::Ice::Int, ::Ice::Int, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void throwCasA(::Ice::Int a, ::Ice::Int b, ::Ice::Int c, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_throwCasA(_iceI_begin_throwCasA(a, b, c, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_throwCasA(::Ice::Int a, ::Ice::Int b, ::Ice::Int c, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_throwCasA(a, b, c, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_throwCasA(::Ice::Int a, ::Ice::Int b, ::Ice::Int c, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwCasA(a, b, c, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwCasA(::Ice::Int a, ::Ice::Int b, ::Ice::Int c, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwCasA(a, b, c, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwCasA(::Ice::Int a, ::Ice::Int b, ::Ice::Int c, const ::Test::Callback_Thrower_throwCasAPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwCasA(a, b, c, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwCasA(::Ice::Int a, ::Ice::Int b, ::Ice::Int c, const ::Ice::Context& context, const ::Test::Callback_Thrower_throwCasAPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwCasA(a, b, c, context, cb, cookie);
    }

    void end_throwCasA(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_throwCasA(::Ice::Int, ::Ice::Int, ::Ice::Int, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void throwBasB(::Ice::Int a, ::Ice::Int b, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_throwBasB(_iceI_begin_throwBasB(a, b, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_throwBasB(::Ice::Int a, ::Ice::Int b, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_throwBasB(a, b, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_throwBasB(::Ice::Int a, ::Ice::Int b, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwBasB(a, b, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwBasB(::Ice::Int a, ::Ice::Int b, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwBasB(a, b, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwBasB(::Ice::Int a, ::Ice::Int b, const ::Test::Callback_Thrower_throwBasBPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwBasB(a, b, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwBasB(::Ice::Int a, ::Ice::Int b, const ::Ice::Context& context, const ::Test::Callback_Thrower_throwBasBPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwBasB(a, b, context, cb, cookie);
    }

    void end_throwBasB(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_throwBasB(::Ice::Int, ::Ice::Int, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void throwCasB(::Ice::Int a, ::Ice::Int b, ::Ice::Int c, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_throwCasB(_iceI_begin_throwCasB(a, b, c, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_throwCasB(::Ice::Int a, ::Ice::Int b, ::Ice::Int c, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_throwCasB(a, b, c, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_throwCasB(::Ice::Int a, ::Ice::Int b, ::Ice::Int c, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwCasB(a, b, c, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwCasB(::Ice::Int a, ::Ice::Int b, ::Ice::Int c, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwCasB(a, b, c, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwCasB(::Ice::Int a, ::Ice::Int b, ::Ice::Int c, const ::Test::Callback_Thrower_throwCasBPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwCasB(a, b, c, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwCasB(::Ice::Int a, ::Ice::Int b, ::Ice::Int c, const ::Ice::Context& context, const ::Test::Callback_Thrower_throwCasBPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwCasB(a, b, c, context, cb, cookie);
    }

    void end_throwCasB(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_throwCasB(::Ice::Int, ::Ice::Int, ::Ice::Int, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void throwCasC(::Ice::Int a, ::Ice::Int b, ::Ice::Int c, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_throwCasC(_iceI_begin_throwCasC(a, b, c, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_throwCasC(::Ice::Int a, ::Ice::Int b, ::Ice::Int c, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_throwCasC(a, b, c, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_throwCasC(::Ice::Int a, ::Ice::Int b, ::Ice::Int c, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwCasC(a, b, c, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwCasC(::Ice::Int a, ::Ice::Int b, ::Ice::Int c, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwCasC(a, b, c, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwCasC(::Ice::Int a, ::Ice::Int b, ::Ice::Int c, const ::Test::Callback_Thrower_throwCasCPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwCasC(a, b, c, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwCasC(::Ice::Int a, ::Ice::Int b, ::Ice::Int c, const ::Ice::Context& context, const ::Test::Callback_Thrower_throwCasCPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwCasC(a, b, c, context, cb, cookie);
    }

    void end_throwCasC(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_throwCasC(::Ice::Int, ::Ice::Int, ::Ice::Int, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void throwUndeclaredA(::Ice::Int a, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_throwUndeclaredA(_iceI_begin_throwUndeclaredA(a, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_throwUndeclaredA(::Ice::Int a, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_throwUndeclaredA(a, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_throwUndeclaredA(::Ice::Int a, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwUndeclaredA(a, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwUndeclaredA(::Ice::Int a, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwUndeclaredA(a, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwUndeclaredA(::Ice::Int a, const ::Test::Callback_Thrower_throwUndeclaredAPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwUndeclaredA(a, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwUndeclaredA(::Ice::Int a, const ::Ice::Context& context, const ::Test::Callback_Thrower_throwUndeclaredAPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwUndeclaredA(a, context, cb, cookie);
    }

    void end_throwUndeclaredA(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_throwUndeclaredA(::Ice::Int, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void throwUndeclaredB(::Ice::Int a, ::Ice::Int b, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_throwUndeclaredB(_iceI_begin_throwUndeclaredB(a, b, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_throwUndeclaredB(::Ice::Int a, ::Ice::Int b, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_throwUndeclaredB(a, b, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_throwUndeclaredB(::Ice::Int a, ::Ice::Int b, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwUndeclaredB(a, b, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwUndeclaredB(::Ice::Int a, ::Ice::Int b, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwUndeclaredB(a, b, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwUndeclaredB(::Ice::Int a, ::Ice::Int b, const ::Test::Callback_Thrower_throwUndeclaredBPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwUndeclaredB(a, b, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwUndeclaredB(::Ice::Int a, ::Ice::Int b, const ::Ice::Context& context, const ::Test::Callback_Thrower_throwUndeclaredBPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwUndeclaredB(a, b, context, cb, cookie);
    }

    void end_throwUndeclaredB(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_throwUndeclaredB(::Ice::Int, ::Ice::Int, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void throwUndeclaredC(::Ice::Int a, ::Ice::Int b, ::Ice::Int c, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_throwUndeclaredC(_iceI_begin_throwUndeclaredC(a, b, c, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_throwUndeclaredC(::Ice::Int a, ::Ice::Int b, ::Ice::Int c, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_throwUndeclaredC(a, b, c, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_throwUndeclaredC(::Ice::Int a, ::Ice::Int b, ::Ice::Int c, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwUndeclaredC(a, b, c, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwUndeclaredC(::Ice::Int a, ::Ice::Int b, ::Ice::Int c, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwUndeclaredC(a, b, c, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwUndeclaredC(::Ice::Int a, ::Ice::Int b, ::Ice::Int c, const ::Test::Callback_Thrower_throwUndeclaredCPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwUndeclaredC(a, b, c, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwUndeclaredC(::Ice::Int a, ::Ice::Int b, ::Ice::Int c, const ::Ice::Context& context, const ::Test::Callback_Thrower_throwUndeclaredCPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwUndeclaredC(a, b, c, context, cb, cookie);
    }

    void end_throwUndeclaredC(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_throwUndeclaredC(::Ice::Int, ::Ice::Int, ::Ice::Int, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void throwLocalException(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_throwLocalException(_iceI_begin_throwLocalException(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_throwLocalException(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_throwLocalException(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_throwLocalException(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwLocalException(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwLocalException(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwLocalException(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwLocalException(const ::Test::Callback_Thrower_throwLocalExceptionPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwLocalException(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwLocalException(const ::Ice::Context& context, const ::Test::Callback_Thrower_throwLocalExceptionPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwLocalException(context, cb, cookie);
    }

    void end_throwLocalException(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_throwLocalException(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void throwNonIceException(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_throwNonIceException(_iceI_begin_throwNonIceException(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_throwNonIceException(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_throwNonIceException(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_throwNonIceException(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwNonIceException(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwNonIceException(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwNonIceException(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwNonIceException(const ::Test::Callback_Thrower_throwNonIceExceptionPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwNonIceException(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwNonIceException(const ::Ice::Context& context, const ::Test::Callback_Thrower_throwNonIceExceptionPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwNonIceException(context, cb, cookie);
    }

    void end_throwNonIceException(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_throwNonIceException(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Ice::ByteSeq throwMemoryLimitException(const ::Ice::ByteSeq& seq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_throwMemoryLimitException(_iceI_begin_throwMemoryLimitException(seq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_throwMemoryLimitException(const ::Ice::ByteSeq& seq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_throwMemoryLimitException(seq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_throwMemoryLimitException(const ::Ice::ByteSeq& seq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwMemoryLimitException(seq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwMemoryLimitException(const ::Ice::ByteSeq& seq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwMemoryLimitException(seq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwMemoryLimitException(const ::Ice::ByteSeq& seq, const ::Test::Callback_Thrower_throwMemoryLimitExceptionPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwMemoryLimitException(seq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwMemoryLimitException(const ::Ice::ByteSeq& seq, const ::Ice::Context& context, const ::Test::Callback_Thrower_throwMemoryLimitExceptionPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwMemoryLimitException(seq, context, cb, cookie);
    }

    ::Ice::ByteSeq end_throwMemoryLimitException(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_throwMemoryLimitException(const ::Ice::ByteSeq&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void throwLocalExceptionIdempotent(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_throwLocalExceptionIdempotent(_iceI_begin_throwLocalExceptionIdempotent(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_throwLocalExceptionIdempotent(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_throwLocalExceptionIdempotent(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_throwLocalExceptionIdempotent(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwLocalExceptionIdempotent(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwLocalExceptionIdempotent(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwLocalExceptionIdempotent(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwLocalExceptionIdempotent(const ::Test::Callback_Thrower_throwLocalExceptionIdempotentPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwLocalExceptionIdempotent(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_throwLocalExceptionIdempotent(const ::Ice::Context& context, const ::Test::Callback_Thrower_throwLocalExceptionIdempotentPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_throwLocalExceptionIdempotent(context, cb, cookie);
    }

    void end_throwLocalExceptionIdempotent(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_throwLocalExceptionIdempotent(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class WrongOperation : public virtual ::Ice::Proxy<WrongOperation, ::IceProxy::Ice::Object>
{
public:

    void noSuchOperation(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_noSuchOperation(_iceI_begin_noSuchOperation(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_noSuchOperation(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_noSuchOperation(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_noSuchOperation(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_noSuchOperation(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_noSuchOperation(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_noSuchOperation(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_noSuchOperation(const ::Test::Callback_WrongOperation_noSuchOperationPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_noSuchOperation(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_noSuchOperation(const ::Ice::Context& context, const ::Test::Callback_WrongOperation_noSuchOperationPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_noSuchOperation(context, cb, cookie);
    }

    void end_noSuchOperation(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_noSuchOperation(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

}

}

namespace Test
{

class Empty : public virtual ::Ice::Object
{
public:

    typedef EmptyPrx ProxyType;
    typedef EmptyPtr PointerType;

    virtual ~Empty();

#ifdef ICE_CPP11_COMPILER
    Empty() = default;
    Empty(const Empty&) = default;
    Empty& operator=(const Empty&) = default;
#endif

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
inline bool operator==(const Empty& lhs, const Empty& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const Empty& lhs, const Empty& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class Thrower : public virtual ::Ice::Object
{
public:

    typedef ThrowerPrx ProxyType;
    typedef ThrowerPtr PointerType;

    virtual ~Thrower();

#ifdef ICE_CPP11_COMPILER
    Thrower() = default;
    Thrower(const Thrower&) = default;
    Thrower& operator=(const Thrower&) = default;
#endif

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void shutdown(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_shutdown(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool supportsUndeclaredExceptions(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_supportsUndeclaredExceptions(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void throwAasA(::Ice::Int a, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_throwAasA(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void throwAorDasAorD(::Ice::Int a, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_throwAorDasAorD(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void throwBasA(::Ice::Int a, ::Ice::Int b, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_throwBasA(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void throwCasA(::Ice::Int a, ::Ice::Int b, ::Ice::Int c, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_throwCasA(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void throwBasB(::Ice::Int a, ::Ice::Int b, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_throwBasB(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void throwCasB(::Ice::Int a, ::Ice::Int b, ::Ice::Int c, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_throwCasB(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void throwCasC(::Ice::Int a, ::Ice::Int b, ::Ice::Int c, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_throwCasC(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void throwUndeclaredA(::Ice::Int a, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_throwUndeclaredA(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void throwUndeclaredB(::Ice::Int a, ::Ice::Int b, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_throwUndeclaredB(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void throwUndeclaredC(::Ice::Int a, ::Ice::Int b, ::Ice::Int c, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_throwUndeclaredC(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void throwLocalException(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_throwLocalException(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void throwNonIceException(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_throwNonIceException(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::Ice::ByteSeq throwMemoryLimitException(const ::Ice::ByteSeq& seq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_throwMemoryLimitException(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void throwLocalExceptionIdempotent(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_throwLocalExceptionIdempotent(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
inline bool operator==(const Thrower& lhs, const Thrower& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const Thrower& lhs, const Thrower& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class WrongOperation : public virtual ::Ice::Object
{
public:

    typedef WrongOperationPrx ProxyType;
    typedef WrongOperationPtr PointerType;

    virtual ~WrongOperation();

#ifdef ICE_CPP11_COMPILER
    WrongOperation() = default;
    WrongOperation(const WrongOperation&) = default;
    WrongOperation& operator=(const WrongOperation&) = default;
#endif

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void noSuchOperation(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_noSuchOperation(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
inline bool operator==(const WrongOperation& lhs, const WrongOperation& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const WrongOperation& lhs, const WrongOperation& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

}

/// \cond STREAM
namespace Ice
{

template<>
struct StreamableTraits< ::Test::A>
{
    static const StreamHelperCategory helper = StreamHelperCategoryUserException;
};

template<typename S>
struct StreamWriter< ::Test::A, S>
{
    static void write(S* ostr, const ::Test::A& v)
    {
        ostr->write(v.aMem);
    }
};

template<typename S>
struct StreamReader< ::Test::A, S>
{
    static void read(S* istr, ::Test::A& v)
    {
        istr->read(v.aMem);
    }
};

template<>
struct StreamableTraits< ::Test::B>
{
    static const StreamHelperCategory helper = StreamHelperCategoryUserException;
};

template<typename S>
struct StreamWriter< ::Test::B, S>
{
    static void write(S* ostr, const ::Test::B& v)
    {
        ostr->write(v.bMem);
    }
};

template<typename S>
struct StreamReader< ::Test::B, S>
{
    static void read(S* istr, ::Test::B& v)
    {
        istr->read(v.bMem);
    }
};

template<>
struct StreamableTraits< ::Test::C>
{
    static const StreamHelperCategory helper = StreamHelperCategoryUserException;
};

template<typename S>
struct StreamWriter< ::Test::C, S>
{
    static void write(S* ostr, const ::Test::C& v)
    {
        ostr->write(v.cMem);
    }
};

template<typename S>
struct StreamReader< ::Test::C, S>
{
    static void read(S* istr, ::Test::C& v)
    {
        istr->read(v.cMem);
    }
};

template<>
struct StreamableTraits< ::Test::D>
{
    static const StreamHelperCategory helper = StreamHelperCategoryUserException;
};

template<typename S>
struct StreamWriter< ::Test::D, S>
{
    static void write(S* ostr, const ::Test::D& v)
    {
        ostr->write(v.dMem);
    }
};

template<typename S>
struct StreamReader< ::Test::D, S>
{
    static void read(S* istr, ::Test::D& v)
    {
        istr->read(v.dMem);
    }
};

}
/// \endcond

namespace Test
{

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Thrower::begin_shutdown.
 * Create a wrapper instance by calling ::Test::newCallback_Thrower_shutdown.
 */
template<class T>
class CallbackNC_Thrower_shutdown : public Callback_Thrower_shutdown_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Thrower_shutdown(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_shutdown.
 */
template<class T> Callback_Thrower_shutdownPtr
newCallback_Thrower_shutdown(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_shutdown<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_shutdown.
 */
template<class T> Callback_Thrower_shutdownPtr
newCallback_Thrower_shutdown(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_shutdown<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_shutdown.
 */
template<class T> Callback_Thrower_shutdownPtr
newCallback_Thrower_shutdown(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_shutdown<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_shutdown.
 */
template<class T> Callback_Thrower_shutdownPtr
newCallback_Thrower_shutdown(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_shutdown<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Thrower::begin_shutdown.
 * Create a wrapper instance by calling ::Test::newCallback_Thrower_shutdown.
 */
template<class T, typename CT>
class Callback_Thrower_shutdown : public Callback_Thrower_shutdown_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Thrower_shutdown(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_shutdown.
 */
template<class T, typename CT> Callback_Thrower_shutdownPtr
newCallback_Thrower_shutdown(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_shutdown<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_shutdown.
 */
template<class T, typename CT> Callback_Thrower_shutdownPtr
newCallback_Thrower_shutdown(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_shutdown<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_shutdown.
 */
template<class T, typename CT> Callback_Thrower_shutdownPtr
newCallback_Thrower_shutdown(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_shutdown<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_shutdown.
 */
template<class T, typename CT> Callback_Thrower_shutdownPtr
newCallback_Thrower_shutdown(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_shutdown<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Thrower::begin_supportsUndeclaredExceptions.
 * Create a wrapper instance by calling ::Test::newCallback_Thrower_supportsUndeclaredExceptions.
 */
template<class T>
class CallbackNC_Thrower_supportsUndeclaredExceptions : public Callback_Thrower_supportsUndeclaredExceptions_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_Thrower_supportsUndeclaredExceptions(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ThrowerPrx proxy = ThrowerPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_supportsUndeclaredExceptions(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_supportsUndeclaredExceptions.
 */
template<class T> Callback_Thrower_supportsUndeclaredExceptionsPtr
newCallback_Thrower_supportsUndeclaredExceptions(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_supportsUndeclaredExceptions<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_supportsUndeclaredExceptions.
 */
template<class T> Callback_Thrower_supportsUndeclaredExceptionsPtr
newCallback_Thrower_supportsUndeclaredExceptions(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_supportsUndeclaredExceptions<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Thrower::begin_supportsUndeclaredExceptions.
 * Create a wrapper instance by calling ::Test::newCallback_Thrower_supportsUndeclaredExceptions.
 */
template<class T, typename CT>
class Callback_Thrower_supportsUndeclaredExceptions : public Callback_Thrower_supportsUndeclaredExceptions_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_Thrower_supportsUndeclaredExceptions(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ThrowerPrx proxy = ThrowerPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_supportsUndeclaredExceptions(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_supportsUndeclaredExceptions.
 */
template<class T, typename CT> Callback_Thrower_supportsUndeclaredExceptionsPtr
newCallback_Thrower_supportsUndeclaredExceptions(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_supportsUndeclaredExceptions<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_supportsUndeclaredExceptions.
 */
template<class T, typename CT> Callback_Thrower_supportsUndeclaredExceptionsPtr
newCallback_Thrower_supportsUndeclaredExceptions(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_supportsUndeclaredExceptions<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Thrower::begin_throwAasA.
 * Create a wrapper instance by calling ::Test::newCallback_Thrower_throwAasA.
 */
template<class T>
class CallbackNC_Thrower_throwAasA : public Callback_Thrower_throwAasA_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Thrower_throwAasA(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ThrowerPrx proxy = ThrowerPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_throwAasA(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwAasA.
 */
template<class T> Callback_Thrower_throwAasAPtr
newCallback_Thrower_throwAasA(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwAasA<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwAasA.
 */
template<class T> Callback_Thrower_throwAasAPtr
newCallback_Thrower_throwAasA(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwAasA<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwAasA.
 */
template<class T> Callback_Thrower_throwAasAPtr
newCallback_Thrower_throwAasA(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwAasA<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwAasA.
 */
template<class T> Callback_Thrower_throwAasAPtr
newCallback_Thrower_throwAasA(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwAasA<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Thrower::begin_throwAasA.
 * Create a wrapper instance by calling ::Test::newCallback_Thrower_throwAasA.
 */
template<class T, typename CT>
class Callback_Thrower_throwAasA : public Callback_Thrower_throwAasA_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Thrower_throwAasA(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ThrowerPrx proxy = ThrowerPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_throwAasA(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwAasA.
 */
template<class T, typename CT> Callback_Thrower_throwAasAPtr
newCallback_Thrower_throwAasA(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwAasA<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwAasA.
 */
template<class T, typename CT> Callback_Thrower_throwAasAPtr
newCallback_Thrower_throwAasA(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwAasA<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwAasA.
 */
template<class T, typename CT> Callback_Thrower_throwAasAPtr
newCallback_Thrower_throwAasA(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwAasA<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwAasA.
 */
template<class T, typename CT> Callback_Thrower_throwAasAPtr
newCallback_Thrower_throwAasA(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwAasA<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Thrower::begin_throwAorDasAorD.
 * Create a wrapper instance by calling ::Test::newCallback_Thrower_throwAorDasAorD.
 */
template<class T>
class CallbackNC_Thrower_throwAorDasAorD : public Callback_Thrower_throwAorDasAorD_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Thrower_throwAorDasAorD(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ThrowerPrx proxy = ThrowerPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_throwAorDasAorD(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwAorDasAorD.
 */
template<class T> Callback_Thrower_throwAorDasAorDPtr
newCallback_Thrower_throwAorDasAorD(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwAorDasAorD<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwAorDasAorD.
 */
template<class T> Callback_Thrower_throwAorDasAorDPtr
newCallback_Thrower_throwAorDasAorD(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwAorDasAorD<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwAorDasAorD.
 */
template<class T> Callback_Thrower_throwAorDasAorDPtr
newCallback_Thrower_throwAorDasAorD(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwAorDasAorD<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwAorDasAorD.
 */
template<class T> Callback_Thrower_throwAorDasAorDPtr
newCallback_Thrower_throwAorDasAorD(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwAorDasAorD<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Thrower::begin_throwAorDasAorD.
 * Create a wrapper instance by calling ::Test::newCallback_Thrower_throwAorDasAorD.
 */
template<class T, typename CT>
class Callback_Thrower_throwAorDasAorD : public Callback_Thrower_throwAorDasAorD_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Thrower_throwAorDasAorD(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ThrowerPrx proxy = ThrowerPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_throwAorDasAorD(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwAorDasAorD.
 */
template<class T, typename CT> Callback_Thrower_throwAorDasAorDPtr
newCallback_Thrower_throwAorDasAorD(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwAorDasAorD<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwAorDasAorD.
 */
template<class T, typename CT> Callback_Thrower_throwAorDasAorDPtr
newCallback_Thrower_throwAorDasAorD(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwAorDasAorD<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwAorDasAorD.
 */
template<class T, typename CT> Callback_Thrower_throwAorDasAorDPtr
newCallback_Thrower_throwAorDasAorD(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwAorDasAorD<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwAorDasAorD.
 */
template<class T, typename CT> Callback_Thrower_throwAorDasAorDPtr
newCallback_Thrower_throwAorDasAorD(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwAorDasAorD<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Thrower::begin_throwBasA.
 * Create a wrapper instance by calling ::Test::newCallback_Thrower_throwBasA.
 */
template<class T>
class CallbackNC_Thrower_throwBasA : public Callback_Thrower_throwBasA_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Thrower_throwBasA(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ThrowerPrx proxy = ThrowerPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_throwBasA(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwBasA.
 */
template<class T> Callback_Thrower_throwBasAPtr
newCallback_Thrower_throwBasA(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwBasA<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwBasA.
 */
template<class T> Callback_Thrower_throwBasAPtr
newCallback_Thrower_throwBasA(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwBasA<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwBasA.
 */
template<class T> Callback_Thrower_throwBasAPtr
newCallback_Thrower_throwBasA(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwBasA<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwBasA.
 */
template<class T> Callback_Thrower_throwBasAPtr
newCallback_Thrower_throwBasA(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwBasA<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Thrower::begin_throwBasA.
 * Create a wrapper instance by calling ::Test::newCallback_Thrower_throwBasA.
 */
template<class T, typename CT>
class Callback_Thrower_throwBasA : public Callback_Thrower_throwBasA_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Thrower_throwBasA(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ThrowerPrx proxy = ThrowerPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_throwBasA(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwBasA.
 */
template<class T, typename CT> Callback_Thrower_throwBasAPtr
newCallback_Thrower_throwBasA(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwBasA<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwBasA.
 */
template<class T, typename CT> Callback_Thrower_throwBasAPtr
newCallback_Thrower_throwBasA(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwBasA<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwBasA.
 */
template<class T, typename CT> Callback_Thrower_throwBasAPtr
newCallback_Thrower_throwBasA(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwBasA<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwBasA.
 */
template<class T, typename CT> Callback_Thrower_throwBasAPtr
newCallback_Thrower_throwBasA(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwBasA<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Thrower::begin_throwCasA.
 * Create a wrapper instance by calling ::Test::newCallback_Thrower_throwCasA.
 */
template<class T>
class CallbackNC_Thrower_throwCasA : public Callback_Thrower_throwCasA_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Thrower_throwCasA(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ThrowerPrx proxy = ThrowerPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_throwCasA(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwCasA.
 */
template<class T> Callback_Thrower_throwCasAPtr
newCallback_Thrower_throwCasA(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwCasA<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwCasA.
 */
template<class T> Callback_Thrower_throwCasAPtr
newCallback_Thrower_throwCasA(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwCasA<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwCasA.
 */
template<class T> Callback_Thrower_throwCasAPtr
newCallback_Thrower_throwCasA(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwCasA<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwCasA.
 */
template<class T> Callback_Thrower_throwCasAPtr
newCallback_Thrower_throwCasA(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwCasA<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Thrower::begin_throwCasA.
 * Create a wrapper instance by calling ::Test::newCallback_Thrower_throwCasA.
 */
template<class T, typename CT>
class Callback_Thrower_throwCasA : public Callback_Thrower_throwCasA_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Thrower_throwCasA(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ThrowerPrx proxy = ThrowerPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_throwCasA(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwCasA.
 */
template<class T, typename CT> Callback_Thrower_throwCasAPtr
newCallback_Thrower_throwCasA(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwCasA<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwCasA.
 */
template<class T, typename CT> Callback_Thrower_throwCasAPtr
newCallback_Thrower_throwCasA(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwCasA<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwCasA.
 */
template<class T, typename CT> Callback_Thrower_throwCasAPtr
newCallback_Thrower_throwCasA(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwCasA<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwCasA.
 */
template<class T, typename CT> Callback_Thrower_throwCasAPtr
newCallback_Thrower_throwCasA(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwCasA<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Thrower::begin_throwBasB.
 * Create a wrapper instance by calling ::Test::newCallback_Thrower_throwBasB.
 */
template<class T>
class CallbackNC_Thrower_throwBasB : public Callback_Thrower_throwBasB_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Thrower_throwBasB(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ThrowerPrx proxy = ThrowerPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_throwBasB(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwBasB.
 */
template<class T> Callback_Thrower_throwBasBPtr
newCallback_Thrower_throwBasB(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwBasB<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwBasB.
 */
template<class T> Callback_Thrower_throwBasBPtr
newCallback_Thrower_throwBasB(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwBasB<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwBasB.
 */
template<class T> Callback_Thrower_throwBasBPtr
newCallback_Thrower_throwBasB(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwBasB<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwBasB.
 */
template<class T> Callback_Thrower_throwBasBPtr
newCallback_Thrower_throwBasB(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwBasB<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Thrower::begin_throwBasB.
 * Create a wrapper instance by calling ::Test::newCallback_Thrower_throwBasB.
 */
template<class T, typename CT>
class Callback_Thrower_throwBasB : public Callback_Thrower_throwBasB_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Thrower_throwBasB(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ThrowerPrx proxy = ThrowerPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_throwBasB(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwBasB.
 */
template<class T, typename CT> Callback_Thrower_throwBasBPtr
newCallback_Thrower_throwBasB(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwBasB<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwBasB.
 */
template<class T, typename CT> Callback_Thrower_throwBasBPtr
newCallback_Thrower_throwBasB(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwBasB<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwBasB.
 */
template<class T, typename CT> Callback_Thrower_throwBasBPtr
newCallback_Thrower_throwBasB(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwBasB<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwBasB.
 */
template<class T, typename CT> Callback_Thrower_throwBasBPtr
newCallback_Thrower_throwBasB(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwBasB<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Thrower::begin_throwCasB.
 * Create a wrapper instance by calling ::Test::newCallback_Thrower_throwCasB.
 */
template<class T>
class CallbackNC_Thrower_throwCasB : public Callback_Thrower_throwCasB_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Thrower_throwCasB(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ThrowerPrx proxy = ThrowerPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_throwCasB(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwCasB.
 */
template<class T> Callback_Thrower_throwCasBPtr
newCallback_Thrower_throwCasB(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwCasB<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwCasB.
 */
template<class T> Callback_Thrower_throwCasBPtr
newCallback_Thrower_throwCasB(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwCasB<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwCasB.
 */
template<class T> Callback_Thrower_throwCasBPtr
newCallback_Thrower_throwCasB(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwCasB<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwCasB.
 */
template<class T> Callback_Thrower_throwCasBPtr
newCallback_Thrower_throwCasB(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwCasB<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Thrower::begin_throwCasB.
 * Create a wrapper instance by calling ::Test::newCallback_Thrower_throwCasB.
 */
template<class T, typename CT>
class Callback_Thrower_throwCasB : public Callback_Thrower_throwCasB_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Thrower_throwCasB(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ThrowerPrx proxy = ThrowerPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_throwCasB(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwCasB.
 */
template<class T, typename CT> Callback_Thrower_throwCasBPtr
newCallback_Thrower_throwCasB(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwCasB<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwCasB.
 */
template<class T, typename CT> Callback_Thrower_throwCasBPtr
newCallback_Thrower_throwCasB(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwCasB<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwCasB.
 */
template<class T, typename CT> Callback_Thrower_throwCasBPtr
newCallback_Thrower_throwCasB(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwCasB<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwCasB.
 */
template<class T, typename CT> Callback_Thrower_throwCasBPtr
newCallback_Thrower_throwCasB(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwCasB<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Thrower::begin_throwCasC.
 * Create a wrapper instance by calling ::Test::newCallback_Thrower_throwCasC.
 */
template<class T>
class CallbackNC_Thrower_throwCasC : public Callback_Thrower_throwCasC_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Thrower_throwCasC(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ThrowerPrx proxy = ThrowerPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_throwCasC(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwCasC.
 */
template<class T> Callback_Thrower_throwCasCPtr
newCallback_Thrower_throwCasC(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwCasC<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwCasC.
 */
template<class T> Callback_Thrower_throwCasCPtr
newCallback_Thrower_throwCasC(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwCasC<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwCasC.
 */
template<class T> Callback_Thrower_throwCasCPtr
newCallback_Thrower_throwCasC(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwCasC<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwCasC.
 */
template<class T> Callback_Thrower_throwCasCPtr
newCallback_Thrower_throwCasC(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwCasC<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Thrower::begin_throwCasC.
 * Create a wrapper instance by calling ::Test::newCallback_Thrower_throwCasC.
 */
template<class T, typename CT>
class Callback_Thrower_throwCasC : public Callback_Thrower_throwCasC_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Thrower_throwCasC(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ThrowerPrx proxy = ThrowerPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_throwCasC(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwCasC.
 */
template<class T, typename CT> Callback_Thrower_throwCasCPtr
newCallback_Thrower_throwCasC(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwCasC<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwCasC.
 */
template<class T, typename CT> Callback_Thrower_throwCasCPtr
newCallback_Thrower_throwCasC(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwCasC<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwCasC.
 */
template<class T, typename CT> Callback_Thrower_throwCasCPtr
newCallback_Thrower_throwCasC(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwCasC<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwCasC.
 */
template<class T, typename CT> Callback_Thrower_throwCasCPtr
newCallback_Thrower_throwCasC(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwCasC<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Thrower::begin_throwUndeclaredA.
 * Create a wrapper instance by calling ::Test::newCallback_Thrower_throwUndeclaredA.
 */
template<class T>
class CallbackNC_Thrower_throwUndeclaredA : public Callback_Thrower_throwUndeclaredA_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Thrower_throwUndeclaredA(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwUndeclaredA.
 */
template<class T> Callback_Thrower_throwUndeclaredAPtr
newCallback_Thrower_throwUndeclaredA(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwUndeclaredA<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwUndeclaredA.
 */
template<class T> Callback_Thrower_throwUndeclaredAPtr
newCallback_Thrower_throwUndeclaredA(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwUndeclaredA<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwUndeclaredA.
 */
template<class T> Callback_Thrower_throwUndeclaredAPtr
newCallback_Thrower_throwUndeclaredA(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwUndeclaredA<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwUndeclaredA.
 */
template<class T> Callback_Thrower_throwUndeclaredAPtr
newCallback_Thrower_throwUndeclaredA(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwUndeclaredA<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Thrower::begin_throwUndeclaredA.
 * Create a wrapper instance by calling ::Test::newCallback_Thrower_throwUndeclaredA.
 */
template<class T, typename CT>
class Callback_Thrower_throwUndeclaredA : public Callback_Thrower_throwUndeclaredA_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Thrower_throwUndeclaredA(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwUndeclaredA.
 */
template<class T, typename CT> Callback_Thrower_throwUndeclaredAPtr
newCallback_Thrower_throwUndeclaredA(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwUndeclaredA<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwUndeclaredA.
 */
template<class T, typename CT> Callback_Thrower_throwUndeclaredAPtr
newCallback_Thrower_throwUndeclaredA(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwUndeclaredA<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwUndeclaredA.
 */
template<class T, typename CT> Callback_Thrower_throwUndeclaredAPtr
newCallback_Thrower_throwUndeclaredA(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwUndeclaredA<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwUndeclaredA.
 */
template<class T, typename CT> Callback_Thrower_throwUndeclaredAPtr
newCallback_Thrower_throwUndeclaredA(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwUndeclaredA<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Thrower::begin_throwUndeclaredB.
 * Create a wrapper instance by calling ::Test::newCallback_Thrower_throwUndeclaredB.
 */
template<class T>
class CallbackNC_Thrower_throwUndeclaredB : public Callback_Thrower_throwUndeclaredB_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Thrower_throwUndeclaredB(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwUndeclaredB.
 */
template<class T> Callback_Thrower_throwUndeclaredBPtr
newCallback_Thrower_throwUndeclaredB(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwUndeclaredB<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwUndeclaredB.
 */
template<class T> Callback_Thrower_throwUndeclaredBPtr
newCallback_Thrower_throwUndeclaredB(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwUndeclaredB<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwUndeclaredB.
 */
template<class T> Callback_Thrower_throwUndeclaredBPtr
newCallback_Thrower_throwUndeclaredB(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwUndeclaredB<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwUndeclaredB.
 */
template<class T> Callback_Thrower_throwUndeclaredBPtr
newCallback_Thrower_throwUndeclaredB(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwUndeclaredB<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Thrower::begin_throwUndeclaredB.
 * Create a wrapper instance by calling ::Test::newCallback_Thrower_throwUndeclaredB.
 */
template<class T, typename CT>
class Callback_Thrower_throwUndeclaredB : public Callback_Thrower_throwUndeclaredB_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Thrower_throwUndeclaredB(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwUndeclaredB.
 */
template<class T, typename CT> Callback_Thrower_throwUndeclaredBPtr
newCallback_Thrower_throwUndeclaredB(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwUndeclaredB<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwUndeclaredB.
 */
template<class T, typename CT> Callback_Thrower_throwUndeclaredBPtr
newCallback_Thrower_throwUndeclaredB(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwUndeclaredB<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwUndeclaredB.
 */
template<class T, typename CT> Callback_Thrower_throwUndeclaredBPtr
newCallback_Thrower_throwUndeclaredB(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwUndeclaredB<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwUndeclaredB.
 */
template<class T, typename CT> Callback_Thrower_throwUndeclaredBPtr
newCallback_Thrower_throwUndeclaredB(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwUndeclaredB<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Thrower::begin_throwUndeclaredC.
 * Create a wrapper instance by calling ::Test::newCallback_Thrower_throwUndeclaredC.
 */
template<class T>
class CallbackNC_Thrower_throwUndeclaredC : public Callback_Thrower_throwUndeclaredC_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Thrower_throwUndeclaredC(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwUndeclaredC.
 */
template<class T> Callback_Thrower_throwUndeclaredCPtr
newCallback_Thrower_throwUndeclaredC(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwUndeclaredC<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwUndeclaredC.
 */
template<class T> Callback_Thrower_throwUndeclaredCPtr
newCallback_Thrower_throwUndeclaredC(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwUndeclaredC<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwUndeclaredC.
 */
template<class T> Callback_Thrower_throwUndeclaredCPtr
newCallback_Thrower_throwUndeclaredC(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwUndeclaredC<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwUndeclaredC.
 */
template<class T> Callback_Thrower_throwUndeclaredCPtr
newCallback_Thrower_throwUndeclaredC(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwUndeclaredC<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Thrower::begin_throwUndeclaredC.
 * Create a wrapper instance by calling ::Test::newCallback_Thrower_throwUndeclaredC.
 */
template<class T, typename CT>
class Callback_Thrower_throwUndeclaredC : public Callback_Thrower_throwUndeclaredC_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Thrower_throwUndeclaredC(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwUndeclaredC.
 */
template<class T, typename CT> Callback_Thrower_throwUndeclaredCPtr
newCallback_Thrower_throwUndeclaredC(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwUndeclaredC<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwUndeclaredC.
 */
template<class T, typename CT> Callback_Thrower_throwUndeclaredCPtr
newCallback_Thrower_throwUndeclaredC(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwUndeclaredC<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwUndeclaredC.
 */
template<class T, typename CT> Callback_Thrower_throwUndeclaredCPtr
newCallback_Thrower_throwUndeclaredC(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwUndeclaredC<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwUndeclaredC.
 */
template<class T, typename CT> Callback_Thrower_throwUndeclaredCPtr
newCallback_Thrower_throwUndeclaredC(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwUndeclaredC<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Thrower::begin_throwLocalException.
 * Create a wrapper instance by calling ::Test::newCallback_Thrower_throwLocalException.
 */
template<class T>
class CallbackNC_Thrower_throwLocalException : public Callback_Thrower_throwLocalException_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Thrower_throwLocalException(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwLocalException.
 */
template<class T> Callback_Thrower_throwLocalExceptionPtr
newCallback_Thrower_throwLocalException(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwLocalException<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwLocalException.
 */
template<class T> Callback_Thrower_throwLocalExceptionPtr
newCallback_Thrower_throwLocalException(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwLocalException<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwLocalException.
 */
template<class T> Callback_Thrower_throwLocalExceptionPtr
newCallback_Thrower_throwLocalException(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwLocalException<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwLocalException.
 */
template<class T> Callback_Thrower_throwLocalExceptionPtr
newCallback_Thrower_throwLocalException(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwLocalException<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Thrower::begin_throwLocalException.
 * Create a wrapper instance by calling ::Test::newCallback_Thrower_throwLocalException.
 */
template<class T, typename CT>
class Callback_Thrower_throwLocalException : public Callback_Thrower_throwLocalException_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Thrower_throwLocalException(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwLocalException.
 */
template<class T, typename CT> Callback_Thrower_throwLocalExceptionPtr
newCallback_Thrower_throwLocalException(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwLocalException<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwLocalException.
 */
template<class T, typename CT> Callback_Thrower_throwLocalExceptionPtr
newCallback_Thrower_throwLocalException(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwLocalException<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwLocalException.
 */
template<class T, typename CT> Callback_Thrower_throwLocalExceptionPtr
newCallback_Thrower_throwLocalException(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwLocalException<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwLocalException.
 */
template<class T, typename CT> Callback_Thrower_throwLocalExceptionPtr
newCallback_Thrower_throwLocalException(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwLocalException<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Thrower::begin_throwNonIceException.
 * Create a wrapper instance by calling ::Test::newCallback_Thrower_throwNonIceException.
 */
template<class T>
class CallbackNC_Thrower_throwNonIceException : public Callback_Thrower_throwNonIceException_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Thrower_throwNonIceException(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwNonIceException.
 */
template<class T> Callback_Thrower_throwNonIceExceptionPtr
newCallback_Thrower_throwNonIceException(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwNonIceException<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwNonIceException.
 */
template<class T> Callback_Thrower_throwNonIceExceptionPtr
newCallback_Thrower_throwNonIceException(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwNonIceException<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwNonIceException.
 */
template<class T> Callback_Thrower_throwNonIceExceptionPtr
newCallback_Thrower_throwNonIceException(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwNonIceException<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwNonIceException.
 */
template<class T> Callback_Thrower_throwNonIceExceptionPtr
newCallback_Thrower_throwNonIceException(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwNonIceException<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Thrower::begin_throwNonIceException.
 * Create a wrapper instance by calling ::Test::newCallback_Thrower_throwNonIceException.
 */
template<class T, typename CT>
class Callback_Thrower_throwNonIceException : public Callback_Thrower_throwNonIceException_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Thrower_throwNonIceException(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwNonIceException.
 */
template<class T, typename CT> Callback_Thrower_throwNonIceExceptionPtr
newCallback_Thrower_throwNonIceException(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwNonIceException<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwNonIceException.
 */
template<class T, typename CT> Callback_Thrower_throwNonIceExceptionPtr
newCallback_Thrower_throwNonIceException(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwNonIceException<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwNonIceException.
 */
template<class T, typename CT> Callback_Thrower_throwNonIceExceptionPtr
newCallback_Thrower_throwNonIceException(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwNonIceException<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwNonIceException.
 */
template<class T, typename CT> Callback_Thrower_throwNonIceExceptionPtr
newCallback_Thrower_throwNonIceException(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwNonIceException<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Thrower::begin_throwMemoryLimitException.
 * Create a wrapper instance by calling ::Test::newCallback_Thrower_throwMemoryLimitException.
 */
template<class T>
class CallbackNC_Thrower_throwMemoryLimitException : public Callback_Thrower_throwMemoryLimitException_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Ice::ByteSeq&);

    CallbackNC_Thrower_throwMemoryLimitException(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ThrowerPrx proxy = ThrowerPrx::uncheckedCast(result->getProxy());
        ::Ice::ByteSeq ret;
        try
        {
            ret = proxy->end_throwMemoryLimitException(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwMemoryLimitException.
 */
template<class T> Callback_Thrower_throwMemoryLimitExceptionPtr
newCallback_Thrower_throwMemoryLimitException(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Ice::ByteSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwMemoryLimitException<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwMemoryLimitException.
 */
template<class T> Callback_Thrower_throwMemoryLimitExceptionPtr
newCallback_Thrower_throwMemoryLimitException(T* instance, void (T::*cb)(const ::Ice::ByteSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwMemoryLimitException<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Thrower::begin_throwMemoryLimitException.
 * Create a wrapper instance by calling ::Test::newCallback_Thrower_throwMemoryLimitException.
 */
template<class T, typename CT>
class Callback_Thrower_throwMemoryLimitException : public Callback_Thrower_throwMemoryLimitException_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Ice::ByteSeq&, const CT&);

    Callback_Thrower_throwMemoryLimitException(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ThrowerPrx proxy = ThrowerPrx::uncheckedCast(result->getProxy());
        ::Ice::ByteSeq ret;
        try
        {
            ret = proxy->end_throwMemoryLimitException(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwMemoryLimitException.
 */
template<class T, typename CT> Callback_Thrower_throwMemoryLimitExceptionPtr
newCallback_Thrower_throwMemoryLimitException(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Ice::ByteSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwMemoryLimitException<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwMemoryLimitException.
 */
template<class T, typename CT> Callback_Thrower_throwMemoryLimitExceptionPtr
newCallback_Thrower_throwMemoryLimitException(T* instance, void (T::*cb)(const ::Ice::ByteSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwMemoryLimitException<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::Thrower::begin_throwLocalExceptionIdempotent.
 * Create a wrapper instance by calling ::Test::newCallback_Thrower_throwLocalExceptionIdempotent.
 */
template<class T>
class CallbackNC_Thrower_throwLocalExceptionIdempotent : public Callback_Thrower_throwLocalExceptionIdempotent_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Thrower_throwLocalExceptionIdempotent(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwLocalExceptionIdempotent.
 */
template<class T> Callback_Thrower_throwLocalExceptionIdempotentPtr
newCallback_Thrower_throwLocalExceptionIdempotent(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwLocalExceptionIdempotent<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwLocalExceptionIdempotent.
 */
template<class T> Callback_Thrower_throwLocalExceptionIdempotentPtr
newCallback_Thrower_throwLocalExceptionIdempotent(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwLocalExceptionIdempotent<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwLocalExceptionIdempotent.
 */
template<class T> Callback_Thrower_throwLocalExceptionIdempotentPtr
newCallback_Thrower_throwLocalExceptionIdempotent(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwLocalExceptionIdempotent<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwLocalExceptionIdempotent.
 */
template<class T> Callback_Thrower_throwLocalExceptionIdempotentPtr
newCallback_Thrower_throwLocalExceptionIdempotent(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Thrower_throwLocalExceptionIdempotent<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::Thrower::begin_throwLocalExceptionIdempotent.
 * Create a wrapper instance by calling ::Test::newCallback_Thrower_throwLocalExceptionIdempotent.
 */
template<class T, typename CT>
class Callback_Thrower_throwLocalExceptionIdempotent : public Callback_Thrower_throwLocalExceptionIdempotent_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Thrower_throwLocalExceptionIdempotent(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwLocalExceptionIdempotent.
 */
template<class T, typename CT> Callback_Thrower_throwLocalExceptionIdempotentPtr
newCallback_Thrower_throwLocalExceptionIdempotent(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwLocalExceptionIdempotent<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwLocalExceptionIdempotent.
 */
template<class T, typename CT> Callback_Thrower_throwLocalExceptionIdempotentPtr
newCallback_Thrower_throwLocalExceptionIdempotent(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwLocalExceptionIdempotent<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwLocalExceptionIdempotent.
 */
template<class T, typename CT> Callback_Thrower_throwLocalExceptionIdempotentPtr
newCallback_Thrower_throwLocalExceptionIdempotent(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwLocalExceptionIdempotent<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::Thrower::begin_throwLocalExceptionIdempotent.
 */
template<class T, typename CT> Callback_Thrower_throwLocalExceptionIdempotentPtr
newCallback_Thrower_throwLocalExceptionIdempotent(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Thrower_throwLocalExceptionIdempotent<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::WrongOperation::begin_noSuchOperation.
 * Create a wrapper instance by calling ::Test::newCallback_WrongOperation_noSuchOperation.
 */
template<class T>
class CallbackNC_WrongOperation_noSuchOperation : public Callback_WrongOperation_noSuchOperation_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_WrongOperation_noSuchOperation(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::WrongOperation::begin_noSuchOperation.
 */
template<class T> Callback_WrongOperation_noSuchOperationPtr
newCallback_WrongOperation_noSuchOperation(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_WrongOperation_noSuchOperation<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::WrongOperation::begin_noSuchOperation.
 */
template<class T> Callback_WrongOperation_noSuchOperationPtr
newCallback_WrongOperation_noSuchOperation(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_WrongOperation_noSuchOperation<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::WrongOperation::begin_noSuchOperation.
 */
template<class T> Callback_WrongOperation_noSuchOperationPtr
newCallback_WrongOperation_noSuchOperation(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_WrongOperation_noSuchOperation<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::WrongOperation::begin_noSuchOperation.
 */
template<class T> Callback_WrongOperation_noSuchOperationPtr
newCallback_WrongOperation_noSuchOperation(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_WrongOperation_noSuchOperation<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::WrongOperation::begin_noSuchOperation.
 * Create a wrapper instance by calling ::Test::newCallback_WrongOperation_noSuchOperation.
 */
template<class T, typename CT>
class Callback_WrongOperation_noSuchOperation : public Callback_WrongOperation_noSuchOperation_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_WrongOperation_noSuchOperation(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::WrongOperation::begin_noSuchOperation.
 */
template<class T, typename CT> Callback_WrongOperation_noSuchOperationPtr
newCallback_WrongOperation_noSuchOperation(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_WrongOperation_noSuchOperation<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::WrongOperation::begin_noSuchOperation.
 */
template<class T, typename CT> Callback_WrongOperation_noSuchOperationPtr
newCallback_WrongOperation_noSuchOperation(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_WrongOperation_noSuchOperation<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::WrongOperation::begin_noSuchOperation.
 */
template<class T, typename CT> Callback_WrongOperation_noSuchOperationPtr
newCallback_WrongOperation_noSuchOperation(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_WrongOperation_noSuchOperation<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::WrongOperation::begin_noSuchOperation.
 */
template<class T, typename CT> Callback_WrongOperation_noSuchOperationPtr
newCallback_WrongOperation_noSuchOperation(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_WrongOperation_noSuchOperation<T, CT>(instance, 0, excb, sentcb);
}

}

#endif

#include <IceUtil/PopDisableWarnings.h>
#endif
