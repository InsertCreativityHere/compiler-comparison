//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.8.0-alpha.0
//
// <auto-generated>
//
// Generated from file `Test.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#define ICE_BUILDING_GENERATED_CODE
#include <Test.h>
#include <Ice/OutgoingAsync.h>

#if defined(_MSC_VER)
#   pragma warning(disable:4458) // declaration of ... hides class member
#elif defined(__clang__)
#   pragma clang diagnostic ignored "-Wshadow"
#elif defined(__GNUC__)
#   pragma GCC diagnostic ignored "-Wshadow"
#endif

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION  != 30850
#       error Ice version mismatch: an exact match is required for beta generated code
#   endif
#endif

namespace
{

const ::IceInternal::DefaultValueFactoryInit<::Test::SBase> iceC_Test_SBase_init("::Test::SBase");

const ::IceInternal::DefaultValueFactoryInit<::Test::SBSKnownDerived> iceC_Test_SBSKnownDerived_init("::Test::SBSKnownDerived");

const ::IceInternal::DefaultValueFactoryInit<::Test::B> iceC_Test_B_init("::Test::B");

const ::IceInternal::DefaultValueFactoryInit<::Test::D1> iceC_Test_D1_init("::Test::D1");

const ::IceInternal::DefaultValueFactoryInit<::Test::SS1> iceC_Test_SS1_init("::Test::SS1");

const ::IceInternal::DefaultValueFactoryInit<::Test::SS2> iceC_Test_SS2_init("::Test::SS2");

const ::IceInternal::DefaultUserExceptionFactoryInit<::Test::BaseException> iceC_Test_BaseException_init("::Test::BaseException");

const ::IceInternal::DefaultUserExceptionFactoryInit<::Test::DerivedException> iceC_Test_DerivedException_init("::Test::DerivedException");

const ::IceInternal::DefaultValueFactoryInit<::Test::PBase> iceC_Test_PBase_init("::Test::PBase");

const ::IceInternal::DefaultValueFactoryInit<::Test::Preserved> iceC_Test_Preserved_init("::Test::Preserved");

const ::IceInternal::DefaultValueFactoryInit<::Test::PDerived> iceC_Test_PDerived_init("::Test::PDerived");

const ::IceInternal::DefaultValueFactoryInit<::Test::CompactPDerived> iceC_Test_CompactPDerived_init("::Test::CompactPDerived");
const ::IceInternal::CompactIdInit iceC_Test_CompactPDerived_compactIdInit ("::Test::CompactPDerived", 56);

const ::IceInternal::DefaultValueFactoryInit<::Test::PNode> iceC_Test_PNode_init("::Test::PNode");

const ::IceInternal::DefaultUserExceptionFactoryInit<::Test::PreservedException> iceC_Test_PreservedException_init("::Test::PreservedException");

const ::IceInternal::DefaultValueFactoryInit<::Test::Hidden> iceC_Test_Hidden_init("::Test::Hidden");

const ::IceInternal::DefaultValueFactoryInit<::Test::Forward> iceC_Test_Forward_init("::Test::Forward");

}

::std::shared_ptr<::Ice::Value>
Test::TestIntfPrx::SBaseAsObject(const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::shared_ptr<::Ice::Value>>(true, this, &TestIntfPrx::_iceI_SBaseAsObject, context).get();
}

::std::future<::std::shared_ptr<::Ice::Value>>
Test::TestIntfPrx::SBaseAsObjectAsync(const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::shared_ptr<::Ice::Value>>(false, this, &TestIntfPrx::_iceI_SBaseAsObject, context);
}

::std::function<void()>
Test::TestIntfPrx::SBaseAsObjectAsync(::std::function<void (::std::shared_ptr<::Ice::Value>)> response,
                                      ::std::function<void(::std::exception_ptr)> ex,
                                      ::std::function<void(bool)> sent,
                                      const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<::std::shared_ptr<::Ice::Value>>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_SBaseAsObject, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_SBaseAsObject(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Ice::Value>>>& outAsync, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "SBaseAsObject";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        nullptr,
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::shared_ptr<::Ice::Value> ret;
            istr->readAll(ret);
            istr->readPendingValues();
            return ret;
        });
}
/// \endcond

::std::shared_ptr<::Test::SBase>
Test::TestIntfPrx::SBaseAsSBase(const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::shared_ptr<SBase>>(true, this, &TestIntfPrx::_iceI_SBaseAsSBase, context).get();
}

::std::future<::std::shared_ptr<::Test::SBase>>
Test::TestIntfPrx::SBaseAsSBaseAsync(const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::shared_ptr<SBase>>(false, this, &TestIntfPrx::_iceI_SBaseAsSBase, context);
}

::std::function<void()>
Test::TestIntfPrx::SBaseAsSBaseAsync(::std::function<void (::std::shared_ptr<::Test::SBase>)> response,
                                     ::std::function<void(::std::exception_ptr)> ex,
                                     ::std::function<void(bool)> sent,
                                     const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<::std::shared_ptr<SBase>>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_SBaseAsSBase, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_SBaseAsSBase(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<SBase>>>& outAsync, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "SBaseAsSBase";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        nullptr,
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::shared_ptr<SBase> ret;
            istr->readAll(ret);
            istr->readPendingValues();
            return ret;
        });
}
/// \endcond

::std::shared_ptr<::Test::SBase>
Test::TestIntfPrx::SBSKnownDerivedAsSBase(const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::shared_ptr<SBase>>(true, this, &TestIntfPrx::_iceI_SBSKnownDerivedAsSBase, context).get();
}

::std::future<::std::shared_ptr<::Test::SBase>>
Test::TestIntfPrx::SBSKnownDerivedAsSBaseAsync(const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::shared_ptr<SBase>>(false, this, &TestIntfPrx::_iceI_SBSKnownDerivedAsSBase, context);
}

::std::function<void()>
Test::TestIntfPrx::SBSKnownDerivedAsSBaseAsync(::std::function<void (::std::shared_ptr<::Test::SBase>)> response,
                                               ::std::function<void(::std::exception_ptr)> ex,
                                               ::std::function<void(bool)> sent,
                                               const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<::std::shared_ptr<SBase>>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_SBSKnownDerivedAsSBase, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_SBSKnownDerivedAsSBase(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<SBase>>>& outAsync, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "SBSKnownDerivedAsSBase";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        nullptr,
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::shared_ptr<SBase> ret;
            istr->readAll(ret);
            istr->readPendingValues();
            return ret;
        });
}
/// \endcond

::std::shared_ptr<::Test::SBSKnownDerived>
Test::TestIntfPrx::SBSKnownDerivedAsSBSKnownDerived(const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::shared_ptr<SBSKnownDerived>>(true, this, &TestIntfPrx::_iceI_SBSKnownDerivedAsSBSKnownDerived, context).get();
}

::std::future<::std::shared_ptr<::Test::SBSKnownDerived>>
Test::TestIntfPrx::SBSKnownDerivedAsSBSKnownDerivedAsync(const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::shared_ptr<SBSKnownDerived>>(false, this, &TestIntfPrx::_iceI_SBSKnownDerivedAsSBSKnownDerived, context);
}

::std::function<void()>
Test::TestIntfPrx::SBSKnownDerivedAsSBSKnownDerivedAsync(::std::function<void (::std::shared_ptr<::Test::SBSKnownDerived>)> response,
                                                         ::std::function<void(::std::exception_ptr)> ex,
                                                         ::std::function<void(bool)> sent,
                                                         const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<::std::shared_ptr<SBSKnownDerived>>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_SBSKnownDerivedAsSBSKnownDerived, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_SBSKnownDerivedAsSBSKnownDerived(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<SBSKnownDerived>>>& outAsync, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "SBSKnownDerivedAsSBSKnownDerived";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        nullptr,
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::shared_ptr<SBSKnownDerived> ret;
            istr->readAll(ret);
            istr->readPendingValues();
            return ret;
        });
}
/// \endcond

::std::shared_ptr<::Test::SBase>
Test::TestIntfPrx::SBSUnknownDerivedAsSBase(const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::shared_ptr<SBase>>(true, this, &TestIntfPrx::_iceI_SBSUnknownDerivedAsSBase, context).get();
}

::std::future<::std::shared_ptr<::Test::SBase>>
Test::TestIntfPrx::SBSUnknownDerivedAsSBaseAsync(const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::shared_ptr<SBase>>(false, this, &TestIntfPrx::_iceI_SBSUnknownDerivedAsSBase, context);
}

::std::function<void()>
Test::TestIntfPrx::SBSUnknownDerivedAsSBaseAsync(::std::function<void (::std::shared_ptr<::Test::SBase>)> response,
                                                 ::std::function<void(::std::exception_ptr)> ex,
                                                 ::std::function<void(bool)> sent,
                                                 const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<::std::shared_ptr<SBase>>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_SBSUnknownDerivedAsSBase, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_SBSUnknownDerivedAsSBase(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<SBase>>>& outAsync, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "SBSUnknownDerivedAsSBase";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        nullptr,
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::shared_ptr<SBase> ret;
            istr->readAll(ret);
            istr->readPendingValues();
            return ret;
        });
}
/// \endcond

::std::shared_ptr<::Test::SBase>
Test::TestIntfPrx::SBSUnknownDerivedAsSBaseCompact(const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::shared_ptr<SBase>>(true, this, &TestIntfPrx::_iceI_SBSUnknownDerivedAsSBaseCompact, context).get();
}

::std::future<::std::shared_ptr<::Test::SBase>>
Test::TestIntfPrx::SBSUnknownDerivedAsSBaseCompactAsync(const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::shared_ptr<SBase>>(false, this, &TestIntfPrx::_iceI_SBSUnknownDerivedAsSBaseCompact, context);
}

::std::function<void()>
Test::TestIntfPrx::SBSUnknownDerivedAsSBaseCompactAsync(::std::function<void (::std::shared_ptr<::Test::SBase>)> response,
                                                        ::std::function<void(::std::exception_ptr)> ex,
                                                        ::std::function<void(bool)> sent,
                                                        const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<::std::shared_ptr<SBase>>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_SBSUnknownDerivedAsSBaseCompact, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_SBSUnknownDerivedAsSBaseCompact(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<SBase>>>& outAsync, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "SBSUnknownDerivedAsSBaseCompact";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::CompactFormat, context,
        nullptr,
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::shared_ptr<SBase> ret;
            istr->readAll(ret);
            istr->readPendingValues();
            return ret;
        });
}
/// \endcond

::std::shared_ptr<::Ice::Value>
Test::TestIntfPrx::SUnknownAsObject(const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::shared_ptr<::Ice::Value>>(true, this, &TestIntfPrx::_iceI_SUnknownAsObject, context).get();
}

::std::future<::std::shared_ptr<::Ice::Value>>
Test::TestIntfPrx::SUnknownAsObjectAsync(const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::shared_ptr<::Ice::Value>>(false, this, &TestIntfPrx::_iceI_SUnknownAsObject, context);
}

::std::function<void()>
Test::TestIntfPrx::SUnknownAsObjectAsync(::std::function<void (::std::shared_ptr<::Ice::Value>)> response,
                                         ::std::function<void(::std::exception_ptr)> ex,
                                         ::std::function<void(bool)> sent,
                                         const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<::std::shared_ptr<::Ice::Value>>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_SUnknownAsObject, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_SUnknownAsObject(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Ice::Value>>>& outAsync, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "SUnknownAsObject";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        nullptr,
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::shared_ptr<::Ice::Value> ret;
            istr->readAll(ret);
            istr->readPendingValues();
            return ret;
        });
}
/// \endcond

void
Test::TestIntfPrx::checkSUnknown(const ::std::shared_ptr<::Ice::Value>& iceP_o, const ::Ice::Context& context) const
{
    ::IceInternal::makePromiseOutgoing<void>(true, this, &TestIntfPrx::_iceI_checkSUnknown, iceP_o, context).get();
}

::std::future<void>
Test::TestIntfPrx::checkSUnknownAsync(const ::std::shared_ptr<::Ice::Value>& iceP_o, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<void>(false, this, &TestIntfPrx::_iceI_checkSUnknown, iceP_o, context);
}

::std::function<void()>
Test::TestIntfPrx::checkSUnknownAsync(const ::std::shared_ptr<::Ice::Value>& iceP_o,
                                      ::std::function<void ()> response,
                                      ::std::function<void(::std::exception_ptr)> ex,
                                      ::std::function<void(bool)> sent,
                                      const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_checkSUnknown, iceP_o, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_checkSUnknown(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::shared_ptr<::Ice::Value>& iceP_o, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "checkSUnknown";

    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_o);
            ostr->writePendingValues();
        },
        nullptr);
}
/// \endcond

::std::shared_ptr<::Test::B>
Test::TestIntfPrx::oneElementCycle(const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::shared_ptr<B>>(true, this, &TestIntfPrx::_iceI_oneElementCycle, context).get();
}

::std::future<::std::shared_ptr<::Test::B>>
Test::TestIntfPrx::oneElementCycleAsync(const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::shared_ptr<B>>(false, this, &TestIntfPrx::_iceI_oneElementCycle, context);
}

::std::function<void()>
Test::TestIntfPrx::oneElementCycleAsync(::std::function<void (::std::shared_ptr<::Test::B>)> response,
                                        ::std::function<void(::std::exception_ptr)> ex,
                                        ::std::function<void(bool)> sent,
                                        const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<::std::shared_ptr<B>>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_oneElementCycle, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_oneElementCycle(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<B>>>& outAsync, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "oneElementCycle";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        nullptr,
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::shared_ptr<B> ret;
            istr->readAll(ret);
            istr->readPendingValues();
            return ret;
        });
}
/// \endcond

::std::shared_ptr<::Test::B>
Test::TestIntfPrx::twoElementCycle(const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::shared_ptr<B>>(true, this, &TestIntfPrx::_iceI_twoElementCycle, context).get();
}

::std::future<::std::shared_ptr<::Test::B>>
Test::TestIntfPrx::twoElementCycleAsync(const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::shared_ptr<B>>(false, this, &TestIntfPrx::_iceI_twoElementCycle, context);
}

::std::function<void()>
Test::TestIntfPrx::twoElementCycleAsync(::std::function<void (::std::shared_ptr<::Test::B>)> response,
                                        ::std::function<void(::std::exception_ptr)> ex,
                                        ::std::function<void(bool)> sent,
                                        const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<::std::shared_ptr<B>>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_twoElementCycle, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_twoElementCycle(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<B>>>& outAsync, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "twoElementCycle";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        nullptr,
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::shared_ptr<B> ret;
            istr->readAll(ret);
            istr->readPendingValues();
            return ret;
        });
}
/// \endcond

::std::shared_ptr<::Test::B>
Test::TestIntfPrx::D1AsB(const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::shared_ptr<B>>(true, this, &TestIntfPrx::_iceI_D1AsB, context).get();
}

::std::future<::std::shared_ptr<::Test::B>>
Test::TestIntfPrx::D1AsBAsync(const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::shared_ptr<B>>(false, this, &TestIntfPrx::_iceI_D1AsB, context);
}

::std::function<void()>
Test::TestIntfPrx::D1AsBAsync(::std::function<void (::std::shared_ptr<::Test::B>)> response,
                              ::std::function<void(::std::exception_ptr)> ex,
                              ::std::function<void(bool)> sent,
                              const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<::std::shared_ptr<B>>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_D1AsB, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_D1AsB(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<B>>>& outAsync, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "D1AsB";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        nullptr,
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::shared_ptr<B> ret;
            istr->readAll(ret);
            istr->readPendingValues();
            return ret;
        });
}
/// \endcond

::std::shared_ptr<::Test::D1>
Test::TestIntfPrx::D1AsD1(const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::shared_ptr<D1>>(true, this, &TestIntfPrx::_iceI_D1AsD1, context).get();
}

::std::future<::std::shared_ptr<::Test::D1>>
Test::TestIntfPrx::D1AsD1Async(const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::shared_ptr<D1>>(false, this, &TestIntfPrx::_iceI_D1AsD1, context);
}

::std::function<void()>
Test::TestIntfPrx::D1AsD1Async(::std::function<void (::std::shared_ptr<::Test::D1>)> response,
                               ::std::function<void(::std::exception_ptr)> ex,
                               ::std::function<void(bool)> sent,
                               const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<::std::shared_ptr<D1>>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_D1AsD1, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_D1AsD1(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<D1>>>& outAsync, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "D1AsD1";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        nullptr,
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::shared_ptr<D1> ret;
            istr->readAll(ret);
            istr->readPendingValues();
            return ret;
        });
}
/// \endcond

::std::shared_ptr<::Test::B>
Test::TestIntfPrx::D2AsB(const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::shared_ptr<B>>(true, this, &TestIntfPrx::_iceI_D2AsB, context).get();
}

::std::future<::std::shared_ptr<::Test::B>>
Test::TestIntfPrx::D2AsBAsync(const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::shared_ptr<B>>(false, this, &TestIntfPrx::_iceI_D2AsB, context);
}

::std::function<void()>
Test::TestIntfPrx::D2AsBAsync(::std::function<void (::std::shared_ptr<::Test::B>)> response,
                              ::std::function<void(::std::exception_ptr)> ex,
                              ::std::function<void(bool)> sent,
                              const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<::std::shared_ptr<B>>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_D2AsB, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_D2AsB(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<B>>>& outAsync, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "D2AsB";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        nullptr,
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::shared_ptr<B> ret;
            istr->readAll(ret);
            istr->readPendingValues();
            return ret;
        });
}
/// \endcond

void
Test::TestIntfPrx::paramTest1(::std::shared_ptr<B>& iceP_p1, ::std::shared_ptr<B>& iceP_p2, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<::std::shared_ptr<B>, ::std::shared_ptr<B>>>(true, this, &TestIntfPrx::_iceI_paramTest1, context).get();
    iceP_p1 = ::std::move(::std::get<0>(_result));
    iceP_p2 = ::std::move(::std::get<1>(_result));
}

::std::future<::std::tuple<::std::shared_ptr<::Test::B>, ::std::shared_ptr<::Test::B>>>
Test::TestIntfPrx::paramTest1Async(const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<::std::shared_ptr<B>, ::std::shared_ptr<B>>>(false, this, &TestIntfPrx::_iceI_paramTest1, context);
}

::std::function<void()>
Test::TestIntfPrx::paramTest1Async(::std::function<void (::std::shared_ptr<::Test::B>, ::std::shared_ptr<::Test::B>)> response,
                                   ::std::function<void(::std::exception_ptr)> ex,
                                   ::std::function<void(bool)> sent,
                                   const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<::std::shared_ptr<B>, ::std::shared_ptr<B>>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<::std::shared_ptr<B>, ::std::shared_ptr<B>>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_paramTest1, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_paramTest1(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::shared_ptr<B>, ::std::shared_ptr<B>>>>& outAsync, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "paramTest1";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        nullptr,
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<::std::shared_ptr<B>, ::std::shared_ptr<B>> v;
            istr->readAll(::std::get<0>(v), ::std::get<1>(v));
            istr->readPendingValues();
            return v;
        });
}
/// \endcond

void
Test::TestIntfPrx::paramTest2(::std::shared_ptr<B>& iceP_p2, ::std::shared_ptr<B>& iceP_p1, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<::std::shared_ptr<B>, ::std::shared_ptr<B>>>(true, this, &TestIntfPrx::_iceI_paramTest2, context).get();
    iceP_p2 = ::std::move(::std::get<0>(_result));
    iceP_p1 = ::std::move(::std::get<1>(_result));
}

::std::future<::std::tuple<::std::shared_ptr<::Test::B>, ::std::shared_ptr<::Test::B>>>
Test::TestIntfPrx::paramTest2Async(const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<::std::shared_ptr<B>, ::std::shared_ptr<B>>>(false, this, &TestIntfPrx::_iceI_paramTest2, context);
}

::std::function<void()>
Test::TestIntfPrx::paramTest2Async(::std::function<void (::std::shared_ptr<::Test::B>, ::std::shared_ptr<::Test::B>)> response,
                                   ::std::function<void(::std::exception_ptr)> ex,
                                   ::std::function<void(bool)> sent,
                                   const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<::std::shared_ptr<B>, ::std::shared_ptr<B>>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<::std::shared_ptr<B>, ::std::shared_ptr<B>>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_paramTest2, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_paramTest2(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::shared_ptr<B>, ::std::shared_ptr<B>>>>& outAsync, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "paramTest2";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        nullptr,
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<::std::shared_ptr<B>, ::std::shared_ptr<B>> v;
            istr->readAll(::std::get<0>(v), ::std::get<1>(v));
            istr->readPendingValues();
            return v;
        });
}
/// \endcond

::std::shared_ptr<::Test::B>
Test::TestIntfPrx::paramTest3(::std::shared_ptr<B>& iceP_p1, ::std::shared_ptr<B>& iceP_p2, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<::std::shared_ptr<B>, ::std::shared_ptr<B>, ::std::shared_ptr<B>>>(true, this, &TestIntfPrx::_iceI_paramTest3, context).get();
    iceP_p1 = ::std::move(::std::get<1>(_result));
    iceP_p2 = ::std::move(::std::get<2>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::std::shared_ptr<::Test::B>, ::std::shared_ptr<::Test::B>, ::std::shared_ptr<::Test::B>>>
Test::TestIntfPrx::paramTest3Async(const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<::std::shared_ptr<B>, ::std::shared_ptr<B>, ::std::shared_ptr<B>>>(false, this, &TestIntfPrx::_iceI_paramTest3, context);
}

::std::function<void()>
Test::TestIntfPrx::paramTest3Async(::std::function<void (::std::shared_ptr<::Test::B>, ::std::shared_ptr<::Test::B>, ::std::shared_ptr<::Test::B>)> response,
                                   ::std::function<void(::std::exception_ptr)> ex,
                                   ::std::function<void(bool)> sent,
                                   const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<::std::shared_ptr<B>, ::std::shared_ptr<B>, ::std::shared_ptr<B>>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)), ::std::move(::std::get<2>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<::std::shared_ptr<B>, ::std::shared_ptr<B>, ::std::shared_ptr<B>>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_paramTest3, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_paramTest3(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::shared_ptr<B>, ::std::shared_ptr<B>, ::std::shared_ptr<B>>>>& outAsync, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "paramTest3";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        nullptr,
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<::std::shared_ptr<B>, ::std::shared_ptr<B>, ::std::shared_ptr<B>> v;
            istr->readAll(::std::get<1>(v), ::std::get<2>(v), ::std::get<0>(v));
            istr->readPendingValues();
            return v;
        });
}
/// \endcond

::std::shared_ptr<::Test::B>
Test::TestIntfPrx::paramTest4(::std::shared_ptr<B>& iceP_p, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<::std::shared_ptr<B>, ::std::shared_ptr<B>>>(true, this, &TestIntfPrx::_iceI_paramTest4, context).get();
    iceP_p = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::std::shared_ptr<::Test::B>, ::std::shared_ptr<::Test::B>>>
Test::TestIntfPrx::paramTest4Async(const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<::std::shared_ptr<B>, ::std::shared_ptr<B>>>(false, this, &TestIntfPrx::_iceI_paramTest4, context);
}

::std::function<void()>
Test::TestIntfPrx::paramTest4Async(::std::function<void (::std::shared_ptr<::Test::B>, ::std::shared_ptr<::Test::B>)> response,
                                   ::std::function<void(::std::exception_ptr)> ex,
                                   ::std::function<void(bool)> sent,
                                   const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<::std::shared_ptr<B>, ::std::shared_ptr<B>>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<::std::shared_ptr<B>, ::std::shared_ptr<B>>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_paramTest4, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_paramTest4(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::shared_ptr<B>, ::std::shared_ptr<B>>>>& outAsync, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "paramTest4";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        nullptr,
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<::std::shared_ptr<B>, ::std::shared_ptr<B>> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            istr->readPendingValues();
            return v;
        });
}
/// \endcond

::std::shared_ptr<::Test::B>
Test::TestIntfPrx::returnTest1(::std::shared_ptr<B>& iceP_p1, ::std::shared_ptr<B>& iceP_p2, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<::std::shared_ptr<B>, ::std::shared_ptr<B>, ::std::shared_ptr<B>>>(true, this, &TestIntfPrx::_iceI_returnTest1, context).get();
    iceP_p1 = ::std::move(::std::get<1>(_result));
    iceP_p2 = ::std::move(::std::get<2>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::std::shared_ptr<::Test::B>, ::std::shared_ptr<::Test::B>, ::std::shared_ptr<::Test::B>>>
Test::TestIntfPrx::returnTest1Async(const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<::std::shared_ptr<B>, ::std::shared_ptr<B>, ::std::shared_ptr<B>>>(false, this, &TestIntfPrx::_iceI_returnTest1, context);
}

::std::function<void()>
Test::TestIntfPrx::returnTest1Async(::std::function<void (::std::shared_ptr<::Test::B>, ::std::shared_ptr<::Test::B>, ::std::shared_ptr<::Test::B>)> response,
                                    ::std::function<void(::std::exception_ptr)> ex,
                                    ::std::function<void(bool)> sent,
                                    const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<::std::shared_ptr<B>, ::std::shared_ptr<B>, ::std::shared_ptr<B>>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)), ::std::move(::std::get<2>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<::std::shared_ptr<B>, ::std::shared_ptr<B>, ::std::shared_ptr<B>>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_returnTest1, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_returnTest1(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::shared_ptr<B>, ::std::shared_ptr<B>, ::std::shared_ptr<B>>>>& outAsync, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "returnTest1";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        nullptr,
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<::std::shared_ptr<B>, ::std::shared_ptr<B>, ::std::shared_ptr<B>> v;
            istr->readAll(::std::get<1>(v), ::std::get<2>(v), ::std::get<0>(v));
            istr->readPendingValues();
            return v;
        });
}
/// \endcond

::std::shared_ptr<::Test::B>
Test::TestIntfPrx::returnTest2(::std::shared_ptr<B>& iceP_p2, ::std::shared_ptr<B>& iceP_p1, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<::std::shared_ptr<B>, ::std::shared_ptr<B>, ::std::shared_ptr<B>>>(true, this, &TestIntfPrx::_iceI_returnTest2, context).get();
    iceP_p2 = ::std::move(::std::get<1>(_result));
    iceP_p1 = ::std::move(::std::get<2>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::std::shared_ptr<::Test::B>, ::std::shared_ptr<::Test::B>, ::std::shared_ptr<::Test::B>>>
Test::TestIntfPrx::returnTest2Async(const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<::std::shared_ptr<B>, ::std::shared_ptr<B>, ::std::shared_ptr<B>>>(false, this, &TestIntfPrx::_iceI_returnTest2, context);
}

::std::function<void()>
Test::TestIntfPrx::returnTest2Async(::std::function<void (::std::shared_ptr<::Test::B>, ::std::shared_ptr<::Test::B>, ::std::shared_ptr<::Test::B>)> response,
                                    ::std::function<void(::std::exception_ptr)> ex,
                                    ::std::function<void(bool)> sent,
                                    const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<::std::shared_ptr<B>, ::std::shared_ptr<B>, ::std::shared_ptr<B>>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)), ::std::move(::std::get<2>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<::std::shared_ptr<B>, ::std::shared_ptr<B>, ::std::shared_ptr<B>>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_returnTest2, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_returnTest2(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<::std::shared_ptr<B>, ::std::shared_ptr<B>, ::std::shared_ptr<B>>>>& outAsync, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "returnTest2";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        nullptr,
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<::std::shared_ptr<B>, ::std::shared_ptr<B>, ::std::shared_ptr<B>> v;
            istr->readAll(::std::get<1>(v), ::std::get<2>(v), ::std::get<0>(v));
            istr->readPendingValues();
            return v;
        });
}
/// \endcond

::std::shared_ptr<::Test::B>
Test::TestIntfPrx::returnTest3(const ::std::shared_ptr<B>& iceP_p1, const ::std::shared_ptr<B>& iceP_p2, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::shared_ptr<B>>(true, this, &TestIntfPrx::_iceI_returnTest3, iceP_p1, iceP_p2, context).get();
}

::std::future<::std::shared_ptr<::Test::B>>
Test::TestIntfPrx::returnTest3Async(const ::std::shared_ptr<B>& iceP_p1, const ::std::shared_ptr<B>& iceP_p2, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::shared_ptr<B>>(false, this, &TestIntfPrx::_iceI_returnTest3, iceP_p1, iceP_p2, context);
}

::std::function<void()>
Test::TestIntfPrx::returnTest3Async(const ::std::shared_ptr<B>& iceP_p1, const ::std::shared_ptr<B>& iceP_p2,
                                    ::std::function<void (::std::shared_ptr<::Test::B>)> response,
                                    ::std::function<void(::std::exception_ptr)> ex,
                                    ::std::function<void(bool)> sent,
                                    const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<::std::shared_ptr<B>>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_returnTest3, iceP_p1, iceP_p2, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_returnTest3(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<B>>>& outAsync, const ::std::shared_ptr<B>& iceP_p1, const ::std::shared_ptr<B>& iceP_p2, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "returnTest3";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p1, iceP_p2);
            ostr->writePendingValues();
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::shared_ptr<B> ret;
            istr->readAll(ret);
            istr->readPendingValues();
            return ret;
        });
}
/// \endcond

::Test::SS3
Test::TestIntfPrx::sequenceTest(const ::std::shared_ptr<SS1>& iceP_p1, const ::std::shared_ptr<SS2>& iceP_p2, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<SS3>(true, this, &TestIntfPrx::_iceI_sequenceTest, iceP_p1, iceP_p2, context).get();
}

::std::future<::Test::SS3>
Test::TestIntfPrx::sequenceTestAsync(const ::std::shared_ptr<SS1>& iceP_p1, const ::std::shared_ptr<SS2>& iceP_p2, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<SS3>(false, this, &TestIntfPrx::_iceI_sequenceTest, iceP_p1, iceP_p2, context);
}

::std::function<void()>
Test::TestIntfPrx::sequenceTestAsync(const ::std::shared_ptr<SS1>& iceP_p1, const ::std::shared_ptr<SS2>& iceP_p2,
                                     ::std::function<void (::Test::SS3)> response,
                                     ::std::function<void(::std::exception_ptr)> ex,
                                     ::std::function<void(bool)> sent,
                                     const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<SS3>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_sequenceTest, iceP_p1, iceP_p2, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_sequenceTest(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<SS3>>& outAsync, const ::std::shared_ptr<SS1>& iceP_p1, const ::std::shared_ptr<SS2>& iceP_p2, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "sequenceTest";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p1, iceP_p2);
            ostr->writePendingValues();
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            SS3 ret;
            istr->readAll(ret);
            istr->readPendingValues();
            return ret;
        });
}
/// \endcond

::Test::BDict
Test::TestIntfPrx::dictionaryTest(const BDict& iceP_bin, BDict& iceP_bout, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<BDict, BDict>>(true, this, &TestIntfPrx::_iceI_dictionaryTest, iceP_bin, context).get();
    iceP_bout = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::BDict, ::Test::BDict>>
Test::TestIntfPrx::dictionaryTestAsync(const BDict& iceP_bin, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<BDict, BDict>>(false, this, &TestIntfPrx::_iceI_dictionaryTest, iceP_bin, context);
}

::std::function<void()>
Test::TestIntfPrx::dictionaryTestAsync(const BDict& iceP_bin,
                                       ::std::function<void (::Test::BDict, ::Test::BDict)> response,
                                       ::std::function<void(::std::exception_ptr)> ex,
                                       ::std::function<void(bool)> sent,
                                       const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<BDict, BDict>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<BDict, BDict>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_dictionaryTest, iceP_bin, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_dictionaryTest(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<BDict, BDict>>>& outAsync, const BDict& iceP_bin, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "dictionaryTest";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_bin);
            ostr->writePendingValues();
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<BDict, BDict> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            istr->readPendingValues();
            return v;
        });
}
/// \endcond

::std::shared_ptr<::Test::PBase>
Test::TestIntfPrx::exchangePBase(const ::std::shared_ptr<PBase>& iceP_pb, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::shared_ptr<PBase>>(true, this, &TestIntfPrx::_iceI_exchangePBase, iceP_pb, context).get();
}

::std::future<::std::shared_ptr<::Test::PBase>>
Test::TestIntfPrx::exchangePBaseAsync(const ::std::shared_ptr<PBase>& iceP_pb, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::shared_ptr<PBase>>(false, this, &TestIntfPrx::_iceI_exchangePBase, iceP_pb, context);
}

::std::function<void()>
Test::TestIntfPrx::exchangePBaseAsync(const ::std::shared_ptr<PBase>& iceP_pb,
                                      ::std::function<void (::std::shared_ptr<::Test::PBase>)> response,
                                      ::std::function<void(::std::exception_ptr)> ex,
                                      ::std::function<void(bool)> sent,
                                      const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<::std::shared_ptr<PBase>>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_exchangePBase, iceP_pb, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_exchangePBase(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<PBase>>>& outAsync, const ::std::shared_ptr<PBase>& iceP_pb, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "exchangePBase";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_pb);
            ostr->writePendingValues();
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::shared_ptr<PBase> ret;
            istr->readAll(ret);
            istr->readPendingValues();
            return ret;
        });
}
/// \endcond

::std::shared_ptr<::Test::Preserved>
Test::TestIntfPrx::PBSUnknownAsPreserved(const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::shared_ptr<Preserved>>(true, this, &TestIntfPrx::_iceI_PBSUnknownAsPreserved, context).get();
}

::std::future<::std::shared_ptr<::Test::Preserved>>
Test::TestIntfPrx::PBSUnknownAsPreservedAsync(const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::shared_ptr<Preserved>>(false, this, &TestIntfPrx::_iceI_PBSUnknownAsPreserved, context);
}

::std::function<void()>
Test::TestIntfPrx::PBSUnknownAsPreservedAsync(::std::function<void (::std::shared_ptr<::Test::Preserved>)> response,
                                              ::std::function<void(::std::exception_ptr)> ex,
                                              ::std::function<void(bool)> sent,
                                              const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<::std::shared_ptr<Preserved>>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_PBSUnknownAsPreserved, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_PBSUnknownAsPreserved(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<Preserved>>>& outAsync, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "PBSUnknownAsPreserved";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        nullptr,
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::shared_ptr<Preserved> ret;
            istr->readAll(ret);
            istr->readPendingValues();
            return ret;
        });
}
/// \endcond

void
Test::TestIntfPrx::checkPBSUnknown(const ::std::shared_ptr<Preserved>& iceP_p, const ::Ice::Context& context) const
{
    ::IceInternal::makePromiseOutgoing<void>(true, this, &TestIntfPrx::_iceI_checkPBSUnknown, iceP_p, context).get();
}

::std::future<void>
Test::TestIntfPrx::checkPBSUnknownAsync(const ::std::shared_ptr<Preserved>& iceP_p, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<void>(false, this, &TestIntfPrx::_iceI_checkPBSUnknown, iceP_p, context);
}

::std::function<void()>
Test::TestIntfPrx::checkPBSUnknownAsync(const ::std::shared_ptr<Preserved>& iceP_p,
                                        ::std::function<void ()> response,
                                        ::std::function<void(::std::exception_ptr)> ex,
                                        ::std::function<void(bool)> sent,
                                        const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_checkPBSUnknown, iceP_p, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_checkPBSUnknown(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::shared_ptr<Preserved>& iceP_p, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "checkPBSUnknown";

    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p);
            ostr->writePendingValues();
        },
        nullptr);
}
/// \endcond

::std::shared_ptr<::Test::Preserved>
Test::TestIntfPrx::PBSUnknownAsPreservedWithGraph(const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::shared_ptr<Preserved>>(true, this, &TestIntfPrx::_iceI_PBSUnknownAsPreservedWithGraph, context).get();
}

::std::future<::std::shared_ptr<::Test::Preserved>>
Test::TestIntfPrx::PBSUnknownAsPreservedWithGraphAsync(const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::shared_ptr<Preserved>>(false, this, &TestIntfPrx::_iceI_PBSUnknownAsPreservedWithGraph, context);
}

::std::function<void()>
Test::TestIntfPrx::PBSUnknownAsPreservedWithGraphAsync(::std::function<void (::std::shared_ptr<::Test::Preserved>)> response,
                                                       ::std::function<void(::std::exception_ptr)> ex,
                                                       ::std::function<void(bool)> sent,
                                                       const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<::std::shared_ptr<Preserved>>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_PBSUnknownAsPreservedWithGraph, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_PBSUnknownAsPreservedWithGraph(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<Preserved>>>& outAsync, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "PBSUnknownAsPreservedWithGraph";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        nullptr,
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::shared_ptr<Preserved> ret;
            istr->readAll(ret);
            istr->readPendingValues();
            return ret;
        });
}
/// \endcond

void
Test::TestIntfPrx::checkPBSUnknownWithGraph(const ::std::shared_ptr<Preserved>& iceP_p, const ::Ice::Context& context) const
{
    ::IceInternal::makePromiseOutgoing<void>(true, this, &TestIntfPrx::_iceI_checkPBSUnknownWithGraph, iceP_p, context).get();
}

::std::future<void>
Test::TestIntfPrx::checkPBSUnknownWithGraphAsync(const ::std::shared_ptr<Preserved>& iceP_p, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<void>(false, this, &TestIntfPrx::_iceI_checkPBSUnknownWithGraph, iceP_p, context);
}

::std::function<void()>
Test::TestIntfPrx::checkPBSUnknownWithGraphAsync(const ::std::shared_ptr<Preserved>& iceP_p,
                                                 ::std::function<void ()> response,
                                                 ::std::function<void(::std::exception_ptr)> ex,
                                                 ::std::function<void(bool)> sent,
                                                 const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_checkPBSUnknownWithGraph, iceP_p, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_checkPBSUnknownWithGraph(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::shared_ptr<Preserved>& iceP_p, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "checkPBSUnknownWithGraph";

    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p);
            ostr->writePendingValues();
        },
        nullptr);
}
/// \endcond

::std::shared_ptr<::Test::Preserved>
Test::TestIntfPrx::PBSUnknown2AsPreservedWithGraph(const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::shared_ptr<Preserved>>(true, this, &TestIntfPrx::_iceI_PBSUnknown2AsPreservedWithGraph, context).get();
}

::std::future<::std::shared_ptr<::Test::Preserved>>
Test::TestIntfPrx::PBSUnknown2AsPreservedWithGraphAsync(const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::shared_ptr<Preserved>>(false, this, &TestIntfPrx::_iceI_PBSUnknown2AsPreservedWithGraph, context);
}

::std::function<void()>
Test::TestIntfPrx::PBSUnknown2AsPreservedWithGraphAsync(::std::function<void (::std::shared_ptr<::Test::Preserved>)> response,
                                                        ::std::function<void(::std::exception_ptr)> ex,
                                                        ::std::function<void(bool)> sent,
                                                        const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<::std::shared_ptr<Preserved>>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_PBSUnknown2AsPreservedWithGraph, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_PBSUnknown2AsPreservedWithGraph(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<Preserved>>>& outAsync, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "PBSUnknown2AsPreservedWithGraph";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        nullptr,
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::shared_ptr<Preserved> ret;
            istr->readAll(ret);
            istr->readPendingValues();
            return ret;
        });
}
/// \endcond

void
Test::TestIntfPrx::checkPBSUnknown2WithGraph(const ::std::shared_ptr<Preserved>& iceP_p, const ::Ice::Context& context) const
{
    ::IceInternal::makePromiseOutgoing<void>(true, this, &TestIntfPrx::_iceI_checkPBSUnknown2WithGraph, iceP_p, context).get();
}

::std::future<void>
Test::TestIntfPrx::checkPBSUnknown2WithGraphAsync(const ::std::shared_ptr<Preserved>& iceP_p, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<void>(false, this, &TestIntfPrx::_iceI_checkPBSUnknown2WithGraph, iceP_p, context);
}

::std::function<void()>
Test::TestIntfPrx::checkPBSUnknown2WithGraphAsync(const ::std::shared_ptr<Preserved>& iceP_p,
                                                  ::std::function<void ()> response,
                                                  ::std::function<void(::std::exception_ptr)> ex,
                                                  ::std::function<void(bool)> sent,
                                                  const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_checkPBSUnknown2WithGraph, iceP_p, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_checkPBSUnknown2WithGraph(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::shared_ptr<Preserved>& iceP_p, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "checkPBSUnknown2WithGraph";

    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_p);
            ostr->writePendingValues();
        },
        nullptr);
}
/// \endcond

::std::shared_ptr<::Test::PNode>
Test::TestIntfPrx::exchangePNode(const ::std::shared_ptr<PNode>& iceP_pn, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::shared_ptr<PNode>>(true, this, &TestIntfPrx::_iceI_exchangePNode, iceP_pn, context).get();
}

::std::future<::std::shared_ptr<::Test::PNode>>
Test::TestIntfPrx::exchangePNodeAsync(const ::std::shared_ptr<PNode>& iceP_pn, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::shared_ptr<PNode>>(false, this, &TestIntfPrx::_iceI_exchangePNode, iceP_pn, context);
}

::std::function<void()>
Test::TestIntfPrx::exchangePNodeAsync(const ::std::shared_ptr<PNode>& iceP_pn,
                                      ::std::function<void (::std::shared_ptr<::Test::PNode>)> response,
                                      ::std::function<void(::std::exception_ptr)> ex,
                                      ::std::function<void(bool)> sent,
                                      const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<::std::shared_ptr<PNode>>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_exchangePNode, iceP_pn, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_exchangePNode(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<PNode>>>& outAsync, const ::std::shared_ptr<PNode>& iceP_pn, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "exchangePNode";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_pn);
            ostr->writePendingValues();
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::shared_ptr<PNode> ret;
            istr->readAll(ret);
            istr->readPendingValues();
            return ret;
        });
}
/// \endcond

void
Test::TestIntfPrx::throwBaseAsBase(const ::Ice::Context& context) const
{
    ::IceInternal::makePromiseOutgoing<void>(true, this, &TestIntfPrx::_iceI_throwBaseAsBase, context).get();
}

::std::future<void>
Test::TestIntfPrx::throwBaseAsBaseAsync(const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<void>(false, this, &TestIntfPrx::_iceI_throwBaseAsBase, context);
}

::std::function<void()>
Test::TestIntfPrx::throwBaseAsBaseAsync(::std::function<void ()> response,
                                        ::std::function<void(::std::exception_ptr)> ex,
                                        ::std::function<void(bool)> sent,
                                        const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_throwBaseAsBase, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_throwBaseAsBase(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "throwBaseAsBase";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        nullptr,
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const BaseException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

void
Test::TestIntfPrx::throwDerivedAsBase(const ::Ice::Context& context) const
{
    ::IceInternal::makePromiseOutgoing<void>(true, this, &TestIntfPrx::_iceI_throwDerivedAsBase, context).get();
}

::std::future<void>
Test::TestIntfPrx::throwDerivedAsBaseAsync(const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<void>(false, this, &TestIntfPrx::_iceI_throwDerivedAsBase, context);
}

::std::function<void()>
Test::TestIntfPrx::throwDerivedAsBaseAsync(::std::function<void ()> response,
                                           ::std::function<void(::std::exception_ptr)> ex,
                                           ::std::function<void(bool)> sent,
                                           const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_throwDerivedAsBase, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_throwDerivedAsBase(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "throwDerivedAsBase";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        nullptr,
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const BaseException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

void
Test::TestIntfPrx::throwDerivedAsDerived(const ::Ice::Context& context) const
{
    ::IceInternal::makePromiseOutgoing<void>(true, this, &TestIntfPrx::_iceI_throwDerivedAsDerived, context).get();
}

::std::future<void>
Test::TestIntfPrx::throwDerivedAsDerivedAsync(const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<void>(false, this, &TestIntfPrx::_iceI_throwDerivedAsDerived, context);
}

::std::function<void()>
Test::TestIntfPrx::throwDerivedAsDerivedAsync(::std::function<void ()> response,
                                              ::std::function<void(::std::exception_ptr)> ex,
                                              ::std::function<void(bool)> sent,
                                              const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_throwDerivedAsDerived, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_throwDerivedAsDerived(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "throwDerivedAsDerived";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        nullptr,
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const DerivedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

void
Test::TestIntfPrx::throwUnknownDerivedAsBase(const ::Ice::Context& context) const
{
    ::IceInternal::makePromiseOutgoing<void>(true, this, &TestIntfPrx::_iceI_throwUnknownDerivedAsBase, context).get();
}

::std::future<void>
Test::TestIntfPrx::throwUnknownDerivedAsBaseAsync(const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<void>(false, this, &TestIntfPrx::_iceI_throwUnknownDerivedAsBase, context);
}

::std::function<void()>
Test::TestIntfPrx::throwUnknownDerivedAsBaseAsync(::std::function<void ()> response,
                                                  ::std::function<void(::std::exception_ptr)> ex,
                                                  ::std::function<void(bool)> sent,
                                                  const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_throwUnknownDerivedAsBase, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_throwUnknownDerivedAsBase(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "throwUnknownDerivedAsBase";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        nullptr,
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const BaseException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

void
Test::TestIntfPrx::throwPreservedException(const ::Ice::Context& context) const
{
    ::IceInternal::makePromiseOutgoing<void>(true, this, &TestIntfPrx::_iceI_throwPreservedException, context).get();
}

::std::future<void>
Test::TestIntfPrx::throwPreservedExceptionAsync(const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<void>(false, this, &TestIntfPrx::_iceI_throwPreservedException, context);
}

::std::function<void()>
Test::TestIntfPrx::throwPreservedExceptionAsync(::std::function<void ()> response,
                                                ::std::function<void(::std::exception_ptr)> ex,
                                                ::std::function<void(bool)> sent,
                                                const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_throwPreservedException, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_throwPreservedException(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "throwPreservedException";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        nullptr,
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const PreservedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

void
Test::TestIntfPrx::useForward(::std::shared_ptr<Forward>& iceP_f, const ::Ice::Context& context) const
{
    iceP_f = ::IceInternal::makePromiseOutgoing<::std::shared_ptr<Forward>>(true, this, &TestIntfPrx::_iceI_useForward, context).get();
}

::std::future<::std::shared_ptr<::Test::Forward>>
Test::TestIntfPrx::useForwardAsync(const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::shared_ptr<Forward>>(false, this, &TestIntfPrx::_iceI_useForward, context);
}

::std::function<void()>
Test::TestIntfPrx::useForwardAsync(::std::function<void (::std::shared_ptr<::Test::Forward>)> response,
                                   ::std::function<void(::std::exception_ptr)> ex,
                                   ::std::function<void(bool)> sent,
                                   const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<::std::shared_ptr<Forward>>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_useForward, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_useForward(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<Forward>>>& outAsync, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "useForward";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        nullptr,
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::shared_ptr<Forward> iceP_f;
            istr->readAll(iceP_f);
            istr->readPendingValues();
            return iceP_f;
        });
}
/// \endcond

void
Test::TestIntfPrx::shutdown(const ::Ice::Context& context) const
{
    ::IceInternal::makePromiseOutgoing<void>(true, this, &TestIntfPrx::_iceI_shutdown, context).get();
}

::std::future<void>
Test::TestIntfPrx::shutdownAsync(const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<void>(false, this, &TestIntfPrx::_iceI_shutdown, context);
}

::std::function<void()>
Test::TestIntfPrx::shutdownAsync(::std::function<void ()> response,
                                 ::std::function<void(::std::exception_ptr)> ex,
                                 ::std::function<void(bool)> sent,
                                 const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::TestIntfPrx::_iceI_shutdown, context);
}

/// \cond INTERNAL
void
Test::TestIntfPrx::_iceI_shutdown(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::Ice::Context& context) const
{
    static const ::std::string operationName = "shutdown";

    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::SlicedFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

const ::std::string&
Test::TestIntfPrx::ice_staticId()
{
    static const ::std::string typeId = "::Test::TestIntf";
    return typeId;
}

Test::SBase::~SBase()
{
}

const ::std::string&
Test::SBase::ice_staticId()
{
    static const ::std::string typeId = "::Test::SBase";
    return typeId;
}

Test::SBSKnownDerived::~SBSKnownDerived()
{
}

const ::std::string&
Test::SBSKnownDerived::ice_staticId()
{
    static const ::std::string typeId = "::Test::SBSKnownDerived";
    return typeId;
}

Test::B::~B()
{
}

const ::std::string&
Test::B::ice_staticId()
{
    static const ::std::string typeId = "::Test::B";
    return typeId;
}

Test::D1::~D1()
{
}

const ::std::string&
Test::D1::ice_staticId()
{
    static const ::std::string typeId = "::Test::D1";
    return typeId;
}

Test::SS1::~SS1()
{
}

const ::std::string&
Test::SS1::ice_staticId()
{
    static const ::std::string typeId = "::Test::SS1";
    return typeId;
}

Test::SS2::~SS2()
{
}

const ::std::string&
Test::SS2::ice_staticId()
{
    static const ::std::string typeId = "::Test::SS2";
    return typeId;
}

Test::BaseException::~BaseException()
{
}

const ::std::string&
Test::BaseException::ice_staticId()
{
    static const ::std::string typeId = "::Test::BaseException";
    return typeId;
}

/// \cond STREAM
bool
Test::BaseException::_usesClasses() const
{
    return true;
}
/// \endcond

Test::DerivedException::~DerivedException()
{
}

const ::std::string&
Test::DerivedException::ice_staticId()
{
    static const ::std::string typeId = "::Test::DerivedException";
    return typeId;
}

Test::PBase::~PBase()
{
}

const ::std::string&
Test::PBase::ice_staticId()
{
    static const ::std::string typeId = "::Test::PBase";
    return typeId;
}

Test::Preserved::~Preserved()
{
}

::std::shared_ptr<::Ice::SlicedData>
Test::Preserved::ice_getSlicedData() const
{
    return _iceSlicedData;
}

/// \cond STREAM
void
Test::Preserved::_iceWrite(::Ice::OutputStream* ostr) const
{
    ostr->startValue(_iceSlicedData);
    _iceWriteImpl(ostr);
    ostr->endValue();
}

void
Test::Preserved::_iceRead(::Ice::InputStream* istr)
{
    istr->startValue();
    _iceReadImpl(istr);
    _iceSlicedData = istr->endValue(true);
}
/// \endcond

const ::std::string&
Test::Preserved::ice_staticId()
{
    static const ::std::string typeId = "::Test::Preserved";
    return typeId;
}

Test::PDerived::~PDerived()
{
}

const ::std::string&
Test::PDerived::ice_staticId()
{
    static const ::std::string typeId = "::Test::PDerived";
    return typeId;
}

Test::CompactPDerived::~CompactPDerived()
{
}

const ::std::string&
Test::CompactPDerived::ice_staticId()
{
    static const ::std::string typeId = "::Test::CompactPDerived";
    return typeId;
}

Test::PNode::~PNode()
{
}

::std::shared_ptr<::Ice::SlicedData>
Test::PNode::ice_getSlicedData() const
{
    return _iceSlicedData;
}

/// \cond STREAM
void
Test::PNode::_iceWrite(::Ice::OutputStream* ostr) const
{
    ostr->startValue(_iceSlicedData);
    _iceWriteImpl(ostr);
    ostr->endValue();
}

void
Test::PNode::_iceRead(::Ice::InputStream* istr)
{
    istr->startValue();
    _iceReadImpl(istr);
    _iceSlicedData = istr->endValue(true);
}
/// \endcond

const ::std::string&
Test::PNode::ice_staticId()
{
    static const ::std::string typeId = "::Test::PNode";
    return typeId;
}

Test::PreservedException::~PreservedException()
{
}

const ::std::string&
Test::PreservedException::ice_staticId()
{
    static const ::std::string typeId = "::Test::PreservedException";
    return typeId;
}

::std::shared_ptr<::Ice::SlicedData>
Test::PreservedException::ice_getSlicedData() const
{
    return _slicedData;
}

/// \cond STREAM
void
Test::PreservedException::_write(::Ice::OutputStream* ostr) const
{
    ostr->startException(_slicedData);
    _writeImpl(ostr);
    ostr->endException();
}

void
Test::PreservedException::_read(::Ice::InputStream* istr)
{
    istr->startException();
    _readImpl(istr);
    _slicedData = istr->endException(true);
}
/// \endcond

Test::Hidden::~Hidden()
{
}

const ::std::string&
Test::Hidden::ice_staticId()
{
    static const ::std::string typeId = "::Test::Hidden";
    return typeId;
}

Test::Forward::~Forward()
{
}

const ::std::string&
Test::Forward::ice_staticId()
{
    static const ::std::string typeId = "::Test::Forward";
    return typeId;
}

::std::vector<::std::string>
Test::TestIntf::ice_ids(const ::Ice::Current&) const
{
    static const ::std::vector<::std::string> allTypeIds = { "::Ice::Object", "::Test::TestIntf" };
    return allTypeIds;
}

::std::string
Test::TestIntf::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::TestIntf::ice_staticId()
{
    static const ::std::string typeId = "::Test::TestIntf";
    return typeId;
}

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_SBaseAsObject(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    ::std::shared_ptr<::Ice::Value> ret = this->SBaseAsObject(current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_SBaseAsSBase(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    ::std::shared_ptr<SBase> ret = this->SBaseAsSBase(current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_SBSKnownDerivedAsSBase(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    ::std::shared_ptr<SBase> ret = this->SBSKnownDerivedAsSBase(current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_SBSKnownDerivedAsSBSKnownDerived(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    ::std::shared_ptr<SBSKnownDerived> ret = this->SBSKnownDerivedAsSBSKnownDerived(current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_SBSUnknownDerivedAsSBase(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    ::std::shared_ptr<SBase> ret = this->SBSUnknownDerivedAsSBase(current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_SBSUnknownDerivedAsSBaseCompact(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::FormatType::CompactFormat);
    ::std::shared_ptr<SBase> ret = this->SBSUnknownDerivedAsSBaseCompact(current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_SUnknownAsObject(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    ::std::shared_ptr<::Ice::Value> ret = this->SUnknownAsObject(current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_checkSUnknown(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::shared_ptr<::Ice::Value> iceP_o;
    istr->readAll(iceP_o);
    istr->readPendingValues();
    inS.endReadParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    this->checkSUnknown(::std::move(iceP_o), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_oneElementCycle(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    ::std::shared_ptr<B> ret = this->oneElementCycle(current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_twoElementCycle(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    ::std::shared_ptr<B> ret = this->twoElementCycle(current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_D1AsB(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    ::std::shared_ptr<B> ret = this->D1AsB(current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_D1AsD1(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    ::std::shared_ptr<D1> ret = this->D1AsD1(current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_D2AsB(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    ::std::shared_ptr<B> ret = this->D2AsB(current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_paramTest1(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    ::std::shared_ptr<B> iceP_p1;
    ::std::shared_ptr<B> iceP_p2;
    this->paramTest1(iceP_p1, iceP_p2, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_p1, iceP_p2);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_paramTest2(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    ::std::shared_ptr<B> iceP_p2;
    ::std::shared_ptr<B> iceP_p1;
    this->paramTest2(iceP_p2, iceP_p1, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_p2, iceP_p1);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_paramTest3(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    ::std::shared_ptr<B> iceP_p1;
    ::std::shared_ptr<B> iceP_p2;
    ::std::shared_ptr<B> ret = this->paramTest3(iceP_p1, iceP_p2, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_p1, iceP_p2, ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_paramTest4(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    ::std::shared_ptr<B> iceP_p;
    ::std::shared_ptr<B> ret = this->paramTest4(iceP_p, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_p, ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_returnTest1(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    ::std::shared_ptr<B> iceP_p1;
    ::std::shared_ptr<B> iceP_p2;
    ::std::shared_ptr<B> ret = this->returnTest1(iceP_p1, iceP_p2, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_p1, iceP_p2, ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_returnTest2(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    ::std::shared_ptr<B> iceP_p2;
    ::std::shared_ptr<B> iceP_p1;
    ::std::shared_ptr<B> ret = this->returnTest2(iceP_p2, iceP_p1, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_p2, iceP_p1, ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_returnTest3(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::shared_ptr<B> iceP_p1;
    ::std::shared_ptr<B> iceP_p2;
    istr->readAll(iceP_p1, iceP_p2);
    istr->readPendingValues();
    inS.endReadParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    ::std::shared_ptr<B> ret = this->returnTest3(::std::move(iceP_p1), ::std::move(iceP_p2), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_sequenceTest(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::shared_ptr<SS1> iceP_p1;
    ::std::shared_ptr<SS2> iceP_p2;
    istr->readAll(iceP_p1, iceP_p2);
    istr->readPendingValues();
    inS.endReadParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    SS3 ret = this->sequenceTest(::std::move(iceP_p1), ::std::move(iceP_p2), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_dictionaryTest(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    BDict iceP_bin;
    istr->readAll(iceP_bin);
    istr->readPendingValues();
    inS.endReadParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    BDict iceP_bout;
    BDict ret = this->dictionaryTest(::std::move(iceP_bin), iceP_bout, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_bout, ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_exchangePBase(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::shared_ptr<PBase> iceP_pb;
    istr->readAll(iceP_pb);
    istr->readPendingValues();
    inS.endReadParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    ::std::shared_ptr<PBase> ret = this->exchangePBase(::std::move(iceP_pb), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_PBSUnknownAsPreserved(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    ::std::shared_ptr<Preserved> ret = this->PBSUnknownAsPreserved(current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_checkPBSUnknown(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::shared_ptr<Preserved> iceP_p;
    istr->readAll(iceP_p);
    istr->readPendingValues();
    inS.endReadParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    this->checkPBSUnknown(::std::move(iceP_p), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_PBSUnknownAsPreservedWithGraph(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const ::std::shared_ptr<Preserved>& ret)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(ret);
        ostr->writePendingValues();
        inA->endWriteParams();
        inA->completed();
    };
    this->PBSUnknownAsPreservedWithGraphAsync(responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_checkPBSUnknownWithGraph(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::shared_ptr<Preserved> iceP_p;
    istr->readAll(iceP_p);
    istr->readPendingValues();
    inS.endReadParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    this->checkPBSUnknownWithGraph(::std::move(iceP_p), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_PBSUnknown2AsPreservedWithGraph(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const ::std::shared_ptr<Preserved>& ret)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(ret);
        ostr->writePendingValues();
        inA->endWriteParams();
        inA->completed();
    };
    this->PBSUnknown2AsPreservedWithGraphAsync(responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_checkPBSUnknown2WithGraph(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::shared_ptr<Preserved> iceP_p;
    istr->readAll(iceP_p);
    istr->readPendingValues();
    inS.endReadParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    this->checkPBSUnknown2WithGraph(::std::move(iceP_p), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_exchangePNode(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::shared_ptr<PNode> iceP_pn;
    istr->readAll(iceP_pn);
    istr->readPendingValues();
    inS.endReadParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    ::std::shared_ptr<PNode> ret = this->exchangePNode(::std::move(iceP_pn), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_throwBaseAsBase(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    this->throwBaseAsBase(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_throwDerivedAsBase(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    this->throwDerivedAsBase(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_throwDerivedAsDerived(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    this->throwDerivedAsDerived(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_throwUnknownDerivedAsBase(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    this->throwUnknownDerivedAsBase(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_throwPreservedException(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    this->throwPreservedExceptionAsync(inA->response(), inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_useForward(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    ::std::shared_ptr<Forward> iceP_f;
    this->useForward(iceP_f, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_f);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceD_shutdown(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    inS.setFormat(::Ice::FormatType::SlicedFormat);
    this->shutdown(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::TestIntf::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    static constexpr ::std::string_view allOperations[] = { "D1AsB", "D1AsD1", "D2AsB", "PBSUnknown2AsPreservedWithGraph", "PBSUnknownAsPreserved", "PBSUnknownAsPreservedWithGraph", "SBSKnownDerivedAsSBSKnownDerived", "SBSKnownDerivedAsSBase", "SBSUnknownDerivedAsSBase", "SBSUnknownDerivedAsSBaseCompact", "SBaseAsObject", "SBaseAsSBase", "SUnknownAsObject", "checkPBSUnknown", "checkPBSUnknown2WithGraph", "checkPBSUnknownWithGraph", "checkSUnknown", "dictionaryTest", "exchangePBase", "exchangePNode", "ice_id", "ice_ids", "ice_isA", "ice_ping", "oneElementCycle", "paramTest1", "paramTest2", "paramTest3", "paramTest4", "returnTest1", "returnTest2", "returnTest3", "sequenceTest", "shutdown", "throwBaseAsBase", "throwDerivedAsBase", "throwDerivedAsDerived", "throwPreservedException", "throwUnknownDerivedAsBase", "twoElementCycle", "useForward" };

    ::std::pair<const ::std::string_view*, const ::std::string_view*> r = ::std::equal_range(allOperations, allOperations + 41, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - allOperations)
    {
        case 0:
        {
            return _iceD_D1AsB(in, current);
        }
        case 1:
        {
            return _iceD_D1AsD1(in, current);
        }
        case 2:
        {
            return _iceD_D2AsB(in, current);
        }
        case 3:
        {
            return _iceD_PBSUnknown2AsPreservedWithGraph(in, current);
        }
        case 4:
        {
            return _iceD_PBSUnknownAsPreserved(in, current);
        }
        case 5:
        {
            return _iceD_PBSUnknownAsPreservedWithGraph(in, current);
        }
        case 6:
        {
            return _iceD_SBSKnownDerivedAsSBSKnownDerived(in, current);
        }
        case 7:
        {
            return _iceD_SBSKnownDerivedAsSBase(in, current);
        }
        case 8:
        {
            return _iceD_SBSUnknownDerivedAsSBase(in, current);
        }
        case 9:
        {
            return _iceD_SBSUnknownDerivedAsSBaseCompact(in, current);
        }
        case 10:
        {
            return _iceD_SBaseAsObject(in, current);
        }
        case 11:
        {
            return _iceD_SBaseAsSBase(in, current);
        }
        case 12:
        {
            return _iceD_SUnknownAsObject(in, current);
        }
        case 13:
        {
            return _iceD_checkPBSUnknown(in, current);
        }
        case 14:
        {
            return _iceD_checkPBSUnknown2WithGraph(in, current);
        }
        case 15:
        {
            return _iceD_checkPBSUnknownWithGraph(in, current);
        }
        case 16:
        {
            return _iceD_checkSUnknown(in, current);
        }
        case 17:
        {
            return _iceD_dictionaryTest(in, current);
        }
        case 18:
        {
            return _iceD_exchangePBase(in, current);
        }
        case 19:
        {
            return _iceD_exchangePNode(in, current);
        }
        case 20:
        {
            return _iceD_ice_id(in, current);
        }
        case 21:
        {
            return _iceD_ice_ids(in, current);
        }
        case 22:
        {
            return _iceD_ice_isA(in, current);
        }
        case 23:
        {
            return _iceD_ice_ping(in, current);
        }
        case 24:
        {
            return _iceD_oneElementCycle(in, current);
        }
        case 25:
        {
            return _iceD_paramTest1(in, current);
        }
        case 26:
        {
            return _iceD_paramTest2(in, current);
        }
        case 27:
        {
            return _iceD_paramTest3(in, current);
        }
        case 28:
        {
            return _iceD_paramTest4(in, current);
        }
        case 29:
        {
            return _iceD_returnTest1(in, current);
        }
        case 30:
        {
            return _iceD_returnTest2(in, current);
        }
        case 31:
        {
            return _iceD_returnTest3(in, current);
        }
        case 32:
        {
            return _iceD_sequenceTest(in, current);
        }
        case 33:
        {
            return _iceD_shutdown(in, current);
        }
        case 34:
        {
            return _iceD_throwBaseAsBase(in, current);
        }
        case 35:
        {
            return _iceD_throwDerivedAsBase(in, current);
        }
        case 36:
        {
            return _iceD_throwDerivedAsDerived(in, current);
        }
        case 37:
        {
            return _iceD_throwPreservedException(in, current);
        }
        case 38:
        {
            return _iceD_throwUnknownDerivedAsBase(in, current);
        }
        case 39:
        {
            return _iceD_twoElementCycle(in, current);
        }
        case 40:
        {
            return _iceD_useForward(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond
