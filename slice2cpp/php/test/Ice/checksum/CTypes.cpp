//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.7.9
//
// <auto-generated>
//
// Generated from file `CTypes.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#include <CTypes.h>
#include <IceUtil/PushDisableWarnings.h>
#include <Ice/LocalException.h>
#include <Ice/ValueFactory.h>
#include <Ice/OutgoingAsync.h>
#include <Ice/InputStream.h>
#include <Ice/OutputStream.h>
#include <Ice/LocalException.h>
#include <IceUtil/PopDisableWarnings.h>

#if defined(_MSC_VER)
#   pragma warning(disable:4458) // declaration of ... hides class member
#elif defined(__clang__)
#   pragma clang diagnostic ignored "-Wshadow"
#elif defined(__GNUC__)
#   pragma GCC diagnostic ignored "-Wshadow"
#endif

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 307
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 >= 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 9
#       error Ice patch level mismatch!
#   endif
#endif

#ifdef ICE_CPP11_MAPPING // C++11 mapping

namespace
{

const ::std::string iceC_Test_Interface1_ids[2] =
{
    "::Ice::Object",
    "::Test::Interface1"
};
const ::std::string iceC_Test_Interface1_ops[] =
{
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};

const ::std::string iceC_Test_Interface2_ids[2] =
{
    "::Ice::Object",
    "::Test::Interface2"
};
const ::std::string iceC_Test_Interface2_ops[] =
{
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};

const ::std::string iceC_Test_Interface3_ids[2] =
{
    "::Ice::Object",
    "::Test::Interface3"
};
const ::std::string iceC_Test_Interface3_ops[] =
{
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};

const ::std::string iceC_Test_Interface4_ids[2] =
{
    "::Ice::Object",
    "::Test::Interface4"
};
const ::std::string iceC_Test_Interface4_ops[] =
{
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};

const ::IceInternal::DefaultValueFactoryInit<::Test::EmptyClass1> iceC_Test_EmptyClass1_init("::Test::EmptyClass1");

const ::IceInternal::DefaultValueFactoryInit<::Test::EmptyClass2> iceC_Test_EmptyClass2_init("::Test::EmptyClass2");

const ::IceInternal::DefaultValueFactoryInit<::Test::EmptyClass3> iceC_Test_EmptyClass3_init("::Test::EmptyClass3");

const ::IceInternal::DefaultValueFactoryInit<::Test::EmptyClass4> iceC_Test_EmptyClass4_init("::Test::EmptyClass4");

const ::IceInternal::DefaultValueFactoryInit<::Test::EmptyClass5> iceC_Test_EmptyClass5_init("::Test::EmptyClass5");

const ::IceInternal::DefaultValueFactoryInit<::Test::SimpleClass1> iceC_Test_SimpleClass1_init("::Test::SimpleClass1");

const ::IceInternal::DefaultValueFactoryInit<::Test::SimpleClass2> iceC_Test_SimpleClass2_init("::Test::SimpleClass2");

const ::IceInternal::DefaultValueFactoryInit<::Test::SimpleClass3> iceC_Test_SimpleClass3_init("::Test::SimpleClass3");

const ::IceInternal::DefaultValueFactoryInit<::Test::SimpleClass4> iceC_Test_SimpleClass4_init("::Test::SimpleClass4");

const ::IceInternal::DefaultValueFactoryInit<::Test::SimpleClass5> iceC_Test_SimpleClass5_init("::Test::SimpleClass5");

const ::IceInternal::DefaultValueFactoryInit<::Test::SimpleClass6> iceC_Test_SimpleClass6_init("::Test::SimpleClass6");

const ::IceInternal::DefaultValueFactoryInit<::Test::SimpleClass7> iceC_Test_SimpleClass7_init("::Test::SimpleClass7");

const ::IceInternal::DefaultUserExceptionFactoryInit<::Test::Exception1> iceC_Test_Exception1_init("::Test::Exception1");

const ::IceInternal::DefaultUserExceptionFactoryInit<::Test::Exception2> iceC_Test_Exception2_init("::Test::Exception2");

const ::IceInternal::DefaultUserExceptionFactoryInit<::Test::Exception3> iceC_Test_Exception3_init("::Test::Exception3");

const ::IceInternal::DefaultUserExceptionFactoryInit<::Test::Exception4> iceC_Test_Exception4_init("::Test::Exception4");

const ::IceInternal::DefaultUserExceptionFactoryInit<::Test::Exception5> iceC_Test_Exception5_init("::Test::Exception5");

const ::IceInternal::DefaultUserExceptionFactoryInit<::Test::Exception6> iceC_Test_Exception6_init("::Test::Exception6");

const ::IceInternal::DefaultUserExceptionFactoryInit<::Test::OptionalEx0> iceC_Test_OptionalEx0_init("::Test::OptionalEx0");

const ::IceInternal::DefaultUserExceptionFactoryInit<::Test::OptionalEx1> iceC_Test_OptionalEx1_init("::Test::OptionalEx1");

const ::IceInternal::DefaultUserExceptionFactoryInit<::Test::OptionalEx2> iceC_Test_OptionalEx2_init("::Test::OptionalEx2");

const ::IceInternal::DefaultUserExceptionFactoryInit<::Test::OptionalEx3> iceC_Test_OptionalEx3_init("::Test::OptionalEx3");

const ::IceInternal::DefaultUserExceptionFactoryInit<::Test::OptionalEx4> iceC_Test_OptionalEx4_init("::Test::OptionalEx4");

const ::std::string iceC_Test_BaseInterface1_ids[2] =
{
    "::Ice::Object",
    "::Test::BaseInterface1"
};
const ::std::string iceC_Test_BaseInterface1_ops[] =
{
    "baseOp1",
    "baseOp2",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};
const ::std::string iceC_Test_BaseInterface1_baseOp1_name = "baseOp1";
const ::std::string iceC_Test_BaseInterface1_baseOp2_name = "baseOp2";

const ::std::string iceC_Test_BaseInterface2_ids[2] =
{
    "::Ice::Object",
    "::Test::BaseInterface2"
};
const ::std::string iceC_Test_BaseInterface2_ops[] =
{
    "baseOp",
    "baseOp2",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};
const ::std::string iceC_Test_BaseInterface2_baseOp_name = "baseOp";
const ::std::string iceC_Test_BaseInterface2_baseOp2_name = "baseOp2";

const ::std::string iceC_Test_BaseInterface3_ids[2] =
{
    "::Ice::Object",
    "::Test::BaseInterface3"
};
const ::std::string iceC_Test_BaseInterface3_ops[] =
{
    "baseOp",
    "baseOp2",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};
const ::std::string iceC_Test_BaseInterface3_baseOp_name = "baseOp";
const ::std::string iceC_Test_BaseInterface3_baseOp2_name = "baseOp2";

const ::std::string iceC_Test_BaseInterface4_ids[2] =
{
    "::Ice::Object",
    "::Test::BaseInterface4"
};
const ::std::string iceC_Test_BaseInterface4_ops[] =
{
    "baseOp",
    "baseOp2",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};
const ::std::string iceC_Test_BaseInterface4_baseOp_name = "baseOp";
const ::std::string iceC_Test_BaseInterface4_baseOp2_name = "baseOp2";

const ::std::string iceC_Test_BaseInterface5_ids[2] =
{
    "::Ice::Object",
    "::Test::BaseInterface5"
};
const ::std::string iceC_Test_BaseInterface5_ops[] =
{
    "baseOp",
    "baseOp2",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};
const ::std::string iceC_Test_BaseInterface5_baseOp_name = "baseOp";
const ::std::string iceC_Test_BaseInterface5_baseOp2_name = "baseOp2";

const ::std::string iceC_Test_BaseInterface6_ids[2] =
{
    "::Ice::Object",
    "::Test::BaseInterface6"
};
const ::std::string iceC_Test_BaseInterface6_ops[] =
{
    "baseOp",
    "baseOp2",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};
const ::std::string iceC_Test_BaseInterface6_baseOp_name = "baseOp";
const ::std::string iceC_Test_BaseInterface6_baseOp2_name = "baseOp2";

const ::std::string iceC_Test_BaseInterface7_ids[2] =
{
    "::Ice::Object",
    "::Test::BaseInterface7"
};
const ::std::string iceC_Test_BaseInterface7_ops[] =
{
    "baseOp",
    "baseOp2",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};
const ::std::string iceC_Test_BaseInterface7_baseOp_name = "baseOp";
const ::std::string iceC_Test_BaseInterface7_baseOp2_name = "baseOp2";

const ::std::string iceC_Test_BaseInterface8_ids[2] =
{
    "::Ice::Object",
    "::Test::BaseInterface8"
};
const ::std::string iceC_Test_BaseInterface8_ops[] =
{
    "baseOp",
    "baseOp2",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};
const ::std::string iceC_Test_BaseInterface8_baseOp_name = "baseOp";
const ::std::string iceC_Test_BaseInterface8_baseOp2_name = "baseOp2";

const ::std::string iceC_Test_BaseInterface9_ids[2] =
{
    "::Ice::Object",
    "::Test::BaseInterface9"
};
const ::std::string iceC_Test_BaseInterface9_ops[] =
{
    "baseOp",
    "baseOp2",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};
const ::std::string iceC_Test_BaseInterface9_baseOp_name = "baseOp";
const ::std::string iceC_Test_BaseInterface9_baseOp2_name = "baseOp2";

const ::std::string iceC_Test_BaseInterface10_ids[2] =
{
    "::Ice::Object",
    "::Test::BaseInterface10"
};
const ::std::string iceC_Test_BaseInterface10_ops[] =
{
    "baseOp",
    "baseOp2",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};
const ::std::string iceC_Test_BaseInterface10_baseOp_name = "baseOp";
const ::std::string iceC_Test_BaseInterface10_baseOp2_name = "baseOp2";

const ::std::string iceC_Test_BaseInterface11_ids[2] =
{
    "::Ice::Object",
    "::Test::BaseInterface11"
};
const ::std::string iceC_Test_BaseInterface11_ops[] =
{
    "baseOp",
    "baseOp2",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};
const ::std::string iceC_Test_BaseInterface11_baseOp_name = "baseOp";
const ::std::string iceC_Test_BaseInterface11_baseOp2_name = "baseOp2";

const ::IceInternal::DefaultValueFactoryInit<::Test::Compact1> iceC_Test_Compact1_init("::Test::Compact1");
const ::IceInternal::CompactIdInit iceC_Test_Compact1_compactIdInit ("::Test::Compact1", 1);

const ::IceInternal::DefaultValueFactoryInit<::Test::Derived1> iceC_Test_Derived1_init("::Test::Derived1");

const ::IceInternal::DefaultValueFactoryInit<::Test::Compact2> iceC_Test_Compact2_init("::Test::Compact2");
const ::IceInternal::CompactIdInit iceC_Test_Compact2_compactIdInit ("::Test::Compact2", 2);

const ::IceInternal::DefaultValueFactoryInit<::Test::Optional0> iceC_Test_Optional0_init("::Test::Optional0");

const ::IceInternal::DefaultValueFactoryInit<::Test::Optional1> iceC_Test_Optional1_init("::Test::Optional1");

const ::IceInternal::DefaultValueFactoryInit<::Test::Optional2> iceC_Test_Optional2_init("::Test::Optional2");

const ::IceInternal::DefaultValueFactoryInit<::Test::Optional3> iceC_Test_Optional3_init("::Test::Optional3");

const ::IceInternal::DefaultValueFactoryInit<::Test::Optional4> iceC_Test_Optional4_init("::Test::Optional4");

const ::std::string iceC_Test_OptionalParameters0_ids[2] =
{
    "::Ice::Object",
    "::Test::OptionalParameters0"
};
const ::std::string iceC_Test_OptionalParameters0_ops[] =
{
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "op1"
};
const ::std::string iceC_Test_OptionalParameters0_op1_name = "op1";

const ::std::string iceC_Test_OptionalParameters1_ids[2] =
{
    "::Ice::Object",
    "::Test::OptionalParameters1"
};
const ::std::string iceC_Test_OptionalParameters1_ops[] =
{
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "op1"
};
const ::std::string iceC_Test_OptionalParameters1_op1_name = "op1";

const ::std::string iceC_Test_OptionalParameters2_ids[2] =
{
    "::Ice::Object",
    "::Test::OptionalParameters2"
};
const ::std::string iceC_Test_OptionalParameters2_ops[] =
{
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "op1"
};
const ::std::string iceC_Test_OptionalParameters2_op1_name = "op1";

const ::std::string iceC_Test_OptionalParameters3_ids[2] =
{
    "::Ice::Object",
    "::Test::OptionalParameters3"
};
const ::std::string iceC_Test_OptionalParameters3_ops[] =
{
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "op1"
};
const ::std::string iceC_Test_OptionalParameters3_op1_name = "op1";

const ::std::string iceC_Test_OptionalReturn0_ids[2] =
{
    "::Ice::Object",
    "::Test::OptionalReturn0"
};
const ::std::string iceC_Test_OptionalReturn0_ops[] =
{
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "op"
};
const ::std::string iceC_Test_OptionalReturn0_op_name = "op";

const ::std::string iceC_Test_OptionalReturn2_ids[2] =
{
    "::Ice::Object",
    "::Test::OptionalReturn2"
};
const ::std::string iceC_Test_OptionalReturn2_ops[] =
{
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "op"
};
const ::std::string iceC_Test_OptionalReturn2_op_name = "op";

}

Test::Exception1::~Exception1()
{
}

const ::std::string&
Test::Exception1::ice_staticId()
{
    static const ::std::string typeId = "::Test::Exception1";
    return typeId;
}

Test::Exception2::~Exception2()
{
}

const ::std::string&
Test::Exception2::ice_staticId()
{
    static const ::std::string typeId = "::Test::Exception2";
    return typeId;
}

Test::Exception3::~Exception3()
{
}

const ::std::string&
Test::Exception3::ice_staticId()
{
    static const ::std::string typeId = "::Test::Exception3";
    return typeId;
}

Test::Exception4::~Exception4()
{
}

const ::std::string&
Test::Exception4::ice_staticId()
{
    static const ::std::string typeId = "::Test::Exception4";
    return typeId;
}

Test::Exception5::~Exception5()
{
}

const ::std::string&
Test::Exception5::ice_staticId()
{
    static const ::std::string typeId = "::Test::Exception5";
    return typeId;
}

Test::Exception6::~Exception6()
{
}

const ::std::string&
Test::Exception6::ice_staticId()
{
    static const ::std::string typeId = "::Test::Exception6";
    return typeId;
}

Test::OptionalEx0::~OptionalEx0()
{
}

const ::std::string&
Test::OptionalEx0::ice_staticId()
{
    static const ::std::string typeId = "::Test::OptionalEx0";
    return typeId;
}

Test::OptionalEx1::~OptionalEx1()
{
}

const ::std::string&
Test::OptionalEx1::ice_staticId()
{
    static const ::std::string typeId = "::Test::OptionalEx1";
    return typeId;
}

Test::OptionalEx2::~OptionalEx2()
{
}

const ::std::string&
Test::OptionalEx2::ice_staticId()
{
    static const ::std::string typeId = "::Test::OptionalEx2";
    return typeId;
}

Test::OptionalEx3::~OptionalEx3()
{
}

const ::std::string&
Test::OptionalEx3::ice_staticId()
{
    static const ::std::string typeId = "::Test::OptionalEx3";
    return typeId;
}

Test::OptionalEx4::~OptionalEx4()
{
}

const ::std::string&
Test::OptionalEx4::ice_staticId()
{
    static const ::std::string typeId = "::Test::OptionalEx4";
    return typeId;
}

Test::LocalClass::~LocalClass()
{
}

bool
Test::Interface1::ice_isA(::std::string s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_Interface1_ids, iceC_Test_Interface1_ids + 2, s);
}

::std::vector<::std::string>
Test::Interface1::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector<::std::string>(&iceC_Test_Interface1_ids[0], &iceC_Test_Interface1_ids[2]);
}

::std::string
Test::Interface1::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::Interface1::ice_staticId()
{
    static const ::std::string typeId = "::Test::Interface1";
    return typeId;
}

bool
Test::Interface2::ice_isA(::std::string s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_Interface2_ids, iceC_Test_Interface2_ids + 2, s);
}

::std::vector<::std::string>
Test::Interface2::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector<::std::string>(&iceC_Test_Interface2_ids[0], &iceC_Test_Interface2_ids[2]);
}

::std::string
Test::Interface2::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::Interface2::ice_staticId()
{
    static const ::std::string typeId = "::Test::Interface2";
    return typeId;
}

bool
Test::Interface3::ice_isA(::std::string s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_Interface3_ids, iceC_Test_Interface3_ids + 2, s);
}

::std::vector<::std::string>
Test::Interface3::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector<::std::string>(&iceC_Test_Interface3_ids[0], &iceC_Test_Interface3_ids[2]);
}

::std::string
Test::Interface3::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::Interface3::ice_staticId()
{
    static const ::std::string typeId = "::Test::Interface3";
    return typeId;
}

bool
Test::Interface4::ice_isA(::std::string s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_Interface4_ids, iceC_Test_Interface4_ids + 2, s);
}

::std::vector<::std::string>
Test::Interface4::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector<::std::string>(&iceC_Test_Interface4_ids[0], &iceC_Test_Interface4_ids[2]);
}

::std::string
Test::Interface4::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::Interface4::ice_staticId()
{
    static const ::std::string typeId = "::Test::Interface4";
    return typeId;
}

bool
Test::BaseInterface1::ice_isA(::std::string s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_BaseInterface1_ids, iceC_Test_BaseInterface1_ids + 2, s);
}

::std::vector<::std::string>
Test::BaseInterface1::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector<::std::string>(&iceC_Test_BaseInterface1_ids[0], &iceC_Test_BaseInterface1_ids[2]);
}

::std::string
Test::BaseInterface1::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::BaseInterface1::ice_staticId()
{
    static const ::std::string typeId = "::Test::BaseInterface1";
    return typeId;
}

/// \cond INTERNAL
bool
Test::BaseInterface1::_iceD_baseOp1(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    this->baseOp1(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::BaseInterface1::_iceD_baseOp2(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    int iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    ::std::string iceP_s;
    this->baseOp2(iceP_i, iceP_s, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_s);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::BaseInterface1::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_Test_BaseInterface1_ops, iceC_Test_BaseInterface1_ops + 6, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_Test_BaseInterface1_ops)
    {
        case 0:
        {
            return _iceD_baseOp1(in, current);
        }
        case 1:
        {
            return _iceD_baseOp2(in, current);
        }
        case 2:
        {
            return _iceD_ice_id(in, current);
        }
        case 3:
        {
            return _iceD_ice_ids(in, current);
        }
        case 4:
        {
            return _iceD_ice_isA(in, current);
        }
        case 5:
        {
            return _iceD_ice_ping(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

bool
Test::BaseInterface2::ice_isA(::std::string s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_BaseInterface2_ids, iceC_Test_BaseInterface2_ids + 2, s);
}

::std::vector<::std::string>
Test::BaseInterface2::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector<::std::string>(&iceC_Test_BaseInterface2_ids[0], &iceC_Test_BaseInterface2_ids[2]);
}

::std::string
Test::BaseInterface2::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::BaseInterface2::ice_staticId()
{
    static const ::std::string typeId = "::Test::BaseInterface2";
    return typeId;
}

/// \cond INTERNAL
bool
Test::BaseInterface2::_iceD_baseOp(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    this->baseOp(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::BaseInterface2::_iceD_baseOp2(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    int iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    ::std::string iceP_s;
    this->baseOp2(iceP_i, iceP_s, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_s);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::BaseInterface2::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_Test_BaseInterface2_ops, iceC_Test_BaseInterface2_ops + 6, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_Test_BaseInterface2_ops)
    {
        case 0:
        {
            return _iceD_baseOp(in, current);
        }
        case 1:
        {
            return _iceD_baseOp2(in, current);
        }
        case 2:
        {
            return _iceD_ice_id(in, current);
        }
        case 3:
        {
            return _iceD_ice_ids(in, current);
        }
        case 4:
        {
            return _iceD_ice_isA(in, current);
        }
        case 5:
        {
            return _iceD_ice_ping(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

bool
Test::BaseInterface3::ice_isA(::std::string s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_BaseInterface3_ids, iceC_Test_BaseInterface3_ids + 2, s);
}

::std::vector<::std::string>
Test::BaseInterface3::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector<::std::string>(&iceC_Test_BaseInterface3_ids[0], &iceC_Test_BaseInterface3_ids[2]);
}

::std::string
Test::BaseInterface3::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::BaseInterface3::ice_staticId()
{
    static const ::std::string typeId = "::Test::BaseInterface3";
    return typeId;
}

/// \cond INTERNAL
bool
Test::BaseInterface3::_iceD_baseOp(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    this->baseOp(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::BaseInterface3::_iceD_baseOp2(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    int iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    ::std::string iceP_s;
    this->baseOp2(iceP_i, iceP_s, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_s);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::BaseInterface3::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_Test_BaseInterface3_ops, iceC_Test_BaseInterface3_ops + 6, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_Test_BaseInterface3_ops)
    {
        case 0:
        {
            return _iceD_baseOp(in, current);
        }
        case 1:
        {
            return _iceD_baseOp2(in, current);
        }
        case 2:
        {
            return _iceD_ice_id(in, current);
        }
        case 3:
        {
            return _iceD_ice_ids(in, current);
        }
        case 4:
        {
            return _iceD_ice_isA(in, current);
        }
        case 5:
        {
            return _iceD_ice_ping(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

bool
Test::BaseInterface4::ice_isA(::std::string s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_BaseInterface4_ids, iceC_Test_BaseInterface4_ids + 2, s);
}

::std::vector<::std::string>
Test::BaseInterface4::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector<::std::string>(&iceC_Test_BaseInterface4_ids[0], &iceC_Test_BaseInterface4_ids[2]);
}

::std::string
Test::BaseInterface4::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::BaseInterface4::ice_staticId()
{
    static const ::std::string typeId = "::Test::BaseInterface4";
    return typeId;
}

/// \cond INTERNAL
bool
Test::BaseInterface4::_iceD_baseOp(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    this->baseOp(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::BaseInterface4::_iceD_baseOp2(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    int iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    ::std::string iceP_s;
    this->baseOp2(iceP_i, iceP_s, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_s);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::BaseInterface4::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_Test_BaseInterface4_ops, iceC_Test_BaseInterface4_ops + 6, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_Test_BaseInterface4_ops)
    {
        case 0:
        {
            return _iceD_baseOp(in, current);
        }
        case 1:
        {
            return _iceD_baseOp2(in, current);
        }
        case 2:
        {
            return _iceD_ice_id(in, current);
        }
        case 3:
        {
            return _iceD_ice_ids(in, current);
        }
        case 4:
        {
            return _iceD_ice_isA(in, current);
        }
        case 5:
        {
            return _iceD_ice_ping(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

bool
Test::BaseInterface5::ice_isA(::std::string s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_BaseInterface5_ids, iceC_Test_BaseInterface5_ids + 2, s);
}

::std::vector<::std::string>
Test::BaseInterface5::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector<::std::string>(&iceC_Test_BaseInterface5_ids[0], &iceC_Test_BaseInterface5_ids[2]);
}

::std::string
Test::BaseInterface5::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::BaseInterface5::ice_staticId()
{
    static const ::std::string typeId = "::Test::BaseInterface5";
    return typeId;
}

/// \cond INTERNAL
bool
Test::BaseInterface5::_iceD_baseOp(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    this->baseOp(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::BaseInterface5::_iceD_baseOp2(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    int iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    ::std::string iceP_s;
    this->baseOp2(iceP_i, iceP_s, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_s);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::BaseInterface5::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_Test_BaseInterface5_ops, iceC_Test_BaseInterface5_ops + 6, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_Test_BaseInterface5_ops)
    {
        case 0:
        {
            return _iceD_baseOp(in, current);
        }
        case 1:
        {
            return _iceD_baseOp2(in, current);
        }
        case 2:
        {
            return _iceD_ice_id(in, current);
        }
        case 3:
        {
            return _iceD_ice_ids(in, current);
        }
        case 4:
        {
            return _iceD_ice_isA(in, current);
        }
        case 5:
        {
            return _iceD_ice_ping(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

bool
Test::BaseInterface6::ice_isA(::std::string s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_BaseInterface6_ids, iceC_Test_BaseInterface6_ids + 2, s);
}

::std::vector<::std::string>
Test::BaseInterface6::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector<::std::string>(&iceC_Test_BaseInterface6_ids[0], &iceC_Test_BaseInterface6_ids[2]);
}

::std::string
Test::BaseInterface6::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::BaseInterface6::ice_staticId()
{
    static const ::std::string typeId = "::Test::BaseInterface6";
    return typeId;
}

/// \cond INTERNAL
bool
Test::BaseInterface6::_iceD_baseOp(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    this->baseOp(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::BaseInterface6::_iceD_baseOp2(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    int iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    ::std::string iceP_s;
    this->baseOp2(iceP_i, iceP_s, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_s);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::BaseInterface6::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_Test_BaseInterface6_ops, iceC_Test_BaseInterface6_ops + 6, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_Test_BaseInterface6_ops)
    {
        case 0:
        {
            return _iceD_baseOp(in, current);
        }
        case 1:
        {
            return _iceD_baseOp2(in, current);
        }
        case 2:
        {
            return _iceD_ice_id(in, current);
        }
        case 3:
        {
            return _iceD_ice_ids(in, current);
        }
        case 4:
        {
            return _iceD_ice_isA(in, current);
        }
        case 5:
        {
            return _iceD_ice_ping(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

bool
Test::BaseInterface7::ice_isA(::std::string s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_BaseInterface7_ids, iceC_Test_BaseInterface7_ids + 2, s);
}

::std::vector<::std::string>
Test::BaseInterface7::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector<::std::string>(&iceC_Test_BaseInterface7_ids[0], &iceC_Test_BaseInterface7_ids[2]);
}

::std::string
Test::BaseInterface7::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::BaseInterface7::ice_staticId()
{
    static const ::std::string typeId = "::Test::BaseInterface7";
    return typeId;
}

/// \cond INTERNAL
bool
Test::BaseInterface7::_iceD_baseOp(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    this->baseOp(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::BaseInterface7::_iceD_baseOp2(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    int iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    ::std::string iceP_s;
    this->baseOp2(iceP_i, iceP_s, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_s);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::BaseInterface7::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_Test_BaseInterface7_ops, iceC_Test_BaseInterface7_ops + 6, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_Test_BaseInterface7_ops)
    {
        case 0:
        {
            return _iceD_baseOp(in, current);
        }
        case 1:
        {
            return _iceD_baseOp2(in, current);
        }
        case 2:
        {
            return _iceD_ice_id(in, current);
        }
        case 3:
        {
            return _iceD_ice_ids(in, current);
        }
        case 4:
        {
            return _iceD_ice_isA(in, current);
        }
        case 5:
        {
            return _iceD_ice_ping(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

bool
Test::BaseInterface8::ice_isA(::std::string s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_BaseInterface8_ids, iceC_Test_BaseInterface8_ids + 2, s);
}

::std::vector<::std::string>
Test::BaseInterface8::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector<::std::string>(&iceC_Test_BaseInterface8_ids[0], &iceC_Test_BaseInterface8_ids[2]);
}

::std::string
Test::BaseInterface8::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::BaseInterface8::ice_staticId()
{
    static const ::std::string typeId = "::Test::BaseInterface8";
    return typeId;
}

/// \cond INTERNAL
bool
Test::BaseInterface8::_iceD_baseOp(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    this->baseOp(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::BaseInterface8::_iceD_baseOp2(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    int iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    ::std::string iceP_s;
    this->baseOp2(iceP_i, iceP_s, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_s);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::BaseInterface8::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_Test_BaseInterface8_ops, iceC_Test_BaseInterface8_ops + 6, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_Test_BaseInterface8_ops)
    {
        case 0:
        {
            return _iceD_baseOp(in, current);
        }
        case 1:
        {
            return _iceD_baseOp2(in, current);
        }
        case 2:
        {
            return _iceD_ice_id(in, current);
        }
        case 3:
        {
            return _iceD_ice_ids(in, current);
        }
        case 4:
        {
            return _iceD_ice_isA(in, current);
        }
        case 5:
        {
            return _iceD_ice_ping(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

bool
Test::BaseInterface9::ice_isA(::std::string s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_BaseInterface9_ids, iceC_Test_BaseInterface9_ids + 2, s);
}

::std::vector<::std::string>
Test::BaseInterface9::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector<::std::string>(&iceC_Test_BaseInterface9_ids[0], &iceC_Test_BaseInterface9_ids[2]);
}

::std::string
Test::BaseInterface9::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::BaseInterface9::ice_staticId()
{
    static const ::std::string typeId = "::Test::BaseInterface9";
    return typeId;
}

/// \cond INTERNAL
bool
Test::BaseInterface9::_iceD_baseOp(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    this->baseOp(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::BaseInterface9::_iceD_baseOp2(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    int iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    ::std::string iceP_s;
    this->baseOp2(iceP_i, iceP_s, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_s);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::BaseInterface9::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_Test_BaseInterface9_ops, iceC_Test_BaseInterface9_ops + 6, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_Test_BaseInterface9_ops)
    {
        case 0:
        {
            return _iceD_baseOp(in, current);
        }
        case 1:
        {
            return _iceD_baseOp2(in, current);
        }
        case 2:
        {
            return _iceD_ice_id(in, current);
        }
        case 3:
        {
            return _iceD_ice_ids(in, current);
        }
        case 4:
        {
            return _iceD_ice_isA(in, current);
        }
        case 5:
        {
            return _iceD_ice_ping(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

bool
Test::BaseInterface10::ice_isA(::std::string s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_BaseInterface10_ids, iceC_Test_BaseInterface10_ids + 2, s);
}

::std::vector<::std::string>
Test::BaseInterface10::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector<::std::string>(&iceC_Test_BaseInterface10_ids[0], &iceC_Test_BaseInterface10_ids[2]);
}

::std::string
Test::BaseInterface10::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::BaseInterface10::ice_staticId()
{
    static const ::std::string typeId = "::Test::BaseInterface10";
    return typeId;
}

/// \cond INTERNAL
bool
Test::BaseInterface10::_iceD_baseOp(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    this->baseOp(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::BaseInterface10::_iceD_baseOp2(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    int iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    ::std::string iceP_s;
    this->baseOp2(iceP_i, iceP_s, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_s);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::BaseInterface10::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_Test_BaseInterface10_ops, iceC_Test_BaseInterface10_ops + 6, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_Test_BaseInterface10_ops)
    {
        case 0:
        {
            return _iceD_baseOp(in, current);
        }
        case 1:
        {
            return _iceD_baseOp2(in, current);
        }
        case 2:
        {
            return _iceD_ice_id(in, current);
        }
        case 3:
        {
            return _iceD_ice_ids(in, current);
        }
        case 4:
        {
            return _iceD_ice_isA(in, current);
        }
        case 5:
        {
            return _iceD_ice_ping(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

bool
Test::BaseInterface11::ice_isA(::std::string s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_BaseInterface11_ids, iceC_Test_BaseInterface11_ids + 2, s);
}

::std::vector<::std::string>
Test::BaseInterface11::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector<::std::string>(&iceC_Test_BaseInterface11_ids[0], &iceC_Test_BaseInterface11_ids[2]);
}

::std::string
Test::BaseInterface11::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::BaseInterface11::ice_staticId()
{
    static const ::std::string typeId = "::Test::BaseInterface11";
    return typeId;
}

/// \cond INTERNAL
bool
Test::BaseInterface11::_iceD_baseOp(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    this->baseOp(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::BaseInterface11::_iceD_baseOp2(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    int iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    ::std::string iceP_s;
    this->baseOp2(iceP_i, iceP_s, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_s);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::BaseInterface11::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_Test_BaseInterface11_ops, iceC_Test_BaseInterface11_ops + 6, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_Test_BaseInterface11_ops)
    {
        case 0:
        {
            return _iceD_baseOp(in, current);
        }
        case 1:
        {
            return _iceD_baseOp2(in, current);
        }
        case 2:
        {
            return _iceD_ice_id(in, current);
        }
        case 3:
        {
            return _iceD_ice_ids(in, current);
        }
        case 4:
        {
            return _iceD_ice_isA(in, current);
        }
        case 5:
        {
            return _iceD_ice_ping(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

bool
Test::OptionalParameters0::ice_isA(::std::string s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_OptionalParameters0_ids, iceC_Test_OptionalParameters0_ids + 2, s);
}

::std::vector<::std::string>
Test::OptionalParameters0::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector<::std::string>(&iceC_Test_OptionalParameters0_ids[0], &iceC_Test_OptionalParameters0_ids[2]);
}

::std::string
Test::OptionalParameters0::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::OptionalParameters0::ice_staticId()
{
    static const ::std::string typeId = "::Test::OptionalParameters0";
    return typeId;
}

/// \cond INTERNAL
bool
Test::OptionalParameters0::_iceD_op1(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_firstName;
    Ice::optional<::std::string> iceP_secondName;
    Ice::optional<::std::string> iceP_emailAddress;
    istr->readAll(iceP_firstName);
    istr->readAll({1, 2}, iceP_secondName, iceP_emailAddress);
    inS.endReadParams();
    this->op1(::std::move(iceP_firstName), ::std::move(iceP_secondName), ::std::move(iceP_emailAddress), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::OptionalParameters0::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_Test_OptionalParameters0_ops, iceC_Test_OptionalParameters0_ops + 5, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_Test_OptionalParameters0_ops)
    {
        case 0:
        {
            return _iceD_ice_id(in, current);
        }
        case 1:
        {
            return _iceD_ice_ids(in, current);
        }
        case 2:
        {
            return _iceD_ice_isA(in, current);
        }
        case 3:
        {
            return _iceD_ice_ping(in, current);
        }
        case 4:
        {
            return _iceD_op1(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

bool
Test::OptionalParameters1::ice_isA(::std::string s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_OptionalParameters1_ids, iceC_Test_OptionalParameters1_ids + 2, s);
}

::std::vector<::std::string>
Test::OptionalParameters1::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector<::std::string>(&iceC_Test_OptionalParameters1_ids[0], &iceC_Test_OptionalParameters1_ids[2]);
}

::std::string
Test::OptionalParameters1::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::OptionalParameters1::ice_staticId()
{
    static const ::std::string typeId = "::Test::OptionalParameters1";
    return typeId;
}

/// \cond INTERNAL
bool
Test::OptionalParameters1::_iceD_op1(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_firstName;
    Ice::optional<::std::string> iceP_secondName;
    Ice::optional<::std::string> iceP_emailAddress;
    istr->readAll(iceP_firstName);
    istr->readAll({1, 2}, iceP_secondName, iceP_emailAddress);
    inS.endReadParams();
    this->op1(::std::move(iceP_firstName), ::std::move(iceP_secondName), ::std::move(iceP_emailAddress), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::OptionalParameters1::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_Test_OptionalParameters1_ops, iceC_Test_OptionalParameters1_ops + 5, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_Test_OptionalParameters1_ops)
    {
        case 0:
        {
            return _iceD_ice_id(in, current);
        }
        case 1:
        {
            return _iceD_ice_ids(in, current);
        }
        case 2:
        {
            return _iceD_ice_isA(in, current);
        }
        case 3:
        {
            return _iceD_ice_ping(in, current);
        }
        case 4:
        {
            return _iceD_op1(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

bool
Test::OptionalParameters2::ice_isA(::std::string s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_OptionalParameters2_ids, iceC_Test_OptionalParameters2_ids + 2, s);
}

::std::vector<::std::string>
Test::OptionalParameters2::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector<::std::string>(&iceC_Test_OptionalParameters2_ids[0], &iceC_Test_OptionalParameters2_ids[2]);
}

::std::string
Test::OptionalParameters2::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::OptionalParameters2::ice_staticId()
{
    static const ::std::string typeId = "::Test::OptionalParameters2";
    return typeId;
}

/// \cond INTERNAL
bool
Test::OptionalParameters2::_iceD_op1(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_firstName;
    Ice::optional<::std::string> iceP_emailAddress;
    Ice::optional<::std::string> iceP_secondName;
    istr->readAll(iceP_firstName);
    istr->readAll({1, 2}, iceP_emailAddress, iceP_secondName);
    inS.endReadParams();
    this->op1(::std::move(iceP_firstName), ::std::move(iceP_emailAddress), ::std::move(iceP_secondName), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::OptionalParameters2::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_Test_OptionalParameters2_ops, iceC_Test_OptionalParameters2_ops + 5, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_Test_OptionalParameters2_ops)
    {
        case 0:
        {
            return _iceD_ice_id(in, current);
        }
        case 1:
        {
            return _iceD_ice_ids(in, current);
        }
        case 2:
        {
            return _iceD_ice_isA(in, current);
        }
        case 3:
        {
            return _iceD_ice_ping(in, current);
        }
        case 4:
        {
            return _iceD_op1(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

bool
Test::OptionalParameters3::ice_isA(::std::string s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_OptionalParameters3_ids, iceC_Test_OptionalParameters3_ids + 2, s);
}

::std::vector<::std::string>
Test::OptionalParameters3::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector<::std::string>(&iceC_Test_OptionalParameters3_ids[0], &iceC_Test_OptionalParameters3_ids[2]);
}

::std::string
Test::OptionalParameters3::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::OptionalParameters3::ice_staticId()
{
    static const ::std::string typeId = "::Test::OptionalParameters3";
    return typeId;
}

/// \cond INTERNAL
bool
Test::OptionalParameters3::_iceD_op1(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_firstName;
    Ice::optional<::std::string> iceP_emailAddress;
    ::std::string iceP_secondName;
    istr->readAll(iceP_firstName, iceP_secondName);
    istr->readAll({1}, iceP_emailAddress);
    inS.endReadParams();
    this->op1(::std::move(iceP_firstName), ::std::move(iceP_emailAddress), ::std::move(iceP_secondName), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::OptionalParameters3::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_Test_OptionalParameters3_ops, iceC_Test_OptionalParameters3_ops + 5, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_Test_OptionalParameters3_ops)
    {
        case 0:
        {
            return _iceD_ice_id(in, current);
        }
        case 1:
        {
            return _iceD_ice_ids(in, current);
        }
        case 2:
        {
            return _iceD_ice_isA(in, current);
        }
        case 3:
        {
            return _iceD_ice_ping(in, current);
        }
        case 4:
        {
            return _iceD_op1(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

bool
Test::OptionalReturn0::ice_isA(::std::string s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_OptionalReturn0_ids, iceC_Test_OptionalReturn0_ids + 2, s);
}

::std::vector<::std::string>
Test::OptionalReturn0::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector<::std::string>(&iceC_Test_OptionalReturn0_ids[0], &iceC_Test_OptionalReturn0_ids[2]);
}

::std::string
Test::OptionalReturn0::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::OptionalReturn0::ice_staticId()
{
    static const ::std::string typeId = "::Test::OptionalReturn0";
    return typeId;
}

/// \cond INTERNAL
bool
Test::OptionalReturn0::_iceD_op(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    Ice::optional<int> ret = this->op(current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll({1}, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::OptionalReturn0::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_Test_OptionalReturn0_ops, iceC_Test_OptionalReturn0_ops + 5, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_Test_OptionalReturn0_ops)
    {
        case 0:
        {
            return _iceD_ice_id(in, current);
        }
        case 1:
        {
            return _iceD_ice_ids(in, current);
        }
        case 2:
        {
            return _iceD_ice_isA(in, current);
        }
        case 3:
        {
            return _iceD_ice_ping(in, current);
        }
        case 4:
        {
            return _iceD_op(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

bool
Test::OptionalReturn2::ice_isA(::std::string s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_OptionalReturn2_ids, iceC_Test_OptionalReturn2_ids + 2, s);
}

::std::vector<::std::string>
Test::OptionalReturn2::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector<::std::string>(&iceC_Test_OptionalReturn2_ids[0], &iceC_Test_OptionalReturn2_ids[2]);
}

::std::string
Test::OptionalReturn2::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::OptionalReturn2::ice_staticId()
{
    static const ::std::string typeId = "::Test::OptionalReturn2";
    return typeId;
}

/// \cond INTERNAL
bool
Test::OptionalReturn2::_iceD_op(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    Ice::optional<int> ret = this->op(current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll({1}, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::OptionalReturn2::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_Test_OptionalReturn2_ops, iceC_Test_OptionalReturn2_ops + 5, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_Test_OptionalReturn2_ops)
    {
        case 0:
        {
            return _iceD_ice_id(in, current);
        }
        case 1:
        {
            return _iceD_ice_ids(in, current);
        }
        case 2:
        {
            return _iceD_ice_isA(in, current);
        }
        case 3:
        {
            return _iceD_ice_ping(in, current);
        }
        case 4:
        {
            return _iceD_op(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

Test::EmptyClass1::~EmptyClass1()
{
}

const ::std::string&
Test::EmptyClass1::ice_staticId()
{
    static const ::std::string typeId = "::Test::EmptyClass1";
    return typeId;
}

Test::EmptyClass2::~EmptyClass2()
{
}

const ::std::string&
Test::EmptyClass2::ice_staticId()
{
    static const ::std::string typeId = "::Test::EmptyClass2";
    return typeId;
}

Test::EmptyClass3::~EmptyClass3()
{
}

const ::std::string&
Test::EmptyClass3::ice_staticId()
{
    static const ::std::string typeId = "::Test::EmptyClass3";
    return typeId;
}

Test::EmptyClass4::~EmptyClass4()
{
}

const ::std::string&
Test::EmptyClass4::ice_staticId()
{
    static const ::std::string typeId = "::Test::EmptyClass4";
    return typeId;
}

Test::EmptyClass5::~EmptyClass5()
{
}

const ::std::string&
Test::EmptyClass5::ice_staticId()
{
    static const ::std::string typeId = "::Test::EmptyClass5";
    return typeId;
}

Test::SimpleClass1::~SimpleClass1()
{
}

const ::std::string&
Test::SimpleClass1::ice_staticId()
{
    static const ::std::string typeId = "::Test::SimpleClass1";
    return typeId;
}

Test::SimpleClass2::~SimpleClass2()
{
}

const ::std::string&
Test::SimpleClass2::ice_staticId()
{
    static const ::std::string typeId = "::Test::SimpleClass2";
    return typeId;
}

Test::SimpleClass3::~SimpleClass3()
{
}

const ::std::string&
Test::SimpleClass3::ice_staticId()
{
    static const ::std::string typeId = "::Test::SimpleClass3";
    return typeId;
}

Test::SimpleClass4::~SimpleClass4()
{
}

const ::std::string&
Test::SimpleClass4::ice_staticId()
{
    static const ::std::string typeId = "::Test::SimpleClass4";
    return typeId;
}

Test::SimpleClass5::~SimpleClass5()
{
}

const ::std::string&
Test::SimpleClass5::ice_staticId()
{
    static const ::std::string typeId = "::Test::SimpleClass5";
    return typeId;
}

Test::SimpleClass6::~SimpleClass6()
{
}

const ::std::string&
Test::SimpleClass6::ice_staticId()
{
    static const ::std::string typeId = "::Test::SimpleClass6";
    return typeId;
}

Test::SimpleClass7::~SimpleClass7()
{
}

const ::std::string&
Test::SimpleClass7::ice_staticId()
{
    static const ::std::string typeId = "::Test::SimpleClass7";
    return typeId;
}

Test::Compact1::~Compact1()
{
}

const ::std::string&
Test::Compact1::ice_staticId()
{
    static const ::std::string typeId = "::Test::Compact1";
    return typeId;
}

Test::Derived1::~Derived1()
{
}

const ::std::string&
Test::Derived1::ice_staticId()
{
    static const ::std::string typeId = "::Test::Derived1";
    return typeId;
}

Test::Compact2::~Compact2()
{
}

const ::std::string&
Test::Compact2::ice_staticId()
{
    static const ::std::string typeId = "::Test::Compact2";
    return typeId;
}

Test::Optional0::~Optional0()
{
}

const ::std::string&
Test::Optional0::ice_staticId()
{
    static const ::std::string typeId = "::Test::Optional0";
    return typeId;
}

Test::Optional1::~Optional1()
{
}

const ::std::string&
Test::Optional1::ice_staticId()
{
    static const ::std::string typeId = "::Test::Optional1";
    return typeId;
}

Test::Optional2::~Optional2()
{
}

const ::std::string&
Test::Optional2::ice_staticId()
{
    static const ::std::string typeId = "::Test::Optional2";
    return typeId;
}

Test::Optional3::~Optional3()
{
}

const ::std::string&
Test::Optional3::ice_staticId()
{
    static const ::std::string typeId = "::Test::Optional3";
    return typeId;
}

Test::Optional4::~Optional4()
{
}

const ::std::string&
Test::Optional4::ice_staticId()
{
    static const ::std::string typeId = "::Test::Optional4";
    return typeId;
}

/// \cond INTERNAL
::std::shared_ptr<::Ice::ObjectPrx>
Test::Interface1Prx::_newInstance() const
{
    return ::IceInternal::createProxy<Interface1Prx>();
}
/// \endcond

const ::std::string&
Test::Interface1Prx::ice_staticId()
{
    return Interface1::ice_staticId();
}

/// \cond INTERNAL
::std::shared_ptr<::Ice::ObjectPrx>
Test::Interface2Prx::_newInstance() const
{
    return ::IceInternal::createProxy<Interface2Prx>();
}
/// \endcond

const ::std::string&
Test::Interface2Prx::ice_staticId()
{
    return Interface2::ice_staticId();
}

/// \cond INTERNAL
::std::shared_ptr<::Ice::ObjectPrx>
Test::Interface3Prx::_newInstance() const
{
    return ::IceInternal::createProxy<Interface3Prx>();
}
/// \endcond

const ::std::string&
Test::Interface3Prx::ice_staticId()
{
    return Interface3::ice_staticId();
}

/// \cond INTERNAL
::std::shared_ptr<::Ice::ObjectPrx>
Test::Interface4Prx::_newInstance() const
{
    return ::IceInternal::createProxy<Interface4Prx>();
}
/// \endcond

const ::std::string&
Test::Interface4Prx::ice_staticId()
{
    return Interface4::ice_staticId();
}

/// \cond INTERNAL
void
Test::BaseInterface1Prx::_iceI_baseOp1(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_Test_BaseInterface1_baseOp1_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Test::BaseInterface1Prx::_iceI_baseOp2(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::string>>& outAsync, int iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_BaseInterface1_baseOp2_name);
    outAsync->invoke(iceC_Test_BaseInterface1_baseOp2_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const Exception1&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
::std::shared_ptr<::Ice::ObjectPrx>
Test::BaseInterface1Prx::_newInstance() const
{
    return ::IceInternal::createProxy<BaseInterface1Prx>();
}
/// \endcond

const ::std::string&
Test::BaseInterface1Prx::ice_staticId()
{
    return BaseInterface1::ice_staticId();
}

/// \cond INTERNAL
void
Test::BaseInterface2Prx::_iceI_baseOp(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_Test_BaseInterface2_baseOp_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Test::BaseInterface2Prx::_iceI_baseOp2(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::string>>& outAsync, int iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_BaseInterface2_baseOp2_name);
    outAsync->invoke(iceC_Test_BaseInterface2_baseOp2_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const Exception1&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
::std::shared_ptr<::Ice::ObjectPrx>
Test::BaseInterface2Prx::_newInstance() const
{
    return ::IceInternal::createProxy<BaseInterface2Prx>();
}
/// \endcond

const ::std::string&
Test::BaseInterface2Prx::ice_staticId()
{
    return BaseInterface2::ice_staticId();
}

/// \cond INTERNAL
void
Test::BaseInterface3Prx::_iceI_baseOp(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_Test_BaseInterface3_baseOp_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Test::BaseInterface3Prx::_iceI_baseOp2(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::string>>& outAsync, int iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_BaseInterface3_baseOp2_name);
    outAsync->invoke(iceC_Test_BaseInterface3_baseOp2_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const Exception1&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
::std::shared_ptr<::Ice::ObjectPrx>
Test::BaseInterface3Prx::_newInstance() const
{
    return ::IceInternal::createProxy<BaseInterface3Prx>();
}
/// \endcond

const ::std::string&
Test::BaseInterface3Prx::ice_staticId()
{
    return BaseInterface3::ice_staticId();
}

/// \cond INTERNAL
void
Test::BaseInterface4Prx::_iceI_baseOp(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_Test_BaseInterface4_baseOp_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Test::BaseInterface4Prx::_iceI_baseOp2(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::string>>& outAsync, int iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_BaseInterface4_baseOp2_name);
    outAsync->invoke(iceC_Test_BaseInterface4_baseOp2_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const Exception1&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
::std::shared_ptr<::Ice::ObjectPrx>
Test::BaseInterface4Prx::_newInstance() const
{
    return ::IceInternal::createProxy<BaseInterface4Prx>();
}
/// \endcond

const ::std::string&
Test::BaseInterface4Prx::ice_staticId()
{
    return BaseInterface4::ice_staticId();
}

/// \cond INTERNAL
void
Test::BaseInterface5Prx::_iceI_baseOp(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_Test_BaseInterface5_baseOp_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Test::BaseInterface5Prx::_iceI_baseOp2(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::string>>& outAsync, int iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_BaseInterface5_baseOp2_name);
    outAsync->invoke(iceC_Test_BaseInterface5_baseOp2_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const Exception1&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
::std::shared_ptr<::Ice::ObjectPrx>
Test::BaseInterface5Prx::_newInstance() const
{
    return ::IceInternal::createProxy<BaseInterface5Prx>();
}
/// \endcond

const ::std::string&
Test::BaseInterface5Prx::ice_staticId()
{
    return BaseInterface5::ice_staticId();
}

/// \cond INTERNAL
void
Test::BaseInterface6Prx::_iceI_baseOp(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_Test_BaseInterface6_baseOp_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Test::BaseInterface6Prx::_iceI_baseOp2(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::string>>& outAsync, int iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_BaseInterface6_baseOp2_name);
    outAsync->invoke(iceC_Test_BaseInterface6_baseOp2_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const Exception1&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
::std::shared_ptr<::Ice::ObjectPrx>
Test::BaseInterface6Prx::_newInstance() const
{
    return ::IceInternal::createProxy<BaseInterface6Prx>();
}
/// \endcond

const ::std::string&
Test::BaseInterface6Prx::ice_staticId()
{
    return BaseInterface6::ice_staticId();
}

/// \cond INTERNAL
void
Test::BaseInterface7Prx::_iceI_baseOp(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_Test_BaseInterface7_baseOp_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Test::BaseInterface7Prx::_iceI_baseOp2(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::string>>& outAsync, int iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_BaseInterface7_baseOp2_name);
    outAsync->invoke(iceC_Test_BaseInterface7_baseOp2_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const Exception1&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
::std::shared_ptr<::Ice::ObjectPrx>
Test::BaseInterface7Prx::_newInstance() const
{
    return ::IceInternal::createProxy<BaseInterface7Prx>();
}
/// \endcond

const ::std::string&
Test::BaseInterface7Prx::ice_staticId()
{
    return BaseInterface7::ice_staticId();
}

/// \cond INTERNAL
void
Test::BaseInterface8Prx::_iceI_baseOp(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_Test_BaseInterface8_baseOp_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Test::BaseInterface8Prx::_iceI_baseOp2(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::string>>& outAsync, int iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_BaseInterface8_baseOp2_name);
    outAsync->invoke(iceC_Test_BaseInterface8_baseOp2_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const Exception1&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
::std::shared_ptr<::Ice::ObjectPrx>
Test::BaseInterface8Prx::_newInstance() const
{
    return ::IceInternal::createProxy<BaseInterface8Prx>();
}
/// \endcond

const ::std::string&
Test::BaseInterface8Prx::ice_staticId()
{
    return BaseInterface8::ice_staticId();
}

/// \cond INTERNAL
void
Test::BaseInterface9Prx::_iceI_baseOp(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_Test_BaseInterface9_baseOp_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Test::BaseInterface9Prx::_iceI_baseOp2(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::string>>& outAsync, int iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_BaseInterface9_baseOp2_name);
    outAsync->invoke(iceC_Test_BaseInterface9_baseOp2_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const Exception1&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
::std::shared_ptr<::Ice::ObjectPrx>
Test::BaseInterface9Prx::_newInstance() const
{
    return ::IceInternal::createProxy<BaseInterface9Prx>();
}
/// \endcond

const ::std::string&
Test::BaseInterface9Prx::ice_staticId()
{
    return BaseInterface9::ice_staticId();
}

/// \cond INTERNAL
void
Test::BaseInterface10Prx::_iceI_baseOp(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_Test_BaseInterface10_baseOp_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Test::BaseInterface10Prx::_iceI_baseOp2(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::string>>& outAsync, int iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_BaseInterface10_baseOp2_name);
    outAsync->invoke(iceC_Test_BaseInterface10_baseOp2_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const Exception1&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
::std::shared_ptr<::Ice::ObjectPrx>
Test::BaseInterface10Prx::_newInstance() const
{
    return ::IceInternal::createProxy<BaseInterface10Prx>();
}
/// \endcond

const ::std::string&
Test::BaseInterface10Prx::ice_staticId()
{
    return BaseInterface10::ice_staticId();
}

/// \cond INTERNAL
void
Test::BaseInterface11Prx::_iceI_baseOp(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_Test_BaseInterface11_baseOp_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Test::BaseInterface11Prx::_iceI_baseOp2(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::string>>& outAsync, int iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_BaseInterface11_baseOp2_name);
    outAsync->invoke(iceC_Test_BaseInterface11_baseOp2_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        [](const ::Ice::UserException& ex)
        {
            try
            {
                ex.ice_throw();
            }
            catch(const Exception1&)
            {
                throw;
            }
            catch(const ::Ice::UserException&)
            {
            }
        });
}
/// \endcond

/// \cond INTERNAL
::std::shared_ptr<::Ice::ObjectPrx>
Test::BaseInterface11Prx::_newInstance() const
{
    return ::IceInternal::createProxy<BaseInterface11Prx>();
}
/// \endcond

const ::std::string&
Test::BaseInterface11Prx::ice_staticId()
{
    return BaseInterface11::ice_staticId();
}

/// \cond INTERNAL
void
Test::OptionalParameters0Prx::_iceI_op1(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::string& iceP_firstName, const Ice::optional<::std::string>& iceP_secondName, const Ice::optional<::std::string>& iceP_emailAddress, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_Test_OptionalParameters0_op1_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_firstName);
            ostr->writeAll({1, 2}, iceP_secondName, iceP_emailAddress);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
::std::shared_ptr<::Ice::ObjectPrx>
Test::OptionalParameters0Prx::_newInstance() const
{
    return ::IceInternal::createProxy<OptionalParameters0Prx>();
}
/// \endcond

const ::std::string&
Test::OptionalParameters0Prx::ice_staticId()
{
    return OptionalParameters0::ice_staticId();
}

/// \cond INTERNAL
void
Test::OptionalParameters1Prx::_iceI_op1(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::string& iceP_firstName, const Ice::optional<::std::string>& iceP_secondName, const Ice::optional<::std::string>& iceP_emailAddress, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_Test_OptionalParameters1_op1_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_firstName);
            ostr->writeAll({1, 2}, iceP_secondName, iceP_emailAddress);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
::std::shared_ptr<::Ice::ObjectPrx>
Test::OptionalParameters1Prx::_newInstance() const
{
    return ::IceInternal::createProxy<OptionalParameters1Prx>();
}
/// \endcond

const ::std::string&
Test::OptionalParameters1Prx::ice_staticId()
{
    return OptionalParameters1::ice_staticId();
}

/// \cond INTERNAL
void
Test::OptionalParameters2Prx::_iceI_op1(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::string& iceP_firstName, const Ice::optional<::std::string>& iceP_emailAddress, const Ice::optional<::std::string>& iceP_secondName, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_Test_OptionalParameters2_op1_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_firstName);
            ostr->writeAll({1, 2}, iceP_emailAddress, iceP_secondName);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
::std::shared_ptr<::Ice::ObjectPrx>
Test::OptionalParameters2Prx::_newInstance() const
{
    return ::IceInternal::createProxy<OptionalParameters2Prx>();
}
/// \endcond

const ::std::string&
Test::OptionalParameters2Prx::ice_staticId()
{
    return OptionalParameters2::ice_staticId();
}

/// \cond INTERNAL
void
Test::OptionalParameters3Prx::_iceI_op1(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::string& iceP_firstName, const Ice::optional<::std::string>& iceP_emailAddress, const ::std::string& iceP_secondName, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_Test_OptionalParameters3_op1_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_firstName, iceP_secondName);
            ostr->writeAll({1}, iceP_emailAddress);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
::std::shared_ptr<::Ice::ObjectPrx>
Test::OptionalParameters3Prx::_newInstance() const
{
    return ::IceInternal::createProxy<OptionalParameters3Prx>();
}
/// \endcond

const ::std::string&
Test::OptionalParameters3Prx::ice_staticId()
{
    return OptionalParameters3::ice_staticId();
}

/// \cond INTERNAL
void
Test::OptionalReturn0Prx::_iceI_op(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Ice::optional<int>>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_OptionalReturn0_op_name);
    outAsync->invoke(iceC_Test_OptionalReturn0_op_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr,
        [](::Ice::InputStream* istr)
        {
            Ice::optional<int> ret;
            istr->readAll({1}, ret);
            return ret;
        });
}
/// \endcond

/// \cond INTERNAL
::std::shared_ptr<::Ice::ObjectPrx>
Test::OptionalReturn0Prx::_newInstance() const
{
    return ::IceInternal::createProxy<OptionalReturn0Prx>();
}
/// \endcond

const ::std::string&
Test::OptionalReturn0Prx::ice_staticId()
{
    return OptionalReturn0::ice_staticId();
}

/// \cond INTERNAL
void
Test::OptionalReturn2Prx::_iceI_op(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Ice::optional<int>>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_OptionalReturn2_op_name);
    outAsync->invoke(iceC_Test_OptionalReturn2_op_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr,
        [](::Ice::InputStream* istr)
        {
            Ice::optional<int> ret;
            istr->readAll({1}, ret);
            return ret;
        });
}
/// \endcond

/// \cond INTERNAL
::std::shared_ptr<::Ice::ObjectPrx>
Test::OptionalReturn2Prx::_newInstance() const
{
    return ::IceInternal::createProxy<OptionalReturn2Prx>();
}
/// \endcond

const ::std::string&
Test::OptionalReturn2Prx::ice_staticId()
{
    return OptionalReturn2::ice_staticId();
}

namespace Ice
{
}

#else // C++98 mapping

namespace
{

const ::std::string iceC_Test_BaseInterface1_baseOp1_name = "baseOp1";

const ::std::string iceC_Test_BaseInterface1_baseOp2_name = "baseOp2";

const ::std::string iceC_Test_BaseInterface2_baseOp_name = "baseOp";

const ::std::string iceC_Test_BaseInterface2_baseOp2_name = "baseOp2";

const ::std::string iceC_Test_BaseInterface3_baseOp_name = "baseOp";

const ::std::string iceC_Test_BaseInterface3_baseOp2_name = "baseOp2";

const ::std::string iceC_Test_BaseInterface4_baseOp_name = "baseOp";

const ::std::string iceC_Test_BaseInterface4_baseOp2_name = "baseOp2";

const ::std::string iceC_Test_BaseInterface5_baseOp_name = "baseOp";

const ::std::string iceC_Test_BaseInterface5_baseOp2_name = "baseOp2";

const ::std::string iceC_Test_BaseInterface6_baseOp_name = "baseOp";

const ::std::string iceC_Test_BaseInterface6_baseOp2_name = "baseOp2";

const ::std::string iceC_Test_BaseInterface7_baseOp_name = "baseOp";

const ::std::string iceC_Test_BaseInterface7_baseOp2_name = "baseOp2";

const ::std::string iceC_Test_BaseInterface8_baseOp_name = "baseOp";

const ::std::string iceC_Test_BaseInterface8_baseOp2_name = "baseOp2";

const ::std::string iceC_Test_BaseInterface9_baseOp_name = "baseOp";

const ::std::string iceC_Test_BaseInterface9_baseOp2_name = "baseOp2";

const ::std::string iceC_Test_BaseInterface10_baseOp_name = "baseOp";

const ::std::string iceC_Test_BaseInterface10_baseOp2_name = "baseOp2";

const ::std::string iceC_Test_BaseInterface11_baseOp_name = "baseOp";

const ::std::string iceC_Test_BaseInterface11_baseOp2_name = "baseOp2";

const ::std::string iceC_Test_OptionalParameters0_op1_name = "op1";

const ::std::string iceC_Test_OptionalParameters1_op1_name = "op1";

const ::std::string iceC_Test_OptionalParameters2_op1_name = "op1";

const ::std::string iceC_Test_OptionalParameters3_op1_name = "op1";

const ::std::string iceC_Test_OptionalReturn0_op_name = "op";

const ::std::string iceC_Test_OptionalReturn2_op_name = "op";

}

namespace
{

const ::IceInternal::DefaultUserExceptionFactoryInit< ::Test::Exception1> iceC_Test_Exception1_init("::Test::Exception1");

}

Test::Exception1::Exception1(const ::std::string& str, bool b) :
    ::Ice::UserException(),
    str(str),
    b(b)
{
}

#ifdef ICE_CPP11_COMPILER
Test::Exception1::~Exception1()
{
}
#else
Test::Exception1::~Exception1() throw()
{
}
#endif

::std::string
Test::Exception1::ice_id() const
{
    return "::Test::Exception1";
}

Test::Exception1*
Test::Exception1::ice_clone() const
{
    return new Exception1(*this);
}

void
Test::Exception1::ice_throw() const
{
    throw *this;
}

/// \cond STREAM
void
Test::Exception1::_writeImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice("::Test::Exception1", -1, true);
    ::Ice::StreamWriter< Exception1, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Test::Exception1::_readImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< Exception1, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

namespace
{

const ::IceInternal::DefaultUserExceptionFactoryInit< ::Test::Exception2> iceC_Test_Exception2_init("::Test::Exception2");

}

Test::Exception2::Exception2(const ::std::string& str, bool b) :
    ::Ice::UserException(),
    str(str),
    b(b)
{
}

#ifdef ICE_CPP11_COMPILER
Test::Exception2::~Exception2()
{
}
#else
Test::Exception2::~Exception2() throw()
{
}
#endif

::std::string
Test::Exception2::ice_id() const
{
    return "::Test::Exception2";
}

Test::Exception2*
Test::Exception2::ice_clone() const
{
    return new Exception2(*this);
}

void
Test::Exception2::ice_throw() const
{
    throw *this;
}

/// \cond STREAM
void
Test::Exception2::_writeImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice("::Test::Exception2", -1, true);
    ::Ice::StreamWriter< Exception2, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Test::Exception2::_readImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< Exception2, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

namespace
{

const ::IceInternal::DefaultUserExceptionFactoryInit< ::Test::Exception3> iceC_Test_Exception3_init("::Test::Exception3");

}

Test::Exception3::Exception3(const ::std::string& str, bool b) :
    ::Ice::UserException(),
    str(str),
    b(b)
{
}

#ifdef ICE_CPP11_COMPILER
Test::Exception3::~Exception3()
{
}
#else
Test::Exception3::~Exception3() throw()
{
}
#endif

::std::string
Test::Exception3::ice_id() const
{
    return "::Test::Exception3";
}

Test::Exception3*
Test::Exception3::ice_clone() const
{
    return new Exception3(*this);
}

void
Test::Exception3::ice_throw() const
{
    throw *this;
}

/// \cond STREAM
void
Test::Exception3::_writeImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice("::Test::Exception3", -1, true);
    ::Ice::StreamWriter< Exception3, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Test::Exception3::_readImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< Exception3, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

namespace
{

const ::IceInternal::DefaultUserExceptionFactoryInit< ::Test::Exception4> iceC_Test_Exception4_init("::Test::Exception4");

}

Test::Exception4::Exception4(const ::std::string& str, bool b) :
    ::Ice::UserException(),
    str(str),
    b(b)
{
}

#ifdef ICE_CPP11_COMPILER
Test::Exception4::~Exception4()
{
}
#else
Test::Exception4::~Exception4() throw()
{
}
#endif

::std::string
Test::Exception4::ice_id() const
{
    return "::Test::Exception4";
}

Test::Exception4*
Test::Exception4::ice_clone() const
{
    return new Exception4(*this);
}

void
Test::Exception4::ice_throw() const
{
    throw *this;
}

/// \cond STREAM
void
Test::Exception4::_writeImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice("::Test::Exception4", -1, true);
    ::Ice::StreamWriter< Exception4, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Test::Exception4::_readImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< Exception4, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

namespace
{

const ::IceInternal::DefaultUserExceptionFactoryInit< ::Test::Exception5> iceC_Test_Exception5_init("::Test::Exception5");

}

#ifdef ICE_CPP11_COMPILER
Test::Exception5::~Exception5()
{
}
#else
Test::Exception5::~Exception5() throw()
{
}
#endif

::std::string
Test::Exception5::ice_id() const
{
    return "::Test::Exception5";
}

Test::Exception5*
Test::Exception5::ice_clone() const
{
    return new Exception5(*this);
}

void
Test::Exception5::ice_throw() const
{
    throw *this;
}

/// \cond STREAM
void
Test::Exception5::_writeImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice("::Test::Exception5", -1, true);
    ::Ice::StreamWriter< Exception5, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Test::Exception5::_readImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< Exception5, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

namespace
{

const ::IceInternal::DefaultUserExceptionFactoryInit< ::Test::Exception6> iceC_Test_Exception6_init("::Test::Exception6");

}

Test::Exception6::Exception6(const ::std::string& str, bool b) :
    ::Ice::UserException(),
    str(str),
    b(b)
{
}

#ifdef ICE_CPP11_COMPILER
Test::Exception6::~Exception6()
{
}
#else
Test::Exception6::~Exception6() throw()
{
}
#endif

::std::string
Test::Exception6::ice_id() const
{
    return "::Test::Exception6";
}

Test::Exception6*
Test::Exception6::ice_clone() const
{
    return new Exception6(*this);
}

void
Test::Exception6::ice_throw() const
{
    throw *this;
}

/// \cond STREAM
void
Test::Exception6::_writeImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice("::Test::Exception6", -1, true);
    ::Ice::StreamWriter< Exception6, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Test::Exception6::_readImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< Exception6, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

namespace
{

const ::IceInternal::DefaultUserExceptionFactoryInit< ::Test::OptionalEx0> iceC_Test_OptionalEx0_init("::Test::OptionalEx0");

}

Test::OptionalEx0::OptionalEx0(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& secondName, const IceUtil::Optional< ::std::string>& emailAddress) :
    ::Ice::UserException(),
    firstName(firstName),
    secondName(secondName),
    emailAddress(emailAddress)
{
}

#ifdef ICE_CPP11_COMPILER
Test::OptionalEx0::~OptionalEx0()
{
}
#else
Test::OptionalEx0::~OptionalEx0() throw()
{
}
#endif

::std::string
Test::OptionalEx0::ice_id() const
{
    return "::Test::OptionalEx0";
}

Test::OptionalEx0*
Test::OptionalEx0::ice_clone() const
{
    return new OptionalEx0(*this);
}

void
Test::OptionalEx0::ice_throw() const
{
    throw *this;
}

/// \cond STREAM
void
Test::OptionalEx0::_writeImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice("::Test::OptionalEx0", -1, true);
    ::Ice::StreamWriter< OptionalEx0, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Test::OptionalEx0::_readImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< OptionalEx0, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

namespace
{

const ::IceInternal::DefaultUserExceptionFactoryInit< ::Test::OptionalEx1> iceC_Test_OptionalEx1_init("::Test::OptionalEx1");

}

Test::OptionalEx1::OptionalEx1(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& secondName, const IceUtil::Optional< ::std::string>& emailAddress) :
    ::Ice::UserException(),
    firstName(firstName),
    secondName(secondName),
    emailAddress(emailAddress)
{
}

#ifdef ICE_CPP11_COMPILER
Test::OptionalEx1::~OptionalEx1()
{
}
#else
Test::OptionalEx1::~OptionalEx1() throw()
{
}
#endif

::std::string
Test::OptionalEx1::ice_id() const
{
    return "::Test::OptionalEx1";
}

Test::OptionalEx1*
Test::OptionalEx1::ice_clone() const
{
    return new OptionalEx1(*this);
}

void
Test::OptionalEx1::ice_throw() const
{
    throw *this;
}

/// \cond STREAM
void
Test::OptionalEx1::_writeImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice("::Test::OptionalEx1", -1, true);
    ::Ice::StreamWriter< OptionalEx1, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Test::OptionalEx1::_readImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< OptionalEx1, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

namespace
{

const ::IceInternal::DefaultUserExceptionFactoryInit< ::Test::OptionalEx2> iceC_Test_OptionalEx2_init("::Test::OptionalEx2");

}

Test::OptionalEx2::OptionalEx2(const ::std::string& firstName, const ::std::string& secondName, const IceUtil::Optional< ::std::string>& emailAddress) :
    ::Ice::UserException(),
    firstName(firstName),
    secondName(secondName),
    emailAddress(emailAddress)
{
}

#ifdef ICE_CPP11_COMPILER
Test::OptionalEx2::~OptionalEx2()
{
}
#else
Test::OptionalEx2::~OptionalEx2() throw()
{
}
#endif

::std::string
Test::OptionalEx2::ice_id() const
{
    return "::Test::OptionalEx2";
}

Test::OptionalEx2*
Test::OptionalEx2::ice_clone() const
{
    return new OptionalEx2(*this);
}

void
Test::OptionalEx2::ice_throw() const
{
    throw *this;
}

/// \cond STREAM
void
Test::OptionalEx2::_writeImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice("::Test::OptionalEx2", -1, true);
    ::Ice::StreamWriter< OptionalEx2, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Test::OptionalEx2::_readImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< OptionalEx2, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

namespace
{

const ::IceInternal::DefaultUserExceptionFactoryInit< ::Test::OptionalEx3> iceC_Test_OptionalEx3_init("::Test::OptionalEx3");

}

Test::OptionalEx3::OptionalEx3(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& secondName, const IceUtil::Optional< ::std::string>& emailAddress) :
    ::Ice::UserException(),
    firstName(firstName),
    secondName(secondName),
    emailAddress(emailAddress)
{
}

#ifdef ICE_CPP11_COMPILER
Test::OptionalEx3::~OptionalEx3()
{
}
#else
Test::OptionalEx3::~OptionalEx3() throw()
{
}
#endif

::std::string
Test::OptionalEx3::ice_id() const
{
    return "::Test::OptionalEx3";
}

Test::OptionalEx3*
Test::OptionalEx3::ice_clone() const
{
    return new OptionalEx3(*this);
}

void
Test::OptionalEx3::ice_throw() const
{
    throw *this;
}

/// \cond STREAM
void
Test::OptionalEx3::_writeImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice("::Test::OptionalEx3", -1, true);
    ::Ice::StreamWriter< OptionalEx3, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Test::OptionalEx3::_readImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< OptionalEx3, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

namespace
{

const ::IceInternal::DefaultUserExceptionFactoryInit< ::Test::OptionalEx4> iceC_Test_OptionalEx4_init("::Test::OptionalEx4");

}

Test::OptionalEx4::OptionalEx4(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& secondName, const IceUtil::Optional< ::std::string>& emailAddress) :
    ::Ice::UserException(),
    firstName(firstName),
    secondName(secondName),
    emailAddress(emailAddress)
{
}

#ifdef ICE_CPP11_COMPILER
Test::OptionalEx4::~OptionalEx4()
{
}
#else
Test::OptionalEx4::~OptionalEx4() throw()
{
}
#endif

::std::string
Test::OptionalEx4::ice_id() const
{
    return "::Test::OptionalEx4";
}

Test::OptionalEx4*
Test::OptionalEx4::ice_clone() const
{
    return new OptionalEx4(*this);
}

void
Test::OptionalEx4::ice_throw() const
{
    throw *this;
}

/// \cond STREAM
void
Test::OptionalEx4::_writeImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice("::Test::OptionalEx4", -1, true);
    ::Ice::StreamWriter< OptionalEx4, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Test::OptionalEx4::_readImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< OptionalEx4, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(Interface1* p) { return p; }

void
::IceProxy::Test::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< Interface1>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new Interface1;
        v->_copyFrom(proxy);
    }
}
/// \endcond

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::Test::Interface1::_newInstance() const
{
    return new Interface1;
}
/// \endcond

const ::std::string&
IceProxy::Test::Interface1::ice_staticId()
{
    return ::Test::Interface1::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(Interface2* p) { return p; }

void
::IceProxy::Test::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< Interface2>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new Interface2;
        v->_copyFrom(proxy);
    }
}
/// \endcond

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::Test::Interface2::_newInstance() const
{
    return new Interface2;
}
/// \endcond

const ::std::string&
IceProxy::Test::Interface2::ice_staticId()
{
    return ::Test::Interface2::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(Interface3* p) { return p; }

void
::IceProxy::Test::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< Interface3>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new Interface3;
        v->_copyFrom(proxy);
    }
}
/// \endcond

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::Test::Interface3::_newInstance() const
{
    return new Interface3;
}
/// \endcond

const ::std::string&
IceProxy::Test::Interface3::ice_staticId()
{
    return ::Test::Interface3::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(Interface4* p) { return p; }

void
::IceProxy::Test::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< Interface4>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new Interface4;
        v->_copyFrom(proxy);
    }
}
/// \endcond

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::Test::Interface4::_newInstance() const
{
    return new Interface4;
}
/// \endcond

const ::std::string&
IceProxy::Test::Interface4::ice_staticId()
{
    return ::Test::Interface4::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(EmptyClass1* p) { return p; }

void
::IceProxy::Test::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< EmptyClass1>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new EmptyClass1;
        v->_copyFrom(proxy);
    }
}
/// \endcond

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::Test::EmptyClass1::_newInstance() const
{
    return new EmptyClass1;
}
/// \endcond

const ::std::string&
IceProxy::Test::EmptyClass1::ice_staticId()
{
    return ::Test::EmptyClass1::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(EmptyClass2* p) { return p; }

void
::IceProxy::Test::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< EmptyClass2>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new EmptyClass2;
        v->_copyFrom(proxy);
    }
}
/// \endcond

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::Test::EmptyClass2::_newInstance() const
{
    return new EmptyClass2;
}
/// \endcond

const ::std::string&
IceProxy::Test::EmptyClass2::ice_staticId()
{
    return ::Test::EmptyClass2::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(EmptyClass3* p) { return p; }

void
::IceProxy::Test::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< EmptyClass3>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new EmptyClass3;
        v->_copyFrom(proxy);
    }
}
/// \endcond

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::Test::EmptyClass3::_newInstance() const
{
    return new EmptyClass3;
}
/// \endcond

const ::std::string&
IceProxy::Test::EmptyClass3::ice_staticId()
{
    return ::Test::EmptyClass3::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(EmptyClass4* p) { return p; }

void
::IceProxy::Test::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< EmptyClass4>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new EmptyClass4;
        v->_copyFrom(proxy);
    }
}
/// \endcond

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::Test::EmptyClass4::_newInstance() const
{
    return new EmptyClass4;
}
/// \endcond

const ::std::string&
IceProxy::Test::EmptyClass4::ice_staticId()
{
    return ::Test::EmptyClass4::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(EmptyClass5* p) { return p; }

void
::IceProxy::Test::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< EmptyClass5>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new EmptyClass5;
        v->_copyFrom(proxy);
    }
}
/// \endcond

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::Test::EmptyClass5::_newInstance() const
{
    return new EmptyClass5;
}
/// \endcond

const ::std::string&
IceProxy::Test::EmptyClass5::ice_staticId()
{
    return ::Test::EmptyClass5::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(SimpleClass1* p) { return p; }

void
::IceProxy::Test::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< SimpleClass1>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new SimpleClass1;
        v->_copyFrom(proxy);
    }
}
/// \endcond

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::Test::SimpleClass1::_newInstance() const
{
    return new SimpleClass1;
}
/// \endcond

const ::std::string&
IceProxy::Test::SimpleClass1::ice_staticId()
{
    return ::Test::SimpleClass1::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(SimpleClass2* p) { return p; }

void
::IceProxy::Test::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< SimpleClass2>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new SimpleClass2;
        v->_copyFrom(proxy);
    }
}
/// \endcond

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::Test::SimpleClass2::_newInstance() const
{
    return new SimpleClass2;
}
/// \endcond

const ::std::string&
IceProxy::Test::SimpleClass2::ice_staticId()
{
    return ::Test::SimpleClass2::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(SimpleClass3* p) { return p; }

void
::IceProxy::Test::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< SimpleClass3>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new SimpleClass3;
        v->_copyFrom(proxy);
    }
}
/// \endcond

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::Test::SimpleClass3::_newInstance() const
{
    return new SimpleClass3;
}
/// \endcond

const ::std::string&
IceProxy::Test::SimpleClass3::ice_staticId()
{
    return ::Test::SimpleClass3::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(SimpleClass4* p) { return p; }

void
::IceProxy::Test::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< SimpleClass4>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new SimpleClass4;
        v->_copyFrom(proxy);
    }
}
/// \endcond

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::Test::SimpleClass4::_newInstance() const
{
    return new SimpleClass4;
}
/// \endcond

const ::std::string&
IceProxy::Test::SimpleClass4::ice_staticId()
{
    return ::Test::SimpleClass4::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(SimpleClass5* p) { return p; }

void
::IceProxy::Test::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< SimpleClass5>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new SimpleClass5;
        v->_copyFrom(proxy);
    }
}
/// \endcond

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::Test::SimpleClass5::_newInstance() const
{
    return new SimpleClass5;
}
/// \endcond

const ::std::string&
IceProxy::Test::SimpleClass5::ice_staticId()
{
    return ::Test::SimpleClass5::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(SimpleClass6* p) { return p; }

void
::IceProxy::Test::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< SimpleClass6>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new SimpleClass6;
        v->_copyFrom(proxy);
    }
}
/// \endcond

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::Test::SimpleClass6::_newInstance() const
{
    return new SimpleClass6;
}
/// \endcond

const ::std::string&
IceProxy::Test::SimpleClass6::ice_staticId()
{
    return ::Test::SimpleClass6::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(SimpleClass7* p) { return p; }

void
::IceProxy::Test::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< SimpleClass7>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new SimpleClass7;
        v->_copyFrom(proxy);
    }
}
/// \endcond

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::Test::SimpleClass7::_newInstance() const
{
    return new SimpleClass7;
}
/// \endcond

const ::std::string&
IceProxy::Test::SimpleClass7::ice_staticId()
{
    return ::Test::SimpleClass7::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(BaseInterface1* p) { return p; }

void
::IceProxy::Test::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< BaseInterface1>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new BaseInterface1;
        v->_copyFrom(proxy);
    }
}
/// \endcond

::Ice::AsyncResultPtr
IceProxy::Test::BaseInterface1::_iceI_begin_baseOp1(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_BaseInterface1_baseOp1_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_BaseInterface1_baseOp1_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Test_BaseInterface1_baseOp1_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Test::BaseInterface1::end_baseOp1(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_Test_BaseInterface1_baseOp1_name);
}

::Ice::AsyncResultPtr
IceProxy::Test::BaseInterface1::_iceI_begin_baseOp2(::Ice::Int iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_BaseInterface1_baseOp2_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_BaseInterface1_baseOp2_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_BaseInterface1_baseOp2_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_BaseInterface1_baseOp2_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Test::BaseInterface1::end_baseOp2(::std::string& iceP_s, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_BaseInterface1_baseOp2_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Test::Exception1&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_s);
    result->_endReadParams();
}

void IceProxy::Test::BaseInterface1::_iceI_end_baseOp2(::std::string& iceP_s, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_BaseInterface1_baseOp2_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Test::Exception1&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_s);
    result->_endReadParams();
}

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::Test::BaseInterface1::_newInstance() const
{
    return new BaseInterface1;
}
/// \endcond

const ::std::string&
IceProxy::Test::BaseInterface1::ice_staticId()
{
    return ::Test::BaseInterface1::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(BaseInterface2* p) { return p; }

void
::IceProxy::Test::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< BaseInterface2>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new BaseInterface2;
        v->_copyFrom(proxy);
    }
}
/// \endcond

::Ice::AsyncResultPtr
IceProxy::Test::BaseInterface2::_iceI_begin_baseOp(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_BaseInterface2_baseOp_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_BaseInterface2_baseOp_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Test_BaseInterface2_baseOp_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Test::BaseInterface2::end_baseOp(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_Test_BaseInterface2_baseOp_name);
}

::Ice::AsyncResultPtr
IceProxy::Test::BaseInterface2::_iceI_begin_baseOp2(::Ice::Int iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_BaseInterface2_baseOp2_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_BaseInterface2_baseOp2_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_BaseInterface2_baseOp2_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_BaseInterface2_baseOp2_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Test::BaseInterface2::end_baseOp2(::std::string& iceP_s, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_BaseInterface2_baseOp2_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Test::Exception1&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_s);
    result->_endReadParams();
}

void IceProxy::Test::BaseInterface2::_iceI_end_baseOp2(::std::string& iceP_s, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_BaseInterface2_baseOp2_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Test::Exception1&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_s);
    result->_endReadParams();
}

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::Test::BaseInterface2::_newInstance() const
{
    return new BaseInterface2;
}
/// \endcond

const ::std::string&
IceProxy::Test::BaseInterface2::ice_staticId()
{
    return ::Test::BaseInterface2::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(BaseInterface3* p) { return p; }

void
::IceProxy::Test::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< BaseInterface3>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new BaseInterface3;
        v->_copyFrom(proxy);
    }
}
/// \endcond

::Ice::AsyncResultPtr
IceProxy::Test::BaseInterface3::_iceI_begin_baseOp(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_BaseInterface3_baseOp_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_BaseInterface3_baseOp_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Test_BaseInterface3_baseOp_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Test::BaseInterface3::end_baseOp(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_Test_BaseInterface3_baseOp_name);
}

::Ice::AsyncResultPtr
IceProxy::Test::BaseInterface3::_iceI_begin_baseOp2(::Ice::Int iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_BaseInterface3_baseOp2_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_BaseInterface3_baseOp2_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_BaseInterface3_baseOp2_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_BaseInterface3_baseOp2_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Test::BaseInterface3::end_baseOp2(::std::string& iceP_s, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_BaseInterface3_baseOp2_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Test::Exception1&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_s);
    result->_endReadParams();
}

void IceProxy::Test::BaseInterface3::_iceI_end_baseOp2(::std::string& iceP_s, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_BaseInterface3_baseOp2_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Test::Exception1&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_s);
    result->_endReadParams();
}

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::Test::BaseInterface3::_newInstance() const
{
    return new BaseInterface3;
}
/// \endcond

const ::std::string&
IceProxy::Test::BaseInterface3::ice_staticId()
{
    return ::Test::BaseInterface3::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(BaseInterface4* p) { return p; }

void
::IceProxy::Test::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< BaseInterface4>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new BaseInterface4;
        v->_copyFrom(proxy);
    }
}
/// \endcond

::Ice::AsyncResultPtr
IceProxy::Test::BaseInterface4::_iceI_begin_baseOp(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_BaseInterface4_baseOp_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_BaseInterface4_baseOp_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Test_BaseInterface4_baseOp_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Test::BaseInterface4::end_baseOp(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_Test_BaseInterface4_baseOp_name);
}

::Ice::AsyncResultPtr
IceProxy::Test::BaseInterface4::_iceI_begin_baseOp2(::Ice::Int iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_BaseInterface4_baseOp2_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_BaseInterface4_baseOp2_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_BaseInterface4_baseOp2_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_BaseInterface4_baseOp2_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Test::BaseInterface4::end_baseOp2(::std::string& iceP_s, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_BaseInterface4_baseOp2_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Test::Exception1&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_s);
    result->_endReadParams();
}

void IceProxy::Test::BaseInterface4::_iceI_end_baseOp2(::std::string& iceP_s, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_BaseInterface4_baseOp2_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Test::Exception1&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_s);
    result->_endReadParams();
}

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::Test::BaseInterface4::_newInstance() const
{
    return new BaseInterface4;
}
/// \endcond

const ::std::string&
IceProxy::Test::BaseInterface4::ice_staticId()
{
    return ::Test::BaseInterface4::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(BaseInterface5* p) { return p; }

void
::IceProxy::Test::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< BaseInterface5>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new BaseInterface5;
        v->_copyFrom(proxy);
    }
}
/// \endcond

::Ice::AsyncResultPtr
IceProxy::Test::BaseInterface5::_iceI_begin_baseOp(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_BaseInterface5_baseOp_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_BaseInterface5_baseOp_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Test_BaseInterface5_baseOp_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Test::BaseInterface5::end_baseOp(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_Test_BaseInterface5_baseOp_name);
}

::Ice::AsyncResultPtr
IceProxy::Test::BaseInterface5::_iceI_begin_baseOp2(::Ice::Int iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_BaseInterface5_baseOp2_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_BaseInterface5_baseOp2_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_BaseInterface5_baseOp2_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_BaseInterface5_baseOp2_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Test::BaseInterface5::end_baseOp2(::std::string& iceP_s, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_BaseInterface5_baseOp2_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Test::Exception1&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_s);
    result->_endReadParams();
}

void IceProxy::Test::BaseInterface5::_iceI_end_baseOp2(::std::string& iceP_s, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_BaseInterface5_baseOp2_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Test::Exception1&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_s);
    result->_endReadParams();
}

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::Test::BaseInterface5::_newInstance() const
{
    return new BaseInterface5;
}
/// \endcond

const ::std::string&
IceProxy::Test::BaseInterface5::ice_staticId()
{
    return ::Test::BaseInterface5::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(BaseInterface6* p) { return p; }

void
::IceProxy::Test::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< BaseInterface6>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new BaseInterface6;
        v->_copyFrom(proxy);
    }
}
/// \endcond

::Ice::AsyncResultPtr
IceProxy::Test::BaseInterface6::_iceI_begin_baseOp(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_BaseInterface6_baseOp_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_BaseInterface6_baseOp_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Test_BaseInterface6_baseOp_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Test::BaseInterface6::end_baseOp(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_Test_BaseInterface6_baseOp_name);
}

::Ice::AsyncResultPtr
IceProxy::Test::BaseInterface6::_iceI_begin_baseOp2(::Ice::Int iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_BaseInterface6_baseOp2_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_BaseInterface6_baseOp2_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_BaseInterface6_baseOp2_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_BaseInterface6_baseOp2_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Test::BaseInterface6::end_baseOp2(::std::string& iceP_s, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_BaseInterface6_baseOp2_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Test::Exception1&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_s);
    result->_endReadParams();
}

void IceProxy::Test::BaseInterface6::_iceI_end_baseOp2(::std::string& iceP_s, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_BaseInterface6_baseOp2_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Test::Exception1&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_s);
    result->_endReadParams();
}

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::Test::BaseInterface6::_newInstance() const
{
    return new BaseInterface6;
}
/// \endcond

const ::std::string&
IceProxy::Test::BaseInterface6::ice_staticId()
{
    return ::Test::BaseInterface6::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(BaseInterface7* p) { return p; }

void
::IceProxy::Test::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< BaseInterface7>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new BaseInterface7;
        v->_copyFrom(proxy);
    }
}
/// \endcond

::Ice::AsyncResultPtr
IceProxy::Test::BaseInterface7::_iceI_begin_baseOp(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_BaseInterface7_baseOp_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_BaseInterface7_baseOp_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Test_BaseInterface7_baseOp_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Test::BaseInterface7::end_baseOp(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_Test_BaseInterface7_baseOp_name);
}

::Ice::AsyncResultPtr
IceProxy::Test::BaseInterface7::_iceI_begin_baseOp2(::Ice::Int iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_BaseInterface7_baseOp2_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_BaseInterface7_baseOp2_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_BaseInterface7_baseOp2_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_BaseInterface7_baseOp2_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Test::BaseInterface7::end_baseOp2(::std::string& iceP_s, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_BaseInterface7_baseOp2_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Test::Exception1&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_s);
    result->_endReadParams();
}

void IceProxy::Test::BaseInterface7::_iceI_end_baseOp2(::std::string& iceP_s, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_BaseInterface7_baseOp2_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Test::Exception1&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_s);
    result->_endReadParams();
}

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::Test::BaseInterface7::_newInstance() const
{
    return new BaseInterface7;
}
/// \endcond

const ::std::string&
IceProxy::Test::BaseInterface7::ice_staticId()
{
    return ::Test::BaseInterface7::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(BaseInterface8* p) { return p; }

void
::IceProxy::Test::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< BaseInterface8>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new BaseInterface8;
        v->_copyFrom(proxy);
    }
}
/// \endcond

::Ice::AsyncResultPtr
IceProxy::Test::BaseInterface8::_iceI_begin_baseOp(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_BaseInterface8_baseOp_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_BaseInterface8_baseOp_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Test_BaseInterface8_baseOp_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Test::BaseInterface8::end_baseOp(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_Test_BaseInterface8_baseOp_name);
}

::Ice::AsyncResultPtr
IceProxy::Test::BaseInterface8::_iceI_begin_baseOp2(::Ice::Int iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_BaseInterface8_baseOp2_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_BaseInterface8_baseOp2_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_BaseInterface8_baseOp2_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_BaseInterface8_baseOp2_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Test::BaseInterface8::end_baseOp2(::std::string& iceP_s, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_BaseInterface8_baseOp2_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Test::Exception1&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_s);
    result->_endReadParams();
}

void IceProxy::Test::BaseInterface8::_iceI_end_baseOp2(::std::string& iceP_s, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_BaseInterface8_baseOp2_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Test::Exception1&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_s);
    result->_endReadParams();
}

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::Test::BaseInterface8::_newInstance() const
{
    return new BaseInterface8;
}
/// \endcond

const ::std::string&
IceProxy::Test::BaseInterface8::ice_staticId()
{
    return ::Test::BaseInterface8::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(BaseInterface9* p) { return p; }

void
::IceProxy::Test::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< BaseInterface9>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new BaseInterface9;
        v->_copyFrom(proxy);
    }
}
/// \endcond

::Ice::AsyncResultPtr
IceProxy::Test::BaseInterface9::_iceI_begin_baseOp(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_BaseInterface9_baseOp_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_BaseInterface9_baseOp_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Test_BaseInterface9_baseOp_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Test::BaseInterface9::end_baseOp(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_Test_BaseInterface9_baseOp_name);
}

::Ice::AsyncResultPtr
IceProxy::Test::BaseInterface9::_iceI_begin_baseOp2(::Ice::Int iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_BaseInterface9_baseOp2_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_BaseInterface9_baseOp2_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_BaseInterface9_baseOp2_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_BaseInterface9_baseOp2_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Test::BaseInterface9::end_baseOp2(::std::string& iceP_s, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_BaseInterface9_baseOp2_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Test::Exception1&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_s);
    result->_endReadParams();
}

void IceProxy::Test::BaseInterface9::_iceI_end_baseOp2(::std::string& iceP_s, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_BaseInterface9_baseOp2_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Test::Exception1&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_s);
    result->_endReadParams();
}

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::Test::BaseInterface9::_newInstance() const
{
    return new BaseInterface9;
}
/// \endcond

const ::std::string&
IceProxy::Test::BaseInterface9::ice_staticId()
{
    return ::Test::BaseInterface9::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(BaseInterface10* p) { return p; }

void
::IceProxy::Test::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< BaseInterface10>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new BaseInterface10;
        v->_copyFrom(proxy);
    }
}
/// \endcond

::Ice::AsyncResultPtr
IceProxy::Test::BaseInterface10::_iceI_begin_baseOp(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_BaseInterface10_baseOp_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_BaseInterface10_baseOp_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Test_BaseInterface10_baseOp_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Test::BaseInterface10::end_baseOp(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_Test_BaseInterface10_baseOp_name);
}

::Ice::AsyncResultPtr
IceProxy::Test::BaseInterface10::_iceI_begin_baseOp2(::Ice::Int iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_BaseInterface10_baseOp2_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_BaseInterface10_baseOp2_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_BaseInterface10_baseOp2_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_BaseInterface10_baseOp2_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Test::BaseInterface10::end_baseOp2(::std::string& iceP_s, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_BaseInterface10_baseOp2_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Test::Exception1&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_s);
    result->_endReadParams();
}

void IceProxy::Test::BaseInterface10::_iceI_end_baseOp2(::std::string& iceP_s, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_BaseInterface10_baseOp2_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Test::Exception1&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_s);
    result->_endReadParams();
}

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::Test::BaseInterface10::_newInstance() const
{
    return new BaseInterface10;
}
/// \endcond

const ::std::string&
IceProxy::Test::BaseInterface10::ice_staticId()
{
    return ::Test::BaseInterface10::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(BaseInterface11* p) { return p; }

void
::IceProxy::Test::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< BaseInterface11>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new BaseInterface11;
        v->_copyFrom(proxy);
    }
}
/// \endcond

::Ice::AsyncResultPtr
IceProxy::Test::BaseInterface11::_iceI_begin_baseOp(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_BaseInterface11_baseOp_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_BaseInterface11_baseOp_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Test_BaseInterface11_baseOp_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Test::BaseInterface11::end_baseOp(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_Test_BaseInterface11_baseOp_name);
}

::Ice::AsyncResultPtr
IceProxy::Test::BaseInterface11::_iceI_begin_baseOp2(::Ice::Int iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_BaseInterface11_baseOp2_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_BaseInterface11_baseOp2_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_BaseInterface11_baseOp2_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_BaseInterface11_baseOp2_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Test::BaseInterface11::end_baseOp2(::std::string& iceP_s, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_BaseInterface11_baseOp2_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Test::Exception1&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_s);
    result->_endReadParams();
}

void IceProxy::Test::BaseInterface11::_iceI_end_baseOp2(::std::string& iceP_s, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_BaseInterface11_baseOp2_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Test::Exception1&)
        {
            throw;
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_s);
    result->_endReadParams();
}

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::Test::BaseInterface11::_newInstance() const
{
    return new BaseInterface11;
}
/// \endcond

const ::std::string&
IceProxy::Test::BaseInterface11::ice_staticId()
{
    return ::Test::BaseInterface11::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(Compact1* p) { return p; }

void
::IceProxy::Test::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< Compact1>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new Compact1;
        v->_copyFrom(proxy);
    }
}
/// \endcond

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::Test::Compact1::_newInstance() const
{
    return new Compact1;
}
/// \endcond

const ::std::string&
IceProxy::Test::Compact1::ice_staticId()
{
    return ::Test::Compact1::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(Derived1* p) { return p; }

void
::IceProxy::Test::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< Derived1>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new Derived1;
        v->_copyFrom(proxy);
    }
}
/// \endcond

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::Test::Derived1::_newInstance() const
{
    return new Derived1;
}
/// \endcond

const ::std::string&
IceProxy::Test::Derived1::ice_staticId()
{
    return ::Test::Derived1::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(Compact2* p) { return p; }

void
::IceProxy::Test::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< Compact2>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new Compact2;
        v->_copyFrom(proxy);
    }
}
/// \endcond

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::Test::Compact2::_newInstance() const
{
    return new Compact2;
}
/// \endcond

const ::std::string&
IceProxy::Test::Compact2::ice_staticId()
{
    return ::Test::Compact2::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(Optional0* p) { return p; }

void
::IceProxy::Test::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< Optional0>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new Optional0;
        v->_copyFrom(proxy);
    }
}
/// \endcond

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::Test::Optional0::_newInstance() const
{
    return new Optional0;
}
/// \endcond

const ::std::string&
IceProxy::Test::Optional0::ice_staticId()
{
    return ::Test::Optional0::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(Optional1* p) { return p; }

void
::IceProxy::Test::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< Optional1>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new Optional1;
        v->_copyFrom(proxy);
    }
}
/// \endcond

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::Test::Optional1::_newInstance() const
{
    return new Optional1;
}
/// \endcond

const ::std::string&
IceProxy::Test::Optional1::ice_staticId()
{
    return ::Test::Optional1::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(Optional2* p) { return p; }

void
::IceProxy::Test::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< Optional2>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new Optional2;
        v->_copyFrom(proxy);
    }
}
/// \endcond

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::Test::Optional2::_newInstance() const
{
    return new Optional2;
}
/// \endcond

const ::std::string&
IceProxy::Test::Optional2::ice_staticId()
{
    return ::Test::Optional2::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(Optional3* p) { return p; }

void
::IceProxy::Test::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< Optional3>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new Optional3;
        v->_copyFrom(proxy);
    }
}
/// \endcond

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::Test::Optional3::_newInstance() const
{
    return new Optional3;
}
/// \endcond

const ::std::string&
IceProxy::Test::Optional3::ice_staticId()
{
    return ::Test::Optional3::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(Optional4* p) { return p; }

void
::IceProxy::Test::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< Optional4>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new Optional4;
        v->_copyFrom(proxy);
    }
}
/// \endcond

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::Test::Optional4::_newInstance() const
{
    return new Optional4;
}
/// \endcond

const ::std::string&
IceProxy::Test::Optional4::ice_staticId()
{
    return ::Test::Optional4::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(OptionalParameters0* p) { return p; }

void
::IceProxy::Test::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< OptionalParameters0>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new OptionalParameters0;
        v->_copyFrom(proxy);
    }
}
/// \endcond

::Ice::AsyncResultPtr
IceProxy::Test::OptionalParameters0::_iceI_begin_op1(const ::std::string& iceP_firstName, const IceUtil::Optional< ::std::string>& iceP_secondName, const IceUtil::Optional< ::std::string>& iceP_emailAddress, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_OptionalParameters0_op1_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_OptionalParameters0_op1_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_firstName);
        ostr->write(1, iceP_secondName);
        ostr->write(2, iceP_emailAddress);
        result->endWriteParams();
        result->invoke(iceC_Test_OptionalParameters0_op1_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Test::OptionalParameters0::end_op1(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_Test_OptionalParameters0_op1_name);
}

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::Test::OptionalParameters0::_newInstance() const
{
    return new OptionalParameters0;
}
/// \endcond

const ::std::string&
IceProxy::Test::OptionalParameters0::ice_staticId()
{
    return ::Test::OptionalParameters0::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(OptionalParameters1* p) { return p; }

void
::IceProxy::Test::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< OptionalParameters1>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new OptionalParameters1;
        v->_copyFrom(proxy);
    }
}
/// \endcond

::Ice::AsyncResultPtr
IceProxy::Test::OptionalParameters1::_iceI_begin_op1(const ::std::string& iceP_firstName, const IceUtil::Optional< ::std::string>& iceP_secondName, const IceUtil::Optional< ::std::string>& iceP_emailAddress, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_OptionalParameters1_op1_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_OptionalParameters1_op1_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_firstName);
        ostr->write(1, iceP_secondName);
        ostr->write(2, iceP_emailAddress);
        result->endWriteParams();
        result->invoke(iceC_Test_OptionalParameters1_op1_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Test::OptionalParameters1::end_op1(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_Test_OptionalParameters1_op1_name);
}

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::Test::OptionalParameters1::_newInstance() const
{
    return new OptionalParameters1;
}
/// \endcond

const ::std::string&
IceProxy::Test::OptionalParameters1::ice_staticId()
{
    return ::Test::OptionalParameters1::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(OptionalParameters2* p) { return p; }

void
::IceProxy::Test::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< OptionalParameters2>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new OptionalParameters2;
        v->_copyFrom(proxy);
    }
}
/// \endcond

::Ice::AsyncResultPtr
IceProxy::Test::OptionalParameters2::_iceI_begin_op1(const ::std::string& iceP_firstName, const IceUtil::Optional< ::std::string>& iceP_emailAddress, const IceUtil::Optional< ::std::string>& iceP_secondName, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_OptionalParameters2_op1_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_OptionalParameters2_op1_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_firstName);
        ostr->write(1, iceP_emailAddress);
        ostr->write(2, iceP_secondName);
        result->endWriteParams();
        result->invoke(iceC_Test_OptionalParameters2_op1_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Test::OptionalParameters2::end_op1(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_Test_OptionalParameters2_op1_name);
}

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::Test::OptionalParameters2::_newInstance() const
{
    return new OptionalParameters2;
}
/// \endcond

const ::std::string&
IceProxy::Test::OptionalParameters2::ice_staticId()
{
    return ::Test::OptionalParameters2::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(OptionalParameters3* p) { return p; }

void
::IceProxy::Test::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< OptionalParameters3>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new OptionalParameters3;
        v->_copyFrom(proxy);
    }
}
/// \endcond

::Ice::AsyncResultPtr
IceProxy::Test::OptionalParameters3::_iceI_begin_op1(const ::std::string& iceP_firstName, const IceUtil::Optional< ::std::string>& iceP_emailAddress, const ::std::string& iceP_secondName, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_OptionalParameters3_op1_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_OptionalParameters3_op1_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_firstName);
        ostr->write(iceP_secondName);
        ostr->write(1, iceP_emailAddress);
        result->endWriteParams();
        result->invoke(iceC_Test_OptionalParameters3_op1_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Test::OptionalParameters3::end_op1(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_Test_OptionalParameters3_op1_name);
}

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::Test::OptionalParameters3::_newInstance() const
{
    return new OptionalParameters3;
}
/// \endcond

const ::std::string&
IceProxy::Test::OptionalParameters3::ice_staticId()
{
    return ::Test::OptionalParameters3::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(OptionalReturn0* p) { return p; }

void
::IceProxy::Test::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< OptionalReturn0>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new OptionalReturn0;
        v->_copyFrom(proxy);
    }
}
/// \endcond

::Ice::AsyncResultPtr
IceProxy::Test::OptionalReturn0::_iceI_begin_op(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_OptionalReturn0_op_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_OptionalReturn0_op_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_OptionalReturn0_op_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Test_OptionalReturn0_op_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

IceUtil::Optional< ::Ice::Int>
IceProxy::Test::OptionalReturn0::end_op(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_OptionalReturn0_op_name);
    IceUtil::Optional< ::Ice::Int> ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(1, ret);
    result->_endReadParams();
    return ret;
}

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::Test::OptionalReturn0::_newInstance() const
{
    return new OptionalReturn0;
}
/// \endcond

const ::std::string&
IceProxy::Test::OptionalReturn0::ice_staticId()
{
    return ::Test::OptionalReturn0::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(OptionalReturn2* p) { return p; }

void
::IceProxy::Test::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< OptionalReturn2>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new OptionalReturn2;
        v->_copyFrom(proxy);
    }
}
/// \endcond

::Ice::AsyncResultPtr
IceProxy::Test::OptionalReturn2::_iceI_begin_op(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_OptionalReturn2_op_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_OptionalReturn2_op_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_OptionalReturn2_op_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Test_OptionalReturn2_op_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

IceUtil::Optional< ::Ice::Int>
IceProxy::Test::OptionalReturn2::end_op(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_OptionalReturn2_op_name);
    IceUtil::Optional< ::Ice::Int> ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(1, ret);
    result->_endReadParams();
    return ret;
}

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::Test::OptionalReturn2::_newInstance() const
{
    return new OptionalReturn2;
}
/// \endcond

const ::std::string&
IceProxy::Test::OptionalReturn2::ice_staticId()
{
    return ::Test::OptionalReturn2::ice_staticId();
}

Test::Interface1::~Interface1()
{
}

/// \cond INTERNAL
::Ice::Object* Test::upCast(Interface1* p) { return p; }

/// \endcond

namespace
{
const ::std::string iceC_Test_Interface1_ids[2] =
{
    "::Ice::Object",
    "::Test::Interface1"
};

}

bool
Test::Interface1::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_Interface1_ids, iceC_Test_Interface1_ids + 2, s);
}

::std::vector< ::std::string>
Test::Interface1::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Test_Interface1_ids[0], &iceC_Test_Interface1_ids[2]);
}

const ::std::string&
Test::Interface1::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::Interface1::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::Test::Interface1";
    return typeId;
#else
    return iceC_Test_Interface1_ids[1];
#endif
}

/// \cond STREAM
void
Test::Interface1::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< Interface1, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Test::Interface1::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< Interface1, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

/// \cond INTERNAL
void
Test::_icePatchObjectPtr(Interface1Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = Interface1Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(Interface1::ice_staticId(), v);
    }
}
/// \endcond

Test::Interface2::~Interface2()
{
}

/// \cond INTERNAL
::Ice::Object* Test::upCast(Interface2* p) { return p; }

/// \endcond

namespace
{
const ::std::string iceC_Test_Interface2_ids[2] =
{
    "::Ice::Object",
    "::Test::Interface2"
};

}

bool
Test::Interface2::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_Interface2_ids, iceC_Test_Interface2_ids + 2, s);
}

::std::vector< ::std::string>
Test::Interface2::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Test_Interface2_ids[0], &iceC_Test_Interface2_ids[2]);
}

const ::std::string&
Test::Interface2::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::Interface2::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::Test::Interface2";
    return typeId;
#else
    return iceC_Test_Interface2_ids[1];
#endif
}

/// \cond STREAM
void
Test::Interface2::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< Interface2, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Test::Interface2::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< Interface2, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

/// \cond INTERNAL
void
Test::_icePatchObjectPtr(Interface2Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = Interface2Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(Interface2::ice_staticId(), v);
    }
}
/// \endcond

Test::Interface3::~Interface3()
{
}

/// \cond INTERNAL
::Ice::Object* Test::upCast(Interface3* p) { return p; }

/// \endcond

namespace
{
const ::std::string iceC_Test_Interface3_ids[2] =
{
    "::Ice::Object",
    "::Test::Interface3"
};

}

bool
Test::Interface3::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_Interface3_ids, iceC_Test_Interface3_ids + 2, s);
}

::std::vector< ::std::string>
Test::Interface3::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Test_Interface3_ids[0], &iceC_Test_Interface3_ids[2]);
}

const ::std::string&
Test::Interface3::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::Interface3::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::Test::Interface3";
    return typeId;
#else
    return iceC_Test_Interface3_ids[1];
#endif
}

/// \cond STREAM
void
Test::Interface3::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< Interface3, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Test::Interface3::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< Interface3, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

/// \cond INTERNAL
void
Test::_icePatchObjectPtr(Interface3Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = Interface3Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(Interface3::ice_staticId(), v);
    }
}
/// \endcond

Test::Interface4::~Interface4()
{
}

/// \cond INTERNAL
::Ice::Object* Test::upCast(Interface4* p) { return p; }

/// \endcond

namespace
{
const ::std::string iceC_Test_Interface4_ids[2] =
{
    "::Ice::Object",
    "::Test::Interface4"
};

}

bool
Test::Interface4::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_Interface4_ids, iceC_Test_Interface4_ids + 2, s);
}

::std::vector< ::std::string>
Test::Interface4::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Test_Interface4_ids[0], &iceC_Test_Interface4_ids[2]);
}

const ::std::string&
Test::Interface4::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::Interface4::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::Test::Interface4";
    return typeId;
#else
    return iceC_Test_Interface4_ids[1];
#endif
}

/// \cond STREAM
void
Test::Interface4::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< Interface4, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Test::Interface4::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< Interface4, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

/// \cond INTERNAL
void
Test::_icePatchObjectPtr(Interface4Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = Interface4Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(Interface4::ice_staticId(), v);
    }
}
/// \endcond

Test::EmptyClass1::~EmptyClass1()
{
}

/// \cond INTERNAL
::Ice::Object* Test::upCast(EmptyClass1* p) { return p; }

/// \endcond
::Ice::ObjectPtr
Test::EmptyClass1::ice_clone() const
{
    ::Ice::Object* p = new EmptyClass1(*this);
    return p;
}

namespace
{
const ::std::string iceC_Test_EmptyClass1_ids[2] =
{
    "::Ice::Object",
    "::Test::EmptyClass1"
};

}

bool
Test::EmptyClass1::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_EmptyClass1_ids, iceC_Test_EmptyClass1_ids + 2, s);
}

::std::vector< ::std::string>
Test::EmptyClass1::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Test_EmptyClass1_ids[0], &iceC_Test_EmptyClass1_ids[2]);
}

const ::std::string&
Test::EmptyClass1::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::EmptyClass1::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::Test::EmptyClass1";
    return typeId;
#else
    return iceC_Test_EmptyClass1_ids[1];
#endif
}

/// \cond STREAM
void
Test::EmptyClass1::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< EmptyClass1, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Test::EmptyClass1::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< EmptyClass1, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

namespace
{
const ::IceInternal::DefaultValueFactoryInit< ::Test::EmptyClass1> iceC_Test_EmptyClass1_init("::Test::EmptyClass1");
}

::Ice::ValueFactoryPtr
Test::EmptyClass1::ice_factory()
{
    return ::IceInternal::factoryTable->getValueFactory(::Test::EmptyClass1::ice_staticId());
}

/// \cond INTERNAL
void
Test::_icePatchObjectPtr(EmptyClass1Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = EmptyClass1Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(EmptyClass1::ice_staticId(), v);
    }
}
/// \endcond

Test::EmptyClass2::~EmptyClass2()
{
}

/// \cond INTERNAL
::Ice::Object* Test::upCast(EmptyClass2* p) { return p; }

/// \endcond
::Ice::ObjectPtr
Test::EmptyClass2::ice_clone() const
{
    ::Ice::Object* p = new EmptyClass2(*this);
    return p;
}

namespace
{
const ::std::string iceC_Test_EmptyClass2_ids[2] =
{
    "::Ice::Object",
    "::Test::EmptyClass2"
};

}

bool
Test::EmptyClass2::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_EmptyClass2_ids, iceC_Test_EmptyClass2_ids + 2, s);
}

::std::vector< ::std::string>
Test::EmptyClass2::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Test_EmptyClass2_ids[0], &iceC_Test_EmptyClass2_ids[2]);
}

const ::std::string&
Test::EmptyClass2::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::EmptyClass2::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::Test::EmptyClass2";
    return typeId;
#else
    return iceC_Test_EmptyClass2_ids[1];
#endif
}

/// \cond STREAM
void
Test::EmptyClass2::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< EmptyClass2, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Test::EmptyClass2::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< EmptyClass2, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

namespace
{
const ::IceInternal::DefaultValueFactoryInit< ::Test::EmptyClass2> iceC_Test_EmptyClass2_init("::Test::EmptyClass2");
}

::Ice::ValueFactoryPtr
Test::EmptyClass2::ice_factory()
{
    return ::IceInternal::factoryTable->getValueFactory(::Test::EmptyClass2::ice_staticId());
}

/// \cond INTERNAL
void
Test::_icePatchObjectPtr(EmptyClass2Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = EmptyClass2Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(EmptyClass2::ice_staticId(), v);
    }
}
/// \endcond

Test::EmptyClass3::~EmptyClass3()
{
}

/// \cond INTERNAL
::Ice::Object* Test::upCast(EmptyClass3* p) { return p; }

/// \endcond
::Ice::ObjectPtr
Test::EmptyClass3::ice_clone() const
{
    ::Ice::Object* p = new EmptyClass3(*this);
    return p;
}

namespace
{
const ::std::string iceC_Test_EmptyClass3_ids[2] =
{
    "::Ice::Object",
    "::Test::EmptyClass3"
};

}

bool
Test::EmptyClass3::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_EmptyClass3_ids, iceC_Test_EmptyClass3_ids + 2, s);
}

::std::vector< ::std::string>
Test::EmptyClass3::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Test_EmptyClass3_ids[0], &iceC_Test_EmptyClass3_ids[2]);
}

const ::std::string&
Test::EmptyClass3::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::EmptyClass3::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::Test::EmptyClass3";
    return typeId;
#else
    return iceC_Test_EmptyClass3_ids[1];
#endif
}

/// \cond STREAM
void
Test::EmptyClass3::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< EmptyClass3, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Test::EmptyClass3::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< EmptyClass3, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

namespace
{
const ::IceInternal::DefaultValueFactoryInit< ::Test::EmptyClass3> iceC_Test_EmptyClass3_init("::Test::EmptyClass3");
}

::Ice::ValueFactoryPtr
Test::EmptyClass3::ice_factory()
{
    return ::IceInternal::factoryTable->getValueFactory(::Test::EmptyClass3::ice_staticId());
}

/// \cond INTERNAL
void
Test::_icePatchObjectPtr(EmptyClass3Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = EmptyClass3Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(EmptyClass3::ice_staticId(), v);
    }
}
/// \endcond

Test::EmptyClass4::~EmptyClass4()
{
}

/// \cond INTERNAL
::Ice::Object* Test::upCast(EmptyClass4* p) { return p; }

/// \endcond
::Ice::ObjectPtr
Test::EmptyClass4::ice_clone() const
{
    ::Ice::Object* p = new EmptyClass4(*this);
    return p;
}

namespace
{
const ::std::string iceC_Test_EmptyClass4_ids[2] =
{
    "::Ice::Object",
    "::Test::EmptyClass4"
};

}

bool
Test::EmptyClass4::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_EmptyClass4_ids, iceC_Test_EmptyClass4_ids + 2, s);
}

::std::vector< ::std::string>
Test::EmptyClass4::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Test_EmptyClass4_ids[0], &iceC_Test_EmptyClass4_ids[2]);
}

const ::std::string&
Test::EmptyClass4::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::EmptyClass4::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::Test::EmptyClass4";
    return typeId;
#else
    return iceC_Test_EmptyClass4_ids[1];
#endif
}

/// \cond STREAM
void
Test::EmptyClass4::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< EmptyClass4, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Test::EmptyClass4::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< EmptyClass4, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

namespace
{
const ::IceInternal::DefaultValueFactoryInit< ::Test::EmptyClass4> iceC_Test_EmptyClass4_init("::Test::EmptyClass4");
}

::Ice::ValueFactoryPtr
Test::EmptyClass4::ice_factory()
{
    return ::IceInternal::factoryTable->getValueFactory(::Test::EmptyClass4::ice_staticId());
}

/// \cond INTERNAL
void
Test::_icePatchObjectPtr(EmptyClass4Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = EmptyClass4Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(EmptyClass4::ice_staticId(), v);
    }
}
/// \endcond

Test::EmptyClass5::~EmptyClass5()
{
}

/// \cond INTERNAL
::Ice::Object* Test::upCast(EmptyClass5* p) { return p; }

/// \endcond
::Ice::ObjectPtr
Test::EmptyClass5::ice_clone() const
{
    ::Ice::Object* p = new EmptyClass5(*this);
    return p;
}

namespace
{
const ::std::string iceC_Test_EmptyClass5_ids[2] =
{
    "::Ice::Object",
    "::Test::EmptyClass5"
};

}

bool
Test::EmptyClass5::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_EmptyClass5_ids, iceC_Test_EmptyClass5_ids + 2, s);
}

::std::vector< ::std::string>
Test::EmptyClass5::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Test_EmptyClass5_ids[0], &iceC_Test_EmptyClass5_ids[2]);
}

const ::std::string&
Test::EmptyClass5::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::EmptyClass5::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::Test::EmptyClass5";
    return typeId;
#else
    return iceC_Test_EmptyClass5_ids[1];
#endif
}

/// \cond STREAM
void
Test::EmptyClass5::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< EmptyClass5, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Test::EmptyClass5::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< EmptyClass5, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

namespace
{
const ::IceInternal::DefaultValueFactoryInit< ::Test::EmptyClass5> iceC_Test_EmptyClass5_init("::Test::EmptyClass5");
}

::Ice::ValueFactoryPtr
Test::EmptyClass5::ice_factory()
{
    return ::IceInternal::factoryTable->getValueFactory(::Test::EmptyClass5::ice_staticId());
}

/// \cond INTERNAL
void
Test::_icePatchObjectPtr(EmptyClass5Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = EmptyClass5Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(EmptyClass5::ice_staticId(), v);
    }
}
/// \endcond

Test::SimpleClass1::~SimpleClass1()
{
}

/// \cond INTERNAL
::Ice::Object* Test::upCast(SimpleClass1* p) { return p; }

/// \endcond
::Ice::ObjectPtr
Test::SimpleClass1::ice_clone() const
{
    ::Ice::Object* p = new SimpleClass1(*this);
    return p;
}

namespace
{
const ::std::string iceC_Test_SimpleClass1_ids[2] =
{
    "::Ice::Object",
    "::Test::SimpleClass1"
};

}

bool
Test::SimpleClass1::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_SimpleClass1_ids, iceC_Test_SimpleClass1_ids + 2, s);
}

::std::vector< ::std::string>
Test::SimpleClass1::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Test_SimpleClass1_ids[0], &iceC_Test_SimpleClass1_ids[2]);
}

const ::std::string&
Test::SimpleClass1::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::SimpleClass1::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::Test::SimpleClass1";
    return typeId;
#else
    return iceC_Test_SimpleClass1_ids[1];
#endif
}

/// \cond STREAM
void
Test::SimpleClass1::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< SimpleClass1, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Test::SimpleClass1::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< SimpleClass1, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

namespace
{
const ::IceInternal::DefaultValueFactoryInit< ::Test::SimpleClass1> iceC_Test_SimpleClass1_init("::Test::SimpleClass1");
}

::Ice::ValueFactoryPtr
Test::SimpleClass1::ice_factory()
{
    return ::IceInternal::factoryTable->getValueFactory(::Test::SimpleClass1::ice_staticId());
}

/// \cond INTERNAL
void
Test::_icePatchObjectPtr(SimpleClass1Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = SimpleClass1Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(SimpleClass1::ice_staticId(), v);
    }
}
/// \endcond

Test::SimpleClass2::~SimpleClass2()
{
}

/// \cond INTERNAL
::Ice::Object* Test::upCast(SimpleClass2* p) { return p; }

/// \endcond
::Ice::ObjectPtr
Test::SimpleClass2::ice_clone() const
{
    ::Ice::Object* p = new SimpleClass2(*this);
    return p;
}

namespace
{
const ::std::string iceC_Test_SimpleClass2_ids[2] =
{
    "::Ice::Object",
    "::Test::SimpleClass2"
};

}

bool
Test::SimpleClass2::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_SimpleClass2_ids, iceC_Test_SimpleClass2_ids + 2, s);
}

::std::vector< ::std::string>
Test::SimpleClass2::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Test_SimpleClass2_ids[0], &iceC_Test_SimpleClass2_ids[2]);
}

const ::std::string&
Test::SimpleClass2::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::SimpleClass2::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::Test::SimpleClass2";
    return typeId;
#else
    return iceC_Test_SimpleClass2_ids[1];
#endif
}

/// \cond STREAM
void
Test::SimpleClass2::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< SimpleClass2, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Test::SimpleClass2::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< SimpleClass2, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

namespace
{
const ::IceInternal::DefaultValueFactoryInit< ::Test::SimpleClass2> iceC_Test_SimpleClass2_init("::Test::SimpleClass2");
}

::Ice::ValueFactoryPtr
Test::SimpleClass2::ice_factory()
{
    return ::IceInternal::factoryTable->getValueFactory(::Test::SimpleClass2::ice_staticId());
}

/// \cond INTERNAL
void
Test::_icePatchObjectPtr(SimpleClass2Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = SimpleClass2Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(SimpleClass2::ice_staticId(), v);
    }
}
/// \endcond

Test::SimpleClass3::~SimpleClass3()
{
}

/// \cond INTERNAL
::Ice::Object* Test::upCast(SimpleClass3* p) { return p; }

/// \endcond
::Ice::ObjectPtr
Test::SimpleClass3::ice_clone() const
{
    ::Ice::Object* p = new SimpleClass3(*this);
    return p;
}

namespace
{
const ::std::string iceC_Test_SimpleClass3_ids[2] =
{
    "::Ice::Object",
    "::Test::SimpleClass3"
};

}

bool
Test::SimpleClass3::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_SimpleClass3_ids, iceC_Test_SimpleClass3_ids + 2, s);
}

::std::vector< ::std::string>
Test::SimpleClass3::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Test_SimpleClass3_ids[0], &iceC_Test_SimpleClass3_ids[2]);
}

const ::std::string&
Test::SimpleClass3::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::SimpleClass3::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::Test::SimpleClass3";
    return typeId;
#else
    return iceC_Test_SimpleClass3_ids[1];
#endif
}

/// \cond STREAM
void
Test::SimpleClass3::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< SimpleClass3, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Test::SimpleClass3::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< SimpleClass3, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

namespace
{
const ::IceInternal::DefaultValueFactoryInit< ::Test::SimpleClass3> iceC_Test_SimpleClass3_init("::Test::SimpleClass3");
}

::Ice::ValueFactoryPtr
Test::SimpleClass3::ice_factory()
{
    return ::IceInternal::factoryTable->getValueFactory(::Test::SimpleClass3::ice_staticId());
}

/// \cond INTERNAL
void
Test::_icePatchObjectPtr(SimpleClass3Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = SimpleClass3Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(SimpleClass3::ice_staticId(), v);
    }
}
/// \endcond

Test::SimpleClass4::~SimpleClass4()
{
}

/// \cond INTERNAL
::Ice::Object* Test::upCast(SimpleClass4* p) { return p; }

/// \endcond
::Ice::ObjectPtr
Test::SimpleClass4::ice_clone() const
{
    ::Ice::Object* p = new SimpleClass4(*this);
    return p;
}

namespace
{
const ::std::string iceC_Test_SimpleClass4_ids[2] =
{
    "::Ice::Object",
    "::Test::SimpleClass4"
};

}

bool
Test::SimpleClass4::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_SimpleClass4_ids, iceC_Test_SimpleClass4_ids + 2, s);
}

::std::vector< ::std::string>
Test::SimpleClass4::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Test_SimpleClass4_ids[0], &iceC_Test_SimpleClass4_ids[2]);
}

const ::std::string&
Test::SimpleClass4::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::SimpleClass4::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::Test::SimpleClass4";
    return typeId;
#else
    return iceC_Test_SimpleClass4_ids[1];
#endif
}

/// \cond STREAM
void
Test::SimpleClass4::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< SimpleClass4, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Test::SimpleClass4::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< SimpleClass4, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

namespace
{
const ::IceInternal::DefaultValueFactoryInit< ::Test::SimpleClass4> iceC_Test_SimpleClass4_init("::Test::SimpleClass4");
}

::Ice::ValueFactoryPtr
Test::SimpleClass4::ice_factory()
{
    return ::IceInternal::factoryTable->getValueFactory(::Test::SimpleClass4::ice_staticId());
}

/// \cond INTERNAL
void
Test::_icePatchObjectPtr(SimpleClass4Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = SimpleClass4Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(SimpleClass4::ice_staticId(), v);
    }
}
/// \endcond

Test::SimpleClass5::~SimpleClass5()
{
}

/// \cond INTERNAL
::Ice::Object* Test::upCast(SimpleClass5* p) { return p; }

/// \endcond
::Ice::ObjectPtr
Test::SimpleClass5::ice_clone() const
{
    ::Ice::Object* p = new SimpleClass5(*this);
    return p;
}

namespace
{
const ::std::string iceC_Test_SimpleClass5_ids[2] =
{
    "::Ice::Object",
    "::Test::SimpleClass5"
};

}

bool
Test::SimpleClass5::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_SimpleClass5_ids, iceC_Test_SimpleClass5_ids + 2, s);
}

::std::vector< ::std::string>
Test::SimpleClass5::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Test_SimpleClass5_ids[0], &iceC_Test_SimpleClass5_ids[2]);
}

const ::std::string&
Test::SimpleClass5::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::SimpleClass5::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::Test::SimpleClass5";
    return typeId;
#else
    return iceC_Test_SimpleClass5_ids[1];
#endif
}

/// \cond STREAM
void
Test::SimpleClass5::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< SimpleClass5, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Test::SimpleClass5::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< SimpleClass5, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

namespace
{
const ::IceInternal::DefaultValueFactoryInit< ::Test::SimpleClass5> iceC_Test_SimpleClass5_init("::Test::SimpleClass5");
}

::Ice::ValueFactoryPtr
Test::SimpleClass5::ice_factory()
{
    return ::IceInternal::factoryTable->getValueFactory(::Test::SimpleClass5::ice_staticId());
}

/// \cond INTERNAL
void
Test::_icePatchObjectPtr(SimpleClass5Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = SimpleClass5Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(SimpleClass5::ice_staticId(), v);
    }
}
/// \endcond

Test::SimpleClass6::~SimpleClass6()
{
}

/// \cond INTERNAL
::Ice::Object* Test::upCast(SimpleClass6* p) { return p; }

/// \endcond
::Ice::ObjectPtr
Test::SimpleClass6::ice_clone() const
{
    ::Ice::Object* p = new SimpleClass6(*this);
    return p;
}

namespace
{
const ::std::string iceC_Test_SimpleClass6_ids[2] =
{
    "::Ice::Object",
    "::Test::SimpleClass6"
};

}

bool
Test::SimpleClass6::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_SimpleClass6_ids, iceC_Test_SimpleClass6_ids + 2, s);
}

::std::vector< ::std::string>
Test::SimpleClass6::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Test_SimpleClass6_ids[0], &iceC_Test_SimpleClass6_ids[2]);
}

const ::std::string&
Test::SimpleClass6::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::SimpleClass6::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::Test::SimpleClass6";
    return typeId;
#else
    return iceC_Test_SimpleClass6_ids[1];
#endif
}

/// \cond STREAM
void
Test::SimpleClass6::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< SimpleClass6, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Test::SimpleClass6::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< SimpleClass6, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

namespace
{
const ::IceInternal::DefaultValueFactoryInit< ::Test::SimpleClass6> iceC_Test_SimpleClass6_init("::Test::SimpleClass6");
}

::Ice::ValueFactoryPtr
Test::SimpleClass6::ice_factory()
{
    return ::IceInternal::factoryTable->getValueFactory(::Test::SimpleClass6::ice_staticId());
}

/// \cond INTERNAL
void
Test::_icePatchObjectPtr(SimpleClass6Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = SimpleClass6Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(SimpleClass6::ice_staticId(), v);
    }
}
/// \endcond

Test::SimpleClass7::~SimpleClass7()
{
}

/// \cond INTERNAL
::Ice::Object* Test::upCast(SimpleClass7* p) { return p; }

/// \endcond
::Ice::ObjectPtr
Test::SimpleClass7::ice_clone() const
{
    ::Ice::Object* p = new SimpleClass7(*this);
    return p;
}

namespace
{
const ::std::string iceC_Test_SimpleClass7_ids[2] =
{
    "::Ice::Object",
    "::Test::SimpleClass7"
};

}

bool
Test::SimpleClass7::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_SimpleClass7_ids, iceC_Test_SimpleClass7_ids + 2, s);
}

::std::vector< ::std::string>
Test::SimpleClass7::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Test_SimpleClass7_ids[0], &iceC_Test_SimpleClass7_ids[2]);
}

const ::std::string&
Test::SimpleClass7::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::SimpleClass7::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::Test::SimpleClass7";
    return typeId;
#else
    return iceC_Test_SimpleClass7_ids[1];
#endif
}

/// \cond STREAM
void
Test::SimpleClass7::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< SimpleClass7, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Test::SimpleClass7::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< SimpleClass7, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

namespace
{
const ::IceInternal::DefaultValueFactoryInit< ::Test::SimpleClass7> iceC_Test_SimpleClass7_init("::Test::SimpleClass7");
}

::Ice::ValueFactoryPtr
Test::SimpleClass7::ice_factory()
{
    return ::IceInternal::factoryTable->getValueFactory(::Test::SimpleClass7::ice_staticId());
}

/// \cond INTERNAL
void
Test::_icePatchObjectPtr(SimpleClass7Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = SimpleClass7Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(SimpleClass7::ice_staticId(), v);
    }
}
/// \endcond

Test::BaseInterface1::~BaseInterface1()
{
}

/// \cond INTERNAL
::Ice::Object* Test::upCast(BaseInterface1* p) { return p; }

/// \endcond

namespace
{
const ::std::string iceC_Test_BaseInterface1_ids[2] =
{
    "::Ice::Object",
    "::Test::BaseInterface1"
};

}

bool
Test::BaseInterface1::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_BaseInterface1_ids, iceC_Test_BaseInterface1_ids + 2, s);
}

::std::vector< ::std::string>
Test::BaseInterface1::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Test_BaseInterface1_ids[0], &iceC_Test_BaseInterface1_ids[2]);
}

const ::std::string&
Test::BaseInterface1::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::BaseInterface1::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::Test::BaseInterface1";
    return typeId;
#else
    return iceC_Test_BaseInterface1_ids[1];
#endif
}

/// \cond INTERNAL
bool
Test::BaseInterface1::_iceD_baseOp1(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    this->baseOp1(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::BaseInterface1::_iceD_baseOp2(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Int iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    ::std::string iceP_s;
    this->baseOp2(iceP_i, iceP_s, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_s);
    inS.endWriteParams();
    return true;
}
/// \endcond

namespace
{
const ::std::string iceC_Test_BaseInterface1_all[] =
{
    "baseOp1",
    "baseOp2",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};

}

/// \cond INTERNAL
bool
Test::BaseInterface1::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_Test_BaseInterface1_all, iceC_Test_BaseInterface1_all + 6, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_Test_BaseInterface1_all)
    {
        case 0:
        {
            return _iceD_baseOp1(in, current);
        }
        case 1:
        {
            return _iceD_baseOp2(in, current);
        }
        case 2:
        {
            return _iceD_ice_id(in, current);
        }
        case 3:
        {
            return _iceD_ice_ids(in, current);
        }
        case 4:
        {
            return _iceD_ice_isA(in, current);
        }
        case 5:
        {
            return _iceD_ice_ping(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

/// \cond STREAM
void
Test::BaseInterface1::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< BaseInterface1, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Test::BaseInterface1::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< BaseInterface1, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

/// \cond INTERNAL
void
Test::_icePatchObjectPtr(BaseInterface1Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = BaseInterface1Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(BaseInterface1::ice_staticId(), v);
    }
}
/// \endcond

Test::BaseInterface2::~BaseInterface2()
{
}

/// \cond INTERNAL
::Ice::Object* Test::upCast(BaseInterface2* p) { return p; }

/// \endcond

namespace
{
const ::std::string iceC_Test_BaseInterface2_ids[2] =
{
    "::Ice::Object",
    "::Test::BaseInterface2"
};

}

bool
Test::BaseInterface2::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_BaseInterface2_ids, iceC_Test_BaseInterface2_ids + 2, s);
}

::std::vector< ::std::string>
Test::BaseInterface2::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Test_BaseInterface2_ids[0], &iceC_Test_BaseInterface2_ids[2]);
}

const ::std::string&
Test::BaseInterface2::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::BaseInterface2::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::Test::BaseInterface2";
    return typeId;
#else
    return iceC_Test_BaseInterface2_ids[1];
#endif
}

/// \cond INTERNAL
bool
Test::BaseInterface2::_iceD_baseOp(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    this->baseOp(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::BaseInterface2::_iceD_baseOp2(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Int iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    ::std::string iceP_s;
    this->baseOp2(iceP_i, iceP_s, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_s);
    inS.endWriteParams();
    return true;
}
/// \endcond

namespace
{
const ::std::string iceC_Test_BaseInterface2_all[] =
{
    "baseOp",
    "baseOp2",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};

}

/// \cond INTERNAL
bool
Test::BaseInterface2::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_Test_BaseInterface2_all, iceC_Test_BaseInterface2_all + 6, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_Test_BaseInterface2_all)
    {
        case 0:
        {
            return _iceD_baseOp(in, current);
        }
        case 1:
        {
            return _iceD_baseOp2(in, current);
        }
        case 2:
        {
            return _iceD_ice_id(in, current);
        }
        case 3:
        {
            return _iceD_ice_ids(in, current);
        }
        case 4:
        {
            return _iceD_ice_isA(in, current);
        }
        case 5:
        {
            return _iceD_ice_ping(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

/// \cond STREAM
void
Test::BaseInterface2::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< BaseInterface2, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Test::BaseInterface2::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< BaseInterface2, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

/// \cond INTERNAL
void
Test::_icePatchObjectPtr(BaseInterface2Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = BaseInterface2Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(BaseInterface2::ice_staticId(), v);
    }
}
/// \endcond

Test::BaseInterface3::~BaseInterface3()
{
}

/// \cond INTERNAL
::Ice::Object* Test::upCast(BaseInterface3* p) { return p; }

/// \endcond

namespace
{
const ::std::string iceC_Test_BaseInterface3_ids[2] =
{
    "::Ice::Object",
    "::Test::BaseInterface3"
};

}

bool
Test::BaseInterface3::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_BaseInterface3_ids, iceC_Test_BaseInterface3_ids + 2, s);
}

::std::vector< ::std::string>
Test::BaseInterface3::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Test_BaseInterface3_ids[0], &iceC_Test_BaseInterface3_ids[2]);
}

const ::std::string&
Test::BaseInterface3::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::BaseInterface3::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::Test::BaseInterface3";
    return typeId;
#else
    return iceC_Test_BaseInterface3_ids[1];
#endif
}

/// \cond INTERNAL
bool
Test::BaseInterface3::_iceD_baseOp(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    this->baseOp(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::BaseInterface3::_iceD_baseOp2(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Int iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    ::std::string iceP_s;
    this->baseOp2(iceP_i, iceP_s, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_s);
    inS.endWriteParams();
    return true;
}
/// \endcond

namespace
{
const ::std::string iceC_Test_BaseInterface3_all[] =
{
    "baseOp",
    "baseOp2",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};

}

/// \cond INTERNAL
bool
Test::BaseInterface3::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_Test_BaseInterface3_all, iceC_Test_BaseInterface3_all + 6, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_Test_BaseInterface3_all)
    {
        case 0:
        {
            return _iceD_baseOp(in, current);
        }
        case 1:
        {
            return _iceD_baseOp2(in, current);
        }
        case 2:
        {
            return _iceD_ice_id(in, current);
        }
        case 3:
        {
            return _iceD_ice_ids(in, current);
        }
        case 4:
        {
            return _iceD_ice_isA(in, current);
        }
        case 5:
        {
            return _iceD_ice_ping(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

/// \cond STREAM
void
Test::BaseInterface3::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< BaseInterface3, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Test::BaseInterface3::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< BaseInterface3, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

/// \cond INTERNAL
void
Test::_icePatchObjectPtr(BaseInterface3Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = BaseInterface3Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(BaseInterface3::ice_staticId(), v);
    }
}
/// \endcond

Test::BaseInterface4::~BaseInterface4()
{
}

/// \cond INTERNAL
::Ice::Object* Test::upCast(BaseInterface4* p) { return p; }

/// \endcond

namespace
{
const ::std::string iceC_Test_BaseInterface4_ids[2] =
{
    "::Ice::Object",
    "::Test::BaseInterface4"
};

}

bool
Test::BaseInterface4::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_BaseInterface4_ids, iceC_Test_BaseInterface4_ids + 2, s);
}

::std::vector< ::std::string>
Test::BaseInterface4::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Test_BaseInterface4_ids[0], &iceC_Test_BaseInterface4_ids[2]);
}

const ::std::string&
Test::BaseInterface4::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::BaseInterface4::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::Test::BaseInterface4";
    return typeId;
#else
    return iceC_Test_BaseInterface4_ids[1];
#endif
}

/// \cond INTERNAL
bool
Test::BaseInterface4::_iceD_baseOp(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    this->baseOp(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::BaseInterface4::_iceD_baseOp2(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Int iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    ::std::string iceP_s;
    this->baseOp2(iceP_i, iceP_s, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_s);
    inS.endWriteParams();
    return true;
}
/// \endcond

namespace
{
const ::std::string iceC_Test_BaseInterface4_all[] =
{
    "baseOp",
    "baseOp2",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};

}

/// \cond INTERNAL
bool
Test::BaseInterface4::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_Test_BaseInterface4_all, iceC_Test_BaseInterface4_all + 6, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_Test_BaseInterface4_all)
    {
        case 0:
        {
            return _iceD_baseOp(in, current);
        }
        case 1:
        {
            return _iceD_baseOp2(in, current);
        }
        case 2:
        {
            return _iceD_ice_id(in, current);
        }
        case 3:
        {
            return _iceD_ice_ids(in, current);
        }
        case 4:
        {
            return _iceD_ice_isA(in, current);
        }
        case 5:
        {
            return _iceD_ice_ping(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

/// \cond STREAM
void
Test::BaseInterface4::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< BaseInterface4, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Test::BaseInterface4::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< BaseInterface4, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

/// \cond INTERNAL
void
Test::_icePatchObjectPtr(BaseInterface4Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = BaseInterface4Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(BaseInterface4::ice_staticId(), v);
    }
}
/// \endcond

Test::BaseInterface5::~BaseInterface5()
{
}

/// \cond INTERNAL
::Ice::Object* Test::upCast(BaseInterface5* p) { return p; }

/// \endcond

namespace
{
const ::std::string iceC_Test_BaseInterface5_ids[2] =
{
    "::Ice::Object",
    "::Test::BaseInterface5"
};

}

bool
Test::BaseInterface5::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_BaseInterface5_ids, iceC_Test_BaseInterface5_ids + 2, s);
}

::std::vector< ::std::string>
Test::BaseInterface5::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Test_BaseInterface5_ids[0], &iceC_Test_BaseInterface5_ids[2]);
}

const ::std::string&
Test::BaseInterface5::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::BaseInterface5::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::Test::BaseInterface5";
    return typeId;
#else
    return iceC_Test_BaseInterface5_ids[1];
#endif
}

/// \cond INTERNAL
bool
Test::BaseInterface5::_iceD_baseOp(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    this->baseOp(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::BaseInterface5::_iceD_baseOp2(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Int iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    ::std::string iceP_s;
    this->baseOp2(iceP_i, iceP_s, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_s);
    inS.endWriteParams();
    return true;
}
/// \endcond

namespace
{
const ::std::string iceC_Test_BaseInterface5_all[] =
{
    "baseOp",
    "baseOp2",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};

}

/// \cond INTERNAL
bool
Test::BaseInterface5::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_Test_BaseInterface5_all, iceC_Test_BaseInterface5_all + 6, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_Test_BaseInterface5_all)
    {
        case 0:
        {
            return _iceD_baseOp(in, current);
        }
        case 1:
        {
            return _iceD_baseOp2(in, current);
        }
        case 2:
        {
            return _iceD_ice_id(in, current);
        }
        case 3:
        {
            return _iceD_ice_ids(in, current);
        }
        case 4:
        {
            return _iceD_ice_isA(in, current);
        }
        case 5:
        {
            return _iceD_ice_ping(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

/// \cond STREAM
void
Test::BaseInterface5::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< BaseInterface5, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Test::BaseInterface5::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< BaseInterface5, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

/// \cond INTERNAL
void
Test::_icePatchObjectPtr(BaseInterface5Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = BaseInterface5Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(BaseInterface5::ice_staticId(), v);
    }
}
/// \endcond

Test::BaseInterface6::~BaseInterface6()
{
}

/// \cond INTERNAL
::Ice::Object* Test::upCast(BaseInterface6* p) { return p; }

/// \endcond

namespace
{
const ::std::string iceC_Test_BaseInterface6_ids[2] =
{
    "::Ice::Object",
    "::Test::BaseInterface6"
};

}

bool
Test::BaseInterface6::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_BaseInterface6_ids, iceC_Test_BaseInterface6_ids + 2, s);
}

::std::vector< ::std::string>
Test::BaseInterface6::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Test_BaseInterface6_ids[0], &iceC_Test_BaseInterface6_ids[2]);
}

const ::std::string&
Test::BaseInterface6::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::BaseInterface6::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::Test::BaseInterface6";
    return typeId;
#else
    return iceC_Test_BaseInterface6_ids[1];
#endif
}

/// \cond INTERNAL
bool
Test::BaseInterface6::_iceD_baseOp(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    this->baseOp(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::BaseInterface6::_iceD_baseOp2(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Int iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    ::std::string iceP_s;
    this->baseOp2(iceP_i, iceP_s, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_s);
    inS.endWriteParams();
    return true;
}
/// \endcond

namespace
{
const ::std::string iceC_Test_BaseInterface6_all[] =
{
    "baseOp",
    "baseOp2",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};

}

/// \cond INTERNAL
bool
Test::BaseInterface6::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_Test_BaseInterface6_all, iceC_Test_BaseInterface6_all + 6, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_Test_BaseInterface6_all)
    {
        case 0:
        {
            return _iceD_baseOp(in, current);
        }
        case 1:
        {
            return _iceD_baseOp2(in, current);
        }
        case 2:
        {
            return _iceD_ice_id(in, current);
        }
        case 3:
        {
            return _iceD_ice_ids(in, current);
        }
        case 4:
        {
            return _iceD_ice_isA(in, current);
        }
        case 5:
        {
            return _iceD_ice_ping(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

/// \cond STREAM
void
Test::BaseInterface6::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< BaseInterface6, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Test::BaseInterface6::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< BaseInterface6, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

/// \cond INTERNAL
void
Test::_icePatchObjectPtr(BaseInterface6Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = BaseInterface6Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(BaseInterface6::ice_staticId(), v);
    }
}
/// \endcond

Test::BaseInterface7::~BaseInterface7()
{
}

/// \cond INTERNAL
::Ice::Object* Test::upCast(BaseInterface7* p) { return p; }

/// \endcond

namespace
{
const ::std::string iceC_Test_BaseInterface7_ids[2] =
{
    "::Ice::Object",
    "::Test::BaseInterface7"
};

}

bool
Test::BaseInterface7::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_BaseInterface7_ids, iceC_Test_BaseInterface7_ids + 2, s);
}

::std::vector< ::std::string>
Test::BaseInterface7::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Test_BaseInterface7_ids[0], &iceC_Test_BaseInterface7_ids[2]);
}

const ::std::string&
Test::BaseInterface7::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::BaseInterface7::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::Test::BaseInterface7";
    return typeId;
#else
    return iceC_Test_BaseInterface7_ids[1];
#endif
}

/// \cond INTERNAL
bool
Test::BaseInterface7::_iceD_baseOp(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    this->baseOp(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::BaseInterface7::_iceD_baseOp2(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Int iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    ::std::string iceP_s;
    this->baseOp2(iceP_i, iceP_s, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_s);
    inS.endWriteParams();
    return true;
}
/// \endcond

namespace
{
const ::std::string iceC_Test_BaseInterface7_all[] =
{
    "baseOp",
    "baseOp2",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};

}

/// \cond INTERNAL
bool
Test::BaseInterface7::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_Test_BaseInterface7_all, iceC_Test_BaseInterface7_all + 6, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_Test_BaseInterface7_all)
    {
        case 0:
        {
            return _iceD_baseOp(in, current);
        }
        case 1:
        {
            return _iceD_baseOp2(in, current);
        }
        case 2:
        {
            return _iceD_ice_id(in, current);
        }
        case 3:
        {
            return _iceD_ice_ids(in, current);
        }
        case 4:
        {
            return _iceD_ice_isA(in, current);
        }
        case 5:
        {
            return _iceD_ice_ping(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

/// \cond STREAM
void
Test::BaseInterface7::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< BaseInterface7, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Test::BaseInterface7::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< BaseInterface7, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

/// \cond INTERNAL
void
Test::_icePatchObjectPtr(BaseInterface7Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = BaseInterface7Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(BaseInterface7::ice_staticId(), v);
    }
}
/// \endcond

Test::BaseInterface8::~BaseInterface8()
{
}

/// \cond INTERNAL
::Ice::Object* Test::upCast(BaseInterface8* p) { return p; }

/// \endcond

namespace
{
const ::std::string iceC_Test_BaseInterface8_ids[2] =
{
    "::Ice::Object",
    "::Test::BaseInterface8"
};

}

bool
Test::BaseInterface8::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_BaseInterface8_ids, iceC_Test_BaseInterface8_ids + 2, s);
}

::std::vector< ::std::string>
Test::BaseInterface8::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Test_BaseInterface8_ids[0], &iceC_Test_BaseInterface8_ids[2]);
}

const ::std::string&
Test::BaseInterface8::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::BaseInterface8::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::Test::BaseInterface8";
    return typeId;
#else
    return iceC_Test_BaseInterface8_ids[1];
#endif
}

/// \cond INTERNAL
bool
Test::BaseInterface8::_iceD_baseOp(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    this->baseOp(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::BaseInterface8::_iceD_baseOp2(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Int iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    ::std::string iceP_s;
    this->baseOp2(iceP_i, iceP_s, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_s);
    inS.endWriteParams();
    return true;
}
/// \endcond

namespace
{
const ::std::string iceC_Test_BaseInterface8_all[] =
{
    "baseOp",
    "baseOp2",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};

}

/// \cond INTERNAL
bool
Test::BaseInterface8::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_Test_BaseInterface8_all, iceC_Test_BaseInterface8_all + 6, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_Test_BaseInterface8_all)
    {
        case 0:
        {
            return _iceD_baseOp(in, current);
        }
        case 1:
        {
            return _iceD_baseOp2(in, current);
        }
        case 2:
        {
            return _iceD_ice_id(in, current);
        }
        case 3:
        {
            return _iceD_ice_ids(in, current);
        }
        case 4:
        {
            return _iceD_ice_isA(in, current);
        }
        case 5:
        {
            return _iceD_ice_ping(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

/// \cond STREAM
void
Test::BaseInterface8::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< BaseInterface8, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Test::BaseInterface8::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< BaseInterface8, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

/// \cond INTERNAL
void
Test::_icePatchObjectPtr(BaseInterface8Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = BaseInterface8Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(BaseInterface8::ice_staticId(), v);
    }
}
/// \endcond

Test::BaseInterface9::~BaseInterface9()
{
}

/// \cond INTERNAL
::Ice::Object* Test::upCast(BaseInterface9* p) { return p; }

/// \endcond

namespace
{
const ::std::string iceC_Test_BaseInterface9_ids[2] =
{
    "::Ice::Object",
    "::Test::BaseInterface9"
};

}

bool
Test::BaseInterface9::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_BaseInterface9_ids, iceC_Test_BaseInterface9_ids + 2, s);
}

::std::vector< ::std::string>
Test::BaseInterface9::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Test_BaseInterface9_ids[0], &iceC_Test_BaseInterface9_ids[2]);
}

const ::std::string&
Test::BaseInterface9::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::BaseInterface9::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::Test::BaseInterface9";
    return typeId;
#else
    return iceC_Test_BaseInterface9_ids[1];
#endif
}

/// \cond INTERNAL
bool
Test::BaseInterface9::_iceD_baseOp(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    this->baseOp(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::BaseInterface9::_iceD_baseOp2(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Int iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    ::std::string iceP_s;
    this->baseOp2(iceP_i, iceP_s, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_s);
    inS.endWriteParams();
    return true;
}
/// \endcond

namespace
{
const ::std::string iceC_Test_BaseInterface9_all[] =
{
    "baseOp",
    "baseOp2",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};

}

/// \cond INTERNAL
bool
Test::BaseInterface9::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_Test_BaseInterface9_all, iceC_Test_BaseInterface9_all + 6, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_Test_BaseInterface9_all)
    {
        case 0:
        {
            return _iceD_baseOp(in, current);
        }
        case 1:
        {
            return _iceD_baseOp2(in, current);
        }
        case 2:
        {
            return _iceD_ice_id(in, current);
        }
        case 3:
        {
            return _iceD_ice_ids(in, current);
        }
        case 4:
        {
            return _iceD_ice_isA(in, current);
        }
        case 5:
        {
            return _iceD_ice_ping(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

/// \cond STREAM
void
Test::BaseInterface9::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< BaseInterface9, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Test::BaseInterface9::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< BaseInterface9, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

/// \cond INTERNAL
void
Test::_icePatchObjectPtr(BaseInterface9Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = BaseInterface9Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(BaseInterface9::ice_staticId(), v);
    }
}
/// \endcond

Test::BaseInterface10::~BaseInterface10()
{
}

/// \cond INTERNAL
::Ice::Object* Test::upCast(BaseInterface10* p) { return p; }

/// \endcond

namespace
{
const ::std::string iceC_Test_BaseInterface10_ids[2] =
{
    "::Ice::Object",
    "::Test::BaseInterface10"
};

}

bool
Test::BaseInterface10::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_BaseInterface10_ids, iceC_Test_BaseInterface10_ids + 2, s);
}

::std::vector< ::std::string>
Test::BaseInterface10::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Test_BaseInterface10_ids[0], &iceC_Test_BaseInterface10_ids[2]);
}

const ::std::string&
Test::BaseInterface10::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::BaseInterface10::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::Test::BaseInterface10";
    return typeId;
#else
    return iceC_Test_BaseInterface10_ids[1];
#endif
}

/// \cond INTERNAL
bool
Test::BaseInterface10::_iceD_baseOp(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    this->baseOp(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::BaseInterface10::_iceD_baseOp2(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Int iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    ::std::string iceP_s;
    this->baseOp2(iceP_i, iceP_s, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_s);
    inS.endWriteParams();
    return true;
}
/// \endcond

namespace
{
const ::std::string iceC_Test_BaseInterface10_all[] =
{
    "baseOp",
    "baseOp2",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};

}

/// \cond INTERNAL
bool
Test::BaseInterface10::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_Test_BaseInterface10_all, iceC_Test_BaseInterface10_all + 6, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_Test_BaseInterface10_all)
    {
        case 0:
        {
            return _iceD_baseOp(in, current);
        }
        case 1:
        {
            return _iceD_baseOp2(in, current);
        }
        case 2:
        {
            return _iceD_ice_id(in, current);
        }
        case 3:
        {
            return _iceD_ice_ids(in, current);
        }
        case 4:
        {
            return _iceD_ice_isA(in, current);
        }
        case 5:
        {
            return _iceD_ice_ping(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

/// \cond STREAM
void
Test::BaseInterface10::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< BaseInterface10, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Test::BaseInterface10::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< BaseInterface10, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

/// \cond INTERNAL
void
Test::_icePatchObjectPtr(BaseInterface10Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = BaseInterface10Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(BaseInterface10::ice_staticId(), v);
    }
}
/// \endcond

Test::BaseInterface11::~BaseInterface11()
{
}

/// \cond INTERNAL
::Ice::Object* Test::upCast(BaseInterface11* p) { return p; }

/// \endcond

namespace
{
const ::std::string iceC_Test_BaseInterface11_ids[2] =
{
    "::Ice::Object",
    "::Test::BaseInterface11"
};

}

bool
Test::BaseInterface11::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_BaseInterface11_ids, iceC_Test_BaseInterface11_ids + 2, s);
}

::std::vector< ::std::string>
Test::BaseInterface11::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Test_BaseInterface11_ids[0], &iceC_Test_BaseInterface11_ids[2]);
}

const ::std::string&
Test::BaseInterface11::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::BaseInterface11::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::Test::BaseInterface11";
    return typeId;
#else
    return iceC_Test_BaseInterface11_ids[1];
#endif
}

/// \cond INTERNAL
bool
Test::BaseInterface11::_iceD_baseOp(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    this->baseOp(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::BaseInterface11::_iceD_baseOp2(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Int iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    ::std::string iceP_s;
    this->baseOp2(iceP_i, iceP_s, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_s);
    inS.endWriteParams();
    return true;
}
/// \endcond

namespace
{
const ::std::string iceC_Test_BaseInterface11_all[] =
{
    "baseOp",
    "baseOp2",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};

}

/// \cond INTERNAL
bool
Test::BaseInterface11::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_Test_BaseInterface11_all, iceC_Test_BaseInterface11_all + 6, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_Test_BaseInterface11_all)
    {
        case 0:
        {
            return _iceD_baseOp(in, current);
        }
        case 1:
        {
            return _iceD_baseOp2(in, current);
        }
        case 2:
        {
            return _iceD_ice_id(in, current);
        }
        case 3:
        {
            return _iceD_ice_ids(in, current);
        }
        case 4:
        {
            return _iceD_ice_isA(in, current);
        }
        case 5:
        {
            return _iceD_ice_ping(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

/// \cond STREAM
void
Test::BaseInterface11::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< BaseInterface11, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Test::BaseInterface11::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< BaseInterface11, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

/// \cond INTERNAL
void
Test::_icePatchObjectPtr(BaseInterface11Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = BaseInterface11Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(BaseInterface11::ice_staticId(), v);
    }
}
/// \endcond

Test::Compact1::~Compact1()
{
}

/// \cond INTERNAL
::Ice::Object* Test::upCast(Compact1* p) { return p; }

/// \endcond
::Ice::ObjectPtr
Test::Compact1::ice_clone() const
{
    ::Ice::Object* p = new Compact1(*this);
    return p;
}

namespace
{
const ::std::string iceC_Test_Compact1_ids[2] =
{
    "::Ice::Object",
    "::Test::Compact1"
};

}

bool
Test::Compact1::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_Compact1_ids, iceC_Test_Compact1_ids + 2, s);
}

::std::vector< ::std::string>
Test::Compact1::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Test_Compact1_ids[0], &iceC_Test_Compact1_ids[2]);
}

const ::std::string&
Test::Compact1::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::Compact1::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::Test::Compact1";
    return typeId;
#else
    return iceC_Test_Compact1_ids[1];
#endif
}

/// \cond STREAM
void
Test::Compact1::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), 1, true);
    ::Ice::StreamWriter< Compact1, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Test::Compact1::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< Compact1, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

namespace
{
const ::IceInternal::DefaultValueFactoryInit< ::Test::Compact1> iceC_Test_Compact1_init("::Test::Compact1");
const ::IceInternal::CompactIdInit iceC_Test_Compact1_compactIdInit("::Test::Compact1", 1);
}

::Ice::ValueFactoryPtr
Test::Compact1::ice_factory()
{
    return ::IceInternal::factoryTable->getValueFactory(::Test::Compact1::ice_staticId());
}

/// \cond INTERNAL
void
Test::_icePatchObjectPtr(Compact1Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = Compact1Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(Compact1::ice_staticId(), v);
    }
}
/// \endcond

Test::Derived1::~Derived1()
{
}

/// \cond INTERNAL
::Ice::Object* Test::upCast(Derived1* p) { return p; }

/// \endcond
::Ice::ObjectPtr
Test::Derived1::ice_clone() const
{
    ::Ice::Object* p = new Derived1(*this);
    return p;
}

namespace
{
const ::std::string iceC_Test_Derived1_ids[3] =
{
    "::Ice::Object",
    "::Test::Compact1",
    "::Test::Derived1"
};

}

bool
Test::Derived1::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_Derived1_ids, iceC_Test_Derived1_ids + 3, s);
}

::std::vector< ::std::string>
Test::Derived1::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Test_Derived1_ids[0], &iceC_Test_Derived1_ids[3]);
}

const ::std::string&
Test::Derived1::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::Derived1::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::Test::Derived1";
    return typeId;
#else
    return iceC_Test_Derived1_ids[2];
#endif
}

/// \cond STREAM
void
Test::Derived1::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, false);
    ::Ice::StreamWriter< Derived1, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
    Compact1::_iceWriteImpl(ostr);
}

void
Test::Derived1::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< Derived1, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
    Compact1::_iceReadImpl(istr);
}
/// \endcond

namespace
{
const ::IceInternal::DefaultValueFactoryInit< ::Test::Derived1> iceC_Test_Derived1_init("::Test::Derived1");
}

::Ice::ValueFactoryPtr
Test::Derived1::ice_factory()
{
    return ::IceInternal::factoryTable->getValueFactory(::Test::Derived1::ice_staticId());
}

/// \cond INTERNAL
void
Test::_icePatchObjectPtr(Derived1Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = Derived1Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(Derived1::ice_staticId(), v);
    }
}
/// \endcond

Test::Compact2::~Compact2()
{
}

/// \cond INTERNAL
::Ice::Object* Test::upCast(Compact2* p) { return p; }

/// \endcond
::Ice::ObjectPtr
Test::Compact2::ice_clone() const
{
    ::Ice::Object* p = new Compact2(*this);
    return p;
}

namespace
{
const ::std::string iceC_Test_Compact2_ids[2] =
{
    "::Ice::Object",
    "::Test::Compact2"
};

}

bool
Test::Compact2::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_Compact2_ids, iceC_Test_Compact2_ids + 2, s);
}

::std::vector< ::std::string>
Test::Compact2::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Test_Compact2_ids[0], &iceC_Test_Compact2_ids[2]);
}

const ::std::string&
Test::Compact2::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::Compact2::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::Test::Compact2";
    return typeId;
#else
    return iceC_Test_Compact2_ids[1];
#endif
}

/// \cond STREAM
void
Test::Compact2::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), 2, true);
    ::Ice::StreamWriter< Compact2, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Test::Compact2::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< Compact2, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

namespace
{
const ::IceInternal::DefaultValueFactoryInit< ::Test::Compact2> iceC_Test_Compact2_init("::Test::Compact2");
const ::IceInternal::CompactIdInit iceC_Test_Compact2_compactIdInit("::Test::Compact2", 2);
}

::Ice::ValueFactoryPtr
Test::Compact2::ice_factory()
{
    return ::IceInternal::factoryTable->getValueFactory(::Test::Compact2::ice_staticId());
}

/// \cond INTERNAL
void
Test::_icePatchObjectPtr(Compact2Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = Compact2Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(Compact2::ice_staticId(), v);
    }
}
/// \endcond

Test::Optional0::~Optional0()
{
}

/// \cond INTERNAL
::Ice::Object* Test::upCast(Optional0* p) { return p; }

/// \endcond
::Ice::ObjectPtr
Test::Optional0::ice_clone() const
{
    ::Ice::Object* p = new Optional0(*this);
    return p;
}

namespace
{
const ::std::string iceC_Test_Optional0_ids[2] =
{
    "::Ice::Object",
    "::Test::Optional0"
};

}

bool
Test::Optional0::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_Optional0_ids, iceC_Test_Optional0_ids + 2, s);
}

::std::vector< ::std::string>
Test::Optional0::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Test_Optional0_ids[0], &iceC_Test_Optional0_ids[2]);
}

const ::std::string&
Test::Optional0::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::Optional0::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::Test::Optional0";
    return typeId;
#else
    return iceC_Test_Optional0_ids[1];
#endif
}

/// \cond STREAM
void
Test::Optional0::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< Optional0, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Test::Optional0::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< Optional0, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

namespace
{
const ::IceInternal::DefaultValueFactoryInit< ::Test::Optional0> iceC_Test_Optional0_init("::Test::Optional0");
}

::Ice::ValueFactoryPtr
Test::Optional0::ice_factory()
{
    return ::IceInternal::factoryTable->getValueFactory(::Test::Optional0::ice_staticId());
}

/// \cond INTERNAL
void
Test::_icePatchObjectPtr(Optional0Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = Optional0Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(Optional0::ice_staticId(), v);
    }
}
/// \endcond

Test::Optional1::~Optional1()
{
}

/// \cond INTERNAL
::Ice::Object* Test::upCast(Optional1* p) { return p; }

/// \endcond
::Ice::ObjectPtr
Test::Optional1::ice_clone() const
{
    ::Ice::Object* p = new Optional1(*this);
    return p;
}

namespace
{
const ::std::string iceC_Test_Optional1_ids[2] =
{
    "::Ice::Object",
    "::Test::Optional1"
};

}

bool
Test::Optional1::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_Optional1_ids, iceC_Test_Optional1_ids + 2, s);
}

::std::vector< ::std::string>
Test::Optional1::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Test_Optional1_ids[0], &iceC_Test_Optional1_ids[2]);
}

const ::std::string&
Test::Optional1::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::Optional1::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::Test::Optional1";
    return typeId;
#else
    return iceC_Test_Optional1_ids[1];
#endif
}

/// \cond STREAM
void
Test::Optional1::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< Optional1, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Test::Optional1::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< Optional1, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

namespace
{
const ::IceInternal::DefaultValueFactoryInit< ::Test::Optional1> iceC_Test_Optional1_init("::Test::Optional1");
}

::Ice::ValueFactoryPtr
Test::Optional1::ice_factory()
{
    return ::IceInternal::factoryTable->getValueFactory(::Test::Optional1::ice_staticId());
}

/// \cond INTERNAL
void
Test::_icePatchObjectPtr(Optional1Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = Optional1Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(Optional1::ice_staticId(), v);
    }
}
/// \endcond

Test::Optional2::~Optional2()
{
}

/// \cond INTERNAL
::Ice::Object* Test::upCast(Optional2* p) { return p; }

/// \endcond
::Ice::ObjectPtr
Test::Optional2::ice_clone() const
{
    ::Ice::Object* p = new Optional2(*this);
    return p;
}

namespace
{
const ::std::string iceC_Test_Optional2_ids[2] =
{
    "::Ice::Object",
    "::Test::Optional2"
};

}

bool
Test::Optional2::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_Optional2_ids, iceC_Test_Optional2_ids + 2, s);
}

::std::vector< ::std::string>
Test::Optional2::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Test_Optional2_ids[0], &iceC_Test_Optional2_ids[2]);
}

const ::std::string&
Test::Optional2::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::Optional2::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::Test::Optional2";
    return typeId;
#else
    return iceC_Test_Optional2_ids[1];
#endif
}

/// \cond STREAM
void
Test::Optional2::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< Optional2, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Test::Optional2::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< Optional2, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

namespace
{
const ::IceInternal::DefaultValueFactoryInit< ::Test::Optional2> iceC_Test_Optional2_init("::Test::Optional2");
}

::Ice::ValueFactoryPtr
Test::Optional2::ice_factory()
{
    return ::IceInternal::factoryTable->getValueFactory(::Test::Optional2::ice_staticId());
}

/// \cond INTERNAL
void
Test::_icePatchObjectPtr(Optional2Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = Optional2Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(Optional2::ice_staticId(), v);
    }
}
/// \endcond

Test::Optional3::~Optional3()
{
}

/// \cond INTERNAL
::Ice::Object* Test::upCast(Optional3* p) { return p; }

/// \endcond
::Ice::ObjectPtr
Test::Optional3::ice_clone() const
{
    ::Ice::Object* p = new Optional3(*this);
    return p;
}

namespace
{
const ::std::string iceC_Test_Optional3_ids[2] =
{
    "::Ice::Object",
    "::Test::Optional3"
};

}

bool
Test::Optional3::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_Optional3_ids, iceC_Test_Optional3_ids + 2, s);
}

::std::vector< ::std::string>
Test::Optional3::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Test_Optional3_ids[0], &iceC_Test_Optional3_ids[2]);
}

const ::std::string&
Test::Optional3::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::Optional3::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::Test::Optional3";
    return typeId;
#else
    return iceC_Test_Optional3_ids[1];
#endif
}

/// \cond STREAM
void
Test::Optional3::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< Optional3, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Test::Optional3::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< Optional3, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

namespace
{
const ::IceInternal::DefaultValueFactoryInit< ::Test::Optional3> iceC_Test_Optional3_init("::Test::Optional3");
}

::Ice::ValueFactoryPtr
Test::Optional3::ice_factory()
{
    return ::IceInternal::factoryTable->getValueFactory(::Test::Optional3::ice_staticId());
}

/// \cond INTERNAL
void
Test::_icePatchObjectPtr(Optional3Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = Optional3Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(Optional3::ice_staticId(), v);
    }
}
/// \endcond

Test::Optional4::~Optional4()
{
}

/// \cond INTERNAL
::Ice::Object* Test::upCast(Optional4* p) { return p; }

/// \endcond
::Ice::ObjectPtr
Test::Optional4::ice_clone() const
{
    ::Ice::Object* p = new Optional4(*this);
    return p;
}

namespace
{
const ::std::string iceC_Test_Optional4_ids[2] =
{
    "::Ice::Object",
    "::Test::Optional4"
};

}

bool
Test::Optional4::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_Optional4_ids, iceC_Test_Optional4_ids + 2, s);
}

::std::vector< ::std::string>
Test::Optional4::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Test_Optional4_ids[0], &iceC_Test_Optional4_ids[2]);
}

const ::std::string&
Test::Optional4::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::Optional4::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::Test::Optional4";
    return typeId;
#else
    return iceC_Test_Optional4_ids[1];
#endif
}

/// \cond STREAM
void
Test::Optional4::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< Optional4, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Test::Optional4::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< Optional4, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

namespace
{
const ::IceInternal::DefaultValueFactoryInit< ::Test::Optional4> iceC_Test_Optional4_init("::Test::Optional4");
}

::Ice::ValueFactoryPtr
Test::Optional4::ice_factory()
{
    return ::IceInternal::factoryTable->getValueFactory(::Test::Optional4::ice_staticId());
}

/// \cond INTERNAL
void
Test::_icePatchObjectPtr(Optional4Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = Optional4Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(Optional4::ice_staticId(), v);
    }
}
/// \endcond

Test::OptionalParameters0::~OptionalParameters0()
{
}

/// \cond INTERNAL
::Ice::Object* Test::upCast(OptionalParameters0* p) { return p; }

/// \endcond

namespace
{
const ::std::string iceC_Test_OptionalParameters0_ids[2] =
{
    "::Ice::Object",
    "::Test::OptionalParameters0"
};

}

bool
Test::OptionalParameters0::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_OptionalParameters0_ids, iceC_Test_OptionalParameters0_ids + 2, s);
}

::std::vector< ::std::string>
Test::OptionalParameters0::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Test_OptionalParameters0_ids[0], &iceC_Test_OptionalParameters0_ids[2]);
}

const ::std::string&
Test::OptionalParameters0::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::OptionalParameters0::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::Test::OptionalParameters0";
    return typeId;
#else
    return iceC_Test_OptionalParameters0_ids[1];
#endif
}

/// \cond INTERNAL
bool
Test::OptionalParameters0::_iceD_op1(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_firstName;
    IceUtil::Optional< ::std::string> iceP_secondName;
    IceUtil::Optional< ::std::string> iceP_emailAddress;
    istr->read(iceP_firstName);
    istr->read(1, iceP_secondName);
    istr->read(2, iceP_emailAddress);
    inS.endReadParams();
    this->op1(iceP_firstName, iceP_secondName, iceP_emailAddress, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

namespace
{
const ::std::string iceC_Test_OptionalParameters0_all[] =
{
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "op1"
};

}

/// \cond INTERNAL
bool
Test::OptionalParameters0::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_Test_OptionalParameters0_all, iceC_Test_OptionalParameters0_all + 5, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_Test_OptionalParameters0_all)
    {
        case 0:
        {
            return _iceD_ice_id(in, current);
        }
        case 1:
        {
            return _iceD_ice_ids(in, current);
        }
        case 2:
        {
            return _iceD_ice_isA(in, current);
        }
        case 3:
        {
            return _iceD_ice_ping(in, current);
        }
        case 4:
        {
            return _iceD_op1(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

/// \cond STREAM
void
Test::OptionalParameters0::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< OptionalParameters0, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Test::OptionalParameters0::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< OptionalParameters0, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

/// \cond INTERNAL
void
Test::_icePatchObjectPtr(OptionalParameters0Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = OptionalParameters0Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(OptionalParameters0::ice_staticId(), v);
    }
}
/// \endcond

Test::OptionalParameters1::~OptionalParameters1()
{
}

/// \cond INTERNAL
::Ice::Object* Test::upCast(OptionalParameters1* p) { return p; }

/// \endcond

namespace
{
const ::std::string iceC_Test_OptionalParameters1_ids[2] =
{
    "::Ice::Object",
    "::Test::OptionalParameters1"
};

}

bool
Test::OptionalParameters1::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_OptionalParameters1_ids, iceC_Test_OptionalParameters1_ids + 2, s);
}

::std::vector< ::std::string>
Test::OptionalParameters1::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Test_OptionalParameters1_ids[0], &iceC_Test_OptionalParameters1_ids[2]);
}

const ::std::string&
Test::OptionalParameters1::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::OptionalParameters1::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::Test::OptionalParameters1";
    return typeId;
#else
    return iceC_Test_OptionalParameters1_ids[1];
#endif
}

/// \cond INTERNAL
bool
Test::OptionalParameters1::_iceD_op1(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_firstName;
    IceUtil::Optional< ::std::string> iceP_secondName;
    IceUtil::Optional< ::std::string> iceP_emailAddress;
    istr->read(iceP_firstName);
    istr->read(1, iceP_secondName);
    istr->read(2, iceP_emailAddress);
    inS.endReadParams();
    this->op1(iceP_firstName, iceP_secondName, iceP_emailAddress, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

namespace
{
const ::std::string iceC_Test_OptionalParameters1_all[] =
{
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "op1"
};

}

/// \cond INTERNAL
bool
Test::OptionalParameters1::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_Test_OptionalParameters1_all, iceC_Test_OptionalParameters1_all + 5, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_Test_OptionalParameters1_all)
    {
        case 0:
        {
            return _iceD_ice_id(in, current);
        }
        case 1:
        {
            return _iceD_ice_ids(in, current);
        }
        case 2:
        {
            return _iceD_ice_isA(in, current);
        }
        case 3:
        {
            return _iceD_ice_ping(in, current);
        }
        case 4:
        {
            return _iceD_op1(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

/// \cond STREAM
void
Test::OptionalParameters1::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< OptionalParameters1, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Test::OptionalParameters1::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< OptionalParameters1, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

/// \cond INTERNAL
void
Test::_icePatchObjectPtr(OptionalParameters1Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = OptionalParameters1Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(OptionalParameters1::ice_staticId(), v);
    }
}
/// \endcond

Test::OptionalParameters2::~OptionalParameters2()
{
}

/// \cond INTERNAL
::Ice::Object* Test::upCast(OptionalParameters2* p) { return p; }

/// \endcond

namespace
{
const ::std::string iceC_Test_OptionalParameters2_ids[2] =
{
    "::Ice::Object",
    "::Test::OptionalParameters2"
};

}

bool
Test::OptionalParameters2::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_OptionalParameters2_ids, iceC_Test_OptionalParameters2_ids + 2, s);
}

::std::vector< ::std::string>
Test::OptionalParameters2::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Test_OptionalParameters2_ids[0], &iceC_Test_OptionalParameters2_ids[2]);
}

const ::std::string&
Test::OptionalParameters2::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::OptionalParameters2::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::Test::OptionalParameters2";
    return typeId;
#else
    return iceC_Test_OptionalParameters2_ids[1];
#endif
}

/// \cond INTERNAL
bool
Test::OptionalParameters2::_iceD_op1(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_firstName;
    IceUtil::Optional< ::std::string> iceP_emailAddress;
    IceUtil::Optional< ::std::string> iceP_secondName;
    istr->read(iceP_firstName);
    istr->read(1, iceP_emailAddress);
    istr->read(2, iceP_secondName);
    inS.endReadParams();
    this->op1(iceP_firstName, iceP_emailAddress, iceP_secondName, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

namespace
{
const ::std::string iceC_Test_OptionalParameters2_all[] =
{
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "op1"
};

}

/// \cond INTERNAL
bool
Test::OptionalParameters2::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_Test_OptionalParameters2_all, iceC_Test_OptionalParameters2_all + 5, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_Test_OptionalParameters2_all)
    {
        case 0:
        {
            return _iceD_ice_id(in, current);
        }
        case 1:
        {
            return _iceD_ice_ids(in, current);
        }
        case 2:
        {
            return _iceD_ice_isA(in, current);
        }
        case 3:
        {
            return _iceD_ice_ping(in, current);
        }
        case 4:
        {
            return _iceD_op1(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

/// \cond STREAM
void
Test::OptionalParameters2::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< OptionalParameters2, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Test::OptionalParameters2::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< OptionalParameters2, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

/// \cond INTERNAL
void
Test::_icePatchObjectPtr(OptionalParameters2Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = OptionalParameters2Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(OptionalParameters2::ice_staticId(), v);
    }
}
/// \endcond

Test::OptionalParameters3::~OptionalParameters3()
{
}

/// \cond INTERNAL
::Ice::Object* Test::upCast(OptionalParameters3* p) { return p; }

/// \endcond

namespace
{
const ::std::string iceC_Test_OptionalParameters3_ids[2] =
{
    "::Ice::Object",
    "::Test::OptionalParameters3"
};

}

bool
Test::OptionalParameters3::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_OptionalParameters3_ids, iceC_Test_OptionalParameters3_ids + 2, s);
}

::std::vector< ::std::string>
Test::OptionalParameters3::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Test_OptionalParameters3_ids[0], &iceC_Test_OptionalParameters3_ids[2]);
}

const ::std::string&
Test::OptionalParameters3::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::OptionalParameters3::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::Test::OptionalParameters3";
    return typeId;
#else
    return iceC_Test_OptionalParameters3_ids[1];
#endif
}

/// \cond INTERNAL
bool
Test::OptionalParameters3::_iceD_op1(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_firstName;
    IceUtil::Optional< ::std::string> iceP_emailAddress;
    ::std::string iceP_secondName;
    istr->read(iceP_firstName);
    istr->read(iceP_secondName);
    istr->read(1, iceP_emailAddress);
    inS.endReadParams();
    this->op1(iceP_firstName, iceP_emailAddress, iceP_secondName, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

namespace
{
const ::std::string iceC_Test_OptionalParameters3_all[] =
{
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "op1"
};

}

/// \cond INTERNAL
bool
Test::OptionalParameters3::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_Test_OptionalParameters3_all, iceC_Test_OptionalParameters3_all + 5, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_Test_OptionalParameters3_all)
    {
        case 0:
        {
            return _iceD_ice_id(in, current);
        }
        case 1:
        {
            return _iceD_ice_ids(in, current);
        }
        case 2:
        {
            return _iceD_ice_isA(in, current);
        }
        case 3:
        {
            return _iceD_ice_ping(in, current);
        }
        case 4:
        {
            return _iceD_op1(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

/// \cond STREAM
void
Test::OptionalParameters3::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< OptionalParameters3, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Test::OptionalParameters3::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< OptionalParameters3, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

/// \cond INTERNAL
void
Test::_icePatchObjectPtr(OptionalParameters3Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = OptionalParameters3Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(OptionalParameters3::ice_staticId(), v);
    }
}
/// \endcond

Test::OptionalReturn0::~OptionalReturn0()
{
}

/// \cond INTERNAL
::Ice::Object* Test::upCast(OptionalReturn0* p) { return p; }

/// \endcond

namespace
{
const ::std::string iceC_Test_OptionalReturn0_ids[2] =
{
    "::Ice::Object",
    "::Test::OptionalReturn0"
};

}

bool
Test::OptionalReturn0::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_OptionalReturn0_ids, iceC_Test_OptionalReturn0_ids + 2, s);
}

::std::vector< ::std::string>
Test::OptionalReturn0::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Test_OptionalReturn0_ids[0], &iceC_Test_OptionalReturn0_ids[2]);
}

const ::std::string&
Test::OptionalReturn0::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::OptionalReturn0::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::Test::OptionalReturn0";
    return typeId;
#else
    return iceC_Test_OptionalReturn0_ids[1];
#endif
}

/// \cond INTERNAL
bool
Test::OptionalReturn0::_iceD_op(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    IceUtil::Optional< ::Ice::Int> ret = this->op(current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(1, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

namespace
{
const ::std::string iceC_Test_OptionalReturn0_all[] =
{
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "op"
};

}

/// \cond INTERNAL
bool
Test::OptionalReturn0::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_Test_OptionalReturn0_all, iceC_Test_OptionalReturn0_all + 5, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_Test_OptionalReturn0_all)
    {
        case 0:
        {
            return _iceD_ice_id(in, current);
        }
        case 1:
        {
            return _iceD_ice_ids(in, current);
        }
        case 2:
        {
            return _iceD_ice_isA(in, current);
        }
        case 3:
        {
            return _iceD_ice_ping(in, current);
        }
        case 4:
        {
            return _iceD_op(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

/// \cond STREAM
void
Test::OptionalReturn0::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< OptionalReturn0, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Test::OptionalReturn0::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< OptionalReturn0, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

/// \cond INTERNAL
void
Test::_icePatchObjectPtr(OptionalReturn0Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = OptionalReturn0Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(OptionalReturn0::ice_staticId(), v);
    }
}
/// \endcond

Test::OptionalReturn2::~OptionalReturn2()
{
}

/// \cond INTERNAL
::Ice::Object* Test::upCast(OptionalReturn2* p) { return p; }

/// \endcond

namespace
{
const ::std::string iceC_Test_OptionalReturn2_ids[2] =
{
    "::Ice::Object",
    "::Test::OptionalReturn2"
};

}

bool
Test::OptionalReturn2::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_OptionalReturn2_ids, iceC_Test_OptionalReturn2_ids + 2, s);
}

::std::vector< ::std::string>
Test::OptionalReturn2::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Test_OptionalReturn2_ids[0], &iceC_Test_OptionalReturn2_ids[2]);
}

const ::std::string&
Test::OptionalReturn2::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::OptionalReturn2::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::Test::OptionalReturn2";
    return typeId;
#else
    return iceC_Test_OptionalReturn2_ids[1];
#endif
}

/// \cond INTERNAL
bool
Test::OptionalReturn2::_iceD_op(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    IceUtil::Optional< ::Ice::Int> ret = this->op(current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(1, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

namespace
{
const ::std::string iceC_Test_OptionalReturn2_all[] =
{
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "op"
};

}

/// \cond INTERNAL
bool
Test::OptionalReturn2::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_Test_OptionalReturn2_all, iceC_Test_OptionalReturn2_all + 5, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_Test_OptionalReturn2_all)
    {
        case 0:
        {
            return _iceD_ice_id(in, current);
        }
        case 1:
        {
            return _iceD_ice_ids(in, current);
        }
        case 2:
        {
            return _iceD_ice_isA(in, current);
        }
        case 3:
        {
            return _iceD_ice_ping(in, current);
        }
        case 4:
        {
            return _iceD_op(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

/// \cond STREAM
void
Test::OptionalReturn2::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< OptionalReturn2, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Test::OptionalReturn2::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< OptionalReturn2, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

/// \cond INTERNAL
void
Test::_icePatchObjectPtr(OptionalReturn2Ptr& handle, const ::Ice::ObjectPtr& v)
{
    handle = OptionalReturn2Ptr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(OptionalReturn2::ice_staticId(), v);
    }
}
/// \endcond

Test::LocalClass::~LocalClass()
{
}

/// \cond INTERNAL
::Ice::LocalObject* Test::upCast(LocalClass* p) { return p; }
/// \endcond

namespace Ice
{
}

#endif
