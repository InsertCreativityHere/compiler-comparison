//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.7.10
//
// <auto-generated>
//
// Generated from file `CTypes.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __CTypes_h__
#define __CTypes_h__

#include <IceUtil/PushDisableWarnings.h>
#include <Ice/ProxyF.h>
#include <Ice/ObjectF.h>
#include <Ice/ValueF.h>
#include <Ice/Exception.h>
#include <Ice/LocalObject.h>
#include <Ice/StreamHelpers.h>
#include <Ice/Comparable.h>
#include <Ice/Proxy.h>
#include <Ice/Object.h>
#include <Ice/GCObject.h>
#include <Ice/Value.h>
#include <Ice/Incoming.h>
#include <Ice/FactoryTableInit.h>
#include <IceUtil/ScopedArray.h>
#include <Ice/Optional.h>
#include <Ice/ExceptionHelpers.h>
#include <IceUtil/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 307
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 >= 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 10
#       error Ice patch level mismatch!
#   endif
#endif

#ifdef ICE_CPP11_MAPPING // C++11 mapping

namespace Test
{

class Interface1;
class Interface1Prx;
class Interface2;
class Interface2Prx;
class Interface3;
class Interface3Prx;
class Interface4;
class Interface4Prx;
class EmptyClass1;
class EmptyClass2;
class EmptyClass3;
class EmptyClass4;
class EmptyClass5;
class SimpleClass1;
class SimpleClass2;
class SimpleClass3;
class SimpleClass4;
class SimpleClass5;
class SimpleClass6;
class SimpleClass7;
class BaseInterface1;
class BaseInterface1Prx;
class BaseInterface2;
class BaseInterface2Prx;
class BaseInterface3;
class BaseInterface3Prx;
class BaseInterface4;
class BaseInterface4Prx;
class BaseInterface5;
class BaseInterface5Prx;
class BaseInterface6;
class BaseInterface6Prx;
class BaseInterface7;
class BaseInterface7Prx;
class BaseInterface8;
class BaseInterface8Prx;
class BaseInterface9;
class BaseInterface9Prx;
class BaseInterface10;
class BaseInterface10Prx;
class BaseInterface11;
class BaseInterface11Prx;
class Compact1;
class Derived1;
class Compact2;
class Optional0;
class Optional1;
class Optional2;
class Optional3;
class Optional4;
class OptionalParameters0;
class OptionalParameters0Prx;
class OptionalParameters1;
class OptionalParameters1Prx;
class OptionalParameters2;
class OptionalParameters2Prx;
class OptionalParameters3;
class OptionalParameters3Prx;
class OptionalReturn0;
class OptionalReturn0Prx;
class OptionalReturn2;
class OptionalReturn2Prx;
class LocalClass;

}

namespace Test
{

constexpr int IntConst1 = 100;

constexpr int IntConst2 = 100;

constexpr int IntConst3 = 100;

enum class Enum1 : unsigned char
{
    Enum11,
    Enum12,
    Enum13
};

enum class Enum2 : unsigned char
{
    Enum21,
    Enum22,
    Enum23
};

enum class Enum3 : unsigned char
{
    Enum31,
    Enum32,
    Enum33
};

enum class Enum4 : unsigned char
{
    Enum41,
    Enum42,
    Enum43
};

enum class EnumExplicit0 : unsigned char
{
    EnumExplicit01 = 1,
    EnumExplicit02 = 2,
    EnumExplicit03 = 3
};

enum class EnumExplicit1 : unsigned char
{
    EnumExplicit11 = 1,
    EnumExplicit12 = 2,
    EnumExplicit13 = 3
};

enum class EnumExplicit2 : unsigned char
{
    EnumExplicit21 = 1,
    EnumExplicit22 = 2,
    EnumExplicit23 = 3
};

enum class EnumExplicit3 : unsigned char
{
    EnumExplicit31 = 1,
    EnumExplicit32 = 2,
    EnumExplicit33 = 3
};

using Sequence1 = ::std::vector<int>;

using Sequence2 = ::std::vector<int>;

using Sequence3 = ::std::vector<int>;

using Dictionary1 = ::std::map<::std::string, int>;

using Dictionary2 = ::std::map<::std::string, int>;

using Dictionary3 = ::std::map<::std::string, int>;

using Dictionary4 = ::std::map<::std::string, int>;

struct Struct1
{
    ::std::string str;
    bool b;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const bool&> ice_tuple() const
    {
        return std::tie(str, b);
    }
};

struct Struct2
{
    ::std::string str;
    bool b;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const bool&> ice_tuple() const
    {
        return std::tie(str, b);
    }
};

struct Struct3
{
    ::std::string str;
    bool b;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const bool&> ice_tuple() const
    {
        return std::tie(str, b);
    }
};

struct Struct4
{
    ::std::string str;
    bool b;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const bool&> ice_tuple() const
    {
        return std::tie(str, b);
    }
};

struct Struct5
{
    ::std::string str;
    bool b;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const bool&> ice_tuple() const
    {
        return std::tie(str, b);
    }
};

class Exception1 : public ::Ice::UserExceptionHelper<Exception1, ::Ice::UserException>
{
public:

    virtual ~Exception1();

    Exception1(const Exception1&) = default;

    Exception1() = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    Exception1(const ::std::string& str, bool b) :
        str(str),
        b(b)
    {
    }

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const bool&> ice_tuple() const
    {
        return std::tie(str, b);
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::std::string str;
    bool b;
};

/// \cond INTERNAL
static Exception1 _iceS_Exception1_init;
/// \endcond

class Exception2 : public ::Ice::UserExceptionHelper<Exception2, ::Ice::UserException>
{
public:

    virtual ~Exception2();

    Exception2(const Exception2&) = default;

    Exception2() = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    Exception2(const ::std::string& str, bool b) :
        str(str),
        b(b)
    {
    }

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const bool&> ice_tuple() const
    {
        return std::tie(str, b);
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::std::string str;
    bool b;
};

class Exception3 : public ::Ice::UserExceptionHelper<Exception3, ::Ice::UserException>
{
public:

    virtual ~Exception3();

    Exception3(const Exception3&) = default;

    Exception3() = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    Exception3(const ::std::string& str, bool b) :
        str(str),
        b(b)
    {
    }

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const bool&> ice_tuple() const
    {
        return std::tie(str, b);
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::std::string str;
    bool b;
};

class Exception4 : public ::Ice::UserExceptionHelper<Exception4, ::Ice::UserException>
{
public:

    virtual ~Exception4();

    Exception4(const Exception4&) = default;

    Exception4() = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    Exception4(const ::std::string& str, bool b) :
        str(str),
        b(b)
    {
    }

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const bool&> ice_tuple() const
    {
        return std::tie(str, b);
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::std::string str;
    bool b;
};

class Exception5 : public ::Ice::UserExceptionHelper<Exception5, ::Ice::UserException>
{
public:

    virtual ~Exception5();

    Exception5(const Exception5&) = default;

    Exception5() = default;

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<> ice_tuple() const
    {
        return std::tie();
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();
};

class Exception6 : public ::Ice::UserExceptionHelper<Exception6, ::Ice::UserException>
{
public:

    virtual ~Exception6();

    Exception6(const Exception6&) = default;

    Exception6() = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    Exception6(const ::std::string& str, bool b) :
        str(str),
        b(b)
    {
    }

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const bool&> ice_tuple() const
    {
        return std::tie(str, b);
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::std::string str;
    bool b;
};

class OptionalEx0 : public ::Ice::UserExceptionHelper<OptionalEx0, ::Ice::UserException>
{
public:

    virtual ~OptionalEx0();

    OptionalEx0(const OptionalEx0&) = default;

    OptionalEx0() = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    OptionalEx0(const ::std::string& firstName, const Ice::optional<::std::string>& secondName, const Ice::optional<::std::string>& emailAddress) :
        firstName(firstName),
        secondName(secondName),
        emailAddress(emailAddress)
    {
    }

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const Ice::optional<::std::string>&, const Ice::optional<::std::string>&> ice_tuple() const
    {
        return std::tie(firstName, secondName, emailAddress);
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::std::string firstName;
    Ice::optional<::std::string> secondName;
    Ice::optional<::std::string> emailAddress;
};

class OptionalEx1 : public ::Ice::UserExceptionHelper<OptionalEx1, ::Ice::UserException>
{
public:

    virtual ~OptionalEx1();

    OptionalEx1(const OptionalEx1&) = default;

    OptionalEx1() = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    OptionalEx1(const ::std::string& firstName, const Ice::optional<::std::string>& secondName, const Ice::optional<::std::string>& emailAddress) :
        firstName(firstName),
        secondName(secondName),
        emailAddress(emailAddress)
    {
    }

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const Ice::optional<::std::string>&, const Ice::optional<::std::string>&> ice_tuple() const
    {
        return std::tie(firstName, secondName, emailAddress);
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::std::string firstName;
    Ice::optional<::std::string> secondName;
    Ice::optional<::std::string> emailAddress;
};

class OptionalEx2 : public ::Ice::UserExceptionHelper<OptionalEx2, ::Ice::UserException>
{
public:

    virtual ~OptionalEx2();

    OptionalEx2(const OptionalEx2&) = default;

    OptionalEx2() = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    OptionalEx2(const ::std::string& firstName, const ::std::string& secondName, const Ice::optional<::std::string>& emailAddress) :
        firstName(firstName),
        secondName(secondName),
        emailAddress(emailAddress)
    {
    }

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::std::string&, const Ice::optional<::std::string>&> ice_tuple() const
    {
        return std::tie(firstName, secondName, emailAddress);
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::std::string firstName;
    ::std::string secondName;
    Ice::optional<::std::string> emailAddress;
};

class OptionalEx3 : public ::Ice::UserExceptionHelper<OptionalEx3, ::Ice::UserException>
{
public:

    virtual ~OptionalEx3();

    OptionalEx3(const OptionalEx3&) = default;

    OptionalEx3() = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    OptionalEx3(const ::std::string& firstName, const Ice::optional<::std::string>& secondName, const Ice::optional<::std::string>& emailAddress) :
        firstName(firstName),
        secondName(secondName),
        emailAddress(emailAddress)
    {
    }

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const Ice::optional<::std::string>&, const Ice::optional<::std::string>&> ice_tuple() const
    {
        return std::tie(firstName, secondName, emailAddress);
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::std::string firstName;
    Ice::optional<::std::string> secondName;
    Ice::optional<::std::string> emailAddress;
};

class OptionalEx4 : public ::Ice::UserExceptionHelper<OptionalEx4, ::Ice::UserException>
{
public:

    virtual ~OptionalEx4();

    OptionalEx4(const OptionalEx4&) = default;

    OptionalEx4() = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    OptionalEx4(const ::std::string& firstName, const Ice::optional<::std::string>& secondName, const Ice::optional<::std::string>& emailAddress) :
        firstName(firstName),
        secondName(secondName),
        emailAddress(emailAddress)
    {
    }

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const Ice::optional<::std::string>&, const Ice::optional<::std::string>&> ice_tuple() const
    {
        return std::tie(firstName, secondName, emailAddress);
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::std::string firstName;
    Ice::optional<::std::string> secondName;
    Ice::optional<::std::string> emailAddress;
};

enum class LocalEnum : unsigned char
{
    LocalEnum1,
    LocalEnum2,
    LocalEnum3
};

using LocalSequence = ::std::vector<::std::string>;

using LocalDictionary = ::std::map<::std::string, ::std::string>;

struct LocalStruct
{
    ::std::string str;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&> ice_tuple() const
    {
        return std::tie(str);
    }
};

using Ice::operator<;
using Ice::operator<=;
using Ice::operator>;
using Ice::operator>=;
using Ice::operator==;
using Ice::operator!=;

}

namespace Test
{

class LocalClass
{
public:

    virtual ~LocalClass();

    LocalClass() = default;

    LocalClass(const LocalClass&) = default;
    LocalClass(LocalClass&&) = default;
    LocalClass& operator=(const LocalClass&) = default;
    LocalClass& operator=(LocalClass&&) = default;
};

}

namespace Test
{

class Interface1 : public virtual ::Ice::Object
{
public:

    using ProxyType = Interface1Prx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();
};

class Interface2 : public virtual ::Ice::Object
{
public:

    using ProxyType = Interface2Prx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();
};

class Interface3 : public virtual ::Ice::Object
{
public:

    using ProxyType = Interface3Prx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();
};

class Interface4 : public virtual ::Ice::Object
{
public:

    using ProxyType = Interface4Prx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();
};

class BaseInterface1 : public virtual ::Ice::Object
{
public:

    using ProxyType = BaseInterface1Prx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void baseOp1(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_baseOp1(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void baseOp2(int i, ::std::string& s, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_baseOp2(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

class BaseInterface2 : public virtual ::Ice::Object
{
public:

    using ProxyType = BaseInterface2Prx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void baseOp(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_baseOp(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void baseOp2(int i, ::std::string& s, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_baseOp2(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

class BaseInterface3 : public virtual ::Ice::Object
{
public:

    using ProxyType = BaseInterface3Prx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void baseOp(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_baseOp(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void baseOp2(int i, ::std::string& s, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_baseOp2(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

class BaseInterface4 : public virtual ::Ice::Object
{
public:

    using ProxyType = BaseInterface4Prx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void baseOp(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_baseOp(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void baseOp2(int i, ::std::string& s, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_baseOp2(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

class BaseInterface5 : public virtual ::Ice::Object
{
public:

    using ProxyType = BaseInterface5Prx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void baseOp(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_baseOp(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void baseOp2(int i, ::std::string& s, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_baseOp2(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

class BaseInterface6 : public virtual ::Ice::Object
{
public:

    using ProxyType = BaseInterface6Prx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void baseOp(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_baseOp(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void baseOp2(int i, ::std::string& s, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_baseOp2(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

class BaseInterface7 : public virtual ::Ice::Object
{
public:

    using ProxyType = BaseInterface7Prx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void baseOp(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_baseOp(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void baseOp2(int i, ::std::string& s, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_baseOp2(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

class BaseInterface8 : public virtual ::Ice::Object
{
public:

    using ProxyType = BaseInterface8Prx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void baseOp(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_baseOp(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void baseOp2(int i, ::std::string& s, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_baseOp2(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

class BaseInterface9 : public virtual ::Ice::Object
{
public:

    using ProxyType = BaseInterface9Prx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void baseOp(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_baseOp(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void baseOp2(int i, ::std::string& s, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_baseOp2(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

class BaseInterface10 : public virtual ::Ice::Object
{
public:

    using ProxyType = BaseInterface10Prx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void baseOp(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_baseOp(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void baseOp2(int i, ::std::string& s, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_baseOp2(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

class BaseInterface11 : public virtual ::Ice::Object
{
public:

    using ProxyType = BaseInterface11Prx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void baseOp(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_baseOp(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void baseOp2(int i, ::std::string& s, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_baseOp2(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

class OptionalParameters0 : public virtual ::Ice::Object
{
public:

    using ProxyType = OptionalParameters0Prx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void op1(::std::string firstName, Ice::optional<::std::string> secondName, Ice::optional<::std::string> emailAddress, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_op1(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

class OptionalParameters1 : public virtual ::Ice::Object
{
public:

    using ProxyType = OptionalParameters1Prx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void op1(::std::string firstName, Ice::optional<::std::string> secondName, Ice::optional<::std::string> emailAddress, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_op1(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

class OptionalParameters2 : public virtual ::Ice::Object
{
public:

    using ProxyType = OptionalParameters2Prx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void op1(::std::string firstName, Ice::optional<::std::string> emailAddress, Ice::optional<::std::string> secondName, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_op1(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

class OptionalParameters3 : public virtual ::Ice::Object
{
public:

    using ProxyType = OptionalParameters3Prx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void op1(::std::string firstName, Ice::optional<::std::string> emailAddress, ::std::string secondName, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_op1(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

class OptionalReturn0 : public virtual ::Ice::Object
{
public:

    using ProxyType = OptionalReturn0Prx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual Ice::optional<int> op(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_op(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

class OptionalReturn2 : public virtual ::Ice::Object
{
public:

    using ProxyType = OptionalReturn2Prx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual Ice::optional<int> op(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_op(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

}

namespace Test
{

class EmptyClass1 : public ::Ice::ValueHelper<EmptyClass1, ::Ice::Value>
{
public:

    virtual ~EmptyClass1();

    EmptyClass1() = default;

    EmptyClass1(const EmptyClass1&) = default;
    EmptyClass1(EmptyClass1&&) = default;
    EmptyClass1& operator=(const EmptyClass1&) = default;
    EmptyClass1& operator=(EmptyClass1&&) = default;

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<> ice_tuple() const
    {
        return std::tie();
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();
};

/// \cond INTERNAL
static EmptyClass1 _iceS_EmptyClass1_init;
/// \endcond

class EmptyClass2 : public ::Ice::ValueHelper<EmptyClass2, ::Ice::Value>
{
public:

    virtual ~EmptyClass2();

    EmptyClass2() = default;

    EmptyClass2(const EmptyClass2&) = default;
    EmptyClass2(EmptyClass2&&) = default;
    EmptyClass2& operator=(const EmptyClass2&) = default;
    EmptyClass2& operator=(EmptyClass2&&) = default;

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<> ice_tuple() const
    {
        return std::tie();
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();
};

class EmptyClass3 : public ::Ice::ValueHelper<EmptyClass3, ::Ice::Value>
{
public:

    virtual ~EmptyClass3();

    EmptyClass3() = default;

    EmptyClass3(const EmptyClass3&) = default;
    EmptyClass3(EmptyClass3&&) = default;
    EmptyClass3& operator=(const EmptyClass3&) = default;
    EmptyClass3& operator=(EmptyClass3&&) = default;

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<> ice_tuple() const
    {
        return std::tie();
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();
};

class EmptyClass4 : public ::Ice::ValueHelper<EmptyClass4, ::Ice::Value>
{
public:

    virtual ~EmptyClass4();

    EmptyClass4() = default;

    EmptyClass4(const EmptyClass4&) = default;
    EmptyClass4(EmptyClass4&&) = default;
    EmptyClass4& operator=(const EmptyClass4&) = default;
    EmptyClass4& operator=(EmptyClass4&&) = default;

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<> ice_tuple() const
    {
        return std::tie();
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();
};

class EmptyClass5 : public ::Ice::ValueHelper<EmptyClass5, ::Ice::Value>
{
public:

    virtual ~EmptyClass5();

    EmptyClass5() = default;

    EmptyClass5(const EmptyClass5&) = default;
    EmptyClass5(EmptyClass5&&) = default;
    EmptyClass5& operator=(const EmptyClass5&) = default;
    EmptyClass5& operator=(EmptyClass5&&) = default;

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<> ice_tuple() const
    {
        return std::tie();
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();
};

class SimpleClass1 : public ::Ice::ValueHelper<SimpleClass1, ::Ice::Value>
{
public:

    virtual ~SimpleClass1();

    SimpleClass1() = default;

    SimpleClass1(const SimpleClass1&) = default;
    SimpleClass1(SimpleClass1&&) = default;
    SimpleClass1& operator=(const SimpleClass1&) = default;
    SimpleClass1& operator=(SimpleClass1&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    SimpleClass1(const ::std::string& str, float f) :
        str(str),
        f(f)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const float&> ice_tuple() const
    {
        return std::tie(str, f);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::std::string str;
    float f;
};

class SimpleClass2 : public ::Ice::ValueHelper<SimpleClass2, ::Ice::Value>
{
public:

    virtual ~SimpleClass2();

    SimpleClass2() = default;

    SimpleClass2(const SimpleClass2&) = default;
    SimpleClass2(SimpleClass2&&) = default;
    SimpleClass2& operator=(const SimpleClass2&) = default;
    SimpleClass2& operator=(SimpleClass2&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    SimpleClass2(const ::std::string& str, float f) :
        str(str),
        f(f)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const float&> ice_tuple() const
    {
        return std::tie(str, f);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::std::string str;
    float f;
};

class SimpleClass3 : public ::Ice::ValueHelper<SimpleClass3, ::Ice::Value>
{
public:

    virtual ~SimpleClass3();

    SimpleClass3() = default;

    SimpleClass3(const SimpleClass3&) = default;
    SimpleClass3(SimpleClass3&&) = default;
    SimpleClass3& operator=(const SimpleClass3&) = default;
    SimpleClass3& operator=(SimpleClass3&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    SimpleClass3(const ::std::string& str, float f) :
        str(str),
        f(f)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const float&> ice_tuple() const
    {
        return std::tie(str, f);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::std::string str;
    float f;
};

class SimpleClass4 : public ::Ice::ValueHelper<SimpleClass4, ::Ice::Value>
{
public:

    virtual ~SimpleClass4();

    SimpleClass4() = default;

    SimpleClass4(const SimpleClass4&) = default;
    SimpleClass4(SimpleClass4&&) = default;
    SimpleClass4& operator=(const SimpleClass4&) = default;
    SimpleClass4& operator=(SimpleClass4&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    SimpleClass4(const ::std::string& str, float f) :
        str(str),
        f(f)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const float&> ice_tuple() const
    {
        return std::tie(str, f);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::std::string str;
    float f;
};

class SimpleClass5 : public ::Ice::ValueHelper<SimpleClass5, ::Ice::Value>
{
public:

    virtual ~SimpleClass5();

    SimpleClass5() = default;

    SimpleClass5(const SimpleClass5&) = default;
    SimpleClass5(SimpleClass5&&) = default;
    SimpleClass5& operator=(const SimpleClass5&) = default;
    SimpleClass5& operator=(SimpleClass5&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    SimpleClass5(const ::std::string& str, float f) :
        str(str),
        f(f)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const float&> ice_tuple() const
    {
        return std::tie(str, f);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::std::string str;
    float f;
};

class SimpleClass6 : public ::Ice::ValueHelper<SimpleClass6, ::Ice::Value>
{
public:

    virtual ~SimpleClass6();

    SimpleClass6() = default;

    SimpleClass6(const SimpleClass6&) = default;
    SimpleClass6(SimpleClass6&&) = default;
    SimpleClass6& operator=(const SimpleClass6&) = default;
    SimpleClass6& operator=(SimpleClass6&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    SimpleClass6(const ::std::string& str, float f) :
        str(str),
        f(f)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const float&> ice_tuple() const
    {
        return std::tie(str, f);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::std::string str;
    float f;
};

class SimpleClass7 : public ::Ice::ValueHelper<SimpleClass7, ::Ice::Value>
{
public:

    virtual ~SimpleClass7();

    SimpleClass7() = default;

    SimpleClass7(const SimpleClass7&) = default;
    SimpleClass7(SimpleClass7&&) = default;
    SimpleClass7& operator=(const SimpleClass7&) = default;
    SimpleClass7& operator=(SimpleClass7&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    SimpleClass7(const ::std::string& str, float f) :
        str(str),
        f(f)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const float&> ice_tuple() const
    {
        return std::tie(str, f);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::std::string str;
    float f;
};

class Compact1 : public ::Ice::ValueHelper<Compact1, ::Ice::Value>
{
public:

    virtual ~Compact1();

    Compact1() = default;

    Compact1(const Compact1&) = default;
    Compact1(Compact1&&) = default;
    Compact1& operator=(const Compact1&) = default;
    Compact1& operator=(Compact1&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit Compact1(int id) :
        id(id)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const int&> ice_tuple() const
    {
        return std::tie(id);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    int id;
};

class Derived1 : public ::Ice::ValueHelper<Derived1, Compact1>
{
public:

    virtual ~Derived1();

    Derived1() = default;

    Derived1(const Derived1&) = default;
    Derived1(Derived1&&) = default;
    Derived1& operator=(const Derived1&) = default;
    Derived1& operator=(Derived1&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit Derived1(int id) :
        Ice::ValueHelper<Derived1, Compact1>(id)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const int&> ice_tuple() const
    {
        return std::tie(id);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();
};

class Compact2 : public ::Ice::ValueHelper<Compact2, ::Ice::Value>
{
public:

    virtual ~Compact2();

    Compact2() = default;

    Compact2(const Compact2&) = default;
    Compact2(Compact2&&) = default;
    Compact2& operator=(const Compact2&) = default;
    Compact2& operator=(Compact2&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit Compact2(int id) :
        id(id)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const int&> ice_tuple() const
    {
        return std::tie(id);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    int id;
};

class Optional0 : public ::Ice::ValueHelper<Optional0, ::Ice::Value>
{
public:

    virtual ~Optional0();

    Optional0() = default;

    Optional0(const Optional0&) = default;
    Optional0(Optional0&&) = default;
    Optional0& operator=(const Optional0&) = default;
    Optional0& operator=(Optional0&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    Optional0(const ::std::string& firstName, const Ice::optional<::std::string>& secondName, const Ice::optional<::std::string>& emailAddress) :
        firstName(firstName),
        secondName(secondName),
        emailAddress(emailAddress)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const Ice::optional<::std::string>&, const Ice::optional<::std::string>&> ice_tuple() const
    {
        return std::tie(firstName, secondName, emailAddress);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::std::string firstName;
    Ice::optional<::std::string> secondName;
    Ice::optional<::std::string> emailAddress;
};

class Optional1 : public ::Ice::ValueHelper<Optional1, ::Ice::Value>
{
public:

    virtual ~Optional1();

    Optional1() = default;

    Optional1(const Optional1&) = default;
    Optional1(Optional1&&) = default;
    Optional1& operator=(const Optional1&) = default;
    Optional1& operator=(Optional1&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    Optional1(const ::std::string& firstName, const Ice::optional<::std::string>& secondName, const Ice::optional<::std::string>& emailAddress) :
        firstName(firstName),
        secondName(secondName),
        emailAddress(emailAddress)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const Ice::optional<::std::string>&, const Ice::optional<::std::string>&> ice_tuple() const
    {
        return std::tie(firstName, secondName, emailAddress);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::std::string firstName;
    Ice::optional<::std::string> secondName;
    Ice::optional<::std::string> emailAddress;
};

class Optional2 : public ::Ice::ValueHelper<Optional2, ::Ice::Value>
{
public:

    virtual ~Optional2();

    Optional2() = default;

    Optional2(const Optional2&) = default;
    Optional2(Optional2&&) = default;
    Optional2& operator=(const Optional2&) = default;
    Optional2& operator=(Optional2&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    Optional2(const ::std::string& firstName, const ::std::string& secondName, const Ice::optional<::std::string>& emailAddress) :
        firstName(firstName),
        secondName(secondName),
        emailAddress(emailAddress)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::std::string&, const Ice::optional<::std::string>&> ice_tuple() const
    {
        return std::tie(firstName, secondName, emailAddress);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::std::string firstName;
    ::std::string secondName;
    Ice::optional<::std::string> emailAddress;
};

class Optional3 : public ::Ice::ValueHelper<Optional3, ::Ice::Value>
{
public:

    virtual ~Optional3();

    Optional3() = default;

    Optional3(const Optional3&) = default;
    Optional3(Optional3&&) = default;
    Optional3& operator=(const Optional3&) = default;
    Optional3& operator=(Optional3&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    Optional3(const ::std::string& firstName, const Ice::optional<::std::string>& secondName, const Ice::optional<::std::string>& emailAddress) :
        firstName(firstName),
        secondName(secondName),
        emailAddress(emailAddress)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const Ice::optional<::std::string>&, const Ice::optional<::std::string>&> ice_tuple() const
    {
        return std::tie(firstName, secondName, emailAddress);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::std::string firstName;
    Ice::optional<::std::string> secondName;
    Ice::optional<::std::string> emailAddress;
};

class Optional4 : public ::Ice::ValueHelper<Optional4, ::Ice::Value>
{
public:

    virtual ~Optional4();

    Optional4() = default;

    Optional4(const Optional4&) = default;
    Optional4(Optional4&&) = default;
    Optional4& operator=(const Optional4&) = default;
    Optional4& operator=(Optional4&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    Optional4(const ::std::string& firstName, const Ice::optional<::std::string>& secondName, const Ice::optional<::std::string>& emailAddress) :
        firstName(firstName),
        secondName(secondName),
        emailAddress(emailAddress)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const Ice::optional<::std::string>&, const Ice::optional<::std::string>&> ice_tuple() const
    {
        return std::tie(firstName, secondName, emailAddress);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    ::std::string firstName;
    Ice::optional<::std::string> secondName;
    Ice::optional<::std::string> emailAddress;
};

}

namespace Test
{

class Interface1Prx : public virtual ::Ice::Proxy<Interface1Prx, ::Ice::ObjectPrx>
{
public:

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    Interface1Prx() = default;
    friend ::std::shared_ptr<Interface1Prx> IceInternal::createProxy<Interface1Prx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

class Interface2Prx : public virtual ::Ice::Proxy<Interface2Prx, ::Ice::ObjectPrx>
{
public:

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    Interface2Prx() = default;
    friend ::std::shared_ptr<Interface2Prx> IceInternal::createProxy<Interface2Prx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

class Interface3Prx : public virtual ::Ice::Proxy<Interface3Prx, ::Ice::ObjectPrx>
{
public:

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    Interface3Prx() = default;
    friend ::std::shared_ptr<Interface3Prx> IceInternal::createProxy<Interface3Prx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

class Interface4Prx : public virtual ::Ice::Proxy<Interface4Prx, ::Ice::ObjectPrx>
{
public:

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    Interface4Prx() = default;
    friend ::std::shared_ptr<Interface4Prx> IceInternal::createProxy<Interface4Prx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

class BaseInterface1Prx : public virtual ::Ice::Proxy<BaseInterface1Prx, ::Ice::ObjectPrx>
{
public:

    void baseOp1(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &BaseInterface1Prx::_iceI_baseOp1, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto baseOp1Async(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &BaseInterface1Prx::_iceI_baseOp1, context);
    }

    ::std::function<void()>
    baseOp1Async(::std::function<void()> response,
                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                 ::std::function<void(bool)> sent = nullptr,
                 const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::BaseInterface1Prx::_iceI_baseOp1, context);
    }

    /// \cond INTERNAL
    void _iceI_baseOp1(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    void baseOp2(int i, ::std::string& s, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        s = _makePromiseOutgoing<::std::string>(true, this, &BaseInterface1Prx::_iceI_baseOp2, i, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto baseOp2Async(int i, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::string>>().get_future())
    {
        return _makePromiseOutgoing<::std::string, P>(false, this, &BaseInterface1Prx::_iceI_baseOp2, i, context);
    }

    ::std::function<void()>
    baseOp2Async(int i,
                 ::std::function<void(::std::string)> response,
                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                 ::std::function<void(bool)> sent = nullptr,
                 const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::std::string>(std::move(response), std::move(ex), std::move(sent), this, &Test::BaseInterface1Prx::_iceI_baseOp2, i, context);
    }

    /// \cond INTERNAL
    void _iceI_baseOp2(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::string>>&, int, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    BaseInterface1Prx() = default;
    friend ::std::shared_ptr<BaseInterface1Prx> IceInternal::createProxy<BaseInterface1Prx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

class BaseInterface2Prx : public virtual ::Ice::Proxy<BaseInterface2Prx, ::Ice::ObjectPrx>
{
public:

    void baseOp(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &BaseInterface2Prx::_iceI_baseOp, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto baseOpAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &BaseInterface2Prx::_iceI_baseOp, context);
    }

    ::std::function<void()>
    baseOpAsync(::std::function<void()> response,
                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                ::std::function<void(bool)> sent = nullptr,
                const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::BaseInterface2Prx::_iceI_baseOp, context);
    }

    /// \cond INTERNAL
    void _iceI_baseOp(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    void baseOp2(int i, ::std::string& s, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        s = _makePromiseOutgoing<::std::string>(true, this, &BaseInterface2Prx::_iceI_baseOp2, i, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto baseOp2Async(int i, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::string>>().get_future())
    {
        return _makePromiseOutgoing<::std::string, P>(false, this, &BaseInterface2Prx::_iceI_baseOp2, i, context);
    }

    ::std::function<void()>
    baseOp2Async(int i,
                 ::std::function<void(::std::string)> response,
                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                 ::std::function<void(bool)> sent = nullptr,
                 const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::std::string>(std::move(response), std::move(ex), std::move(sent), this, &Test::BaseInterface2Prx::_iceI_baseOp2, i, context);
    }

    /// \cond INTERNAL
    void _iceI_baseOp2(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::string>>&, int, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    BaseInterface2Prx() = default;
    friend ::std::shared_ptr<BaseInterface2Prx> IceInternal::createProxy<BaseInterface2Prx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

class BaseInterface3Prx : public virtual ::Ice::Proxy<BaseInterface3Prx, ::Ice::ObjectPrx>
{
public:

    void baseOp(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &BaseInterface3Prx::_iceI_baseOp, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto baseOpAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &BaseInterface3Prx::_iceI_baseOp, context);
    }

    ::std::function<void()>
    baseOpAsync(::std::function<void()> response,
                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                ::std::function<void(bool)> sent = nullptr,
                const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::BaseInterface3Prx::_iceI_baseOp, context);
    }

    /// \cond INTERNAL
    void _iceI_baseOp(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    void baseOp2(int i, ::std::string& s, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        s = _makePromiseOutgoing<::std::string>(true, this, &BaseInterface3Prx::_iceI_baseOp2, i, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto baseOp2Async(int i, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::string>>().get_future())
    {
        return _makePromiseOutgoing<::std::string, P>(false, this, &BaseInterface3Prx::_iceI_baseOp2, i, context);
    }

    ::std::function<void()>
    baseOp2Async(int i,
                 ::std::function<void(::std::string)> response,
                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                 ::std::function<void(bool)> sent = nullptr,
                 const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::std::string>(std::move(response), std::move(ex), std::move(sent), this, &Test::BaseInterface3Prx::_iceI_baseOp2, i, context);
    }

    /// \cond INTERNAL
    void _iceI_baseOp2(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::string>>&, int, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    BaseInterface3Prx() = default;
    friend ::std::shared_ptr<BaseInterface3Prx> IceInternal::createProxy<BaseInterface3Prx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

class BaseInterface4Prx : public virtual ::Ice::Proxy<BaseInterface4Prx, ::Ice::ObjectPrx>
{
public:

    void baseOp(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &BaseInterface4Prx::_iceI_baseOp, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto baseOpAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &BaseInterface4Prx::_iceI_baseOp, context);
    }

    ::std::function<void()>
    baseOpAsync(::std::function<void()> response,
                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                ::std::function<void(bool)> sent = nullptr,
                const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::BaseInterface4Prx::_iceI_baseOp, context);
    }

    /// \cond INTERNAL
    void _iceI_baseOp(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    void baseOp2(int i, ::std::string& s, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        s = _makePromiseOutgoing<::std::string>(true, this, &BaseInterface4Prx::_iceI_baseOp2, i, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto baseOp2Async(int i, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::string>>().get_future())
    {
        return _makePromiseOutgoing<::std::string, P>(false, this, &BaseInterface4Prx::_iceI_baseOp2, i, context);
    }

    ::std::function<void()>
    baseOp2Async(int i,
                 ::std::function<void(::std::string)> response,
                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                 ::std::function<void(bool)> sent = nullptr,
                 const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::std::string>(std::move(response), std::move(ex), std::move(sent), this, &Test::BaseInterface4Prx::_iceI_baseOp2, i, context);
    }

    /// \cond INTERNAL
    void _iceI_baseOp2(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::string>>&, int, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    BaseInterface4Prx() = default;
    friend ::std::shared_ptr<BaseInterface4Prx> IceInternal::createProxy<BaseInterface4Prx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

class BaseInterface5Prx : public virtual ::Ice::Proxy<BaseInterface5Prx, ::Ice::ObjectPrx>
{
public:

    void baseOp(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &BaseInterface5Prx::_iceI_baseOp, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto baseOpAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &BaseInterface5Prx::_iceI_baseOp, context);
    }

    ::std::function<void()>
    baseOpAsync(::std::function<void()> response,
                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                ::std::function<void(bool)> sent = nullptr,
                const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::BaseInterface5Prx::_iceI_baseOp, context);
    }

    /// \cond INTERNAL
    void _iceI_baseOp(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    void baseOp2(int i, ::std::string& s, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        s = _makePromiseOutgoing<::std::string>(true, this, &BaseInterface5Prx::_iceI_baseOp2, i, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto baseOp2Async(int i, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::string>>().get_future())
    {
        return _makePromiseOutgoing<::std::string, P>(false, this, &BaseInterface5Prx::_iceI_baseOp2, i, context);
    }

    ::std::function<void()>
    baseOp2Async(int i,
                 ::std::function<void(::std::string)> response,
                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                 ::std::function<void(bool)> sent = nullptr,
                 const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::std::string>(std::move(response), std::move(ex), std::move(sent), this, &Test::BaseInterface5Prx::_iceI_baseOp2, i, context);
    }

    /// \cond INTERNAL
    void _iceI_baseOp2(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::string>>&, int, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    BaseInterface5Prx() = default;
    friend ::std::shared_ptr<BaseInterface5Prx> IceInternal::createProxy<BaseInterface5Prx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

class BaseInterface6Prx : public virtual ::Ice::Proxy<BaseInterface6Prx, ::Ice::ObjectPrx>
{
public:

    void baseOp(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &BaseInterface6Prx::_iceI_baseOp, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto baseOpAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &BaseInterface6Prx::_iceI_baseOp, context);
    }

    ::std::function<void()>
    baseOpAsync(::std::function<void()> response,
                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                ::std::function<void(bool)> sent = nullptr,
                const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::BaseInterface6Prx::_iceI_baseOp, context);
    }

    /// \cond INTERNAL
    void _iceI_baseOp(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    void baseOp2(int i, ::std::string& s, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        s = _makePromiseOutgoing<::std::string>(true, this, &BaseInterface6Prx::_iceI_baseOp2, i, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto baseOp2Async(int i, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::string>>().get_future())
    {
        return _makePromiseOutgoing<::std::string, P>(false, this, &BaseInterface6Prx::_iceI_baseOp2, i, context);
    }

    ::std::function<void()>
    baseOp2Async(int i,
                 ::std::function<void(::std::string)> response,
                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                 ::std::function<void(bool)> sent = nullptr,
                 const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::std::string>(std::move(response), std::move(ex), std::move(sent), this, &Test::BaseInterface6Prx::_iceI_baseOp2, i, context);
    }

    /// \cond INTERNAL
    void _iceI_baseOp2(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::string>>&, int, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    BaseInterface6Prx() = default;
    friend ::std::shared_ptr<BaseInterface6Prx> IceInternal::createProxy<BaseInterface6Prx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

class BaseInterface7Prx : public virtual ::Ice::Proxy<BaseInterface7Prx, ::Ice::ObjectPrx>
{
public:

    void baseOp(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &BaseInterface7Prx::_iceI_baseOp, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto baseOpAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &BaseInterface7Prx::_iceI_baseOp, context);
    }

    ::std::function<void()>
    baseOpAsync(::std::function<void()> response,
                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                ::std::function<void(bool)> sent = nullptr,
                const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::BaseInterface7Prx::_iceI_baseOp, context);
    }

    /// \cond INTERNAL
    void _iceI_baseOp(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    void baseOp2(int i, ::std::string& s, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        s = _makePromiseOutgoing<::std::string>(true, this, &BaseInterface7Prx::_iceI_baseOp2, i, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto baseOp2Async(int i, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::string>>().get_future())
    {
        return _makePromiseOutgoing<::std::string, P>(false, this, &BaseInterface7Prx::_iceI_baseOp2, i, context);
    }

    ::std::function<void()>
    baseOp2Async(int i,
                 ::std::function<void(::std::string)> response,
                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                 ::std::function<void(bool)> sent = nullptr,
                 const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::std::string>(std::move(response), std::move(ex), std::move(sent), this, &Test::BaseInterface7Prx::_iceI_baseOp2, i, context);
    }

    /// \cond INTERNAL
    void _iceI_baseOp2(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::string>>&, int, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    BaseInterface7Prx() = default;
    friend ::std::shared_ptr<BaseInterface7Prx> IceInternal::createProxy<BaseInterface7Prx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

class BaseInterface8Prx : public virtual ::Ice::Proxy<BaseInterface8Prx, ::Ice::ObjectPrx>
{
public:

    void baseOp(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &BaseInterface8Prx::_iceI_baseOp, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto baseOpAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &BaseInterface8Prx::_iceI_baseOp, context);
    }

    ::std::function<void()>
    baseOpAsync(::std::function<void()> response,
                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                ::std::function<void(bool)> sent = nullptr,
                const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::BaseInterface8Prx::_iceI_baseOp, context);
    }

    /// \cond INTERNAL
    void _iceI_baseOp(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    void baseOp2(int i, ::std::string& s, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        s = _makePromiseOutgoing<::std::string>(true, this, &BaseInterface8Prx::_iceI_baseOp2, i, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto baseOp2Async(int i, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::string>>().get_future())
    {
        return _makePromiseOutgoing<::std::string, P>(false, this, &BaseInterface8Prx::_iceI_baseOp2, i, context);
    }

    ::std::function<void()>
    baseOp2Async(int i,
                 ::std::function<void(::std::string)> response,
                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                 ::std::function<void(bool)> sent = nullptr,
                 const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::std::string>(std::move(response), std::move(ex), std::move(sent), this, &Test::BaseInterface8Prx::_iceI_baseOp2, i, context);
    }

    /// \cond INTERNAL
    void _iceI_baseOp2(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::string>>&, int, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    BaseInterface8Prx() = default;
    friend ::std::shared_ptr<BaseInterface8Prx> IceInternal::createProxy<BaseInterface8Prx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

class BaseInterface9Prx : public virtual ::Ice::Proxy<BaseInterface9Prx, ::Ice::ObjectPrx>
{
public:

    void baseOp(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &BaseInterface9Prx::_iceI_baseOp, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto baseOpAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &BaseInterface9Prx::_iceI_baseOp, context);
    }

    ::std::function<void()>
    baseOpAsync(::std::function<void()> response,
                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                ::std::function<void(bool)> sent = nullptr,
                const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::BaseInterface9Prx::_iceI_baseOp, context);
    }

    /// \cond INTERNAL
    void _iceI_baseOp(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    void baseOp2(int i, ::std::string& s, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        s = _makePromiseOutgoing<::std::string>(true, this, &BaseInterface9Prx::_iceI_baseOp2, i, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto baseOp2Async(int i, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::string>>().get_future())
    {
        return _makePromiseOutgoing<::std::string, P>(false, this, &BaseInterface9Prx::_iceI_baseOp2, i, context);
    }

    ::std::function<void()>
    baseOp2Async(int i,
                 ::std::function<void(::std::string)> response,
                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                 ::std::function<void(bool)> sent = nullptr,
                 const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::std::string>(std::move(response), std::move(ex), std::move(sent), this, &Test::BaseInterface9Prx::_iceI_baseOp2, i, context);
    }

    /// \cond INTERNAL
    void _iceI_baseOp2(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::string>>&, int, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    BaseInterface9Prx() = default;
    friend ::std::shared_ptr<BaseInterface9Prx> IceInternal::createProxy<BaseInterface9Prx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

class BaseInterface10Prx : public virtual ::Ice::Proxy<BaseInterface10Prx, ::Ice::ObjectPrx>
{
public:

    void baseOp(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &BaseInterface10Prx::_iceI_baseOp, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto baseOpAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &BaseInterface10Prx::_iceI_baseOp, context);
    }

    ::std::function<void()>
    baseOpAsync(::std::function<void()> response,
                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                ::std::function<void(bool)> sent = nullptr,
                const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::BaseInterface10Prx::_iceI_baseOp, context);
    }

    /// \cond INTERNAL
    void _iceI_baseOp(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    void baseOp2(int i, ::std::string& s, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        s = _makePromiseOutgoing<::std::string>(true, this, &BaseInterface10Prx::_iceI_baseOp2, i, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto baseOp2Async(int i, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::string>>().get_future())
    {
        return _makePromiseOutgoing<::std::string, P>(false, this, &BaseInterface10Prx::_iceI_baseOp2, i, context);
    }

    ::std::function<void()>
    baseOp2Async(int i,
                 ::std::function<void(::std::string)> response,
                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                 ::std::function<void(bool)> sent = nullptr,
                 const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::std::string>(std::move(response), std::move(ex), std::move(sent), this, &Test::BaseInterface10Prx::_iceI_baseOp2, i, context);
    }

    /// \cond INTERNAL
    void _iceI_baseOp2(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::string>>&, int, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    BaseInterface10Prx() = default;
    friend ::std::shared_ptr<BaseInterface10Prx> IceInternal::createProxy<BaseInterface10Prx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

class BaseInterface11Prx : public virtual ::Ice::Proxy<BaseInterface11Prx, ::Ice::ObjectPrx>
{
public:

    void baseOp(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &BaseInterface11Prx::_iceI_baseOp, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto baseOpAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &BaseInterface11Prx::_iceI_baseOp, context);
    }

    ::std::function<void()>
    baseOpAsync(::std::function<void()> response,
                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                ::std::function<void(bool)> sent = nullptr,
                const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::BaseInterface11Prx::_iceI_baseOp, context);
    }

    /// \cond INTERNAL
    void _iceI_baseOp(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    void baseOp2(int i, ::std::string& s, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        s = _makePromiseOutgoing<::std::string>(true, this, &BaseInterface11Prx::_iceI_baseOp2, i, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto baseOp2Async(int i, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::string>>().get_future())
    {
        return _makePromiseOutgoing<::std::string, P>(false, this, &BaseInterface11Prx::_iceI_baseOp2, i, context);
    }

    ::std::function<void()>
    baseOp2Async(int i,
                 ::std::function<void(::std::string)> response,
                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                 ::std::function<void(bool)> sent = nullptr,
                 const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::std::string>(std::move(response), std::move(ex), std::move(sent), this, &Test::BaseInterface11Prx::_iceI_baseOp2, i, context);
    }

    /// \cond INTERNAL
    void _iceI_baseOp2(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::string>>&, int, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    BaseInterface11Prx() = default;
    friend ::std::shared_ptr<BaseInterface11Prx> IceInternal::createProxy<BaseInterface11Prx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

class OptionalParameters0Prx : public virtual ::Ice::Proxy<OptionalParameters0Prx, ::Ice::ObjectPrx>
{
public:

    void op1(const ::std::string& firstName, const Ice::optional<::std::string>& secondName, const Ice::optional<::std::string>& emailAddress, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &OptionalParameters0Prx::_iceI_op1, firstName, secondName, emailAddress, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto op1Async(const ::std::string& firstName, const Ice::optional<::std::string>& secondName, const Ice::optional<::std::string>& emailAddress, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &OptionalParameters0Prx::_iceI_op1, firstName, secondName, emailAddress, context);
    }

    ::std::function<void()>
    op1Async(const ::std::string& firstName, const Ice::optional<::std::string>& secondName, const Ice::optional<::std::string>& emailAddress,
             ::std::function<void()> response,
             ::std::function<void(::std::exception_ptr)> ex = nullptr,
             ::std::function<void(bool)> sent = nullptr,
             const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::OptionalParameters0Prx::_iceI_op1, firstName, secondName, emailAddress, context);
    }

    /// \cond INTERNAL
    void _iceI_op1(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, const Ice::optional<::std::string>&, const Ice::optional<::std::string>&, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    OptionalParameters0Prx() = default;
    friend ::std::shared_ptr<OptionalParameters0Prx> IceInternal::createProxy<OptionalParameters0Prx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

class OptionalParameters1Prx : public virtual ::Ice::Proxy<OptionalParameters1Prx, ::Ice::ObjectPrx>
{
public:

    void op1(const ::std::string& firstName, const Ice::optional<::std::string>& secondName, const Ice::optional<::std::string>& emailAddress, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &OptionalParameters1Prx::_iceI_op1, firstName, secondName, emailAddress, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto op1Async(const ::std::string& firstName, const Ice::optional<::std::string>& secondName, const Ice::optional<::std::string>& emailAddress, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &OptionalParameters1Prx::_iceI_op1, firstName, secondName, emailAddress, context);
    }

    ::std::function<void()>
    op1Async(const ::std::string& firstName, const Ice::optional<::std::string>& secondName, const Ice::optional<::std::string>& emailAddress,
             ::std::function<void()> response,
             ::std::function<void(::std::exception_ptr)> ex = nullptr,
             ::std::function<void(bool)> sent = nullptr,
             const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::OptionalParameters1Prx::_iceI_op1, firstName, secondName, emailAddress, context);
    }

    /// \cond INTERNAL
    void _iceI_op1(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, const Ice::optional<::std::string>&, const Ice::optional<::std::string>&, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    OptionalParameters1Prx() = default;
    friend ::std::shared_ptr<OptionalParameters1Prx> IceInternal::createProxy<OptionalParameters1Prx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

class OptionalParameters2Prx : public virtual ::Ice::Proxy<OptionalParameters2Prx, ::Ice::ObjectPrx>
{
public:

    void op1(const ::std::string& firstName, const Ice::optional<::std::string>& emailAddress, const Ice::optional<::std::string>& secondName, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &OptionalParameters2Prx::_iceI_op1, firstName, emailAddress, secondName, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto op1Async(const ::std::string& firstName, const Ice::optional<::std::string>& emailAddress, const Ice::optional<::std::string>& secondName, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &OptionalParameters2Prx::_iceI_op1, firstName, emailAddress, secondName, context);
    }

    ::std::function<void()>
    op1Async(const ::std::string& firstName, const Ice::optional<::std::string>& emailAddress, const Ice::optional<::std::string>& secondName,
             ::std::function<void()> response,
             ::std::function<void(::std::exception_ptr)> ex = nullptr,
             ::std::function<void(bool)> sent = nullptr,
             const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::OptionalParameters2Prx::_iceI_op1, firstName, emailAddress, secondName, context);
    }

    /// \cond INTERNAL
    void _iceI_op1(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, const Ice::optional<::std::string>&, const Ice::optional<::std::string>&, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    OptionalParameters2Prx() = default;
    friend ::std::shared_ptr<OptionalParameters2Prx> IceInternal::createProxy<OptionalParameters2Prx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

class OptionalParameters3Prx : public virtual ::Ice::Proxy<OptionalParameters3Prx, ::Ice::ObjectPrx>
{
public:

    void op1(const ::std::string& firstName, const Ice::optional<::std::string>& emailAddress, const ::std::string& secondName, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &OptionalParameters3Prx::_iceI_op1, firstName, emailAddress, secondName, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto op1Async(const ::std::string& firstName, const Ice::optional<::std::string>& emailAddress, const ::std::string& secondName, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &OptionalParameters3Prx::_iceI_op1, firstName, emailAddress, secondName, context);
    }

    ::std::function<void()>
    op1Async(const ::std::string& firstName, const Ice::optional<::std::string>& emailAddress, const ::std::string& secondName,
             ::std::function<void()> response,
             ::std::function<void(::std::exception_ptr)> ex = nullptr,
             ::std::function<void(bool)> sent = nullptr,
             const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::OptionalParameters3Prx::_iceI_op1, firstName, emailAddress, secondName, context);
    }

    /// \cond INTERNAL
    void _iceI_op1(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, const Ice::optional<::std::string>&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    OptionalParameters3Prx() = default;
    friend ::std::shared_ptr<OptionalParameters3Prx> IceInternal::createProxy<OptionalParameters3Prx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

class OptionalReturn0Prx : public virtual ::Ice::Proxy<OptionalReturn0Prx, ::Ice::ObjectPrx>
{
public:

    Ice::optional<int> op(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<Ice::optional<int>>(true, this, &OptionalReturn0Prx::_iceI_op, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto opAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Ice::optional<int>>>().get_future())
    {
        return _makePromiseOutgoing<Ice::optional<int>, P>(false, this, &OptionalReturn0Prx::_iceI_op, context);
    }

    ::std::function<void()>
    opAsync(::std::function<void(Ice::optional<int>)> response,
            ::std::function<void(::std::exception_ptr)> ex = nullptr,
            ::std::function<void(bool)> sent = nullptr,
            const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<Ice::optional<int>>(std::move(response), std::move(ex), std::move(sent), this, &Test::OptionalReturn0Prx::_iceI_op, context);
    }

    /// \cond INTERNAL
    void _iceI_op(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Ice::optional<int>>>&, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    OptionalReturn0Prx() = default;
    friend ::std::shared_ptr<OptionalReturn0Prx> IceInternal::createProxy<OptionalReturn0Prx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

class OptionalReturn2Prx : public virtual ::Ice::Proxy<OptionalReturn2Prx, ::Ice::ObjectPrx>
{
public:

    Ice::optional<int> op(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<Ice::optional<int>>(true, this, &OptionalReturn2Prx::_iceI_op, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto opAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Ice::optional<int>>>().get_future())
    {
        return _makePromiseOutgoing<Ice::optional<int>, P>(false, this, &OptionalReturn2Prx::_iceI_op, context);
    }

    ::std::function<void()>
    opAsync(::std::function<void(Ice::optional<int>)> response,
            ::std::function<void(::std::exception_ptr)> ex = nullptr,
            ::std::function<void(bool)> sent = nullptr,
            const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<Ice::optional<int>>(std::move(response), std::move(ex), std::move(sent), this, &Test::OptionalReturn2Prx::_iceI_op, context);
    }

    /// \cond INTERNAL
    void _iceI_op(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Ice::optional<int>>>&, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    OptionalReturn2Prx() = default;
    friend ::std::shared_ptr<OptionalReturn2Prx> IceInternal::createProxy<OptionalReturn2Prx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

}

/// \cond STREAM
namespace Ice
{

template<>
struct StreamableTraits< ::Test::Enum1>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 2;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits< ::Test::Enum2>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 2;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits< ::Test::Enum3>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 2;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits< ::Test::Enum4>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 2;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits< ::Test::EnumExplicit0>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 1;
    static const int maxValue = 3;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits< ::Test::EnumExplicit1>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 1;
    static const int maxValue = 3;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits< ::Test::EnumExplicit2>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 1;
    static const int maxValue = 3;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits< ::Test::EnumExplicit3>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 1;
    static const int maxValue = 3;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits<::Test::Struct1>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 2;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::Test::Struct1, S>
{
    static void read(S* istr, ::Test::Struct1& v)
    {
        istr->readAll(v.str, v.b);
    }
};

template<>
struct StreamableTraits<::Test::Struct2>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 2;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::Test::Struct2, S>
{
    static void read(S* istr, ::Test::Struct2& v)
    {
        istr->readAll(v.str, v.b);
    }
};

template<>
struct StreamableTraits<::Test::Struct3>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 2;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::Test::Struct3, S>
{
    static void read(S* istr, ::Test::Struct3& v)
    {
        istr->readAll(v.str, v.b);
    }
};

template<>
struct StreamableTraits<::Test::Struct4>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 2;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::Test::Struct4, S>
{
    static void read(S* istr, ::Test::Struct4& v)
    {
        istr->readAll(v.str, v.b);
    }
};

template<>
struct StreamableTraits<::Test::Struct5>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 2;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::Test::Struct5, S>
{
    static void read(S* istr, ::Test::Struct5& v)
    {
        istr->readAll(v.str, v.b);
    }
};

template<typename S>
struct StreamReader<::Test::SimpleClass1, S>
{
    static void read(S* istr, ::Test::SimpleClass1& v)
    {
        istr->readAll(v.str, v.f);
    }
};

template<typename S>
struct StreamReader<::Test::SimpleClass2, S>
{
    static void read(S* istr, ::Test::SimpleClass2& v)
    {
        istr->readAll(v.str, v.f);
    }
};

template<typename S>
struct StreamReader<::Test::SimpleClass3, S>
{
    static void read(S* istr, ::Test::SimpleClass3& v)
    {
        istr->readAll(v.str, v.f);
    }
};

template<typename S>
struct StreamReader<::Test::SimpleClass4, S>
{
    static void read(S* istr, ::Test::SimpleClass4& v)
    {
        istr->readAll(v.str, v.f);
    }
};

template<typename S>
struct StreamReader<::Test::SimpleClass5, S>
{
    static void read(S* istr, ::Test::SimpleClass5& v)
    {
        istr->readAll(v.str, v.f);
    }
};

template<typename S>
struct StreamReader<::Test::SimpleClass6, S>
{
    static void read(S* istr, ::Test::SimpleClass6& v)
    {
        istr->readAll(v.str, v.f);
    }
};

template<typename S>
struct StreamReader<::Test::SimpleClass7, S>
{
    static void read(S* istr, ::Test::SimpleClass7& v)
    {
        istr->readAll(v.str, v.f);
    }
};

template<typename S>
struct StreamReader<::Test::Exception1, S>
{
    static void read(S* istr, ::Test::Exception1& v)
    {
        istr->readAll(v.str, v.b);
    }
};

template<typename S>
struct StreamReader<::Test::Exception2, S>
{
    static void read(S* istr, ::Test::Exception2& v)
    {
        istr->readAll(v.str, v.b);
    }
};

template<typename S>
struct StreamReader<::Test::Exception3, S>
{
    static void read(S* istr, ::Test::Exception3& v)
    {
        istr->readAll(v.str, v.b);
    }
};

template<typename S>
struct StreamReader<::Test::Exception4, S>
{
    static void read(S* istr, ::Test::Exception4& v)
    {
        istr->readAll(v.str, v.b);
    }
};

template<typename S>
struct StreamReader<::Test::Exception6, S>
{
    static void read(S* istr, ::Test::Exception6& v)
    {
        istr->readAll(v.str, v.b);
    }
};

template<typename S>
struct StreamWriter<::Test::OptionalEx0, S>
{
    static void write(S* ostr, const ::Test::OptionalEx0& v)
    {
        ostr->writeAll(v.firstName);
        ostr->writeAll({1, 2}, v.secondName, v.emailAddress);
    }
};

template<typename S>
struct StreamReader<::Test::OptionalEx0, S>
{
    static void read(S* istr, ::Test::OptionalEx0& v)
    {
        istr->readAll(v.firstName);
        istr->readAll({1, 2}, v.secondName, v.emailAddress);
    }
};

template<typename S>
struct StreamWriter<::Test::OptionalEx1, S>
{
    static void write(S* ostr, const ::Test::OptionalEx1& v)
    {
        ostr->writeAll(v.firstName);
        ostr->writeAll({1, 2}, v.secondName, v.emailAddress);
    }
};

template<typename S>
struct StreamReader<::Test::OptionalEx1, S>
{
    static void read(S* istr, ::Test::OptionalEx1& v)
    {
        istr->readAll(v.firstName);
        istr->readAll({1, 2}, v.secondName, v.emailAddress);
    }
};

template<typename S>
struct StreamWriter<::Test::OptionalEx2, S>
{
    static void write(S* ostr, const ::Test::OptionalEx2& v)
    {
        ostr->writeAll(v.firstName, v.secondName);
        ostr->writeAll({1}, v.emailAddress);
    }
};

template<typename S>
struct StreamReader<::Test::OptionalEx2, S>
{
    static void read(S* istr, ::Test::OptionalEx2& v)
    {
        istr->readAll(v.firstName, v.secondName);
        istr->readAll({1}, v.emailAddress);
    }
};

template<typename S>
struct StreamWriter<::Test::OptionalEx3, S>
{
    static void write(S* ostr, const ::Test::OptionalEx3& v)
    {
        ostr->writeAll(v.firstName);
        ostr->writeAll({1, 2}, v.secondName, v.emailAddress);
    }
};

template<typename S>
struct StreamReader<::Test::OptionalEx3, S>
{
    static void read(S* istr, ::Test::OptionalEx3& v)
    {
        istr->readAll(v.firstName);
        istr->readAll({1, 2}, v.secondName, v.emailAddress);
    }
};

template<typename S>
struct StreamWriter<::Test::OptionalEx4, S>
{
    static void write(S* ostr, const ::Test::OptionalEx4& v)
    {
        ostr->writeAll(v.firstName);
        ostr->writeAll({1, 2}, v.secondName, v.emailAddress);
    }
};

template<typename S>
struct StreamReader<::Test::OptionalEx4, S>
{
    static void read(S* istr, ::Test::OptionalEx4& v)
    {
        istr->readAll(v.firstName);
        istr->readAll({1, 2}, v.secondName, v.emailAddress);
    }
};

template<typename S>
struct StreamReader<::Test::Compact1, S>
{
    static void read(S* istr, ::Test::Compact1& v)
    {
        istr->readAll(v.id);
    }
};

template<typename S>
struct StreamWriter<::Test::Derived1, S>
{
    static void write(S*, const ::Test::Derived1&)
    {
    }
};

template<typename S>
struct StreamReader<::Test::Derived1, S>
{
    static void read(S*, ::Test::Derived1&)
    {
    }
};

template<typename S>
struct StreamReader<::Test::Compact2, S>
{
    static void read(S* istr, ::Test::Compact2& v)
    {
        istr->readAll(v.id);
    }
};

template<typename S>
struct StreamWriter<::Test::Optional0, S>
{
    static void write(S* ostr, const ::Test::Optional0& v)
    {
        ostr->writeAll(v.firstName);
        ostr->writeAll({1, 2}, v.secondName, v.emailAddress);
    }
};

template<typename S>
struct StreamReader<::Test::Optional0, S>
{
    static void read(S* istr, ::Test::Optional0& v)
    {
        istr->readAll(v.firstName);
        istr->readAll({1, 2}, v.secondName, v.emailAddress);
    }
};

template<typename S>
struct StreamWriter<::Test::Optional1, S>
{
    static void write(S* ostr, const ::Test::Optional1& v)
    {
        ostr->writeAll(v.firstName);
        ostr->writeAll({1, 2}, v.secondName, v.emailAddress);
    }
};

template<typename S>
struct StreamReader<::Test::Optional1, S>
{
    static void read(S* istr, ::Test::Optional1& v)
    {
        istr->readAll(v.firstName);
        istr->readAll({1, 2}, v.secondName, v.emailAddress);
    }
};

template<typename S>
struct StreamWriter<::Test::Optional2, S>
{
    static void write(S* ostr, const ::Test::Optional2& v)
    {
        ostr->writeAll(v.firstName, v.secondName);
        ostr->writeAll({1}, v.emailAddress);
    }
};

template<typename S>
struct StreamReader<::Test::Optional2, S>
{
    static void read(S* istr, ::Test::Optional2& v)
    {
        istr->readAll(v.firstName, v.secondName);
        istr->readAll({1}, v.emailAddress);
    }
};

template<typename S>
struct StreamWriter<::Test::Optional3, S>
{
    static void write(S* ostr, const ::Test::Optional3& v)
    {
        ostr->writeAll(v.firstName);
        ostr->writeAll({1, 2}, v.secondName, v.emailAddress);
    }
};

template<typename S>
struct StreamReader<::Test::Optional3, S>
{
    static void read(S* istr, ::Test::Optional3& v)
    {
        istr->readAll(v.firstName);
        istr->readAll({1, 2}, v.secondName, v.emailAddress);
    }
};

template<typename S>
struct StreamWriter<::Test::Optional4, S>
{
    static void write(S* ostr, const ::Test::Optional4& v)
    {
        ostr->writeAll(v.firstName);
        ostr->writeAll({1, 2}, v.secondName, v.emailAddress);
    }
};

template<typename S>
struct StreamReader<::Test::Optional4, S>
{
    static void read(S* istr, ::Test::Optional4& v)
    {
        istr->readAll(v.firstName);
        istr->readAll({1, 2}, v.secondName, v.emailAddress);
    }
};

}
/// \endcond

/// \cond INTERNAL
namespace Test
{

using Interface1Ptr = ::std::shared_ptr<Interface1>;
using Interface1PrxPtr = ::std::shared_ptr<Interface1Prx>;

using Interface2Ptr = ::std::shared_ptr<Interface2>;
using Interface2PrxPtr = ::std::shared_ptr<Interface2Prx>;

using Interface3Ptr = ::std::shared_ptr<Interface3>;
using Interface3PrxPtr = ::std::shared_ptr<Interface3Prx>;

using Interface4Ptr = ::std::shared_ptr<Interface4>;
using Interface4PrxPtr = ::std::shared_ptr<Interface4Prx>;

using EmptyClass1Ptr = ::std::shared_ptr<EmptyClass1>;

using EmptyClass2Ptr = ::std::shared_ptr<EmptyClass2>;

using EmptyClass3Ptr = ::std::shared_ptr<EmptyClass3>;

using EmptyClass4Ptr = ::std::shared_ptr<EmptyClass4>;

using EmptyClass5Ptr = ::std::shared_ptr<EmptyClass5>;

using SimpleClass1Ptr = ::std::shared_ptr<SimpleClass1>;

using SimpleClass2Ptr = ::std::shared_ptr<SimpleClass2>;

using SimpleClass3Ptr = ::std::shared_ptr<SimpleClass3>;

using SimpleClass4Ptr = ::std::shared_ptr<SimpleClass4>;

using SimpleClass5Ptr = ::std::shared_ptr<SimpleClass5>;

using SimpleClass6Ptr = ::std::shared_ptr<SimpleClass6>;

using SimpleClass7Ptr = ::std::shared_ptr<SimpleClass7>;

using BaseInterface1Ptr = ::std::shared_ptr<BaseInterface1>;
using BaseInterface1PrxPtr = ::std::shared_ptr<BaseInterface1Prx>;

using BaseInterface2Ptr = ::std::shared_ptr<BaseInterface2>;
using BaseInterface2PrxPtr = ::std::shared_ptr<BaseInterface2Prx>;

using BaseInterface3Ptr = ::std::shared_ptr<BaseInterface3>;
using BaseInterface3PrxPtr = ::std::shared_ptr<BaseInterface3Prx>;

using BaseInterface4Ptr = ::std::shared_ptr<BaseInterface4>;
using BaseInterface4PrxPtr = ::std::shared_ptr<BaseInterface4Prx>;

using BaseInterface5Ptr = ::std::shared_ptr<BaseInterface5>;
using BaseInterface5PrxPtr = ::std::shared_ptr<BaseInterface5Prx>;

using BaseInterface6Ptr = ::std::shared_ptr<BaseInterface6>;
using BaseInterface6PrxPtr = ::std::shared_ptr<BaseInterface6Prx>;

using BaseInterface7Ptr = ::std::shared_ptr<BaseInterface7>;
using BaseInterface7PrxPtr = ::std::shared_ptr<BaseInterface7Prx>;

using BaseInterface8Ptr = ::std::shared_ptr<BaseInterface8>;
using BaseInterface8PrxPtr = ::std::shared_ptr<BaseInterface8Prx>;

using BaseInterface9Ptr = ::std::shared_ptr<BaseInterface9>;
using BaseInterface9PrxPtr = ::std::shared_ptr<BaseInterface9Prx>;

using BaseInterface10Ptr = ::std::shared_ptr<BaseInterface10>;
using BaseInterface10PrxPtr = ::std::shared_ptr<BaseInterface10Prx>;

using BaseInterface11Ptr = ::std::shared_ptr<BaseInterface11>;
using BaseInterface11PrxPtr = ::std::shared_ptr<BaseInterface11Prx>;

using Compact1Ptr = ::std::shared_ptr<Compact1>;

using Derived1Ptr = ::std::shared_ptr<Derived1>;

using Compact2Ptr = ::std::shared_ptr<Compact2>;

using Optional0Ptr = ::std::shared_ptr<Optional0>;

using Optional1Ptr = ::std::shared_ptr<Optional1>;

using Optional2Ptr = ::std::shared_ptr<Optional2>;

using Optional3Ptr = ::std::shared_ptr<Optional3>;

using Optional4Ptr = ::std::shared_ptr<Optional4>;

using OptionalParameters0Ptr = ::std::shared_ptr<OptionalParameters0>;
using OptionalParameters0PrxPtr = ::std::shared_ptr<OptionalParameters0Prx>;

using OptionalParameters1Ptr = ::std::shared_ptr<OptionalParameters1>;
using OptionalParameters1PrxPtr = ::std::shared_ptr<OptionalParameters1Prx>;

using OptionalParameters2Ptr = ::std::shared_ptr<OptionalParameters2>;
using OptionalParameters2PrxPtr = ::std::shared_ptr<OptionalParameters2Prx>;

using OptionalParameters3Ptr = ::std::shared_ptr<OptionalParameters3>;
using OptionalParameters3PrxPtr = ::std::shared_ptr<OptionalParameters3Prx>;

using OptionalReturn0Ptr = ::std::shared_ptr<OptionalReturn0>;
using OptionalReturn0PrxPtr = ::std::shared_ptr<OptionalReturn0Prx>;

using OptionalReturn2Ptr = ::std::shared_ptr<OptionalReturn2>;
using OptionalReturn2PrxPtr = ::std::shared_ptr<OptionalReturn2Prx>;

using LocalClassPtr = ::std::shared_ptr<LocalClass>;

}
/// \endcond

#else // C++98 mapping

namespace IceProxy
{

namespace Test
{

class Interface1;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< Interface1>&);
::IceProxy::Ice::Object* upCast(Interface1*);
/// \endcond

class Interface2;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< Interface2>&);
::IceProxy::Ice::Object* upCast(Interface2*);
/// \endcond

class Interface3;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< Interface3>&);
::IceProxy::Ice::Object* upCast(Interface3*);
/// \endcond

class Interface4;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< Interface4>&);
::IceProxy::Ice::Object* upCast(Interface4*);
/// \endcond

class EmptyClass1;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< EmptyClass1>&);
::IceProxy::Ice::Object* upCast(EmptyClass1*);
/// \endcond

class EmptyClass2;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< EmptyClass2>&);
::IceProxy::Ice::Object* upCast(EmptyClass2*);
/// \endcond

class EmptyClass3;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< EmptyClass3>&);
::IceProxy::Ice::Object* upCast(EmptyClass3*);
/// \endcond

class EmptyClass4;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< EmptyClass4>&);
::IceProxy::Ice::Object* upCast(EmptyClass4*);
/// \endcond

class EmptyClass5;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< EmptyClass5>&);
::IceProxy::Ice::Object* upCast(EmptyClass5*);
/// \endcond

class SimpleClass1;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< SimpleClass1>&);
::IceProxy::Ice::Object* upCast(SimpleClass1*);
/// \endcond

class SimpleClass2;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< SimpleClass2>&);
::IceProxy::Ice::Object* upCast(SimpleClass2*);
/// \endcond

class SimpleClass3;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< SimpleClass3>&);
::IceProxy::Ice::Object* upCast(SimpleClass3*);
/// \endcond

class SimpleClass4;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< SimpleClass4>&);
::IceProxy::Ice::Object* upCast(SimpleClass4*);
/// \endcond

class SimpleClass5;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< SimpleClass5>&);
::IceProxy::Ice::Object* upCast(SimpleClass5*);
/// \endcond

class SimpleClass6;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< SimpleClass6>&);
::IceProxy::Ice::Object* upCast(SimpleClass6*);
/// \endcond

class SimpleClass7;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< SimpleClass7>&);
::IceProxy::Ice::Object* upCast(SimpleClass7*);
/// \endcond

class BaseInterface1;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< BaseInterface1>&);
::IceProxy::Ice::Object* upCast(BaseInterface1*);
/// \endcond

class BaseInterface2;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< BaseInterface2>&);
::IceProxy::Ice::Object* upCast(BaseInterface2*);
/// \endcond

class BaseInterface3;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< BaseInterface3>&);
::IceProxy::Ice::Object* upCast(BaseInterface3*);
/// \endcond

class BaseInterface4;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< BaseInterface4>&);
::IceProxy::Ice::Object* upCast(BaseInterface4*);
/// \endcond

class BaseInterface5;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< BaseInterface5>&);
::IceProxy::Ice::Object* upCast(BaseInterface5*);
/// \endcond

class BaseInterface6;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< BaseInterface6>&);
::IceProxy::Ice::Object* upCast(BaseInterface6*);
/// \endcond

class BaseInterface7;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< BaseInterface7>&);
::IceProxy::Ice::Object* upCast(BaseInterface7*);
/// \endcond

class BaseInterface8;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< BaseInterface8>&);
::IceProxy::Ice::Object* upCast(BaseInterface8*);
/// \endcond

class BaseInterface9;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< BaseInterface9>&);
::IceProxy::Ice::Object* upCast(BaseInterface9*);
/// \endcond

class BaseInterface10;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< BaseInterface10>&);
::IceProxy::Ice::Object* upCast(BaseInterface10*);
/// \endcond

class BaseInterface11;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< BaseInterface11>&);
::IceProxy::Ice::Object* upCast(BaseInterface11*);
/// \endcond

class Compact1;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< Compact1>&);
::IceProxy::Ice::Object* upCast(Compact1*);
/// \endcond

class Derived1;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< Derived1>&);
::IceProxy::Ice::Object* upCast(Derived1*);
/// \endcond

class Compact2;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< Compact2>&);
::IceProxy::Ice::Object* upCast(Compact2*);
/// \endcond

class Optional0;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< Optional0>&);
::IceProxy::Ice::Object* upCast(Optional0*);
/// \endcond

class Optional1;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< Optional1>&);
::IceProxy::Ice::Object* upCast(Optional1*);
/// \endcond

class Optional2;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< Optional2>&);
::IceProxy::Ice::Object* upCast(Optional2*);
/// \endcond

class Optional3;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< Optional3>&);
::IceProxy::Ice::Object* upCast(Optional3*);
/// \endcond

class Optional4;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< Optional4>&);
::IceProxy::Ice::Object* upCast(Optional4*);
/// \endcond

class OptionalParameters0;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< OptionalParameters0>&);
::IceProxy::Ice::Object* upCast(OptionalParameters0*);
/// \endcond

class OptionalParameters1;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< OptionalParameters1>&);
::IceProxy::Ice::Object* upCast(OptionalParameters1*);
/// \endcond

class OptionalParameters2;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< OptionalParameters2>&);
::IceProxy::Ice::Object* upCast(OptionalParameters2*);
/// \endcond

class OptionalParameters3;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< OptionalParameters3>&);
::IceProxy::Ice::Object* upCast(OptionalParameters3*);
/// \endcond

class OptionalReturn0;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< OptionalReturn0>&);
::IceProxy::Ice::Object* upCast(OptionalReturn0*);
/// \endcond

class OptionalReturn2;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< OptionalReturn2>&);
::IceProxy::Ice::Object* upCast(OptionalReturn2*);
/// \endcond

}

}

namespace Test
{

class Interface1;
/// \cond INTERNAL
::Ice::Object* upCast(Interface1*);
/// \endcond
typedef ::IceInternal::Handle< Interface1> Interface1Ptr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::Interface1> Interface1Prx;
typedef Interface1Prx Interface1PrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(Interface1Ptr&, const ::Ice::ObjectPtr&);
/// \endcond

class Interface2;
/// \cond INTERNAL
::Ice::Object* upCast(Interface2*);
/// \endcond
typedef ::IceInternal::Handle< Interface2> Interface2Ptr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::Interface2> Interface2Prx;
typedef Interface2Prx Interface2PrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(Interface2Ptr&, const ::Ice::ObjectPtr&);
/// \endcond

class Interface3;
/// \cond INTERNAL
::Ice::Object* upCast(Interface3*);
/// \endcond
typedef ::IceInternal::Handle< Interface3> Interface3Ptr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::Interface3> Interface3Prx;
typedef Interface3Prx Interface3PrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(Interface3Ptr&, const ::Ice::ObjectPtr&);
/// \endcond

class Interface4;
/// \cond INTERNAL
::Ice::Object* upCast(Interface4*);
/// \endcond
typedef ::IceInternal::Handle< Interface4> Interface4Ptr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::Interface4> Interface4Prx;
typedef Interface4Prx Interface4PrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(Interface4Ptr&, const ::Ice::ObjectPtr&);
/// \endcond

class EmptyClass1;
/// \cond INTERNAL
::Ice::Object* upCast(EmptyClass1*);
/// \endcond
typedef ::IceInternal::Handle< EmptyClass1> EmptyClass1Ptr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::EmptyClass1> EmptyClass1Prx;
typedef EmptyClass1Prx EmptyClass1PrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(EmptyClass1Ptr&, const ::Ice::ObjectPtr&);
/// \endcond

class EmptyClass2;
/// \cond INTERNAL
::Ice::Object* upCast(EmptyClass2*);
/// \endcond
typedef ::IceInternal::Handle< EmptyClass2> EmptyClass2Ptr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::EmptyClass2> EmptyClass2Prx;
typedef EmptyClass2Prx EmptyClass2PrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(EmptyClass2Ptr&, const ::Ice::ObjectPtr&);
/// \endcond

class EmptyClass3;
/// \cond INTERNAL
::Ice::Object* upCast(EmptyClass3*);
/// \endcond
typedef ::IceInternal::Handle< EmptyClass3> EmptyClass3Ptr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::EmptyClass3> EmptyClass3Prx;
typedef EmptyClass3Prx EmptyClass3PrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(EmptyClass3Ptr&, const ::Ice::ObjectPtr&);
/// \endcond

class EmptyClass4;
/// \cond INTERNAL
::Ice::Object* upCast(EmptyClass4*);
/// \endcond
typedef ::IceInternal::Handle< EmptyClass4> EmptyClass4Ptr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::EmptyClass4> EmptyClass4Prx;
typedef EmptyClass4Prx EmptyClass4PrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(EmptyClass4Ptr&, const ::Ice::ObjectPtr&);
/// \endcond

class EmptyClass5;
/// \cond INTERNAL
::Ice::Object* upCast(EmptyClass5*);
/// \endcond
typedef ::IceInternal::Handle< EmptyClass5> EmptyClass5Ptr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::EmptyClass5> EmptyClass5Prx;
typedef EmptyClass5Prx EmptyClass5PrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(EmptyClass5Ptr&, const ::Ice::ObjectPtr&);
/// \endcond

class SimpleClass1;
/// \cond INTERNAL
::Ice::Object* upCast(SimpleClass1*);
/// \endcond
typedef ::IceInternal::Handle< SimpleClass1> SimpleClass1Ptr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::SimpleClass1> SimpleClass1Prx;
typedef SimpleClass1Prx SimpleClass1PrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(SimpleClass1Ptr&, const ::Ice::ObjectPtr&);
/// \endcond

class SimpleClass2;
/// \cond INTERNAL
::Ice::Object* upCast(SimpleClass2*);
/// \endcond
typedef ::IceInternal::Handle< SimpleClass2> SimpleClass2Ptr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::SimpleClass2> SimpleClass2Prx;
typedef SimpleClass2Prx SimpleClass2PrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(SimpleClass2Ptr&, const ::Ice::ObjectPtr&);
/// \endcond

class SimpleClass3;
/// \cond INTERNAL
::Ice::Object* upCast(SimpleClass3*);
/// \endcond
typedef ::IceInternal::Handle< SimpleClass3> SimpleClass3Ptr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::SimpleClass3> SimpleClass3Prx;
typedef SimpleClass3Prx SimpleClass3PrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(SimpleClass3Ptr&, const ::Ice::ObjectPtr&);
/// \endcond

class SimpleClass4;
/// \cond INTERNAL
::Ice::Object* upCast(SimpleClass4*);
/// \endcond
typedef ::IceInternal::Handle< SimpleClass4> SimpleClass4Ptr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::SimpleClass4> SimpleClass4Prx;
typedef SimpleClass4Prx SimpleClass4PrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(SimpleClass4Ptr&, const ::Ice::ObjectPtr&);
/// \endcond

class SimpleClass5;
/// \cond INTERNAL
::Ice::Object* upCast(SimpleClass5*);
/// \endcond
typedef ::IceInternal::Handle< SimpleClass5> SimpleClass5Ptr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::SimpleClass5> SimpleClass5Prx;
typedef SimpleClass5Prx SimpleClass5PrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(SimpleClass5Ptr&, const ::Ice::ObjectPtr&);
/// \endcond

class SimpleClass6;
/// \cond INTERNAL
::Ice::Object* upCast(SimpleClass6*);
/// \endcond
typedef ::IceInternal::Handle< SimpleClass6> SimpleClass6Ptr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::SimpleClass6> SimpleClass6Prx;
typedef SimpleClass6Prx SimpleClass6PrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(SimpleClass6Ptr&, const ::Ice::ObjectPtr&);
/// \endcond

class SimpleClass7;
/// \cond INTERNAL
::Ice::Object* upCast(SimpleClass7*);
/// \endcond
typedef ::IceInternal::Handle< SimpleClass7> SimpleClass7Ptr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::SimpleClass7> SimpleClass7Prx;
typedef SimpleClass7Prx SimpleClass7PrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(SimpleClass7Ptr&, const ::Ice::ObjectPtr&);
/// \endcond

class BaseInterface1;
/// \cond INTERNAL
::Ice::Object* upCast(BaseInterface1*);
/// \endcond
typedef ::IceInternal::Handle< BaseInterface1> BaseInterface1Ptr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::BaseInterface1> BaseInterface1Prx;
typedef BaseInterface1Prx BaseInterface1PrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(BaseInterface1Ptr&, const ::Ice::ObjectPtr&);
/// \endcond

class BaseInterface2;
/// \cond INTERNAL
::Ice::Object* upCast(BaseInterface2*);
/// \endcond
typedef ::IceInternal::Handle< BaseInterface2> BaseInterface2Ptr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::BaseInterface2> BaseInterface2Prx;
typedef BaseInterface2Prx BaseInterface2PrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(BaseInterface2Ptr&, const ::Ice::ObjectPtr&);
/// \endcond

class BaseInterface3;
/// \cond INTERNAL
::Ice::Object* upCast(BaseInterface3*);
/// \endcond
typedef ::IceInternal::Handle< BaseInterface3> BaseInterface3Ptr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::BaseInterface3> BaseInterface3Prx;
typedef BaseInterface3Prx BaseInterface3PrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(BaseInterface3Ptr&, const ::Ice::ObjectPtr&);
/// \endcond

class BaseInterface4;
/// \cond INTERNAL
::Ice::Object* upCast(BaseInterface4*);
/// \endcond
typedef ::IceInternal::Handle< BaseInterface4> BaseInterface4Ptr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::BaseInterface4> BaseInterface4Prx;
typedef BaseInterface4Prx BaseInterface4PrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(BaseInterface4Ptr&, const ::Ice::ObjectPtr&);
/// \endcond

class BaseInterface5;
/// \cond INTERNAL
::Ice::Object* upCast(BaseInterface5*);
/// \endcond
typedef ::IceInternal::Handle< BaseInterface5> BaseInterface5Ptr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::BaseInterface5> BaseInterface5Prx;
typedef BaseInterface5Prx BaseInterface5PrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(BaseInterface5Ptr&, const ::Ice::ObjectPtr&);
/// \endcond

class BaseInterface6;
/// \cond INTERNAL
::Ice::Object* upCast(BaseInterface6*);
/// \endcond
typedef ::IceInternal::Handle< BaseInterface6> BaseInterface6Ptr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::BaseInterface6> BaseInterface6Prx;
typedef BaseInterface6Prx BaseInterface6PrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(BaseInterface6Ptr&, const ::Ice::ObjectPtr&);
/// \endcond

class BaseInterface7;
/// \cond INTERNAL
::Ice::Object* upCast(BaseInterface7*);
/// \endcond
typedef ::IceInternal::Handle< BaseInterface7> BaseInterface7Ptr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::BaseInterface7> BaseInterface7Prx;
typedef BaseInterface7Prx BaseInterface7PrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(BaseInterface7Ptr&, const ::Ice::ObjectPtr&);
/// \endcond

class BaseInterface8;
/// \cond INTERNAL
::Ice::Object* upCast(BaseInterface8*);
/// \endcond
typedef ::IceInternal::Handle< BaseInterface8> BaseInterface8Ptr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::BaseInterface8> BaseInterface8Prx;
typedef BaseInterface8Prx BaseInterface8PrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(BaseInterface8Ptr&, const ::Ice::ObjectPtr&);
/// \endcond

class BaseInterface9;
/// \cond INTERNAL
::Ice::Object* upCast(BaseInterface9*);
/// \endcond
typedef ::IceInternal::Handle< BaseInterface9> BaseInterface9Ptr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::BaseInterface9> BaseInterface9Prx;
typedef BaseInterface9Prx BaseInterface9PrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(BaseInterface9Ptr&, const ::Ice::ObjectPtr&);
/// \endcond

class BaseInterface10;
/// \cond INTERNAL
::Ice::Object* upCast(BaseInterface10*);
/// \endcond
typedef ::IceInternal::Handle< BaseInterface10> BaseInterface10Ptr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::BaseInterface10> BaseInterface10Prx;
typedef BaseInterface10Prx BaseInterface10PrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(BaseInterface10Ptr&, const ::Ice::ObjectPtr&);
/// \endcond

class BaseInterface11;
/// \cond INTERNAL
::Ice::Object* upCast(BaseInterface11*);
/// \endcond
typedef ::IceInternal::Handle< BaseInterface11> BaseInterface11Ptr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::BaseInterface11> BaseInterface11Prx;
typedef BaseInterface11Prx BaseInterface11PrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(BaseInterface11Ptr&, const ::Ice::ObjectPtr&);
/// \endcond

class Compact1;
/// \cond INTERNAL
::Ice::Object* upCast(Compact1*);
/// \endcond
typedef ::IceInternal::Handle< Compact1> Compact1Ptr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::Compact1> Compact1Prx;
typedef Compact1Prx Compact1PrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(Compact1Ptr&, const ::Ice::ObjectPtr&);
/// \endcond

class Derived1;
/// \cond INTERNAL
::Ice::Object* upCast(Derived1*);
/// \endcond
typedef ::IceInternal::Handle< Derived1> Derived1Ptr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::Derived1> Derived1Prx;
typedef Derived1Prx Derived1PrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(Derived1Ptr&, const ::Ice::ObjectPtr&);
/// \endcond

class Compact2;
/// \cond INTERNAL
::Ice::Object* upCast(Compact2*);
/// \endcond
typedef ::IceInternal::Handle< Compact2> Compact2Ptr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::Compact2> Compact2Prx;
typedef Compact2Prx Compact2PrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(Compact2Ptr&, const ::Ice::ObjectPtr&);
/// \endcond

class Optional0;
/// \cond INTERNAL
::Ice::Object* upCast(Optional0*);
/// \endcond
typedef ::IceInternal::Handle< Optional0> Optional0Ptr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::Optional0> Optional0Prx;
typedef Optional0Prx Optional0PrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(Optional0Ptr&, const ::Ice::ObjectPtr&);
/// \endcond

class Optional1;
/// \cond INTERNAL
::Ice::Object* upCast(Optional1*);
/// \endcond
typedef ::IceInternal::Handle< Optional1> Optional1Ptr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::Optional1> Optional1Prx;
typedef Optional1Prx Optional1PrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(Optional1Ptr&, const ::Ice::ObjectPtr&);
/// \endcond

class Optional2;
/// \cond INTERNAL
::Ice::Object* upCast(Optional2*);
/// \endcond
typedef ::IceInternal::Handle< Optional2> Optional2Ptr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::Optional2> Optional2Prx;
typedef Optional2Prx Optional2PrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(Optional2Ptr&, const ::Ice::ObjectPtr&);
/// \endcond

class Optional3;
/// \cond INTERNAL
::Ice::Object* upCast(Optional3*);
/// \endcond
typedef ::IceInternal::Handle< Optional3> Optional3Ptr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::Optional3> Optional3Prx;
typedef Optional3Prx Optional3PrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(Optional3Ptr&, const ::Ice::ObjectPtr&);
/// \endcond

class Optional4;
/// \cond INTERNAL
::Ice::Object* upCast(Optional4*);
/// \endcond
typedef ::IceInternal::Handle< Optional4> Optional4Ptr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::Optional4> Optional4Prx;
typedef Optional4Prx Optional4PrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(Optional4Ptr&, const ::Ice::ObjectPtr&);
/// \endcond

class OptionalParameters0;
/// \cond INTERNAL
::Ice::Object* upCast(OptionalParameters0*);
/// \endcond
typedef ::IceInternal::Handle< OptionalParameters0> OptionalParameters0Ptr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::OptionalParameters0> OptionalParameters0Prx;
typedef OptionalParameters0Prx OptionalParameters0PrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(OptionalParameters0Ptr&, const ::Ice::ObjectPtr&);
/// \endcond

class OptionalParameters1;
/// \cond INTERNAL
::Ice::Object* upCast(OptionalParameters1*);
/// \endcond
typedef ::IceInternal::Handle< OptionalParameters1> OptionalParameters1Ptr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::OptionalParameters1> OptionalParameters1Prx;
typedef OptionalParameters1Prx OptionalParameters1PrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(OptionalParameters1Ptr&, const ::Ice::ObjectPtr&);
/// \endcond

class OptionalParameters2;
/// \cond INTERNAL
::Ice::Object* upCast(OptionalParameters2*);
/// \endcond
typedef ::IceInternal::Handle< OptionalParameters2> OptionalParameters2Ptr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::OptionalParameters2> OptionalParameters2Prx;
typedef OptionalParameters2Prx OptionalParameters2PrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(OptionalParameters2Ptr&, const ::Ice::ObjectPtr&);
/// \endcond

class OptionalParameters3;
/// \cond INTERNAL
::Ice::Object* upCast(OptionalParameters3*);
/// \endcond
typedef ::IceInternal::Handle< OptionalParameters3> OptionalParameters3Ptr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::OptionalParameters3> OptionalParameters3Prx;
typedef OptionalParameters3Prx OptionalParameters3PrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(OptionalParameters3Ptr&, const ::Ice::ObjectPtr&);
/// \endcond

class OptionalReturn0;
/// \cond INTERNAL
::Ice::Object* upCast(OptionalReturn0*);
/// \endcond
typedef ::IceInternal::Handle< OptionalReturn0> OptionalReturn0Ptr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::OptionalReturn0> OptionalReturn0Prx;
typedef OptionalReturn0Prx OptionalReturn0PrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(OptionalReturn0Ptr&, const ::Ice::ObjectPtr&);
/// \endcond

class OptionalReturn2;
/// \cond INTERNAL
::Ice::Object* upCast(OptionalReturn2*);
/// \endcond
typedef ::IceInternal::Handle< OptionalReturn2> OptionalReturn2Ptr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Test::OptionalReturn2> OptionalReturn2Prx;
typedef OptionalReturn2Prx OptionalReturn2PrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(OptionalReturn2Ptr&, const ::Ice::ObjectPtr&);
/// \endcond

class LocalClass;
/// \cond INTERNAL
::Ice::LocalObject* upCast(LocalClass*);
/// \endcond
typedef ::IceInternal::Handle< LocalClass> LocalClassPtr;

}

namespace Test
{

const ::Ice::Int IntConst1 = 100;

const ::Ice::Int IntConst2 = 100;

const ::Ice::Int IntConst3 = 100;

enum Enum1
{
    Enum11,
    Enum12,
    Enum13
};

enum Enum2
{
    Enum21,
    Enum22,
    Enum23
};

enum Enum3
{
    Enum31,
    Enum32,
    Enum33
};

enum Enum4
{
    Enum41,
    Enum42,
    Enum43
};

enum EnumExplicit0
{
    EnumExplicit01 = 1,
    EnumExplicit02 = 2,
    EnumExplicit03 = 3
};

enum EnumExplicit1
{
    EnumExplicit11 = 1,
    EnumExplicit12 = 2,
    EnumExplicit13 = 3
};

enum EnumExplicit2
{
    EnumExplicit21 = 1,
    EnumExplicit22 = 2,
    EnumExplicit23 = 3
};

enum EnumExplicit3
{
    EnumExplicit31 = 1,
    EnumExplicit32 = 2,
    EnumExplicit33 = 3
};

typedef ::std::vector< ::Ice::Int> Sequence1;

typedef ::std::vector< ::Ice::Int> Sequence2;

typedef ::std::vector< ::Ice::Int> Sequence3;

typedef ::std::map< ::std::string, ::Ice::Int> Dictionary1;

typedef ::std::map< ::std::string, ::Ice::Int> Dictionary2;

typedef ::std::map< ::std::string, ::Ice::Int> Dictionary3;

typedef ::std::map< ::std::string, ::Ice::Int> Dictionary4;

struct Struct1
{
    ::std::string str;
    bool b;

    bool operator==(const Struct1& rhs_) const
    {
        if(this == &rhs_)
        {
            return true;
        }
        if(str != rhs_.str)
        {
            return false;
        }
        if(b != rhs_.b)
        {
            return false;
        }
        return true;
    }

    bool operator<(const Struct1& rhs_) const
    {
        if(this == &rhs_)
        {
            return false;
        }
        if(str < rhs_.str)
        {
            return true;
        }
        else if(rhs_.str < str)
        {
            return false;
        }
        if(b < rhs_.b)
        {
            return true;
        }
        else if(rhs_.b < b)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const Struct1& rhs_) const
    {
        return !operator==(rhs_);
    }
    bool operator<=(const Struct1& rhs_) const
    {
        return operator<(rhs_) || operator==(rhs_);
    }
    bool operator>(const Struct1& rhs_) const
    {
        return !operator<(rhs_) && !operator==(rhs_);
    }
    bool operator>=(const Struct1& rhs_) const
    {
        return !operator<(rhs_);
    }
};

struct Struct2
{
    ::std::string str;
    bool b;

    bool operator==(const Struct2& rhs_) const
    {
        if(this == &rhs_)
        {
            return true;
        }
        if(str != rhs_.str)
        {
            return false;
        }
        if(b != rhs_.b)
        {
            return false;
        }
        return true;
    }

    bool operator<(const Struct2& rhs_) const
    {
        if(this == &rhs_)
        {
            return false;
        }
        if(str < rhs_.str)
        {
            return true;
        }
        else if(rhs_.str < str)
        {
            return false;
        }
        if(b < rhs_.b)
        {
            return true;
        }
        else if(rhs_.b < b)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const Struct2& rhs_) const
    {
        return !operator==(rhs_);
    }
    bool operator<=(const Struct2& rhs_) const
    {
        return operator<(rhs_) || operator==(rhs_);
    }
    bool operator>(const Struct2& rhs_) const
    {
        return !operator<(rhs_) && !operator==(rhs_);
    }
    bool operator>=(const Struct2& rhs_) const
    {
        return !operator<(rhs_);
    }
};

struct Struct3
{
    ::std::string str;
    bool b;

    bool operator==(const Struct3& rhs_) const
    {
        if(this == &rhs_)
        {
            return true;
        }
        if(str != rhs_.str)
        {
            return false;
        }
        if(b != rhs_.b)
        {
            return false;
        }
        return true;
    }

    bool operator<(const Struct3& rhs_) const
    {
        if(this == &rhs_)
        {
            return false;
        }
        if(str < rhs_.str)
        {
            return true;
        }
        else if(rhs_.str < str)
        {
            return false;
        }
        if(b < rhs_.b)
        {
            return true;
        }
        else if(rhs_.b < b)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const Struct3& rhs_) const
    {
        return !operator==(rhs_);
    }
    bool operator<=(const Struct3& rhs_) const
    {
        return operator<(rhs_) || operator==(rhs_);
    }
    bool operator>(const Struct3& rhs_) const
    {
        return !operator<(rhs_) && !operator==(rhs_);
    }
    bool operator>=(const Struct3& rhs_) const
    {
        return !operator<(rhs_);
    }
};

struct Struct4
{
    ::std::string str;
    bool b;

    bool operator==(const Struct4& rhs_) const
    {
        if(this == &rhs_)
        {
            return true;
        }
        if(str != rhs_.str)
        {
            return false;
        }
        if(b != rhs_.b)
        {
            return false;
        }
        return true;
    }

    bool operator<(const Struct4& rhs_) const
    {
        if(this == &rhs_)
        {
            return false;
        }
        if(str < rhs_.str)
        {
            return true;
        }
        else if(rhs_.str < str)
        {
            return false;
        }
        if(b < rhs_.b)
        {
            return true;
        }
        else if(rhs_.b < b)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const Struct4& rhs_) const
    {
        return !operator==(rhs_);
    }
    bool operator<=(const Struct4& rhs_) const
    {
        return operator<(rhs_) || operator==(rhs_);
    }
    bool operator>(const Struct4& rhs_) const
    {
        return !operator<(rhs_) && !operator==(rhs_);
    }
    bool operator>=(const Struct4& rhs_) const
    {
        return !operator<(rhs_);
    }
};

struct Struct5
{
    ::std::string str;
    bool b;

    bool operator==(const Struct5& rhs_) const
    {
        if(this == &rhs_)
        {
            return true;
        }
        if(str != rhs_.str)
        {
            return false;
        }
        if(b != rhs_.b)
        {
            return false;
        }
        return true;
    }

    bool operator<(const Struct5& rhs_) const
    {
        if(this == &rhs_)
        {
            return false;
        }
        if(str < rhs_.str)
        {
            return true;
        }
        else if(rhs_.str < str)
        {
            return false;
        }
        if(b < rhs_.b)
        {
            return true;
        }
        else if(rhs_.b < b)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const Struct5& rhs_) const
    {
        return !operator==(rhs_);
    }
    bool operator<=(const Struct5& rhs_) const
    {
        return operator<(rhs_) || operator==(rhs_);
    }
    bool operator>(const Struct5& rhs_) const
    {
        return !operator<(rhs_) && !operator==(rhs_);
    }
    bool operator>=(const Struct5& rhs_) const
    {
        return !operator<(rhs_);
    }
};

class Exception1 : public ::Ice::UserException
{
public:

    Exception1() {}
    /**
     * One-shot constructor to initialize all data members.
     */
    Exception1(const ::std::string& str, bool b);

#ifdef ICE_CPP11_COMPILER
    Exception1(const Exception1&) = default;
    virtual ~Exception1();
#else
    virtual ~Exception1() throw();
#endif

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    virtual ::std::string ice_id() const;
    /**
     * Polymorphically clones this exception.
     * @return A shallow copy of this exception.
     */
    virtual Exception1* ice_clone() const;
    /**
     * Throws this exception.
     */
    virtual void ice_throw() const;

    ::std::string str;
    bool b;

protected:

    /// \cond STREAM
    virtual void _writeImpl(::Ice::OutputStream*) const;
    virtual void _readImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
static Exception1 _iceS_Exception1_init;
/// \endcond

class Exception2 : public ::Ice::UserException
{
public:

    Exception2() {}
    /**
     * One-shot constructor to initialize all data members.
     */
    Exception2(const ::std::string& str, bool b);

#ifdef ICE_CPP11_COMPILER
    Exception2(const Exception2&) = default;
    virtual ~Exception2();
#else
    virtual ~Exception2() throw();
#endif

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    virtual ::std::string ice_id() const;
    /**
     * Polymorphically clones this exception.
     * @return A shallow copy of this exception.
     */
    virtual Exception2* ice_clone() const;
    /**
     * Throws this exception.
     */
    virtual void ice_throw() const;

    ::std::string str;
    bool b;

protected:

    /// \cond STREAM
    virtual void _writeImpl(::Ice::OutputStream*) const;
    virtual void _readImpl(::Ice::InputStream*);
    /// \endcond
};

class Exception3 : public ::Ice::UserException
{
public:

    Exception3() {}
    /**
     * One-shot constructor to initialize all data members.
     */
    Exception3(const ::std::string& str, bool b);

#ifdef ICE_CPP11_COMPILER
    Exception3(const Exception3&) = default;
    virtual ~Exception3();
#else
    virtual ~Exception3() throw();
#endif

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    virtual ::std::string ice_id() const;
    /**
     * Polymorphically clones this exception.
     * @return A shallow copy of this exception.
     */
    virtual Exception3* ice_clone() const;
    /**
     * Throws this exception.
     */
    virtual void ice_throw() const;

    ::std::string str;
    bool b;

protected:

    /// \cond STREAM
    virtual void _writeImpl(::Ice::OutputStream*) const;
    virtual void _readImpl(::Ice::InputStream*);
    /// \endcond
};

class Exception4 : public ::Ice::UserException
{
public:

    Exception4() {}
    /**
     * One-shot constructor to initialize all data members.
     */
    Exception4(const ::std::string& str, bool b);

#ifdef ICE_CPP11_COMPILER
    Exception4(const Exception4&) = default;
    virtual ~Exception4();
#else
    virtual ~Exception4() throw();
#endif

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    virtual ::std::string ice_id() const;
    /**
     * Polymorphically clones this exception.
     * @return A shallow copy of this exception.
     */
    virtual Exception4* ice_clone() const;
    /**
     * Throws this exception.
     */
    virtual void ice_throw() const;

    ::std::string str;
    bool b;

protected:

    /// \cond STREAM
    virtual void _writeImpl(::Ice::OutputStream*) const;
    virtual void _readImpl(::Ice::InputStream*);
    /// \endcond
};

class Exception5 : public ::Ice::UserException
{
public:

    Exception5() {}

#ifdef ICE_CPP11_COMPILER
    Exception5(const Exception5&) = default;
    virtual ~Exception5();
#else
    virtual ~Exception5() throw();
#endif

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    virtual ::std::string ice_id() const;
    /**
     * Polymorphically clones this exception.
     * @return A shallow copy of this exception.
     */
    virtual Exception5* ice_clone() const;
    /**
     * Throws this exception.
     */
    virtual void ice_throw() const;

protected:

    /// \cond STREAM
    virtual void _writeImpl(::Ice::OutputStream*) const;
    virtual void _readImpl(::Ice::InputStream*);
    /// \endcond
};

class Exception6 : public ::Ice::UserException
{
public:

    Exception6() {}
    /**
     * One-shot constructor to initialize all data members.
     */
    Exception6(const ::std::string& str, bool b);

#ifdef ICE_CPP11_COMPILER
    Exception6(const Exception6&) = default;
    virtual ~Exception6();
#else
    virtual ~Exception6() throw();
#endif

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    virtual ::std::string ice_id() const;
    /**
     * Polymorphically clones this exception.
     * @return A shallow copy of this exception.
     */
    virtual Exception6* ice_clone() const;
    /**
     * Throws this exception.
     */
    virtual void ice_throw() const;

    ::std::string str;
    bool b;

protected:

    /// \cond STREAM
    virtual void _writeImpl(::Ice::OutputStream*) const;
    virtual void _readImpl(::Ice::InputStream*);
    /// \endcond
};

class OptionalEx0 : public ::Ice::UserException
{
public:

    OptionalEx0() {}
    /**
     * One-shot constructor to initialize all data members.
     */
    OptionalEx0(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& secondName, const IceUtil::Optional< ::std::string>& emailAddress);

#ifdef ICE_CPP11_COMPILER
    OptionalEx0(const OptionalEx0&) = default;
    virtual ~OptionalEx0();
#else
    virtual ~OptionalEx0() throw();
#endif

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    virtual ::std::string ice_id() const;
    /**
     * Polymorphically clones this exception.
     * @return A shallow copy of this exception.
     */
    virtual OptionalEx0* ice_clone() const;
    /**
     * Throws this exception.
     */
    virtual void ice_throw() const;

    ::std::string firstName;
    IceUtil::Optional< ::std::string> secondName;
    IceUtil::Optional< ::std::string> emailAddress;

protected:

    /// \cond STREAM
    virtual void _writeImpl(::Ice::OutputStream*) const;
    virtual void _readImpl(::Ice::InputStream*);
    /// \endcond
};

class OptionalEx1 : public ::Ice::UserException
{
public:

    OptionalEx1() {}
    /**
     * One-shot constructor to initialize all data members.
     */
    OptionalEx1(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& secondName, const IceUtil::Optional< ::std::string>& emailAddress);

#ifdef ICE_CPP11_COMPILER
    OptionalEx1(const OptionalEx1&) = default;
    virtual ~OptionalEx1();
#else
    virtual ~OptionalEx1() throw();
#endif

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    virtual ::std::string ice_id() const;
    /**
     * Polymorphically clones this exception.
     * @return A shallow copy of this exception.
     */
    virtual OptionalEx1* ice_clone() const;
    /**
     * Throws this exception.
     */
    virtual void ice_throw() const;

    ::std::string firstName;
    IceUtil::Optional< ::std::string> secondName;
    IceUtil::Optional< ::std::string> emailAddress;

protected:

    /// \cond STREAM
    virtual void _writeImpl(::Ice::OutputStream*) const;
    virtual void _readImpl(::Ice::InputStream*);
    /// \endcond
};

class OptionalEx2 : public ::Ice::UserException
{
public:

    OptionalEx2() {}
    /**
     * One-shot constructor to initialize all data members.
     */
    OptionalEx2(const ::std::string& firstName, const ::std::string& secondName, const IceUtil::Optional< ::std::string>& emailAddress);

#ifdef ICE_CPP11_COMPILER
    OptionalEx2(const OptionalEx2&) = default;
    virtual ~OptionalEx2();
#else
    virtual ~OptionalEx2() throw();
#endif

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    virtual ::std::string ice_id() const;
    /**
     * Polymorphically clones this exception.
     * @return A shallow copy of this exception.
     */
    virtual OptionalEx2* ice_clone() const;
    /**
     * Throws this exception.
     */
    virtual void ice_throw() const;

    ::std::string firstName;
    ::std::string secondName;
    IceUtil::Optional< ::std::string> emailAddress;

protected:

    /// \cond STREAM
    virtual void _writeImpl(::Ice::OutputStream*) const;
    virtual void _readImpl(::Ice::InputStream*);
    /// \endcond
};

class OptionalEx3 : public ::Ice::UserException
{
public:

    OptionalEx3() {}
    /**
     * One-shot constructor to initialize all data members.
     */
    OptionalEx3(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& secondName, const IceUtil::Optional< ::std::string>& emailAddress);

#ifdef ICE_CPP11_COMPILER
    OptionalEx3(const OptionalEx3&) = default;
    virtual ~OptionalEx3();
#else
    virtual ~OptionalEx3() throw();
#endif

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    virtual ::std::string ice_id() const;
    /**
     * Polymorphically clones this exception.
     * @return A shallow copy of this exception.
     */
    virtual OptionalEx3* ice_clone() const;
    /**
     * Throws this exception.
     */
    virtual void ice_throw() const;

    ::std::string firstName;
    IceUtil::Optional< ::std::string> secondName;
    IceUtil::Optional< ::std::string> emailAddress;

protected:

    /// \cond STREAM
    virtual void _writeImpl(::Ice::OutputStream*) const;
    virtual void _readImpl(::Ice::InputStream*);
    /// \endcond
};

class OptionalEx4 : public ::Ice::UserException
{
public:

    OptionalEx4() {}
    /**
     * One-shot constructor to initialize all data members.
     */
    OptionalEx4(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& secondName, const IceUtil::Optional< ::std::string>& emailAddress);

#ifdef ICE_CPP11_COMPILER
    OptionalEx4(const OptionalEx4&) = default;
    virtual ~OptionalEx4();
#else
    virtual ~OptionalEx4() throw();
#endif

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    virtual ::std::string ice_id() const;
    /**
     * Polymorphically clones this exception.
     * @return A shallow copy of this exception.
     */
    virtual OptionalEx4* ice_clone() const;
    /**
     * Throws this exception.
     */
    virtual void ice_throw() const;

    ::std::string firstName;
    IceUtil::Optional< ::std::string> secondName;
    IceUtil::Optional< ::std::string> emailAddress;

protected:

    /// \cond STREAM
    virtual void _writeImpl(::Ice::OutputStream*) const;
    virtual void _readImpl(::Ice::InputStream*);
    /// \endcond
};

enum LocalEnum
{
    LocalEnum1,
    LocalEnum2,
    LocalEnum3
};

typedef ::std::vector< ::std::string> LocalSequence;

typedef ::std::map< ::std::string, ::std::string> LocalDictionary;

struct LocalStruct
{
    ::std::string str;

    bool operator==(const LocalStruct& rhs_) const
    {
        if(this == &rhs_)
        {
            return true;
        }
        if(str != rhs_.str)
        {
            return false;
        }
        return true;
    }

    bool operator<(const LocalStruct& rhs_) const
    {
        if(this == &rhs_)
        {
            return false;
        }
        if(str < rhs_.str)
        {
            return true;
        }
        else if(rhs_.str < str)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const LocalStruct& rhs_) const
    {
        return !operator==(rhs_);
    }
    bool operator<=(const LocalStruct& rhs_) const
    {
        return operator<(rhs_) || operator==(rhs_);
    }
    bool operator>(const LocalStruct& rhs_) const
    {
        return !operator<(rhs_) && !operator==(rhs_);
    }
    bool operator>=(const LocalStruct& rhs_) const
    {
        return !operator<(rhs_);
    }
};

}

namespace Test
{

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::BaseInterface1::begin_baseOp1.
 * Create a wrapper instance by calling ::Test::newCallback_BaseInterface1_baseOp1.
 */
class Callback_BaseInterface1_baseOp1_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_BaseInterface1_baseOp1_Base> Callback_BaseInterface1_baseOp1Ptr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::BaseInterface1::begin_baseOp2.
 * Create a wrapper instance by calling ::Test::newCallback_BaseInterface1_baseOp2.
 */
class Callback_BaseInterface1_baseOp2_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_BaseInterface1_baseOp2_Base> Callback_BaseInterface1_baseOp2Ptr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::BaseInterface2::begin_baseOp.
 * Create a wrapper instance by calling ::Test::newCallback_BaseInterface2_baseOp.
 */
class Callback_BaseInterface2_baseOp_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_BaseInterface2_baseOp_Base> Callback_BaseInterface2_baseOpPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::BaseInterface2::begin_baseOp2.
 * Create a wrapper instance by calling ::Test::newCallback_BaseInterface2_baseOp2.
 */
class Callback_BaseInterface2_baseOp2_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_BaseInterface2_baseOp2_Base> Callback_BaseInterface2_baseOp2Ptr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::BaseInterface3::begin_baseOp.
 * Create a wrapper instance by calling ::Test::newCallback_BaseInterface3_baseOp.
 */
class Callback_BaseInterface3_baseOp_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_BaseInterface3_baseOp_Base> Callback_BaseInterface3_baseOpPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::BaseInterface3::begin_baseOp2.
 * Create a wrapper instance by calling ::Test::newCallback_BaseInterface3_baseOp2.
 */
class Callback_BaseInterface3_baseOp2_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_BaseInterface3_baseOp2_Base> Callback_BaseInterface3_baseOp2Ptr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::BaseInterface4::begin_baseOp.
 * Create a wrapper instance by calling ::Test::newCallback_BaseInterface4_baseOp.
 */
class Callback_BaseInterface4_baseOp_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_BaseInterface4_baseOp_Base> Callback_BaseInterface4_baseOpPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::BaseInterface4::begin_baseOp2.
 * Create a wrapper instance by calling ::Test::newCallback_BaseInterface4_baseOp2.
 */
class Callback_BaseInterface4_baseOp2_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_BaseInterface4_baseOp2_Base> Callback_BaseInterface4_baseOp2Ptr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::BaseInterface5::begin_baseOp.
 * Create a wrapper instance by calling ::Test::newCallback_BaseInterface5_baseOp.
 */
class Callback_BaseInterface5_baseOp_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_BaseInterface5_baseOp_Base> Callback_BaseInterface5_baseOpPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::BaseInterface5::begin_baseOp2.
 * Create a wrapper instance by calling ::Test::newCallback_BaseInterface5_baseOp2.
 */
class Callback_BaseInterface5_baseOp2_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_BaseInterface5_baseOp2_Base> Callback_BaseInterface5_baseOp2Ptr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::BaseInterface6::begin_baseOp.
 * Create a wrapper instance by calling ::Test::newCallback_BaseInterface6_baseOp.
 */
class Callback_BaseInterface6_baseOp_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_BaseInterface6_baseOp_Base> Callback_BaseInterface6_baseOpPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::BaseInterface6::begin_baseOp2.
 * Create a wrapper instance by calling ::Test::newCallback_BaseInterface6_baseOp2.
 */
class Callback_BaseInterface6_baseOp2_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_BaseInterface6_baseOp2_Base> Callback_BaseInterface6_baseOp2Ptr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::BaseInterface7::begin_baseOp.
 * Create a wrapper instance by calling ::Test::newCallback_BaseInterface7_baseOp.
 */
class Callback_BaseInterface7_baseOp_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_BaseInterface7_baseOp_Base> Callback_BaseInterface7_baseOpPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::BaseInterface7::begin_baseOp2.
 * Create a wrapper instance by calling ::Test::newCallback_BaseInterface7_baseOp2.
 */
class Callback_BaseInterface7_baseOp2_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_BaseInterface7_baseOp2_Base> Callback_BaseInterface7_baseOp2Ptr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::BaseInterface8::begin_baseOp.
 * Create a wrapper instance by calling ::Test::newCallback_BaseInterface8_baseOp.
 */
class Callback_BaseInterface8_baseOp_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_BaseInterface8_baseOp_Base> Callback_BaseInterface8_baseOpPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::BaseInterface8::begin_baseOp2.
 * Create a wrapper instance by calling ::Test::newCallback_BaseInterface8_baseOp2.
 */
class Callback_BaseInterface8_baseOp2_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_BaseInterface8_baseOp2_Base> Callback_BaseInterface8_baseOp2Ptr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::BaseInterface9::begin_baseOp.
 * Create a wrapper instance by calling ::Test::newCallback_BaseInterface9_baseOp.
 */
class Callback_BaseInterface9_baseOp_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_BaseInterface9_baseOp_Base> Callback_BaseInterface9_baseOpPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::BaseInterface9::begin_baseOp2.
 * Create a wrapper instance by calling ::Test::newCallback_BaseInterface9_baseOp2.
 */
class Callback_BaseInterface9_baseOp2_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_BaseInterface9_baseOp2_Base> Callback_BaseInterface9_baseOp2Ptr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::BaseInterface10::begin_baseOp.
 * Create a wrapper instance by calling ::Test::newCallback_BaseInterface10_baseOp.
 */
class Callback_BaseInterface10_baseOp_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_BaseInterface10_baseOp_Base> Callback_BaseInterface10_baseOpPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::BaseInterface10::begin_baseOp2.
 * Create a wrapper instance by calling ::Test::newCallback_BaseInterface10_baseOp2.
 */
class Callback_BaseInterface10_baseOp2_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_BaseInterface10_baseOp2_Base> Callback_BaseInterface10_baseOp2Ptr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::BaseInterface11::begin_baseOp.
 * Create a wrapper instance by calling ::Test::newCallback_BaseInterface11_baseOp.
 */
class Callback_BaseInterface11_baseOp_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_BaseInterface11_baseOp_Base> Callback_BaseInterface11_baseOpPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::BaseInterface11::begin_baseOp2.
 * Create a wrapper instance by calling ::Test::newCallback_BaseInterface11_baseOp2.
 */
class Callback_BaseInterface11_baseOp2_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_BaseInterface11_baseOp2_Base> Callback_BaseInterface11_baseOp2Ptr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::OptionalParameters0::begin_op1.
 * Create a wrapper instance by calling ::Test::newCallback_OptionalParameters0_op1.
 */
class Callback_OptionalParameters0_op1_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_OptionalParameters0_op1_Base> Callback_OptionalParameters0_op1Ptr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::OptionalParameters1::begin_op1.
 * Create a wrapper instance by calling ::Test::newCallback_OptionalParameters1_op1.
 */
class Callback_OptionalParameters1_op1_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_OptionalParameters1_op1_Base> Callback_OptionalParameters1_op1Ptr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::OptionalParameters2::begin_op1.
 * Create a wrapper instance by calling ::Test::newCallback_OptionalParameters2_op1.
 */
class Callback_OptionalParameters2_op1_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_OptionalParameters2_op1_Base> Callback_OptionalParameters2_op1Ptr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::OptionalParameters3::begin_op1.
 * Create a wrapper instance by calling ::Test::newCallback_OptionalParameters3_op1.
 */
class Callback_OptionalParameters3_op1_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_OptionalParameters3_op1_Base> Callback_OptionalParameters3_op1Ptr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::OptionalReturn0::begin_op.
 * Create a wrapper instance by calling ::Test::newCallback_OptionalReturn0_op.
 */
class Callback_OptionalReturn0_op_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_OptionalReturn0_op_Base> Callback_OptionalReturn0_opPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Test::OptionalReturn2::begin_op.
 * Create a wrapper instance by calling ::Test::newCallback_OptionalReturn2_op.
 */
class Callback_OptionalReturn2_op_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_OptionalReturn2_op_Base> Callback_OptionalReturn2_opPtr;

}

namespace IceProxy
{

namespace Test
{

class Interface1 : public virtual ::Ice::Proxy<Interface1, ::IceProxy::Ice::Object>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class Interface2 : public virtual ::Ice::Proxy<Interface2, ::IceProxy::Ice::Object>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class Interface3 : public virtual ::Ice::Proxy<Interface3, ::IceProxy::Ice::Object>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class Interface4 : public virtual ::Ice::Proxy<Interface4, ::IceProxy::Ice::Object>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class EmptyClass1 : public virtual ::Ice::Proxy<EmptyClass1, ::IceProxy::Ice::Object>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class EmptyClass2 : public virtual ::Ice::Proxy<EmptyClass2, ::IceProxy::Ice::Object>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class EmptyClass3 : public virtual ::Ice::Proxy<EmptyClass3, ::IceProxy::Ice::Object>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class EmptyClass4 : public virtual ::Ice::Proxy<EmptyClass4, ::IceProxy::Ice::Object>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class EmptyClass5 : public virtual ::Ice::Proxy<EmptyClass5, ::IceProxy::Ice::Object>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class SimpleClass1 : public virtual ::Ice::Proxy<SimpleClass1, ::IceProxy::Ice::Object>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class SimpleClass2 : public virtual ::Ice::Proxy<SimpleClass2, ::IceProxy::Ice::Object>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class SimpleClass3 : public virtual ::Ice::Proxy<SimpleClass3, ::IceProxy::Ice::Object>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class SimpleClass4 : public virtual ::Ice::Proxy<SimpleClass4, ::IceProxy::Ice::Object>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class SimpleClass5 : public virtual ::Ice::Proxy<SimpleClass5, ::IceProxy::Ice::Object>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class SimpleClass6 : public virtual ::Ice::Proxy<SimpleClass6, ::IceProxy::Ice::Object>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class SimpleClass7 : public virtual ::Ice::Proxy<SimpleClass7, ::IceProxy::Ice::Object>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class BaseInterface1 : public virtual ::Ice::Proxy<BaseInterface1, ::IceProxy::Ice::Object>
{
public:

    void baseOp1(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_baseOp1(_iceI_begin_baseOp1(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_baseOp1(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_baseOp1(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_baseOp1(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_baseOp1(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp1(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_baseOp1(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp1(const ::Test::Callback_BaseInterface1_baseOp1Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_baseOp1(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp1(const ::Ice::Context& context, const ::Test::Callback_BaseInterface1_baseOp1Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_baseOp1(context, cb, cookie);
    }

    void end_baseOp1(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_baseOp1(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void baseOp2(::Ice::Int i, ::std::string& s, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_baseOp2(s, _iceI_begin_baseOp2(i, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_baseOp2(i, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_baseOp2(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_baseOp2(i, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Test::Callback_BaseInterface1_baseOp2Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_baseOp2(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Ice::Context& context, const ::Test::Callback_BaseInterface1_baseOp2Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_baseOp2(i, context, cb, cookie);
    }

    void end_baseOp2(::std::string& s, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_baseOp2(::std::string& iceP_s, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_baseOp2(::Ice::Int, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class BaseInterface2 : public virtual ::Ice::Proxy<BaseInterface2, ::IceProxy::Ice::Object>
{
public:

    void baseOp(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_baseOp(_iceI_begin_baseOp(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_baseOp(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_baseOp(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_baseOp(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_baseOp(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_baseOp(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp(const ::Test::Callback_BaseInterface2_baseOpPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_baseOp(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp(const ::Ice::Context& context, const ::Test::Callback_BaseInterface2_baseOpPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_baseOp(context, cb, cookie);
    }

    void end_baseOp(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_baseOp(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void baseOp2(::Ice::Int i, ::std::string& s, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_baseOp2(s, _iceI_begin_baseOp2(i, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_baseOp2(i, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_baseOp2(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_baseOp2(i, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Test::Callback_BaseInterface2_baseOp2Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_baseOp2(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Ice::Context& context, const ::Test::Callback_BaseInterface2_baseOp2Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_baseOp2(i, context, cb, cookie);
    }

    void end_baseOp2(::std::string& s, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_baseOp2(::std::string& iceP_s, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_baseOp2(::Ice::Int, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class BaseInterface3 : public virtual ::Ice::Proxy<BaseInterface3, ::IceProxy::Ice::Object>
{
public:

    void baseOp(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_baseOp(_iceI_begin_baseOp(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_baseOp(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_baseOp(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_baseOp(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_baseOp(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_baseOp(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp(const ::Test::Callback_BaseInterface3_baseOpPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_baseOp(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp(const ::Ice::Context& context, const ::Test::Callback_BaseInterface3_baseOpPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_baseOp(context, cb, cookie);
    }

    void end_baseOp(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_baseOp(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void baseOp2(::Ice::Int i, ::std::string& s, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_baseOp2(s, _iceI_begin_baseOp2(i, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_baseOp2(i, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_baseOp2(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_baseOp2(i, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Test::Callback_BaseInterface3_baseOp2Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_baseOp2(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Ice::Context& context, const ::Test::Callback_BaseInterface3_baseOp2Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_baseOp2(i, context, cb, cookie);
    }

    void end_baseOp2(::std::string& s, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_baseOp2(::std::string& iceP_s, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_baseOp2(::Ice::Int, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class BaseInterface4 : public virtual ::Ice::Proxy<BaseInterface4, ::IceProxy::Ice::Object>
{
public:

    void baseOp(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_baseOp(_iceI_begin_baseOp(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_baseOp(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_baseOp(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_baseOp(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_baseOp(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_baseOp(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp(const ::Test::Callback_BaseInterface4_baseOpPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_baseOp(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp(const ::Ice::Context& context, const ::Test::Callback_BaseInterface4_baseOpPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_baseOp(context, cb, cookie);
    }

    void end_baseOp(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_baseOp(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void baseOp2(::Ice::Int i, ::std::string& s, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_baseOp2(s, _iceI_begin_baseOp2(i, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_baseOp2(i, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_baseOp2(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_baseOp2(i, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Test::Callback_BaseInterface4_baseOp2Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_baseOp2(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Ice::Context& context, const ::Test::Callback_BaseInterface4_baseOp2Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_baseOp2(i, context, cb, cookie);
    }

    void end_baseOp2(::std::string& s, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_baseOp2(::std::string& iceP_s, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_baseOp2(::Ice::Int, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class BaseInterface5 : public virtual ::Ice::Proxy<BaseInterface5, ::IceProxy::Ice::Object>
{
public:

    void baseOp(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_baseOp(_iceI_begin_baseOp(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_baseOp(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_baseOp(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_baseOp(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_baseOp(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_baseOp(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp(const ::Test::Callback_BaseInterface5_baseOpPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_baseOp(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp(const ::Ice::Context& context, const ::Test::Callback_BaseInterface5_baseOpPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_baseOp(context, cb, cookie);
    }

    void end_baseOp(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_baseOp(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void baseOp2(::Ice::Int i, ::std::string& s, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_baseOp2(s, _iceI_begin_baseOp2(i, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_baseOp2(i, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_baseOp2(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_baseOp2(i, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Test::Callback_BaseInterface5_baseOp2Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_baseOp2(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Ice::Context& context, const ::Test::Callback_BaseInterface5_baseOp2Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_baseOp2(i, context, cb, cookie);
    }

    void end_baseOp2(::std::string& s, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_baseOp2(::std::string& iceP_s, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_baseOp2(::Ice::Int, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class BaseInterface6 : public virtual ::Ice::Proxy<BaseInterface6, ::IceProxy::Ice::Object>
{
public:

    void baseOp(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_baseOp(_iceI_begin_baseOp(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_baseOp(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_baseOp(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_baseOp(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_baseOp(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_baseOp(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp(const ::Test::Callback_BaseInterface6_baseOpPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_baseOp(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp(const ::Ice::Context& context, const ::Test::Callback_BaseInterface6_baseOpPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_baseOp(context, cb, cookie);
    }

    void end_baseOp(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_baseOp(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void baseOp2(::Ice::Int i, ::std::string& s, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_baseOp2(s, _iceI_begin_baseOp2(i, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_baseOp2(i, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_baseOp2(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_baseOp2(i, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Test::Callback_BaseInterface6_baseOp2Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_baseOp2(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Ice::Context& context, const ::Test::Callback_BaseInterface6_baseOp2Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_baseOp2(i, context, cb, cookie);
    }

    void end_baseOp2(::std::string& s, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_baseOp2(::std::string& iceP_s, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_baseOp2(::Ice::Int, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class BaseInterface7 : public virtual ::Ice::Proxy<BaseInterface7, ::IceProxy::Ice::Object>
{
public:

    void baseOp(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_baseOp(_iceI_begin_baseOp(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_baseOp(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_baseOp(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_baseOp(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_baseOp(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_baseOp(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp(const ::Test::Callback_BaseInterface7_baseOpPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_baseOp(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp(const ::Ice::Context& context, const ::Test::Callback_BaseInterface7_baseOpPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_baseOp(context, cb, cookie);
    }

    void end_baseOp(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_baseOp(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void baseOp2(::Ice::Int i, ::std::string& s, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_baseOp2(s, _iceI_begin_baseOp2(i, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_baseOp2(i, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_baseOp2(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_baseOp2(i, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Test::Callback_BaseInterface7_baseOp2Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_baseOp2(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Ice::Context& context, const ::Test::Callback_BaseInterface7_baseOp2Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_baseOp2(i, context, cb, cookie);
    }

    void end_baseOp2(::std::string& s, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_baseOp2(::std::string& iceP_s, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_baseOp2(::Ice::Int, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class BaseInterface8 : public virtual ::Ice::Proxy<BaseInterface8, ::IceProxy::Ice::Object>
{
public:

    void baseOp(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_baseOp(_iceI_begin_baseOp(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_baseOp(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_baseOp(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_baseOp(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_baseOp(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_baseOp(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp(const ::Test::Callback_BaseInterface8_baseOpPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_baseOp(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp(const ::Ice::Context& context, const ::Test::Callback_BaseInterface8_baseOpPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_baseOp(context, cb, cookie);
    }

    void end_baseOp(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_baseOp(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void baseOp2(::Ice::Int i, ::std::string& s, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_baseOp2(s, _iceI_begin_baseOp2(i, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_baseOp2(i, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_baseOp2(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_baseOp2(i, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Test::Callback_BaseInterface8_baseOp2Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_baseOp2(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Ice::Context& context, const ::Test::Callback_BaseInterface8_baseOp2Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_baseOp2(i, context, cb, cookie);
    }

    void end_baseOp2(::std::string& s, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_baseOp2(::std::string& iceP_s, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_baseOp2(::Ice::Int, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class BaseInterface9 : public virtual ::Ice::Proxy<BaseInterface9, ::IceProxy::Ice::Object>
{
public:

    void baseOp(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_baseOp(_iceI_begin_baseOp(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_baseOp(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_baseOp(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_baseOp(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_baseOp(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_baseOp(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp(const ::Test::Callback_BaseInterface9_baseOpPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_baseOp(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp(const ::Ice::Context& context, const ::Test::Callback_BaseInterface9_baseOpPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_baseOp(context, cb, cookie);
    }

    void end_baseOp(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_baseOp(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void baseOp2(::Ice::Int i, ::std::string& s, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_baseOp2(s, _iceI_begin_baseOp2(i, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_baseOp2(i, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_baseOp2(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_baseOp2(i, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Test::Callback_BaseInterface9_baseOp2Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_baseOp2(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Ice::Context& context, const ::Test::Callback_BaseInterface9_baseOp2Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_baseOp2(i, context, cb, cookie);
    }

    void end_baseOp2(::std::string& s, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_baseOp2(::std::string& iceP_s, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_baseOp2(::Ice::Int, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class BaseInterface10 : public virtual ::Ice::Proxy<BaseInterface10, ::IceProxy::Ice::Object>
{
public:

    void baseOp(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_baseOp(_iceI_begin_baseOp(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_baseOp(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_baseOp(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_baseOp(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_baseOp(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_baseOp(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp(const ::Test::Callback_BaseInterface10_baseOpPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_baseOp(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp(const ::Ice::Context& context, const ::Test::Callback_BaseInterface10_baseOpPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_baseOp(context, cb, cookie);
    }

    void end_baseOp(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_baseOp(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void baseOp2(::Ice::Int i, ::std::string& s, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_baseOp2(s, _iceI_begin_baseOp2(i, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_baseOp2(i, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_baseOp2(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_baseOp2(i, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Test::Callback_BaseInterface10_baseOp2Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_baseOp2(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Ice::Context& context, const ::Test::Callback_BaseInterface10_baseOp2Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_baseOp2(i, context, cb, cookie);
    }

    void end_baseOp2(::std::string& s, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_baseOp2(::std::string& iceP_s, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_baseOp2(::Ice::Int, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class BaseInterface11 : public virtual ::Ice::Proxy<BaseInterface11, ::IceProxy::Ice::Object>
{
public:

    void baseOp(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_baseOp(_iceI_begin_baseOp(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_baseOp(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_baseOp(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_baseOp(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_baseOp(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_baseOp(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp(const ::Test::Callback_BaseInterface11_baseOpPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_baseOp(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp(const ::Ice::Context& context, const ::Test::Callback_BaseInterface11_baseOpPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_baseOp(context, cb, cookie);
    }

    void end_baseOp(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_baseOp(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void baseOp2(::Ice::Int i, ::std::string& s, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_baseOp2(s, _iceI_begin_baseOp2(i, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_baseOp2(i, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_baseOp2(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_baseOp2(i, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Test::Callback_BaseInterface11_baseOp2Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_baseOp2(i, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_baseOp2(::Ice::Int i, const ::Ice::Context& context, const ::Test::Callback_BaseInterface11_baseOp2Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_baseOp2(i, context, cb, cookie);
    }

    void end_baseOp2(::std::string& s, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_baseOp2(::std::string& iceP_s, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_baseOp2(::Ice::Int, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class Compact1 : public virtual ::Ice::Proxy<Compact1, ::IceProxy::Ice::Object>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class Derived1 : public virtual ::Ice::Proxy<Derived1, ::IceProxy::Test::Compact1>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class Compact2 : public virtual ::Ice::Proxy<Compact2, ::IceProxy::Ice::Object>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class Optional0 : public virtual ::Ice::Proxy<Optional0, ::IceProxy::Ice::Object>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class Optional1 : public virtual ::Ice::Proxy<Optional1, ::IceProxy::Ice::Object>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class Optional2 : public virtual ::Ice::Proxy<Optional2, ::IceProxy::Ice::Object>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class Optional3 : public virtual ::Ice::Proxy<Optional3, ::IceProxy::Ice::Object>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class Optional4 : public virtual ::Ice::Proxy<Optional4, ::IceProxy::Ice::Object>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class OptionalParameters0 : public virtual ::Ice::Proxy<OptionalParameters0, ::IceProxy::Ice::Object>
{
public:

    void op1(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& secondName, const IceUtil::Optional< ::std::string>& emailAddress, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_op1(_iceI_begin_op1(firstName, secondName, emailAddress, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_op1(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& secondName, const IceUtil::Optional< ::std::string>& emailAddress, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_op1(firstName, secondName, emailAddress, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_op1(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& secondName, const IceUtil::Optional< ::std::string>& emailAddress, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_op1(firstName, secondName, emailAddress, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_op1(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& secondName, const IceUtil::Optional< ::std::string>& emailAddress, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_op1(firstName, secondName, emailAddress, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_op1(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& secondName, const IceUtil::Optional< ::std::string>& emailAddress, const ::Test::Callback_OptionalParameters0_op1Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_op1(firstName, secondName, emailAddress, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_op1(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& secondName, const IceUtil::Optional< ::std::string>& emailAddress, const ::Ice::Context& context, const ::Test::Callback_OptionalParameters0_op1Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_op1(firstName, secondName, emailAddress, context, cb, cookie);
    }

    void end_op1(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_op1(const ::std::string&, const IceUtil::Optional< ::std::string>&, const IceUtil::Optional< ::std::string>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class OptionalParameters1 : public virtual ::Ice::Proxy<OptionalParameters1, ::IceProxy::Ice::Object>
{
public:

    void op1(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& secondName, const IceUtil::Optional< ::std::string>& emailAddress, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_op1(_iceI_begin_op1(firstName, secondName, emailAddress, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_op1(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& secondName, const IceUtil::Optional< ::std::string>& emailAddress, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_op1(firstName, secondName, emailAddress, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_op1(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& secondName, const IceUtil::Optional< ::std::string>& emailAddress, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_op1(firstName, secondName, emailAddress, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_op1(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& secondName, const IceUtil::Optional< ::std::string>& emailAddress, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_op1(firstName, secondName, emailAddress, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_op1(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& secondName, const IceUtil::Optional< ::std::string>& emailAddress, const ::Test::Callback_OptionalParameters1_op1Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_op1(firstName, secondName, emailAddress, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_op1(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& secondName, const IceUtil::Optional< ::std::string>& emailAddress, const ::Ice::Context& context, const ::Test::Callback_OptionalParameters1_op1Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_op1(firstName, secondName, emailAddress, context, cb, cookie);
    }

    void end_op1(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_op1(const ::std::string&, const IceUtil::Optional< ::std::string>&, const IceUtil::Optional< ::std::string>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class OptionalParameters2 : public virtual ::Ice::Proxy<OptionalParameters2, ::IceProxy::Ice::Object>
{
public:

    void op1(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& emailAddress, const IceUtil::Optional< ::std::string>& secondName, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_op1(_iceI_begin_op1(firstName, emailAddress, secondName, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_op1(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& emailAddress, const IceUtil::Optional< ::std::string>& secondName, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_op1(firstName, emailAddress, secondName, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_op1(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& emailAddress, const IceUtil::Optional< ::std::string>& secondName, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_op1(firstName, emailAddress, secondName, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_op1(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& emailAddress, const IceUtil::Optional< ::std::string>& secondName, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_op1(firstName, emailAddress, secondName, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_op1(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& emailAddress, const IceUtil::Optional< ::std::string>& secondName, const ::Test::Callback_OptionalParameters2_op1Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_op1(firstName, emailAddress, secondName, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_op1(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& emailAddress, const IceUtil::Optional< ::std::string>& secondName, const ::Ice::Context& context, const ::Test::Callback_OptionalParameters2_op1Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_op1(firstName, emailAddress, secondName, context, cb, cookie);
    }

    void end_op1(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_op1(const ::std::string&, const IceUtil::Optional< ::std::string>&, const IceUtil::Optional< ::std::string>&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class OptionalParameters3 : public virtual ::Ice::Proxy<OptionalParameters3, ::IceProxy::Ice::Object>
{
public:

    void op1(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& emailAddress, const ::std::string& secondName, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_op1(_iceI_begin_op1(firstName, emailAddress, secondName, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_op1(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& emailAddress, const ::std::string& secondName, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_op1(firstName, emailAddress, secondName, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_op1(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& emailAddress, const ::std::string& secondName, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_op1(firstName, emailAddress, secondName, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_op1(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& emailAddress, const ::std::string& secondName, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_op1(firstName, emailAddress, secondName, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_op1(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& emailAddress, const ::std::string& secondName, const ::Test::Callback_OptionalParameters3_op1Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_op1(firstName, emailAddress, secondName, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_op1(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& emailAddress, const ::std::string& secondName, const ::Ice::Context& context, const ::Test::Callback_OptionalParameters3_op1Ptr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_op1(firstName, emailAddress, secondName, context, cb, cookie);
    }

    void end_op1(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_op1(const ::std::string&, const IceUtil::Optional< ::std::string>&, const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class OptionalReturn0 : public virtual ::Ice::Proxy<OptionalReturn0, ::IceProxy::Ice::Object>
{
public:

    IceUtil::Optional< ::Ice::Int> op(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_op(_iceI_begin_op(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_op(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_op(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_op(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_op(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_op(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_op(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_op(const ::Test::Callback_OptionalReturn0_opPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_op(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_op(const ::Ice::Context& context, const ::Test::Callback_OptionalReturn0_opPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_op(context, cb, cookie);
    }

    IceUtil::Optional< ::Ice::Int> end_op(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_op(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class OptionalReturn2 : public virtual ::Ice::Proxy<OptionalReturn2, ::IceProxy::Ice::Object>
{
public:

    IceUtil::Optional< ::Ice::Int> op(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_op(_iceI_begin_op(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_op(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_op(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_op(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_op(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_op(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_op(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_op(const ::Test::Callback_OptionalReturn2_opPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_op(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_op(const ::Ice::Context& context, const ::Test::Callback_OptionalReturn2_opPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_op(context, cb, cookie);
    }

    IceUtil::Optional< ::Ice::Int> end_op(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_op(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

}

}

namespace Test
{

class Interface1 : public virtual ::Ice::Object
{
public:

    typedef Interface1Prx ProxyType;
    typedef Interface1Ptr PointerType;

    virtual ~Interface1();

#ifdef ICE_CPP11_COMPILER
    Interface1() = default;
    Interface1(const Interface1&) = default;
    Interface1& operator=(const Interface1&) = default;
#endif

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
inline bool operator==(const Interface1& lhs, const Interface1& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const Interface1& lhs, const Interface1& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class Interface2 : public virtual ::Ice::Object
{
public:

    typedef Interface2Prx ProxyType;
    typedef Interface2Ptr PointerType;

    virtual ~Interface2();

#ifdef ICE_CPP11_COMPILER
    Interface2() = default;
    Interface2(const Interface2&) = default;
    Interface2& operator=(const Interface2&) = default;
#endif

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
inline bool operator==(const Interface2& lhs, const Interface2& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const Interface2& lhs, const Interface2& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class Interface3 : public virtual ::Ice::Object
{
public:

    typedef Interface3Prx ProxyType;
    typedef Interface3Ptr PointerType;

    virtual ~Interface3();

#ifdef ICE_CPP11_COMPILER
    Interface3() = default;
    Interface3(const Interface3&) = default;
    Interface3& operator=(const Interface3&) = default;
#endif

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
inline bool operator==(const Interface3& lhs, const Interface3& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const Interface3& lhs, const Interface3& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class Interface4 : public virtual ::Ice::Object
{
public:

    typedef Interface4Prx ProxyType;
    typedef Interface4Ptr PointerType;

    virtual ~Interface4();

#ifdef ICE_CPP11_COMPILER
    Interface4() = default;
    Interface4(const Interface4&) = default;
    Interface4& operator=(const Interface4&) = default;
#endif

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
inline bool operator==(const Interface4& lhs, const Interface4& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const Interface4& lhs, const Interface4& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class EmptyClass1 : public virtual ::Ice::Object
{
public:

    typedef EmptyClass1Prx ProxyType;
    typedef EmptyClass1Ptr PointerType;

    virtual ~EmptyClass1();

    EmptyClass1()
    {
    }

#ifdef ICE_CPP11_COMPILER
    EmptyClass1(const EmptyClass1&) = default;
    EmptyClass1& operator=(const EmptyClass1&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_EmptyClass1_init = ::Test::EmptyClass1::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const EmptyClass1& lhs, const EmptyClass1& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const EmptyClass1& lhs, const EmptyClass1& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class EmptyClass2 : public virtual ::Ice::Object
{
public:

    typedef EmptyClass2Prx ProxyType;
    typedef EmptyClass2Ptr PointerType;

    virtual ~EmptyClass2();

    EmptyClass2()
    {
    }

#ifdef ICE_CPP11_COMPILER
    EmptyClass2(const EmptyClass2&) = default;
    EmptyClass2& operator=(const EmptyClass2&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_EmptyClass2_init = ::Test::EmptyClass2::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const EmptyClass2& lhs, const EmptyClass2& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const EmptyClass2& lhs, const EmptyClass2& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class EmptyClass3 : public virtual ::Ice::Object
{
public:

    typedef EmptyClass3Prx ProxyType;
    typedef EmptyClass3Ptr PointerType;

    virtual ~EmptyClass3();

    EmptyClass3()
    {
    }

#ifdef ICE_CPP11_COMPILER
    EmptyClass3(const EmptyClass3&) = default;
    EmptyClass3& operator=(const EmptyClass3&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_EmptyClass3_init = ::Test::EmptyClass3::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const EmptyClass3& lhs, const EmptyClass3& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const EmptyClass3& lhs, const EmptyClass3& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class EmptyClass4 : public virtual ::Ice::Object
{
public:

    typedef EmptyClass4Prx ProxyType;
    typedef EmptyClass4Ptr PointerType;

    virtual ~EmptyClass4();

    EmptyClass4()
    {
    }

#ifdef ICE_CPP11_COMPILER
    EmptyClass4(const EmptyClass4&) = default;
    EmptyClass4& operator=(const EmptyClass4&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_EmptyClass4_init = ::Test::EmptyClass4::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const EmptyClass4& lhs, const EmptyClass4& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const EmptyClass4& lhs, const EmptyClass4& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class EmptyClass5 : public virtual ::Ice::Object
{
public:

    typedef EmptyClass5Prx ProxyType;
    typedef EmptyClass5Ptr PointerType;

    virtual ~EmptyClass5();

    EmptyClass5()
    {
    }

#ifdef ICE_CPP11_COMPILER
    EmptyClass5(const EmptyClass5&) = default;
    EmptyClass5& operator=(const EmptyClass5&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_EmptyClass5_init = ::Test::EmptyClass5::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const EmptyClass5& lhs, const EmptyClass5& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const EmptyClass5& lhs, const EmptyClass5& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class SimpleClass1 : public virtual ::Ice::Object
{
public:

    typedef SimpleClass1Prx ProxyType;
    typedef SimpleClass1Ptr PointerType;

    virtual ~SimpleClass1();

    SimpleClass1()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    SimpleClass1(const ::std::string& str, ::Ice::Float f) :
        str(str),
        f(f)
    {
    }

#ifdef ICE_CPP11_COMPILER
    SimpleClass1(const SimpleClass1&) = default;
    SimpleClass1& operator=(const SimpleClass1&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    ::std::string str;
    ::Ice::Float f;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_SimpleClass1_init = ::Test::SimpleClass1::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const SimpleClass1& lhs, const SimpleClass1& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const SimpleClass1& lhs, const SimpleClass1& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class SimpleClass2 : public virtual ::Ice::Object
{
public:

    typedef SimpleClass2Prx ProxyType;
    typedef SimpleClass2Ptr PointerType;

    virtual ~SimpleClass2();

    SimpleClass2()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    SimpleClass2(const ::std::string& str, ::Ice::Float f) :
        str(str),
        f(f)
    {
    }

#ifdef ICE_CPP11_COMPILER
    SimpleClass2(const SimpleClass2&) = default;
    SimpleClass2& operator=(const SimpleClass2&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    ::std::string str;
    ::Ice::Float f;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_SimpleClass2_init = ::Test::SimpleClass2::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const SimpleClass2& lhs, const SimpleClass2& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const SimpleClass2& lhs, const SimpleClass2& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class SimpleClass3 : public virtual ::Ice::Object
{
public:

    typedef SimpleClass3Prx ProxyType;
    typedef SimpleClass3Ptr PointerType;

    virtual ~SimpleClass3();

    SimpleClass3()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    SimpleClass3(const ::std::string& str, ::Ice::Float f) :
        str(str),
        f(f)
    {
    }

#ifdef ICE_CPP11_COMPILER
    SimpleClass3(const SimpleClass3&) = default;
    SimpleClass3& operator=(const SimpleClass3&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    ::std::string str;
    ::Ice::Float f;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_SimpleClass3_init = ::Test::SimpleClass3::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const SimpleClass3& lhs, const SimpleClass3& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const SimpleClass3& lhs, const SimpleClass3& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class SimpleClass4 : public virtual ::Ice::Object
{
public:

    typedef SimpleClass4Prx ProxyType;
    typedef SimpleClass4Ptr PointerType;

    virtual ~SimpleClass4();

    SimpleClass4()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    SimpleClass4(const ::std::string& str, ::Ice::Float f) :
        str(str),
        f(f)
    {
    }

#ifdef ICE_CPP11_COMPILER
    SimpleClass4(const SimpleClass4&) = default;
    SimpleClass4& operator=(const SimpleClass4&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    ::std::string str;
    ::Ice::Float f;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_SimpleClass4_init = ::Test::SimpleClass4::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const SimpleClass4& lhs, const SimpleClass4& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const SimpleClass4& lhs, const SimpleClass4& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class SimpleClass5 : public virtual ::Ice::Object
{
public:

    typedef SimpleClass5Prx ProxyType;
    typedef SimpleClass5Ptr PointerType;

    virtual ~SimpleClass5();

    SimpleClass5()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    SimpleClass5(const ::std::string& str, ::Ice::Float f) :
        str(str),
        f(f)
    {
    }

#ifdef ICE_CPP11_COMPILER
    SimpleClass5(const SimpleClass5&) = default;
    SimpleClass5& operator=(const SimpleClass5&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    ::std::string str;
    ::Ice::Float f;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_SimpleClass5_init = ::Test::SimpleClass5::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const SimpleClass5& lhs, const SimpleClass5& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const SimpleClass5& lhs, const SimpleClass5& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class SimpleClass6 : public virtual ::Ice::Object
{
public:

    typedef SimpleClass6Prx ProxyType;
    typedef SimpleClass6Ptr PointerType;

    virtual ~SimpleClass6();

    SimpleClass6()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    SimpleClass6(const ::std::string& str, ::Ice::Float f) :
        str(str),
        f(f)
    {
    }

#ifdef ICE_CPP11_COMPILER
    SimpleClass6(const SimpleClass6&) = default;
    SimpleClass6& operator=(const SimpleClass6&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    ::std::string str;
    ::Ice::Float f;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_SimpleClass6_init = ::Test::SimpleClass6::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const SimpleClass6& lhs, const SimpleClass6& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const SimpleClass6& lhs, const SimpleClass6& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class SimpleClass7 : public virtual ::Ice::Object
{
public:

    typedef SimpleClass7Prx ProxyType;
    typedef SimpleClass7Ptr PointerType;

    virtual ~SimpleClass7();

    SimpleClass7()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    SimpleClass7(const ::std::string& str, ::Ice::Float f) :
        str(str),
        f(f)
    {
    }

#ifdef ICE_CPP11_COMPILER
    SimpleClass7(const SimpleClass7&) = default;
    SimpleClass7& operator=(const SimpleClass7&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    ::std::string str;
    ::Ice::Float f;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_SimpleClass7_init = ::Test::SimpleClass7::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const SimpleClass7& lhs, const SimpleClass7& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const SimpleClass7& lhs, const SimpleClass7& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class BaseInterface1 : public virtual ::Ice::Object
{
public:

    typedef BaseInterface1Prx ProxyType;
    typedef BaseInterface1Ptr PointerType;

    virtual ~BaseInterface1();

#ifdef ICE_CPP11_COMPILER
    BaseInterface1() = default;
    BaseInterface1(const BaseInterface1&) = default;
    BaseInterface1& operator=(const BaseInterface1&) = default;
#endif

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void baseOp1(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_baseOp1(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void baseOp2(::Ice::Int i, ::std::string& s, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_baseOp2(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
inline bool operator==(const BaseInterface1& lhs, const BaseInterface1& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const BaseInterface1& lhs, const BaseInterface1& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class BaseInterface2 : public virtual ::Ice::Object
{
public:

    typedef BaseInterface2Prx ProxyType;
    typedef BaseInterface2Ptr PointerType;

    virtual ~BaseInterface2();

#ifdef ICE_CPP11_COMPILER
    BaseInterface2() = default;
    BaseInterface2(const BaseInterface2&) = default;
    BaseInterface2& operator=(const BaseInterface2&) = default;
#endif

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void baseOp(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_baseOp(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void baseOp2(::Ice::Int i, ::std::string& s, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_baseOp2(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
inline bool operator==(const BaseInterface2& lhs, const BaseInterface2& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const BaseInterface2& lhs, const BaseInterface2& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class BaseInterface3 : public virtual ::Ice::Object
{
public:

    typedef BaseInterface3Prx ProxyType;
    typedef BaseInterface3Ptr PointerType;

    virtual ~BaseInterface3();

#ifdef ICE_CPP11_COMPILER
    BaseInterface3() = default;
    BaseInterface3(const BaseInterface3&) = default;
    BaseInterface3& operator=(const BaseInterface3&) = default;
#endif

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void baseOp(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_baseOp(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void baseOp2(::Ice::Int i, ::std::string& s, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_baseOp2(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
inline bool operator==(const BaseInterface3& lhs, const BaseInterface3& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const BaseInterface3& lhs, const BaseInterface3& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class BaseInterface4 : public virtual ::Ice::Object
{
public:

    typedef BaseInterface4Prx ProxyType;
    typedef BaseInterface4Ptr PointerType;

    virtual ~BaseInterface4();

#ifdef ICE_CPP11_COMPILER
    BaseInterface4() = default;
    BaseInterface4(const BaseInterface4&) = default;
    BaseInterface4& operator=(const BaseInterface4&) = default;
#endif

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void baseOp(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_baseOp(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void baseOp2(::Ice::Int i, ::std::string& s, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_baseOp2(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
inline bool operator==(const BaseInterface4& lhs, const BaseInterface4& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const BaseInterface4& lhs, const BaseInterface4& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class BaseInterface5 : public virtual ::Ice::Object
{
public:

    typedef BaseInterface5Prx ProxyType;
    typedef BaseInterface5Ptr PointerType;

    virtual ~BaseInterface5();

#ifdef ICE_CPP11_COMPILER
    BaseInterface5() = default;
    BaseInterface5(const BaseInterface5&) = default;
    BaseInterface5& operator=(const BaseInterface5&) = default;
#endif

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void baseOp(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_baseOp(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void baseOp2(::Ice::Int i, ::std::string& s, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_baseOp2(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
inline bool operator==(const BaseInterface5& lhs, const BaseInterface5& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const BaseInterface5& lhs, const BaseInterface5& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class BaseInterface6 : public virtual ::Ice::Object
{
public:

    typedef BaseInterface6Prx ProxyType;
    typedef BaseInterface6Ptr PointerType;

    virtual ~BaseInterface6();

#ifdef ICE_CPP11_COMPILER
    BaseInterface6() = default;
    BaseInterface6(const BaseInterface6&) = default;
    BaseInterface6& operator=(const BaseInterface6&) = default;
#endif

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void baseOp(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_baseOp(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void baseOp2(::Ice::Int i, ::std::string& s, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_baseOp2(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
inline bool operator==(const BaseInterface6& lhs, const BaseInterface6& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const BaseInterface6& lhs, const BaseInterface6& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class BaseInterface7 : public virtual ::Ice::Object
{
public:

    typedef BaseInterface7Prx ProxyType;
    typedef BaseInterface7Ptr PointerType;

    virtual ~BaseInterface7();

#ifdef ICE_CPP11_COMPILER
    BaseInterface7() = default;
    BaseInterface7(const BaseInterface7&) = default;
    BaseInterface7& operator=(const BaseInterface7&) = default;
#endif

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void baseOp(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_baseOp(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void baseOp2(::Ice::Int i, ::std::string& s, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_baseOp2(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
inline bool operator==(const BaseInterface7& lhs, const BaseInterface7& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const BaseInterface7& lhs, const BaseInterface7& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class BaseInterface8 : public virtual ::Ice::Object
{
public:

    typedef BaseInterface8Prx ProxyType;
    typedef BaseInterface8Ptr PointerType;

    virtual ~BaseInterface8();

#ifdef ICE_CPP11_COMPILER
    BaseInterface8() = default;
    BaseInterface8(const BaseInterface8&) = default;
    BaseInterface8& operator=(const BaseInterface8&) = default;
#endif

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void baseOp(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_baseOp(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void baseOp2(::Ice::Int i, ::std::string& s, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_baseOp2(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
inline bool operator==(const BaseInterface8& lhs, const BaseInterface8& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const BaseInterface8& lhs, const BaseInterface8& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class BaseInterface9 : public virtual ::Ice::Object
{
public:

    typedef BaseInterface9Prx ProxyType;
    typedef BaseInterface9Ptr PointerType;

    virtual ~BaseInterface9();

#ifdef ICE_CPP11_COMPILER
    BaseInterface9() = default;
    BaseInterface9(const BaseInterface9&) = default;
    BaseInterface9& operator=(const BaseInterface9&) = default;
#endif

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void baseOp(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_baseOp(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void baseOp2(::Ice::Int i, ::std::string& s, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_baseOp2(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
inline bool operator==(const BaseInterface9& lhs, const BaseInterface9& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const BaseInterface9& lhs, const BaseInterface9& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class BaseInterface10 : public virtual ::Ice::Object
{
public:

    typedef BaseInterface10Prx ProxyType;
    typedef BaseInterface10Ptr PointerType;

    virtual ~BaseInterface10();

#ifdef ICE_CPP11_COMPILER
    BaseInterface10() = default;
    BaseInterface10(const BaseInterface10&) = default;
    BaseInterface10& operator=(const BaseInterface10&) = default;
#endif

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void baseOp(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_baseOp(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void baseOp2(::Ice::Int i, ::std::string& s, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_baseOp2(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
inline bool operator==(const BaseInterface10& lhs, const BaseInterface10& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const BaseInterface10& lhs, const BaseInterface10& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class BaseInterface11 : public virtual ::Ice::Object
{
public:

    typedef BaseInterface11Prx ProxyType;
    typedef BaseInterface11Ptr PointerType;

    virtual ~BaseInterface11();

#ifdef ICE_CPP11_COMPILER
    BaseInterface11() = default;
    BaseInterface11(const BaseInterface11&) = default;
    BaseInterface11& operator=(const BaseInterface11&) = default;
#endif

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void baseOp(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_baseOp(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void baseOp2(::Ice::Int i, ::std::string& s, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_baseOp2(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
inline bool operator==(const BaseInterface11& lhs, const BaseInterface11& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const BaseInterface11& lhs, const BaseInterface11& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class Compact1 : public virtual ::Ice::Object
{
public:

    typedef Compact1Prx ProxyType;
    typedef Compact1Ptr PointerType;

    virtual ~Compact1();

    Compact1()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit Compact1(::Ice::Int id) :
        id(id)
    {
    }

#ifdef ICE_CPP11_COMPILER
    Compact1(const Compact1&) = default;
    Compact1& operator=(const Compact1&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    ::Ice::Int id;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_Compact1_init = ::Test::Compact1::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const Compact1& lhs, const Compact1& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const Compact1& lhs, const Compact1& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class Derived1 : public Compact1
{
public:

    typedef Derived1Prx ProxyType;
    typedef Derived1Ptr PointerType;

    virtual ~Derived1();

    Derived1()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit Derived1(::Ice::Int id) :
        ::Test::Compact1(id)
    {
    }

#ifdef ICE_CPP11_COMPILER
    Derived1(const Derived1&) = default;
    Derived1& operator=(const Derived1&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_Derived1_init = ::Test::Derived1::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const Derived1& lhs, const Derived1& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const Derived1& lhs, const Derived1& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class Compact2 : public virtual ::Ice::Object
{
public:

    typedef Compact2Prx ProxyType;
    typedef Compact2Ptr PointerType;

    virtual ~Compact2();

    Compact2()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    explicit Compact2(::Ice::Int id) :
        id(id)
    {
    }

#ifdef ICE_CPP11_COMPILER
    Compact2(const Compact2&) = default;
    Compact2& operator=(const Compact2&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    ::Ice::Int id;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_Compact2_init = ::Test::Compact2::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const Compact2& lhs, const Compact2& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const Compact2& lhs, const Compact2& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class Optional0 : public virtual ::Ice::Object
{
public:

    typedef Optional0Prx ProxyType;
    typedef Optional0Ptr PointerType;

    virtual ~Optional0();

    Optional0()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    Optional0(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& secondName, const IceUtil::Optional< ::std::string>& emailAddress) :
        firstName(firstName),
        secondName(secondName),
        emailAddress(emailAddress)
    {
    }

#ifdef ICE_CPP11_COMPILER
    Optional0(const Optional0&) = default;
    Optional0& operator=(const Optional0&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    ::std::string firstName;
    IceUtil::Optional< ::std::string> secondName;
    IceUtil::Optional< ::std::string> emailAddress;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_Optional0_init = ::Test::Optional0::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const Optional0& lhs, const Optional0& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const Optional0& lhs, const Optional0& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class Optional1 : public virtual ::Ice::Object
{
public:

    typedef Optional1Prx ProxyType;
    typedef Optional1Ptr PointerType;

    virtual ~Optional1();

    Optional1()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    Optional1(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& secondName, const IceUtil::Optional< ::std::string>& emailAddress) :
        firstName(firstName),
        secondName(secondName),
        emailAddress(emailAddress)
    {
    }

#ifdef ICE_CPP11_COMPILER
    Optional1(const Optional1&) = default;
    Optional1& operator=(const Optional1&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    ::std::string firstName;
    IceUtil::Optional< ::std::string> secondName;
    IceUtil::Optional< ::std::string> emailAddress;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_Optional1_init = ::Test::Optional1::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const Optional1& lhs, const Optional1& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const Optional1& lhs, const Optional1& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class Optional2 : public virtual ::Ice::Object
{
public:

    typedef Optional2Prx ProxyType;
    typedef Optional2Ptr PointerType;

    virtual ~Optional2();

    Optional2()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    Optional2(const ::std::string& firstName, const ::std::string& secondName, const IceUtil::Optional< ::std::string>& emailAddress) :
        firstName(firstName),
        secondName(secondName),
        emailAddress(emailAddress)
    {
    }

#ifdef ICE_CPP11_COMPILER
    Optional2(const Optional2&) = default;
    Optional2& operator=(const Optional2&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    ::std::string firstName;
    ::std::string secondName;
    IceUtil::Optional< ::std::string> emailAddress;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_Optional2_init = ::Test::Optional2::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const Optional2& lhs, const Optional2& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const Optional2& lhs, const Optional2& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class Optional3 : public virtual ::Ice::Object
{
public:

    typedef Optional3Prx ProxyType;
    typedef Optional3Ptr PointerType;

    virtual ~Optional3();

    Optional3()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    Optional3(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& secondName, const IceUtil::Optional< ::std::string>& emailAddress) :
        firstName(firstName),
        secondName(secondName),
        emailAddress(emailAddress)
    {
    }

#ifdef ICE_CPP11_COMPILER
    Optional3(const Optional3&) = default;
    Optional3& operator=(const Optional3&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    ::std::string firstName;
    IceUtil::Optional< ::std::string> secondName;
    IceUtil::Optional< ::std::string> emailAddress;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_Optional3_init = ::Test::Optional3::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const Optional3& lhs, const Optional3& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const Optional3& lhs, const Optional3& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class Optional4 : public virtual ::Ice::Object
{
public:

    typedef Optional4Prx ProxyType;
    typedef Optional4Ptr PointerType;

    virtual ~Optional4();

    Optional4()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    Optional4(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& secondName, const IceUtil::Optional< ::std::string>& emailAddress) :
        firstName(firstName),
        secondName(secondName),
        emailAddress(emailAddress)
    {
    }

#ifdef ICE_CPP11_COMPILER
    Optional4(const Optional4&) = default;
    Optional4& operator=(const Optional4&) = default;
#endif

    /**
     * Polymorphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    ::std::string firstName;
    IceUtil::Optional< ::std::string> secondName;
    IceUtil::Optional< ::std::string> emailAddress;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_Optional4_init = ::Test::Optional4::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const Optional4& lhs, const Optional4& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const Optional4& lhs, const Optional4& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class OptionalParameters0 : public virtual ::Ice::Object
{
public:

    typedef OptionalParameters0Prx ProxyType;
    typedef OptionalParameters0Ptr PointerType;

    virtual ~OptionalParameters0();

#ifdef ICE_CPP11_COMPILER
    OptionalParameters0() = default;
    OptionalParameters0(const OptionalParameters0&) = default;
    OptionalParameters0& operator=(const OptionalParameters0&) = default;
#endif

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void op1(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& secondName, const IceUtil::Optional< ::std::string>& emailAddress, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_op1(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
inline bool operator==(const OptionalParameters0& lhs, const OptionalParameters0& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const OptionalParameters0& lhs, const OptionalParameters0& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class OptionalParameters1 : public virtual ::Ice::Object
{
public:

    typedef OptionalParameters1Prx ProxyType;
    typedef OptionalParameters1Ptr PointerType;

    virtual ~OptionalParameters1();

#ifdef ICE_CPP11_COMPILER
    OptionalParameters1() = default;
    OptionalParameters1(const OptionalParameters1&) = default;
    OptionalParameters1& operator=(const OptionalParameters1&) = default;
#endif

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void op1(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& secondName, const IceUtil::Optional< ::std::string>& emailAddress, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_op1(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
inline bool operator==(const OptionalParameters1& lhs, const OptionalParameters1& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const OptionalParameters1& lhs, const OptionalParameters1& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class OptionalParameters2 : public virtual ::Ice::Object
{
public:

    typedef OptionalParameters2Prx ProxyType;
    typedef OptionalParameters2Ptr PointerType;

    virtual ~OptionalParameters2();

#ifdef ICE_CPP11_COMPILER
    OptionalParameters2() = default;
    OptionalParameters2(const OptionalParameters2&) = default;
    OptionalParameters2& operator=(const OptionalParameters2&) = default;
#endif

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void op1(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& emailAddress, const IceUtil::Optional< ::std::string>& secondName, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_op1(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
inline bool operator==(const OptionalParameters2& lhs, const OptionalParameters2& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const OptionalParameters2& lhs, const OptionalParameters2& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class OptionalParameters3 : public virtual ::Ice::Object
{
public:

    typedef OptionalParameters3Prx ProxyType;
    typedef OptionalParameters3Ptr PointerType;

    virtual ~OptionalParameters3();

#ifdef ICE_CPP11_COMPILER
    OptionalParameters3() = default;
    OptionalParameters3(const OptionalParameters3&) = default;
    OptionalParameters3& operator=(const OptionalParameters3&) = default;
#endif

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void op1(const ::std::string& firstName, const IceUtil::Optional< ::std::string>& emailAddress, const ::std::string& secondName, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_op1(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
inline bool operator==(const OptionalParameters3& lhs, const OptionalParameters3& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const OptionalParameters3& lhs, const OptionalParameters3& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class OptionalReturn0 : public virtual ::Ice::Object
{
public:

    typedef OptionalReturn0Prx ProxyType;
    typedef OptionalReturn0Ptr PointerType;

    virtual ~OptionalReturn0();

#ifdef ICE_CPP11_COMPILER
    OptionalReturn0() = default;
    OptionalReturn0(const OptionalReturn0&) = default;
    OptionalReturn0& operator=(const OptionalReturn0&) = default;
#endif

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual IceUtil::Optional< ::Ice::Int> op(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_op(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
inline bool operator==(const OptionalReturn0& lhs, const OptionalReturn0& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const OptionalReturn0& lhs, const OptionalReturn0& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class OptionalReturn2 : public virtual ::Ice::Object
{
public:

    typedef OptionalReturn2Prx ProxyType;
    typedef OptionalReturn2Ptr PointerType;

    virtual ~OptionalReturn2();

#ifdef ICE_CPP11_COMPILER
    OptionalReturn2() = default;
    OptionalReturn2(const OptionalReturn2&) = default;
    OptionalReturn2& operator=(const OptionalReturn2&) = default;
#endif

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual IceUtil::Optional< ::Ice::Int> op(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_op(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
inline bool operator==(const OptionalReturn2& lhs, const OptionalReturn2& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const OptionalReturn2& lhs, const OptionalReturn2& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class LocalClass : public virtual ::Ice::LocalObject
{
public:

    typedef LocalClassPtr PointerType;

    virtual ~LocalClass();

    LocalClass()
    {
    }

#ifdef ICE_CPP11_COMPILER
    LocalClass(const LocalClass&) = default;
    LocalClass& operator=(const LocalClass&) = default;
#endif
};

/// \cond INTERNAL
inline bool operator==(const LocalClass& lhs, const LocalClass& rhs)
{
    return static_cast<const ::Ice::LocalObject&>(lhs) == static_cast<const ::Ice::LocalObject&>(rhs);
}

inline bool operator<(const LocalClass& lhs, const LocalClass& rhs)
{
    return static_cast<const ::Ice::LocalObject&>(lhs) < static_cast<const ::Ice::LocalObject&>(rhs);
}
/// \endcond

}

/// \cond STREAM
namespace Ice
{

template<>
struct StreamableTraits< ::Test::Enum1>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 2;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits< ::Test::Enum2>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 2;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits< ::Test::Enum3>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 2;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits< ::Test::Enum4>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 2;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits< ::Test::EnumExplicit0>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 1;
    static const int maxValue = 3;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits< ::Test::EnumExplicit1>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 1;
    static const int maxValue = 3;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits< ::Test::EnumExplicit2>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 1;
    static const int maxValue = 3;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits< ::Test::EnumExplicit3>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 1;
    static const int maxValue = 3;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits< ::Test::Struct1>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 2;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::Test::Struct1, S>
{
    static void write(S* ostr, const ::Test::Struct1& v)
    {
        ostr->write(v.str);
        ostr->write(v.b);
    }
};

template<typename S>
struct StreamReader< ::Test::Struct1, S>
{
    static void read(S* istr, ::Test::Struct1& v)
    {
        istr->read(v.str);
        istr->read(v.b);
    }
};

template<>
struct StreamableTraits< ::Test::Struct2>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 2;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::Test::Struct2, S>
{
    static void write(S* ostr, const ::Test::Struct2& v)
    {
        ostr->write(v.str);
        ostr->write(v.b);
    }
};

template<typename S>
struct StreamReader< ::Test::Struct2, S>
{
    static void read(S* istr, ::Test::Struct2& v)
    {
        istr->read(v.str);
        istr->read(v.b);
    }
};

template<>
struct StreamableTraits< ::Test::Struct3>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 2;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::Test::Struct3, S>
{
    static void write(S* ostr, const ::Test::Struct3& v)
    {
        ostr->write(v.str);
        ostr->write(v.b);
    }
};

template<typename S>
struct StreamReader< ::Test::Struct3, S>
{
    static void read(S* istr, ::Test::Struct3& v)
    {
        istr->read(v.str);
        istr->read(v.b);
    }
};

template<>
struct StreamableTraits< ::Test::Struct4>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 2;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::Test::Struct4, S>
{
    static void write(S* ostr, const ::Test::Struct4& v)
    {
        ostr->write(v.str);
        ostr->write(v.b);
    }
};

template<typename S>
struct StreamReader< ::Test::Struct4, S>
{
    static void read(S* istr, ::Test::Struct4& v)
    {
        istr->read(v.str);
        istr->read(v.b);
    }
};

template<>
struct StreamableTraits< ::Test::Struct5>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 2;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::Test::Struct5, S>
{
    static void write(S* ostr, const ::Test::Struct5& v)
    {
        ostr->write(v.str);
        ostr->write(v.b);
    }
};

template<typename S>
struct StreamReader< ::Test::Struct5, S>
{
    static void read(S* istr, ::Test::Struct5& v)
    {
        istr->read(v.str);
        istr->read(v.b);
    }
};

template<typename S>
struct StreamWriter< ::Test::SimpleClass1, S>
{
    static void write(S* ostr, const ::Test::SimpleClass1& v)
    {
        ostr->write(v.str);
        ostr->write(v.f);
    }
};

template<typename S>
struct StreamReader< ::Test::SimpleClass1, S>
{
    static void read(S* istr, ::Test::SimpleClass1& v)
    {
        istr->read(v.str);
        istr->read(v.f);
    }
};

template<typename S>
struct StreamWriter< ::Test::SimpleClass2, S>
{
    static void write(S* ostr, const ::Test::SimpleClass2& v)
    {
        ostr->write(v.str);
        ostr->write(v.f);
    }
};

template<typename S>
struct StreamReader< ::Test::SimpleClass2, S>
{
    static void read(S* istr, ::Test::SimpleClass2& v)
    {
        istr->read(v.str);
        istr->read(v.f);
    }
};

template<typename S>
struct StreamWriter< ::Test::SimpleClass3, S>
{
    static void write(S* ostr, const ::Test::SimpleClass3& v)
    {
        ostr->write(v.str);
        ostr->write(v.f);
    }
};

template<typename S>
struct StreamReader< ::Test::SimpleClass3, S>
{
    static void read(S* istr, ::Test::SimpleClass3& v)
    {
        istr->read(v.str);
        istr->read(v.f);
    }
};

template<typename S>
struct StreamWriter< ::Test::SimpleClass4, S>
{
    static void write(S* ostr, const ::Test::SimpleClass4& v)
    {
        ostr->write(v.str);
        ostr->write(v.f);
    }
};

template<typename S>
struct StreamReader< ::Test::SimpleClass4, S>
{
    static void read(S* istr, ::Test::SimpleClass4& v)
    {
        istr->read(v.str);
        istr->read(v.f);
    }
};

template<typename S>
struct StreamWriter< ::Test::SimpleClass5, S>
{
    static void write(S* ostr, const ::Test::SimpleClass5& v)
    {
        ostr->write(v.str);
        ostr->write(v.f);
    }
};

template<typename S>
struct StreamReader< ::Test::SimpleClass5, S>
{
    static void read(S* istr, ::Test::SimpleClass5& v)
    {
        istr->read(v.str);
        istr->read(v.f);
    }
};

template<typename S>
struct StreamWriter< ::Test::SimpleClass6, S>
{
    static void write(S* ostr, const ::Test::SimpleClass6& v)
    {
        ostr->write(v.str);
        ostr->write(v.f);
    }
};

template<typename S>
struct StreamReader< ::Test::SimpleClass6, S>
{
    static void read(S* istr, ::Test::SimpleClass6& v)
    {
        istr->read(v.str);
        istr->read(v.f);
    }
};

template<typename S>
struct StreamWriter< ::Test::SimpleClass7, S>
{
    static void write(S* ostr, const ::Test::SimpleClass7& v)
    {
        ostr->write(v.str);
        ostr->write(v.f);
    }
};

template<typename S>
struct StreamReader< ::Test::SimpleClass7, S>
{
    static void read(S* istr, ::Test::SimpleClass7& v)
    {
        istr->read(v.str);
        istr->read(v.f);
    }
};

template<>
struct StreamableTraits< ::Test::Exception1>
{
    static const StreamHelperCategory helper = StreamHelperCategoryUserException;
};

template<typename S>
struct StreamWriter< ::Test::Exception1, S>
{
    static void write(S* ostr, const ::Test::Exception1& v)
    {
        ostr->write(v.str);
        ostr->write(v.b);
    }
};

template<typename S>
struct StreamReader< ::Test::Exception1, S>
{
    static void read(S* istr, ::Test::Exception1& v)
    {
        istr->read(v.str);
        istr->read(v.b);
    }
};

template<>
struct StreamableTraits< ::Test::Exception2>
{
    static const StreamHelperCategory helper = StreamHelperCategoryUserException;
};

template<typename S>
struct StreamWriter< ::Test::Exception2, S>
{
    static void write(S* ostr, const ::Test::Exception2& v)
    {
        ostr->write(v.str);
        ostr->write(v.b);
    }
};

template<typename S>
struct StreamReader< ::Test::Exception2, S>
{
    static void read(S* istr, ::Test::Exception2& v)
    {
        istr->read(v.str);
        istr->read(v.b);
    }
};

template<>
struct StreamableTraits< ::Test::Exception3>
{
    static const StreamHelperCategory helper = StreamHelperCategoryUserException;
};

template<typename S>
struct StreamWriter< ::Test::Exception3, S>
{
    static void write(S* ostr, const ::Test::Exception3& v)
    {
        ostr->write(v.str);
        ostr->write(v.b);
    }
};

template<typename S>
struct StreamReader< ::Test::Exception3, S>
{
    static void read(S* istr, ::Test::Exception3& v)
    {
        istr->read(v.str);
        istr->read(v.b);
    }
};

template<>
struct StreamableTraits< ::Test::Exception4>
{
    static const StreamHelperCategory helper = StreamHelperCategoryUserException;
};

template<typename S>
struct StreamWriter< ::Test::Exception4, S>
{
    static void write(S* ostr, const ::Test::Exception4& v)
    {
        ostr->write(v.str);
        ostr->write(v.b);
    }
};

template<typename S>
struct StreamReader< ::Test::Exception4, S>
{
    static void read(S* istr, ::Test::Exception4& v)
    {
        istr->read(v.str);
        istr->read(v.b);
    }
};

template<>
struct StreamableTraits< ::Test::Exception5>
{
    static const StreamHelperCategory helper = StreamHelperCategoryUserException;
};

template<>
struct StreamableTraits< ::Test::Exception6>
{
    static const StreamHelperCategory helper = StreamHelperCategoryUserException;
};

template<typename S>
struct StreamWriter< ::Test::Exception6, S>
{
    static void write(S* ostr, const ::Test::Exception6& v)
    {
        ostr->write(v.str);
        ostr->write(v.b);
    }
};

template<typename S>
struct StreamReader< ::Test::Exception6, S>
{
    static void read(S* istr, ::Test::Exception6& v)
    {
        istr->read(v.str);
        istr->read(v.b);
    }
};

template<>
struct StreamableTraits< ::Test::OptionalEx0>
{
    static const StreamHelperCategory helper = StreamHelperCategoryUserException;
};

template<typename S>
struct StreamWriter< ::Test::OptionalEx0, S>
{
    static void write(S* ostr, const ::Test::OptionalEx0& v)
    {
        ostr->write(v.firstName);
        ostr->write(1, v.secondName);
        ostr->write(2, v.emailAddress);
    }
};

template<typename S>
struct StreamReader< ::Test::OptionalEx0, S>
{
    static void read(S* istr, ::Test::OptionalEx0& v)
    {
        istr->read(v.firstName);
        istr->read(1, v.secondName);
        istr->read(2, v.emailAddress);
    }
};

template<>
struct StreamableTraits< ::Test::OptionalEx1>
{
    static const StreamHelperCategory helper = StreamHelperCategoryUserException;
};

template<typename S>
struct StreamWriter< ::Test::OptionalEx1, S>
{
    static void write(S* ostr, const ::Test::OptionalEx1& v)
    {
        ostr->write(v.firstName);
        ostr->write(1, v.secondName);
        ostr->write(2, v.emailAddress);
    }
};

template<typename S>
struct StreamReader< ::Test::OptionalEx1, S>
{
    static void read(S* istr, ::Test::OptionalEx1& v)
    {
        istr->read(v.firstName);
        istr->read(1, v.secondName);
        istr->read(2, v.emailAddress);
    }
};

template<>
struct StreamableTraits< ::Test::OptionalEx2>
{
    static const StreamHelperCategory helper = StreamHelperCategoryUserException;
};

template<typename S>
struct StreamWriter< ::Test::OptionalEx2, S>
{
    static void write(S* ostr, const ::Test::OptionalEx2& v)
    {
        ostr->write(v.firstName);
        ostr->write(v.secondName);
        ostr->write(1, v.emailAddress);
    }
};

template<typename S>
struct StreamReader< ::Test::OptionalEx2, S>
{
    static void read(S* istr, ::Test::OptionalEx2& v)
    {
        istr->read(v.firstName);
        istr->read(v.secondName);
        istr->read(1, v.emailAddress);
    }
};

template<>
struct StreamableTraits< ::Test::OptionalEx3>
{
    static const StreamHelperCategory helper = StreamHelperCategoryUserException;
};

template<typename S>
struct StreamWriter< ::Test::OptionalEx3, S>
{
    static void write(S* ostr, const ::Test::OptionalEx3& v)
    {
        ostr->write(v.firstName);
        ostr->write(1, v.secondName);
        ostr->write(2, v.emailAddress);
    }
};

template<typename S>
struct StreamReader< ::Test::OptionalEx3, S>
{
    static void read(S* istr, ::Test::OptionalEx3& v)
    {
        istr->read(v.firstName);
        istr->read(1, v.secondName);
        istr->read(2, v.emailAddress);
    }
};

template<>
struct StreamableTraits< ::Test::OptionalEx4>
{
    static const StreamHelperCategory helper = StreamHelperCategoryUserException;
};

template<typename S>
struct StreamWriter< ::Test::OptionalEx4, S>
{
    static void write(S* ostr, const ::Test::OptionalEx4& v)
    {
        ostr->write(v.firstName);
        ostr->write(1, v.secondName);
        ostr->write(2, v.emailAddress);
    }
};

template<typename S>
struct StreamReader< ::Test::OptionalEx4, S>
{
    static void read(S* istr, ::Test::OptionalEx4& v)
    {
        istr->read(v.firstName);
        istr->read(1, v.secondName);
        istr->read(2, v.emailAddress);
    }
};

template<typename S>
struct StreamWriter< ::Test::Compact1, S>
{
    static void write(S* ostr, const ::Test::Compact1& v)
    {
        ostr->write(v.id);
    }
};

template<typename S>
struct StreamReader< ::Test::Compact1, S>
{
    static void read(S* istr, ::Test::Compact1& v)
    {
        istr->read(v.id);
    }
};

template<typename S>
struct StreamWriter< ::Test::Compact2, S>
{
    static void write(S* ostr, const ::Test::Compact2& v)
    {
        ostr->write(v.id);
    }
};

template<typename S>
struct StreamReader< ::Test::Compact2, S>
{
    static void read(S* istr, ::Test::Compact2& v)
    {
        istr->read(v.id);
    }
};

template<typename S>
struct StreamWriter< ::Test::Optional0, S>
{
    static void write(S* ostr, const ::Test::Optional0& v)
    {
        ostr->write(v.firstName);
        ostr->write(1, v.secondName);
        ostr->write(2, v.emailAddress);
    }
};

template<typename S>
struct StreamReader< ::Test::Optional0, S>
{
    static void read(S* istr, ::Test::Optional0& v)
    {
        istr->read(v.firstName);
        istr->read(1, v.secondName);
        istr->read(2, v.emailAddress);
    }
};

template<typename S>
struct StreamWriter< ::Test::Optional1, S>
{
    static void write(S* ostr, const ::Test::Optional1& v)
    {
        ostr->write(v.firstName);
        ostr->write(1, v.secondName);
        ostr->write(2, v.emailAddress);
    }
};

template<typename S>
struct StreamReader< ::Test::Optional1, S>
{
    static void read(S* istr, ::Test::Optional1& v)
    {
        istr->read(v.firstName);
        istr->read(1, v.secondName);
        istr->read(2, v.emailAddress);
    }
};

template<typename S>
struct StreamWriter< ::Test::Optional2, S>
{
    static void write(S* ostr, const ::Test::Optional2& v)
    {
        ostr->write(v.firstName);
        ostr->write(v.secondName);
        ostr->write(1, v.emailAddress);
    }
};

template<typename S>
struct StreamReader< ::Test::Optional2, S>
{
    static void read(S* istr, ::Test::Optional2& v)
    {
        istr->read(v.firstName);
        istr->read(v.secondName);
        istr->read(1, v.emailAddress);
    }
};

template<typename S>
struct StreamWriter< ::Test::Optional3, S>
{
    static void write(S* ostr, const ::Test::Optional3& v)
    {
        ostr->write(v.firstName);
        ostr->write(1, v.secondName);
        ostr->write(2, v.emailAddress);
    }
};

template<typename S>
struct StreamReader< ::Test::Optional3, S>
{
    static void read(S* istr, ::Test::Optional3& v)
    {
        istr->read(v.firstName);
        istr->read(1, v.secondName);
        istr->read(2, v.emailAddress);
    }
};

template<typename S>
struct StreamWriter< ::Test::Optional4, S>
{
    static void write(S* ostr, const ::Test::Optional4& v)
    {
        ostr->write(v.firstName);
        ostr->write(1, v.secondName);
        ostr->write(2, v.emailAddress);
    }
};

template<typename S>
struct StreamReader< ::Test::Optional4, S>
{
    static void read(S* istr, ::Test::Optional4& v)
    {
        istr->read(v.firstName);
        istr->read(1, v.secondName);
        istr->read(2, v.emailAddress);
    }
};

}
/// \endcond

namespace Test
{

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::BaseInterface1::begin_baseOp1.
 * Create a wrapper instance by calling ::Test::newCallback_BaseInterface1_baseOp1.
 */
template<class T>
class CallbackNC_BaseInterface1_baseOp1 : public Callback_BaseInterface1_baseOp1_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_BaseInterface1_baseOp1(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface1::begin_baseOp1.
 */
template<class T> Callback_BaseInterface1_baseOp1Ptr
newCallback_BaseInterface1_baseOp1(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseInterface1_baseOp1<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface1::begin_baseOp1.
 */
template<class T> Callback_BaseInterface1_baseOp1Ptr
newCallback_BaseInterface1_baseOp1(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseInterface1_baseOp1<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface1::begin_baseOp1.
 */
template<class T> Callback_BaseInterface1_baseOp1Ptr
newCallback_BaseInterface1_baseOp1(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseInterface1_baseOp1<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface1::begin_baseOp1.
 */
template<class T> Callback_BaseInterface1_baseOp1Ptr
newCallback_BaseInterface1_baseOp1(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseInterface1_baseOp1<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::BaseInterface1::begin_baseOp1.
 * Create a wrapper instance by calling ::Test::newCallback_BaseInterface1_baseOp1.
 */
template<class T, typename CT>
class Callback_BaseInterface1_baseOp1 : public Callback_BaseInterface1_baseOp1_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_BaseInterface1_baseOp1(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface1::begin_baseOp1.
 */
template<class T, typename CT> Callback_BaseInterface1_baseOp1Ptr
newCallback_BaseInterface1_baseOp1(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseInterface1_baseOp1<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface1::begin_baseOp1.
 */
template<class T, typename CT> Callback_BaseInterface1_baseOp1Ptr
newCallback_BaseInterface1_baseOp1(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseInterface1_baseOp1<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface1::begin_baseOp1.
 */
template<class T, typename CT> Callback_BaseInterface1_baseOp1Ptr
newCallback_BaseInterface1_baseOp1(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseInterface1_baseOp1<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface1::begin_baseOp1.
 */
template<class T, typename CT> Callback_BaseInterface1_baseOp1Ptr
newCallback_BaseInterface1_baseOp1(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseInterface1_baseOp1<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::BaseInterface1::begin_baseOp2.
 * Create a wrapper instance by calling ::Test::newCallback_BaseInterface1_baseOp2.
 */
template<class T>
class CallbackNC_BaseInterface1_baseOp2 : public Callback_BaseInterface1_baseOp2_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_BaseInterface1_baseOp2(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        BaseInterface1Prx proxy = BaseInterface1Prx::uncheckedCast(result->getProxy());
        ::std::string iceP_s;
        try
        {
            proxy->end_baseOp2(iceP_s, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(iceP_s);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface1::begin_baseOp2.
 */
template<class T> Callback_BaseInterface1_baseOp2Ptr
newCallback_BaseInterface1_baseOp2(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseInterface1_baseOp2<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface1::begin_baseOp2.
 */
template<class T> Callback_BaseInterface1_baseOp2Ptr
newCallback_BaseInterface1_baseOp2(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseInterface1_baseOp2<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::BaseInterface1::begin_baseOp2.
 * Create a wrapper instance by calling ::Test::newCallback_BaseInterface1_baseOp2.
 */
template<class T, typename CT>
class Callback_BaseInterface1_baseOp2 : public Callback_BaseInterface1_baseOp2_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_BaseInterface1_baseOp2(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        BaseInterface1Prx proxy = BaseInterface1Prx::uncheckedCast(result->getProxy());
        ::std::string iceP_s;
        try
        {
            proxy->end_baseOp2(iceP_s, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(iceP_s, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface1::begin_baseOp2.
 */
template<class T, typename CT> Callback_BaseInterface1_baseOp2Ptr
newCallback_BaseInterface1_baseOp2(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseInterface1_baseOp2<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface1::begin_baseOp2.
 */
template<class T, typename CT> Callback_BaseInterface1_baseOp2Ptr
newCallback_BaseInterface1_baseOp2(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseInterface1_baseOp2<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::BaseInterface2::begin_baseOp.
 * Create a wrapper instance by calling ::Test::newCallback_BaseInterface2_baseOp.
 */
template<class T>
class CallbackNC_BaseInterface2_baseOp : public Callback_BaseInterface2_baseOp_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_BaseInterface2_baseOp(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface2::begin_baseOp.
 */
template<class T> Callback_BaseInterface2_baseOpPtr
newCallback_BaseInterface2_baseOp(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseInterface2_baseOp<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface2::begin_baseOp.
 */
template<class T> Callback_BaseInterface2_baseOpPtr
newCallback_BaseInterface2_baseOp(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseInterface2_baseOp<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface2::begin_baseOp.
 */
template<class T> Callback_BaseInterface2_baseOpPtr
newCallback_BaseInterface2_baseOp(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseInterface2_baseOp<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface2::begin_baseOp.
 */
template<class T> Callback_BaseInterface2_baseOpPtr
newCallback_BaseInterface2_baseOp(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseInterface2_baseOp<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::BaseInterface2::begin_baseOp.
 * Create a wrapper instance by calling ::Test::newCallback_BaseInterface2_baseOp.
 */
template<class T, typename CT>
class Callback_BaseInterface2_baseOp : public Callback_BaseInterface2_baseOp_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_BaseInterface2_baseOp(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface2::begin_baseOp.
 */
template<class T, typename CT> Callback_BaseInterface2_baseOpPtr
newCallback_BaseInterface2_baseOp(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseInterface2_baseOp<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface2::begin_baseOp.
 */
template<class T, typename CT> Callback_BaseInterface2_baseOpPtr
newCallback_BaseInterface2_baseOp(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseInterface2_baseOp<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface2::begin_baseOp.
 */
template<class T, typename CT> Callback_BaseInterface2_baseOpPtr
newCallback_BaseInterface2_baseOp(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseInterface2_baseOp<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface2::begin_baseOp.
 */
template<class T, typename CT> Callback_BaseInterface2_baseOpPtr
newCallback_BaseInterface2_baseOp(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseInterface2_baseOp<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::BaseInterface2::begin_baseOp2.
 * Create a wrapper instance by calling ::Test::newCallback_BaseInterface2_baseOp2.
 */
template<class T>
class CallbackNC_BaseInterface2_baseOp2 : public Callback_BaseInterface2_baseOp2_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_BaseInterface2_baseOp2(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        BaseInterface2Prx proxy = BaseInterface2Prx::uncheckedCast(result->getProxy());
        ::std::string iceP_s;
        try
        {
            proxy->end_baseOp2(iceP_s, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(iceP_s);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface2::begin_baseOp2.
 */
template<class T> Callback_BaseInterface2_baseOp2Ptr
newCallback_BaseInterface2_baseOp2(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseInterface2_baseOp2<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface2::begin_baseOp2.
 */
template<class T> Callback_BaseInterface2_baseOp2Ptr
newCallback_BaseInterface2_baseOp2(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseInterface2_baseOp2<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::BaseInterface2::begin_baseOp2.
 * Create a wrapper instance by calling ::Test::newCallback_BaseInterface2_baseOp2.
 */
template<class T, typename CT>
class Callback_BaseInterface2_baseOp2 : public Callback_BaseInterface2_baseOp2_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_BaseInterface2_baseOp2(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        BaseInterface2Prx proxy = BaseInterface2Prx::uncheckedCast(result->getProxy());
        ::std::string iceP_s;
        try
        {
            proxy->end_baseOp2(iceP_s, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(iceP_s, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface2::begin_baseOp2.
 */
template<class T, typename CT> Callback_BaseInterface2_baseOp2Ptr
newCallback_BaseInterface2_baseOp2(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseInterface2_baseOp2<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface2::begin_baseOp2.
 */
template<class T, typename CT> Callback_BaseInterface2_baseOp2Ptr
newCallback_BaseInterface2_baseOp2(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseInterface2_baseOp2<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::BaseInterface3::begin_baseOp.
 * Create a wrapper instance by calling ::Test::newCallback_BaseInterface3_baseOp.
 */
template<class T>
class CallbackNC_BaseInterface3_baseOp : public Callback_BaseInterface3_baseOp_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_BaseInterface3_baseOp(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface3::begin_baseOp.
 */
template<class T> Callback_BaseInterface3_baseOpPtr
newCallback_BaseInterface3_baseOp(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseInterface3_baseOp<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface3::begin_baseOp.
 */
template<class T> Callback_BaseInterface3_baseOpPtr
newCallback_BaseInterface3_baseOp(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseInterface3_baseOp<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface3::begin_baseOp.
 */
template<class T> Callback_BaseInterface3_baseOpPtr
newCallback_BaseInterface3_baseOp(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseInterface3_baseOp<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface3::begin_baseOp.
 */
template<class T> Callback_BaseInterface3_baseOpPtr
newCallback_BaseInterface3_baseOp(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseInterface3_baseOp<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::BaseInterface3::begin_baseOp.
 * Create a wrapper instance by calling ::Test::newCallback_BaseInterface3_baseOp.
 */
template<class T, typename CT>
class Callback_BaseInterface3_baseOp : public Callback_BaseInterface3_baseOp_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_BaseInterface3_baseOp(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface3::begin_baseOp.
 */
template<class T, typename CT> Callback_BaseInterface3_baseOpPtr
newCallback_BaseInterface3_baseOp(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseInterface3_baseOp<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface3::begin_baseOp.
 */
template<class T, typename CT> Callback_BaseInterface3_baseOpPtr
newCallback_BaseInterface3_baseOp(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseInterface3_baseOp<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface3::begin_baseOp.
 */
template<class T, typename CT> Callback_BaseInterface3_baseOpPtr
newCallback_BaseInterface3_baseOp(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseInterface3_baseOp<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface3::begin_baseOp.
 */
template<class T, typename CT> Callback_BaseInterface3_baseOpPtr
newCallback_BaseInterface3_baseOp(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseInterface3_baseOp<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::BaseInterface3::begin_baseOp2.
 * Create a wrapper instance by calling ::Test::newCallback_BaseInterface3_baseOp2.
 */
template<class T>
class CallbackNC_BaseInterface3_baseOp2 : public Callback_BaseInterface3_baseOp2_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_BaseInterface3_baseOp2(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        BaseInterface3Prx proxy = BaseInterface3Prx::uncheckedCast(result->getProxy());
        ::std::string iceP_s;
        try
        {
            proxy->end_baseOp2(iceP_s, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(iceP_s);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface3::begin_baseOp2.
 */
template<class T> Callback_BaseInterface3_baseOp2Ptr
newCallback_BaseInterface3_baseOp2(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseInterface3_baseOp2<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface3::begin_baseOp2.
 */
template<class T> Callback_BaseInterface3_baseOp2Ptr
newCallback_BaseInterface3_baseOp2(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseInterface3_baseOp2<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::BaseInterface3::begin_baseOp2.
 * Create a wrapper instance by calling ::Test::newCallback_BaseInterface3_baseOp2.
 */
template<class T, typename CT>
class Callback_BaseInterface3_baseOp2 : public Callback_BaseInterface3_baseOp2_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_BaseInterface3_baseOp2(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        BaseInterface3Prx proxy = BaseInterface3Prx::uncheckedCast(result->getProxy());
        ::std::string iceP_s;
        try
        {
            proxy->end_baseOp2(iceP_s, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(iceP_s, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface3::begin_baseOp2.
 */
template<class T, typename CT> Callback_BaseInterface3_baseOp2Ptr
newCallback_BaseInterface3_baseOp2(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseInterface3_baseOp2<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface3::begin_baseOp2.
 */
template<class T, typename CT> Callback_BaseInterface3_baseOp2Ptr
newCallback_BaseInterface3_baseOp2(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseInterface3_baseOp2<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::BaseInterface4::begin_baseOp.
 * Create a wrapper instance by calling ::Test::newCallback_BaseInterface4_baseOp.
 */
template<class T>
class CallbackNC_BaseInterface4_baseOp : public Callback_BaseInterface4_baseOp_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_BaseInterface4_baseOp(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface4::begin_baseOp.
 */
template<class T> Callback_BaseInterface4_baseOpPtr
newCallback_BaseInterface4_baseOp(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseInterface4_baseOp<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface4::begin_baseOp.
 */
template<class T> Callback_BaseInterface4_baseOpPtr
newCallback_BaseInterface4_baseOp(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseInterface4_baseOp<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface4::begin_baseOp.
 */
template<class T> Callback_BaseInterface4_baseOpPtr
newCallback_BaseInterface4_baseOp(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseInterface4_baseOp<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface4::begin_baseOp.
 */
template<class T> Callback_BaseInterface4_baseOpPtr
newCallback_BaseInterface4_baseOp(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseInterface4_baseOp<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::BaseInterface4::begin_baseOp.
 * Create a wrapper instance by calling ::Test::newCallback_BaseInterface4_baseOp.
 */
template<class T, typename CT>
class Callback_BaseInterface4_baseOp : public Callback_BaseInterface4_baseOp_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_BaseInterface4_baseOp(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface4::begin_baseOp.
 */
template<class T, typename CT> Callback_BaseInterface4_baseOpPtr
newCallback_BaseInterface4_baseOp(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseInterface4_baseOp<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface4::begin_baseOp.
 */
template<class T, typename CT> Callback_BaseInterface4_baseOpPtr
newCallback_BaseInterface4_baseOp(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseInterface4_baseOp<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface4::begin_baseOp.
 */
template<class T, typename CT> Callback_BaseInterface4_baseOpPtr
newCallback_BaseInterface4_baseOp(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseInterface4_baseOp<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface4::begin_baseOp.
 */
template<class T, typename CT> Callback_BaseInterface4_baseOpPtr
newCallback_BaseInterface4_baseOp(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseInterface4_baseOp<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::BaseInterface4::begin_baseOp2.
 * Create a wrapper instance by calling ::Test::newCallback_BaseInterface4_baseOp2.
 */
template<class T>
class CallbackNC_BaseInterface4_baseOp2 : public Callback_BaseInterface4_baseOp2_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_BaseInterface4_baseOp2(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        BaseInterface4Prx proxy = BaseInterface4Prx::uncheckedCast(result->getProxy());
        ::std::string iceP_s;
        try
        {
            proxy->end_baseOp2(iceP_s, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(iceP_s);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface4::begin_baseOp2.
 */
template<class T> Callback_BaseInterface4_baseOp2Ptr
newCallback_BaseInterface4_baseOp2(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseInterface4_baseOp2<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface4::begin_baseOp2.
 */
template<class T> Callback_BaseInterface4_baseOp2Ptr
newCallback_BaseInterface4_baseOp2(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseInterface4_baseOp2<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::BaseInterface4::begin_baseOp2.
 * Create a wrapper instance by calling ::Test::newCallback_BaseInterface4_baseOp2.
 */
template<class T, typename CT>
class Callback_BaseInterface4_baseOp2 : public Callback_BaseInterface4_baseOp2_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_BaseInterface4_baseOp2(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        BaseInterface4Prx proxy = BaseInterface4Prx::uncheckedCast(result->getProxy());
        ::std::string iceP_s;
        try
        {
            proxy->end_baseOp2(iceP_s, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(iceP_s, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface4::begin_baseOp2.
 */
template<class T, typename CT> Callback_BaseInterface4_baseOp2Ptr
newCallback_BaseInterface4_baseOp2(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseInterface4_baseOp2<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface4::begin_baseOp2.
 */
template<class T, typename CT> Callback_BaseInterface4_baseOp2Ptr
newCallback_BaseInterface4_baseOp2(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseInterface4_baseOp2<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::BaseInterface5::begin_baseOp.
 * Create a wrapper instance by calling ::Test::newCallback_BaseInterface5_baseOp.
 */
template<class T>
class CallbackNC_BaseInterface5_baseOp : public Callback_BaseInterface5_baseOp_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_BaseInterface5_baseOp(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface5::begin_baseOp.
 */
template<class T> Callback_BaseInterface5_baseOpPtr
newCallback_BaseInterface5_baseOp(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseInterface5_baseOp<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface5::begin_baseOp.
 */
template<class T> Callback_BaseInterface5_baseOpPtr
newCallback_BaseInterface5_baseOp(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseInterface5_baseOp<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface5::begin_baseOp.
 */
template<class T> Callback_BaseInterface5_baseOpPtr
newCallback_BaseInterface5_baseOp(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseInterface5_baseOp<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface5::begin_baseOp.
 */
template<class T> Callback_BaseInterface5_baseOpPtr
newCallback_BaseInterface5_baseOp(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseInterface5_baseOp<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::BaseInterface5::begin_baseOp.
 * Create a wrapper instance by calling ::Test::newCallback_BaseInterface5_baseOp.
 */
template<class T, typename CT>
class Callback_BaseInterface5_baseOp : public Callback_BaseInterface5_baseOp_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_BaseInterface5_baseOp(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface5::begin_baseOp.
 */
template<class T, typename CT> Callback_BaseInterface5_baseOpPtr
newCallback_BaseInterface5_baseOp(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseInterface5_baseOp<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface5::begin_baseOp.
 */
template<class T, typename CT> Callback_BaseInterface5_baseOpPtr
newCallback_BaseInterface5_baseOp(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseInterface5_baseOp<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface5::begin_baseOp.
 */
template<class T, typename CT> Callback_BaseInterface5_baseOpPtr
newCallback_BaseInterface5_baseOp(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseInterface5_baseOp<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface5::begin_baseOp.
 */
template<class T, typename CT> Callback_BaseInterface5_baseOpPtr
newCallback_BaseInterface5_baseOp(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseInterface5_baseOp<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::BaseInterface5::begin_baseOp2.
 * Create a wrapper instance by calling ::Test::newCallback_BaseInterface5_baseOp2.
 */
template<class T>
class CallbackNC_BaseInterface5_baseOp2 : public Callback_BaseInterface5_baseOp2_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_BaseInterface5_baseOp2(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        BaseInterface5Prx proxy = BaseInterface5Prx::uncheckedCast(result->getProxy());
        ::std::string iceP_s;
        try
        {
            proxy->end_baseOp2(iceP_s, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(iceP_s);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface5::begin_baseOp2.
 */
template<class T> Callback_BaseInterface5_baseOp2Ptr
newCallback_BaseInterface5_baseOp2(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseInterface5_baseOp2<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface5::begin_baseOp2.
 */
template<class T> Callback_BaseInterface5_baseOp2Ptr
newCallback_BaseInterface5_baseOp2(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseInterface5_baseOp2<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::BaseInterface5::begin_baseOp2.
 * Create a wrapper instance by calling ::Test::newCallback_BaseInterface5_baseOp2.
 */
template<class T, typename CT>
class Callback_BaseInterface5_baseOp2 : public Callback_BaseInterface5_baseOp2_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_BaseInterface5_baseOp2(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        BaseInterface5Prx proxy = BaseInterface5Prx::uncheckedCast(result->getProxy());
        ::std::string iceP_s;
        try
        {
            proxy->end_baseOp2(iceP_s, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(iceP_s, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface5::begin_baseOp2.
 */
template<class T, typename CT> Callback_BaseInterface5_baseOp2Ptr
newCallback_BaseInterface5_baseOp2(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseInterface5_baseOp2<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface5::begin_baseOp2.
 */
template<class T, typename CT> Callback_BaseInterface5_baseOp2Ptr
newCallback_BaseInterface5_baseOp2(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseInterface5_baseOp2<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::BaseInterface6::begin_baseOp.
 * Create a wrapper instance by calling ::Test::newCallback_BaseInterface6_baseOp.
 */
template<class T>
class CallbackNC_BaseInterface6_baseOp : public Callback_BaseInterface6_baseOp_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_BaseInterface6_baseOp(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface6::begin_baseOp.
 */
template<class T> Callback_BaseInterface6_baseOpPtr
newCallback_BaseInterface6_baseOp(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseInterface6_baseOp<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface6::begin_baseOp.
 */
template<class T> Callback_BaseInterface6_baseOpPtr
newCallback_BaseInterface6_baseOp(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseInterface6_baseOp<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface6::begin_baseOp.
 */
template<class T> Callback_BaseInterface6_baseOpPtr
newCallback_BaseInterface6_baseOp(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseInterface6_baseOp<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface6::begin_baseOp.
 */
template<class T> Callback_BaseInterface6_baseOpPtr
newCallback_BaseInterface6_baseOp(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseInterface6_baseOp<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::BaseInterface6::begin_baseOp.
 * Create a wrapper instance by calling ::Test::newCallback_BaseInterface6_baseOp.
 */
template<class T, typename CT>
class Callback_BaseInterface6_baseOp : public Callback_BaseInterface6_baseOp_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_BaseInterface6_baseOp(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface6::begin_baseOp.
 */
template<class T, typename CT> Callback_BaseInterface6_baseOpPtr
newCallback_BaseInterface6_baseOp(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseInterface6_baseOp<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface6::begin_baseOp.
 */
template<class T, typename CT> Callback_BaseInterface6_baseOpPtr
newCallback_BaseInterface6_baseOp(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseInterface6_baseOp<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface6::begin_baseOp.
 */
template<class T, typename CT> Callback_BaseInterface6_baseOpPtr
newCallback_BaseInterface6_baseOp(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseInterface6_baseOp<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface6::begin_baseOp.
 */
template<class T, typename CT> Callback_BaseInterface6_baseOpPtr
newCallback_BaseInterface6_baseOp(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseInterface6_baseOp<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::BaseInterface6::begin_baseOp2.
 * Create a wrapper instance by calling ::Test::newCallback_BaseInterface6_baseOp2.
 */
template<class T>
class CallbackNC_BaseInterface6_baseOp2 : public Callback_BaseInterface6_baseOp2_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_BaseInterface6_baseOp2(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        BaseInterface6Prx proxy = BaseInterface6Prx::uncheckedCast(result->getProxy());
        ::std::string iceP_s;
        try
        {
            proxy->end_baseOp2(iceP_s, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(iceP_s);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface6::begin_baseOp2.
 */
template<class T> Callback_BaseInterface6_baseOp2Ptr
newCallback_BaseInterface6_baseOp2(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseInterface6_baseOp2<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface6::begin_baseOp2.
 */
template<class T> Callback_BaseInterface6_baseOp2Ptr
newCallback_BaseInterface6_baseOp2(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseInterface6_baseOp2<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::BaseInterface6::begin_baseOp2.
 * Create a wrapper instance by calling ::Test::newCallback_BaseInterface6_baseOp2.
 */
template<class T, typename CT>
class Callback_BaseInterface6_baseOp2 : public Callback_BaseInterface6_baseOp2_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_BaseInterface6_baseOp2(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        BaseInterface6Prx proxy = BaseInterface6Prx::uncheckedCast(result->getProxy());
        ::std::string iceP_s;
        try
        {
            proxy->end_baseOp2(iceP_s, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(iceP_s, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface6::begin_baseOp2.
 */
template<class T, typename CT> Callback_BaseInterface6_baseOp2Ptr
newCallback_BaseInterface6_baseOp2(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseInterface6_baseOp2<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface6::begin_baseOp2.
 */
template<class T, typename CT> Callback_BaseInterface6_baseOp2Ptr
newCallback_BaseInterface6_baseOp2(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseInterface6_baseOp2<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::BaseInterface7::begin_baseOp.
 * Create a wrapper instance by calling ::Test::newCallback_BaseInterface7_baseOp.
 */
template<class T>
class CallbackNC_BaseInterface7_baseOp : public Callback_BaseInterface7_baseOp_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_BaseInterface7_baseOp(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface7::begin_baseOp.
 */
template<class T> Callback_BaseInterface7_baseOpPtr
newCallback_BaseInterface7_baseOp(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseInterface7_baseOp<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface7::begin_baseOp.
 */
template<class T> Callback_BaseInterface7_baseOpPtr
newCallback_BaseInterface7_baseOp(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseInterface7_baseOp<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface7::begin_baseOp.
 */
template<class T> Callback_BaseInterface7_baseOpPtr
newCallback_BaseInterface7_baseOp(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseInterface7_baseOp<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface7::begin_baseOp.
 */
template<class T> Callback_BaseInterface7_baseOpPtr
newCallback_BaseInterface7_baseOp(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseInterface7_baseOp<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::BaseInterface7::begin_baseOp.
 * Create a wrapper instance by calling ::Test::newCallback_BaseInterface7_baseOp.
 */
template<class T, typename CT>
class Callback_BaseInterface7_baseOp : public Callback_BaseInterface7_baseOp_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_BaseInterface7_baseOp(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface7::begin_baseOp.
 */
template<class T, typename CT> Callback_BaseInterface7_baseOpPtr
newCallback_BaseInterface7_baseOp(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseInterface7_baseOp<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface7::begin_baseOp.
 */
template<class T, typename CT> Callback_BaseInterface7_baseOpPtr
newCallback_BaseInterface7_baseOp(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseInterface7_baseOp<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface7::begin_baseOp.
 */
template<class T, typename CT> Callback_BaseInterface7_baseOpPtr
newCallback_BaseInterface7_baseOp(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseInterface7_baseOp<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface7::begin_baseOp.
 */
template<class T, typename CT> Callback_BaseInterface7_baseOpPtr
newCallback_BaseInterface7_baseOp(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseInterface7_baseOp<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::BaseInterface7::begin_baseOp2.
 * Create a wrapper instance by calling ::Test::newCallback_BaseInterface7_baseOp2.
 */
template<class T>
class CallbackNC_BaseInterface7_baseOp2 : public Callback_BaseInterface7_baseOp2_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_BaseInterface7_baseOp2(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        BaseInterface7Prx proxy = BaseInterface7Prx::uncheckedCast(result->getProxy());
        ::std::string iceP_s;
        try
        {
            proxy->end_baseOp2(iceP_s, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(iceP_s);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface7::begin_baseOp2.
 */
template<class T> Callback_BaseInterface7_baseOp2Ptr
newCallback_BaseInterface7_baseOp2(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseInterface7_baseOp2<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface7::begin_baseOp2.
 */
template<class T> Callback_BaseInterface7_baseOp2Ptr
newCallback_BaseInterface7_baseOp2(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseInterface7_baseOp2<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::BaseInterface7::begin_baseOp2.
 * Create a wrapper instance by calling ::Test::newCallback_BaseInterface7_baseOp2.
 */
template<class T, typename CT>
class Callback_BaseInterface7_baseOp2 : public Callback_BaseInterface7_baseOp2_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_BaseInterface7_baseOp2(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        BaseInterface7Prx proxy = BaseInterface7Prx::uncheckedCast(result->getProxy());
        ::std::string iceP_s;
        try
        {
            proxy->end_baseOp2(iceP_s, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(iceP_s, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface7::begin_baseOp2.
 */
template<class T, typename CT> Callback_BaseInterface7_baseOp2Ptr
newCallback_BaseInterface7_baseOp2(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseInterface7_baseOp2<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface7::begin_baseOp2.
 */
template<class T, typename CT> Callback_BaseInterface7_baseOp2Ptr
newCallback_BaseInterface7_baseOp2(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseInterface7_baseOp2<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::BaseInterface8::begin_baseOp.
 * Create a wrapper instance by calling ::Test::newCallback_BaseInterface8_baseOp.
 */
template<class T>
class CallbackNC_BaseInterface8_baseOp : public Callback_BaseInterface8_baseOp_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_BaseInterface8_baseOp(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface8::begin_baseOp.
 */
template<class T> Callback_BaseInterface8_baseOpPtr
newCallback_BaseInterface8_baseOp(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseInterface8_baseOp<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface8::begin_baseOp.
 */
template<class T> Callback_BaseInterface8_baseOpPtr
newCallback_BaseInterface8_baseOp(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseInterface8_baseOp<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface8::begin_baseOp.
 */
template<class T> Callback_BaseInterface8_baseOpPtr
newCallback_BaseInterface8_baseOp(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseInterface8_baseOp<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface8::begin_baseOp.
 */
template<class T> Callback_BaseInterface8_baseOpPtr
newCallback_BaseInterface8_baseOp(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseInterface8_baseOp<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::BaseInterface8::begin_baseOp.
 * Create a wrapper instance by calling ::Test::newCallback_BaseInterface8_baseOp.
 */
template<class T, typename CT>
class Callback_BaseInterface8_baseOp : public Callback_BaseInterface8_baseOp_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_BaseInterface8_baseOp(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface8::begin_baseOp.
 */
template<class T, typename CT> Callback_BaseInterface8_baseOpPtr
newCallback_BaseInterface8_baseOp(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseInterface8_baseOp<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface8::begin_baseOp.
 */
template<class T, typename CT> Callback_BaseInterface8_baseOpPtr
newCallback_BaseInterface8_baseOp(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseInterface8_baseOp<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface8::begin_baseOp.
 */
template<class T, typename CT> Callback_BaseInterface8_baseOpPtr
newCallback_BaseInterface8_baseOp(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseInterface8_baseOp<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface8::begin_baseOp.
 */
template<class T, typename CT> Callback_BaseInterface8_baseOpPtr
newCallback_BaseInterface8_baseOp(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseInterface8_baseOp<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::BaseInterface8::begin_baseOp2.
 * Create a wrapper instance by calling ::Test::newCallback_BaseInterface8_baseOp2.
 */
template<class T>
class CallbackNC_BaseInterface8_baseOp2 : public Callback_BaseInterface8_baseOp2_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_BaseInterface8_baseOp2(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        BaseInterface8Prx proxy = BaseInterface8Prx::uncheckedCast(result->getProxy());
        ::std::string iceP_s;
        try
        {
            proxy->end_baseOp2(iceP_s, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(iceP_s);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface8::begin_baseOp2.
 */
template<class T> Callback_BaseInterface8_baseOp2Ptr
newCallback_BaseInterface8_baseOp2(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseInterface8_baseOp2<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface8::begin_baseOp2.
 */
template<class T> Callback_BaseInterface8_baseOp2Ptr
newCallback_BaseInterface8_baseOp2(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseInterface8_baseOp2<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::BaseInterface8::begin_baseOp2.
 * Create a wrapper instance by calling ::Test::newCallback_BaseInterface8_baseOp2.
 */
template<class T, typename CT>
class Callback_BaseInterface8_baseOp2 : public Callback_BaseInterface8_baseOp2_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_BaseInterface8_baseOp2(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        BaseInterface8Prx proxy = BaseInterface8Prx::uncheckedCast(result->getProxy());
        ::std::string iceP_s;
        try
        {
            proxy->end_baseOp2(iceP_s, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(iceP_s, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface8::begin_baseOp2.
 */
template<class T, typename CT> Callback_BaseInterface8_baseOp2Ptr
newCallback_BaseInterface8_baseOp2(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseInterface8_baseOp2<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface8::begin_baseOp2.
 */
template<class T, typename CT> Callback_BaseInterface8_baseOp2Ptr
newCallback_BaseInterface8_baseOp2(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseInterface8_baseOp2<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::BaseInterface9::begin_baseOp.
 * Create a wrapper instance by calling ::Test::newCallback_BaseInterface9_baseOp.
 */
template<class T>
class CallbackNC_BaseInterface9_baseOp : public Callback_BaseInterface9_baseOp_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_BaseInterface9_baseOp(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface9::begin_baseOp.
 */
template<class T> Callback_BaseInterface9_baseOpPtr
newCallback_BaseInterface9_baseOp(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseInterface9_baseOp<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface9::begin_baseOp.
 */
template<class T> Callback_BaseInterface9_baseOpPtr
newCallback_BaseInterface9_baseOp(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseInterface9_baseOp<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface9::begin_baseOp.
 */
template<class T> Callback_BaseInterface9_baseOpPtr
newCallback_BaseInterface9_baseOp(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseInterface9_baseOp<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface9::begin_baseOp.
 */
template<class T> Callback_BaseInterface9_baseOpPtr
newCallback_BaseInterface9_baseOp(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseInterface9_baseOp<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::BaseInterface9::begin_baseOp.
 * Create a wrapper instance by calling ::Test::newCallback_BaseInterface9_baseOp.
 */
template<class T, typename CT>
class Callback_BaseInterface9_baseOp : public Callback_BaseInterface9_baseOp_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_BaseInterface9_baseOp(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface9::begin_baseOp.
 */
template<class T, typename CT> Callback_BaseInterface9_baseOpPtr
newCallback_BaseInterface9_baseOp(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseInterface9_baseOp<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface9::begin_baseOp.
 */
template<class T, typename CT> Callback_BaseInterface9_baseOpPtr
newCallback_BaseInterface9_baseOp(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseInterface9_baseOp<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface9::begin_baseOp.
 */
template<class T, typename CT> Callback_BaseInterface9_baseOpPtr
newCallback_BaseInterface9_baseOp(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseInterface9_baseOp<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface9::begin_baseOp.
 */
template<class T, typename CT> Callback_BaseInterface9_baseOpPtr
newCallback_BaseInterface9_baseOp(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseInterface9_baseOp<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::BaseInterface9::begin_baseOp2.
 * Create a wrapper instance by calling ::Test::newCallback_BaseInterface9_baseOp2.
 */
template<class T>
class CallbackNC_BaseInterface9_baseOp2 : public Callback_BaseInterface9_baseOp2_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_BaseInterface9_baseOp2(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        BaseInterface9Prx proxy = BaseInterface9Prx::uncheckedCast(result->getProxy());
        ::std::string iceP_s;
        try
        {
            proxy->end_baseOp2(iceP_s, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(iceP_s);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface9::begin_baseOp2.
 */
template<class T> Callback_BaseInterface9_baseOp2Ptr
newCallback_BaseInterface9_baseOp2(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseInterface9_baseOp2<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface9::begin_baseOp2.
 */
template<class T> Callback_BaseInterface9_baseOp2Ptr
newCallback_BaseInterface9_baseOp2(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseInterface9_baseOp2<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::BaseInterface9::begin_baseOp2.
 * Create a wrapper instance by calling ::Test::newCallback_BaseInterface9_baseOp2.
 */
template<class T, typename CT>
class Callback_BaseInterface9_baseOp2 : public Callback_BaseInterface9_baseOp2_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_BaseInterface9_baseOp2(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        BaseInterface9Prx proxy = BaseInterface9Prx::uncheckedCast(result->getProxy());
        ::std::string iceP_s;
        try
        {
            proxy->end_baseOp2(iceP_s, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(iceP_s, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface9::begin_baseOp2.
 */
template<class T, typename CT> Callback_BaseInterface9_baseOp2Ptr
newCallback_BaseInterface9_baseOp2(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseInterface9_baseOp2<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface9::begin_baseOp2.
 */
template<class T, typename CT> Callback_BaseInterface9_baseOp2Ptr
newCallback_BaseInterface9_baseOp2(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseInterface9_baseOp2<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::BaseInterface10::begin_baseOp.
 * Create a wrapper instance by calling ::Test::newCallback_BaseInterface10_baseOp.
 */
template<class T>
class CallbackNC_BaseInterface10_baseOp : public Callback_BaseInterface10_baseOp_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_BaseInterface10_baseOp(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface10::begin_baseOp.
 */
template<class T> Callback_BaseInterface10_baseOpPtr
newCallback_BaseInterface10_baseOp(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseInterface10_baseOp<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface10::begin_baseOp.
 */
template<class T> Callback_BaseInterface10_baseOpPtr
newCallback_BaseInterface10_baseOp(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseInterface10_baseOp<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface10::begin_baseOp.
 */
template<class T> Callback_BaseInterface10_baseOpPtr
newCallback_BaseInterface10_baseOp(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseInterface10_baseOp<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface10::begin_baseOp.
 */
template<class T> Callback_BaseInterface10_baseOpPtr
newCallback_BaseInterface10_baseOp(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseInterface10_baseOp<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::BaseInterface10::begin_baseOp.
 * Create a wrapper instance by calling ::Test::newCallback_BaseInterface10_baseOp.
 */
template<class T, typename CT>
class Callback_BaseInterface10_baseOp : public Callback_BaseInterface10_baseOp_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_BaseInterface10_baseOp(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface10::begin_baseOp.
 */
template<class T, typename CT> Callback_BaseInterface10_baseOpPtr
newCallback_BaseInterface10_baseOp(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseInterface10_baseOp<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface10::begin_baseOp.
 */
template<class T, typename CT> Callback_BaseInterface10_baseOpPtr
newCallback_BaseInterface10_baseOp(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseInterface10_baseOp<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface10::begin_baseOp.
 */
template<class T, typename CT> Callback_BaseInterface10_baseOpPtr
newCallback_BaseInterface10_baseOp(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseInterface10_baseOp<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface10::begin_baseOp.
 */
template<class T, typename CT> Callback_BaseInterface10_baseOpPtr
newCallback_BaseInterface10_baseOp(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseInterface10_baseOp<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::BaseInterface10::begin_baseOp2.
 * Create a wrapper instance by calling ::Test::newCallback_BaseInterface10_baseOp2.
 */
template<class T>
class CallbackNC_BaseInterface10_baseOp2 : public Callback_BaseInterface10_baseOp2_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_BaseInterface10_baseOp2(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        BaseInterface10Prx proxy = BaseInterface10Prx::uncheckedCast(result->getProxy());
        ::std::string iceP_s;
        try
        {
            proxy->end_baseOp2(iceP_s, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(iceP_s);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface10::begin_baseOp2.
 */
template<class T> Callback_BaseInterface10_baseOp2Ptr
newCallback_BaseInterface10_baseOp2(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseInterface10_baseOp2<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface10::begin_baseOp2.
 */
template<class T> Callback_BaseInterface10_baseOp2Ptr
newCallback_BaseInterface10_baseOp2(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseInterface10_baseOp2<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::BaseInterface10::begin_baseOp2.
 * Create a wrapper instance by calling ::Test::newCallback_BaseInterface10_baseOp2.
 */
template<class T, typename CT>
class Callback_BaseInterface10_baseOp2 : public Callback_BaseInterface10_baseOp2_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_BaseInterface10_baseOp2(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        BaseInterface10Prx proxy = BaseInterface10Prx::uncheckedCast(result->getProxy());
        ::std::string iceP_s;
        try
        {
            proxy->end_baseOp2(iceP_s, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(iceP_s, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface10::begin_baseOp2.
 */
template<class T, typename CT> Callback_BaseInterface10_baseOp2Ptr
newCallback_BaseInterface10_baseOp2(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseInterface10_baseOp2<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface10::begin_baseOp2.
 */
template<class T, typename CT> Callback_BaseInterface10_baseOp2Ptr
newCallback_BaseInterface10_baseOp2(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseInterface10_baseOp2<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::BaseInterface11::begin_baseOp.
 * Create a wrapper instance by calling ::Test::newCallback_BaseInterface11_baseOp.
 */
template<class T>
class CallbackNC_BaseInterface11_baseOp : public Callback_BaseInterface11_baseOp_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_BaseInterface11_baseOp(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface11::begin_baseOp.
 */
template<class T> Callback_BaseInterface11_baseOpPtr
newCallback_BaseInterface11_baseOp(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseInterface11_baseOp<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface11::begin_baseOp.
 */
template<class T> Callback_BaseInterface11_baseOpPtr
newCallback_BaseInterface11_baseOp(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseInterface11_baseOp<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface11::begin_baseOp.
 */
template<class T> Callback_BaseInterface11_baseOpPtr
newCallback_BaseInterface11_baseOp(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseInterface11_baseOp<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface11::begin_baseOp.
 */
template<class T> Callback_BaseInterface11_baseOpPtr
newCallback_BaseInterface11_baseOp(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseInterface11_baseOp<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::BaseInterface11::begin_baseOp.
 * Create a wrapper instance by calling ::Test::newCallback_BaseInterface11_baseOp.
 */
template<class T, typename CT>
class Callback_BaseInterface11_baseOp : public Callback_BaseInterface11_baseOp_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_BaseInterface11_baseOp(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface11::begin_baseOp.
 */
template<class T, typename CT> Callback_BaseInterface11_baseOpPtr
newCallback_BaseInterface11_baseOp(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseInterface11_baseOp<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface11::begin_baseOp.
 */
template<class T, typename CT> Callback_BaseInterface11_baseOpPtr
newCallback_BaseInterface11_baseOp(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseInterface11_baseOp<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface11::begin_baseOp.
 */
template<class T, typename CT> Callback_BaseInterface11_baseOpPtr
newCallback_BaseInterface11_baseOp(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseInterface11_baseOp<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface11::begin_baseOp.
 */
template<class T, typename CT> Callback_BaseInterface11_baseOpPtr
newCallback_BaseInterface11_baseOp(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseInterface11_baseOp<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::BaseInterface11::begin_baseOp2.
 * Create a wrapper instance by calling ::Test::newCallback_BaseInterface11_baseOp2.
 */
template<class T>
class CallbackNC_BaseInterface11_baseOp2 : public Callback_BaseInterface11_baseOp2_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_BaseInterface11_baseOp2(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        BaseInterface11Prx proxy = BaseInterface11Prx::uncheckedCast(result->getProxy());
        ::std::string iceP_s;
        try
        {
            proxy->end_baseOp2(iceP_s, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(iceP_s);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface11::begin_baseOp2.
 */
template<class T> Callback_BaseInterface11_baseOp2Ptr
newCallback_BaseInterface11_baseOp2(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseInterface11_baseOp2<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface11::begin_baseOp2.
 */
template<class T> Callback_BaseInterface11_baseOp2Ptr
newCallback_BaseInterface11_baseOp2(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_BaseInterface11_baseOp2<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::BaseInterface11::begin_baseOp2.
 * Create a wrapper instance by calling ::Test::newCallback_BaseInterface11_baseOp2.
 */
template<class T, typename CT>
class Callback_BaseInterface11_baseOp2 : public Callback_BaseInterface11_baseOp2_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_BaseInterface11_baseOp2(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        BaseInterface11Prx proxy = BaseInterface11Prx::uncheckedCast(result->getProxy());
        ::std::string iceP_s;
        try
        {
            proxy->end_baseOp2(iceP_s, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(iceP_s, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface11::begin_baseOp2.
 */
template<class T, typename CT> Callback_BaseInterface11_baseOp2Ptr
newCallback_BaseInterface11_baseOp2(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseInterface11_baseOp2<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::BaseInterface11::begin_baseOp2.
 */
template<class T, typename CT> Callback_BaseInterface11_baseOp2Ptr
newCallback_BaseInterface11_baseOp2(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_BaseInterface11_baseOp2<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::OptionalParameters0::begin_op1.
 * Create a wrapper instance by calling ::Test::newCallback_OptionalParameters0_op1.
 */
template<class T>
class CallbackNC_OptionalParameters0_op1 : public Callback_OptionalParameters0_op1_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_OptionalParameters0_op1(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::OptionalParameters0::begin_op1.
 */
template<class T> Callback_OptionalParameters0_op1Ptr
newCallback_OptionalParameters0_op1(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_OptionalParameters0_op1<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::OptionalParameters0::begin_op1.
 */
template<class T> Callback_OptionalParameters0_op1Ptr
newCallback_OptionalParameters0_op1(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_OptionalParameters0_op1<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::OptionalParameters0::begin_op1.
 */
template<class T> Callback_OptionalParameters0_op1Ptr
newCallback_OptionalParameters0_op1(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_OptionalParameters0_op1<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::OptionalParameters0::begin_op1.
 */
template<class T> Callback_OptionalParameters0_op1Ptr
newCallback_OptionalParameters0_op1(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_OptionalParameters0_op1<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::OptionalParameters0::begin_op1.
 * Create a wrapper instance by calling ::Test::newCallback_OptionalParameters0_op1.
 */
template<class T, typename CT>
class Callback_OptionalParameters0_op1 : public Callback_OptionalParameters0_op1_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_OptionalParameters0_op1(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::OptionalParameters0::begin_op1.
 */
template<class T, typename CT> Callback_OptionalParameters0_op1Ptr
newCallback_OptionalParameters0_op1(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_OptionalParameters0_op1<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::OptionalParameters0::begin_op1.
 */
template<class T, typename CT> Callback_OptionalParameters0_op1Ptr
newCallback_OptionalParameters0_op1(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_OptionalParameters0_op1<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::OptionalParameters0::begin_op1.
 */
template<class T, typename CT> Callback_OptionalParameters0_op1Ptr
newCallback_OptionalParameters0_op1(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_OptionalParameters0_op1<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::OptionalParameters0::begin_op1.
 */
template<class T, typename CT> Callback_OptionalParameters0_op1Ptr
newCallback_OptionalParameters0_op1(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_OptionalParameters0_op1<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::OptionalParameters1::begin_op1.
 * Create a wrapper instance by calling ::Test::newCallback_OptionalParameters1_op1.
 */
template<class T>
class CallbackNC_OptionalParameters1_op1 : public Callback_OptionalParameters1_op1_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_OptionalParameters1_op1(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::OptionalParameters1::begin_op1.
 */
template<class T> Callback_OptionalParameters1_op1Ptr
newCallback_OptionalParameters1_op1(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_OptionalParameters1_op1<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::OptionalParameters1::begin_op1.
 */
template<class T> Callback_OptionalParameters1_op1Ptr
newCallback_OptionalParameters1_op1(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_OptionalParameters1_op1<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::OptionalParameters1::begin_op1.
 */
template<class T> Callback_OptionalParameters1_op1Ptr
newCallback_OptionalParameters1_op1(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_OptionalParameters1_op1<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::OptionalParameters1::begin_op1.
 */
template<class T> Callback_OptionalParameters1_op1Ptr
newCallback_OptionalParameters1_op1(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_OptionalParameters1_op1<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::OptionalParameters1::begin_op1.
 * Create a wrapper instance by calling ::Test::newCallback_OptionalParameters1_op1.
 */
template<class T, typename CT>
class Callback_OptionalParameters1_op1 : public Callback_OptionalParameters1_op1_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_OptionalParameters1_op1(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::OptionalParameters1::begin_op1.
 */
template<class T, typename CT> Callback_OptionalParameters1_op1Ptr
newCallback_OptionalParameters1_op1(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_OptionalParameters1_op1<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::OptionalParameters1::begin_op1.
 */
template<class T, typename CT> Callback_OptionalParameters1_op1Ptr
newCallback_OptionalParameters1_op1(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_OptionalParameters1_op1<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::OptionalParameters1::begin_op1.
 */
template<class T, typename CT> Callback_OptionalParameters1_op1Ptr
newCallback_OptionalParameters1_op1(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_OptionalParameters1_op1<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::OptionalParameters1::begin_op1.
 */
template<class T, typename CT> Callback_OptionalParameters1_op1Ptr
newCallback_OptionalParameters1_op1(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_OptionalParameters1_op1<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::OptionalParameters2::begin_op1.
 * Create a wrapper instance by calling ::Test::newCallback_OptionalParameters2_op1.
 */
template<class T>
class CallbackNC_OptionalParameters2_op1 : public Callback_OptionalParameters2_op1_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_OptionalParameters2_op1(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::OptionalParameters2::begin_op1.
 */
template<class T> Callback_OptionalParameters2_op1Ptr
newCallback_OptionalParameters2_op1(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_OptionalParameters2_op1<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::OptionalParameters2::begin_op1.
 */
template<class T> Callback_OptionalParameters2_op1Ptr
newCallback_OptionalParameters2_op1(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_OptionalParameters2_op1<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::OptionalParameters2::begin_op1.
 */
template<class T> Callback_OptionalParameters2_op1Ptr
newCallback_OptionalParameters2_op1(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_OptionalParameters2_op1<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::OptionalParameters2::begin_op1.
 */
template<class T> Callback_OptionalParameters2_op1Ptr
newCallback_OptionalParameters2_op1(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_OptionalParameters2_op1<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::OptionalParameters2::begin_op1.
 * Create a wrapper instance by calling ::Test::newCallback_OptionalParameters2_op1.
 */
template<class T, typename CT>
class Callback_OptionalParameters2_op1 : public Callback_OptionalParameters2_op1_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_OptionalParameters2_op1(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::OptionalParameters2::begin_op1.
 */
template<class T, typename CT> Callback_OptionalParameters2_op1Ptr
newCallback_OptionalParameters2_op1(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_OptionalParameters2_op1<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::OptionalParameters2::begin_op1.
 */
template<class T, typename CT> Callback_OptionalParameters2_op1Ptr
newCallback_OptionalParameters2_op1(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_OptionalParameters2_op1<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::OptionalParameters2::begin_op1.
 */
template<class T, typename CT> Callback_OptionalParameters2_op1Ptr
newCallback_OptionalParameters2_op1(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_OptionalParameters2_op1<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::OptionalParameters2::begin_op1.
 */
template<class T, typename CT> Callback_OptionalParameters2_op1Ptr
newCallback_OptionalParameters2_op1(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_OptionalParameters2_op1<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::OptionalParameters3::begin_op1.
 * Create a wrapper instance by calling ::Test::newCallback_OptionalParameters3_op1.
 */
template<class T>
class CallbackNC_OptionalParameters3_op1 : public Callback_OptionalParameters3_op1_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_OptionalParameters3_op1(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::OptionalParameters3::begin_op1.
 */
template<class T> Callback_OptionalParameters3_op1Ptr
newCallback_OptionalParameters3_op1(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_OptionalParameters3_op1<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::OptionalParameters3::begin_op1.
 */
template<class T> Callback_OptionalParameters3_op1Ptr
newCallback_OptionalParameters3_op1(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_OptionalParameters3_op1<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::OptionalParameters3::begin_op1.
 */
template<class T> Callback_OptionalParameters3_op1Ptr
newCallback_OptionalParameters3_op1(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_OptionalParameters3_op1<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::OptionalParameters3::begin_op1.
 */
template<class T> Callback_OptionalParameters3_op1Ptr
newCallback_OptionalParameters3_op1(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_OptionalParameters3_op1<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::OptionalParameters3::begin_op1.
 * Create a wrapper instance by calling ::Test::newCallback_OptionalParameters3_op1.
 */
template<class T, typename CT>
class Callback_OptionalParameters3_op1 : public Callback_OptionalParameters3_op1_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_OptionalParameters3_op1(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::OptionalParameters3::begin_op1.
 */
template<class T, typename CT> Callback_OptionalParameters3_op1Ptr
newCallback_OptionalParameters3_op1(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_OptionalParameters3_op1<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::OptionalParameters3::begin_op1.
 */
template<class T, typename CT> Callback_OptionalParameters3_op1Ptr
newCallback_OptionalParameters3_op1(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_OptionalParameters3_op1<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::OptionalParameters3::begin_op1.
 */
template<class T, typename CT> Callback_OptionalParameters3_op1Ptr
newCallback_OptionalParameters3_op1(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_OptionalParameters3_op1<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::OptionalParameters3::begin_op1.
 */
template<class T, typename CT> Callback_OptionalParameters3_op1Ptr
newCallback_OptionalParameters3_op1(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_OptionalParameters3_op1<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::OptionalReturn0::begin_op.
 * Create a wrapper instance by calling ::Test::newCallback_OptionalReturn0_op.
 */
template<class T>
class CallbackNC_OptionalReturn0_op : public Callback_OptionalReturn0_op_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IceUtil::Optional< ::Ice::Int>&);

    CallbackNC_OptionalReturn0_op(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        OptionalReturn0Prx proxy = OptionalReturn0Prx::uncheckedCast(result->getProxy());
        IceUtil::Optional< ::Ice::Int> ret;
        try
        {
            ret = proxy->end_op(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::OptionalReturn0::begin_op.
 */
template<class T> Callback_OptionalReturn0_opPtr
newCallback_OptionalReturn0_op(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional< ::Ice::Int>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_OptionalReturn0_op<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::OptionalReturn0::begin_op.
 */
template<class T> Callback_OptionalReturn0_opPtr
newCallback_OptionalReturn0_op(T* instance, void (T::*cb)(const IceUtil::Optional< ::Ice::Int>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_OptionalReturn0_op<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::OptionalReturn0::begin_op.
 * Create a wrapper instance by calling ::Test::newCallback_OptionalReturn0_op.
 */
template<class T, typename CT>
class Callback_OptionalReturn0_op : public Callback_OptionalReturn0_op_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IceUtil::Optional< ::Ice::Int>&, const CT&);

    Callback_OptionalReturn0_op(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        OptionalReturn0Prx proxy = OptionalReturn0Prx::uncheckedCast(result->getProxy());
        IceUtil::Optional< ::Ice::Int> ret;
        try
        {
            ret = proxy->end_op(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::OptionalReturn0::begin_op.
 */
template<class T, typename CT> Callback_OptionalReturn0_opPtr
newCallback_OptionalReturn0_op(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional< ::Ice::Int>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_OptionalReturn0_op<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::OptionalReturn0::begin_op.
 */
template<class T, typename CT> Callback_OptionalReturn0_opPtr
newCallback_OptionalReturn0_op(T* instance, void (T::*cb)(const IceUtil::Optional< ::Ice::Int>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_OptionalReturn0_op<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Test::OptionalReturn2::begin_op.
 * Create a wrapper instance by calling ::Test::newCallback_OptionalReturn2_op.
 */
template<class T>
class CallbackNC_OptionalReturn2_op : public Callback_OptionalReturn2_op_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IceUtil::Optional< ::Ice::Int>&);

    CallbackNC_OptionalReturn2_op(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        OptionalReturn2Prx proxy = OptionalReturn2Prx::uncheckedCast(result->getProxy());
        IceUtil::Optional< ::Ice::Int> ret;
        try
        {
            ret = proxy->end_op(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::OptionalReturn2::begin_op.
 */
template<class T> Callback_OptionalReturn2_opPtr
newCallback_OptionalReturn2_op(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional< ::Ice::Int>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_OptionalReturn2_op<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::OptionalReturn2::begin_op.
 */
template<class T> Callback_OptionalReturn2_opPtr
newCallback_OptionalReturn2_op(T* instance, void (T::*cb)(const IceUtil::Optional< ::Ice::Int>&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_OptionalReturn2_op<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Test::OptionalReturn2::begin_op.
 * Create a wrapper instance by calling ::Test::newCallback_OptionalReturn2_op.
 */
template<class T, typename CT>
class Callback_OptionalReturn2_op : public Callback_OptionalReturn2_op_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IceUtil::Optional< ::Ice::Int>&, const CT&);

    Callback_OptionalReturn2_op(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        OptionalReturn2Prx proxy = OptionalReturn2Prx::uncheckedCast(result->getProxy());
        IceUtil::Optional< ::Ice::Int> ret;
        try
        {
            ret = proxy->end_op(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::OptionalReturn2::begin_op.
 */
template<class T, typename CT> Callback_OptionalReturn2_opPtr
newCallback_OptionalReturn2_op(const IceUtil::Handle<T>& instance, void (T::*cb)(const IceUtil::Optional< ::Ice::Int>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_OptionalReturn2_op<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Test::OptionalReturn2::begin_op.
 */
template<class T, typename CT> Callback_OptionalReturn2_opPtr
newCallback_OptionalReturn2_op(T* instance, void (T::*cb)(const IceUtil::Optional< ::Ice::Int>&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_OptionalReturn2_op<T, CT>(instance, cb, excb, sentcb);
}

}

#endif

#include <IceUtil/PopDisableWarnings.h>
#endif
