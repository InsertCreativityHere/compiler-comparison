// Copyright (c) ZeroC, Inc.
//
// Ice version 3.8.0-alpha.0
//
// <auto-generated>
//
// Generated from file 'Key.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>

// clang-format off

#ifndef Key_h_
#define Key_h_

#include <Ice/PushDisableWarnings.h>
#include <Ice/Ice.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION  != 30850
#       error Ice version mismatch: an exact match is required for beta generated code
#   endif
#endif

namespace cs_abstract
{
    enum class as : std::uint8_t
    {
        base
    };

    std::ostream& operator<<(std::ostream&, as);

    struct break;

    class casePrx;

    class decimalPrx;

    class delegate;
    using delegatePtr = std::shared_ptr<delegate>;

    class explicitPrx;

    using while = std::map<std::string, break>;

    class optionalMembers;
    using optionalMembersPtr = std::shared_ptr<optionalMembers>;

    class optionalParamsPrx;

    constexpr std::int32_t protected = 0;

    constexpr std::int32_t struct = 1;

    namespace System
    {

        class TestPrx;
    }
}

namespace System
{

    class TestPrx;
}

namespace cs_abstract
{
    class casePrx : public Ice::Proxy<casePrx, Ice::ObjectPrx>
    {
    public:
        /// @param continue make sure the parameter doc-comment is mapped without a leading '@'.
        /// @param context The Context map to send with the invocation.
        void catch(std::int32_t checked, std::int32_t& continue, const Ice::Context& context = Ice::noExplicitContext) const;

        /// @param context The Context map to send with the invocation.
        /// @return The future object for the invocation.
        [[nodiscard]] std::future<std::int32_t> catchAsync(std::int32_t checked, const Ice::Context& context = Ice::noExplicitContext) const;

        /// @param response The response callback.
        /// @param exception The exception callback.
        /// @param sent The sent callback.
        /// @param context The Context map to send with the invocation.
        /// @return A function that can be called to cancel the invocation locally.
        // NOLINTNEXTLINE(modernize-use-nodiscard)
        std::function<void()> catchAsync(std::int32_t checked, std::function<void(std::int32_t)> response, std::function<void(std::exception_ptr)> exception = nullptr, std::function<void(bool)> sent = nullptr, const Ice::Context& context = Ice::noExplicitContext) const;

        /// \cond INTERNAL
        void _iceI_catch(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::int32_t>>&, std::int32_t, const Ice::Context&) const;
        /// \endcond

        /// Obtains the Slice type ID of this interface.
        /// @return The fully-scoped type ID.
        static const char* ice_staticId() noexcept;

        casePrx(const casePrx& other) noexcept : Ice::ObjectPrx(other) {} // NOLINT(modernize-use-equals-default)

        casePrx(casePrx&& other) noexcept : Ice::ObjectPrx(std::move(other)) {} // NOLINT(modernize-use-equals-default)

        casePrx(const Ice::CommunicatorPtr& communicator, std::string_view proxyString) : Ice::ObjectPrx(communicator, proxyString) {} // NOLINT(modernize-use-equals-default)

        ~casePrx() override;

        casePrx& operator=(const casePrx& rhs) noexcept
        {
            if (this != &rhs)
            {
                Ice::ObjectPrx::operator=(rhs);
            }
            return *this;
        }

        casePrx& operator=(casePrx&& rhs) noexcept
        {
            if (this != &rhs)
            {
                Ice::ObjectPrx::operator=(std::move(rhs));
            }
            return *this;
        }

        /// \cond INTERNAL
        static casePrx _fromReference(IceInternal::ReferencePtr ref) { return casePrx(std::move(ref)); }

    protected:
        casePrx() = default;

        explicit casePrx(IceInternal::ReferencePtr&& ref) : Ice::ObjectPrx(std::move(ref))
        {
        }
        /// \endcond
    };

    class decimalPrx : public Ice::Proxy<decimalPrx, Ice::ObjectPrx>
    {
    public:
        /// @param context The Context map to send with the invocation.
        /// @throws cs_abstract::foreach make sure the link is correctly generated.
        void default(const Ice::Context& context = Ice::noExplicitContext) const;

        /// @param context The Context map to send with the invocation.
        /// @return The future object for the invocation.
        [[nodiscard]] std::future<void> defaultAsync(const Ice::Context& context = Ice::noExplicitContext) const;

        /// @param response The response callback.
        /// @param exception The exception callback.
        /// @param sent The sent callback.
        /// @param context The Context map to send with the invocation.
        /// @return A function that can be called to cancel the invocation locally.
        // NOLINTNEXTLINE(modernize-use-nodiscard)
        std::function<void()> defaultAsync(std::function<void()> response, std::function<void(std::exception_ptr)> exception = nullptr, std::function<void(bool)> sent = nullptr, const Ice::Context& context = Ice::noExplicitContext) const;

        /// \cond INTERNAL
        void _iceI_default(const std::shared_ptr<IceInternal::OutgoingAsyncT<void>>&, const Ice::Context&) const;
        /// \endcond

        /// Obtains the Slice type ID of this interface.
        /// @return The fully-scoped type ID.
        static const char* ice_staticId() noexcept;

        decimalPrx(const decimalPrx& other) noexcept : Ice::ObjectPrx(other) {} // NOLINT(modernize-use-equals-default)

        decimalPrx(decimalPrx&& other) noexcept : Ice::ObjectPrx(std::move(other)) {} // NOLINT(modernize-use-equals-default)

        decimalPrx(const Ice::CommunicatorPtr& communicator, std::string_view proxyString) : Ice::ObjectPrx(communicator, proxyString) {} // NOLINT(modernize-use-equals-default)

        ~decimalPrx() override;

        decimalPrx& operator=(const decimalPrx& rhs) noexcept
        {
            if (this != &rhs)
            {
                Ice::ObjectPrx::operator=(rhs);
            }
            return *this;
        }

        decimalPrx& operator=(decimalPrx&& rhs) noexcept
        {
            if (this != &rhs)
            {
                Ice::ObjectPrx::operator=(std::move(rhs));
            }
            return *this;
        }

        /// \cond INTERNAL
        static decimalPrx _fromReference(IceInternal::ReferencePtr ref) { return decimalPrx(std::move(ref)); }

    protected:
        decimalPrx() = default;

        explicit decimalPrx(IceInternal::ReferencePtr&& ref) : Ice::ObjectPrx(std::move(ref))
        {
        }
        /// \endcond
    };

    class explicitPrx : public Ice::Proxy<explicitPrx, decimalPrx, casePrx>
    {
    public:

        /// Obtains the Slice type ID of this interface.
        /// @return The fully-scoped type ID.
        static const char* ice_staticId() noexcept;

#if defined(__GNUC__)
#   pragma GCC diagnostic push
#   pragma GCC diagnostic ignored "-Wextra" // initialize all virtual bases in correct order
#endif

        explicitPrx(const explicitPrx& other) noexcept : Ice::ObjectPrx(other) {} // NOLINT(modernize-use-equals-default)

        explicitPrx(explicitPrx&& other) noexcept : Ice::ObjectPrx(std::move(other)) {} // NOLINT(modernize-use-equals-default)

        explicitPrx(const Ice::CommunicatorPtr& communicator, std::string_view proxyString) : Ice::ObjectPrx(communicator, proxyString) {} // NOLINT(modernize-use-equals-default)

        ~explicitPrx() override;

        explicitPrx& operator=(const explicitPrx& rhs) noexcept
        {
            if (this != &rhs)
            {
                Ice::ObjectPrx::operator=(rhs);
            }
            return *this;
        }

        explicitPrx& operator=(explicitPrx&& rhs) noexcept
        {
            if (this != &rhs)
            {
                Ice::ObjectPrx::operator=(std::move(rhs));
            }
            return *this;
        }

        /// \cond INTERNAL
        static explicitPrx _fromReference(IceInternal::ReferencePtr ref) { return explicitPrx(std::move(ref)); }

    protected:
        explicitPrx() = default;

        explicit explicitPrx(IceInternal::ReferencePtr&& ref) : Ice::ObjectPrx(std::move(ref))
        {
        }
        /// \endcond

#if defined(__GNUC__)
#   pragma GCC diagnostic pop
#endif
    };

    class optionalParamsPrx : public Ice::Proxy<optionalParamsPrx, Ice::ObjectPrx>
    {
    public:
        std::optional<break> for(std::optional<as> goto, const std::optional<explicitPrx>& if, const std::optional<while>& internal, std::optional<std::string_view> context, const Ice::Context& context_ = Ice::noExplicitContext) const; // NOLINT(modernize-use-nodiscard)

        [[nodiscard]] std::future<std::optional<break>> forAsync(std::optional<as> goto, const std::optional<explicitPrx>& if, const std::optional<while>& internal, std::optional<std::string_view> context, const Ice::Context& context_ = Ice::noExplicitContext) const;

        // NOLINTNEXTLINE(modernize-use-nodiscard)
        std::function<void()> forAsync(std::optional<as> goto, const std::optional<explicitPrx>& if, const std::optional<while>& internal, std::optional<std::string_view> context, std::function<void(std::optional<::cs_abstract::break>)> response, std::function<void(std::exception_ptr)> exception = nullptr, std::function<void(bool)> sent = nullptr, const Ice::Context& context_ = Ice::noExplicitContext) const;

        /// \cond INTERNAL
        void _iceI_for(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::optional<break>>>&, std::optional<as>, const std::optional<explicitPrx>&, const std::optional<while>&, std::optional<std::string_view>, const Ice::Context&) const;
        /// \endcond

        std::optional<break> continue(std::optional<as> goto, const std::optional<explicitPrx>& if, const std::optional<while>& internal, std::optional<std::string_view> context, const Ice::Context& context_ = Ice::noExplicitContext) const; // NOLINT(modernize-use-nodiscard)

        [[nodiscard]] std::future<std::optional<break>> continueAsync(std::optional<as> goto, const std::optional<explicitPrx>& if, const std::optional<while>& internal, std::optional<std::string_view> context, const Ice::Context& context_ = Ice::noExplicitContext) const;

        // NOLINTNEXTLINE(modernize-use-nodiscard)
        std::function<void()> continueAsync(std::optional<as> goto, const std::optional<explicitPrx>& if, const std::optional<while>& internal, std::optional<std::string_view> context, std::function<void(std::optional<::cs_abstract::break>)> response, std::function<void(std::exception_ptr)> exception = nullptr, std::function<void(bool)> sent = nullptr, const Ice::Context& context_ = Ice::noExplicitContext) const;

        /// \cond INTERNAL
        void _iceI_continue(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::optional<break>>>&, std::optional<as>, const std::optional<explicitPrx>&, const std::optional<while>&, std::optional<std::string_view>, const Ice::Context&) const;
        /// \endcond

        std::optional<break> in(std::optional<as>& goto, std::optional<explicitPrx>& if, std::optional<while>& internal, std::optional<std::string>& context, const Ice::Context& context_ = Ice::noExplicitContext) const;

        [[nodiscard]] std::future<std::tuple<std::optional<break>, std::optional<as>, std::optional<explicitPrx>, std::optional<while>, std::optional<std::string>>> inAsync(const Ice::Context& context_ = Ice::noExplicitContext) const;

        // NOLINTNEXTLINE(modernize-use-nodiscard)
        std::function<void()> inAsync(std::function<void(std::optional<::cs_abstract::break>, std::optional<::cs_abstract::as>, std::optional<::cs_abstract::explicitPrx>, std::optional<::cs_abstract::while>, std::optional<std::string>)> response, std::function<void(std::exception_ptr)> exception = nullptr, std::function<void(bool)> sent = nullptr, const Ice::Context& context_ = Ice::noExplicitContext) const;

        /// \cond INTERNAL
        void _iceI_in(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::tuple<std::optional<break>, std::optional<as>, std::optional<explicitPrx>, std::optional<while>, std::optional<std::string>>>>&, const Ice::Context&) const;
        /// \endcond

        std::optional<break> foreach(std::optional<as>& goto, std::optional<explicitPrx>& if, std::optional<while>& internal, std::optional<std::string>& context, const Ice::Context& context_ = Ice::noExplicitContext) const;

        [[nodiscard]] std::future<std::tuple<std::optional<break>, std::optional<as>, std::optional<explicitPrx>, std::optional<while>, std::optional<std::string>>> foreachAsync(const Ice::Context& context_ = Ice::noExplicitContext) const;

        // NOLINTNEXTLINE(modernize-use-nodiscard)
        std::function<void()> foreachAsync(std::function<void(std::optional<::cs_abstract::break>, std::optional<::cs_abstract::as>, std::optional<::cs_abstract::explicitPrx>, std::optional<::cs_abstract::while>, std::optional<std::string>)> response, std::function<void(std::exception_ptr)> exception = nullptr, std::function<void(bool)> sent = nullptr, const Ice::Context& context_ = Ice::noExplicitContext) const;

        /// \cond INTERNAL
        void _iceI_foreach(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::tuple<std::optional<break>, std::optional<as>, std::optional<explicitPrx>, std::optional<while>, std::optional<std::string>>>>&, const Ice::Context&) const;
        /// \endcond

        /// Obtains the Slice type ID of this interface.
        /// @return The fully-scoped type ID.
        static const char* ice_staticId() noexcept;

        optionalParamsPrx(const optionalParamsPrx& other) noexcept : Ice::ObjectPrx(other) {} // NOLINT(modernize-use-equals-default)

        optionalParamsPrx(optionalParamsPrx&& other) noexcept : Ice::ObjectPrx(std::move(other)) {} // NOLINT(modernize-use-equals-default)

        optionalParamsPrx(const Ice::CommunicatorPtr& communicator, std::string_view proxyString) : Ice::ObjectPrx(communicator, proxyString) {} // NOLINT(modernize-use-equals-default)

        ~optionalParamsPrx() override;

        optionalParamsPrx& operator=(const optionalParamsPrx& rhs) noexcept
        {
            if (this != &rhs)
            {
                Ice::ObjectPrx::operator=(rhs);
            }
            return *this;
        }

        optionalParamsPrx& operator=(optionalParamsPrx&& rhs) noexcept
        {
            if (this != &rhs)
            {
                Ice::ObjectPrx::operator=(std::move(rhs));
            }
            return *this;
        }

        /// \cond INTERNAL
        static optionalParamsPrx _fromReference(IceInternal::ReferencePtr ref) { return optionalParamsPrx(std::move(ref)); }

    protected:
        optionalParamsPrx() = default;

        explicit optionalParamsPrx(IceInternal::ReferencePtr&& ref) : Ice::ObjectPrx(std::move(ref))
        {
        }
        /// \endcond
    };

    namespace System
    {

        class TestPrx : public Ice::Proxy<TestPrx, Ice::ObjectPrx>
        {
        public:
            void op(const Ice::Context& context = Ice::noExplicitContext) const;

            [[nodiscard]] std::future<void> opAsync(const Ice::Context& context = Ice::noExplicitContext) const;

            // NOLINTNEXTLINE(modernize-use-nodiscard)
            std::function<void()> opAsync(std::function<void()> response, std::function<void(std::exception_ptr)> exception = nullptr, std::function<void(bool)> sent = nullptr, const Ice::Context& context = Ice::noExplicitContext) const;

            /// \cond INTERNAL
            void _iceI_op(const std::shared_ptr<IceInternal::OutgoingAsyncT<void>>&, const Ice::Context&) const;
            /// \endcond

            /// Obtains the Slice type ID of this interface.
            /// @return The fully-scoped type ID.
            static const char* ice_staticId() noexcept;

            TestPrx(const TestPrx& other) noexcept : Ice::ObjectPrx(other) {} // NOLINT(modernize-use-equals-default)

            TestPrx(TestPrx&& other) noexcept : Ice::ObjectPrx(std::move(other)) {} // NOLINT(modernize-use-equals-default)

            TestPrx(const Ice::CommunicatorPtr& communicator, std::string_view proxyString) : Ice::ObjectPrx(communicator, proxyString) {} // NOLINT(modernize-use-equals-default)

            ~TestPrx() override;

            TestPrx& operator=(const TestPrx& rhs) noexcept
            {
                if (this != &rhs)
                {
                    Ice::ObjectPrx::operator=(rhs);
                }
                return *this;
            }

            TestPrx& operator=(TestPrx&& rhs) noexcept
            {
                if (this != &rhs)
                {
                    Ice::ObjectPrx::operator=(std::move(rhs));
                }
                return *this;
            }

            /// \cond INTERNAL
            static TestPrx _fromReference(IceInternal::ReferencePtr ref) { return TestPrx(std::move(ref)); }

        protected:
            TestPrx() = default;

            explicit TestPrx(IceInternal::ReferencePtr&& ref) : Ice::ObjectPrx(std::move(ref))
            {
            }
            /// \endcond
        };
    }
}

namespace System
{

    class TestPrx : public Ice::Proxy<TestPrx, Ice::ObjectPrx>
    {
    public:
        void op(const Ice::Context& context = Ice::noExplicitContext) const;

        [[nodiscard]] std::future<void> opAsync(const Ice::Context& context = Ice::noExplicitContext) const;

        // NOLINTNEXTLINE(modernize-use-nodiscard)
        std::function<void()> opAsync(std::function<void()> response, std::function<void(std::exception_ptr)> exception = nullptr, std::function<void(bool)> sent = nullptr, const Ice::Context& context = Ice::noExplicitContext) const;

        /// \cond INTERNAL
        void _iceI_op(const std::shared_ptr<IceInternal::OutgoingAsyncT<void>>&, const Ice::Context&) const;
        /// \endcond

        /// Obtains the Slice type ID of this interface.
        /// @return The fully-scoped type ID.
        static const char* ice_staticId() noexcept;

        TestPrx(const TestPrx& other) noexcept : Ice::ObjectPrx(other) {} // NOLINT(modernize-use-equals-default)

        TestPrx(TestPrx&& other) noexcept : Ice::ObjectPrx(std::move(other)) {} // NOLINT(modernize-use-equals-default)

        TestPrx(const Ice::CommunicatorPtr& communicator, std::string_view proxyString) : Ice::ObjectPrx(communicator, proxyString) {} // NOLINT(modernize-use-equals-default)

        ~TestPrx() override;

        TestPrx& operator=(const TestPrx& rhs) noexcept
        {
            if (this != &rhs)
            {
                Ice::ObjectPrx::operator=(rhs);
            }
            return *this;
        }

        TestPrx& operator=(TestPrx&& rhs) noexcept
        {
            if (this != &rhs)
            {
                Ice::ObjectPrx::operator=(std::move(rhs));
            }
            return *this;
        }

        /// \cond INTERNAL
        static TestPrx _fromReference(IceInternal::ReferencePtr ref) { return TestPrx(std::move(ref)); }

    protected:
        TestPrx() = default;

        explicit TestPrx(IceInternal::ReferencePtr&& ref) : Ice::ObjectPrx(std::move(ref))
        {
        }
        /// \endcond
    };
}

namespace cs_abstract
{
    struct break
    {
        std::int32_t readonly;

        /// Obtains a tuple containing all of the struct's data members.
        /// @return The data members in a tuple.
        [[nodiscard]] std::tuple<const std::int32_t&> ice_tuple() const
        {
            return std::tie(readonly);
        }

        /// Outputs the name and value of each field of this instance to the stream.
        /// @param os The output stream.
        void ice_printFields(std::ostream& os) const;
    };

    std::ostream& operator<<(std::ostream&, const break&);

    class fixed : public Ice::UserException
    {
    public:
        /// Default constructor.
        fixed() noexcept = default;

        /// One-shot constructor to initialize all data members.
        fixed(std::int32_t for) noexcept :
            for(for)
        {
        }

        /// Copy constructor.
        fixed(const fixed&) noexcept = default;

        /// Obtains a tuple containing all of the exception's data members.
        /// @return The data members in a tuple.
        [[nodiscard]] std::tuple<const std::int32_t&> ice_tuple() const
        {
            return std::tie(for);
        }


        void ice_printFields(std::ostream& os) const override;
        /// Obtains the Slice type ID of this exception.
        /// @return The fully-scoped type ID.
        static const char* ice_staticId() noexcept;

        [[nodiscard]] const char* ice_id() const noexcept override;

        void ice_throw() const override;

        std::int32_t for;

    protected:
        void _writeImpl(Ice::OutputStream*) const override;

        void _readImpl(Ice::InputStream*) override;
    };

    class foreach : public fixed
    {
    public:
        /// Default constructor.
        foreach() noexcept = default;

        /// One-shot constructor to initialize all data members.
        foreach(std::int32_t for, std::int32_t goto, std::int32_t Message) noexcept :
            fixed(for),
            goto(goto),
            Message(Message)
        {
        }

        /// Copy constructor.
        foreach(const foreach&) noexcept = default;

        /// Obtains a tuple containing all of the exception's data members.
        /// @return The data members in a tuple.
        [[nodiscard]] std::tuple<const std::int32_t&, const std::int32_t&, const std::int32_t&> ice_tuple() const
        {
            return std::tie(for, goto, Message);
        }


        void ice_printFields(std::ostream& os) const override;
        /// Obtains the Slice type ID of this exception.
        /// @return The fully-scoped type ID.
        static const char* ice_staticId() noexcept;

        [[nodiscard]] const char* ice_id() const noexcept override;

        void ice_throw() const override;

        std::int32_t goto;
        std::int32_t Message;

    protected:
        void _writeImpl(Ice::OutputStream*) const override;

        void _readImpl(Ice::InputStream*) override;
    };

    class delegate : public Ice::Value
    {
    public:
        /// Default constructor.
        delegate() noexcept = default;

        /// One-shot constructor to initialize all data members.
        delegate(std::int32_t if, std::optional<::cs_abstract::casePrx> else) noexcept :
            if(if),
            else(std::move(else))
        {
        }

        /// Obtains the Slice type ID of this value.
        /// @return The fully-scoped type ID.
        static const char* ice_staticId() noexcept;

        [[nodiscard]] const char* ice_id() const noexcept override;

        /// Obtains a tuple containing all of the value's data members.
        /// @return The data members in a tuple.
        [[nodiscard]] std::tuple<const std::int32_t&, const std::optional<::cs_abstract::casePrx>&> ice_tuple() const
        {
            return std::tie(if, else);
        }

        /// Creates a shallow polymorphic copy of this instance.
        /// @return The cloned value.
        [[nodiscard]] delegatePtr ice_clone() const { return std::static_pointer_cast<delegate>(_iceCloneImpl()); }

        std::int32_t if;
        std::optional<::cs_abstract::casePrx> else;

        void ice_printFields(std::ostream& os) const override;
        delegate(const delegate&) = default;

        [[nodiscard]] Ice::ValuePtr _iceCloneImpl() const override;

        void _iceWriteImpl(Ice::OutputStream*) const override;

        void _iceReadImpl(Ice::InputStream*) override;
    };

    class optionalMembers : public Ice::Value
    {
    public:
        /// Default constructor.
        optionalMembers() noexcept = default;

        /// One-shot constructor to initialize all data members.
        optionalMembers(std::optional<::cs_abstract::break> for, std::optional<::cs_abstract::as> goto, std::optional<::cs_abstract::explicitPrx> if, std::optional<::cs_abstract::while> internal, std::optional<std::string> namespace) noexcept :
            for(for),
            goto(goto),
            if(std::move(if)),
            internal(std::move(internal)),
            namespace(std::move(namespace))
        {
        }

        /// Obtains the Slice type ID of this value.
        /// @return The fully-scoped type ID.
        static const char* ice_staticId() noexcept;

        [[nodiscard]] const char* ice_id() const noexcept override;

        /// Obtains a tuple containing all of the value's data members.
        /// @return The data members in a tuple.
        [[nodiscard]] std::tuple<const std::optional<::cs_abstract::break>&, const std::optional<::cs_abstract::as>&, const std::optional<::cs_abstract::explicitPrx>&, const std::optional<::cs_abstract::while>&, const std::optional<std::string>&> ice_tuple() const
        {
            return std::tie(for, goto, if, internal, namespace);
        }

        /// Creates a shallow polymorphic copy of this instance.
        /// @return The cloned value.
        [[nodiscard]] optionalMembersPtr ice_clone() const { return std::static_pointer_cast<optionalMembers>(_iceCloneImpl()); }

        std::optional<::cs_abstract::break> for;
        std::optional<::cs_abstract::as> goto;
        std::optional<::cs_abstract::explicitPrx> if;
        std::optional<::cs_abstract::while> internal;
        std::optional<std::string> namespace;

        void ice_printFields(std::ostream& os) const override;
        optionalMembers(const optionalMembers&) = default;

        [[nodiscard]] Ice::ValuePtr _iceCloneImpl() const override;

        void _iceWriteImpl(Ice::OutputStream*) const override;

        void _iceReadImpl(Ice::InputStream*) override;
    };

    using Ice::Tuple::operator<;
    using Ice::Tuple::operator<=;
    using Ice::Tuple::operator>;
    using Ice::Tuple::operator>=;
    using Ice::Tuple::operator==;
    using Ice::Tuple::operator!=;
}

namespace cs_abstract
{
    class case : public virtual Ice::Object
    {
    public:
        using ProxyType = casePrx;

        /// Obtains a list of the Slice type IDs representing the interfaces supported by this object.
        /// @param current The Current object for the invocation.
        /// @return A list of fully-scoped type IDs.
        [[nodiscard]] std::vector<std::string> ice_ids(const Ice::Current& current) const override;

        /// Obtains a Slice type ID representing the most-derived interface supported by this object.
        /// @param current The Current object for the invocation.
        /// @return A fully-scoped type ID.
        [[nodiscard]] std::string ice_id(const Ice::Current& current) const override;

        /// Obtains the Slice type ID corresponding to this interface.
        /// @return A fully-scoped type ID.
        static const char* ice_staticId() noexcept;

        /// @param response The response callback.
        /// @param exception The exception callback.
        /// @param current The Current object for the invocation.
        virtual void catchAsync(std::int32_t checked, std::function<void(std::int32_t continue)> response, std::function<void(std::exception_ptr)> exception, const Ice::Current& current) = 0;

        /// \cond INTERNAL
        void _iceD_catch(Ice::IncomingRequest&, std::function<void(Ice::OutgoingResponse)>);
        /// \endcond

        void dispatch(Ice::IncomingRequest&, std::function<void(Ice::OutgoingResponse)>) override;
    };

    using casePtr = std::shared_ptr<case>;

    class decimal : public virtual Ice::Object
    {
    public:
        using ProxyType = decimalPrx;

        /// Obtains a list of the Slice type IDs representing the interfaces supported by this object.
        /// @param current The Current object for the invocation.
        /// @return A list of fully-scoped type IDs.
        [[nodiscard]] std::vector<std::string> ice_ids(const Ice::Current& current) const override;

        /// Obtains a Slice type ID representing the most-derived interface supported by this object.
        /// @param current The Current object for the invocation.
        /// @return A fully-scoped type ID.
        [[nodiscard]] std::string ice_id(const Ice::Current& current) const override;

        /// Obtains the Slice type ID corresponding to this interface.
        /// @return A fully-scoped type ID.
        static const char* ice_staticId() noexcept;

        /// @param current The Current object for the invocation.
        /// @throws cs_abstract::foreach make sure the link is correctly generated.
        virtual void default(const Ice::Current& current) = 0;

        /// \cond INTERNAL
        void _iceD_default(Ice::IncomingRequest&, std::function<void(Ice::OutgoingResponse)>);
        /// \endcond

        void dispatch(Ice::IncomingRequest&, std::function<void(Ice::OutgoingResponse)>) override;
    };

    using decimalPtr = std::shared_ptr<decimal>;

    class explicit : public virtual decimal,
                     public virtual case
    {
    public:
        using ProxyType = explicitPrx;

        /// Obtains a list of the Slice type IDs representing the interfaces supported by this object.
        /// @param current The Current object for the invocation.
        /// @return A list of fully-scoped type IDs.
        [[nodiscard]] std::vector<std::string> ice_ids(const Ice::Current& current) const override;

        /// Obtains a Slice type ID representing the most-derived interface supported by this object.
        /// @param current The Current object for the invocation.
        /// @return A fully-scoped type ID.
        [[nodiscard]] std::string ice_id(const Ice::Current& current) const override;

        /// Obtains the Slice type ID corresponding to this interface.
        /// @return A fully-scoped type ID.
        static const char* ice_staticId() noexcept;

        void dispatch(Ice::IncomingRequest&, std::function<void(Ice::OutgoingResponse)>) override;
    };

    using explicitPtr = std::shared_ptr<explicit>;

    class optionalParams : public virtual Ice::Object
    {
    public:
        using ProxyType = optionalParamsPrx;

        /// Obtains a list of the Slice type IDs representing the interfaces supported by this object.
        /// @param current The Current object for the invocation.
        /// @return A list of fully-scoped type IDs.
        [[nodiscard]] std::vector<std::string> ice_ids(const Ice::Current& current) const override;

        /// Obtains a Slice type ID representing the most-derived interface supported by this object.
        /// @param current The Current object for the invocation.
        /// @return A fully-scoped type ID.
        [[nodiscard]] std::string ice_id(const Ice::Current& current) const override;

        /// Obtains the Slice type ID corresponding to this interface.
        /// @return A fully-scoped type ID.
        static const char* ice_staticId() noexcept;

        virtual std::optional<break> for(std::optional<as> goto, std::optional<explicitPrx> if, std::optional<while> internal, std::optional<std::string> context, const Ice::Current& current) = 0;

        /// \cond INTERNAL
        void _iceD_for(Ice::IncomingRequest&, std::function<void(Ice::OutgoingResponse)>);
        /// \endcond

        virtual void continueAsync(std::optional<as> goto, std::optional<explicitPrx> if, std::optional<while> internal, std::optional<std::string> context, std::function<void(const std::optional<break>& returnValue)> response, std::function<void(std::exception_ptr)> exception, const Ice::Current& current) = 0;

        /// \cond INTERNAL
        void _iceD_continue(Ice::IncomingRequest&, std::function<void(Ice::OutgoingResponse)>);
        /// \endcond

        virtual std::optional<break> in(std::optional<as>& goto, std::optional<explicitPrx>& if, std::optional<while>& internal, std::optional<std::string>& context, const Ice::Current& current) = 0;

        /// \cond INTERNAL
        void _iceD_in(Ice::IncomingRequest&, std::function<void(Ice::OutgoingResponse)>);
        /// \endcond

        virtual void foreachAsync(std::function<void(const std::optional<break>& returnValue, std::optional<as> goto, const std::optional<explicitPrx>& if, const std::optional<while>& internal, std::optional<std::string_view> context)> response, std::function<void(std::exception_ptr)> exception, const Ice::Current& current) = 0;

        /// \cond INTERNAL
        void _iceD_foreach(Ice::IncomingRequest&, std::function<void(Ice::OutgoingResponse)>);
        /// \endcond

        void dispatch(Ice::IncomingRequest&, std::function<void(Ice::OutgoingResponse)>) override;
    };

    using optionalParamsPtr = std::shared_ptr<optionalParams>;

    namespace System
    {

        class Test : public virtual Ice::Object
        {
        public:
            using ProxyType = TestPrx;

            /// Obtains a list of the Slice type IDs representing the interfaces supported by this object.
            /// @param current The Current object for the invocation.
            /// @return A list of fully-scoped type IDs.
            [[nodiscard]] std::vector<std::string> ice_ids(const Ice::Current& current) const override;

            /// Obtains a Slice type ID representing the most-derived interface supported by this object.
            /// @param current The Current object for the invocation.
            /// @return A fully-scoped type ID.
            [[nodiscard]] std::string ice_id(const Ice::Current& current) const override;

            /// Obtains the Slice type ID corresponding to this interface.
            /// @return A fully-scoped type ID.
            static const char* ice_staticId() noexcept;

            virtual void op(const Ice::Current& current) = 0;

            /// \cond INTERNAL
            void _iceD_op(Ice::IncomingRequest&, std::function<void(Ice::OutgoingResponse)>);
            /// \endcond

            void dispatch(Ice::IncomingRequest&, std::function<void(Ice::OutgoingResponse)>) override;
        };

        using TestPtr = std::shared_ptr<Test>;
    }
}

namespace System
{

    class Test : public virtual Ice::Object
    {
    public:
        using ProxyType = TestPrx;

        /// Obtains a list of the Slice type IDs representing the interfaces supported by this object.
        /// @param current The Current object for the invocation.
        /// @return A list of fully-scoped type IDs.
        [[nodiscard]] std::vector<std::string> ice_ids(const Ice::Current& current) const override;

        /// Obtains a Slice type ID representing the most-derived interface supported by this object.
        /// @param current The Current object for the invocation.
        /// @return A fully-scoped type ID.
        [[nodiscard]] std::string ice_id(const Ice::Current& current) const override;

        /// Obtains the Slice type ID corresponding to this interface.
        /// @return A fully-scoped type ID.
        static const char* ice_staticId() noexcept;

        virtual void op(const Ice::Current& current) = 0;

        /// \cond INTERNAL
        void _iceD_op(Ice::IncomingRequest&, std::function<void(Ice::OutgoingResponse)>);
        /// \endcond

        void dispatch(Ice::IncomingRequest&, std::function<void(Ice::OutgoingResponse)>) override;
    };

    using TestPtr = std::shared_ptr<Test>;
}

/// \cond STREAM
namespace Ice
{
    template<>
    struct StreamableTraits<::cs_abstract::as>
    {
        static const StreamHelperCategory helper = StreamHelperCategoryEnum;
        static const int minValue = 0;
        static const int maxValue = 0;
        static const int minWireSize = 1;
        static const bool fixedLength = false;
    };

    template<>
    struct StreamableTraits<::cs_abstract::break>
    {
        static const StreamHelperCategory helper = StreamHelperCategoryStruct;
        static const int minWireSize = 4;
        static const bool fixedLength = true;
    };
    
    template<>
    struct StreamReader<::cs_abstract::break>
    {
        static void read(InputStream* istr, ::cs_abstract::break& v)
        {
            istr->readAll(v.readonly);
        }
    };
}
/// \endcond

#include <Ice/PopDisableWarnings.h>
#endif
