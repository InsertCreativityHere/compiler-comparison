//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.8.0-alpha.0
//
// <auto-generated>
//
// Generated from file `TestAMD.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#define ICE_BUILDING_GENERATED_CODE
#include <TestAMD.h>
#include <Ice/OutgoingAsync.h>
#include <Ice/Incoming.h>

#if defined(_MSC_VER)
#   pragma warning(disable:4458) // declaration of ... hides class member
#elif defined(__clang__)
#   pragma clang diagnostic ignored "-Wshadow"
#elif defined(__GNUC__)
#   pragma GCC diagnostic ignored "-Wshadow"
#endif

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION  != 30850
#       error Ice version mismatch: an exact match is required for beta generated code
#   endif
#endif

namespace
{

const ::IceInternal::DefaultValueFactoryInit<::Test::CV> iceC_Test_CV_init("::Test::CV");

const ::IceInternal::DefaultValueFactoryInit<::Test::CR> iceC_Test_CR_init("::Test::CR");

}

::std::string_view
Test::IPrx::ice_staticId()
{
    static constexpr ::std::string_view typeId = "::Test::I";
    return typeId;
}

void
Test::MyClassPrx::shutdown(const ::Ice::Context& context) const
{
    ::IceInternal::makePromiseOutgoing<void>(true, this, &MyClassPrx::_iceI_shutdown, context).get();
}

::std::future<void>
Test::MyClassPrx::shutdownAsync(const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<void>(false, this, &MyClassPrx::_iceI_shutdown, context);
}

::std::function<void()>
Test::MyClassPrx::shutdownAsync(::std::function<void()> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_shutdown, context);
}

void
Test::MyClassPrx::_iceI_shutdown(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "shutdown";

    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}

::Test::AByteS
Test::MyClassPrx::opAByteS(const AByteS& iceP_i, AByteS& iceP_o, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<AByteS, AByteS>>(true, this, &MyClassPrx::_iceI_opAByteS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::AByteS, ::Test::AByteS>>
Test::MyClassPrx::opAByteSAsync(const AByteS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<AByteS, AByteS>>(false, this, &MyClassPrx::_iceI_opAByteS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opAByteSAsync(const AByteS& iceP_i, ::std::function<void(::Test::AByteS, ::Test::AByteS)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<AByteS, AByteS>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<AByteS, AByteS>>(std::move(responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opAByteS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opAByteS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<AByteS, AByteS>>>& outAsync, const AByteS& iceP_i, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opAByteS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<AByteS, AByteS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::LByteS
Test::MyClassPrx::opLByteS(const LByteS& iceP_i, LByteS& iceP_o, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<LByteS, LByteS>>(true, this, &MyClassPrx::_iceI_opLByteS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::LByteS, ::Test::LByteS>>
Test::MyClassPrx::opLByteSAsync(const LByteS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<LByteS, LByteS>>(false, this, &MyClassPrx::_iceI_opLByteS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opLByteSAsync(const LByteS& iceP_i, ::std::function<void(::Test::LByteS, ::Test::LByteS)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<LByteS, LByteS>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<LByteS, LByteS>>(std::move(responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opLByteS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opLByteS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<LByteS, LByteS>>>& outAsync, const LByteS& iceP_i, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opLByteS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<LByteS, LByteS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::KByteS
Test::MyClassPrx::opKByteS(const KByteS& iceP_i, KByteS& iceP_o, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<KByteS, KByteS>>(true, this, &MyClassPrx::_iceI_opKByteS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::KByteS, ::Test::KByteS>>
Test::MyClassPrx::opKByteSAsync(const KByteS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<KByteS, KByteS>>(false, this, &MyClassPrx::_iceI_opKByteS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opKByteSAsync(const KByteS& iceP_i, ::std::function<void(::Test::KByteS, ::Test::KByteS)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<KByteS, KByteS>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<KByteS, KByteS>>(std::move(responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opKByteS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opKByteS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<KByteS, KByteS>>>& outAsync, const KByteS& iceP_i, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opKByteS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<KByteS, KByteS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::QByteS
Test::MyClassPrx::opQByteS(const QByteS& iceP_i, QByteS& iceP_o, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<QByteS, QByteS>>(true, this, &MyClassPrx::_iceI_opQByteS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::QByteS, ::Test::QByteS>>
Test::MyClassPrx::opQByteSAsync(const QByteS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<QByteS, QByteS>>(false, this, &MyClassPrx::_iceI_opQByteS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opQByteSAsync(const QByteS& iceP_i, ::std::function<void(::Test::QByteS, ::Test::QByteS)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<QByteS, QByteS>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<QByteS, QByteS>>(std::move(responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opQByteS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opQByteS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<QByteS, QByteS>>>& outAsync, const QByteS& iceP_i, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opQByteS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<QByteS, QByteS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::SByteS
Test::MyClassPrx::opSByteS(const SByteS& iceP_i, SByteS& iceP_o, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<SByteS, SByteS>>(true, this, &MyClassPrx::_iceI_opSByteS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::SByteS, ::Test::SByteS>>
Test::MyClassPrx::opSByteSAsync(const SByteS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<SByteS, SByteS>>(false, this, &MyClassPrx::_iceI_opSByteS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opSByteSAsync(const SByteS& iceP_i, ::std::function<void(::Test::SByteS, ::Test::SByteS)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<SByteS, SByteS>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<SByteS, SByteS>>(std::move(responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opSByteS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opSByteS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<SByteS, SByteS>>>& outAsync, const SByteS& iceP_i, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opSByteS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<SByteS, SByteS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::ABoolS
Test::MyClassPrx::opABoolS(const ABoolS& iceP_i, ABoolS& iceP_o, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<ABoolS, ABoolS>>(true, this, &MyClassPrx::_iceI_opABoolS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::ABoolS, ::Test::ABoolS>>
Test::MyClassPrx::opABoolSAsync(const ABoolS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<ABoolS, ABoolS>>(false, this, &MyClassPrx::_iceI_opABoolS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opABoolSAsync(const ABoolS& iceP_i, ::std::function<void(::Test::ABoolS, ::Test::ABoolS)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<ABoolS, ABoolS>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<ABoolS, ABoolS>>(std::move(responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opABoolS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opABoolS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<ABoolS, ABoolS>>>& outAsync, const ABoolS& iceP_i, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opABoolS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<ABoolS, ABoolS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::LBoolS
Test::MyClassPrx::opLBoolS(const LBoolS& iceP_i, LBoolS& iceP_o, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<LBoolS, LBoolS>>(true, this, &MyClassPrx::_iceI_opLBoolS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::LBoolS, ::Test::LBoolS>>
Test::MyClassPrx::opLBoolSAsync(const LBoolS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<LBoolS, LBoolS>>(false, this, &MyClassPrx::_iceI_opLBoolS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opLBoolSAsync(const LBoolS& iceP_i, ::std::function<void(::Test::LBoolS, ::Test::LBoolS)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<LBoolS, LBoolS>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<LBoolS, LBoolS>>(std::move(responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opLBoolS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opLBoolS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<LBoolS, LBoolS>>>& outAsync, const LBoolS& iceP_i, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opLBoolS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<LBoolS, LBoolS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::KBoolS
Test::MyClassPrx::opKBoolS(const KBoolS& iceP_i, KBoolS& iceP_o, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<KBoolS, KBoolS>>(true, this, &MyClassPrx::_iceI_opKBoolS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::KBoolS, ::Test::KBoolS>>
Test::MyClassPrx::opKBoolSAsync(const KBoolS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<KBoolS, KBoolS>>(false, this, &MyClassPrx::_iceI_opKBoolS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opKBoolSAsync(const KBoolS& iceP_i, ::std::function<void(::Test::KBoolS, ::Test::KBoolS)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<KBoolS, KBoolS>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<KBoolS, KBoolS>>(std::move(responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opKBoolS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opKBoolS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<KBoolS, KBoolS>>>& outAsync, const KBoolS& iceP_i, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opKBoolS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<KBoolS, KBoolS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::QBoolS
Test::MyClassPrx::opQBoolS(const QBoolS& iceP_i, QBoolS& iceP_o, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<QBoolS, QBoolS>>(true, this, &MyClassPrx::_iceI_opQBoolS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::QBoolS, ::Test::QBoolS>>
Test::MyClassPrx::opQBoolSAsync(const QBoolS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<QBoolS, QBoolS>>(false, this, &MyClassPrx::_iceI_opQBoolS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opQBoolSAsync(const QBoolS& iceP_i, ::std::function<void(::Test::QBoolS, ::Test::QBoolS)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<QBoolS, QBoolS>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<QBoolS, QBoolS>>(std::move(responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opQBoolS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opQBoolS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<QBoolS, QBoolS>>>& outAsync, const QBoolS& iceP_i, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opQBoolS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<QBoolS, QBoolS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::SBoolS
Test::MyClassPrx::opSBoolS(const SBoolS& iceP_i, SBoolS& iceP_o, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<SBoolS, SBoolS>>(true, this, &MyClassPrx::_iceI_opSBoolS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::SBoolS, ::Test::SBoolS>>
Test::MyClassPrx::opSBoolSAsync(const SBoolS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<SBoolS, SBoolS>>(false, this, &MyClassPrx::_iceI_opSBoolS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opSBoolSAsync(const SBoolS& iceP_i, ::std::function<void(::Test::SBoolS, ::Test::SBoolS)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<SBoolS, SBoolS>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<SBoolS, SBoolS>>(std::move(responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opSBoolS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opSBoolS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<SBoolS, SBoolS>>>& outAsync, const SBoolS& iceP_i, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opSBoolS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<SBoolS, SBoolS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::AShortS
Test::MyClassPrx::opAShortS(const AShortS& iceP_i, AShortS& iceP_o, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<AShortS, AShortS>>(true, this, &MyClassPrx::_iceI_opAShortS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::AShortS, ::Test::AShortS>>
Test::MyClassPrx::opAShortSAsync(const AShortS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<AShortS, AShortS>>(false, this, &MyClassPrx::_iceI_opAShortS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opAShortSAsync(const AShortS& iceP_i, ::std::function<void(::Test::AShortS, ::Test::AShortS)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<AShortS, AShortS>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<AShortS, AShortS>>(std::move(responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opAShortS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opAShortS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<AShortS, AShortS>>>& outAsync, const AShortS& iceP_i, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opAShortS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<AShortS, AShortS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::LShortS
Test::MyClassPrx::opLShortS(const LShortS& iceP_i, LShortS& iceP_o, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<LShortS, LShortS>>(true, this, &MyClassPrx::_iceI_opLShortS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::LShortS, ::Test::LShortS>>
Test::MyClassPrx::opLShortSAsync(const LShortS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<LShortS, LShortS>>(false, this, &MyClassPrx::_iceI_opLShortS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opLShortSAsync(const LShortS& iceP_i, ::std::function<void(::Test::LShortS, ::Test::LShortS)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<LShortS, LShortS>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<LShortS, LShortS>>(std::move(responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opLShortS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opLShortS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<LShortS, LShortS>>>& outAsync, const LShortS& iceP_i, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opLShortS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<LShortS, LShortS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::KShortS
Test::MyClassPrx::opKShortS(const KShortS& iceP_i, KShortS& iceP_o, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<KShortS, KShortS>>(true, this, &MyClassPrx::_iceI_opKShortS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::KShortS, ::Test::KShortS>>
Test::MyClassPrx::opKShortSAsync(const KShortS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<KShortS, KShortS>>(false, this, &MyClassPrx::_iceI_opKShortS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opKShortSAsync(const KShortS& iceP_i, ::std::function<void(::Test::KShortS, ::Test::KShortS)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<KShortS, KShortS>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<KShortS, KShortS>>(std::move(responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opKShortS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opKShortS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<KShortS, KShortS>>>& outAsync, const KShortS& iceP_i, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opKShortS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<KShortS, KShortS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::QShortS
Test::MyClassPrx::opQShortS(const QShortS& iceP_i, QShortS& iceP_o, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<QShortS, QShortS>>(true, this, &MyClassPrx::_iceI_opQShortS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::QShortS, ::Test::QShortS>>
Test::MyClassPrx::opQShortSAsync(const QShortS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<QShortS, QShortS>>(false, this, &MyClassPrx::_iceI_opQShortS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opQShortSAsync(const QShortS& iceP_i, ::std::function<void(::Test::QShortS, ::Test::QShortS)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<QShortS, QShortS>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<QShortS, QShortS>>(std::move(responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opQShortS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opQShortS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<QShortS, QShortS>>>& outAsync, const QShortS& iceP_i, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opQShortS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<QShortS, QShortS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::SShortS
Test::MyClassPrx::opSShortS(const SShortS& iceP_i, SShortS& iceP_o, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<SShortS, SShortS>>(true, this, &MyClassPrx::_iceI_opSShortS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::SShortS, ::Test::SShortS>>
Test::MyClassPrx::opSShortSAsync(const SShortS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<SShortS, SShortS>>(false, this, &MyClassPrx::_iceI_opSShortS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opSShortSAsync(const SShortS& iceP_i, ::std::function<void(::Test::SShortS, ::Test::SShortS)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<SShortS, SShortS>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<SShortS, SShortS>>(std::move(responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opSShortS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opSShortS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<SShortS, SShortS>>>& outAsync, const SShortS& iceP_i, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opSShortS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<SShortS, SShortS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::AIntS
Test::MyClassPrx::opAIntS(const AIntS& iceP_i, AIntS& iceP_o, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<AIntS, AIntS>>(true, this, &MyClassPrx::_iceI_opAIntS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::AIntS, ::Test::AIntS>>
Test::MyClassPrx::opAIntSAsync(const AIntS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<AIntS, AIntS>>(false, this, &MyClassPrx::_iceI_opAIntS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opAIntSAsync(const AIntS& iceP_i, ::std::function<void(::Test::AIntS, ::Test::AIntS)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<AIntS, AIntS>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<AIntS, AIntS>>(std::move(responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opAIntS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opAIntS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<AIntS, AIntS>>>& outAsync, const AIntS& iceP_i, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opAIntS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<AIntS, AIntS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::LIntS
Test::MyClassPrx::opLIntS(const LIntS& iceP_i, LIntS& iceP_o, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<LIntS, LIntS>>(true, this, &MyClassPrx::_iceI_opLIntS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::LIntS, ::Test::LIntS>>
Test::MyClassPrx::opLIntSAsync(const LIntS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<LIntS, LIntS>>(false, this, &MyClassPrx::_iceI_opLIntS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opLIntSAsync(const LIntS& iceP_i, ::std::function<void(::Test::LIntS, ::Test::LIntS)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<LIntS, LIntS>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<LIntS, LIntS>>(std::move(responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opLIntS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opLIntS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<LIntS, LIntS>>>& outAsync, const LIntS& iceP_i, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opLIntS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<LIntS, LIntS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::KIntS
Test::MyClassPrx::opKIntS(const KIntS& iceP_i, KIntS& iceP_o, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<KIntS, KIntS>>(true, this, &MyClassPrx::_iceI_opKIntS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::KIntS, ::Test::KIntS>>
Test::MyClassPrx::opKIntSAsync(const KIntS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<KIntS, KIntS>>(false, this, &MyClassPrx::_iceI_opKIntS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opKIntSAsync(const KIntS& iceP_i, ::std::function<void(::Test::KIntS, ::Test::KIntS)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<KIntS, KIntS>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<KIntS, KIntS>>(std::move(responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opKIntS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opKIntS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<KIntS, KIntS>>>& outAsync, const KIntS& iceP_i, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opKIntS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<KIntS, KIntS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::QIntS
Test::MyClassPrx::opQIntS(const QIntS& iceP_i, QIntS& iceP_o, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<QIntS, QIntS>>(true, this, &MyClassPrx::_iceI_opQIntS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::QIntS, ::Test::QIntS>>
Test::MyClassPrx::opQIntSAsync(const QIntS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<QIntS, QIntS>>(false, this, &MyClassPrx::_iceI_opQIntS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opQIntSAsync(const QIntS& iceP_i, ::std::function<void(::Test::QIntS, ::Test::QIntS)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<QIntS, QIntS>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<QIntS, QIntS>>(std::move(responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opQIntS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opQIntS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<QIntS, QIntS>>>& outAsync, const QIntS& iceP_i, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opQIntS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<QIntS, QIntS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::SIntS
Test::MyClassPrx::opSIntS(const SIntS& iceP_i, SIntS& iceP_o, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<SIntS, SIntS>>(true, this, &MyClassPrx::_iceI_opSIntS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::SIntS, ::Test::SIntS>>
Test::MyClassPrx::opSIntSAsync(const SIntS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<SIntS, SIntS>>(false, this, &MyClassPrx::_iceI_opSIntS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opSIntSAsync(const SIntS& iceP_i, ::std::function<void(::Test::SIntS, ::Test::SIntS)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<SIntS, SIntS>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<SIntS, SIntS>>(std::move(responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opSIntS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opSIntS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<SIntS, SIntS>>>& outAsync, const SIntS& iceP_i, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opSIntS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<SIntS, SIntS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::ALongS
Test::MyClassPrx::opALongS(const ALongS& iceP_i, ALongS& iceP_o, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<ALongS, ALongS>>(true, this, &MyClassPrx::_iceI_opALongS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::ALongS, ::Test::ALongS>>
Test::MyClassPrx::opALongSAsync(const ALongS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<ALongS, ALongS>>(false, this, &MyClassPrx::_iceI_opALongS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opALongSAsync(const ALongS& iceP_i, ::std::function<void(::Test::ALongS, ::Test::ALongS)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<ALongS, ALongS>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<ALongS, ALongS>>(std::move(responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opALongS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opALongS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<ALongS, ALongS>>>& outAsync, const ALongS& iceP_i, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opALongS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<ALongS, ALongS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::LLongS
Test::MyClassPrx::opLLongS(const LLongS& iceP_i, LLongS& iceP_o, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<LLongS, LLongS>>(true, this, &MyClassPrx::_iceI_opLLongS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::LLongS, ::Test::LLongS>>
Test::MyClassPrx::opLLongSAsync(const LLongS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<LLongS, LLongS>>(false, this, &MyClassPrx::_iceI_opLLongS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opLLongSAsync(const LLongS& iceP_i, ::std::function<void(::Test::LLongS, ::Test::LLongS)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<LLongS, LLongS>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<LLongS, LLongS>>(std::move(responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opLLongS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opLLongS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<LLongS, LLongS>>>& outAsync, const LLongS& iceP_i, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opLLongS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<LLongS, LLongS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::KLongS
Test::MyClassPrx::opKLongS(const KLongS& iceP_i, KLongS& iceP_o, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<KLongS, KLongS>>(true, this, &MyClassPrx::_iceI_opKLongS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::KLongS, ::Test::KLongS>>
Test::MyClassPrx::opKLongSAsync(const KLongS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<KLongS, KLongS>>(false, this, &MyClassPrx::_iceI_opKLongS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opKLongSAsync(const KLongS& iceP_i, ::std::function<void(::Test::KLongS, ::Test::KLongS)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<KLongS, KLongS>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<KLongS, KLongS>>(std::move(responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opKLongS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opKLongS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<KLongS, KLongS>>>& outAsync, const KLongS& iceP_i, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opKLongS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<KLongS, KLongS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::QLongS
Test::MyClassPrx::opQLongS(const QLongS& iceP_i, QLongS& iceP_o, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<QLongS, QLongS>>(true, this, &MyClassPrx::_iceI_opQLongS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::QLongS, ::Test::QLongS>>
Test::MyClassPrx::opQLongSAsync(const QLongS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<QLongS, QLongS>>(false, this, &MyClassPrx::_iceI_opQLongS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opQLongSAsync(const QLongS& iceP_i, ::std::function<void(::Test::QLongS, ::Test::QLongS)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<QLongS, QLongS>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<QLongS, QLongS>>(std::move(responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opQLongS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opQLongS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<QLongS, QLongS>>>& outAsync, const QLongS& iceP_i, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opQLongS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<QLongS, QLongS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::SLongS
Test::MyClassPrx::opSLongS(const SLongS& iceP_i, SLongS& iceP_o, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<SLongS, SLongS>>(true, this, &MyClassPrx::_iceI_opSLongS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::SLongS, ::Test::SLongS>>
Test::MyClassPrx::opSLongSAsync(const SLongS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<SLongS, SLongS>>(false, this, &MyClassPrx::_iceI_opSLongS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opSLongSAsync(const SLongS& iceP_i, ::std::function<void(::Test::SLongS, ::Test::SLongS)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<SLongS, SLongS>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<SLongS, SLongS>>(std::move(responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opSLongS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opSLongS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<SLongS, SLongS>>>& outAsync, const SLongS& iceP_i, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opSLongS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<SLongS, SLongS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::AFloatS
Test::MyClassPrx::opAFloatS(const AFloatS& iceP_i, AFloatS& iceP_o, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<AFloatS, AFloatS>>(true, this, &MyClassPrx::_iceI_opAFloatS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::AFloatS, ::Test::AFloatS>>
Test::MyClassPrx::opAFloatSAsync(const AFloatS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<AFloatS, AFloatS>>(false, this, &MyClassPrx::_iceI_opAFloatS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opAFloatSAsync(const AFloatS& iceP_i, ::std::function<void(::Test::AFloatS, ::Test::AFloatS)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<AFloatS, AFloatS>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<AFloatS, AFloatS>>(std::move(responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opAFloatS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opAFloatS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<AFloatS, AFloatS>>>& outAsync, const AFloatS& iceP_i, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opAFloatS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<AFloatS, AFloatS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::LFloatS
Test::MyClassPrx::opLFloatS(const LFloatS& iceP_i, LFloatS& iceP_o, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<LFloatS, LFloatS>>(true, this, &MyClassPrx::_iceI_opLFloatS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::LFloatS, ::Test::LFloatS>>
Test::MyClassPrx::opLFloatSAsync(const LFloatS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<LFloatS, LFloatS>>(false, this, &MyClassPrx::_iceI_opLFloatS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opLFloatSAsync(const LFloatS& iceP_i, ::std::function<void(::Test::LFloatS, ::Test::LFloatS)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<LFloatS, LFloatS>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<LFloatS, LFloatS>>(std::move(responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opLFloatS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opLFloatS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<LFloatS, LFloatS>>>& outAsync, const LFloatS& iceP_i, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opLFloatS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<LFloatS, LFloatS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::KFloatS
Test::MyClassPrx::opKFloatS(const KFloatS& iceP_i, KFloatS& iceP_o, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<KFloatS, KFloatS>>(true, this, &MyClassPrx::_iceI_opKFloatS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::KFloatS, ::Test::KFloatS>>
Test::MyClassPrx::opKFloatSAsync(const KFloatS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<KFloatS, KFloatS>>(false, this, &MyClassPrx::_iceI_opKFloatS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opKFloatSAsync(const KFloatS& iceP_i, ::std::function<void(::Test::KFloatS, ::Test::KFloatS)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<KFloatS, KFloatS>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<KFloatS, KFloatS>>(std::move(responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opKFloatS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opKFloatS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<KFloatS, KFloatS>>>& outAsync, const KFloatS& iceP_i, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opKFloatS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<KFloatS, KFloatS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::QFloatS
Test::MyClassPrx::opQFloatS(const QFloatS& iceP_i, QFloatS& iceP_o, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<QFloatS, QFloatS>>(true, this, &MyClassPrx::_iceI_opQFloatS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::QFloatS, ::Test::QFloatS>>
Test::MyClassPrx::opQFloatSAsync(const QFloatS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<QFloatS, QFloatS>>(false, this, &MyClassPrx::_iceI_opQFloatS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opQFloatSAsync(const QFloatS& iceP_i, ::std::function<void(::Test::QFloatS, ::Test::QFloatS)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<QFloatS, QFloatS>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<QFloatS, QFloatS>>(std::move(responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opQFloatS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opQFloatS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<QFloatS, QFloatS>>>& outAsync, const QFloatS& iceP_i, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opQFloatS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<QFloatS, QFloatS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::SFloatS
Test::MyClassPrx::opSFloatS(const SFloatS& iceP_i, SFloatS& iceP_o, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<SFloatS, SFloatS>>(true, this, &MyClassPrx::_iceI_opSFloatS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::SFloatS, ::Test::SFloatS>>
Test::MyClassPrx::opSFloatSAsync(const SFloatS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<SFloatS, SFloatS>>(false, this, &MyClassPrx::_iceI_opSFloatS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opSFloatSAsync(const SFloatS& iceP_i, ::std::function<void(::Test::SFloatS, ::Test::SFloatS)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<SFloatS, SFloatS>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<SFloatS, SFloatS>>(std::move(responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opSFloatS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opSFloatS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<SFloatS, SFloatS>>>& outAsync, const SFloatS& iceP_i, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opSFloatS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<SFloatS, SFloatS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::ADoubleS
Test::MyClassPrx::opADoubleS(const ADoubleS& iceP_i, ADoubleS& iceP_o, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<ADoubleS, ADoubleS>>(true, this, &MyClassPrx::_iceI_opADoubleS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::ADoubleS, ::Test::ADoubleS>>
Test::MyClassPrx::opADoubleSAsync(const ADoubleS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<ADoubleS, ADoubleS>>(false, this, &MyClassPrx::_iceI_opADoubleS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opADoubleSAsync(const ADoubleS& iceP_i, ::std::function<void(::Test::ADoubleS, ::Test::ADoubleS)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<ADoubleS, ADoubleS>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<ADoubleS, ADoubleS>>(std::move(responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opADoubleS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opADoubleS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<ADoubleS, ADoubleS>>>& outAsync, const ADoubleS& iceP_i, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opADoubleS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<ADoubleS, ADoubleS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::LDoubleS
Test::MyClassPrx::opLDoubleS(const LDoubleS& iceP_i, LDoubleS& iceP_o, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<LDoubleS, LDoubleS>>(true, this, &MyClassPrx::_iceI_opLDoubleS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::LDoubleS, ::Test::LDoubleS>>
Test::MyClassPrx::opLDoubleSAsync(const LDoubleS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<LDoubleS, LDoubleS>>(false, this, &MyClassPrx::_iceI_opLDoubleS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opLDoubleSAsync(const LDoubleS& iceP_i, ::std::function<void(::Test::LDoubleS, ::Test::LDoubleS)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<LDoubleS, LDoubleS>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<LDoubleS, LDoubleS>>(std::move(responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opLDoubleS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opLDoubleS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<LDoubleS, LDoubleS>>>& outAsync, const LDoubleS& iceP_i, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opLDoubleS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<LDoubleS, LDoubleS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::KDoubleS
Test::MyClassPrx::opKDoubleS(const KDoubleS& iceP_i, KDoubleS& iceP_o, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<KDoubleS, KDoubleS>>(true, this, &MyClassPrx::_iceI_opKDoubleS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::KDoubleS, ::Test::KDoubleS>>
Test::MyClassPrx::opKDoubleSAsync(const KDoubleS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<KDoubleS, KDoubleS>>(false, this, &MyClassPrx::_iceI_opKDoubleS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opKDoubleSAsync(const KDoubleS& iceP_i, ::std::function<void(::Test::KDoubleS, ::Test::KDoubleS)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<KDoubleS, KDoubleS>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<KDoubleS, KDoubleS>>(std::move(responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opKDoubleS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opKDoubleS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<KDoubleS, KDoubleS>>>& outAsync, const KDoubleS& iceP_i, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opKDoubleS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<KDoubleS, KDoubleS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::QDoubleS
Test::MyClassPrx::opQDoubleS(const QDoubleS& iceP_i, QDoubleS& iceP_o, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<QDoubleS, QDoubleS>>(true, this, &MyClassPrx::_iceI_opQDoubleS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::QDoubleS, ::Test::QDoubleS>>
Test::MyClassPrx::opQDoubleSAsync(const QDoubleS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<QDoubleS, QDoubleS>>(false, this, &MyClassPrx::_iceI_opQDoubleS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opQDoubleSAsync(const QDoubleS& iceP_i, ::std::function<void(::Test::QDoubleS, ::Test::QDoubleS)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<QDoubleS, QDoubleS>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<QDoubleS, QDoubleS>>(std::move(responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opQDoubleS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opQDoubleS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<QDoubleS, QDoubleS>>>& outAsync, const QDoubleS& iceP_i, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opQDoubleS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<QDoubleS, QDoubleS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::SDoubleS
Test::MyClassPrx::opSDoubleS(const SDoubleS& iceP_i, SDoubleS& iceP_o, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<SDoubleS, SDoubleS>>(true, this, &MyClassPrx::_iceI_opSDoubleS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::SDoubleS, ::Test::SDoubleS>>
Test::MyClassPrx::opSDoubleSAsync(const SDoubleS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<SDoubleS, SDoubleS>>(false, this, &MyClassPrx::_iceI_opSDoubleS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opSDoubleSAsync(const SDoubleS& iceP_i, ::std::function<void(::Test::SDoubleS, ::Test::SDoubleS)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<SDoubleS, SDoubleS>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<SDoubleS, SDoubleS>>(std::move(responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opSDoubleS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opSDoubleS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<SDoubleS, SDoubleS>>>& outAsync, const SDoubleS& iceP_i, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opSDoubleS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<SDoubleS, SDoubleS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::AStringS
Test::MyClassPrx::opAStringS(const AStringS& iceP_i, AStringS& iceP_o, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<AStringS, AStringS>>(true, this, &MyClassPrx::_iceI_opAStringS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::AStringS, ::Test::AStringS>>
Test::MyClassPrx::opAStringSAsync(const AStringS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<AStringS, AStringS>>(false, this, &MyClassPrx::_iceI_opAStringS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opAStringSAsync(const AStringS& iceP_i, ::std::function<void(::Test::AStringS, ::Test::AStringS)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<AStringS, AStringS>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<AStringS, AStringS>>(std::move(responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opAStringS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opAStringS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<AStringS, AStringS>>>& outAsync, const AStringS& iceP_i, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opAStringS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<AStringS, AStringS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::LStringS
Test::MyClassPrx::opLStringS(const LStringS& iceP_i, LStringS& iceP_o, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<LStringS, LStringS>>(true, this, &MyClassPrx::_iceI_opLStringS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::LStringS, ::Test::LStringS>>
Test::MyClassPrx::opLStringSAsync(const LStringS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<LStringS, LStringS>>(false, this, &MyClassPrx::_iceI_opLStringS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opLStringSAsync(const LStringS& iceP_i, ::std::function<void(::Test::LStringS, ::Test::LStringS)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<LStringS, LStringS>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<LStringS, LStringS>>(std::move(responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opLStringS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opLStringS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<LStringS, LStringS>>>& outAsync, const LStringS& iceP_i, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opLStringS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<LStringS, LStringS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::KStringS
Test::MyClassPrx::opKStringS(const KStringS& iceP_i, KStringS& iceP_o, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<KStringS, KStringS>>(true, this, &MyClassPrx::_iceI_opKStringS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::KStringS, ::Test::KStringS>>
Test::MyClassPrx::opKStringSAsync(const KStringS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<KStringS, KStringS>>(false, this, &MyClassPrx::_iceI_opKStringS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opKStringSAsync(const KStringS& iceP_i, ::std::function<void(::Test::KStringS, ::Test::KStringS)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<KStringS, KStringS>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<KStringS, KStringS>>(std::move(responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opKStringS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opKStringS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<KStringS, KStringS>>>& outAsync, const KStringS& iceP_i, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opKStringS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<KStringS, KStringS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::QStringS
Test::MyClassPrx::opQStringS(const QStringS& iceP_i, QStringS& iceP_o, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<QStringS, QStringS>>(true, this, &MyClassPrx::_iceI_opQStringS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::QStringS, ::Test::QStringS>>
Test::MyClassPrx::opQStringSAsync(const QStringS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<QStringS, QStringS>>(false, this, &MyClassPrx::_iceI_opQStringS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opQStringSAsync(const QStringS& iceP_i, ::std::function<void(::Test::QStringS, ::Test::QStringS)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<QStringS, QStringS>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<QStringS, QStringS>>(std::move(responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opQStringS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opQStringS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<QStringS, QStringS>>>& outAsync, const QStringS& iceP_i, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opQStringS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<QStringS, QStringS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::SStringS
Test::MyClassPrx::opSStringS(const SStringS& iceP_i, SStringS& iceP_o, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<SStringS, SStringS>>(true, this, &MyClassPrx::_iceI_opSStringS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::SStringS, ::Test::SStringS>>
Test::MyClassPrx::opSStringSAsync(const SStringS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<SStringS, SStringS>>(false, this, &MyClassPrx::_iceI_opSStringS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opSStringSAsync(const SStringS& iceP_i, ::std::function<void(::Test::SStringS, ::Test::SStringS)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<SStringS, SStringS>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<SStringS, SStringS>>(std::move(responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opSStringS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opSStringS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<SStringS, SStringS>>>& outAsync, const SStringS& iceP_i, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opSStringS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<SStringS, SStringS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::AObjectS
Test::MyClassPrx::opAObjectS(const AObjectS& iceP_i, AObjectS& iceP_o, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<AObjectS, AObjectS>>(true, this, &MyClassPrx::_iceI_opAObjectS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::AObjectS, ::Test::AObjectS>>
Test::MyClassPrx::opAObjectSAsync(const AObjectS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<AObjectS, AObjectS>>(false, this, &MyClassPrx::_iceI_opAObjectS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opAObjectSAsync(const AObjectS& iceP_i, ::std::function<void(::Test::AObjectS, ::Test::AObjectS)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<AObjectS, AObjectS>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<AObjectS, AObjectS>>(std::move(responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opAObjectS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opAObjectS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<AObjectS, AObjectS>>>& outAsync, const AObjectS& iceP_i, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opAObjectS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
            ostr->writePendingValues();
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<AObjectS, AObjectS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            istr->readPendingValues();
            return v;
        });
}

::Test::LObjectS
Test::MyClassPrx::opLObjectS(const LObjectS& iceP_i, LObjectS& iceP_o, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<LObjectS, LObjectS>>(true, this, &MyClassPrx::_iceI_opLObjectS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::LObjectS, ::Test::LObjectS>>
Test::MyClassPrx::opLObjectSAsync(const LObjectS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<LObjectS, LObjectS>>(false, this, &MyClassPrx::_iceI_opLObjectS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opLObjectSAsync(const LObjectS& iceP_i, ::std::function<void(::Test::LObjectS, ::Test::LObjectS)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<LObjectS, LObjectS>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<LObjectS, LObjectS>>(std::move(responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opLObjectS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opLObjectS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<LObjectS, LObjectS>>>& outAsync, const LObjectS& iceP_i, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opLObjectS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
            ostr->writePendingValues();
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<LObjectS, LObjectS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            istr->readPendingValues();
            return v;
        });
}

::Test::AObjectPrxS
Test::MyClassPrx::opAObjectPrxS(const AObjectPrxS& iceP_i, AObjectPrxS& iceP_o, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<AObjectPrxS, AObjectPrxS>>(true, this, &MyClassPrx::_iceI_opAObjectPrxS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::AObjectPrxS, ::Test::AObjectPrxS>>
Test::MyClassPrx::opAObjectPrxSAsync(const AObjectPrxS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<AObjectPrxS, AObjectPrxS>>(false, this, &MyClassPrx::_iceI_opAObjectPrxS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opAObjectPrxSAsync(const AObjectPrxS& iceP_i, ::std::function<void(::Test::AObjectPrxS, ::Test::AObjectPrxS)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<AObjectPrxS, AObjectPrxS>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<AObjectPrxS, AObjectPrxS>>(std::move(responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opAObjectPrxS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opAObjectPrxS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<AObjectPrxS, AObjectPrxS>>>& outAsync, const AObjectPrxS& iceP_i, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opAObjectPrxS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<AObjectPrxS, AObjectPrxS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::LObjectPrxS
Test::MyClassPrx::opLObjectPrxS(const LObjectPrxS& iceP_i, LObjectPrxS& iceP_o, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<LObjectPrxS, LObjectPrxS>>(true, this, &MyClassPrx::_iceI_opLObjectPrxS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::LObjectPrxS, ::Test::LObjectPrxS>>
Test::MyClassPrx::opLObjectPrxSAsync(const LObjectPrxS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<LObjectPrxS, LObjectPrxS>>(false, this, &MyClassPrx::_iceI_opLObjectPrxS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opLObjectPrxSAsync(const LObjectPrxS& iceP_i, ::std::function<void(::Test::LObjectPrxS, ::Test::LObjectPrxS)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<LObjectPrxS, LObjectPrxS>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<LObjectPrxS, LObjectPrxS>>(std::move(responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opLObjectPrxS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opLObjectPrxS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<LObjectPrxS, LObjectPrxS>>>& outAsync, const LObjectPrxS& iceP_i, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opLObjectPrxS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<LObjectPrxS, LObjectPrxS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::KObjectPrxS
Test::MyClassPrx::opKObjectPrxS(const KObjectPrxS& iceP_i, KObjectPrxS& iceP_o, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<KObjectPrxS, KObjectPrxS>>(true, this, &MyClassPrx::_iceI_opKObjectPrxS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::KObjectPrxS, ::Test::KObjectPrxS>>
Test::MyClassPrx::opKObjectPrxSAsync(const KObjectPrxS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<KObjectPrxS, KObjectPrxS>>(false, this, &MyClassPrx::_iceI_opKObjectPrxS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opKObjectPrxSAsync(const KObjectPrxS& iceP_i, ::std::function<void(::Test::KObjectPrxS, ::Test::KObjectPrxS)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<KObjectPrxS, KObjectPrxS>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<KObjectPrxS, KObjectPrxS>>(std::move(responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opKObjectPrxS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opKObjectPrxS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<KObjectPrxS, KObjectPrxS>>>& outAsync, const KObjectPrxS& iceP_i, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opKObjectPrxS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<KObjectPrxS, KObjectPrxS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::QObjectPrxS
Test::MyClassPrx::opQObjectPrxS(const QObjectPrxS& iceP_i, QObjectPrxS& iceP_o, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<QObjectPrxS, QObjectPrxS>>(true, this, &MyClassPrx::_iceI_opQObjectPrxS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::QObjectPrxS, ::Test::QObjectPrxS>>
Test::MyClassPrx::opQObjectPrxSAsync(const QObjectPrxS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<QObjectPrxS, QObjectPrxS>>(false, this, &MyClassPrx::_iceI_opQObjectPrxS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opQObjectPrxSAsync(const QObjectPrxS& iceP_i, ::std::function<void(::Test::QObjectPrxS, ::Test::QObjectPrxS)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<QObjectPrxS, QObjectPrxS>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<QObjectPrxS, QObjectPrxS>>(std::move(responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opQObjectPrxS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opQObjectPrxS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<QObjectPrxS, QObjectPrxS>>>& outAsync, const QObjectPrxS& iceP_i, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opQObjectPrxS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<QObjectPrxS, QObjectPrxS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::SObjectPrxS
Test::MyClassPrx::opSObjectPrxS(const SObjectPrxS& iceP_i, SObjectPrxS& iceP_o, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<SObjectPrxS, SObjectPrxS>>(true, this, &MyClassPrx::_iceI_opSObjectPrxS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::SObjectPrxS, ::Test::SObjectPrxS>>
Test::MyClassPrx::opSObjectPrxSAsync(const SObjectPrxS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<SObjectPrxS, SObjectPrxS>>(false, this, &MyClassPrx::_iceI_opSObjectPrxS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opSObjectPrxSAsync(const SObjectPrxS& iceP_i, ::std::function<void(::Test::SObjectPrxS, ::Test::SObjectPrxS)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<SObjectPrxS, SObjectPrxS>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<SObjectPrxS, SObjectPrxS>>(std::move(responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opSObjectPrxS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opSObjectPrxS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<SObjectPrxS, SObjectPrxS>>>& outAsync, const SObjectPrxS& iceP_i, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opSObjectPrxS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<SObjectPrxS, SObjectPrxS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::AStructS
Test::MyClassPrx::opAStructS(const AStructS& iceP_i, AStructS& iceP_o, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<AStructS, AStructS>>(true, this, &MyClassPrx::_iceI_opAStructS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::AStructS, ::Test::AStructS>>
Test::MyClassPrx::opAStructSAsync(const AStructS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<AStructS, AStructS>>(false, this, &MyClassPrx::_iceI_opAStructS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opAStructSAsync(const AStructS& iceP_i, ::std::function<void(::Test::AStructS, ::Test::AStructS)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<AStructS, AStructS>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<AStructS, AStructS>>(std::move(responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opAStructS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opAStructS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<AStructS, AStructS>>>& outAsync, const AStructS& iceP_i, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opAStructS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<AStructS, AStructS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::LStructS
Test::MyClassPrx::opLStructS(const LStructS& iceP_i, LStructS& iceP_o, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<LStructS, LStructS>>(true, this, &MyClassPrx::_iceI_opLStructS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::LStructS, ::Test::LStructS>>
Test::MyClassPrx::opLStructSAsync(const LStructS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<LStructS, LStructS>>(false, this, &MyClassPrx::_iceI_opLStructS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opLStructSAsync(const LStructS& iceP_i, ::std::function<void(::Test::LStructS, ::Test::LStructS)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<LStructS, LStructS>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<LStructS, LStructS>>(std::move(responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opLStructS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opLStructS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<LStructS, LStructS>>>& outAsync, const LStructS& iceP_i, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opLStructS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<LStructS, LStructS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::KStructS
Test::MyClassPrx::opKStructS(const KStructS& iceP_i, KStructS& iceP_o, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<KStructS, KStructS>>(true, this, &MyClassPrx::_iceI_opKStructS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::KStructS, ::Test::KStructS>>
Test::MyClassPrx::opKStructSAsync(const KStructS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<KStructS, KStructS>>(false, this, &MyClassPrx::_iceI_opKStructS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opKStructSAsync(const KStructS& iceP_i, ::std::function<void(::Test::KStructS, ::Test::KStructS)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<KStructS, KStructS>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<KStructS, KStructS>>(std::move(responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opKStructS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opKStructS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<KStructS, KStructS>>>& outAsync, const KStructS& iceP_i, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opKStructS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<KStructS, KStructS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::QStructS
Test::MyClassPrx::opQStructS(const QStructS& iceP_i, QStructS& iceP_o, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<QStructS, QStructS>>(true, this, &MyClassPrx::_iceI_opQStructS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::QStructS, ::Test::QStructS>>
Test::MyClassPrx::opQStructSAsync(const QStructS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<QStructS, QStructS>>(false, this, &MyClassPrx::_iceI_opQStructS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opQStructSAsync(const QStructS& iceP_i, ::std::function<void(::Test::QStructS, ::Test::QStructS)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<QStructS, QStructS>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<QStructS, QStructS>>(std::move(responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opQStructS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opQStructS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<QStructS, QStructS>>>& outAsync, const QStructS& iceP_i, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opQStructS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<QStructS, QStructS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::SStructS
Test::MyClassPrx::opSStructS(const SStructS& iceP_i, SStructS& iceP_o, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<SStructS, SStructS>>(true, this, &MyClassPrx::_iceI_opSStructS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::SStructS, ::Test::SStructS>>
Test::MyClassPrx::opSStructSAsync(const SStructS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<SStructS, SStructS>>(false, this, &MyClassPrx::_iceI_opSStructS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opSStructSAsync(const SStructS& iceP_i, ::std::function<void(::Test::SStructS, ::Test::SStructS)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<SStructS, SStructS>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<SStructS, SStructS>>(std::move(responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opSStructS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opSStructS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<SStructS, SStructS>>>& outAsync, const SStructS& iceP_i, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opSStructS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<SStructS, SStructS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::AStructSD
Test::MyClassPrx::opAStructSD(const AStructSD& iceP_i, AStructSD& iceP_o, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<AStructSD, AStructSD>>(true, this, &MyClassPrx::_iceI_opAStructSD, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::AStructSD, ::Test::AStructSD>>
Test::MyClassPrx::opAStructSDAsync(const AStructSD& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<AStructSD, AStructSD>>(false, this, &MyClassPrx::_iceI_opAStructSD, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opAStructSDAsync(const AStructSD& iceP_i, ::std::function<void(::Test::AStructSD, ::Test::AStructSD)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<AStructSD, AStructSD>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<AStructSD, AStructSD>>(std::move(responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opAStructSD, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opAStructSD(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<AStructSD, AStructSD>>>& outAsync, const AStructSD& iceP_i, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opAStructSD";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<AStructSD, AStructSD> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::LStructSD
Test::MyClassPrx::opLStructSD(const LStructSD& iceP_i, LStructSD& iceP_o, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<LStructSD, LStructSD>>(true, this, &MyClassPrx::_iceI_opLStructSD, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::LStructSD, ::Test::LStructSD>>
Test::MyClassPrx::opLStructSDAsync(const LStructSD& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<LStructSD, LStructSD>>(false, this, &MyClassPrx::_iceI_opLStructSD, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opLStructSDAsync(const LStructSD& iceP_i, ::std::function<void(::Test::LStructSD, ::Test::LStructSD)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<LStructSD, LStructSD>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<LStructSD, LStructSD>>(std::move(responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opLStructSD, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opLStructSD(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<LStructSD, LStructSD>>>& outAsync, const LStructSD& iceP_i, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opLStructSD";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<LStructSD, LStructSD> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::KStructSD
Test::MyClassPrx::opKStructSD(const KStructSD& iceP_i, KStructSD& iceP_o, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<KStructSD, KStructSD>>(true, this, &MyClassPrx::_iceI_opKStructSD, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::KStructSD, ::Test::KStructSD>>
Test::MyClassPrx::opKStructSDAsync(const KStructSD& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<KStructSD, KStructSD>>(false, this, &MyClassPrx::_iceI_opKStructSD, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opKStructSDAsync(const KStructSD& iceP_i, ::std::function<void(::Test::KStructSD, ::Test::KStructSD)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<KStructSD, KStructSD>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<KStructSD, KStructSD>>(std::move(responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opKStructSD, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opKStructSD(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<KStructSD, KStructSD>>>& outAsync, const KStructSD& iceP_i, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opKStructSD";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<KStructSD, KStructSD> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::QStructSD
Test::MyClassPrx::opQStructSD(const QStructSD& iceP_i, QStructSD& iceP_o, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<QStructSD, QStructSD>>(true, this, &MyClassPrx::_iceI_opQStructSD, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::QStructSD, ::Test::QStructSD>>
Test::MyClassPrx::opQStructSDAsync(const QStructSD& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<QStructSD, QStructSD>>(false, this, &MyClassPrx::_iceI_opQStructSD, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opQStructSDAsync(const QStructSD& iceP_i, ::std::function<void(::Test::QStructSD, ::Test::QStructSD)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<QStructSD, QStructSD>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<QStructSD, QStructSD>>(std::move(responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opQStructSD, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opQStructSD(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<QStructSD, QStructSD>>>& outAsync, const QStructSD& iceP_i, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opQStructSD";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<QStructSD, QStructSD> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::SStructSD
Test::MyClassPrx::opSStructSD(const SStructSD& iceP_i, SStructSD& iceP_o, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<SStructSD, SStructSD>>(true, this, &MyClassPrx::_iceI_opSStructSD, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::SStructSD, ::Test::SStructSD>>
Test::MyClassPrx::opSStructSDAsync(const SStructSD& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<SStructSD, SStructSD>>(false, this, &MyClassPrx::_iceI_opSStructSD, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opSStructSDAsync(const SStructSD& iceP_i, ::std::function<void(::Test::SStructSD, ::Test::SStructSD)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<SStructSD, SStructSD>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<SStructSD, SStructSD>>(std::move(responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opSStructSD, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opSStructSD(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<SStructSD, SStructSD>>>& outAsync, const SStructSD& iceP_i, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opSStructSD";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<SStructSD, SStructSD> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::ACVS
Test::MyClassPrx::opACVS(const ACVS& iceP_i, ACVS& iceP_o, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<ACVS, ACVS>>(true, this, &MyClassPrx::_iceI_opACVS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::ACVS, ::Test::ACVS>>
Test::MyClassPrx::opACVSAsync(const ACVS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<ACVS, ACVS>>(false, this, &MyClassPrx::_iceI_opACVS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opACVSAsync(const ACVS& iceP_i, ::std::function<void(::Test::ACVS, ::Test::ACVS)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<ACVS, ACVS>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<ACVS, ACVS>>(std::move(responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opACVS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opACVS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<ACVS, ACVS>>>& outAsync, const ACVS& iceP_i, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opACVS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
            ostr->writePendingValues();
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<ACVS, ACVS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            istr->readPendingValues();
            return v;
        });
}

::Test::LCVS
Test::MyClassPrx::opLCVS(const LCVS& iceP_i, LCVS& iceP_o, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<LCVS, LCVS>>(true, this, &MyClassPrx::_iceI_opLCVS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::LCVS, ::Test::LCVS>>
Test::MyClassPrx::opLCVSAsync(const LCVS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<LCVS, LCVS>>(false, this, &MyClassPrx::_iceI_opLCVS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opLCVSAsync(const LCVS& iceP_i, ::std::function<void(::Test::LCVS, ::Test::LCVS)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<LCVS, LCVS>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<LCVS, LCVS>>(std::move(responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opLCVS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opLCVS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<LCVS, LCVS>>>& outAsync, const LCVS& iceP_i, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opLCVS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
            ostr->writePendingValues();
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<LCVS, LCVS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            istr->readPendingValues();
            return v;
        });
}

::Test::ACRS
Test::MyClassPrx::opACRS(const ACRS& iceP_i, ACRS& iceP_o, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<ACRS, ACRS>>(true, this, &MyClassPrx::_iceI_opACRS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::ACRS, ::Test::ACRS>>
Test::MyClassPrx::opACRSAsync(const ACRS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<ACRS, ACRS>>(false, this, &MyClassPrx::_iceI_opACRS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opACRSAsync(const ACRS& iceP_i, ::std::function<void(::Test::ACRS, ::Test::ACRS)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<ACRS, ACRS>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<ACRS, ACRS>>(std::move(responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opACRS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opACRS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<ACRS, ACRS>>>& outAsync, const ACRS& iceP_i, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opACRS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
            ostr->writePendingValues();
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<ACRS, ACRS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            istr->readPendingValues();
            return v;
        });
}

::Test::LCRS
Test::MyClassPrx::opLCRS(const LCRS& iceP_i, LCRS& iceP_o, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<LCRS, LCRS>>(true, this, &MyClassPrx::_iceI_opLCRS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::LCRS, ::Test::LCRS>>
Test::MyClassPrx::opLCRSAsync(const LCRS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<LCRS, LCRS>>(false, this, &MyClassPrx::_iceI_opLCRS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opLCRSAsync(const LCRS& iceP_i, ::std::function<void(::Test::LCRS, ::Test::LCRS)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<LCRS, LCRS>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<LCRS, LCRS>>(std::move(responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opLCRS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opLCRS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<LCRS, LCRS>>>& outAsync, const LCRS& iceP_i, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opLCRS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
            ostr->writePendingValues();
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<LCRS, LCRS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            istr->readPendingValues();
            return v;
        });
}

::Test::AEnS
Test::MyClassPrx::opAEnS(const AEnS& iceP_i, AEnS& iceP_o, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<AEnS, AEnS>>(true, this, &MyClassPrx::_iceI_opAEnS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::AEnS, ::Test::AEnS>>
Test::MyClassPrx::opAEnSAsync(const AEnS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<AEnS, AEnS>>(false, this, &MyClassPrx::_iceI_opAEnS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opAEnSAsync(const AEnS& iceP_i, ::std::function<void(::Test::AEnS, ::Test::AEnS)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<AEnS, AEnS>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<AEnS, AEnS>>(std::move(responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opAEnS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opAEnS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<AEnS, AEnS>>>& outAsync, const AEnS& iceP_i, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opAEnS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<AEnS, AEnS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::LEnS
Test::MyClassPrx::opLEnS(const LEnS& iceP_i, LEnS& iceP_o, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<LEnS, LEnS>>(true, this, &MyClassPrx::_iceI_opLEnS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::LEnS, ::Test::LEnS>>
Test::MyClassPrx::opLEnSAsync(const LEnS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<LEnS, LEnS>>(false, this, &MyClassPrx::_iceI_opLEnS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opLEnSAsync(const LEnS& iceP_i, ::std::function<void(::Test::LEnS, ::Test::LEnS)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<LEnS, LEnS>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<LEnS, LEnS>>(std::move(responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opLEnS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opLEnS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<LEnS, LEnS>>>& outAsync, const LEnS& iceP_i, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opLEnS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<LEnS, LEnS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::KEnS
Test::MyClassPrx::opKEnS(const KEnS& iceP_i, KEnS& iceP_o, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<KEnS, KEnS>>(true, this, &MyClassPrx::_iceI_opKEnS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::KEnS, ::Test::KEnS>>
Test::MyClassPrx::opKEnSAsync(const KEnS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<KEnS, KEnS>>(false, this, &MyClassPrx::_iceI_opKEnS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opKEnSAsync(const KEnS& iceP_i, ::std::function<void(::Test::KEnS, ::Test::KEnS)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<KEnS, KEnS>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<KEnS, KEnS>>(std::move(responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opKEnS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opKEnS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<KEnS, KEnS>>>& outAsync, const KEnS& iceP_i, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opKEnS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<KEnS, KEnS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::QEnS
Test::MyClassPrx::opQEnS(const QEnS& iceP_i, QEnS& iceP_o, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<QEnS, QEnS>>(true, this, &MyClassPrx::_iceI_opQEnS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::QEnS, ::Test::QEnS>>
Test::MyClassPrx::opQEnSAsync(const QEnS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<QEnS, QEnS>>(false, this, &MyClassPrx::_iceI_opQEnS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opQEnSAsync(const QEnS& iceP_i, ::std::function<void(::Test::QEnS, ::Test::QEnS)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<QEnS, QEnS>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<QEnS, QEnS>>(std::move(responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opQEnS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opQEnS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<QEnS, QEnS>>>& outAsync, const QEnS& iceP_i, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opQEnS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<QEnS, QEnS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::SEnS
Test::MyClassPrx::opSEnS(const SEnS& iceP_i, SEnS& iceP_o, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<SEnS, SEnS>>(true, this, &MyClassPrx::_iceI_opSEnS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::SEnS, ::Test::SEnS>>
Test::MyClassPrx::opSEnSAsync(const SEnS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<SEnS, SEnS>>(false, this, &MyClassPrx::_iceI_opSEnS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opSEnSAsync(const SEnS& iceP_i, ::std::function<void(::Test::SEnS, ::Test::SEnS)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<SEnS, SEnS>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<SEnS, SEnS>>(std::move(responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opSEnS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opSEnS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<SEnS, SEnS>>>& outAsync, const SEnS& iceP_i, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opSEnS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<SEnS, SEnS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::AIPrxS
Test::MyClassPrx::opAIPrxS(const AIPrxS& iceP_i, AIPrxS& iceP_o, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<AIPrxS, AIPrxS>>(true, this, &MyClassPrx::_iceI_opAIPrxS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::AIPrxS, ::Test::AIPrxS>>
Test::MyClassPrx::opAIPrxSAsync(const AIPrxS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<AIPrxS, AIPrxS>>(false, this, &MyClassPrx::_iceI_opAIPrxS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opAIPrxSAsync(const AIPrxS& iceP_i, ::std::function<void(::Test::AIPrxS, ::Test::AIPrxS)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<AIPrxS, AIPrxS>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<AIPrxS, AIPrxS>>(std::move(responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opAIPrxS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opAIPrxS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<AIPrxS, AIPrxS>>>& outAsync, const AIPrxS& iceP_i, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opAIPrxS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<AIPrxS, AIPrxS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::LIPrxS
Test::MyClassPrx::opLIPrxS(const LIPrxS& iceP_i, LIPrxS& iceP_o, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<LIPrxS, LIPrxS>>(true, this, &MyClassPrx::_iceI_opLIPrxS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::LIPrxS, ::Test::LIPrxS>>
Test::MyClassPrx::opLIPrxSAsync(const LIPrxS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<LIPrxS, LIPrxS>>(false, this, &MyClassPrx::_iceI_opLIPrxS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opLIPrxSAsync(const LIPrxS& iceP_i, ::std::function<void(::Test::LIPrxS, ::Test::LIPrxS)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<LIPrxS, LIPrxS>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<LIPrxS, LIPrxS>>(std::move(responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opLIPrxS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opLIPrxS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<LIPrxS, LIPrxS>>>& outAsync, const LIPrxS& iceP_i, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opLIPrxS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<LIPrxS, LIPrxS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::KIPrxS
Test::MyClassPrx::opKIPrxS(const KIPrxS& iceP_i, KIPrxS& iceP_o, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<KIPrxS, KIPrxS>>(true, this, &MyClassPrx::_iceI_opKIPrxS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::KIPrxS, ::Test::KIPrxS>>
Test::MyClassPrx::opKIPrxSAsync(const KIPrxS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<KIPrxS, KIPrxS>>(false, this, &MyClassPrx::_iceI_opKIPrxS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opKIPrxSAsync(const KIPrxS& iceP_i, ::std::function<void(::Test::KIPrxS, ::Test::KIPrxS)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<KIPrxS, KIPrxS>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<KIPrxS, KIPrxS>>(std::move(responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opKIPrxS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opKIPrxS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<KIPrxS, KIPrxS>>>& outAsync, const KIPrxS& iceP_i, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opKIPrxS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<KIPrxS, KIPrxS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::QIPrxS
Test::MyClassPrx::opQIPrxS(const QIPrxS& iceP_i, QIPrxS& iceP_o, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<QIPrxS, QIPrxS>>(true, this, &MyClassPrx::_iceI_opQIPrxS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::QIPrxS, ::Test::QIPrxS>>
Test::MyClassPrx::opQIPrxSAsync(const QIPrxS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<QIPrxS, QIPrxS>>(false, this, &MyClassPrx::_iceI_opQIPrxS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opQIPrxSAsync(const QIPrxS& iceP_i, ::std::function<void(::Test::QIPrxS, ::Test::QIPrxS)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<QIPrxS, QIPrxS>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<QIPrxS, QIPrxS>>(std::move(responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opQIPrxS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opQIPrxS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<QIPrxS, QIPrxS>>>& outAsync, const QIPrxS& iceP_i, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opQIPrxS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<QIPrxS, QIPrxS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::SIPrxS
Test::MyClassPrx::opSIPrxS(const SIPrxS& iceP_i, SIPrxS& iceP_o, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<SIPrxS, SIPrxS>>(true, this, &MyClassPrx::_iceI_opSIPrxS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::SIPrxS, ::Test::SIPrxS>>
Test::MyClassPrx::opSIPrxSAsync(const SIPrxS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<SIPrxS, SIPrxS>>(false, this, &MyClassPrx::_iceI_opSIPrxS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opSIPrxSAsync(const SIPrxS& iceP_i, ::std::function<void(::Test::SIPrxS, ::Test::SIPrxS)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<SIPrxS, SIPrxS>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<SIPrxS, SIPrxS>>(std::move(responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opSIPrxS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opSIPrxS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<SIPrxS, SIPrxS>>>& outAsync, const SIPrxS& iceP_i, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opSIPrxS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<SIPrxS, SIPrxS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::CustomIntS
Test::MyClassPrx::opCustomIntS(const CustomIntS& iceP_i, CustomIntS& iceP_o, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<CustomIntS, CustomIntS>>(true, this, &MyClassPrx::_iceI_opCustomIntS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::CustomIntS, ::Test::CustomIntS>>
Test::MyClassPrx::opCustomIntSAsync(const CustomIntS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<CustomIntS, CustomIntS>>(false, this, &MyClassPrx::_iceI_opCustomIntS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opCustomIntSAsync(const CustomIntS& iceP_i, ::std::function<void(::Test::CustomIntS, ::Test::CustomIntS)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<CustomIntS, CustomIntS>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<CustomIntS, CustomIntS>>(std::move(responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opCustomIntS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opCustomIntS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<CustomIntS, CustomIntS>>>& outAsync, const CustomIntS& iceP_i, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opCustomIntS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<CustomIntS, CustomIntS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::CustomCVS
Test::MyClassPrx::opCustomCVS(const CustomCVS& iceP_i, CustomCVS& iceP_o, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<CustomCVS, CustomCVS>>(true, this, &MyClassPrx::_iceI_opCustomCVS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::CustomCVS, ::Test::CustomCVS>>
Test::MyClassPrx::opCustomCVSAsync(const CustomCVS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<CustomCVS, CustomCVS>>(false, this, &MyClassPrx::_iceI_opCustomCVS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opCustomCVSAsync(const CustomCVS& iceP_i, ::std::function<void(::Test::CustomCVS, ::Test::CustomCVS)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<CustomCVS, CustomCVS>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<CustomCVS, CustomCVS>>(std::move(responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opCustomCVS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opCustomCVS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<CustomCVS, CustomCVS>>>& outAsync, const CustomCVS& iceP_i, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opCustomCVS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
            ostr->writePendingValues();
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<CustomCVS, CustomCVS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            istr->readPendingValues();
            return v;
        });
}

::Test::CustomIntSS
Test::MyClassPrx::opCustomIntSS(const CustomIntSS& iceP_i, CustomIntSS& iceP_o, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<CustomIntSS, CustomIntSS>>(true, this, &MyClassPrx::_iceI_opCustomIntSS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::CustomIntSS, ::Test::CustomIntSS>>
Test::MyClassPrx::opCustomIntSSAsync(const CustomIntSS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<CustomIntSS, CustomIntSS>>(false, this, &MyClassPrx::_iceI_opCustomIntSS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opCustomIntSSAsync(const CustomIntSS& iceP_i, ::std::function<void(::Test::CustomIntSS, ::Test::CustomIntSS)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<CustomIntSS, CustomIntSS>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<CustomIntSS, CustomIntSS>>(std::move(responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opCustomIntSS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opCustomIntSS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<CustomIntSS, CustomIntSS>>>& outAsync, const CustomIntSS& iceP_i, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opCustomIntSS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<CustomIntSS, CustomIntSS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}

::Test::CustomCVSS
Test::MyClassPrx::opCustomCVSS(const CustomCVSS& iceP_i, CustomCVSS& iceP_o, const ::Ice::Context& context) const
{
    auto result = ::IceInternal::makePromiseOutgoing<::std::tuple<CustomCVSS, CustomCVSS>>(true, this, &MyClassPrx::_iceI_opCustomCVSS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(result));
    return ::std::move(::std::get<0>(result));
}

::std::future<::std::tuple<::Test::CustomCVSS, ::Test::CustomCVSS>>
Test::MyClassPrx::opCustomCVSSAsync(const CustomCVSS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<CustomCVSS, CustomCVSS>>(false, this, &MyClassPrx::_iceI_opCustomCVSS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opCustomCVSSAsync(const CustomCVSS& iceP_i, ::std::function<void(::Test::CustomCVSS, ::Test::CustomCVSS)> response, ::std::function<void(::std::exception_ptr)> ex, ::std::function<void(bool)> sent, const ::Ice::Context& context) const
{
    auto responseCb = [response = ::std::move(response)](::std::tuple<CustomCVSS, CustomCVSS>&& result)
    {
        ::std::apply(::std::move(response), ::std::move(result));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<CustomCVSS, CustomCVSS>>(std::move(responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opCustomCVSS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opCustomCVSS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<CustomCVSS, CustomCVSS>>>& outAsync, const CustomCVSS& iceP_i, const ::Ice::Context& context) const
{
    static constexpr ::std::string_view operationName = "opCustomCVSS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
            ostr->writePendingValues();
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<CustomCVSS, CustomCVSS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            istr->readPendingValues();
            return v;
        });
}

::std::string_view
Test::MyClassPrx::ice_staticId()
{
    static constexpr ::std::string_view typeId = "::Test::MyClass";
    return typeId;
}

Test::CV::~CV()
{
}

::std::string_view
Test::CV::ice_staticId()
{
    static constexpr ::std::string_view typeId = "::Test::CV";
    return typeId;
}

Test::CR::~CR()
{
}

::std::string_view
Test::CR::ice_staticId()
{
    static constexpr ::std::string_view typeId = "::Test::CR";
    return typeId;
}

::std::vector<::std::string>
Test::I::ice_ids(const ::Ice::Current&) const
{
    static const ::std::vector<::std::string> allTypeIds = {"::Ice::Object", "::Test::I"};
    return allTypeIds;
}

::std::string
Test::I::ice_id(const ::Ice::Current&) const
{
    return ::std::string{ice_staticId()};
}

::std::string_view
Test::I::ice_staticId()
{
    static constexpr ::std::string_view typeId = "::Test::I";
    return typeId;
}

::std::vector<::std::string>
Test::MyClass::ice_ids(const ::Ice::Current&) const
{
    static const ::std::vector<::std::string> allTypeIds = {"::Ice::Object", "::Test::MyClass"};
    return allTypeIds;
}

::std::string
Test::MyClass::ice_id(const ::Ice::Current&) const
{
    return ::std::string{ice_staticId()};
}

::std::string_view
Test::MyClass::ice_staticId()
{
    static constexpr ::std::string_view typeId = "::Test::MyClass";
    return typeId;
}

/// \cond INTERNAL
bool
Test::MyClass::_iceD_shutdown(::IceInternal::Incoming& incoming)
{
    _iceCheckMode(::Ice::OperationMode::Normal, incoming.current().mode);
    incoming.readEmptyParams();
    auto incomingPtr = ::std::make_shared<::IceInternal::Incoming>(::std::move(incoming));
    try
    {
        this->shutdownAsync([incomingPtr] { incomingPtr->response(); }, [incomingPtr](std::exception_ptr ex) { incomingPtr->completed(ex); }, incomingPtr->current());
    }
    catch (...)
    {
        incomingPtr->failed(::std::current_exception());
    }
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opAByteS(::IceInternal::Incoming& incoming)
{
    _iceCheckMode(::Ice::OperationMode::Normal, incoming.current().mode);
    auto istr = incoming.startReadParams();
    AByteS iceP_i;
    istr->readAll(iceP_i);
    incoming.endReadParams();
    auto incomingPtr = ::std::make_shared<::IceInternal::Incoming>(::std::move(incoming));
    auto responseCB = [incomingPtr](const AByteS& ret, const AByteS& iceP_o)
    {
        auto ostr = incomingPtr->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        incomingPtr->endWriteParams();
        incomingPtr->completed();
    };
    try
    {
        this->opAByteSAsync(::std::move(iceP_i), responseCB, [incomingPtr](std::exception_ptr ex) { incomingPtr->completed(ex); }, incomingPtr->current());
    }
    catch (...)
    {
        incomingPtr->failed(::std::current_exception());
    }
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opLByteS(::IceInternal::Incoming& incoming)
{
    _iceCheckMode(::Ice::OperationMode::Normal, incoming.current().mode);
    auto istr = incoming.startReadParams();
    LByteS iceP_i;
    istr->readAll(iceP_i);
    incoming.endReadParams();
    auto incomingPtr = ::std::make_shared<::IceInternal::Incoming>(::std::move(incoming));
    auto responseCB = [incomingPtr](const LByteS& ret, const LByteS& iceP_o)
    {
        auto ostr = incomingPtr->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        incomingPtr->endWriteParams();
        incomingPtr->completed();
    };
    try
    {
        this->opLByteSAsync(::std::move(iceP_i), responseCB, [incomingPtr](std::exception_ptr ex) { incomingPtr->completed(ex); }, incomingPtr->current());
    }
    catch (...)
    {
        incomingPtr->failed(::std::current_exception());
    }
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opKByteS(::IceInternal::Incoming& incoming)
{
    _iceCheckMode(::Ice::OperationMode::Normal, incoming.current().mode);
    auto istr = incoming.startReadParams();
    KByteS iceP_i;
    istr->readAll(iceP_i);
    incoming.endReadParams();
    auto incomingPtr = ::std::make_shared<::IceInternal::Incoming>(::std::move(incoming));
    auto responseCB = [incomingPtr](const KByteS& ret, const KByteS& iceP_o)
    {
        auto ostr = incomingPtr->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        incomingPtr->endWriteParams();
        incomingPtr->completed();
    };
    try
    {
        this->opKByteSAsync(::std::move(iceP_i), responseCB, [incomingPtr](std::exception_ptr ex) { incomingPtr->completed(ex); }, incomingPtr->current());
    }
    catch (...)
    {
        incomingPtr->failed(::std::current_exception());
    }
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opQByteS(::IceInternal::Incoming& incoming)
{
    _iceCheckMode(::Ice::OperationMode::Normal, incoming.current().mode);
    auto istr = incoming.startReadParams();
    QByteS iceP_i;
    istr->readAll(iceP_i);
    incoming.endReadParams();
    auto incomingPtr = ::std::make_shared<::IceInternal::Incoming>(::std::move(incoming));
    auto responseCB = [incomingPtr](const QByteS& ret, const QByteS& iceP_o)
    {
        auto ostr = incomingPtr->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        incomingPtr->endWriteParams();
        incomingPtr->completed();
    };
    try
    {
        this->opQByteSAsync(::std::move(iceP_i), responseCB, [incomingPtr](std::exception_ptr ex) { incomingPtr->completed(ex); }, incomingPtr->current());
    }
    catch (...)
    {
        incomingPtr->failed(::std::current_exception());
    }
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opSByteS(::IceInternal::Incoming& incoming)
{
    _iceCheckMode(::Ice::OperationMode::Normal, incoming.current().mode);
    auto istr = incoming.startReadParams();
    SByteS iceP_i;
    istr->readAll(iceP_i);
    incoming.endReadParams();
    auto incomingPtr = ::std::make_shared<::IceInternal::Incoming>(::std::move(incoming));
    auto responseCB = [incomingPtr](const SByteS& ret, const SByteS& iceP_o)
    {
        auto ostr = incomingPtr->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        incomingPtr->endWriteParams();
        incomingPtr->completed();
    };
    try
    {
        this->opSByteSAsync(::std::move(iceP_i), responseCB, [incomingPtr](std::exception_ptr ex) { incomingPtr->completed(ex); }, incomingPtr->current());
    }
    catch (...)
    {
        incomingPtr->failed(::std::current_exception());
    }
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opABoolS(::IceInternal::Incoming& incoming)
{
    _iceCheckMode(::Ice::OperationMode::Normal, incoming.current().mode);
    auto istr = incoming.startReadParams();
    ABoolS iceP_i;
    istr->readAll(iceP_i);
    incoming.endReadParams();
    auto incomingPtr = ::std::make_shared<::IceInternal::Incoming>(::std::move(incoming));
    auto responseCB = [incomingPtr](const ABoolS& ret, const ABoolS& iceP_o)
    {
        auto ostr = incomingPtr->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        incomingPtr->endWriteParams();
        incomingPtr->completed();
    };
    try
    {
        this->opABoolSAsync(::std::move(iceP_i), responseCB, [incomingPtr](std::exception_ptr ex) { incomingPtr->completed(ex); }, incomingPtr->current());
    }
    catch (...)
    {
        incomingPtr->failed(::std::current_exception());
    }
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opLBoolS(::IceInternal::Incoming& incoming)
{
    _iceCheckMode(::Ice::OperationMode::Normal, incoming.current().mode);
    auto istr = incoming.startReadParams();
    LBoolS iceP_i;
    istr->readAll(iceP_i);
    incoming.endReadParams();
    auto incomingPtr = ::std::make_shared<::IceInternal::Incoming>(::std::move(incoming));
    auto responseCB = [incomingPtr](const LBoolS& ret, const LBoolS& iceP_o)
    {
        auto ostr = incomingPtr->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        incomingPtr->endWriteParams();
        incomingPtr->completed();
    };
    try
    {
        this->opLBoolSAsync(::std::move(iceP_i), responseCB, [incomingPtr](std::exception_ptr ex) { incomingPtr->completed(ex); }, incomingPtr->current());
    }
    catch (...)
    {
        incomingPtr->failed(::std::current_exception());
    }
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opKBoolS(::IceInternal::Incoming& incoming)
{
    _iceCheckMode(::Ice::OperationMode::Normal, incoming.current().mode);
    auto istr = incoming.startReadParams();
    KBoolS iceP_i;
    istr->readAll(iceP_i);
    incoming.endReadParams();
    auto incomingPtr = ::std::make_shared<::IceInternal::Incoming>(::std::move(incoming));
    auto responseCB = [incomingPtr](const KBoolS& ret, const KBoolS& iceP_o)
    {
        auto ostr = incomingPtr->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        incomingPtr->endWriteParams();
        incomingPtr->completed();
    };
    try
    {
        this->opKBoolSAsync(::std::move(iceP_i), responseCB, [incomingPtr](std::exception_ptr ex) { incomingPtr->completed(ex); }, incomingPtr->current());
    }
    catch (...)
    {
        incomingPtr->failed(::std::current_exception());
    }
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opQBoolS(::IceInternal::Incoming& incoming)
{
    _iceCheckMode(::Ice::OperationMode::Normal, incoming.current().mode);
    auto istr = incoming.startReadParams();
    QBoolS iceP_i;
    istr->readAll(iceP_i);
    incoming.endReadParams();
    auto incomingPtr = ::std::make_shared<::IceInternal::Incoming>(::std::move(incoming));
    auto responseCB = [incomingPtr](const QBoolS& ret, const QBoolS& iceP_o)
    {
        auto ostr = incomingPtr->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        incomingPtr->endWriteParams();
        incomingPtr->completed();
    };
    try
    {
        this->opQBoolSAsync(::std::move(iceP_i), responseCB, [incomingPtr](std::exception_ptr ex) { incomingPtr->completed(ex); }, incomingPtr->current());
    }
    catch (...)
    {
        incomingPtr->failed(::std::current_exception());
    }
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opSBoolS(::IceInternal::Incoming& incoming)
{
    _iceCheckMode(::Ice::OperationMode::Normal, incoming.current().mode);
    auto istr = incoming.startReadParams();
    SBoolS iceP_i;
    istr->readAll(iceP_i);
    incoming.endReadParams();
    auto incomingPtr = ::std::make_shared<::IceInternal::Incoming>(::std::move(incoming));
    auto responseCB = [incomingPtr](const SBoolS& ret, const SBoolS& iceP_o)
    {
        auto ostr = incomingPtr->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        incomingPtr->endWriteParams();
        incomingPtr->completed();
    };
    try
    {
        this->opSBoolSAsync(::std::move(iceP_i), responseCB, [incomingPtr](std::exception_ptr ex) { incomingPtr->completed(ex); }, incomingPtr->current());
    }
    catch (...)
    {
        incomingPtr->failed(::std::current_exception());
    }
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opAShortS(::IceInternal::Incoming& incoming)
{
    _iceCheckMode(::Ice::OperationMode::Normal, incoming.current().mode);
    auto istr = incoming.startReadParams();
    AShortS iceP_i;
    istr->readAll(iceP_i);
    incoming.endReadParams();
    auto incomingPtr = ::std::make_shared<::IceInternal::Incoming>(::std::move(incoming));
    auto responseCB = [incomingPtr](const AShortS& ret, const AShortS& iceP_o)
    {
        auto ostr = incomingPtr->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        incomingPtr->endWriteParams();
        incomingPtr->completed();
    };
    try
    {
        this->opAShortSAsync(::std::move(iceP_i), responseCB, [incomingPtr](std::exception_ptr ex) { incomingPtr->completed(ex); }, incomingPtr->current());
    }
    catch (...)
    {
        incomingPtr->failed(::std::current_exception());
    }
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opLShortS(::IceInternal::Incoming& incoming)
{
    _iceCheckMode(::Ice::OperationMode::Normal, incoming.current().mode);
    auto istr = incoming.startReadParams();
    LShortS iceP_i;
    istr->readAll(iceP_i);
    incoming.endReadParams();
    auto incomingPtr = ::std::make_shared<::IceInternal::Incoming>(::std::move(incoming));
    auto responseCB = [incomingPtr](const LShortS& ret, const LShortS& iceP_o)
    {
        auto ostr = incomingPtr->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        incomingPtr->endWriteParams();
        incomingPtr->completed();
    };
    try
    {
        this->opLShortSAsync(::std::move(iceP_i), responseCB, [incomingPtr](std::exception_ptr ex) { incomingPtr->completed(ex); }, incomingPtr->current());
    }
    catch (...)
    {
        incomingPtr->failed(::std::current_exception());
    }
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opKShortS(::IceInternal::Incoming& incoming)
{
    _iceCheckMode(::Ice::OperationMode::Normal, incoming.current().mode);
    auto istr = incoming.startReadParams();
    KShortS iceP_i;
    istr->readAll(iceP_i);
    incoming.endReadParams();
    auto incomingPtr = ::std::make_shared<::IceInternal::Incoming>(::std::move(incoming));
    auto responseCB = [incomingPtr](const KShortS& ret, const KShortS& iceP_o)
    {
        auto ostr = incomingPtr->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        incomingPtr->endWriteParams();
        incomingPtr->completed();
    };
    try
    {
        this->opKShortSAsync(::std::move(iceP_i), responseCB, [incomingPtr](std::exception_ptr ex) { incomingPtr->completed(ex); }, incomingPtr->current());
    }
    catch (...)
    {
        incomingPtr->failed(::std::current_exception());
    }
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opQShortS(::IceInternal::Incoming& incoming)
{
    _iceCheckMode(::Ice::OperationMode::Normal, incoming.current().mode);
    auto istr = incoming.startReadParams();
    QShortS iceP_i;
    istr->readAll(iceP_i);
    incoming.endReadParams();
    auto incomingPtr = ::std::make_shared<::IceInternal::Incoming>(::std::move(incoming));
    auto responseCB = [incomingPtr](const QShortS& ret, const QShortS& iceP_o)
    {
        auto ostr = incomingPtr->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        incomingPtr->endWriteParams();
        incomingPtr->completed();
    };
    try
    {
        this->opQShortSAsync(::std::move(iceP_i), responseCB, [incomingPtr](std::exception_ptr ex) { incomingPtr->completed(ex); }, incomingPtr->current());
    }
    catch (...)
    {
        incomingPtr->failed(::std::current_exception());
    }
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opSShortS(::IceInternal::Incoming& incoming)
{
    _iceCheckMode(::Ice::OperationMode::Normal, incoming.current().mode);
    auto istr = incoming.startReadParams();
    SShortS iceP_i;
    istr->readAll(iceP_i);
    incoming.endReadParams();
    auto incomingPtr = ::std::make_shared<::IceInternal::Incoming>(::std::move(incoming));
    auto responseCB = [incomingPtr](const SShortS& ret, const SShortS& iceP_o)
    {
        auto ostr = incomingPtr->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        incomingPtr->endWriteParams();
        incomingPtr->completed();
    };
    try
    {
        this->opSShortSAsync(::std::move(iceP_i), responseCB, [incomingPtr](std::exception_ptr ex) { incomingPtr->completed(ex); }, incomingPtr->current());
    }
    catch (...)
    {
        incomingPtr->failed(::std::current_exception());
    }
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opAIntS(::IceInternal::Incoming& incoming)
{
    _iceCheckMode(::Ice::OperationMode::Normal, incoming.current().mode);
    auto istr = incoming.startReadParams();
    AIntS iceP_i;
    istr->readAll(iceP_i);
    incoming.endReadParams();
    auto incomingPtr = ::std::make_shared<::IceInternal::Incoming>(::std::move(incoming));
    auto responseCB = [incomingPtr](const AIntS& ret, const AIntS& iceP_o)
    {
        auto ostr = incomingPtr->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        incomingPtr->endWriteParams();
        incomingPtr->completed();
    };
    try
    {
        this->opAIntSAsync(::std::move(iceP_i), responseCB, [incomingPtr](std::exception_ptr ex) { incomingPtr->completed(ex); }, incomingPtr->current());
    }
    catch (...)
    {
        incomingPtr->failed(::std::current_exception());
    }
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opLIntS(::IceInternal::Incoming& incoming)
{
    _iceCheckMode(::Ice::OperationMode::Normal, incoming.current().mode);
    auto istr = incoming.startReadParams();
    LIntS iceP_i;
    istr->readAll(iceP_i);
    incoming.endReadParams();
    auto incomingPtr = ::std::make_shared<::IceInternal::Incoming>(::std::move(incoming));
    auto responseCB = [incomingPtr](const LIntS& ret, const LIntS& iceP_o)
    {
        auto ostr = incomingPtr->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        incomingPtr->endWriteParams();
        incomingPtr->completed();
    };
    try
    {
        this->opLIntSAsync(::std::move(iceP_i), responseCB, [incomingPtr](std::exception_ptr ex) { incomingPtr->completed(ex); }, incomingPtr->current());
    }
    catch (...)
    {
        incomingPtr->failed(::std::current_exception());
    }
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opKIntS(::IceInternal::Incoming& incoming)
{
    _iceCheckMode(::Ice::OperationMode::Normal, incoming.current().mode);
    auto istr = incoming.startReadParams();
    KIntS iceP_i;
    istr->readAll(iceP_i);
    incoming.endReadParams();
    auto incomingPtr = ::std::make_shared<::IceInternal::Incoming>(::std::move(incoming));
    auto responseCB = [incomingPtr](const KIntS& ret, const KIntS& iceP_o)
    {
        auto ostr = incomingPtr->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        incomingPtr->endWriteParams();
        incomingPtr->completed();
    };
    try
    {
        this->opKIntSAsync(::std::move(iceP_i), responseCB, [incomingPtr](std::exception_ptr ex) { incomingPtr->completed(ex); }, incomingPtr->current());
    }
    catch (...)
    {
        incomingPtr->failed(::std::current_exception());
    }
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opQIntS(::IceInternal::Incoming& incoming)
{
    _iceCheckMode(::Ice::OperationMode::Normal, incoming.current().mode);
    auto istr = incoming.startReadParams();
    QIntS iceP_i;
    istr->readAll(iceP_i);
    incoming.endReadParams();
    auto incomingPtr = ::std::make_shared<::IceInternal::Incoming>(::std::move(incoming));
    auto responseCB = [incomingPtr](const QIntS& ret, const QIntS& iceP_o)
    {
        auto ostr = incomingPtr->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        incomingPtr->endWriteParams();
        incomingPtr->completed();
    };
    try
    {
        this->opQIntSAsync(::std::move(iceP_i), responseCB, [incomingPtr](std::exception_ptr ex) { incomingPtr->completed(ex); }, incomingPtr->current());
    }
    catch (...)
    {
        incomingPtr->failed(::std::current_exception());
    }
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opSIntS(::IceInternal::Incoming& incoming)
{
    _iceCheckMode(::Ice::OperationMode::Normal, incoming.current().mode);
    auto istr = incoming.startReadParams();
    SIntS iceP_i;
    istr->readAll(iceP_i);
    incoming.endReadParams();
    auto incomingPtr = ::std::make_shared<::IceInternal::Incoming>(::std::move(incoming));
    auto responseCB = [incomingPtr](const SIntS& ret, const SIntS& iceP_o)
    {
        auto ostr = incomingPtr->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        incomingPtr->endWriteParams();
        incomingPtr->completed();
    };
    try
    {
        this->opSIntSAsync(::std::move(iceP_i), responseCB, [incomingPtr](std::exception_ptr ex) { incomingPtr->completed(ex); }, incomingPtr->current());
    }
    catch (...)
    {
        incomingPtr->failed(::std::current_exception());
    }
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opALongS(::IceInternal::Incoming& incoming)
{
    _iceCheckMode(::Ice::OperationMode::Normal, incoming.current().mode);
    auto istr = incoming.startReadParams();
    ALongS iceP_i;
    istr->readAll(iceP_i);
    incoming.endReadParams();
    auto incomingPtr = ::std::make_shared<::IceInternal::Incoming>(::std::move(incoming));
    auto responseCB = [incomingPtr](const ALongS& ret, const ALongS& iceP_o)
    {
        auto ostr = incomingPtr->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        incomingPtr->endWriteParams();
        incomingPtr->completed();
    };
    try
    {
        this->opALongSAsync(::std::move(iceP_i), responseCB, [incomingPtr](std::exception_ptr ex) { incomingPtr->completed(ex); }, incomingPtr->current());
    }
    catch (...)
    {
        incomingPtr->failed(::std::current_exception());
    }
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opLLongS(::IceInternal::Incoming& incoming)
{
    _iceCheckMode(::Ice::OperationMode::Normal, incoming.current().mode);
    auto istr = incoming.startReadParams();
    LLongS iceP_i;
    istr->readAll(iceP_i);
    incoming.endReadParams();
    auto incomingPtr = ::std::make_shared<::IceInternal::Incoming>(::std::move(incoming));
    auto responseCB = [incomingPtr](const LLongS& ret, const LLongS& iceP_o)
    {
        auto ostr = incomingPtr->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        incomingPtr->endWriteParams();
        incomingPtr->completed();
    };
    try
    {
        this->opLLongSAsync(::std::move(iceP_i), responseCB, [incomingPtr](std::exception_ptr ex) { incomingPtr->completed(ex); }, incomingPtr->current());
    }
    catch (...)
    {
        incomingPtr->failed(::std::current_exception());
    }
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opKLongS(::IceInternal::Incoming& incoming)
{
    _iceCheckMode(::Ice::OperationMode::Normal, incoming.current().mode);
    auto istr = incoming.startReadParams();
    KLongS iceP_i;
    istr->readAll(iceP_i);
    incoming.endReadParams();
    auto incomingPtr = ::std::make_shared<::IceInternal::Incoming>(::std::move(incoming));
    auto responseCB = [incomingPtr](const KLongS& ret, const KLongS& iceP_o)
    {
        auto ostr = incomingPtr->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        incomingPtr->endWriteParams();
        incomingPtr->completed();
    };
    try
    {
        this->opKLongSAsync(::std::move(iceP_i), responseCB, [incomingPtr](std::exception_ptr ex) { incomingPtr->completed(ex); }, incomingPtr->current());
    }
    catch (...)
    {
        incomingPtr->failed(::std::current_exception());
    }
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opQLongS(::IceInternal::Incoming& incoming)
{
    _iceCheckMode(::Ice::OperationMode::Normal, incoming.current().mode);
    auto istr = incoming.startReadParams();
    QLongS iceP_i;
    istr->readAll(iceP_i);
    incoming.endReadParams();
    auto incomingPtr = ::std::make_shared<::IceInternal::Incoming>(::std::move(incoming));
    auto responseCB = [incomingPtr](const QLongS& ret, const QLongS& iceP_o)
    {
        auto ostr = incomingPtr->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        incomingPtr->endWriteParams();
        incomingPtr->completed();
    };
    try
    {
        this->opQLongSAsync(::std::move(iceP_i), responseCB, [incomingPtr](std::exception_ptr ex) { incomingPtr->completed(ex); }, incomingPtr->current());
    }
    catch (...)
    {
        incomingPtr->failed(::std::current_exception());
    }
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opSLongS(::IceInternal::Incoming& incoming)
{
    _iceCheckMode(::Ice::OperationMode::Normal, incoming.current().mode);
    auto istr = incoming.startReadParams();
    SLongS iceP_i;
    istr->readAll(iceP_i);
    incoming.endReadParams();
    auto incomingPtr = ::std::make_shared<::IceInternal::Incoming>(::std::move(incoming));
    auto responseCB = [incomingPtr](const SLongS& ret, const SLongS& iceP_o)
    {
        auto ostr = incomingPtr->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        incomingPtr->endWriteParams();
        incomingPtr->completed();
    };
    try
    {
        this->opSLongSAsync(::std::move(iceP_i), responseCB, [incomingPtr](std::exception_ptr ex) { incomingPtr->completed(ex); }, incomingPtr->current());
    }
    catch (...)
    {
        incomingPtr->failed(::std::current_exception());
    }
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opAFloatS(::IceInternal::Incoming& incoming)
{
    _iceCheckMode(::Ice::OperationMode::Normal, incoming.current().mode);
    auto istr = incoming.startReadParams();
    AFloatS iceP_i;
    istr->readAll(iceP_i);
    incoming.endReadParams();
    auto incomingPtr = ::std::make_shared<::IceInternal::Incoming>(::std::move(incoming));
    auto responseCB = [incomingPtr](const AFloatS& ret, const AFloatS& iceP_o)
    {
        auto ostr = incomingPtr->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        incomingPtr->endWriteParams();
        incomingPtr->completed();
    };
    try
    {
        this->opAFloatSAsync(::std::move(iceP_i), responseCB, [incomingPtr](std::exception_ptr ex) { incomingPtr->completed(ex); }, incomingPtr->current());
    }
    catch (...)
    {
        incomingPtr->failed(::std::current_exception());
    }
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opLFloatS(::IceInternal::Incoming& incoming)
{
    _iceCheckMode(::Ice::OperationMode::Normal, incoming.current().mode);
    auto istr = incoming.startReadParams();
    LFloatS iceP_i;
    istr->readAll(iceP_i);
    incoming.endReadParams();
    auto incomingPtr = ::std::make_shared<::IceInternal::Incoming>(::std::move(incoming));
    auto responseCB = [incomingPtr](const LFloatS& ret, const LFloatS& iceP_o)
    {
        auto ostr = incomingPtr->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        incomingPtr->endWriteParams();
        incomingPtr->completed();
    };
    try
    {
        this->opLFloatSAsync(::std::move(iceP_i), responseCB, [incomingPtr](std::exception_ptr ex) { incomingPtr->completed(ex); }, incomingPtr->current());
    }
    catch (...)
    {
        incomingPtr->failed(::std::current_exception());
    }
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opKFloatS(::IceInternal::Incoming& incoming)
{
    _iceCheckMode(::Ice::OperationMode::Normal, incoming.current().mode);
    auto istr = incoming.startReadParams();
    KFloatS iceP_i;
    istr->readAll(iceP_i);
    incoming.endReadParams();
    auto incomingPtr = ::std::make_shared<::IceInternal::Incoming>(::std::move(incoming));
    auto responseCB = [incomingPtr](const KFloatS& ret, const KFloatS& iceP_o)
    {
        auto ostr = incomingPtr->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        incomingPtr->endWriteParams();
        incomingPtr->completed();
    };
    try
    {
        this->opKFloatSAsync(::std::move(iceP_i), responseCB, [incomingPtr](std::exception_ptr ex) { incomingPtr->completed(ex); }, incomingPtr->current());
    }
    catch (...)
    {
        incomingPtr->failed(::std::current_exception());
    }
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opQFloatS(::IceInternal::Incoming& incoming)
{
    _iceCheckMode(::Ice::OperationMode::Normal, incoming.current().mode);
    auto istr = incoming.startReadParams();
    QFloatS iceP_i;
    istr->readAll(iceP_i);
    incoming.endReadParams();
    auto incomingPtr = ::std::make_shared<::IceInternal::Incoming>(::std::move(incoming));
    auto responseCB = [incomingPtr](const QFloatS& ret, const QFloatS& iceP_o)
    {
        auto ostr = incomingPtr->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        incomingPtr->endWriteParams();
        incomingPtr->completed();
    };
    try
    {
        this->opQFloatSAsync(::std::move(iceP_i), responseCB, [incomingPtr](std::exception_ptr ex) { incomingPtr->completed(ex); }, incomingPtr->current());
    }
    catch (...)
    {
        incomingPtr->failed(::std::current_exception());
    }
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opSFloatS(::IceInternal::Incoming& incoming)
{
    _iceCheckMode(::Ice::OperationMode::Normal, incoming.current().mode);
    auto istr = incoming.startReadParams();
    SFloatS iceP_i;
    istr->readAll(iceP_i);
    incoming.endReadParams();
    auto incomingPtr = ::std::make_shared<::IceInternal::Incoming>(::std::move(incoming));
    auto responseCB = [incomingPtr](const SFloatS& ret, const SFloatS& iceP_o)
    {
        auto ostr = incomingPtr->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        incomingPtr->endWriteParams();
        incomingPtr->completed();
    };
    try
    {
        this->opSFloatSAsync(::std::move(iceP_i), responseCB, [incomingPtr](std::exception_ptr ex) { incomingPtr->completed(ex); }, incomingPtr->current());
    }
    catch (...)
    {
        incomingPtr->failed(::std::current_exception());
    }
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opADoubleS(::IceInternal::Incoming& incoming)
{
    _iceCheckMode(::Ice::OperationMode::Normal, incoming.current().mode);
    auto istr = incoming.startReadParams();
    ADoubleS iceP_i;
    istr->readAll(iceP_i);
    incoming.endReadParams();
    auto incomingPtr = ::std::make_shared<::IceInternal::Incoming>(::std::move(incoming));
    auto responseCB = [incomingPtr](const ADoubleS& ret, const ADoubleS& iceP_o)
    {
        auto ostr = incomingPtr->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        incomingPtr->endWriteParams();
        incomingPtr->completed();
    };
    try
    {
        this->opADoubleSAsync(::std::move(iceP_i), responseCB, [incomingPtr](std::exception_ptr ex) { incomingPtr->completed(ex); }, incomingPtr->current());
    }
    catch (...)
    {
        incomingPtr->failed(::std::current_exception());
    }
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opLDoubleS(::IceInternal::Incoming& incoming)
{
    _iceCheckMode(::Ice::OperationMode::Normal, incoming.current().mode);
    auto istr = incoming.startReadParams();
    LDoubleS iceP_i;
    istr->readAll(iceP_i);
    incoming.endReadParams();
    auto incomingPtr = ::std::make_shared<::IceInternal::Incoming>(::std::move(incoming));
    auto responseCB = [incomingPtr](const LDoubleS& ret, const LDoubleS& iceP_o)
    {
        auto ostr = incomingPtr->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        incomingPtr->endWriteParams();
        incomingPtr->completed();
    };
    try
    {
        this->opLDoubleSAsync(::std::move(iceP_i), responseCB, [incomingPtr](std::exception_ptr ex) { incomingPtr->completed(ex); }, incomingPtr->current());
    }
    catch (...)
    {
        incomingPtr->failed(::std::current_exception());
    }
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opKDoubleS(::IceInternal::Incoming& incoming)
{
    _iceCheckMode(::Ice::OperationMode::Normal, incoming.current().mode);
    auto istr = incoming.startReadParams();
    KDoubleS iceP_i;
    istr->readAll(iceP_i);
    incoming.endReadParams();
    auto incomingPtr = ::std::make_shared<::IceInternal::Incoming>(::std::move(incoming));
    auto responseCB = [incomingPtr](const KDoubleS& ret, const KDoubleS& iceP_o)
    {
        auto ostr = incomingPtr->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        incomingPtr->endWriteParams();
        incomingPtr->completed();
    };
    try
    {
        this->opKDoubleSAsync(::std::move(iceP_i), responseCB, [incomingPtr](std::exception_ptr ex) { incomingPtr->completed(ex); }, incomingPtr->current());
    }
    catch (...)
    {
        incomingPtr->failed(::std::current_exception());
    }
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opQDoubleS(::IceInternal::Incoming& incoming)
{
    _iceCheckMode(::Ice::OperationMode::Normal, incoming.current().mode);
    auto istr = incoming.startReadParams();
    QDoubleS iceP_i;
    istr->readAll(iceP_i);
    incoming.endReadParams();
    auto incomingPtr = ::std::make_shared<::IceInternal::Incoming>(::std::move(incoming));
    auto responseCB = [incomingPtr](const QDoubleS& ret, const QDoubleS& iceP_o)
    {
        auto ostr = incomingPtr->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        incomingPtr->endWriteParams();
        incomingPtr->completed();
    };
    try
    {
        this->opQDoubleSAsync(::std::move(iceP_i), responseCB, [incomingPtr](std::exception_ptr ex) { incomingPtr->completed(ex); }, incomingPtr->current());
    }
    catch (...)
    {
        incomingPtr->failed(::std::current_exception());
    }
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opSDoubleS(::IceInternal::Incoming& incoming)
{
    _iceCheckMode(::Ice::OperationMode::Normal, incoming.current().mode);
    auto istr = incoming.startReadParams();
    SDoubleS iceP_i;
    istr->readAll(iceP_i);
    incoming.endReadParams();
    auto incomingPtr = ::std::make_shared<::IceInternal::Incoming>(::std::move(incoming));
    auto responseCB = [incomingPtr](const SDoubleS& ret, const SDoubleS& iceP_o)
    {
        auto ostr = incomingPtr->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        incomingPtr->endWriteParams();
        incomingPtr->completed();
    };
    try
    {
        this->opSDoubleSAsync(::std::move(iceP_i), responseCB, [incomingPtr](std::exception_ptr ex) { incomingPtr->completed(ex); }, incomingPtr->current());
    }
    catch (...)
    {
        incomingPtr->failed(::std::current_exception());
    }
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opAStringS(::IceInternal::Incoming& incoming)
{
    _iceCheckMode(::Ice::OperationMode::Normal, incoming.current().mode);
    auto istr = incoming.startReadParams();
    AStringS iceP_i;
    istr->readAll(iceP_i);
    incoming.endReadParams();
    auto incomingPtr = ::std::make_shared<::IceInternal::Incoming>(::std::move(incoming));
    auto responseCB = [incomingPtr](const AStringS& ret, const AStringS& iceP_o)
    {
        auto ostr = incomingPtr->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        incomingPtr->endWriteParams();
        incomingPtr->completed();
    };
    try
    {
        this->opAStringSAsync(::std::move(iceP_i), responseCB, [incomingPtr](std::exception_ptr ex) { incomingPtr->completed(ex); }, incomingPtr->current());
    }
    catch (...)
    {
        incomingPtr->failed(::std::current_exception());
    }
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opLStringS(::IceInternal::Incoming& incoming)
{
    _iceCheckMode(::Ice::OperationMode::Normal, incoming.current().mode);
    auto istr = incoming.startReadParams();
    LStringS iceP_i;
    istr->readAll(iceP_i);
    incoming.endReadParams();
    auto incomingPtr = ::std::make_shared<::IceInternal::Incoming>(::std::move(incoming));
    auto responseCB = [incomingPtr](const LStringS& ret, const LStringS& iceP_o)
    {
        auto ostr = incomingPtr->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        incomingPtr->endWriteParams();
        incomingPtr->completed();
    };
    try
    {
        this->opLStringSAsync(::std::move(iceP_i), responseCB, [incomingPtr](std::exception_ptr ex) { incomingPtr->completed(ex); }, incomingPtr->current());
    }
    catch (...)
    {
        incomingPtr->failed(::std::current_exception());
    }
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opKStringS(::IceInternal::Incoming& incoming)
{
    _iceCheckMode(::Ice::OperationMode::Normal, incoming.current().mode);
    auto istr = incoming.startReadParams();
    KStringS iceP_i;
    istr->readAll(iceP_i);
    incoming.endReadParams();
    auto incomingPtr = ::std::make_shared<::IceInternal::Incoming>(::std::move(incoming));
    auto responseCB = [incomingPtr](const KStringS& ret, const KStringS& iceP_o)
    {
        auto ostr = incomingPtr->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        incomingPtr->endWriteParams();
        incomingPtr->completed();
    };
    try
    {
        this->opKStringSAsync(::std::move(iceP_i), responseCB, [incomingPtr](std::exception_ptr ex) { incomingPtr->completed(ex); }, incomingPtr->current());
    }
    catch (...)
    {
        incomingPtr->failed(::std::current_exception());
    }
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opQStringS(::IceInternal::Incoming& incoming)
{
    _iceCheckMode(::Ice::OperationMode::Normal, incoming.current().mode);
    auto istr = incoming.startReadParams();
    QStringS iceP_i;
    istr->readAll(iceP_i);
    incoming.endReadParams();
    auto incomingPtr = ::std::make_shared<::IceInternal::Incoming>(::std::move(incoming));
    auto responseCB = [incomingPtr](const QStringS& ret, const QStringS& iceP_o)
    {
        auto ostr = incomingPtr->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        incomingPtr->endWriteParams();
        incomingPtr->completed();
    };
    try
    {
        this->opQStringSAsync(::std::move(iceP_i), responseCB, [incomingPtr](std::exception_ptr ex) { incomingPtr->completed(ex); }, incomingPtr->current());
    }
    catch (...)
    {
        incomingPtr->failed(::std::current_exception());
    }
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opSStringS(::IceInternal::Incoming& incoming)
{
    _iceCheckMode(::Ice::OperationMode::Normal, incoming.current().mode);
    auto istr = incoming.startReadParams();
    SStringS iceP_i;
    istr->readAll(iceP_i);
    incoming.endReadParams();
    auto incomingPtr = ::std::make_shared<::IceInternal::Incoming>(::std::move(incoming));
    auto responseCB = [incomingPtr](const SStringS& ret, const SStringS& iceP_o)
    {
        auto ostr = incomingPtr->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        incomingPtr->endWriteParams();
        incomingPtr->completed();
    };
    try
    {
        this->opSStringSAsync(::std::move(iceP_i), responseCB, [incomingPtr](std::exception_ptr ex) { incomingPtr->completed(ex); }, incomingPtr->current());
    }
    catch (...)
    {
        incomingPtr->failed(::std::current_exception());
    }
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opAObjectS(::IceInternal::Incoming& incoming)
{
    _iceCheckMode(::Ice::OperationMode::Normal, incoming.current().mode);
    auto istr = incoming.startReadParams();
    AObjectS iceP_i;
    istr->readAll(iceP_i);
    istr->readPendingValues();
    incoming.endReadParams();
    auto incomingPtr = ::std::make_shared<::IceInternal::Incoming>(::std::move(incoming));
    auto responseCB = [incomingPtr](const AObjectS& ret, const AObjectS& iceP_o)
    {
        auto ostr = incomingPtr->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        ostr->writePendingValues();
        incomingPtr->endWriteParams();
        incomingPtr->completed();
    };
    try
    {
        this->opAObjectSAsync(::std::move(iceP_i), responseCB, [incomingPtr](std::exception_ptr ex) { incomingPtr->completed(ex); }, incomingPtr->current());
    }
    catch (...)
    {
        incomingPtr->failed(::std::current_exception());
    }
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opLObjectS(::IceInternal::Incoming& incoming)
{
    _iceCheckMode(::Ice::OperationMode::Normal, incoming.current().mode);
    auto istr = incoming.startReadParams();
    LObjectS iceP_i;
    istr->readAll(iceP_i);
    istr->readPendingValues();
    incoming.endReadParams();
    auto incomingPtr = ::std::make_shared<::IceInternal::Incoming>(::std::move(incoming));
    auto responseCB = [incomingPtr](const LObjectS& ret, const LObjectS& iceP_o)
    {
        auto ostr = incomingPtr->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        ostr->writePendingValues();
        incomingPtr->endWriteParams();
        incomingPtr->completed();
    };
    try
    {
        this->opLObjectSAsync(::std::move(iceP_i), responseCB, [incomingPtr](std::exception_ptr ex) { incomingPtr->completed(ex); }, incomingPtr->current());
    }
    catch (...)
    {
        incomingPtr->failed(::std::current_exception());
    }
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opAObjectPrxS(::IceInternal::Incoming& incoming)
{
    _iceCheckMode(::Ice::OperationMode::Normal, incoming.current().mode);
    auto istr = incoming.startReadParams();
    AObjectPrxS iceP_i;
    istr->readAll(iceP_i);
    incoming.endReadParams();
    auto incomingPtr = ::std::make_shared<::IceInternal::Incoming>(::std::move(incoming));
    auto responseCB = [incomingPtr](const AObjectPrxS& ret, const AObjectPrxS& iceP_o)
    {
        auto ostr = incomingPtr->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        incomingPtr->endWriteParams();
        incomingPtr->completed();
    };
    try
    {
        this->opAObjectPrxSAsync(::std::move(iceP_i), responseCB, [incomingPtr](std::exception_ptr ex) { incomingPtr->completed(ex); }, incomingPtr->current());
    }
    catch (...)
    {
        incomingPtr->failed(::std::current_exception());
    }
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opLObjectPrxS(::IceInternal::Incoming& incoming)
{
    _iceCheckMode(::Ice::OperationMode::Normal, incoming.current().mode);
    auto istr = incoming.startReadParams();
    LObjectPrxS iceP_i;
    istr->readAll(iceP_i);
    incoming.endReadParams();
    auto incomingPtr = ::std::make_shared<::IceInternal::Incoming>(::std::move(incoming));
    auto responseCB = [incomingPtr](const LObjectPrxS& ret, const LObjectPrxS& iceP_o)
    {
        auto ostr = incomingPtr->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        incomingPtr->endWriteParams();
        incomingPtr->completed();
    };
    try
    {
        this->opLObjectPrxSAsync(::std::move(iceP_i), responseCB, [incomingPtr](std::exception_ptr ex) { incomingPtr->completed(ex); }, incomingPtr->current());
    }
    catch (...)
    {
        incomingPtr->failed(::std::current_exception());
    }
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opKObjectPrxS(::IceInternal::Incoming& incoming)
{
    _iceCheckMode(::Ice::OperationMode::Normal, incoming.current().mode);
    auto istr = incoming.startReadParams();
    KObjectPrxS iceP_i;
    istr->readAll(iceP_i);
    incoming.endReadParams();
    auto incomingPtr = ::std::make_shared<::IceInternal::Incoming>(::std::move(incoming));
    auto responseCB = [incomingPtr](const KObjectPrxS& ret, const KObjectPrxS& iceP_o)
    {
        auto ostr = incomingPtr->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        incomingPtr->endWriteParams();
        incomingPtr->completed();
    };
    try
    {
        this->opKObjectPrxSAsync(::std::move(iceP_i), responseCB, [incomingPtr](std::exception_ptr ex) { incomingPtr->completed(ex); }, incomingPtr->current());
    }
    catch (...)
    {
        incomingPtr->failed(::std::current_exception());
    }
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opQObjectPrxS(::IceInternal::Incoming& incoming)
{
    _iceCheckMode(::Ice::OperationMode::Normal, incoming.current().mode);
    auto istr = incoming.startReadParams();
    QObjectPrxS iceP_i;
    istr->readAll(iceP_i);
    incoming.endReadParams();
    auto incomingPtr = ::std::make_shared<::IceInternal::Incoming>(::std::move(incoming));
    auto responseCB = [incomingPtr](const QObjectPrxS& ret, const QObjectPrxS& iceP_o)
    {
        auto ostr = incomingPtr->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        incomingPtr->endWriteParams();
        incomingPtr->completed();
    };
    try
    {
        this->opQObjectPrxSAsync(::std::move(iceP_i), responseCB, [incomingPtr](std::exception_ptr ex) { incomingPtr->completed(ex); }, incomingPtr->current());
    }
    catch (...)
    {
        incomingPtr->failed(::std::current_exception());
    }
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opSObjectPrxS(::IceInternal::Incoming& incoming)
{
    _iceCheckMode(::Ice::OperationMode::Normal, incoming.current().mode);
    auto istr = incoming.startReadParams();
    SObjectPrxS iceP_i;
    istr->readAll(iceP_i);
    incoming.endReadParams();
    auto incomingPtr = ::std::make_shared<::IceInternal::Incoming>(::std::move(incoming));
    auto responseCB = [incomingPtr](const SObjectPrxS& ret, const SObjectPrxS& iceP_o)
    {
        auto ostr = incomingPtr->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        incomingPtr->endWriteParams();
        incomingPtr->completed();
    };
    try
    {
        this->opSObjectPrxSAsync(::std::move(iceP_i), responseCB, [incomingPtr](std::exception_ptr ex) { incomingPtr->completed(ex); }, incomingPtr->current());
    }
    catch (...)
    {
        incomingPtr->failed(::std::current_exception());
    }
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opAStructS(::IceInternal::Incoming& incoming)
{
    _iceCheckMode(::Ice::OperationMode::Normal, incoming.current().mode);
    auto istr = incoming.startReadParams();
    AStructS iceP_i;
    istr->readAll(iceP_i);
    incoming.endReadParams();
    auto incomingPtr = ::std::make_shared<::IceInternal::Incoming>(::std::move(incoming));
    auto responseCB = [incomingPtr](const AStructS& ret, const AStructS& iceP_o)
    {
        auto ostr = incomingPtr->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        incomingPtr->endWriteParams();
        incomingPtr->completed();
    };
    try
    {
        this->opAStructSAsync(::std::move(iceP_i), responseCB, [incomingPtr](std::exception_ptr ex) { incomingPtr->completed(ex); }, incomingPtr->current());
    }
    catch (...)
    {
        incomingPtr->failed(::std::current_exception());
    }
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opLStructS(::IceInternal::Incoming& incoming)
{
    _iceCheckMode(::Ice::OperationMode::Normal, incoming.current().mode);
    auto istr = incoming.startReadParams();
    LStructS iceP_i;
    istr->readAll(iceP_i);
    incoming.endReadParams();
    auto incomingPtr = ::std::make_shared<::IceInternal::Incoming>(::std::move(incoming));
    auto responseCB = [incomingPtr](const LStructS& ret, const LStructS& iceP_o)
    {
        auto ostr = incomingPtr->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        incomingPtr->endWriteParams();
        incomingPtr->completed();
    };
    try
    {
        this->opLStructSAsync(::std::move(iceP_i), responseCB, [incomingPtr](std::exception_ptr ex) { incomingPtr->completed(ex); }, incomingPtr->current());
    }
    catch (...)
    {
        incomingPtr->failed(::std::current_exception());
    }
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opKStructS(::IceInternal::Incoming& incoming)
{
    _iceCheckMode(::Ice::OperationMode::Normal, incoming.current().mode);
    auto istr = incoming.startReadParams();
    KStructS iceP_i;
    istr->readAll(iceP_i);
    incoming.endReadParams();
    auto incomingPtr = ::std::make_shared<::IceInternal::Incoming>(::std::move(incoming));
    auto responseCB = [incomingPtr](const KStructS& ret, const KStructS& iceP_o)
    {
        auto ostr = incomingPtr->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        incomingPtr->endWriteParams();
        incomingPtr->completed();
    };
    try
    {
        this->opKStructSAsync(::std::move(iceP_i), responseCB, [incomingPtr](std::exception_ptr ex) { incomingPtr->completed(ex); }, incomingPtr->current());
    }
    catch (...)
    {
        incomingPtr->failed(::std::current_exception());
    }
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opQStructS(::IceInternal::Incoming& incoming)
{
    _iceCheckMode(::Ice::OperationMode::Normal, incoming.current().mode);
    auto istr = incoming.startReadParams();
    QStructS iceP_i;
    istr->readAll(iceP_i);
    incoming.endReadParams();
    auto incomingPtr = ::std::make_shared<::IceInternal::Incoming>(::std::move(incoming));
    auto responseCB = [incomingPtr](const QStructS& ret, const QStructS& iceP_o)
    {
        auto ostr = incomingPtr->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        incomingPtr->endWriteParams();
        incomingPtr->completed();
    };
    try
    {
        this->opQStructSAsync(::std::move(iceP_i), responseCB, [incomingPtr](std::exception_ptr ex) { incomingPtr->completed(ex); }, incomingPtr->current());
    }
    catch (...)
    {
        incomingPtr->failed(::std::current_exception());
    }
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opSStructS(::IceInternal::Incoming& incoming)
{
    _iceCheckMode(::Ice::OperationMode::Normal, incoming.current().mode);
    auto istr = incoming.startReadParams();
    SStructS iceP_i;
    istr->readAll(iceP_i);
    incoming.endReadParams();
    auto incomingPtr = ::std::make_shared<::IceInternal::Incoming>(::std::move(incoming));
    auto responseCB = [incomingPtr](const SStructS& ret, const SStructS& iceP_o)
    {
        auto ostr = incomingPtr->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        incomingPtr->endWriteParams();
        incomingPtr->completed();
    };
    try
    {
        this->opSStructSAsync(::std::move(iceP_i), responseCB, [incomingPtr](std::exception_ptr ex) { incomingPtr->completed(ex); }, incomingPtr->current());
    }
    catch (...)
    {
        incomingPtr->failed(::std::current_exception());
    }
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opAStructSD(::IceInternal::Incoming& incoming)
{
    _iceCheckMode(::Ice::OperationMode::Normal, incoming.current().mode);
    auto istr = incoming.startReadParams();
    AStructSD iceP_i;
    istr->readAll(iceP_i);
    incoming.endReadParams();
    auto incomingPtr = ::std::make_shared<::IceInternal::Incoming>(::std::move(incoming));
    auto responseCB = [incomingPtr](const AStructSD& ret, const AStructSD& iceP_o)
    {
        auto ostr = incomingPtr->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        incomingPtr->endWriteParams();
        incomingPtr->completed();
    };
    try
    {
        this->opAStructSDAsync(::std::move(iceP_i), responseCB, [incomingPtr](std::exception_ptr ex) { incomingPtr->completed(ex); }, incomingPtr->current());
    }
    catch (...)
    {
        incomingPtr->failed(::std::current_exception());
    }
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opLStructSD(::IceInternal::Incoming& incoming)
{
    _iceCheckMode(::Ice::OperationMode::Normal, incoming.current().mode);
    auto istr = incoming.startReadParams();
    LStructSD iceP_i;
    istr->readAll(iceP_i);
    incoming.endReadParams();
    auto incomingPtr = ::std::make_shared<::IceInternal::Incoming>(::std::move(incoming));
    auto responseCB = [incomingPtr](const LStructSD& ret, const LStructSD& iceP_o)
    {
        auto ostr = incomingPtr->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        incomingPtr->endWriteParams();
        incomingPtr->completed();
    };
    try
    {
        this->opLStructSDAsync(::std::move(iceP_i), responseCB, [incomingPtr](std::exception_ptr ex) { incomingPtr->completed(ex); }, incomingPtr->current());
    }
    catch (...)
    {
        incomingPtr->failed(::std::current_exception());
    }
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opKStructSD(::IceInternal::Incoming& incoming)
{
    _iceCheckMode(::Ice::OperationMode::Normal, incoming.current().mode);
    auto istr = incoming.startReadParams();
    KStructSD iceP_i;
    istr->readAll(iceP_i);
    incoming.endReadParams();
    auto incomingPtr = ::std::make_shared<::IceInternal::Incoming>(::std::move(incoming));
    auto responseCB = [incomingPtr](const KStructSD& ret, const KStructSD& iceP_o)
    {
        auto ostr = incomingPtr->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        incomingPtr->endWriteParams();
        incomingPtr->completed();
    };
    try
    {
        this->opKStructSDAsync(::std::move(iceP_i), responseCB, [incomingPtr](std::exception_ptr ex) { incomingPtr->completed(ex); }, incomingPtr->current());
    }
    catch (...)
    {
        incomingPtr->failed(::std::current_exception());
    }
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opQStructSD(::IceInternal::Incoming& incoming)
{
    _iceCheckMode(::Ice::OperationMode::Normal, incoming.current().mode);
    auto istr = incoming.startReadParams();
    QStructSD iceP_i;
    istr->readAll(iceP_i);
    incoming.endReadParams();
    auto incomingPtr = ::std::make_shared<::IceInternal::Incoming>(::std::move(incoming));
    auto responseCB = [incomingPtr](const QStructSD& ret, const QStructSD& iceP_o)
    {
        auto ostr = incomingPtr->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        incomingPtr->endWriteParams();
        incomingPtr->completed();
    };
    try
    {
        this->opQStructSDAsync(::std::move(iceP_i), responseCB, [incomingPtr](std::exception_ptr ex) { incomingPtr->completed(ex); }, incomingPtr->current());
    }
    catch (...)
    {
        incomingPtr->failed(::std::current_exception());
    }
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opSStructSD(::IceInternal::Incoming& incoming)
{
    _iceCheckMode(::Ice::OperationMode::Normal, incoming.current().mode);
    auto istr = incoming.startReadParams();
    SStructSD iceP_i;
    istr->readAll(iceP_i);
    incoming.endReadParams();
    auto incomingPtr = ::std::make_shared<::IceInternal::Incoming>(::std::move(incoming));
    auto responseCB = [incomingPtr](const SStructSD& ret, const SStructSD& iceP_o)
    {
        auto ostr = incomingPtr->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        incomingPtr->endWriteParams();
        incomingPtr->completed();
    };
    try
    {
        this->opSStructSDAsync(::std::move(iceP_i), responseCB, [incomingPtr](std::exception_ptr ex) { incomingPtr->completed(ex); }, incomingPtr->current());
    }
    catch (...)
    {
        incomingPtr->failed(::std::current_exception());
    }
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opACVS(::IceInternal::Incoming& incoming)
{
    _iceCheckMode(::Ice::OperationMode::Normal, incoming.current().mode);
    auto istr = incoming.startReadParams();
    ACVS iceP_i;
    istr->readAll(iceP_i);
    istr->readPendingValues();
    incoming.endReadParams();
    auto incomingPtr = ::std::make_shared<::IceInternal::Incoming>(::std::move(incoming));
    auto responseCB = [incomingPtr](const ACVS& ret, const ACVS& iceP_o)
    {
        auto ostr = incomingPtr->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        ostr->writePendingValues();
        incomingPtr->endWriteParams();
        incomingPtr->completed();
    };
    try
    {
        this->opACVSAsync(::std::move(iceP_i), responseCB, [incomingPtr](std::exception_ptr ex) { incomingPtr->completed(ex); }, incomingPtr->current());
    }
    catch (...)
    {
        incomingPtr->failed(::std::current_exception());
    }
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opLCVS(::IceInternal::Incoming& incoming)
{
    _iceCheckMode(::Ice::OperationMode::Normal, incoming.current().mode);
    auto istr = incoming.startReadParams();
    LCVS iceP_i;
    istr->readAll(iceP_i);
    istr->readPendingValues();
    incoming.endReadParams();
    auto incomingPtr = ::std::make_shared<::IceInternal::Incoming>(::std::move(incoming));
    auto responseCB = [incomingPtr](const LCVS& ret, const LCVS& iceP_o)
    {
        auto ostr = incomingPtr->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        ostr->writePendingValues();
        incomingPtr->endWriteParams();
        incomingPtr->completed();
    };
    try
    {
        this->opLCVSAsync(::std::move(iceP_i), responseCB, [incomingPtr](std::exception_ptr ex) { incomingPtr->completed(ex); }, incomingPtr->current());
    }
    catch (...)
    {
        incomingPtr->failed(::std::current_exception());
    }
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opACRS(::IceInternal::Incoming& incoming)
{
    _iceCheckMode(::Ice::OperationMode::Normal, incoming.current().mode);
    auto istr = incoming.startReadParams();
    ACRS iceP_i;
    istr->readAll(iceP_i);
    istr->readPendingValues();
    incoming.endReadParams();
    auto incomingPtr = ::std::make_shared<::IceInternal::Incoming>(::std::move(incoming));
    auto responseCB = [incomingPtr](const ACRS& ret, const ACRS& iceP_o)
    {
        auto ostr = incomingPtr->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        ostr->writePendingValues();
        incomingPtr->endWriteParams();
        incomingPtr->completed();
    };
    try
    {
        this->opACRSAsync(::std::move(iceP_i), responseCB, [incomingPtr](std::exception_ptr ex) { incomingPtr->completed(ex); }, incomingPtr->current());
    }
    catch (...)
    {
        incomingPtr->failed(::std::current_exception());
    }
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opLCRS(::IceInternal::Incoming& incoming)
{
    _iceCheckMode(::Ice::OperationMode::Normal, incoming.current().mode);
    auto istr = incoming.startReadParams();
    LCRS iceP_i;
    istr->readAll(iceP_i);
    istr->readPendingValues();
    incoming.endReadParams();
    auto incomingPtr = ::std::make_shared<::IceInternal::Incoming>(::std::move(incoming));
    auto responseCB = [incomingPtr](const LCRS& ret, const LCRS& iceP_o)
    {
        auto ostr = incomingPtr->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        ostr->writePendingValues();
        incomingPtr->endWriteParams();
        incomingPtr->completed();
    };
    try
    {
        this->opLCRSAsync(::std::move(iceP_i), responseCB, [incomingPtr](std::exception_ptr ex) { incomingPtr->completed(ex); }, incomingPtr->current());
    }
    catch (...)
    {
        incomingPtr->failed(::std::current_exception());
    }
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opAEnS(::IceInternal::Incoming& incoming)
{
    _iceCheckMode(::Ice::OperationMode::Normal, incoming.current().mode);
    auto istr = incoming.startReadParams();
    AEnS iceP_i;
    istr->readAll(iceP_i);
    incoming.endReadParams();
    auto incomingPtr = ::std::make_shared<::IceInternal::Incoming>(::std::move(incoming));
    auto responseCB = [incomingPtr](const AEnS& ret, const AEnS& iceP_o)
    {
        auto ostr = incomingPtr->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        incomingPtr->endWriteParams();
        incomingPtr->completed();
    };
    try
    {
        this->opAEnSAsync(::std::move(iceP_i), responseCB, [incomingPtr](std::exception_ptr ex) { incomingPtr->completed(ex); }, incomingPtr->current());
    }
    catch (...)
    {
        incomingPtr->failed(::std::current_exception());
    }
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opLEnS(::IceInternal::Incoming& incoming)
{
    _iceCheckMode(::Ice::OperationMode::Normal, incoming.current().mode);
    auto istr = incoming.startReadParams();
    LEnS iceP_i;
    istr->readAll(iceP_i);
    incoming.endReadParams();
    auto incomingPtr = ::std::make_shared<::IceInternal::Incoming>(::std::move(incoming));
    auto responseCB = [incomingPtr](const LEnS& ret, const LEnS& iceP_o)
    {
        auto ostr = incomingPtr->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        incomingPtr->endWriteParams();
        incomingPtr->completed();
    };
    try
    {
        this->opLEnSAsync(::std::move(iceP_i), responseCB, [incomingPtr](std::exception_ptr ex) { incomingPtr->completed(ex); }, incomingPtr->current());
    }
    catch (...)
    {
        incomingPtr->failed(::std::current_exception());
    }
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opKEnS(::IceInternal::Incoming& incoming)
{
    _iceCheckMode(::Ice::OperationMode::Normal, incoming.current().mode);
    auto istr = incoming.startReadParams();
    KEnS iceP_i;
    istr->readAll(iceP_i);
    incoming.endReadParams();
    auto incomingPtr = ::std::make_shared<::IceInternal::Incoming>(::std::move(incoming));
    auto responseCB = [incomingPtr](const KEnS& ret, const KEnS& iceP_o)
    {
        auto ostr = incomingPtr->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        incomingPtr->endWriteParams();
        incomingPtr->completed();
    };
    try
    {
        this->opKEnSAsync(::std::move(iceP_i), responseCB, [incomingPtr](std::exception_ptr ex) { incomingPtr->completed(ex); }, incomingPtr->current());
    }
    catch (...)
    {
        incomingPtr->failed(::std::current_exception());
    }
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opQEnS(::IceInternal::Incoming& incoming)
{
    _iceCheckMode(::Ice::OperationMode::Normal, incoming.current().mode);
    auto istr = incoming.startReadParams();
    QEnS iceP_i;
    istr->readAll(iceP_i);
    incoming.endReadParams();
    auto incomingPtr = ::std::make_shared<::IceInternal::Incoming>(::std::move(incoming));
    auto responseCB = [incomingPtr](const QEnS& ret, const QEnS& iceP_o)
    {
        auto ostr = incomingPtr->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        incomingPtr->endWriteParams();
        incomingPtr->completed();
    };
    try
    {
        this->opQEnSAsync(::std::move(iceP_i), responseCB, [incomingPtr](std::exception_ptr ex) { incomingPtr->completed(ex); }, incomingPtr->current());
    }
    catch (...)
    {
        incomingPtr->failed(::std::current_exception());
    }
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opSEnS(::IceInternal::Incoming& incoming)
{
    _iceCheckMode(::Ice::OperationMode::Normal, incoming.current().mode);
    auto istr = incoming.startReadParams();
    SEnS iceP_i;
    istr->readAll(iceP_i);
    incoming.endReadParams();
    auto incomingPtr = ::std::make_shared<::IceInternal::Incoming>(::std::move(incoming));
    auto responseCB = [incomingPtr](const SEnS& ret, const SEnS& iceP_o)
    {
        auto ostr = incomingPtr->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        incomingPtr->endWriteParams();
        incomingPtr->completed();
    };
    try
    {
        this->opSEnSAsync(::std::move(iceP_i), responseCB, [incomingPtr](std::exception_ptr ex) { incomingPtr->completed(ex); }, incomingPtr->current());
    }
    catch (...)
    {
        incomingPtr->failed(::std::current_exception());
    }
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opAIPrxS(::IceInternal::Incoming& incoming)
{
    _iceCheckMode(::Ice::OperationMode::Normal, incoming.current().mode);
    auto istr = incoming.startReadParams();
    AIPrxS iceP_i;
    istr->readAll(iceP_i);
    incoming.endReadParams();
    auto incomingPtr = ::std::make_shared<::IceInternal::Incoming>(::std::move(incoming));
    auto responseCB = [incomingPtr](const AIPrxS& ret, const AIPrxS& iceP_o)
    {
        auto ostr = incomingPtr->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        incomingPtr->endWriteParams();
        incomingPtr->completed();
    };
    try
    {
        this->opAIPrxSAsync(::std::move(iceP_i), responseCB, [incomingPtr](std::exception_ptr ex) { incomingPtr->completed(ex); }, incomingPtr->current());
    }
    catch (...)
    {
        incomingPtr->failed(::std::current_exception());
    }
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opLIPrxS(::IceInternal::Incoming& incoming)
{
    _iceCheckMode(::Ice::OperationMode::Normal, incoming.current().mode);
    auto istr = incoming.startReadParams();
    LIPrxS iceP_i;
    istr->readAll(iceP_i);
    incoming.endReadParams();
    auto incomingPtr = ::std::make_shared<::IceInternal::Incoming>(::std::move(incoming));
    auto responseCB = [incomingPtr](const LIPrxS& ret, const LIPrxS& iceP_o)
    {
        auto ostr = incomingPtr->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        incomingPtr->endWriteParams();
        incomingPtr->completed();
    };
    try
    {
        this->opLIPrxSAsync(::std::move(iceP_i), responseCB, [incomingPtr](std::exception_ptr ex) { incomingPtr->completed(ex); }, incomingPtr->current());
    }
    catch (...)
    {
        incomingPtr->failed(::std::current_exception());
    }
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opKIPrxS(::IceInternal::Incoming& incoming)
{
    _iceCheckMode(::Ice::OperationMode::Normal, incoming.current().mode);
    auto istr = incoming.startReadParams();
    KIPrxS iceP_i;
    istr->readAll(iceP_i);
    incoming.endReadParams();
    auto incomingPtr = ::std::make_shared<::IceInternal::Incoming>(::std::move(incoming));
    auto responseCB = [incomingPtr](const KIPrxS& ret, const KIPrxS& iceP_o)
    {
        auto ostr = incomingPtr->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        incomingPtr->endWriteParams();
        incomingPtr->completed();
    };
    try
    {
        this->opKIPrxSAsync(::std::move(iceP_i), responseCB, [incomingPtr](std::exception_ptr ex) { incomingPtr->completed(ex); }, incomingPtr->current());
    }
    catch (...)
    {
        incomingPtr->failed(::std::current_exception());
    }
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opQIPrxS(::IceInternal::Incoming& incoming)
{
    _iceCheckMode(::Ice::OperationMode::Normal, incoming.current().mode);
    auto istr = incoming.startReadParams();
    QIPrxS iceP_i;
    istr->readAll(iceP_i);
    incoming.endReadParams();
    auto incomingPtr = ::std::make_shared<::IceInternal::Incoming>(::std::move(incoming));
    auto responseCB = [incomingPtr](const QIPrxS& ret, const QIPrxS& iceP_o)
    {
        auto ostr = incomingPtr->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        incomingPtr->endWriteParams();
        incomingPtr->completed();
    };
    try
    {
        this->opQIPrxSAsync(::std::move(iceP_i), responseCB, [incomingPtr](std::exception_ptr ex) { incomingPtr->completed(ex); }, incomingPtr->current());
    }
    catch (...)
    {
        incomingPtr->failed(::std::current_exception());
    }
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opSIPrxS(::IceInternal::Incoming& incoming)
{
    _iceCheckMode(::Ice::OperationMode::Normal, incoming.current().mode);
    auto istr = incoming.startReadParams();
    SIPrxS iceP_i;
    istr->readAll(iceP_i);
    incoming.endReadParams();
    auto incomingPtr = ::std::make_shared<::IceInternal::Incoming>(::std::move(incoming));
    auto responseCB = [incomingPtr](const SIPrxS& ret, const SIPrxS& iceP_o)
    {
        auto ostr = incomingPtr->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        incomingPtr->endWriteParams();
        incomingPtr->completed();
    };
    try
    {
        this->opSIPrxSAsync(::std::move(iceP_i), responseCB, [incomingPtr](std::exception_ptr ex) { incomingPtr->completed(ex); }, incomingPtr->current());
    }
    catch (...)
    {
        incomingPtr->failed(::std::current_exception());
    }
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opCustomIntS(::IceInternal::Incoming& incoming)
{
    _iceCheckMode(::Ice::OperationMode::Normal, incoming.current().mode);
    auto istr = incoming.startReadParams();
    CustomIntS iceP_i;
    istr->readAll(iceP_i);
    incoming.endReadParams();
    auto incomingPtr = ::std::make_shared<::IceInternal::Incoming>(::std::move(incoming));
    auto responseCB = [incomingPtr](const CustomIntS& ret, const CustomIntS& iceP_o)
    {
        auto ostr = incomingPtr->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        incomingPtr->endWriteParams();
        incomingPtr->completed();
    };
    try
    {
        this->opCustomIntSAsync(::std::move(iceP_i), responseCB, [incomingPtr](std::exception_ptr ex) { incomingPtr->completed(ex); }, incomingPtr->current());
    }
    catch (...)
    {
        incomingPtr->failed(::std::current_exception());
    }
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opCustomCVS(::IceInternal::Incoming& incoming)
{
    _iceCheckMode(::Ice::OperationMode::Normal, incoming.current().mode);
    auto istr = incoming.startReadParams();
    CustomCVS iceP_i;
    istr->readAll(iceP_i);
    istr->readPendingValues();
    incoming.endReadParams();
    auto incomingPtr = ::std::make_shared<::IceInternal::Incoming>(::std::move(incoming));
    auto responseCB = [incomingPtr](const CustomCVS& ret, const CustomCVS& iceP_o)
    {
        auto ostr = incomingPtr->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        ostr->writePendingValues();
        incomingPtr->endWriteParams();
        incomingPtr->completed();
    };
    try
    {
        this->opCustomCVSAsync(::std::move(iceP_i), responseCB, [incomingPtr](std::exception_ptr ex) { incomingPtr->completed(ex); }, incomingPtr->current());
    }
    catch (...)
    {
        incomingPtr->failed(::std::current_exception());
    }
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opCustomIntSS(::IceInternal::Incoming& incoming)
{
    _iceCheckMode(::Ice::OperationMode::Normal, incoming.current().mode);
    auto istr = incoming.startReadParams();
    CustomIntSS iceP_i;
    istr->readAll(iceP_i);
    incoming.endReadParams();
    auto incomingPtr = ::std::make_shared<::IceInternal::Incoming>(::std::move(incoming));
    auto responseCB = [incomingPtr](const CustomIntSS& ret, const CustomIntSS& iceP_o)
    {
        auto ostr = incomingPtr->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        incomingPtr->endWriteParams();
        incomingPtr->completed();
    };
    try
    {
        this->opCustomIntSSAsync(::std::move(iceP_i), responseCB, [incomingPtr](std::exception_ptr ex) { incomingPtr->completed(ex); }, incomingPtr->current());
    }
    catch (...)
    {
        incomingPtr->failed(::std::current_exception());
    }
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opCustomCVSS(::IceInternal::Incoming& incoming)
{
    _iceCheckMode(::Ice::OperationMode::Normal, incoming.current().mode);
    auto istr = incoming.startReadParams();
    CustomCVSS iceP_i;
    istr->readAll(iceP_i);
    istr->readPendingValues();
    incoming.endReadParams();
    auto incomingPtr = ::std::make_shared<::IceInternal::Incoming>(::std::move(incoming));
    auto responseCB = [incomingPtr](const CustomCVSS& ret, const CustomCVSS& iceP_o)
    {
        auto ostr = incomingPtr->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        ostr->writePendingValues();
        incomingPtr->endWriteParams();
        incomingPtr->completed();
    };
    try
    {
        this->opCustomCVSSAsync(::std::move(iceP_i), responseCB, [incomingPtr](std::exception_ptr ex) { incomingPtr->completed(ex); }, incomingPtr->current());
    }
    catch (...)
    {
        incomingPtr->failed(::std::current_exception());
    }
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceDispatch(::IceInternal::Incoming& incoming)
{
    static constexpr ::std::string_view allOperations[] = {"ice_id", "ice_ids", "ice_isA", "ice_ping", "opABoolS", "opAByteS", "opACRS", "opACVS", "opADoubleS", "opAEnS", "opAFloatS", "opAIPrxS", "opAIntS", "opALongS", "opAObjectPrxS", "opAObjectS", "opAShortS", "opAStringS", "opAStructS", "opAStructSD", "opCustomCVS", "opCustomCVSS", "opCustomIntS", "opCustomIntSS", "opKBoolS", "opKByteS", "opKDoubleS", "opKEnS", "opKFloatS", "opKIPrxS", "opKIntS", "opKLongS", "opKObjectPrxS", "opKShortS", "opKStringS", "opKStructS", "opKStructSD", "opLBoolS", "opLByteS", "opLCRS", "opLCVS", "opLDoubleS", "opLEnS", "opLFloatS", "opLIPrxS", "opLIntS", "opLLongS", "opLObjectPrxS", "opLObjectS", "opLShortS", "opLStringS", "opLStructS", "opLStructSD", "opQBoolS", "opQByteS", "opQDoubleS", "opQEnS", "opQFloatS", "opQIPrxS", "opQIntS", "opQLongS", "opQObjectPrxS", "opQShortS", "opQStringS", "opQStructS", "opQStructSD", "opSBoolS", "opSByteS", "opSDoubleS", "opSEnS", "opSFloatS", "opSIPrxS", "opSIntS", "opSLongS", "opSObjectPrxS", "opSShortS", "opSStringS", "opSStructS", "opSStructSD", "shutdown"};

    const ::Ice::Current& current = incoming.current();
    ::std::pair<const ::std::string_view*, const ::std::string_view*> r = ::std::equal_range(allOperations, allOperations + 80, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - allOperations)
    {
        case 0:
        {
            return _iceD_ice_id(incoming);
        }
        case 1:
        {
            return _iceD_ice_ids(incoming);
        }
        case 2:
        {
            return _iceD_ice_isA(incoming);
        }
        case 3:
        {
            return _iceD_ice_ping(incoming);
        }
        case 4:
        {
            return _iceD_opABoolS(incoming);
        }
        case 5:
        {
            return _iceD_opAByteS(incoming);
        }
        case 6:
        {
            return _iceD_opACRS(incoming);
        }
        case 7:
        {
            return _iceD_opACVS(incoming);
        }
        case 8:
        {
            return _iceD_opADoubleS(incoming);
        }
        case 9:
        {
            return _iceD_opAEnS(incoming);
        }
        case 10:
        {
            return _iceD_opAFloatS(incoming);
        }
        case 11:
        {
            return _iceD_opAIPrxS(incoming);
        }
        case 12:
        {
            return _iceD_opAIntS(incoming);
        }
        case 13:
        {
            return _iceD_opALongS(incoming);
        }
        case 14:
        {
            return _iceD_opAObjectPrxS(incoming);
        }
        case 15:
        {
            return _iceD_opAObjectS(incoming);
        }
        case 16:
        {
            return _iceD_opAShortS(incoming);
        }
        case 17:
        {
            return _iceD_opAStringS(incoming);
        }
        case 18:
        {
            return _iceD_opAStructS(incoming);
        }
        case 19:
        {
            return _iceD_opAStructSD(incoming);
        }
        case 20:
        {
            return _iceD_opCustomCVS(incoming);
        }
        case 21:
        {
            return _iceD_opCustomCVSS(incoming);
        }
        case 22:
        {
            return _iceD_opCustomIntS(incoming);
        }
        case 23:
        {
            return _iceD_opCustomIntSS(incoming);
        }
        case 24:
        {
            return _iceD_opKBoolS(incoming);
        }
        case 25:
        {
            return _iceD_opKByteS(incoming);
        }
        case 26:
        {
            return _iceD_opKDoubleS(incoming);
        }
        case 27:
        {
            return _iceD_opKEnS(incoming);
        }
        case 28:
        {
            return _iceD_opKFloatS(incoming);
        }
        case 29:
        {
            return _iceD_opKIPrxS(incoming);
        }
        case 30:
        {
            return _iceD_opKIntS(incoming);
        }
        case 31:
        {
            return _iceD_opKLongS(incoming);
        }
        case 32:
        {
            return _iceD_opKObjectPrxS(incoming);
        }
        case 33:
        {
            return _iceD_opKShortS(incoming);
        }
        case 34:
        {
            return _iceD_opKStringS(incoming);
        }
        case 35:
        {
            return _iceD_opKStructS(incoming);
        }
        case 36:
        {
            return _iceD_opKStructSD(incoming);
        }
        case 37:
        {
            return _iceD_opLBoolS(incoming);
        }
        case 38:
        {
            return _iceD_opLByteS(incoming);
        }
        case 39:
        {
            return _iceD_opLCRS(incoming);
        }
        case 40:
        {
            return _iceD_opLCVS(incoming);
        }
        case 41:
        {
            return _iceD_opLDoubleS(incoming);
        }
        case 42:
        {
            return _iceD_opLEnS(incoming);
        }
        case 43:
        {
            return _iceD_opLFloatS(incoming);
        }
        case 44:
        {
            return _iceD_opLIPrxS(incoming);
        }
        case 45:
        {
            return _iceD_opLIntS(incoming);
        }
        case 46:
        {
            return _iceD_opLLongS(incoming);
        }
        case 47:
        {
            return _iceD_opLObjectPrxS(incoming);
        }
        case 48:
        {
            return _iceD_opLObjectS(incoming);
        }
        case 49:
        {
            return _iceD_opLShortS(incoming);
        }
        case 50:
        {
            return _iceD_opLStringS(incoming);
        }
        case 51:
        {
            return _iceD_opLStructS(incoming);
        }
        case 52:
        {
            return _iceD_opLStructSD(incoming);
        }
        case 53:
        {
            return _iceD_opQBoolS(incoming);
        }
        case 54:
        {
            return _iceD_opQByteS(incoming);
        }
        case 55:
        {
            return _iceD_opQDoubleS(incoming);
        }
        case 56:
        {
            return _iceD_opQEnS(incoming);
        }
        case 57:
        {
            return _iceD_opQFloatS(incoming);
        }
        case 58:
        {
            return _iceD_opQIPrxS(incoming);
        }
        case 59:
        {
            return _iceD_opQIntS(incoming);
        }
        case 60:
        {
            return _iceD_opQLongS(incoming);
        }
        case 61:
        {
            return _iceD_opQObjectPrxS(incoming);
        }
        case 62:
        {
            return _iceD_opQShortS(incoming);
        }
        case 63:
        {
            return _iceD_opQStringS(incoming);
        }
        case 64:
        {
            return _iceD_opQStructS(incoming);
        }
        case 65:
        {
            return _iceD_opQStructSD(incoming);
        }
        case 66:
        {
            return _iceD_opSBoolS(incoming);
        }
        case 67:
        {
            return _iceD_opSByteS(incoming);
        }
        case 68:
        {
            return _iceD_opSDoubleS(incoming);
        }
        case 69:
        {
            return _iceD_opSEnS(incoming);
        }
        case 70:
        {
            return _iceD_opSFloatS(incoming);
        }
        case 71:
        {
            return _iceD_opSIPrxS(incoming);
        }
        case 72:
        {
            return _iceD_opSIntS(incoming);
        }
        case 73:
        {
            return _iceD_opSLongS(incoming);
        }
        case 74:
        {
            return _iceD_opSObjectPrxS(incoming);
        }
        case 75:
        {
            return _iceD_opSShortS(incoming);
        }
        case 76:
        {
            return _iceD_opSStringS(incoming);
        }
        case 77:
        {
            return _iceD_opSStructS(incoming);
        }
        case 78:
        {
            return _iceD_opSStructSD(incoming);
        }
        case 79:
        {
            return _iceD_shutdown(incoming);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond
