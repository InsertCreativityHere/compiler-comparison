//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.7.10
//
// <auto-generated>
//
// Generated from file `TestAMD.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#define ICE_BUILDING_GENERATED_CODE
#include <TestAMD.h>
#include <IceUtil/PushDisableWarnings.h>
#include <IceUtil/PopDisableWarnings.h>

#if defined(_MSC_VER)
#   pragma warning(disable:4458) // declaration of ... hides class member
#elif defined(__clang__)
#   pragma clang diagnostic ignored "-Wshadow"
#elif defined(__GNUC__)
#   pragma GCC diagnostic ignored "-Wshadow"
#endif

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 307
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 >= 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 10
#       error Ice patch level mismatch!
#   endif
#endif

#ifdef ICE_CPP11_MAPPING // C++11 mapping

namespace
{

const ::IceInternal::DefaultValueFactoryInit<::Test::CV> iceC_Test_CV_init("::Test::CV");

const ::std::string iceC_Test_I_ids[2] =
{
    "::Ice::Object",
    "::Test::I"
};
const ::std::string iceC_Test_I_ops[] =
{
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};

const ::IceInternal::DefaultValueFactoryInit<::Test::CR> iceC_Test_CR_init("::Test::CR");

const ::std::string iceC_Test_MyClass_ids[2] =
{
    "::Ice::Object",
    "::Test::MyClass"
};
const ::std::string iceC_Test_MyClass_ops[] =
{
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "opABoolS",
    "opAByteS",
    "opACRS",
    "opACVS",
    "opADoubleS",
    "opAEnS",
    "opAFloatS",
    "opAIPrxS",
    "opAIntS",
    "opALongS",
    "opAObjectPrxS",
    "opAObjectS",
    "opAShortS",
    "opAStringS",
    "opAStructS",
    "opAStructSD",
    "opCustomCVS",
    "opCustomCVSS",
    "opCustomIntS",
    "opCustomIntSS",
    "opKBoolS",
    "opKByteS",
    "opKDoubleS",
    "opKEnS",
    "opKFloatS",
    "opKIPrxS",
    "opKIntS",
    "opKLongS",
    "opKObjectPrxS",
    "opKShortS",
    "opKStringS",
    "opKStructS",
    "opKStructSD",
    "opLBoolS",
    "opLByteS",
    "opLCRS",
    "opLCVS",
    "opLDoubleS",
    "opLEnS",
    "opLFloatS",
    "opLIPrxS",
    "opLIntS",
    "opLLongS",
    "opLObjectPrxS",
    "opLObjectS",
    "opLShortS",
    "opLStringS",
    "opLStructS",
    "opLStructSD",
    "opQBoolS",
    "opQByteS",
    "opQDoubleS",
    "opQEnS",
    "opQFloatS",
    "opQIPrxS",
    "opQIntS",
    "opQLongS",
    "opQObjectPrxS",
    "opQShortS",
    "opQStringS",
    "opQStructS",
    "opQStructSD",
    "opSBoolS",
    "opSByteS",
    "opSDoubleS",
    "opSEnS",
    "opSFloatS",
    "opSIPrxS",
    "opSIntS",
    "opSLongS",
    "opSObjectPrxS",
    "opSShortS",
    "opSStringS",
    "opSStructS",
    "opSStructSD",
    "shutdown"
};
const ::std::string iceC_Test_MyClass_shutdown_name = "shutdown";
const ::std::string iceC_Test_MyClass_opAByteS_name = "opAByteS";
const ::std::string iceC_Test_MyClass_opLByteS_name = "opLByteS";
const ::std::string iceC_Test_MyClass_opKByteS_name = "opKByteS";
const ::std::string iceC_Test_MyClass_opQByteS_name = "opQByteS";
const ::std::string iceC_Test_MyClass_opSByteS_name = "opSByteS";
const ::std::string iceC_Test_MyClass_opABoolS_name = "opABoolS";
const ::std::string iceC_Test_MyClass_opLBoolS_name = "opLBoolS";
const ::std::string iceC_Test_MyClass_opKBoolS_name = "opKBoolS";
const ::std::string iceC_Test_MyClass_opQBoolS_name = "opQBoolS";
const ::std::string iceC_Test_MyClass_opSBoolS_name = "opSBoolS";
const ::std::string iceC_Test_MyClass_opAShortS_name = "opAShortS";
const ::std::string iceC_Test_MyClass_opLShortS_name = "opLShortS";
const ::std::string iceC_Test_MyClass_opKShortS_name = "opKShortS";
const ::std::string iceC_Test_MyClass_opQShortS_name = "opQShortS";
const ::std::string iceC_Test_MyClass_opSShortS_name = "opSShortS";
const ::std::string iceC_Test_MyClass_opAIntS_name = "opAIntS";
const ::std::string iceC_Test_MyClass_opLIntS_name = "opLIntS";
const ::std::string iceC_Test_MyClass_opKIntS_name = "opKIntS";
const ::std::string iceC_Test_MyClass_opQIntS_name = "opQIntS";
const ::std::string iceC_Test_MyClass_opSIntS_name = "opSIntS";
const ::std::string iceC_Test_MyClass_opALongS_name = "opALongS";
const ::std::string iceC_Test_MyClass_opLLongS_name = "opLLongS";
const ::std::string iceC_Test_MyClass_opKLongS_name = "opKLongS";
const ::std::string iceC_Test_MyClass_opQLongS_name = "opQLongS";
const ::std::string iceC_Test_MyClass_opSLongS_name = "opSLongS";
const ::std::string iceC_Test_MyClass_opAFloatS_name = "opAFloatS";
const ::std::string iceC_Test_MyClass_opLFloatS_name = "opLFloatS";
const ::std::string iceC_Test_MyClass_opKFloatS_name = "opKFloatS";
const ::std::string iceC_Test_MyClass_opQFloatS_name = "opQFloatS";
const ::std::string iceC_Test_MyClass_opSFloatS_name = "opSFloatS";
const ::std::string iceC_Test_MyClass_opADoubleS_name = "opADoubleS";
const ::std::string iceC_Test_MyClass_opLDoubleS_name = "opLDoubleS";
const ::std::string iceC_Test_MyClass_opKDoubleS_name = "opKDoubleS";
const ::std::string iceC_Test_MyClass_opQDoubleS_name = "opQDoubleS";
const ::std::string iceC_Test_MyClass_opSDoubleS_name = "opSDoubleS";
const ::std::string iceC_Test_MyClass_opAStringS_name = "opAStringS";
const ::std::string iceC_Test_MyClass_opLStringS_name = "opLStringS";
const ::std::string iceC_Test_MyClass_opKStringS_name = "opKStringS";
const ::std::string iceC_Test_MyClass_opQStringS_name = "opQStringS";
const ::std::string iceC_Test_MyClass_opSStringS_name = "opSStringS";
const ::std::string iceC_Test_MyClass_opAObjectS_name = "opAObjectS";
const ::std::string iceC_Test_MyClass_opLObjectS_name = "opLObjectS";
const ::std::string iceC_Test_MyClass_opAObjectPrxS_name = "opAObjectPrxS";
const ::std::string iceC_Test_MyClass_opLObjectPrxS_name = "opLObjectPrxS";
const ::std::string iceC_Test_MyClass_opKObjectPrxS_name = "opKObjectPrxS";
const ::std::string iceC_Test_MyClass_opQObjectPrxS_name = "opQObjectPrxS";
const ::std::string iceC_Test_MyClass_opSObjectPrxS_name = "opSObjectPrxS";
const ::std::string iceC_Test_MyClass_opAStructS_name = "opAStructS";
const ::std::string iceC_Test_MyClass_opLStructS_name = "opLStructS";
const ::std::string iceC_Test_MyClass_opKStructS_name = "opKStructS";
const ::std::string iceC_Test_MyClass_opQStructS_name = "opQStructS";
const ::std::string iceC_Test_MyClass_opSStructS_name = "opSStructS";
const ::std::string iceC_Test_MyClass_opAStructSD_name = "opAStructSD";
const ::std::string iceC_Test_MyClass_opLStructSD_name = "opLStructSD";
const ::std::string iceC_Test_MyClass_opKStructSD_name = "opKStructSD";
const ::std::string iceC_Test_MyClass_opQStructSD_name = "opQStructSD";
const ::std::string iceC_Test_MyClass_opSStructSD_name = "opSStructSD";
const ::std::string iceC_Test_MyClass_opACVS_name = "opACVS";
const ::std::string iceC_Test_MyClass_opLCVS_name = "opLCVS";
const ::std::string iceC_Test_MyClass_opACRS_name = "opACRS";
const ::std::string iceC_Test_MyClass_opLCRS_name = "opLCRS";
const ::std::string iceC_Test_MyClass_opAEnS_name = "opAEnS";
const ::std::string iceC_Test_MyClass_opLEnS_name = "opLEnS";
const ::std::string iceC_Test_MyClass_opKEnS_name = "opKEnS";
const ::std::string iceC_Test_MyClass_opQEnS_name = "opQEnS";
const ::std::string iceC_Test_MyClass_opSEnS_name = "opSEnS";
const ::std::string iceC_Test_MyClass_opAIPrxS_name = "opAIPrxS";
const ::std::string iceC_Test_MyClass_opLIPrxS_name = "opLIPrxS";
const ::std::string iceC_Test_MyClass_opKIPrxS_name = "opKIPrxS";
const ::std::string iceC_Test_MyClass_opQIPrxS_name = "opQIPrxS";
const ::std::string iceC_Test_MyClass_opSIPrxS_name = "opSIPrxS";
const ::std::string iceC_Test_MyClass_opCustomIntS_name = "opCustomIntS";
const ::std::string iceC_Test_MyClass_opCustomCVS_name = "opCustomCVS";
const ::std::string iceC_Test_MyClass_opCustomIntSS_name = "opCustomIntSS";
const ::std::string iceC_Test_MyClass_opCustomCVSS_name = "opCustomCVSS";

}

bool
Test::I::ice_isA(::std::string s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_I_ids, iceC_Test_I_ids + 2, s);
}

::std::vector<::std::string>
Test::I::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector<::std::string>(&iceC_Test_I_ids[0], &iceC_Test_I_ids[2]);
}

::std::string
Test::I::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::I::ice_staticId()
{
    static const ::std::string typeId = "::Test::I";
    return typeId;
}

bool
Test::MyClass::ice_isA(::std::string s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_MyClass_ids, iceC_Test_MyClass_ids + 2, s);
}

::std::vector<::std::string>
Test::MyClass::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector<::std::string>(&iceC_Test_MyClass_ids[0], &iceC_Test_MyClass_ids[2]);
}

::std::string
Test::MyClass::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::MyClass::ice_staticId()
{
    static const ::std::string typeId = "::Test::MyClass";
    return typeId;
}

/// \cond INTERNAL
bool
Test::MyClass::_iceD_shutdown(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    this->shutdownAsync(inA->response(), inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opAByteS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    AByteS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const AByteS& ret, const AByteS& iceP_o)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opAByteSAsync(::std::move(iceP_i), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opLByteS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    LByteS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const LByteS& ret, const LByteS& iceP_o)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opLByteSAsync(::std::move(iceP_i), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opKByteS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    KByteS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const KByteS& ret, const KByteS& iceP_o)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opKByteSAsync(::std::move(iceP_i), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opQByteS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    QByteS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const QByteS& ret, const QByteS& iceP_o)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opQByteSAsync(::std::move(iceP_i), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opSByteS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    SByteS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const SByteS& ret, const SByteS& iceP_o)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opSByteSAsync(::std::move(iceP_i), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opABoolS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ABoolS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const ABoolS& ret, const ABoolS& iceP_o)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opABoolSAsync(::std::move(iceP_i), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opLBoolS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    LBoolS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const LBoolS& ret, const LBoolS& iceP_o)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opLBoolSAsync(::std::move(iceP_i), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opKBoolS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    KBoolS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const KBoolS& ret, const KBoolS& iceP_o)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opKBoolSAsync(::std::move(iceP_i), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opQBoolS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    QBoolS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const QBoolS& ret, const QBoolS& iceP_o)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opQBoolSAsync(::std::move(iceP_i), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opSBoolS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    SBoolS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const SBoolS& ret, const SBoolS& iceP_o)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opSBoolSAsync(::std::move(iceP_i), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opAShortS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    AShortS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const AShortS& ret, const AShortS& iceP_o)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opAShortSAsync(::std::move(iceP_i), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opLShortS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    LShortS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const LShortS& ret, const LShortS& iceP_o)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opLShortSAsync(::std::move(iceP_i), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opKShortS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    KShortS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const KShortS& ret, const KShortS& iceP_o)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opKShortSAsync(::std::move(iceP_i), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opQShortS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    QShortS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const QShortS& ret, const QShortS& iceP_o)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opQShortSAsync(::std::move(iceP_i), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opSShortS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    SShortS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const SShortS& ret, const SShortS& iceP_o)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opSShortSAsync(::std::move(iceP_i), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opAIntS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    AIntS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const AIntS& ret, const AIntS& iceP_o)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opAIntSAsync(::std::move(iceP_i), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opLIntS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    LIntS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const LIntS& ret, const LIntS& iceP_o)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opLIntSAsync(::std::move(iceP_i), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opKIntS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    KIntS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const KIntS& ret, const KIntS& iceP_o)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opKIntSAsync(::std::move(iceP_i), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opQIntS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    QIntS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const QIntS& ret, const QIntS& iceP_o)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opQIntSAsync(::std::move(iceP_i), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opSIntS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    SIntS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const SIntS& ret, const SIntS& iceP_o)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opSIntSAsync(::std::move(iceP_i), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opALongS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ALongS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const ALongS& ret, const ALongS& iceP_o)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opALongSAsync(::std::move(iceP_i), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opLLongS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    LLongS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const LLongS& ret, const LLongS& iceP_o)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opLLongSAsync(::std::move(iceP_i), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opKLongS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    KLongS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const KLongS& ret, const KLongS& iceP_o)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opKLongSAsync(::std::move(iceP_i), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opQLongS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    QLongS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const QLongS& ret, const QLongS& iceP_o)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opQLongSAsync(::std::move(iceP_i), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opSLongS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    SLongS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const SLongS& ret, const SLongS& iceP_o)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opSLongSAsync(::std::move(iceP_i), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opAFloatS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    AFloatS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const AFloatS& ret, const AFloatS& iceP_o)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opAFloatSAsync(::std::move(iceP_i), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opLFloatS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    LFloatS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const LFloatS& ret, const LFloatS& iceP_o)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opLFloatSAsync(::std::move(iceP_i), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opKFloatS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    KFloatS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const KFloatS& ret, const KFloatS& iceP_o)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opKFloatSAsync(::std::move(iceP_i), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opQFloatS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    QFloatS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const QFloatS& ret, const QFloatS& iceP_o)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opQFloatSAsync(::std::move(iceP_i), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opSFloatS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    SFloatS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const SFloatS& ret, const SFloatS& iceP_o)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opSFloatSAsync(::std::move(iceP_i), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opADoubleS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ADoubleS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const ADoubleS& ret, const ADoubleS& iceP_o)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opADoubleSAsync(::std::move(iceP_i), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opLDoubleS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    LDoubleS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const LDoubleS& ret, const LDoubleS& iceP_o)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opLDoubleSAsync(::std::move(iceP_i), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opKDoubleS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    KDoubleS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const KDoubleS& ret, const KDoubleS& iceP_o)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opKDoubleSAsync(::std::move(iceP_i), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opQDoubleS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    QDoubleS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const QDoubleS& ret, const QDoubleS& iceP_o)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opQDoubleSAsync(::std::move(iceP_i), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opSDoubleS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    SDoubleS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const SDoubleS& ret, const SDoubleS& iceP_o)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opSDoubleSAsync(::std::move(iceP_i), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opAStringS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    AStringS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const AStringS& ret, const AStringS& iceP_o)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opAStringSAsync(::std::move(iceP_i), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opLStringS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    LStringS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const LStringS& ret, const LStringS& iceP_o)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opLStringSAsync(::std::move(iceP_i), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opKStringS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    KStringS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const KStringS& ret, const KStringS& iceP_o)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opKStringSAsync(::std::move(iceP_i), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opQStringS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    QStringS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const QStringS& ret, const QStringS& iceP_o)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opQStringSAsync(::std::move(iceP_i), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opSStringS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    SStringS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const SStringS& ret, const SStringS& iceP_o)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opSStringSAsync(::std::move(iceP_i), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opAObjectS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    AObjectS iceP_i;
    istr->readAll(iceP_i);
    istr->readPendingValues();
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const AObjectS& ret, const AObjectS& iceP_o)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        ostr->writePendingValues();
        inA->endWriteParams();
        inA->completed();
    };
    this->opAObjectSAsync(::std::move(iceP_i), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opLObjectS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    LObjectS iceP_i;
    istr->readAll(iceP_i);
    istr->readPendingValues();
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const LObjectS& ret, const LObjectS& iceP_o)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        ostr->writePendingValues();
        inA->endWriteParams();
        inA->completed();
    };
    this->opLObjectSAsync(::std::move(iceP_i), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opAObjectPrxS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    AObjectPrxS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const AObjectPrxS& ret, const AObjectPrxS& iceP_o)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opAObjectPrxSAsync(::std::move(iceP_i), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opLObjectPrxS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    LObjectPrxS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const LObjectPrxS& ret, const LObjectPrxS& iceP_o)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opLObjectPrxSAsync(::std::move(iceP_i), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opKObjectPrxS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    KObjectPrxS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const KObjectPrxS& ret, const KObjectPrxS& iceP_o)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opKObjectPrxSAsync(::std::move(iceP_i), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opQObjectPrxS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    QObjectPrxS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const QObjectPrxS& ret, const QObjectPrxS& iceP_o)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opQObjectPrxSAsync(::std::move(iceP_i), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opSObjectPrxS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    SObjectPrxS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const SObjectPrxS& ret, const SObjectPrxS& iceP_o)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opSObjectPrxSAsync(::std::move(iceP_i), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opAStructS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    AStructS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const AStructS& ret, const AStructS& iceP_o)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opAStructSAsync(::std::move(iceP_i), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opLStructS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    LStructS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const LStructS& ret, const LStructS& iceP_o)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opLStructSAsync(::std::move(iceP_i), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opKStructS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    KStructS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const KStructS& ret, const KStructS& iceP_o)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opKStructSAsync(::std::move(iceP_i), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opQStructS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    QStructS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const QStructS& ret, const QStructS& iceP_o)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opQStructSAsync(::std::move(iceP_i), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opSStructS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    SStructS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const SStructS& ret, const SStructS& iceP_o)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opSStructSAsync(::std::move(iceP_i), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opAStructSD(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    AStructSD iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const AStructSD& ret, const AStructSD& iceP_o)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opAStructSDAsync(::std::move(iceP_i), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opLStructSD(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    LStructSD iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const LStructSD& ret, const LStructSD& iceP_o)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opLStructSDAsync(::std::move(iceP_i), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opKStructSD(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    KStructSD iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const KStructSD& ret, const KStructSD& iceP_o)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opKStructSDAsync(::std::move(iceP_i), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opQStructSD(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    QStructSD iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const QStructSD& ret, const QStructSD& iceP_o)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opQStructSDAsync(::std::move(iceP_i), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opSStructSD(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    SStructSD iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const SStructSD& ret, const SStructSD& iceP_o)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opSStructSDAsync(::std::move(iceP_i), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opACVS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ACVS iceP_i;
    istr->readAll(iceP_i);
    istr->readPendingValues();
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const ACVS& ret, const ACVS& iceP_o)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        ostr->writePendingValues();
        inA->endWriteParams();
        inA->completed();
    };
    this->opACVSAsync(::std::move(iceP_i), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opLCVS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    LCVS iceP_i;
    istr->readAll(iceP_i);
    istr->readPendingValues();
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const LCVS& ret, const LCVS& iceP_o)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        ostr->writePendingValues();
        inA->endWriteParams();
        inA->completed();
    };
    this->opLCVSAsync(::std::move(iceP_i), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opACRS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ACRS iceP_i;
    istr->readAll(iceP_i);
    istr->readPendingValues();
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const ACRS& ret, const ACRS& iceP_o)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        ostr->writePendingValues();
        inA->endWriteParams();
        inA->completed();
    };
    this->opACRSAsync(::std::move(iceP_i), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opLCRS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    LCRS iceP_i;
    istr->readAll(iceP_i);
    istr->readPendingValues();
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const LCRS& ret, const LCRS& iceP_o)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        ostr->writePendingValues();
        inA->endWriteParams();
        inA->completed();
    };
    this->opLCRSAsync(::std::move(iceP_i), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opAEnS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    AEnS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const AEnS& ret, const AEnS& iceP_o)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opAEnSAsync(::std::move(iceP_i), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opLEnS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    LEnS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const LEnS& ret, const LEnS& iceP_o)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opLEnSAsync(::std::move(iceP_i), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opKEnS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    KEnS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const KEnS& ret, const KEnS& iceP_o)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opKEnSAsync(::std::move(iceP_i), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opQEnS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    QEnS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const QEnS& ret, const QEnS& iceP_o)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opQEnSAsync(::std::move(iceP_i), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opSEnS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    SEnS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const SEnS& ret, const SEnS& iceP_o)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opSEnSAsync(::std::move(iceP_i), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opAIPrxS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    AIPrxS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const AIPrxS& ret, const AIPrxS& iceP_o)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opAIPrxSAsync(::std::move(iceP_i), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opLIPrxS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    LIPrxS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const LIPrxS& ret, const LIPrxS& iceP_o)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opLIPrxSAsync(::std::move(iceP_i), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opKIPrxS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    KIPrxS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const KIPrxS& ret, const KIPrxS& iceP_o)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opKIPrxSAsync(::std::move(iceP_i), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opQIPrxS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    QIPrxS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const QIPrxS& ret, const QIPrxS& iceP_o)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opQIPrxSAsync(::std::move(iceP_i), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opSIPrxS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    SIPrxS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const SIPrxS& ret, const SIPrxS& iceP_o)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opSIPrxSAsync(::std::move(iceP_i), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opCustomIntS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    CustomIntS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const CustomIntS& ret, const CustomIntS& iceP_o)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opCustomIntSAsync(::std::move(iceP_i), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opCustomCVS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    CustomCVS iceP_i;
    istr->readAll(iceP_i);
    istr->readPendingValues();
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const CustomCVS& ret, const CustomCVS& iceP_o)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        ostr->writePendingValues();
        inA->endWriteParams();
        inA->completed();
    };
    this->opCustomCVSAsync(::std::move(iceP_i), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opCustomIntSS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    CustomIntSS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const CustomIntSS& ret, const CustomIntSS& iceP_o)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        inA->endWriteParams();
        inA->completed();
    };
    this->opCustomIntSSAsync(::std::move(iceP_i), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opCustomCVSS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    CustomCVSS iceP_i;
    istr->readAll(iceP_i);
    istr->readPendingValues();
    inS.endReadParams();
    auto inA = ::IceInternal::IncomingAsync::create(inS);
    auto responseCB = [inA](const CustomCVSS& ret, const CustomCVSS& iceP_o)
    {
        auto ostr = inA->startWriteParams();
        ostr->writeAll(iceP_o, ret);
        ostr->writePendingValues();
        inA->endWriteParams();
        inA->completed();
    };
    this->opCustomCVSSAsync(::std::move(iceP_i), responseCB, inA->exception(), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_Test_MyClass_ops, iceC_Test_MyClass_ops + 80, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_Test_MyClass_ops)
    {
        case 0:
        {
            return _iceD_ice_id(in, current);
        }
        case 1:
        {
            return _iceD_ice_ids(in, current);
        }
        case 2:
        {
            return _iceD_ice_isA(in, current);
        }
        case 3:
        {
            return _iceD_ice_ping(in, current);
        }
        case 4:
        {
            return _iceD_opABoolS(in, current);
        }
        case 5:
        {
            return _iceD_opAByteS(in, current);
        }
        case 6:
        {
            return _iceD_opACRS(in, current);
        }
        case 7:
        {
            return _iceD_opACVS(in, current);
        }
        case 8:
        {
            return _iceD_opADoubleS(in, current);
        }
        case 9:
        {
            return _iceD_opAEnS(in, current);
        }
        case 10:
        {
            return _iceD_opAFloatS(in, current);
        }
        case 11:
        {
            return _iceD_opAIPrxS(in, current);
        }
        case 12:
        {
            return _iceD_opAIntS(in, current);
        }
        case 13:
        {
            return _iceD_opALongS(in, current);
        }
        case 14:
        {
            return _iceD_opAObjectPrxS(in, current);
        }
        case 15:
        {
            return _iceD_opAObjectS(in, current);
        }
        case 16:
        {
            return _iceD_opAShortS(in, current);
        }
        case 17:
        {
            return _iceD_opAStringS(in, current);
        }
        case 18:
        {
            return _iceD_opAStructS(in, current);
        }
        case 19:
        {
            return _iceD_opAStructSD(in, current);
        }
        case 20:
        {
            return _iceD_opCustomCVS(in, current);
        }
        case 21:
        {
            return _iceD_opCustomCVSS(in, current);
        }
        case 22:
        {
            return _iceD_opCustomIntS(in, current);
        }
        case 23:
        {
            return _iceD_opCustomIntSS(in, current);
        }
        case 24:
        {
            return _iceD_opKBoolS(in, current);
        }
        case 25:
        {
            return _iceD_opKByteS(in, current);
        }
        case 26:
        {
            return _iceD_opKDoubleS(in, current);
        }
        case 27:
        {
            return _iceD_opKEnS(in, current);
        }
        case 28:
        {
            return _iceD_opKFloatS(in, current);
        }
        case 29:
        {
            return _iceD_opKIPrxS(in, current);
        }
        case 30:
        {
            return _iceD_opKIntS(in, current);
        }
        case 31:
        {
            return _iceD_opKLongS(in, current);
        }
        case 32:
        {
            return _iceD_opKObjectPrxS(in, current);
        }
        case 33:
        {
            return _iceD_opKShortS(in, current);
        }
        case 34:
        {
            return _iceD_opKStringS(in, current);
        }
        case 35:
        {
            return _iceD_opKStructS(in, current);
        }
        case 36:
        {
            return _iceD_opKStructSD(in, current);
        }
        case 37:
        {
            return _iceD_opLBoolS(in, current);
        }
        case 38:
        {
            return _iceD_opLByteS(in, current);
        }
        case 39:
        {
            return _iceD_opLCRS(in, current);
        }
        case 40:
        {
            return _iceD_opLCVS(in, current);
        }
        case 41:
        {
            return _iceD_opLDoubleS(in, current);
        }
        case 42:
        {
            return _iceD_opLEnS(in, current);
        }
        case 43:
        {
            return _iceD_opLFloatS(in, current);
        }
        case 44:
        {
            return _iceD_opLIPrxS(in, current);
        }
        case 45:
        {
            return _iceD_opLIntS(in, current);
        }
        case 46:
        {
            return _iceD_opLLongS(in, current);
        }
        case 47:
        {
            return _iceD_opLObjectPrxS(in, current);
        }
        case 48:
        {
            return _iceD_opLObjectS(in, current);
        }
        case 49:
        {
            return _iceD_opLShortS(in, current);
        }
        case 50:
        {
            return _iceD_opLStringS(in, current);
        }
        case 51:
        {
            return _iceD_opLStructS(in, current);
        }
        case 52:
        {
            return _iceD_opLStructSD(in, current);
        }
        case 53:
        {
            return _iceD_opQBoolS(in, current);
        }
        case 54:
        {
            return _iceD_opQByteS(in, current);
        }
        case 55:
        {
            return _iceD_opQDoubleS(in, current);
        }
        case 56:
        {
            return _iceD_opQEnS(in, current);
        }
        case 57:
        {
            return _iceD_opQFloatS(in, current);
        }
        case 58:
        {
            return _iceD_opQIPrxS(in, current);
        }
        case 59:
        {
            return _iceD_opQIntS(in, current);
        }
        case 60:
        {
            return _iceD_opQLongS(in, current);
        }
        case 61:
        {
            return _iceD_opQObjectPrxS(in, current);
        }
        case 62:
        {
            return _iceD_opQShortS(in, current);
        }
        case 63:
        {
            return _iceD_opQStringS(in, current);
        }
        case 64:
        {
            return _iceD_opQStructS(in, current);
        }
        case 65:
        {
            return _iceD_opQStructSD(in, current);
        }
        case 66:
        {
            return _iceD_opSBoolS(in, current);
        }
        case 67:
        {
            return _iceD_opSByteS(in, current);
        }
        case 68:
        {
            return _iceD_opSDoubleS(in, current);
        }
        case 69:
        {
            return _iceD_opSEnS(in, current);
        }
        case 70:
        {
            return _iceD_opSFloatS(in, current);
        }
        case 71:
        {
            return _iceD_opSIPrxS(in, current);
        }
        case 72:
        {
            return _iceD_opSIntS(in, current);
        }
        case 73:
        {
            return _iceD_opSLongS(in, current);
        }
        case 74:
        {
            return _iceD_opSObjectPrxS(in, current);
        }
        case 75:
        {
            return _iceD_opSShortS(in, current);
        }
        case 76:
        {
            return _iceD_opSStringS(in, current);
        }
        case 77:
        {
            return _iceD_opSStructS(in, current);
        }
        case 78:
        {
            return _iceD_opSStructSD(in, current);
        }
        case 79:
        {
            return _iceD_shutdown(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

Test::CV::~CV()
{
}

const ::std::string&
Test::CV::ice_staticId()
{
    static const ::std::string typeId = "::Test::CV";
    return typeId;
}

Test::CR::~CR()
{
}

const ::std::string&
Test::CR::ice_staticId()
{
    static const ::std::string typeId = "::Test::CR";
    return typeId;
}

/// \cond INTERNAL
::std::shared_ptr<::Ice::ObjectPrx>
Test::IPrx::_newInstance() const
{
    return ::IceInternal::createProxy<IPrx>();
}
/// \endcond

const ::std::string&
Test::IPrx::ice_staticId()
{
    return I::ice_staticId();
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_shutdown(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_Test_MyClass_shutdown_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opAByteS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpAByteSResult>>& outAsync, const AByteS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opAByteS_name);
    outAsync->invoke(iceC_Test_MyClass_opAByteS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpAByteSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opLByteS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpLByteSResult>>& outAsync, const LByteS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opLByteS_name);
    outAsync->invoke(iceC_Test_MyClass_opLByteS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpLByteSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opKByteS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpKByteSResult>>& outAsync, const KByteS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opKByteS_name);
    outAsync->invoke(iceC_Test_MyClass_opKByteS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpKByteSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opQByteS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpQByteSResult>>& outAsync, const QByteS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opQByteS_name);
    outAsync->invoke(iceC_Test_MyClass_opQByteS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpQByteSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opSByteS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpSByteSResult>>& outAsync, const SByteS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opSByteS_name);
    outAsync->invoke(iceC_Test_MyClass_opSByteS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpSByteSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opABoolS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpABoolSResult>>& outAsync, const ABoolS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opABoolS_name);
    outAsync->invoke(iceC_Test_MyClass_opABoolS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpABoolSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opLBoolS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpLBoolSResult>>& outAsync, const LBoolS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opLBoolS_name);
    outAsync->invoke(iceC_Test_MyClass_opLBoolS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpLBoolSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opKBoolS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpKBoolSResult>>& outAsync, const KBoolS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opKBoolS_name);
    outAsync->invoke(iceC_Test_MyClass_opKBoolS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpKBoolSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opQBoolS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpQBoolSResult>>& outAsync, const QBoolS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opQBoolS_name);
    outAsync->invoke(iceC_Test_MyClass_opQBoolS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpQBoolSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opSBoolS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpSBoolSResult>>& outAsync, const SBoolS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opSBoolS_name);
    outAsync->invoke(iceC_Test_MyClass_opSBoolS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpSBoolSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opAShortS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpAShortSResult>>& outAsync, const AShortS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opAShortS_name);
    outAsync->invoke(iceC_Test_MyClass_opAShortS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpAShortSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opLShortS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpLShortSResult>>& outAsync, const LShortS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opLShortS_name);
    outAsync->invoke(iceC_Test_MyClass_opLShortS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpLShortSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opKShortS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpKShortSResult>>& outAsync, const KShortS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opKShortS_name);
    outAsync->invoke(iceC_Test_MyClass_opKShortS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpKShortSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opQShortS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpQShortSResult>>& outAsync, const QShortS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opQShortS_name);
    outAsync->invoke(iceC_Test_MyClass_opQShortS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpQShortSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opSShortS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpSShortSResult>>& outAsync, const SShortS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opSShortS_name);
    outAsync->invoke(iceC_Test_MyClass_opSShortS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpSShortSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opAIntS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpAIntSResult>>& outAsync, const AIntS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opAIntS_name);
    outAsync->invoke(iceC_Test_MyClass_opAIntS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpAIntSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opLIntS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpLIntSResult>>& outAsync, const LIntS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opLIntS_name);
    outAsync->invoke(iceC_Test_MyClass_opLIntS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpLIntSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opKIntS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpKIntSResult>>& outAsync, const KIntS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opKIntS_name);
    outAsync->invoke(iceC_Test_MyClass_opKIntS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpKIntSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opQIntS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpQIntSResult>>& outAsync, const QIntS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opQIntS_name);
    outAsync->invoke(iceC_Test_MyClass_opQIntS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpQIntSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opSIntS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpSIntSResult>>& outAsync, const SIntS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opSIntS_name);
    outAsync->invoke(iceC_Test_MyClass_opSIntS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpSIntSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opALongS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpALongSResult>>& outAsync, const ALongS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opALongS_name);
    outAsync->invoke(iceC_Test_MyClass_opALongS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpALongSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opLLongS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpLLongSResult>>& outAsync, const LLongS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opLLongS_name);
    outAsync->invoke(iceC_Test_MyClass_opLLongS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpLLongSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opKLongS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpKLongSResult>>& outAsync, const KLongS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opKLongS_name);
    outAsync->invoke(iceC_Test_MyClass_opKLongS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpKLongSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opQLongS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpQLongSResult>>& outAsync, const QLongS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opQLongS_name);
    outAsync->invoke(iceC_Test_MyClass_opQLongS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpQLongSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opSLongS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpSLongSResult>>& outAsync, const SLongS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opSLongS_name);
    outAsync->invoke(iceC_Test_MyClass_opSLongS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpSLongSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opAFloatS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpAFloatSResult>>& outAsync, const AFloatS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opAFloatS_name);
    outAsync->invoke(iceC_Test_MyClass_opAFloatS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpAFloatSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opLFloatS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpLFloatSResult>>& outAsync, const LFloatS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opLFloatS_name);
    outAsync->invoke(iceC_Test_MyClass_opLFloatS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpLFloatSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opKFloatS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpKFloatSResult>>& outAsync, const KFloatS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opKFloatS_name);
    outAsync->invoke(iceC_Test_MyClass_opKFloatS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpKFloatSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opQFloatS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpQFloatSResult>>& outAsync, const QFloatS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opQFloatS_name);
    outAsync->invoke(iceC_Test_MyClass_opQFloatS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpQFloatSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opSFloatS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpSFloatSResult>>& outAsync, const SFloatS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opSFloatS_name);
    outAsync->invoke(iceC_Test_MyClass_opSFloatS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpSFloatSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opADoubleS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpADoubleSResult>>& outAsync, const ADoubleS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opADoubleS_name);
    outAsync->invoke(iceC_Test_MyClass_opADoubleS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpADoubleSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opLDoubleS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpLDoubleSResult>>& outAsync, const LDoubleS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opLDoubleS_name);
    outAsync->invoke(iceC_Test_MyClass_opLDoubleS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpLDoubleSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opKDoubleS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpKDoubleSResult>>& outAsync, const KDoubleS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opKDoubleS_name);
    outAsync->invoke(iceC_Test_MyClass_opKDoubleS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpKDoubleSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opQDoubleS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpQDoubleSResult>>& outAsync, const QDoubleS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opQDoubleS_name);
    outAsync->invoke(iceC_Test_MyClass_opQDoubleS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpQDoubleSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opSDoubleS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpSDoubleSResult>>& outAsync, const SDoubleS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opSDoubleS_name);
    outAsync->invoke(iceC_Test_MyClass_opSDoubleS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpSDoubleSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opAStringS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpAStringSResult>>& outAsync, const AStringS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opAStringS_name);
    outAsync->invoke(iceC_Test_MyClass_opAStringS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpAStringSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opLStringS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpLStringSResult>>& outAsync, const LStringS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opLStringS_name);
    outAsync->invoke(iceC_Test_MyClass_opLStringS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpLStringSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opKStringS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpKStringSResult>>& outAsync, const KStringS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opKStringS_name);
    outAsync->invoke(iceC_Test_MyClass_opKStringS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpKStringSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opQStringS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpQStringSResult>>& outAsync, const QStringS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opQStringS_name);
    outAsync->invoke(iceC_Test_MyClass_opQStringS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpQStringSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opSStringS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpSStringSResult>>& outAsync, const SStringS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opSStringS_name);
    outAsync->invoke(iceC_Test_MyClass_opSStringS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpSStringSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opAObjectS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpAObjectSResult>>& outAsync, const AObjectS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opAObjectS_name);
    outAsync->invoke(iceC_Test_MyClass_opAObjectS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
            ostr->writePendingValues();
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpAObjectSResult v;
            istr->readAll(v.o, v.returnValue);
            istr->readPendingValues();
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opLObjectS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpLObjectSResult>>& outAsync, const LObjectS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opLObjectS_name);
    outAsync->invoke(iceC_Test_MyClass_opLObjectS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
            ostr->writePendingValues();
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpLObjectSResult v;
            istr->readAll(v.o, v.returnValue);
            istr->readPendingValues();
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opAObjectPrxS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpAObjectPrxSResult>>& outAsync, const AObjectPrxS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opAObjectPrxS_name);
    outAsync->invoke(iceC_Test_MyClass_opAObjectPrxS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpAObjectPrxSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opLObjectPrxS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpLObjectPrxSResult>>& outAsync, const LObjectPrxS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opLObjectPrxS_name);
    outAsync->invoke(iceC_Test_MyClass_opLObjectPrxS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpLObjectPrxSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opKObjectPrxS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpKObjectPrxSResult>>& outAsync, const KObjectPrxS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opKObjectPrxS_name);
    outAsync->invoke(iceC_Test_MyClass_opKObjectPrxS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpKObjectPrxSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opQObjectPrxS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpQObjectPrxSResult>>& outAsync, const QObjectPrxS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opQObjectPrxS_name);
    outAsync->invoke(iceC_Test_MyClass_opQObjectPrxS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpQObjectPrxSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opSObjectPrxS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpSObjectPrxSResult>>& outAsync, const SObjectPrxS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opSObjectPrxS_name);
    outAsync->invoke(iceC_Test_MyClass_opSObjectPrxS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpSObjectPrxSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opAStructS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpAStructSResult>>& outAsync, const AStructS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opAStructS_name);
    outAsync->invoke(iceC_Test_MyClass_opAStructS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpAStructSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opLStructS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpLStructSResult>>& outAsync, const LStructS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opLStructS_name);
    outAsync->invoke(iceC_Test_MyClass_opLStructS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpLStructSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opKStructS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpKStructSResult>>& outAsync, const KStructS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opKStructS_name);
    outAsync->invoke(iceC_Test_MyClass_opKStructS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpKStructSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opQStructS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpQStructSResult>>& outAsync, const QStructS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opQStructS_name);
    outAsync->invoke(iceC_Test_MyClass_opQStructS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpQStructSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opSStructS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpSStructSResult>>& outAsync, const SStructS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opSStructS_name);
    outAsync->invoke(iceC_Test_MyClass_opSStructS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpSStructSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opAStructSD(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpAStructSDResult>>& outAsync, const AStructSD& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opAStructSD_name);
    outAsync->invoke(iceC_Test_MyClass_opAStructSD_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpAStructSDResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opLStructSD(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpLStructSDResult>>& outAsync, const LStructSD& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opLStructSD_name);
    outAsync->invoke(iceC_Test_MyClass_opLStructSD_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpLStructSDResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opKStructSD(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpKStructSDResult>>& outAsync, const KStructSD& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opKStructSD_name);
    outAsync->invoke(iceC_Test_MyClass_opKStructSD_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpKStructSDResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opQStructSD(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpQStructSDResult>>& outAsync, const QStructSD& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opQStructSD_name);
    outAsync->invoke(iceC_Test_MyClass_opQStructSD_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpQStructSDResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opSStructSD(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpSStructSDResult>>& outAsync, const SStructSD& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opSStructSD_name);
    outAsync->invoke(iceC_Test_MyClass_opSStructSD_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpSStructSDResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opACVS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpACVSResult>>& outAsync, const ACVS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opACVS_name);
    outAsync->invoke(iceC_Test_MyClass_opACVS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
            ostr->writePendingValues();
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpACVSResult v;
            istr->readAll(v.o, v.returnValue);
            istr->readPendingValues();
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opLCVS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpLCVSResult>>& outAsync, const LCVS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opLCVS_name);
    outAsync->invoke(iceC_Test_MyClass_opLCVS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
            ostr->writePendingValues();
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpLCVSResult v;
            istr->readAll(v.o, v.returnValue);
            istr->readPendingValues();
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opACRS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpACRSResult>>& outAsync, const ACRS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opACRS_name);
    outAsync->invoke(iceC_Test_MyClass_opACRS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
            ostr->writePendingValues();
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpACRSResult v;
            istr->readAll(v.o, v.returnValue);
            istr->readPendingValues();
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opLCRS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpLCRSResult>>& outAsync, const LCRS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opLCRS_name);
    outAsync->invoke(iceC_Test_MyClass_opLCRS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
            ostr->writePendingValues();
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpLCRSResult v;
            istr->readAll(v.o, v.returnValue);
            istr->readPendingValues();
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opAEnS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpAEnSResult>>& outAsync, const AEnS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opAEnS_name);
    outAsync->invoke(iceC_Test_MyClass_opAEnS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpAEnSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opLEnS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpLEnSResult>>& outAsync, const LEnS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opLEnS_name);
    outAsync->invoke(iceC_Test_MyClass_opLEnS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpLEnSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opKEnS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpKEnSResult>>& outAsync, const KEnS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opKEnS_name);
    outAsync->invoke(iceC_Test_MyClass_opKEnS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpKEnSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opQEnS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpQEnSResult>>& outAsync, const QEnS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opQEnS_name);
    outAsync->invoke(iceC_Test_MyClass_opQEnS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpQEnSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opSEnS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpSEnSResult>>& outAsync, const SEnS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opSEnS_name);
    outAsync->invoke(iceC_Test_MyClass_opSEnS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpSEnSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opAIPrxS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpAIPrxSResult>>& outAsync, const AIPrxS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opAIPrxS_name);
    outAsync->invoke(iceC_Test_MyClass_opAIPrxS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpAIPrxSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opLIPrxS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpLIPrxSResult>>& outAsync, const LIPrxS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opLIPrxS_name);
    outAsync->invoke(iceC_Test_MyClass_opLIPrxS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpLIPrxSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opKIPrxS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpKIPrxSResult>>& outAsync, const KIPrxS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opKIPrxS_name);
    outAsync->invoke(iceC_Test_MyClass_opKIPrxS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpKIPrxSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opQIPrxS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpQIPrxSResult>>& outAsync, const QIPrxS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opQIPrxS_name);
    outAsync->invoke(iceC_Test_MyClass_opQIPrxS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpQIPrxSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opSIPrxS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpSIPrxSResult>>& outAsync, const SIPrxS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opSIPrxS_name);
    outAsync->invoke(iceC_Test_MyClass_opSIPrxS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpSIPrxSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opCustomIntS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpCustomIntSResult>>& outAsync, const CustomIntS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opCustomIntS_name);
    outAsync->invoke(iceC_Test_MyClass_opCustomIntS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpCustomIntSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opCustomCVS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpCustomCVSResult>>& outAsync, const CustomCVS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opCustomCVS_name);
    outAsync->invoke(iceC_Test_MyClass_opCustomCVS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
            ostr->writePendingValues();
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpCustomCVSResult v;
            istr->readAll(v.o, v.returnValue);
            istr->readPendingValues();
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opCustomIntSS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpCustomIntSSResult>>& outAsync, const CustomIntSS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opCustomIntSS_name);
    outAsync->invoke(iceC_Test_MyClass_opCustomIntSS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpCustomIntSSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opCustomCVSS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpCustomCVSSResult>>& outAsync, const CustomCVSS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opCustomCVSS_name);
    outAsync->invoke(iceC_Test_MyClass_opCustomCVSS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
            ostr->writePendingValues();
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpCustomCVSSResult v;
            istr->readAll(v.o, v.returnValue);
            istr->readPendingValues();
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
::std::shared_ptr<::Ice::ObjectPrx>
Test::MyClassPrx::_newInstance() const
{
    return ::IceInternal::createProxy<MyClassPrx>();
}
/// \endcond

const ::std::string&
Test::MyClassPrx::ice_staticId()
{
    return MyClass::ice_staticId();
}

namespace Ice
{
}

#else // C++98 mapping

namespace
{

const ::std::string iceC_Test_MyClass_shutdown_name = "shutdown";

const ::std::string iceC_Test_MyClass_opAByteS_name = "opAByteS";

const ::std::string iceC_Test_MyClass_opLByteS_name = "opLByteS";

const ::std::string iceC_Test_MyClass_opKByteS_name = "opKByteS";

const ::std::string iceC_Test_MyClass_opQByteS_name = "opQByteS";

const ::std::string iceC_Test_MyClass_opSByteS_name = "opSByteS";

const ::std::string iceC_Test_MyClass_opABoolS_name = "opABoolS";

const ::std::string iceC_Test_MyClass_opLBoolS_name = "opLBoolS";

const ::std::string iceC_Test_MyClass_opKBoolS_name = "opKBoolS";

const ::std::string iceC_Test_MyClass_opQBoolS_name = "opQBoolS";

const ::std::string iceC_Test_MyClass_opSBoolS_name = "opSBoolS";

const ::std::string iceC_Test_MyClass_opAShortS_name = "opAShortS";

const ::std::string iceC_Test_MyClass_opLShortS_name = "opLShortS";

const ::std::string iceC_Test_MyClass_opKShortS_name = "opKShortS";

const ::std::string iceC_Test_MyClass_opQShortS_name = "opQShortS";

const ::std::string iceC_Test_MyClass_opSShortS_name = "opSShortS";

const ::std::string iceC_Test_MyClass_opAIntS_name = "opAIntS";

const ::std::string iceC_Test_MyClass_opLIntS_name = "opLIntS";

const ::std::string iceC_Test_MyClass_opKIntS_name = "opKIntS";

const ::std::string iceC_Test_MyClass_opQIntS_name = "opQIntS";

const ::std::string iceC_Test_MyClass_opSIntS_name = "opSIntS";

const ::std::string iceC_Test_MyClass_opALongS_name = "opALongS";

const ::std::string iceC_Test_MyClass_opLLongS_name = "opLLongS";

const ::std::string iceC_Test_MyClass_opKLongS_name = "opKLongS";

const ::std::string iceC_Test_MyClass_opQLongS_name = "opQLongS";

const ::std::string iceC_Test_MyClass_opSLongS_name = "opSLongS";

const ::std::string iceC_Test_MyClass_opAFloatS_name = "opAFloatS";

const ::std::string iceC_Test_MyClass_opLFloatS_name = "opLFloatS";

const ::std::string iceC_Test_MyClass_opKFloatS_name = "opKFloatS";

const ::std::string iceC_Test_MyClass_opQFloatS_name = "opQFloatS";

const ::std::string iceC_Test_MyClass_opSFloatS_name = "opSFloatS";

const ::std::string iceC_Test_MyClass_opADoubleS_name = "opADoubleS";

const ::std::string iceC_Test_MyClass_opLDoubleS_name = "opLDoubleS";

const ::std::string iceC_Test_MyClass_opKDoubleS_name = "opKDoubleS";

const ::std::string iceC_Test_MyClass_opQDoubleS_name = "opQDoubleS";

const ::std::string iceC_Test_MyClass_opSDoubleS_name = "opSDoubleS";

const ::std::string iceC_Test_MyClass_opAStringS_name = "opAStringS";

const ::std::string iceC_Test_MyClass_opLStringS_name = "opLStringS";

const ::std::string iceC_Test_MyClass_opKStringS_name = "opKStringS";

const ::std::string iceC_Test_MyClass_opQStringS_name = "opQStringS";

const ::std::string iceC_Test_MyClass_opSStringS_name = "opSStringS";

const ::std::string iceC_Test_MyClass_opAObjectS_name = "opAObjectS";

const ::std::string iceC_Test_MyClass_opLObjectS_name = "opLObjectS";

const ::std::string iceC_Test_MyClass_opAObjectPrxS_name = "opAObjectPrxS";

const ::std::string iceC_Test_MyClass_opLObjectPrxS_name = "opLObjectPrxS";

const ::std::string iceC_Test_MyClass_opKObjectPrxS_name = "opKObjectPrxS";

const ::std::string iceC_Test_MyClass_opQObjectPrxS_name = "opQObjectPrxS";

const ::std::string iceC_Test_MyClass_opSObjectPrxS_name = "opSObjectPrxS";

const ::std::string iceC_Test_MyClass_opAStructS_name = "opAStructS";

const ::std::string iceC_Test_MyClass_opLStructS_name = "opLStructS";

const ::std::string iceC_Test_MyClass_opKStructS_name = "opKStructS";

const ::std::string iceC_Test_MyClass_opQStructS_name = "opQStructS";

const ::std::string iceC_Test_MyClass_opSStructS_name = "opSStructS";

const ::std::string iceC_Test_MyClass_opAStructSD_name = "opAStructSD";

const ::std::string iceC_Test_MyClass_opLStructSD_name = "opLStructSD";

const ::std::string iceC_Test_MyClass_opKStructSD_name = "opKStructSD";

const ::std::string iceC_Test_MyClass_opQStructSD_name = "opQStructSD";

const ::std::string iceC_Test_MyClass_opSStructSD_name = "opSStructSD";

const ::std::string iceC_Test_MyClass_opACVS_name = "opACVS";

const ::std::string iceC_Test_MyClass_opLCVS_name = "opLCVS";

const ::std::string iceC_Test_MyClass_opACRS_name = "opACRS";

const ::std::string iceC_Test_MyClass_opLCRS_name = "opLCRS";

const ::std::string iceC_Test_MyClass_opAEnS_name = "opAEnS";

const ::std::string iceC_Test_MyClass_opLEnS_name = "opLEnS";

const ::std::string iceC_Test_MyClass_opKEnS_name = "opKEnS";

const ::std::string iceC_Test_MyClass_opQEnS_name = "opQEnS";

const ::std::string iceC_Test_MyClass_opSEnS_name = "opSEnS";

const ::std::string iceC_Test_MyClass_opAIPrxS_name = "opAIPrxS";

const ::std::string iceC_Test_MyClass_opLIPrxS_name = "opLIPrxS";

const ::std::string iceC_Test_MyClass_opKIPrxS_name = "opKIPrxS";

const ::std::string iceC_Test_MyClass_opQIPrxS_name = "opQIPrxS";

const ::std::string iceC_Test_MyClass_opSIPrxS_name = "opSIPrxS";

const ::std::string iceC_Test_MyClass_opCustomIntS_name = "opCustomIntS";

const ::std::string iceC_Test_MyClass_opCustomCVS_name = "opCustomCVS";

const ::std::string iceC_Test_MyClass_opCustomIntSS_name = "opCustomIntSS";

const ::std::string iceC_Test_MyClass_opCustomCVSS_name = "opCustomCVSS";

}

Test::AMD_MyClass_shutdown::~AMD_MyClass_shutdown()
{
}

Test::AMD_MyClass_opAByteS::~AMD_MyClass_opAByteS()
{
}

Test::AMD_MyClass_opLByteS::~AMD_MyClass_opLByteS()
{
}

Test::AMD_MyClass_opKByteS::~AMD_MyClass_opKByteS()
{
}

Test::AMD_MyClass_opQByteS::~AMD_MyClass_opQByteS()
{
}

Test::AMD_MyClass_opSByteS::~AMD_MyClass_opSByteS()
{
}

Test::AMD_MyClass_opABoolS::~AMD_MyClass_opABoolS()
{
}

Test::AMD_MyClass_opLBoolS::~AMD_MyClass_opLBoolS()
{
}

Test::AMD_MyClass_opKBoolS::~AMD_MyClass_opKBoolS()
{
}

Test::AMD_MyClass_opQBoolS::~AMD_MyClass_opQBoolS()
{
}

Test::AMD_MyClass_opSBoolS::~AMD_MyClass_opSBoolS()
{
}

Test::AMD_MyClass_opAShortS::~AMD_MyClass_opAShortS()
{
}

Test::AMD_MyClass_opLShortS::~AMD_MyClass_opLShortS()
{
}

Test::AMD_MyClass_opKShortS::~AMD_MyClass_opKShortS()
{
}

Test::AMD_MyClass_opQShortS::~AMD_MyClass_opQShortS()
{
}

Test::AMD_MyClass_opSShortS::~AMD_MyClass_opSShortS()
{
}

Test::AMD_MyClass_opAIntS::~AMD_MyClass_opAIntS()
{
}

Test::AMD_MyClass_opLIntS::~AMD_MyClass_opLIntS()
{
}

Test::AMD_MyClass_opKIntS::~AMD_MyClass_opKIntS()
{
}

Test::AMD_MyClass_opQIntS::~AMD_MyClass_opQIntS()
{
}

Test::AMD_MyClass_opSIntS::~AMD_MyClass_opSIntS()
{
}

Test::AMD_MyClass_opALongS::~AMD_MyClass_opALongS()
{
}

Test::AMD_MyClass_opLLongS::~AMD_MyClass_opLLongS()
{
}

Test::AMD_MyClass_opKLongS::~AMD_MyClass_opKLongS()
{
}

Test::AMD_MyClass_opQLongS::~AMD_MyClass_opQLongS()
{
}

Test::AMD_MyClass_opSLongS::~AMD_MyClass_opSLongS()
{
}

Test::AMD_MyClass_opAFloatS::~AMD_MyClass_opAFloatS()
{
}

Test::AMD_MyClass_opLFloatS::~AMD_MyClass_opLFloatS()
{
}

Test::AMD_MyClass_opKFloatS::~AMD_MyClass_opKFloatS()
{
}

Test::AMD_MyClass_opQFloatS::~AMD_MyClass_opQFloatS()
{
}

Test::AMD_MyClass_opSFloatS::~AMD_MyClass_opSFloatS()
{
}

Test::AMD_MyClass_opADoubleS::~AMD_MyClass_opADoubleS()
{
}

Test::AMD_MyClass_opLDoubleS::~AMD_MyClass_opLDoubleS()
{
}

Test::AMD_MyClass_opKDoubleS::~AMD_MyClass_opKDoubleS()
{
}

Test::AMD_MyClass_opQDoubleS::~AMD_MyClass_opQDoubleS()
{
}

Test::AMD_MyClass_opSDoubleS::~AMD_MyClass_opSDoubleS()
{
}

Test::AMD_MyClass_opAStringS::~AMD_MyClass_opAStringS()
{
}

Test::AMD_MyClass_opLStringS::~AMD_MyClass_opLStringS()
{
}

Test::AMD_MyClass_opKStringS::~AMD_MyClass_opKStringS()
{
}

Test::AMD_MyClass_opQStringS::~AMD_MyClass_opQStringS()
{
}

Test::AMD_MyClass_opSStringS::~AMD_MyClass_opSStringS()
{
}

Test::AMD_MyClass_opAObjectS::~AMD_MyClass_opAObjectS()
{
}

Test::AMD_MyClass_opLObjectS::~AMD_MyClass_opLObjectS()
{
}

Test::AMD_MyClass_opAObjectPrxS::~AMD_MyClass_opAObjectPrxS()
{
}

Test::AMD_MyClass_opLObjectPrxS::~AMD_MyClass_opLObjectPrxS()
{
}

Test::AMD_MyClass_opKObjectPrxS::~AMD_MyClass_opKObjectPrxS()
{
}

Test::AMD_MyClass_opQObjectPrxS::~AMD_MyClass_opQObjectPrxS()
{
}

Test::AMD_MyClass_opSObjectPrxS::~AMD_MyClass_opSObjectPrxS()
{
}

Test::AMD_MyClass_opAStructS::~AMD_MyClass_opAStructS()
{
}

Test::AMD_MyClass_opLStructS::~AMD_MyClass_opLStructS()
{
}

Test::AMD_MyClass_opKStructS::~AMD_MyClass_opKStructS()
{
}

Test::AMD_MyClass_opQStructS::~AMD_MyClass_opQStructS()
{
}

Test::AMD_MyClass_opSStructS::~AMD_MyClass_opSStructS()
{
}

Test::AMD_MyClass_opAStructSD::~AMD_MyClass_opAStructSD()
{
}

Test::AMD_MyClass_opLStructSD::~AMD_MyClass_opLStructSD()
{
}

Test::AMD_MyClass_opKStructSD::~AMD_MyClass_opKStructSD()
{
}

Test::AMD_MyClass_opQStructSD::~AMD_MyClass_opQStructSD()
{
}

Test::AMD_MyClass_opSStructSD::~AMD_MyClass_opSStructSD()
{
}

Test::AMD_MyClass_opACVS::~AMD_MyClass_opACVS()
{
}

Test::AMD_MyClass_opLCVS::~AMD_MyClass_opLCVS()
{
}

Test::AMD_MyClass_opACRS::~AMD_MyClass_opACRS()
{
}

Test::AMD_MyClass_opLCRS::~AMD_MyClass_opLCRS()
{
}

Test::AMD_MyClass_opAEnS::~AMD_MyClass_opAEnS()
{
}

Test::AMD_MyClass_opLEnS::~AMD_MyClass_opLEnS()
{
}

Test::AMD_MyClass_opKEnS::~AMD_MyClass_opKEnS()
{
}

Test::AMD_MyClass_opQEnS::~AMD_MyClass_opQEnS()
{
}

Test::AMD_MyClass_opSEnS::~AMD_MyClass_opSEnS()
{
}

Test::AMD_MyClass_opAIPrxS::~AMD_MyClass_opAIPrxS()
{
}

Test::AMD_MyClass_opLIPrxS::~AMD_MyClass_opLIPrxS()
{
}

Test::AMD_MyClass_opKIPrxS::~AMD_MyClass_opKIPrxS()
{
}

Test::AMD_MyClass_opQIPrxS::~AMD_MyClass_opQIPrxS()
{
}

Test::AMD_MyClass_opSIPrxS::~AMD_MyClass_opSIPrxS()
{
}

Test::AMD_MyClass_opCustomIntS::~AMD_MyClass_opCustomIntS()
{
}

Test::AMD_MyClass_opCustomCVS::~AMD_MyClass_opCustomCVS()
{
}

Test::AMD_MyClass_opCustomIntSS::~AMD_MyClass_opCustomIntSS()
{
}

Test::AMD_MyClass_opCustomCVSS::~AMD_MyClass_opCustomCVSS()
{
}

/// \cond INTERNAL
IceAsync::Test::AMD_MyClass_shutdown::AMD_MyClass_shutdown(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_MyClass_shutdown::ice_response()
{
    writeEmptyParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Test::AMD_MyClass_opAByteS::AMD_MyClass_opAByteS(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_MyClass_opAByteS::ice_response(const ::Test::AByteS& ret, const ::Test::AByteS& o)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(o);
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Test::AMD_MyClass_opLByteS::AMD_MyClass_opLByteS(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_MyClass_opLByteS::ice_response(const ::Test::LByteS& ret, const ::Test::LByteS& o)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(o);
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Test::AMD_MyClass_opKByteS::AMD_MyClass_opKByteS(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_MyClass_opKByteS::ice_response(const ::Test::KByteS& ret, const ::Test::KByteS& o)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(o);
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Test::AMD_MyClass_opQByteS::AMD_MyClass_opQByteS(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_MyClass_opQByteS::ice_response(const ::Test::QByteS& ret, const ::Test::QByteS& o)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(o);
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Test::AMD_MyClass_opSByteS::AMD_MyClass_opSByteS(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_MyClass_opSByteS::ice_response(const ::Test::SByteS& ret, const ::Test::SByteS& o)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(o);
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Test::AMD_MyClass_opABoolS::AMD_MyClass_opABoolS(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_MyClass_opABoolS::ice_response(const ::Test::ABoolS& ret, const ::Test::ABoolS& o)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(o);
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Test::AMD_MyClass_opLBoolS::AMD_MyClass_opLBoolS(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_MyClass_opLBoolS::ice_response(const ::Test::LBoolS& ret, const ::Test::LBoolS& o)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(o);
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Test::AMD_MyClass_opKBoolS::AMD_MyClass_opKBoolS(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_MyClass_opKBoolS::ice_response(const ::Test::KBoolS& ret, const ::Test::KBoolS& o)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(o);
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Test::AMD_MyClass_opQBoolS::AMD_MyClass_opQBoolS(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_MyClass_opQBoolS::ice_response(const ::Test::QBoolS& ret, const ::Test::QBoolS& o)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(o);
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Test::AMD_MyClass_opSBoolS::AMD_MyClass_opSBoolS(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_MyClass_opSBoolS::ice_response(const ::Test::SBoolS& ret, const ::Test::SBoolS& o)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(o);
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Test::AMD_MyClass_opAShortS::AMD_MyClass_opAShortS(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_MyClass_opAShortS::ice_response(const ::Test::AShortS& ret, const ::Test::AShortS& o)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(o);
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Test::AMD_MyClass_opLShortS::AMD_MyClass_opLShortS(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_MyClass_opLShortS::ice_response(const ::Test::LShortS& ret, const ::Test::LShortS& o)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(o);
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Test::AMD_MyClass_opKShortS::AMD_MyClass_opKShortS(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_MyClass_opKShortS::ice_response(const ::Test::KShortS& ret, const ::Test::KShortS& o)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(o);
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Test::AMD_MyClass_opQShortS::AMD_MyClass_opQShortS(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_MyClass_opQShortS::ice_response(const ::Test::QShortS& ret, const ::Test::QShortS& o)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(o);
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Test::AMD_MyClass_opSShortS::AMD_MyClass_opSShortS(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_MyClass_opSShortS::ice_response(const ::Test::SShortS& ret, const ::Test::SShortS& o)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(o);
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Test::AMD_MyClass_opAIntS::AMD_MyClass_opAIntS(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_MyClass_opAIntS::ice_response(const ::Test::AIntS& ret, const ::Test::AIntS& o)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(o);
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Test::AMD_MyClass_opLIntS::AMD_MyClass_opLIntS(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_MyClass_opLIntS::ice_response(const ::Test::LIntS& ret, const ::Test::LIntS& o)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(o);
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Test::AMD_MyClass_opKIntS::AMD_MyClass_opKIntS(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_MyClass_opKIntS::ice_response(const ::Test::KIntS& ret, const ::Test::KIntS& o)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(o);
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Test::AMD_MyClass_opQIntS::AMD_MyClass_opQIntS(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_MyClass_opQIntS::ice_response(const ::Test::QIntS& ret, const ::Test::QIntS& o)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(o);
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Test::AMD_MyClass_opSIntS::AMD_MyClass_opSIntS(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_MyClass_opSIntS::ice_response(const ::Test::SIntS& ret, const ::Test::SIntS& o)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(o);
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Test::AMD_MyClass_opALongS::AMD_MyClass_opALongS(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_MyClass_opALongS::ice_response(const ::Test::ALongS& ret, const ::Test::ALongS& o)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(o);
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Test::AMD_MyClass_opLLongS::AMD_MyClass_opLLongS(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_MyClass_opLLongS::ice_response(const ::Test::LLongS& ret, const ::Test::LLongS& o)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(o);
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Test::AMD_MyClass_opKLongS::AMD_MyClass_opKLongS(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_MyClass_opKLongS::ice_response(const ::Test::KLongS& ret, const ::Test::KLongS& o)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(o);
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Test::AMD_MyClass_opQLongS::AMD_MyClass_opQLongS(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_MyClass_opQLongS::ice_response(const ::Test::QLongS& ret, const ::Test::QLongS& o)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(o);
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Test::AMD_MyClass_opSLongS::AMD_MyClass_opSLongS(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_MyClass_opSLongS::ice_response(const ::Test::SLongS& ret, const ::Test::SLongS& o)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(o);
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Test::AMD_MyClass_opAFloatS::AMD_MyClass_opAFloatS(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_MyClass_opAFloatS::ice_response(const ::Test::AFloatS& ret, const ::Test::AFloatS& o)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(o);
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Test::AMD_MyClass_opLFloatS::AMD_MyClass_opLFloatS(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_MyClass_opLFloatS::ice_response(const ::Test::LFloatS& ret, const ::Test::LFloatS& o)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(o);
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Test::AMD_MyClass_opKFloatS::AMD_MyClass_opKFloatS(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_MyClass_opKFloatS::ice_response(const ::Test::KFloatS& ret, const ::Test::KFloatS& o)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(o);
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Test::AMD_MyClass_opQFloatS::AMD_MyClass_opQFloatS(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_MyClass_opQFloatS::ice_response(const ::Test::QFloatS& ret, const ::Test::QFloatS& o)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(o);
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Test::AMD_MyClass_opSFloatS::AMD_MyClass_opSFloatS(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_MyClass_opSFloatS::ice_response(const ::Test::SFloatS& ret, const ::Test::SFloatS& o)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(o);
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Test::AMD_MyClass_opADoubleS::AMD_MyClass_opADoubleS(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_MyClass_opADoubleS::ice_response(const ::Test::ADoubleS& ret, const ::Test::ADoubleS& o)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(o);
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Test::AMD_MyClass_opLDoubleS::AMD_MyClass_opLDoubleS(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_MyClass_opLDoubleS::ice_response(const ::Test::LDoubleS& ret, const ::Test::LDoubleS& o)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(o);
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Test::AMD_MyClass_opKDoubleS::AMD_MyClass_opKDoubleS(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_MyClass_opKDoubleS::ice_response(const ::Test::KDoubleS& ret, const ::Test::KDoubleS& o)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(o);
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Test::AMD_MyClass_opQDoubleS::AMD_MyClass_opQDoubleS(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_MyClass_opQDoubleS::ice_response(const ::Test::QDoubleS& ret, const ::Test::QDoubleS& o)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(o);
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Test::AMD_MyClass_opSDoubleS::AMD_MyClass_opSDoubleS(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_MyClass_opSDoubleS::ice_response(const ::Test::SDoubleS& ret, const ::Test::SDoubleS& o)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(o);
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Test::AMD_MyClass_opAStringS::AMD_MyClass_opAStringS(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_MyClass_opAStringS::ice_response(const ::Test::AStringS& ret, const ::Test::AStringS& o)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(o);
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Test::AMD_MyClass_opLStringS::AMD_MyClass_opLStringS(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_MyClass_opLStringS::ice_response(const ::Test::LStringS& ret, const ::Test::LStringS& o)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(o);
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Test::AMD_MyClass_opKStringS::AMD_MyClass_opKStringS(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_MyClass_opKStringS::ice_response(const ::Test::KStringS& ret, const ::Test::KStringS& o)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(o);
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Test::AMD_MyClass_opQStringS::AMD_MyClass_opQStringS(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_MyClass_opQStringS::ice_response(const ::Test::QStringS& ret, const ::Test::QStringS& o)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(o);
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Test::AMD_MyClass_opSStringS::AMD_MyClass_opSStringS(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_MyClass_opSStringS::ice_response(const ::Test::SStringS& ret, const ::Test::SStringS& o)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(o);
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Test::AMD_MyClass_opAObjectS::AMD_MyClass_opAObjectS(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_MyClass_opAObjectS::ice_response(const ::Test::AObjectS& ret, const ::Test::AObjectS& o)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(o);
    ostr->write(ret);
    ostr->writePendingValues();
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Test::AMD_MyClass_opLObjectS::AMD_MyClass_opLObjectS(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_MyClass_opLObjectS::ice_response(const ::Test::LObjectS& ret, const ::Test::LObjectS& o)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(o);
    ostr->write(ret);
    ostr->writePendingValues();
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Test::AMD_MyClass_opAObjectPrxS::AMD_MyClass_opAObjectPrxS(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_MyClass_opAObjectPrxS::ice_response(const ::Test::AObjectPrxS& ret, const ::Test::AObjectPrxS& o)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(o);
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Test::AMD_MyClass_opLObjectPrxS::AMD_MyClass_opLObjectPrxS(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_MyClass_opLObjectPrxS::ice_response(const ::Test::LObjectPrxS& ret, const ::Test::LObjectPrxS& o)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(o);
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Test::AMD_MyClass_opKObjectPrxS::AMD_MyClass_opKObjectPrxS(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_MyClass_opKObjectPrxS::ice_response(const ::Test::KObjectPrxS& ret, const ::Test::KObjectPrxS& o)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(o);
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Test::AMD_MyClass_opQObjectPrxS::AMD_MyClass_opQObjectPrxS(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_MyClass_opQObjectPrxS::ice_response(const ::Test::QObjectPrxS& ret, const ::Test::QObjectPrxS& o)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(o);
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Test::AMD_MyClass_opSObjectPrxS::AMD_MyClass_opSObjectPrxS(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_MyClass_opSObjectPrxS::ice_response(const ::Test::SObjectPrxS& ret, const ::Test::SObjectPrxS& o)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(o);
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Test::AMD_MyClass_opAStructS::AMD_MyClass_opAStructS(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_MyClass_opAStructS::ice_response(const ::Test::AStructS& ret, const ::Test::AStructS& o)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(o);
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Test::AMD_MyClass_opLStructS::AMD_MyClass_opLStructS(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_MyClass_opLStructS::ice_response(const ::Test::LStructS& ret, const ::Test::LStructS& o)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(o);
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Test::AMD_MyClass_opKStructS::AMD_MyClass_opKStructS(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_MyClass_opKStructS::ice_response(const ::Test::KStructS& ret, const ::Test::KStructS& o)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(o);
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Test::AMD_MyClass_opQStructS::AMD_MyClass_opQStructS(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_MyClass_opQStructS::ice_response(const ::Test::QStructS& ret, const ::Test::QStructS& o)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(o);
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Test::AMD_MyClass_opSStructS::AMD_MyClass_opSStructS(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_MyClass_opSStructS::ice_response(const ::Test::SStructS& ret, const ::Test::SStructS& o)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(o);
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Test::AMD_MyClass_opAStructSD::AMD_MyClass_opAStructSD(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_MyClass_opAStructSD::ice_response(const ::Test::AStructSD& ret, const ::Test::AStructSD& o)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(o);
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Test::AMD_MyClass_opLStructSD::AMD_MyClass_opLStructSD(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_MyClass_opLStructSD::ice_response(const ::Test::LStructSD& ret, const ::Test::LStructSD& o)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(o);
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Test::AMD_MyClass_opKStructSD::AMD_MyClass_opKStructSD(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_MyClass_opKStructSD::ice_response(const ::Test::KStructSD& ret, const ::Test::KStructSD& o)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(o);
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Test::AMD_MyClass_opQStructSD::AMD_MyClass_opQStructSD(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_MyClass_opQStructSD::ice_response(const ::Test::QStructSD& ret, const ::Test::QStructSD& o)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(o);
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Test::AMD_MyClass_opSStructSD::AMD_MyClass_opSStructSD(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_MyClass_opSStructSD::ice_response(const ::Test::SStructSD& ret, const ::Test::SStructSD& o)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(o);
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Test::AMD_MyClass_opACVS::AMD_MyClass_opACVS(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_MyClass_opACVS::ice_response(const ::Test::ACVS& ret, const ::Test::ACVS& o)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(o);
    ostr->write(ret);
    ostr->writePendingValues();
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Test::AMD_MyClass_opLCVS::AMD_MyClass_opLCVS(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_MyClass_opLCVS::ice_response(const ::Test::LCVS& ret, const ::Test::LCVS& o)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(o);
    ostr->write(ret);
    ostr->writePendingValues();
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Test::AMD_MyClass_opACRS::AMD_MyClass_opACRS(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_MyClass_opACRS::ice_response(const ::Test::ACRS& ret, const ::Test::ACRS& o)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(o);
    ostr->write(ret);
    ostr->writePendingValues();
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Test::AMD_MyClass_opLCRS::AMD_MyClass_opLCRS(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_MyClass_opLCRS::ice_response(const ::Test::LCRS& ret, const ::Test::LCRS& o)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(o);
    ostr->write(ret);
    ostr->writePendingValues();
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Test::AMD_MyClass_opAEnS::AMD_MyClass_opAEnS(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_MyClass_opAEnS::ice_response(const ::Test::AEnS& ret, const ::Test::AEnS& o)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(o);
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Test::AMD_MyClass_opLEnS::AMD_MyClass_opLEnS(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_MyClass_opLEnS::ice_response(const ::Test::LEnS& ret, const ::Test::LEnS& o)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(o);
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Test::AMD_MyClass_opKEnS::AMD_MyClass_opKEnS(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_MyClass_opKEnS::ice_response(const ::Test::KEnS& ret, const ::Test::KEnS& o)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(o);
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Test::AMD_MyClass_opQEnS::AMD_MyClass_opQEnS(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_MyClass_opQEnS::ice_response(const ::Test::QEnS& ret, const ::Test::QEnS& o)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(o);
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Test::AMD_MyClass_opSEnS::AMD_MyClass_opSEnS(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_MyClass_opSEnS::ice_response(const ::Test::SEnS& ret, const ::Test::SEnS& o)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(o);
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Test::AMD_MyClass_opAIPrxS::AMD_MyClass_opAIPrxS(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_MyClass_opAIPrxS::ice_response(const ::Test::AIPrxS& ret, const ::Test::AIPrxS& o)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(o);
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Test::AMD_MyClass_opLIPrxS::AMD_MyClass_opLIPrxS(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_MyClass_opLIPrxS::ice_response(const ::Test::LIPrxS& ret, const ::Test::LIPrxS& o)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(o);
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Test::AMD_MyClass_opKIPrxS::AMD_MyClass_opKIPrxS(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_MyClass_opKIPrxS::ice_response(const ::Test::KIPrxS& ret, const ::Test::KIPrxS& o)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(o);
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Test::AMD_MyClass_opQIPrxS::AMD_MyClass_opQIPrxS(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_MyClass_opQIPrxS::ice_response(const ::Test::QIPrxS& ret, const ::Test::QIPrxS& o)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(o);
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Test::AMD_MyClass_opSIPrxS::AMD_MyClass_opSIPrxS(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_MyClass_opSIPrxS::ice_response(const ::Test::SIPrxS& ret, const ::Test::SIPrxS& o)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(o);
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Test::AMD_MyClass_opCustomIntS::AMD_MyClass_opCustomIntS(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_MyClass_opCustomIntS::ice_response(const ::Test::CustomIntS& ret, const ::Test::CustomIntS& o)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(o);
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Test::AMD_MyClass_opCustomCVS::AMD_MyClass_opCustomCVS(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_MyClass_opCustomCVS::ice_response(const ::Test::CustomCVS& ret, const ::Test::CustomCVS& o)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(o);
    ostr->write(ret);
    ostr->writePendingValues();
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Test::AMD_MyClass_opCustomIntSS::AMD_MyClass_opCustomIntSS(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_MyClass_opCustomIntSS::ice_response(const ::Test::CustomIntSS& ret, const ::Test::CustomIntSS& o)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(o);
    ostr->write(ret);
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
IceAsync::Test::AMD_MyClass_opCustomCVSS::AMD_MyClass_opCustomCVSS(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::Test::AMD_MyClass_opCustomCVSS::ice_response(const ::Test::CustomCVSS& ret, const ::Test::CustomCVSS& o)
{
    ::Ice::OutputStream* ostr = startWriteParams();
    ostr->write(o);
    ostr->write(ret);
    ostr->writePendingValues();
    endWriteParams();
    completed();
}
/// \endcond

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(I* p) { return p; }

void
::IceProxy::Test::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< I>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new I;
        v->_copyFrom(proxy);
    }
}
/// \endcond

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::Test::I::_newInstance() const
{
    return new I;
}
/// \endcond

const ::std::string&
IceProxy::Test::I::ice_staticId()
{
    return ::Test::I::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(MyClass* p) { return p; }

void
::IceProxy::Test::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< MyClass>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new MyClass;
        v->_copyFrom(proxy);
    }
}
/// \endcond

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_shutdown(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_shutdown_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_shutdown_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Test_MyClass_shutdown_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Test::MyClass::end_shutdown(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_Test_MyClass_shutdown_name);
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opAByteS(const ::Test::AByteS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opAByteS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opAByteS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opAByteS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opAByteS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::AByteS
IceProxy::Test::MyClass::end_opAByteS(::Test::AByteS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opAByteS_name);
    ::Test::AByteS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opAByteS(::Test::AByteS& iceP_o, ::Test::AByteS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opAByteS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opLByteS(const ::Test::LByteS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opLByteS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opLByteS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opLByteS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opLByteS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::LByteS
IceProxy::Test::MyClass::end_opLByteS(::Test::LByteS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opLByteS_name);
    ::Test::LByteS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opLByteS(::Test::LByteS& iceP_o, ::Test::LByteS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opLByteS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opKByteS(const ::Test::KByteS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opKByteS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opKByteS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opKByteS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opKByteS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::KByteS
IceProxy::Test::MyClass::end_opKByteS(::Test::KByteS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opKByteS_name);
    ::Test::KByteS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opKByteS(::Test::KByteS& iceP_o, ::Test::KByteS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opKByteS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opQByteS(const ::Test::QByteS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opQByteS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opQByteS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opQByteS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opQByteS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::QByteS
IceProxy::Test::MyClass::end_opQByteS(::Test::QByteS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opQByteS_name);
    ::Test::QByteS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opQByteS(::Test::QByteS& iceP_o, ::Test::QByteS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opQByteS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opSByteS(const ::Test::SByteS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opSByteS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opSByteS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opSByteS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opSByteS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::SByteS
IceProxy::Test::MyClass::end_opSByteS(::Test::SByteS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opSByteS_name);
    ::Test::SByteS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opSByteS(::Test::SByteS& iceP_o, ::Test::SByteS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opSByteS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opABoolS(const ::Test::ABoolS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opABoolS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opABoolS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opABoolS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opABoolS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::ABoolS
IceProxy::Test::MyClass::end_opABoolS(::Test::ABoolS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opABoolS_name);
    ::Test::ABoolS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opABoolS(::Test::ABoolS& iceP_o, ::Test::ABoolS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opABoolS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opLBoolS(const ::Test::LBoolS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opLBoolS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opLBoolS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opLBoolS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opLBoolS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::LBoolS
IceProxy::Test::MyClass::end_opLBoolS(::Test::LBoolS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opLBoolS_name);
    ::Test::LBoolS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opLBoolS(::Test::LBoolS& iceP_o, ::Test::LBoolS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opLBoolS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opKBoolS(const ::Test::KBoolS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opKBoolS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opKBoolS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opKBoolS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opKBoolS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::KBoolS
IceProxy::Test::MyClass::end_opKBoolS(::Test::KBoolS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opKBoolS_name);
    ::Test::KBoolS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opKBoolS(::Test::KBoolS& iceP_o, ::Test::KBoolS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opKBoolS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opQBoolS(const ::Test::QBoolS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opQBoolS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opQBoolS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opQBoolS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opQBoolS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::QBoolS
IceProxy::Test::MyClass::end_opQBoolS(::Test::QBoolS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opQBoolS_name);
    ::Test::QBoolS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opQBoolS(::Test::QBoolS& iceP_o, ::Test::QBoolS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opQBoolS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opSBoolS(const ::Test::SBoolS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opSBoolS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opSBoolS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opSBoolS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opSBoolS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::SBoolS
IceProxy::Test::MyClass::end_opSBoolS(::Test::SBoolS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opSBoolS_name);
    ::Test::SBoolS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opSBoolS(::Test::SBoolS& iceP_o, ::Test::SBoolS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opSBoolS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opAShortS(const ::Test::AShortS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opAShortS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opAShortS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opAShortS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opAShortS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::AShortS
IceProxy::Test::MyClass::end_opAShortS(::Test::AShortS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opAShortS_name);
    ::Test::AShortS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opAShortS(::Test::AShortS& iceP_o, ::Test::AShortS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opAShortS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opLShortS(const ::Test::LShortS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opLShortS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opLShortS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opLShortS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opLShortS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::LShortS
IceProxy::Test::MyClass::end_opLShortS(::Test::LShortS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opLShortS_name);
    ::Test::LShortS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opLShortS(::Test::LShortS& iceP_o, ::Test::LShortS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opLShortS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opKShortS(const ::Test::KShortS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opKShortS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opKShortS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opKShortS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opKShortS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::KShortS
IceProxy::Test::MyClass::end_opKShortS(::Test::KShortS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opKShortS_name);
    ::Test::KShortS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opKShortS(::Test::KShortS& iceP_o, ::Test::KShortS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opKShortS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opQShortS(const ::Test::QShortS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opQShortS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opQShortS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opQShortS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opQShortS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::QShortS
IceProxy::Test::MyClass::end_opQShortS(::Test::QShortS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opQShortS_name);
    ::Test::QShortS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opQShortS(::Test::QShortS& iceP_o, ::Test::QShortS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opQShortS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opSShortS(const ::Test::SShortS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opSShortS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opSShortS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opSShortS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opSShortS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::SShortS
IceProxy::Test::MyClass::end_opSShortS(::Test::SShortS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opSShortS_name);
    ::Test::SShortS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opSShortS(::Test::SShortS& iceP_o, ::Test::SShortS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opSShortS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opAIntS(const ::Test::AIntS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opAIntS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opAIntS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opAIntS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opAIntS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::AIntS
IceProxy::Test::MyClass::end_opAIntS(::Test::AIntS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opAIntS_name);
    ::Test::AIntS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opAIntS(::Test::AIntS& iceP_o, ::Test::AIntS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opAIntS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opLIntS(const ::Test::LIntS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opLIntS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opLIntS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opLIntS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opLIntS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::LIntS
IceProxy::Test::MyClass::end_opLIntS(::Test::LIntS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opLIntS_name);
    ::Test::LIntS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opLIntS(::Test::LIntS& iceP_o, ::Test::LIntS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opLIntS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opKIntS(const ::Test::KIntS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opKIntS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opKIntS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opKIntS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opKIntS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::KIntS
IceProxy::Test::MyClass::end_opKIntS(::Test::KIntS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opKIntS_name);
    ::Test::KIntS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opKIntS(::Test::KIntS& iceP_o, ::Test::KIntS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opKIntS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opQIntS(const ::Test::QIntS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opQIntS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opQIntS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opQIntS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opQIntS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::QIntS
IceProxy::Test::MyClass::end_opQIntS(::Test::QIntS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opQIntS_name);
    ::Test::QIntS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opQIntS(::Test::QIntS& iceP_o, ::Test::QIntS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opQIntS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opSIntS(const ::Test::SIntS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opSIntS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opSIntS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opSIntS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opSIntS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::SIntS
IceProxy::Test::MyClass::end_opSIntS(::Test::SIntS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opSIntS_name);
    ::Test::SIntS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opSIntS(::Test::SIntS& iceP_o, ::Test::SIntS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opSIntS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opALongS(const ::Test::ALongS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opALongS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opALongS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opALongS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opALongS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::ALongS
IceProxy::Test::MyClass::end_opALongS(::Test::ALongS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opALongS_name);
    ::Test::ALongS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opALongS(::Test::ALongS& iceP_o, ::Test::ALongS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opALongS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opLLongS(const ::Test::LLongS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opLLongS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opLLongS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opLLongS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opLLongS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::LLongS
IceProxy::Test::MyClass::end_opLLongS(::Test::LLongS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opLLongS_name);
    ::Test::LLongS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opLLongS(::Test::LLongS& iceP_o, ::Test::LLongS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opLLongS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opKLongS(const ::Test::KLongS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opKLongS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opKLongS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opKLongS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opKLongS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::KLongS
IceProxy::Test::MyClass::end_opKLongS(::Test::KLongS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opKLongS_name);
    ::Test::KLongS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opKLongS(::Test::KLongS& iceP_o, ::Test::KLongS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opKLongS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opQLongS(const ::Test::QLongS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opQLongS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opQLongS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opQLongS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opQLongS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::QLongS
IceProxy::Test::MyClass::end_opQLongS(::Test::QLongS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opQLongS_name);
    ::Test::QLongS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opQLongS(::Test::QLongS& iceP_o, ::Test::QLongS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opQLongS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opSLongS(const ::Test::SLongS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opSLongS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opSLongS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opSLongS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opSLongS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::SLongS
IceProxy::Test::MyClass::end_opSLongS(::Test::SLongS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opSLongS_name);
    ::Test::SLongS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opSLongS(::Test::SLongS& iceP_o, ::Test::SLongS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opSLongS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opAFloatS(const ::Test::AFloatS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opAFloatS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opAFloatS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opAFloatS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opAFloatS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::AFloatS
IceProxy::Test::MyClass::end_opAFloatS(::Test::AFloatS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opAFloatS_name);
    ::Test::AFloatS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opAFloatS(::Test::AFloatS& iceP_o, ::Test::AFloatS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opAFloatS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opLFloatS(const ::Test::LFloatS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opLFloatS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opLFloatS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opLFloatS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opLFloatS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::LFloatS
IceProxy::Test::MyClass::end_opLFloatS(::Test::LFloatS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opLFloatS_name);
    ::Test::LFloatS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opLFloatS(::Test::LFloatS& iceP_o, ::Test::LFloatS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opLFloatS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opKFloatS(const ::Test::KFloatS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opKFloatS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opKFloatS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opKFloatS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opKFloatS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::KFloatS
IceProxy::Test::MyClass::end_opKFloatS(::Test::KFloatS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opKFloatS_name);
    ::Test::KFloatS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opKFloatS(::Test::KFloatS& iceP_o, ::Test::KFloatS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opKFloatS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opQFloatS(const ::Test::QFloatS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opQFloatS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opQFloatS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opQFloatS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opQFloatS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::QFloatS
IceProxy::Test::MyClass::end_opQFloatS(::Test::QFloatS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opQFloatS_name);
    ::Test::QFloatS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opQFloatS(::Test::QFloatS& iceP_o, ::Test::QFloatS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opQFloatS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opSFloatS(const ::Test::SFloatS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opSFloatS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opSFloatS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opSFloatS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opSFloatS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::SFloatS
IceProxy::Test::MyClass::end_opSFloatS(::Test::SFloatS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opSFloatS_name);
    ::Test::SFloatS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opSFloatS(::Test::SFloatS& iceP_o, ::Test::SFloatS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opSFloatS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opADoubleS(const ::Test::ADoubleS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opADoubleS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opADoubleS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opADoubleS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opADoubleS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::ADoubleS
IceProxy::Test::MyClass::end_opADoubleS(::Test::ADoubleS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opADoubleS_name);
    ::Test::ADoubleS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opADoubleS(::Test::ADoubleS& iceP_o, ::Test::ADoubleS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opADoubleS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opLDoubleS(const ::Test::LDoubleS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opLDoubleS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opLDoubleS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opLDoubleS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opLDoubleS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::LDoubleS
IceProxy::Test::MyClass::end_opLDoubleS(::Test::LDoubleS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opLDoubleS_name);
    ::Test::LDoubleS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opLDoubleS(::Test::LDoubleS& iceP_o, ::Test::LDoubleS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opLDoubleS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opKDoubleS(const ::Test::KDoubleS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opKDoubleS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opKDoubleS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opKDoubleS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opKDoubleS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::KDoubleS
IceProxy::Test::MyClass::end_opKDoubleS(::Test::KDoubleS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opKDoubleS_name);
    ::Test::KDoubleS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opKDoubleS(::Test::KDoubleS& iceP_o, ::Test::KDoubleS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opKDoubleS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opQDoubleS(const ::Test::QDoubleS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opQDoubleS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opQDoubleS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opQDoubleS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opQDoubleS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::QDoubleS
IceProxy::Test::MyClass::end_opQDoubleS(::Test::QDoubleS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opQDoubleS_name);
    ::Test::QDoubleS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opQDoubleS(::Test::QDoubleS& iceP_o, ::Test::QDoubleS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opQDoubleS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opSDoubleS(const ::Test::SDoubleS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opSDoubleS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opSDoubleS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opSDoubleS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opSDoubleS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::SDoubleS
IceProxy::Test::MyClass::end_opSDoubleS(::Test::SDoubleS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opSDoubleS_name);
    ::Test::SDoubleS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opSDoubleS(::Test::SDoubleS& iceP_o, ::Test::SDoubleS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opSDoubleS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opAStringS(const ::Test::AStringS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opAStringS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opAStringS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opAStringS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opAStringS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::AStringS
IceProxy::Test::MyClass::end_opAStringS(::Test::AStringS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opAStringS_name);
    ::Test::AStringS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opAStringS(::Test::AStringS& iceP_o, ::Test::AStringS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opAStringS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opLStringS(const ::Test::LStringS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opLStringS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opLStringS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opLStringS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opLStringS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::LStringS
IceProxy::Test::MyClass::end_opLStringS(::Test::LStringS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opLStringS_name);
    ::Test::LStringS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opLStringS(::Test::LStringS& iceP_o, ::Test::LStringS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opLStringS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opKStringS(const ::Test::KStringS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opKStringS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opKStringS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opKStringS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opKStringS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::KStringS
IceProxy::Test::MyClass::end_opKStringS(::Test::KStringS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opKStringS_name);
    ::Test::KStringS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opKStringS(::Test::KStringS& iceP_o, ::Test::KStringS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opKStringS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opQStringS(const ::Test::QStringS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opQStringS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opQStringS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opQStringS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opQStringS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::QStringS
IceProxy::Test::MyClass::end_opQStringS(::Test::QStringS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opQStringS_name);
    ::Test::QStringS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opQStringS(::Test::QStringS& iceP_o, ::Test::QStringS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opQStringS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opSStringS(const ::Test::SStringS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opSStringS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opSStringS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opSStringS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opSStringS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::SStringS
IceProxy::Test::MyClass::end_opSStringS(::Test::SStringS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opSStringS_name);
    ::Test::SStringS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opSStringS(::Test::SStringS& iceP_o, ::Test::SStringS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opSStringS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opAObjectS(const ::Test::AObjectS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opAObjectS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opAObjectS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opAObjectS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        ostr->writePendingValues();
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opAObjectS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::AObjectS
IceProxy::Test::MyClass::end_opAObjectS(::Test::AObjectS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opAObjectS_name);
    ::Test::AObjectS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    istr->readPendingValues();
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opAObjectS(::Test::AObjectS& iceP_o, ::Test::AObjectS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opAObjectS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    istr->readPendingValues();
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opLObjectS(const ::Test::LObjectS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opLObjectS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opLObjectS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opLObjectS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        ostr->writePendingValues();
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opLObjectS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::LObjectS
IceProxy::Test::MyClass::end_opLObjectS(::Test::LObjectS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opLObjectS_name);
    ::Test::LObjectS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    istr->readPendingValues();
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opLObjectS(::Test::LObjectS& iceP_o, ::Test::LObjectS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opLObjectS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    istr->readPendingValues();
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opAObjectPrxS(const ::Test::AObjectPrxS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opAObjectPrxS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opAObjectPrxS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opAObjectPrxS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opAObjectPrxS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::AObjectPrxS
IceProxy::Test::MyClass::end_opAObjectPrxS(::Test::AObjectPrxS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opAObjectPrxS_name);
    ::Test::AObjectPrxS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opAObjectPrxS(::Test::AObjectPrxS& iceP_o, ::Test::AObjectPrxS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opAObjectPrxS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opLObjectPrxS(const ::Test::LObjectPrxS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opLObjectPrxS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opLObjectPrxS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opLObjectPrxS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opLObjectPrxS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::LObjectPrxS
IceProxy::Test::MyClass::end_opLObjectPrxS(::Test::LObjectPrxS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opLObjectPrxS_name);
    ::Test::LObjectPrxS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opLObjectPrxS(::Test::LObjectPrxS& iceP_o, ::Test::LObjectPrxS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opLObjectPrxS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opKObjectPrxS(const ::Test::KObjectPrxS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opKObjectPrxS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opKObjectPrxS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opKObjectPrxS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opKObjectPrxS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::KObjectPrxS
IceProxy::Test::MyClass::end_opKObjectPrxS(::Test::KObjectPrxS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opKObjectPrxS_name);
    ::Test::KObjectPrxS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opKObjectPrxS(::Test::KObjectPrxS& iceP_o, ::Test::KObjectPrxS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opKObjectPrxS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opQObjectPrxS(const ::Test::QObjectPrxS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opQObjectPrxS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opQObjectPrxS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opQObjectPrxS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opQObjectPrxS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::QObjectPrxS
IceProxy::Test::MyClass::end_opQObjectPrxS(::Test::QObjectPrxS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opQObjectPrxS_name);
    ::Test::QObjectPrxS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opQObjectPrxS(::Test::QObjectPrxS& iceP_o, ::Test::QObjectPrxS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opQObjectPrxS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opSObjectPrxS(const ::Test::SObjectPrxS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opSObjectPrxS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opSObjectPrxS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opSObjectPrxS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opSObjectPrxS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::SObjectPrxS
IceProxy::Test::MyClass::end_opSObjectPrxS(::Test::SObjectPrxS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opSObjectPrxS_name);
    ::Test::SObjectPrxS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opSObjectPrxS(::Test::SObjectPrxS& iceP_o, ::Test::SObjectPrxS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opSObjectPrxS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opAStructS(const ::Test::AStructS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opAStructS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opAStructS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opAStructS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opAStructS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::AStructS
IceProxy::Test::MyClass::end_opAStructS(::Test::AStructS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opAStructS_name);
    ::Test::AStructS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opAStructS(::Test::AStructS& iceP_o, ::Test::AStructS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opAStructS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opLStructS(const ::Test::LStructS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opLStructS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opLStructS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opLStructS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opLStructS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::LStructS
IceProxy::Test::MyClass::end_opLStructS(::Test::LStructS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opLStructS_name);
    ::Test::LStructS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opLStructS(::Test::LStructS& iceP_o, ::Test::LStructS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opLStructS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opKStructS(const ::Test::KStructS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opKStructS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opKStructS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opKStructS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opKStructS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::KStructS
IceProxy::Test::MyClass::end_opKStructS(::Test::KStructS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opKStructS_name);
    ::Test::KStructS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opKStructS(::Test::KStructS& iceP_o, ::Test::KStructS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opKStructS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opQStructS(const ::Test::QStructS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opQStructS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opQStructS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opQStructS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opQStructS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::QStructS
IceProxy::Test::MyClass::end_opQStructS(::Test::QStructS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opQStructS_name);
    ::Test::QStructS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opQStructS(::Test::QStructS& iceP_o, ::Test::QStructS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opQStructS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opSStructS(const ::Test::SStructS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opSStructS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opSStructS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opSStructS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opSStructS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::SStructS
IceProxy::Test::MyClass::end_opSStructS(::Test::SStructS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opSStructS_name);
    ::Test::SStructS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opSStructS(::Test::SStructS& iceP_o, ::Test::SStructS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opSStructS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opAStructSD(const ::Test::AStructSD& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opAStructSD_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opAStructSD_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opAStructSD_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opAStructSD_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::AStructSD
IceProxy::Test::MyClass::end_opAStructSD(::Test::AStructSD& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opAStructSD_name);
    ::Test::AStructSD ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opAStructSD(::Test::AStructSD& iceP_o, ::Test::AStructSD& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opAStructSD_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opLStructSD(const ::Test::LStructSD& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opLStructSD_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opLStructSD_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opLStructSD_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opLStructSD_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::LStructSD
IceProxy::Test::MyClass::end_opLStructSD(::Test::LStructSD& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opLStructSD_name);
    ::Test::LStructSD ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opLStructSD(::Test::LStructSD& iceP_o, ::Test::LStructSD& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opLStructSD_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opKStructSD(const ::Test::KStructSD& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opKStructSD_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opKStructSD_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opKStructSD_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opKStructSD_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::KStructSD
IceProxy::Test::MyClass::end_opKStructSD(::Test::KStructSD& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opKStructSD_name);
    ::Test::KStructSD ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opKStructSD(::Test::KStructSD& iceP_o, ::Test::KStructSD& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opKStructSD_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opQStructSD(const ::Test::QStructSD& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opQStructSD_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opQStructSD_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opQStructSD_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opQStructSD_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::QStructSD
IceProxy::Test::MyClass::end_opQStructSD(::Test::QStructSD& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opQStructSD_name);
    ::Test::QStructSD ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opQStructSD(::Test::QStructSD& iceP_o, ::Test::QStructSD& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opQStructSD_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opSStructSD(const ::Test::SStructSD& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opSStructSD_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opSStructSD_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opSStructSD_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opSStructSD_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::SStructSD
IceProxy::Test::MyClass::end_opSStructSD(::Test::SStructSD& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opSStructSD_name);
    ::Test::SStructSD ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opSStructSD(::Test::SStructSD& iceP_o, ::Test::SStructSD& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opSStructSD_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opACVS(const ::Test::ACVS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opACVS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opACVS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opACVS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        ostr->writePendingValues();
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opACVS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::ACVS
IceProxy::Test::MyClass::end_opACVS(::Test::ACVS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opACVS_name);
    ::Test::ACVS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    istr->readPendingValues();
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opACVS(::Test::ACVS& iceP_o, ::Test::ACVS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opACVS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    istr->readPendingValues();
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opLCVS(const ::Test::LCVS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opLCVS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opLCVS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opLCVS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        ostr->writePendingValues();
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opLCVS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::LCVS
IceProxy::Test::MyClass::end_opLCVS(::Test::LCVS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opLCVS_name);
    ::Test::LCVS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    istr->readPendingValues();
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opLCVS(::Test::LCVS& iceP_o, ::Test::LCVS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opLCVS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    istr->readPendingValues();
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opACRS(const ::Test::ACRS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opACRS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opACRS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opACRS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        ostr->writePendingValues();
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opACRS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::ACRS
IceProxy::Test::MyClass::end_opACRS(::Test::ACRS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opACRS_name);
    ::Test::ACRS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    istr->readPendingValues();
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opACRS(::Test::ACRS& iceP_o, ::Test::ACRS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opACRS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    istr->readPendingValues();
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opLCRS(const ::Test::LCRS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opLCRS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opLCRS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opLCRS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        ostr->writePendingValues();
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opLCRS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::LCRS
IceProxy::Test::MyClass::end_opLCRS(::Test::LCRS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opLCRS_name);
    ::Test::LCRS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    istr->readPendingValues();
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opLCRS(::Test::LCRS& iceP_o, ::Test::LCRS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opLCRS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    istr->readPendingValues();
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opAEnS(const ::Test::AEnS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opAEnS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opAEnS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opAEnS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opAEnS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::AEnS
IceProxy::Test::MyClass::end_opAEnS(::Test::AEnS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opAEnS_name);
    ::Test::AEnS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opAEnS(::Test::AEnS& iceP_o, ::Test::AEnS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opAEnS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opLEnS(const ::Test::LEnS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opLEnS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opLEnS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opLEnS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opLEnS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::LEnS
IceProxy::Test::MyClass::end_opLEnS(::Test::LEnS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opLEnS_name);
    ::Test::LEnS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opLEnS(::Test::LEnS& iceP_o, ::Test::LEnS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opLEnS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opKEnS(const ::Test::KEnS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opKEnS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opKEnS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opKEnS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opKEnS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::KEnS
IceProxy::Test::MyClass::end_opKEnS(::Test::KEnS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opKEnS_name);
    ::Test::KEnS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opKEnS(::Test::KEnS& iceP_o, ::Test::KEnS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opKEnS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opQEnS(const ::Test::QEnS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opQEnS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opQEnS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opQEnS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opQEnS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::QEnS
IceProxy::Test::MyClass::end_opQEnS(::Test::QEnS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opQEnS_name);
    ::Test::QEnS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opQEnS(::Test::QEnS& iceP_o, ::Test::QEnS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opQEnS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opSEnS(const ::Test::SEnS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opSEnS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opSEnS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opSEnS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opSEnS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::SEnS
IceProxy::Test::MyClass::end_opSEnS(::Test::SEnS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opSEnS_name);
    ::Test::SEnS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opSEnS(::Test::SEnS& iceP_o, ::Test::SEnS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opSEnS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opAIPrxS(const ::Test::AIPrxS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opAIPrxS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opAIPrxS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opAIPrxS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opAIPrxS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::AIPrxS
IceProxy::Test::MyClass::end_opAIPrxS(::Test::AIPrxS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opAIPrxS_name);
    ::Test::AIPrxS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opAIPrxS(::Test::AIPrxS& iceP_o, ::Test::AIPrxS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opAIPrxS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opLIPrxS(const ::Test::LIPrxS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opLIPrxS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opLIPrxS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opLIPrxS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opLIPrxS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::LIPrxS
IceProxy::Test::MyClass::end_opLIPrxS(::Test::LIPrxS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opLIPrxS_name);
    ::Test::LIPrxS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opLIPrxS(::Test::LIPrxS& iceP_o, ::Test::LIPrxS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opLIPrxS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opKIPrxS(const ::Test::KIPrxS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opKIPrxS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opKIPrxS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opKIPrxS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opKIPrxS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::KIPrxS
IceProxy::Test::MyClass::end_opKIPrxS(::Test::KIPrxS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opKIPrxS_name);
    ::Test::KIPrxS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opKIPrxS(::Test::KIPrxS& iceP_o, ::Test::KIPrxS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opKIPrxS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opQIPrxS(const ::Test::QIPrxS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opQIPrxS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opQIPrxS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opQIPrxS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opQIPrxS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::QIPrxS
IceProxy::Test::MyClass::end_opQIPrxS(::Test::QIPrxS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opQIPrxS_name);
    ::Test::QIPrxS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opQIPrxS(::Test::QIPrxS& iceP_o, ::Test::QIPrxS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opQIPrxS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opSIPrxS(const ::Test::SIPrxS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opSIPrxS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opSIPrxS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opSIPrxS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opSIPrxS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::SIPrxS
IceProxy::Test::MyClass::end_opSIPrxS(::Test::SIPrxS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opSIPrxS_name);
    ::Test::SIPrxS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opSIPrxS(::Test::SIPrxS& iceP_o, ::Test::SIPrxS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opSIPrxS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opCustomIntS(const ::Test::CustomIntS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opCustomIntS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opCustomIntS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opCustomIntS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opCustomIntS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::CustomIntS
IceProxy::Test::MyClass::end_opCustomIntS(::Test::CustomIntS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opCustomIntS_name);
    ::Test::CustomIntS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opCustomIntS(::Test::CustomIntS& iceP_o, ::Test::CustomIntS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opCustomIntS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opCustomCVS(const ::Test::CustomCVS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opCustomCVS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opCustomCVS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opCustomCVS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        ostr->writePendingValues();
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opCustomCVS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::CustomCVS
IceProxy::Test::MyClass::end_opCustomCVS(::Test::CustomCVS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opCustomCVS_name);
    ::Test::CustomCVS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    istr->readPendingValues();
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opCustomCVS(::Test::CustomCVS& iceP_o, ::Test::CustomCVS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opCustomCVS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    istr->readPendingValues();
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opCustomIntSS(const ::Test::CustomIntSS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opCustomIntSS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opCustomIntSS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opCustomIntSS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opCustomIntSS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::CustomIntSS
IceProxy::Test::MyClass::end_opCustomIntSS(::Test::CustomIntSS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opCustomIntSS_name);
    ::Test::CustomIntSS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opCustomIntSS(::Test::CustomIntSS& iceP_o, ::Test::CustomIntSS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opCustomIntSS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opCustomCVSS(const ::Test::CustomCVSS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opCustomCVSS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opCustomCVSS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opCustomCVSS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        ostr->writePendingValues();
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opCustomCVSS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::CustomCVSS
IceProxy::Test::MyClass::end_opCustomCVSS(::Test::CustomCVSS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opCustomCVSS_name);
    ::Test::CustomCVSS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    istr->readPendingValues();
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opCustomCVSS(::Test::CustomCVSS& iceP_o, ::Test::CustomCVSS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opCustomCVSS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    istr->readPendingValues();
    result->_endReadParams();
}

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::Test::MyClass::_newInstance() const
{
    return new MyClass;
}
/// \endcond

const ::std::string&
IceProxy::Test::MyClass::ice_staticId()
{
    return ::Test::MyClass::ice_staticId();
}

Test::I::~I()
{
}

namespace
{
const ::std::string iceC_Test_I_ids[2] =
{
    "::Ice::Object",
    "::Test::I"
};

}

bool
Test::I::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_I_ids, iceC_Test_I_ids + 2, s);
}

::std::vector< ::std::string>
Test::I::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Test_I_ids[0], &iceC_Test_I_ids[2]);
}

const ::std::string&
Test::I::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::I::ice_staticId()
{
    static const ::std::string typeId = "::Test::I";
    return typeId;
}

Test::MyClass::~MyClass()
{
}

namespace
{
const ::std::string iceC_Test_MyClass_ids[2] =
{
    "::Ice::Object",
    "::Test::MyClass"
};

}

bool
Test::MyClass::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_MyClass_ids, iceC_Test_MyClass_ids + 2, s);
}

::std::vector< ::std::string>
Test::MyClass::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Test_MyClass_ids[0], &iceC_Test_MyClass_ids[2]);
}

const ::std::string&
Test::MyClass::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::MyClass::ice_staticId()
{
    static const ::std::string typeId = "::Test::MyClass";
    return typeId;
}

/// \cond INTERNAL
bool
Test::MyClass::_iceD_shutdown(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    this->shutdown_async(new IceAsync::Test::AMD_MyClass_shutdown(inS), current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opAByteS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    AByteS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    this->opAByteS_async(new IceAsync::Test::AMD_MyClass_opAByteS(inS), iceP_i, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opLByteS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    LByteS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    this->opLByteS_async(new IceAsync::Test::AMD_MyClass_opLByteS(inS), iceP_i, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opKByteS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    KByteS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    this->opKByteS_async(new IceAsync::Test::AMD_MyClass_opKByteS(inS), iceP_i, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opQByteS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    QByteS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    this->opQByteS_async(new IceAsync::Test::AMD_MyClass_opQByteS(inS), iceP_i, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opSByteS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    SByteS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    this->opSByteS_async(new IceAsync::Test::AMD_MyClass_opSByteS(inS), iceP_i, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opABoolS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ABoolS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    this->opABoolS_async(new IceAsync::Test::AMD_MyClass_opABoolS(inS), iceP_i, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opLBoolS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    LBoolS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    this->opLBoolS_async(new IceAsync::Test::AMD_MyClass_opLBoolS(inS), iceP_i, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opKBoolS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    KBoolS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    this->opKBoolS_async(new IceAsync::Test::AMD_MyClass_opKBoolS(inS), iceP_i, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opQBoolS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    QBoolS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    this->opQBoolS_async(new IceAsync::Test::AMD_MyClass_opQBoolS(inS), iceP_i, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opSBoolS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    SBoolS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    this->opSBoolS_async(new IceAsync::Test::AMD_MyClass_opSBoolS(inS), iceP_i, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opAShortS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    AShortS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    this->opAShortS_async(new IceAsync::Test::AMD_MyClass_opAShortS(inS), iceP_i, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opLShortS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    LShortS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    this->opLShortS_async(new IceAsync::Test::AMD_MyClass_opLShortS(inS), iceP_i, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opKShortS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    KShortS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    this->opKShortS_async(new IceAsync::Test::AMD_MyClass_opKShortS(inS), iceP_i, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opQShortS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    QShortS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    this->opQShortS_async(new IceAsync::Test::AMD_MyClass_opQShortS(inS), iceP_i, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opSShortS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    SShortS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    this->opSShortS_async(new IceAsync::Test::AMD_MyClass_opSShortS(inS), iceP_i, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opAIntS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    AIntS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    this->opAIntS_async(new IceAsync::Test::AMD_MyClass_opAIntS(inS), iceP_i, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opLIntS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    LIntS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    this->opLIntS_async(new IceAsync::Test::AMD_MyClass_opLIntS(inS), iceP_i, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opKIntS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    KIntS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    this->opKIntS_async(new IceAsync::Test::AMD_MyClass_opKIntS(inS), iceP_i, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opQIntS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    QIntS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    this->opQIntS_async(new IceAsync::Test::AMD_MyClass_opQIntS(inS), iceP_i, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opSIntS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    SIntS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    this->opSIntS_async(new IceAsync::Test::AMD_MyClass_opSIntS(inS), iceP_i, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opALongS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ALongS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    this->opALongS_async(new IceAsync::Test::AMD_MyClass_opALongS(inS), iceP_i, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opLLongS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    LLongS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    this->opLLongS_async(new IceAsync::Test::AMD_MyClass_opLLongS(inS), iceP_i, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opKLongS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    KLongS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    this->opKLongS_async(new IceAsync::Test::AMD_MyClass_opKLongS(inS), iceP_i, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opQLongS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    QLongS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    this->opQLongS_async(new IceAsync::Test::AMD_MyClass_opQLongS(inS), iceP_i, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opSLongS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    SLongS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    this->opSLongS_async(new IceAsync::Test::AMD_MyClass_opSLongS(inS), iceP_i, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opAFloatS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    AFloatS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    this->opAFloatS_async(new IceAsync::Test::AMD_MyClass_opAFloatS(inS), iceP_i, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opLFloatS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    LFloatS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    this->opLFloatS_async(new IceAsync::Test::AMD_MyClass_opLFloatS(inS), iceP_i, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opKFloatS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    KFloatS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    this->opKFloatS_async(new IceAsync::Test::AMD_MyClass_opKFloatS(inS), iceP_i, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opQFloatS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    QFloatS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    this->opQFloatS_async(new IceAsync::Test::AMD_MyClass_opQFloatS(inS), iceP_i, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opSFloatS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    SFloatS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    this->opSFloatS_async(new IceAsync::Test::AMD_MyClass_opSFloatS(inS), iceP_i, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opADoubleS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ADoubleS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    this->opADoubleS_async(new IceAsync::Test::AMD_MyClass_opADoubleS(inS), iceP_i, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opLDoubleS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    LDoubleS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    this->opLDoubleS_async(new IceAsync::Test::AMD_MyClass_opLDoubleS(inS), iceP_i, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opKDoubleS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    KDoubleS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    this->opKDoubleS_async(new IceAsync::Test::AMD_MyClass_opKDoubleS(inS), iceP_i, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opQDoubleS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    QDoubleS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    this->opQDoubleS_async(new IceAsync::Test::AMD_MyClass_opQDoubleS(inS), iceP_i, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opSDoubleS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    SDoubleS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    this->opSDoubleS_async(new IceAsync::Test::AMD_MyClass_opSDoubleS(inS), iceP_i, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opAStringS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    AStringS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    this->opAStringS_async(new IceAsync::Test::AMD_MyClass_opAStringS(inS), iceP_i, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opLStringS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    LStringS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    this->opLStringS_async(new IceAsync::Test::AMD_MyClass_opLStringS(inS), iceP_i, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opKStringS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    KStringS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    this->opKStringS_async(new IceAsync::Test::AMD_MyClass_opKStringS(inS), iceP_i, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opQStringS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    QStringS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    this->opQStringS_async(new IceAsync::Test::AMD_MyClass_opQStringS(inS), iceP_i, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opSStringS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    SStringS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    this->opSStringS_async(new IceAsync::Test::AMD_MyClass_opSStringS(inS), iceP_i, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opAObjectS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    AObjectS iceP_i;
    istr->read(iceP_i);
    istr->readPendingValues();
    inS.endReadParams();
    this->opAObjectS_async(new IceAsync::Test::AMD_MyClass_opAObjectS(inS), iceP_i, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opLObjectS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    LObjectS iceP_i;
    istr->read(iceP_i);
    istr->readPendingValues();
    inS.endReadParams();
    this->opLObjectS_async(new IceAsync::Test::AMD_MyClass_opLObjectS(inS), iceP_i, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opAObjectPrxS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    AObjectPrxS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    this->opAObjectPrxS_async(new IceAsync::Test::AMD_MyClass_opAObjectPrxS(inS), iceP_i, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opLObjectPrxS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    LObjectPrxS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    this->opLObjectPrxS_async(new IceAsync::Test::AMD_MyClass_opLObjectPrxS(inS), iceP_i, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opKObjectPrxS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    KObjectPrxS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    this->opKObjectPrxS_async(new IceAsync::Test::AMD_MyClass_opKObjectPrxS(inS), iceP_i, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opQObjectPrxS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    QObjectPrxS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    this->opQObjectPrxS_async(new IceAsync::Test::AMD_MyClass_opQObjectPrxS(inS), iceP_i, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opSObjectPrxS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    SObjectPrxS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    this->opSObjectPrxS_async(new IceAsync::Test::AMD_MyClass_opSObjectPrxS(inS), iceP_i, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opAStructS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    AStructS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    this->opAStructS_async(new IceAsync::Test::AMD_MyClass_opAStructS(inS), iceP_i, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opLStructS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    LStructS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    this->opLStructS_async(new IceAsync::Test::AMD_MyClass_opLStructS(inS), iceP_i, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opKStructS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    KStructS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    this->opKStructS_async(new IceAsync::Test::AMD_MyClass_opKStructS(inS), iceP_i, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opQStructS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    QStructS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    this->opQStructS_async(new IceAsync::Test::AMD_MyClass_opQStructS(inS), iceP_i, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opSStructS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    SStructS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    this->opSStructS_async(new IceAsync::Test::AMD_MyClass_opSStructS(inS), iceP_i, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opAStructSD(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    AStructSD iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    this->opAStructSD_async(new IceAsync::Test::AMD_MyClass_opAStructSD(inS), iceP_i, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opLStructSD(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    LStructSD iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    this->opLStructSD_async(new IceAsync::Test::AMD_MyClass_opLStructSD(inS), iceP_i, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opKStructSD(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    KStructSD iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    this->opKStructSD_async(new IceAsync::Test::AMD_MyClass_opKStructSD(inS), iceP_i, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opQStructSD(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    QStructSD iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    this->opQStructSD_async(new IceAsync::Test::AMD_MyClass_opQStructSD(inS), iceP_i, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opSStructSD(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    SStructSD iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    this->opSStructSD_async(new IceAsync::Test::AMD_MyClass_opSStructSD(inS), iceP_i, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opACVS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ACVS iceP_i;
    istr->read(iceP_i);
    istr->readPendingValues();
    inS.endReadParams();
    this->opACVS_async(new IceAsync::Test::AMD_MyClass_opACVS(inS), iceP_i, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opLCVS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    LCVS iceP_i;
    istr->read(iceP_i);
    istr->readPendingValues();
    inS.endReadParams();
    this->opLCVS_async(new IceAsync::Test::AMD_MyClass_opLCVS(inS), iceP_i, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opACRS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ACRS iceP_i;
    istr->read(iceP_i);
    istr->readPendingValues();
    inS.endReadParams();
    this->opACRS_async(new IceAsync::Test::AMD_MyClass_opACRS(inS), iceP_i, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opLCRS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    LCRS iceP_i;
    istr->read(iceP_i);
    istr->readPendingValues();
    inS.endReadParams();
    this->opLCRS_async(new IceAsync::Test::AMD_MyClass_opLCRS(inS), iceP_i, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opAEnS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    AEnS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    this->opAEnS_async(new IceAsync::Test::AMD_MyClass_opAEnS(inS), iceP_i, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opLEnS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    LEnS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    this->opLEnS_async(new IceAsync::Test::AMD_MyClass_opLEnS(inS), iceP_i, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opKEnS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    KEnS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    this->opKEnS_async(new IceAsync::Test::AMD_MyClass_opKEnS(inS), iceP_i, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opQEnS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    QEnS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    this->opQEnS_async(new IceAsync::Test::AMD_MyClass_opQEnS(inS), iceP_i, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opSEnS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    SEnS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    this->opSEnS_async(new IceAsync::Test::AMD_MyClass_opSEnS(inS), iceP_i, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opAIPrxS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    AIPrxS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    this->opAIPrxS_async(new IceAsync::Test::AMD_MyClass_opAIPrxS(inS), iceP_i, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opLIPrxS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    LIPrxS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    this->opLIPrxS_async(new IceAsync::Test::AMD_MyClass_opLIPrxS(inS), iceP_i, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opKIPrxS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    KIPrxS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    this->opKIPrxS_async(new IceAsync::Test::AMD_MyClass_opKIPrxS(inS), iceP_i, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opQIPrxS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    QIPrxS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    this->opQIPrxS_async(new IceAsync::Test::AMD_MyClass_opQIPrxS(inS), iceP_i, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opSIPrxS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    SIPrxS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    this->opSIPrxS_async(new IceAsync::Test::AMD_MyClass_opSIPrxS(inS), iceP_i, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opCustomIntS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    CustomIntS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    this->opCustomIntS_async(new IceAsync::Test::AMD_MyClass_opCustomIntS(inS), iceP_i, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opCustomCVS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    CustomCVS iceP_i;
    istr->read(iceP_i);
    istr->readPendingValues();
    inS.endReadParams();
    this->opCustomCVS_async(new IceAsync::Test::AMD_MyClass_opCustomCVS(inS), iceP_i, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opCustomIntSS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    CustomIntSS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    this->opCustomIntSS_async(new IceAsync::Test::AMD_MyClass_opCustomIntSS(inS), iceP_i, current);
    return false;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opCustomCVSS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    CustomCVSS iceP_i;
    istr->read(iceP_i);
    istr->readPendingValues();
    inS.endReadParams();
    this->opCustomCVSS_async(new IceAsync::Test::AMD_MyClass_opCustomCVSS(inS), iceP_i, current);
    return false;
}
/// \endcond

namespace
{
const ::std::string iceC_Test_MyClass_all[] =
{
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "opABoolS",
    "opAByteS",
    "opACRS",
    "opACVS",
    "opADoubleS",
    "opAEnS",
    "opAFloatS",
    "opAIPrxS",
    "opAIntS",
    "opALongS",
    "opAObjectPrxS",
    "opAObjectS",
    "opAShortS",
    "opAStringS",
    "opAStructS",
    "opAStructSD",
    "opCustomCVS",
    "opCustomCVSS",
    "opCustomIntS",
    "opCustomIntSS",
    "opKBoolS",
    "opKByteS",
    "opKDoubleS",
    "opKEnS",
    "opKFloatS",
    "opKIPrxS",
    "opKIntS",
    "opKLongS",
    "opKObjectPrxS",
    "opKShortS",
    "opKStringS",
    "opKStructS",
    "opKStructSD",
    "opLBoolS",
    "opLByteS",
    "opLCRS",
    "opLCVS",
    "opLDoubleS",
    "opLEnS",
    "opLFloatS",
    "opLIPrxS",
    "opLIntS",
    "opLLongS",
    "opLObjectPrxS",
    "opLObjectS",
    "opLShortS",
    "opLStringS",
    "opLStructS",
    "opLStructSD",
    "opQBoolS",
    "opQByteS",
    "opQDoubleS",
    "opQEnS",
    "opQFloatS",
    "opQIPrxS",
    "opQIntS",
    "opQLongS",
    "opQObjectPrxS",
    "opQShortS",
    "opQStringS",
    "opQStructS",
    "opQStructSD",
    "opSBoolS",
    "opSByteS",
    "opSDoubleS",
    "opSEnS",
    "opSFloatS",
    "opSIPrxS",
    "opSIntS",
    "opSLongS",
    "opSObjectPrxS",
    "opSShortS",
    "opSStringS",
    "opSStructS",
    "opSStructSD",
    "shutdown"
};

}

/// \cond INTERNAL
bool
Test::MyClass::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_Test_MyClass_all, iceC_Test_MyClass_all + 80, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_Test_MyClass_all)
    {
        case 0:
        {
            return _iceD_ice_id(in, current);
        }
        case 1:
        {
            return _iceD_ice_ids(in, current);
        }
        case 2:
        {
            return _iceD_ice_isA(in, current);
        }
        case 3:
        {
            return _iceD_ice_ping(in, current);
        }
        case 4:
        {
            return _iceD_opABoolS(in, current);
        }
        case 5:
        {
            return _iceD_opAByteS(in, current);
        }
        case 6:
        {
            return _iceD_opACRS(in, current);
        }
        case 7:
        {
            return _iceD_opACVS(in, current);
        }
        case 8:
        {
            return _iceD_opADoubleS(in, current);
        }
        case 9:
        {
            return _iceD_opAEnS(in, current);
        }
        case 10:
        {
            return _iceD_opAFloatS(in, current);
        }
        case 11:
        {
            return _iceD_opAIPrxS(in, current);
        }
        case 12:
        {
            return _iceD_opAIntS(in, current);
        }
        case 13:
        {
            return _iceD_opALongS(in, current);
        }
        case 14:
        {
            return _iceD_opAObjectPrxS(in, current);
        }
        case 15:
        {
            return _iceD_opAObjectS(in, current);
        }
        case 16:
        {
            return _iceD_opAShortS(in, current);
        }
        case 17:
        {
            return _iceD_opAStringS(in, current);
        }
        case 18:
        {
            return _iceD_opAStructS(in, current);
        }
        case 19:
        {
            return _iceD_opAStructSD(in, current);
        }
        case 20:
        {
            return _iceD_opCustomCVS(in, current);
        }
        case 21:
        {
            return _iceD_opCustomCVSS(in, current);
        }
        case 22:
        {
            return _iceD_opCustomIntS(in, current);
        }
        case 23:
        {
            return _iceD_opCustomIntSS(in, current);
        }
        case 24:
        {
            return _iceD_opKBoolS(in, current);
        }
        case 25:
        {
            return _iceD_opKByteS(in, current);
        }
        case 26:
        {
            return _iceD_opKDoubleS(in, current);
        }
        case 27:
        {
            return _iceD_opKEnS(in, current);
        }
        case 28:
        {
            return _iceD_opKFloatS(in, current);
        }
        case 29:
        {
            return _iceD_opKIPrxS(in, current);
        }
        case 30:
        {
            return _iceD_opKIntS(in, current);
        }
        case 31:
        {
            return _iceD_opKLongS(in, current);
        }
        case 32:
        {
            return _iceD_opKObjectPrxS(in, current);
        }
        case 33:
        {
            return _iceD_opKShortS(in, current);
        }
        case 34:
        {
            return _iceD_opKStringS(in, current);
        }
        case 35:
        {
            return _iceD_opKStructS(in, current);
        }
        case 36:
        {
            return _iceD_opKStructSD(in, current);
        }
        case 37:
        {
            return _iceD_opLBoolS(in, current);
        }
        case 38:
        {
            return _iceD_opLByteS(in, current);
        }
        case 39:
        {
            return _iceD_opLCRS(in, current);
        }
        case 40:
        {
            return _iceD_opLCVS(in, current);
        }
        case 41:
        {
            return _iceD_opLDoubleS(in, current);
        }
        case 42:
        {
            return _iceD_opLEnS(in, current);
        }
        case 43:
        {
            return _iceD_opLFloatS(in, current);
        }
        case 44:
        {
            return _iceD_opLIPrxS(in, current);
        }
        case 45:
        {
            return _iceD_opLIntS(in, current);
        }
        case 46:
        {
            return _iceD_opLLongS(in, current);
        }
        case 47:
        {
            return _iceD_opLObjectPrxS(in, current);
        }
        case 48:
        {
            return _iceD_opLObjectS(in, current);
        }
        case 49:
        {
            return _iceD_opLShortS(in, current);
        }
        case 50:
        {
            return _iceD_opLStringS(in, current);
        }
        case 51:
        {
            return _iceD_opLStructS(in, current);
        }
        case 52:
        {
            return _iceD_opLStructSD(in, current);
        }
        case 53:
        {
            return _iceD_opQBoolS(in, current);
        }
        case 54:
        {
            return _iceD_opQByteS(in, current);
        }
        case 55:
        {
            return _iceD_opQDoubleS(in, current);
        }
        case 56:
        {
            return _iceD_opQEnS(in, current);
        }
        case 57:
        {
            return _iceD_opQFloatS(in, current);
        }
        case 58:
        {
            return _iceD_opQIPrxS(in, current);
        }
        case 59:
        {
            return _iceD_opQIntS(in, current);
        }
        case 60:
        {
            return _iceD_opQLongS(in, current);
        }
        case 61:
        {
            return _iceD_opQObjectPrxS(in, current);
        }
        case 62:
        {
            return _iceD_opQShortS(in, current);
        }
        case 63:
        {
            return _iceD_opQStringS(in, current);
        }
        case 64:
        {
            return _iceD_opQStructS(in, current);
        }
        case 65:
        {
            return _iceD_opQStructSD(in, current);
        }
        case 66:
        {
            return _iceD_opSBoolS(in, current);
        }
        case 67:
        {
            return _iceD_opSByteS(in, current);
        }
        case 68:
        {
            return _iceD_opSDoubleS(in, current);
        }
        case 69:
        {
            return _iceD_opSEnS(in, current);
        }
        case 70:
        {
            return _iceD_opSFloatS(in, current);
        }
        case 71:
        {
            return _iceD_opSIPrxS(in, current);
        }
        case 72:
        {
            return _iceD_opSIntS(in, current);
        }
        case 73:
        {
            return _iceD_opSLongS(in, current);
        }
        case 74:
        {
            return _iceD_opSObjectPrxS(in, current);
        }
        case 75:
        {
            return _iceD_opSShortS(in, current);
        }
        case 76:
        {
            return _iceD_opSStringS(in, current);
        }
        case 77:
        {
            return _iceD_opSStructS(in, current);
        }
        case 78:
        {
            return _iceD_opSStructSD(in, current);
        }
        case 79:
        {
            return _iceD_shutdown(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

Test::CV::~CV()
{
}

/// \cond INTERNAL
::Ice::Value* Test::upCast(CV* p) { return p; }

/// \endcond
::Ice::ValuePtr
Test::CV::ice_clone() const
{
    ::Ice::Value* p = new CV(*this);
    return p;
}

std::string
Test::CV::ice_id() const
{
    return ice_staticId();
}

const ::std::string&
Test::CV::ice_staticId()
{
    static const ::std::string typeId = "::Test::CV";
    return typeId;
}

/// \cond STREAM
void
Test::CV::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< CV, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Test::CV::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< CV, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

namespace
{
const ::IceInternal::DefaultValueFactoryInit< ::Test::CV> iceC_Test_CV_init("::Test::CV");
}

::Ice::ValueFactoryPtr
Test::CV::ice_factory()
{
    return ::IceInternal::factoryTable->getValueFactory(::Test::CV::ice_staticId());
}

/// \cond INTERNAL
void
Test::_icePatchValuePtr(CVPtr& handle, const ::Ice::ValuePtr& v)
{
    handle = CVPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(CV::ice_staticId(), v);
    }
}
/// \endcond

Test::CR::~CR()
{
}

/// \cond INTERNAL
::Ice::Value* Test::upCast(CR* p) { return p; }

/// \endcond

#if defined(_MSC_VER)
#   pragma warning(push)
#   pragma warning(disable:4589)
#endif
::Ice::ValuePtr
Test::CR::ice_clone() const
{
    ::Ice::Value* p = new CR(*this);
    return p;
}
#if defined(_MSC_VER)
#   pragma warning(pop)
#endif

std::string
Test::CR::ice_id() const
{
    return ice_staticId();
}

const ::std::string&
Test::CR::ice_staticId()
{
    static const ::std::string typeId = "::Test::CR";
    return typeId;
}

void
Test::CR::_iceGcVisitMembers(::IceInternal::GCVisitor& v_)
{
    if(v)
    {
        if((::Test::upCast(v.get())->_iceGcVisit(v_)))
        {
            v = 0;
        }
    }
}

/// \cond STREAM
void
Test::CR::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< CR, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Test::CR::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< CR, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

namespace
{
const ::IceInternal::DefaultValueFactoryInit< ::Test::CR> iceC_Test_CR_init("::Test::CR");
}

::Ice::ValueFactoryPtr
Test::CR::ice_factory()
{
    return ::IceInternal::factoryTable->getValueFactory(::Test::CR::ice_staticId());
}

/// \cond INTERNAL
void
Test::_icePatchValuePtr(CRPtr& handle, const ::Ice::ValuePtr& v)
{
    handle = CRPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(CR::ice_staticId(), v);
    }
}
/// \endcond

namespace Ice
{
}

#endif
