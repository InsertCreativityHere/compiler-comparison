// Copyright (c) ZeroC, Inc.
//
// Ice version 3.8.0-alpha.0
//
// <auto-generated>
//
// Generated from file 'TestAMD.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>

#define ICE_BUILDING_GENERATED_CODE
#include "TestAMD.h"
#include <Ice/AsyncResponseHandler.h>
#include <Ice/FactoryTable.h>
#include <Ice/OutgoingAsync.h>
#include <algorithm>
#include <array>

#if defined(_MSC_VER)
#   pragma warning(disable : 4458) // declaration of ... hides class member
#   pragma warning(disable : 4996) // ... was declared deprecated
#elif defined(__clang__)
#   pragma clang diagnostic ignored "-Wshadow"
#   pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
#   pragma GCC diagnostic ignored "-Wshadow"
#   pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION  != 30850
#       error Ice version mismatch: an exact match is required for beta generated code
#   endif
#endif

std::ostream&
Test::operator<<(std::ostream& os, En value)
{
    switch (value)
    {
        case En::A:
            return os << "A";
        case En::B:
            return os << "B";
        case En::C:
            return os << "C";
        default:
            return os << static_cast<std::int32_t>(value);
    }
}

namespace
{
    const IceInternal::FactoryTableInit iceC_factoryTableInit;
    const IceInternal::DefaultValueFactoryInit<::Test::CV> iceC_Test_CV_init("::Test::CV");
    const IceInternal::DefaultValueFactoryInit<::Test::CR> iceC_Test_CR_init("::Test::CR");
}

Test::IPrx::~IPrx() = default;

const char*
Test::IPrx::ice_staticId() noexcept
{
    return "::Test::I";
}

void
Test::MyClassPrx::shutdown(const Ice::Context& context) const
{
    IceInternal::makePromiseOutgoing<void>(true, this, &MyClassPrx::_iceI_shutdown, context).get();
}

std::future<void>
Test::MyClassPrx::shutdownAsync(const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<void>(false, this, &MyClassPrx::_iceI_shutdown, context);
}

std::function<void()>
Test::MyClassPrx::shutdownAsync(std::function<void()> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    return IceInternal::makeLambdaOutgoing<void>(std::move(response), std::move(exception), std::move(sent), this, &Test::MyClassPrx::_iceI_shutdown, context);
}

void
Test::MyClassPrx::_iceI_shutdown(const std::shared_ptr<IceInternal::OutgoingAsyncT<void>>& outAsync, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "shutdown";

    outAsync->invoke(operationName, Ice::OperationMode::Normal, std::nullopt, context,
        nullptr,
        nullptr);
}

::Test::AByteS
Test::MyClassPrx::opAByteS(const AByteS& iceP_i, AByteS& iceP_o, const Ice::Context& context) const
{
    auto result = IceInternal::makePromiseOutgoing<std::tuple<AByteS, AByteS>>(true, this, &MyClassPrx::_iceI_opAByteS, iceP_i, context).get();
    iceP_o = std::move(std::get<1>(result));
    return std::move(std::get<0>(result));
}

std::future<std::tuple<::Test::AByteS, ::Test::AByteS>>
Test::MyClassPrx::opAByteSAsync(const AByteS& iceP_i, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<std::tuple<AByteS, AByteS>>(false, this, &MyClassPrx::_iceI_opAByteS, iceP_i, context);
}

std::function<void()>
Test::MyClassPrx::opAByteSAsync(const AByteS& iceP_i, std::function<void(::Test::AByteS, ::Test::AByteS)> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    auto responseCb = [response = std::move(response)](std::tuple<AByteS, AByteS>&& result) mutable
    {
        std::apply(std::move(response), std::move(result));
    };
    return IceInternal::makeLambdaOutgoing<std::tuple<AByteS, AByteS>>(std::move(responseCb), std::move(exception), std::move(sent), this, &Test::MyClassPrx::_iceI_opAByteS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opAByteS(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::tuple<AByteS, AByteS>>>& outAsync, const AByteS& iceP_i, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "opAByteS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, std::nullopt, context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](Ice::InputStream* istr)
        {
            std::tuple<AByteS, AByteS> v;
            istr->readAll(std::get<1>(v), std::get<0>(v));
            return v;
        });
}

::Test::LByteS
Test::MyClassPrx::opLByteS(const LByteS& iceP_i, LByteS& iceP_o, const Ice::Context& context) const
{
    auto result = IceInternal::makePromiseOutgoing<std::tuple<LByteS, LByteS>>(true, this, &MyClassPrx::_iceI_opLByteS, iceP_i, context).get();
    iceP_o = std::move(std::get<1>(result));
    return std::move(std::get<0>(result));
}

std::future<std::tuple<::Test::LByteS, ::Test::LByteS>>
Test::MyClassPrx::opLByteSAsync(const LByteS& iceP_i, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<std::tuple<LByteS, LByteS>>(false, this, &MyClassPrx::_iceI_opLByteS, iceP_i, context);
}

std::function<void()>
Test::MyClassPrx::opLByteSAsync(const LByteS& iceP_i, std::function<void(::Test::LByteS, ::Test::LByteS)> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    auto responseCb = [response = std::move(response)](std::tuple<LByteS, LByteS>&& result) mutable
    {
        std::apply(std::move(response), std::move(result));
    };
    return IceInternal::makeLambdaOutgoing<std::tuple<LByteS, LByteS>>(std::move(responseCb), std::move(exception), std::move(sent), this, &Test::MyClassPrx::_iceI_opLByteS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opLByteS(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::tuple<LByteS, LByteS>>>& outAsync, const LByteS& iceP_i, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "opLByteS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, std::nullopt, context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](Ice::InputStream* istr)
        {
            std::tuple<LByteS, LByteS> v;
            istr->readAll(std::get<1>(v), std::get<0>(v));
            return v;
        });
}

::Test::KByteS
Test::MyClassPrx::opKByteS(const KByteS& iceP_i, KByteS& iceP_o, const Ice::Context& context) const
{
    auto result = IceInternal::makePromiseOutgoing<std::tuple<KByteS, KByteS>>(true, this, &MyClassPrx::_iceI_opKByteS, iceP_i, context).get();
    iceP_o = std::move(std::get<1>(result));
    return std::move(std::get<0>(result));
}

std::future<std::tuple<::Test::KByteS, ::Test::KByteS>>
Test::MyClassPrx::opKByteSAsync(const KByteS& iceP_i, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<std::tuple<KByteS, KByteS>>(false, this, &MyClassPrx::_iceI_opKByteS, iceP_i, context);
}

std::function<void()>
Test::MyClassPrx::opKByteSAsync(const KByteS& iceP_i, std::function<void(::Test::KByteS, ::Test::KByteS)> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    auto responseCb = [response = std::move(response)](std::tuple<KByteS, KByteS>&& result) mutable
    {
        std::apply(std::move(response), std::move(result));
    };
    return IceInternal::makeLambdaOutgoing<std::tuple<KByteS, KByteS>>(std::move(responseCb), std::move(exception), std::move(sent), this, &Test::MyClassPrx::_iceI_opKByteS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opKByteS(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::tuple<KByteS, KByteS>>>& outAsync, const KByteS& iceP_i, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "opKByteS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, std::nullopt, context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](Ice::InputStream* istr)
        {
            std::tuple<KByteS, KByteS> v;
            istr->readAll(std::get<1>(v), std::get<0>(v));
            return v;
        });
}

::Test::QByteS
Test::MyClassPrx::opQByteS(const QByteS& iceP_i, QByteS& iceP_o, const Ice::Context& context) const
{
    auto result = IceInternal::makePromiseOutgoing<std::tuple<QByteS, QByteS>>(true, this, &MyClassPrx::_iceI_opQByteS, iceP_i, context).get();
    iceP_o = std::move(std::get<1>(result));
    return std::move(std::get<0>(result));
}

std::future<std::tuple<::Test::QByteS, ::Test::QByteS>>
Test::MyClassPrx::opQByteSAsync(const QByteS& iceP_i, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<std::tuple<QByteS, QByteS>>(false, this, &MyClassPrx::_iceI_opQByteS, iceP_i, context);
}

std::function<void()>
Test::MyClassPrx::opQByteSAsync(const QByteS& iceP_i, std::function<void(::Test::QByteS, ::Test::QByteS)> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    auto responseCb = [response = std::move(response)](std::tuple<QByteS, QByteS>&& result) mutable
    {
        std::apply(std::move(response), std::move(result));
    };
    return IceInternal::makeLambdaOutgoing<std::tuple<QByteS, QByteS>>(std::move(responseCb), std::move(exception), std::move(sent), this, &Test::MyClassPrx::_iceI_opQByteS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opQByteS(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::tuple<QByteS, QByteS>>>& outAsync, const QByteS& iceP_i, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "opQByteS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, std::nullopt, context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](Ice::InputStream* istr)
        {
            std::tuple<QByteS, QByteS> v;
            istr->readAll(std::get<1>(v), std::get<0>(v));
            return v;
        });
}

::Test::SByteS
Test::MyClassPrx::opSByteS(const SByteS& iceP_i, SByteS& iceP_o, const Ice::Context& context) const
{
    auto result = IceInternal::makePromiseOutgoing<std::tuple<SByteS, SByteS>>(true, this, &MyClassPrx::_iceI_opSByteS, iceP_i, context).get();
    iceP_o = std::move(std::get<1>(result));
    return std::move(std::get<0>(result));
}

std::future<std::tuple<::Test::SByteS, ::Test::SByteS>>
Test::MyClassPrx::opSByteSAsync(const SByteS& iceP_i, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<std::tuple<SByteS, SByteS>>(false, this, &MyClassPrx::_iceI_opSByteS, iceP_i, context);
}

std::function<void()>
Test::MyClassPrx::opSByteSAsync(const SByteS& iceP_i, std::function<void(::Test::SByteS, ::Test::SByteS)> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    auto responseCb = [response = std::move(response)](std::tuple<SByteS, SByteS>&& result) mutable
    {
        std::apply(std::move(response), std::move(result));
    };
    return IceInternal::makeLambdaOutgoing<std::tuple<SByteS, SByteS>>(std::move(responseCb), std::move(exception), std::move(sent), this, &Test::MyClassPrx::_iceI_opSByteS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opSByteS(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::tuple<SByteS, SByteS>>>& outAsync, const SByteS& iceP_i, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "opSByteS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, std::nullopt, context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](Ice::InputStream* istr)
        {
            std::tuple<SByteS, SByteS> v;
            istr->readAll(std::get<1>(v), std::get<0>(v));
            return v;
        });
}

::Test::ABoolS
Test::MyClassPrx::opABoolS(const ABoolS& iceP_i, ABoolS& iceP_o, const Ice::Context& context) const
{
    auto result = IceInternal::makePromiseOutgoing<std::tuple<ABoolS, ABoolS>>(true, this, &MyClassPrx::_iceI_opABoolS, iceP_i, context).get();
    iceP_o = std::move(std::get<1>(result));
    return std::move(std::get<0>(result));
}

std::future<std::tuple<::Test::ABoolS, ::Test::ABoolS>>
Test::MyClassPrx::opABoolSAsync(const ABoolS& iceP_i, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<std::tuple<ABoolS, ABoolS>>(false, this, &MyClassPrx::_iceI_opABoolS, iceP_i, context);
}

std::function<void()>
Test::MyClassPrx::opABoolSAsync(const ABoolS& iceP_i, std::function<void(::Test::ABoolS, ::Test::ABoolS)> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    auto responseCb = [response = std::move(response)](std::tuple<ABoolS, ABoolS>&& result) mutable
    {
        std::apply(std::move(response), std::move(result));
    };
    return IceInternal::makeLambdaOutgoing<std::tuple<ABoolS, ABoolS>>(std::move(responseCb), std::move(exception), std::move(sent), this, &Test::MyClassPrx::_iceI_opABoolS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opABoolS(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::tuple<ABoolS, ABoolS>>>& outAsync, const ABoolS& iceP_i, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "opABoolS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, std::nullopt, context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](Ice::InputStream* istr)
        {
            std::tuple<ABoolS, ABoolS> v;
            istr->readAll(std::get<1>(v), std::get<0>(v));
            return v;
        });
}

::Test::LBoolS
Test::MyClassPrx::opLBoolS(const LBoolS& iceP_i, LBoolS& iceP_o, const Ice::Context& context) const
{
    auto result = IceInternal::makePromiseOutgoing<std::tuple<LBoolS, LBoolS>>(true, this, &MyClassPrx::_iceI_opLBoolS, iceP_i, context).get();
    iceP_o = std::move(std::get<1>(result));
    return std::move(std::get<0>(result));
}

std::future<std::tuple<::Test::LBoolS, ::Test::LBoolS>>
Test::MyClassPrx::opLBoolSAsync(const LBoolS& iceP_i, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<std::tuple<LBoolS, LBoolS>>(false, this, &MyClassPrx::_iceI_opLBoolS, iceP_i, context);
}

std::function<void()>
Test::MyClassPrx::opLBoolSAsync(const LBoolS& iceP_i, std::function<void(::Test::LBoolS, ::Test::LBoolS)> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    auto responseCb = [response = std::move(response)](std::tuple<LBoolS, LBoolS>&& result) mutable
    {
        std::apply(std::move(response), std::move(result));
    };
    return IceInternal::makeLambdaOutgoing<std::tuple<LBoolS, LBoolS>>(std::move(responseCb), std::move(exception), std::move(sent), this, &Test::MyClassPrx::_iceI_opLBoolS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opLBoolS(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::tuple<LBoolS, LBoolS>>>& outAsync, const LBoolS& iceP_i, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "opLBoolS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, std::nullopt, context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](Ice::InputStream* istr)
        {
            std::tuple<LBoolS, LBoolS> v;
            istr->readAll(std::get<1>(v), std::get<0>(v));
            return v;
        });
}

::Test::KBoolS
Test::MyClassPrx::opKBoolS(const KBoolS& iceP_i, KBoolS& iceP_o, const Ice::Context& context) const
{
    auto result = IceInternal::makePromiseOutgoing<std::tuple<KBoolS, KBoolS>>(true, this, &MyClassPrx::_iceI_opKBoolS, iceP_i, context).get();
    iceP_o = std::move(std::get<1>(result));
    return std::move(std::get<0>(result));
}

std::future<std::tuple<::Test::KBoolS, ::Test::KBoolS>>
Test::MyClassPrx::opKBoolSAsync(const KBoolS& iceP_i, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<std::tuple<KBoolS, KBoolS>>(false, this, &MyClassPrx::_iceI_opKBoolS, iceP_i, context);
}

std::function<void()>
Test::MyClassPrx::opKBoolSAsync(const KBoolS& iceP_i, std::function<void(::Test::KBoolS, ::Test::KBoolS)> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    auto responseCb = [response = std::move(response)](std::tuple<KBoolS, KBoolS>&& result) mutable
    {
        std::apply(std::move(response), std::move(result));
    };
    return IceInternal::makeLambdaOutgoing<std::tuple<KBoolS, KBoolS>>(std::move(responseCb), std::move(exception), std::move(sent), this, &Test::MyClassPrx::_iceI_opKBoolS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opKBoolS(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::tuple<KBoolS, KBoolS>>>& outAsync, const KBoolS& iceP_i, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "opKBoolS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, std::nullopt, context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](Ice::InputStream* istr)
        {
            std::tuple<KBoolS, KBoolS> v;
            istr->readAll(std::get<1>(v), std::get<0>(v));
            return v;
        });
}

::Test::QBoolS
Test::MyClassPrx::opQBoolS(const QBoolS& iceP_i, QBoolS& iceP_o, const Ice::Context& context) const
{
    auto result = IceInternal::makePromiseOutgoing<std::tuple<QBoolS, QBoolS>>(true, this, &MyClassPrx::_iceI_opQBoolS, iceP_i, context).get();
    iceP_o = std::move(std::get<1>(result));
    return std::move(std::get<0>(result));
}

std::future<std::tuple<::Test::QBoolS, ::Test::QBoolS>>
Test::MyClassPrx::opQBoolSAsync(const QBoolS& iceP_i, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<std::tuple<QBoolS, QBoolS>>(false, this, &MyClassPrx::_iceI_opQBoolS, iceP_i, context);
}

std::function<void()>
Test::MyClassPrx::opQBoolSAsync(const QBoolS& iceP_i, std::function<void(::Test::QBoolS, ::Test::QBoolS)> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    auto responseCb = [response = std::move(response)](std::tuple<QBoolS, QBoolS>&& result) mutable
    {
        std::apply(std::move(response), std::move(result));
    };
    return IceInternal::makeLambdaOutgoing<std::tuple<QBoolS, QBoolS>>(std::move(responseCb), std::move(exception), std::move(sent), this, &Test::MyClassPrx::_iceI_opQBoolS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opQBoolS(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::tuple<QBoolS, QBoolS>>>& outAsync, const QBoolS& iceP_i, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "opQBoolS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, std::nullopt, context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](Ice::InputStream* istr)
        {
            std::tuple<QBoolS, QBoolS> v;
            istr->readAll(std::get<1>(v), std::get<0>(v));
            return v;
        });
}

::Test::SBoolS
Test::MyClassPrx::opSBoolS(const SBoolS& iceP_i, SBoolS& iceP_o, const Ice::Context& context) const
{
    auto result = IceInternal::makePromiseOutgoing<std::tuple<SBoolS, SBoolS>>(true, this, &MyClassPrx::_iceI_opSBoolS, iceP_i, context).get();
    iceP_o = std::move(std::get<1>(result));
    return std::move(std::get<0>(result));
}

std::future<std::tuple<::Test::SBoolS, ::Test::SBoolS>>
Test::MyClassPrx::opSBoolSAsync(const SBoolS& iceP_i, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<std::tuple<SBoolS, SBoolS>>(false, this, &MyClassPrx::_iceI_opSBoolS, iceP_i, context);
}

std::function<void()>
Test::MyClassPrx::opSBoolSAsync(const SBoolS& iceP_i, std::function<void(::Test::SBoolS, ::Test::SBoolS)> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    auto responseCb = [response = std::move(response)](std::tuple<SBoolS, SBoolS>&& result) mutable
    {
        std::apply(std::move(response), std::move(result));
    };
    return IceInternal::makeLambdaOutgoing<std::tuple<SBoolS, SBoolS>>(std::move(responseCb), std::move(exception), std::move(sent), this, &Test::MyClassPrx::_iceI_opSBoolS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opSBoolS(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::tuple<SBoolS, SBoolS>>>& outAsync, const SBoolS& iceP_i, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "opSBoolS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, std::nullopt, context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](Ice::InputStream* istr)
        {
            std::tuple<SBoolS, SBoolS> v;
            istr->readAll(std::get<1>(v), std::get<0>(v));
            return v;
        });
}

::Test::AShortS
Test::MyClassPrx::opAShortS(const AShortS& iceP_i, AShortS& iceP_o, const Ice::Context& context) const
{
    auto result = IceInternal::makePromiseOutgoing<std::tuple<AShortS, AShortS>>(true, this, &MyClassPrx::_iceI_opAShortS, iceP_i, context).get();
    iceP_o = std::move(std::get<1>(result));
    return std::move(std::get<0>(result));
}

std::future<std::tuple<::Test::AShortS, ::Test::AShortS>>
Test::MyClassPrx::opAShortSAsync(const AShortS& iceP_i, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<std::tuple<AShortS, AShortS>>(false, this, &MyClassPrx::_iceI_opAShortS, iceP_i, context);
}

std::function<void()>
Test::MyClassPrx::opAShortSAsync(const AShortS& iceP_i, std::function<void(::Test::AShortS, ::Test::AShortS)> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    auto responseCb = [response = std::move(response)](std::tuple<AShortS, AShortS>&& result) mutable
    {
        std::apply(std::move(response), std::move(result));
    };
    return IceInternal::makeLambdaOutgoing<std::tuple<AShortS, AShortS>>(std::move(responseCb), std::move(exception), std::move(sent), this, &Test::MyClassPrx::_iceI_opAShortS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opAShortS(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::tuple<AShortS, AShortS>>>& outAsync, const AShortS& iceP_i, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "opAShortS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, std::nullopt, context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](Ice::InputStream* istr)
        {
            std::tuple<AShortS, AShortS> v;
            istr->readAll(std::get<1>(v), std::get<0>(v));
            return v;
        });
}

::Test::LShortS
Test::MyClassPrx::opLShortS(const LShortS& iceP_i, LShortS& iceP_o, const Ice::Context& context) const
{
    auto result = IceInternal::makePromiseOutgoing<std::tuple<LShortS, LShortS>>(true, this, &MyClassPrx::_iceI_opLShortS, iceP_i, context).get();
    iceP_o = std::move(std::get<1>(result));
    return std::move(std::get<0>(result));
}

std::future<std::tuple<::Test::LShortS, ::Test::LShortS>>
Test::MyClassPrx::opLShortSAsync(const LShortS& iceP_i, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<std::tuple<LShortS, LShortS>>(false, this, &MyClassPrx::_iceI_opLShortS, iceP_i, context);
}

std::function<void()>
Test::MyClassPrx::opLShortSAsync(const LShortS& iceP_i, std::function<void(::Test::LShortS, ::Test::LShortS)> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    auto responseCb = [response = std::move(response)](std::tuple<LShortS, LShortS>&& result) mutable
    {
        std::apply(std::move(response), std::move(result));
    };
    return IceInternal::makeLambdaOutgoing<std::tuple<LShortS, LShortS>>(std::move(responseCb), std::move(exception), std::move(sent), this, &Test::MyClassPrx::_iceI_opLShortS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opLShortS(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::tuple<LShortS, LShortS>>>& outAsync, const LShortS& iceP_i, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "opLShortS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, std::nullopt, context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](Ice::InputStream* istr)
        {
            std::tuple<LShortS, LShortS> v;
            istr->readAll(std::get<1>(v), std::get<0>(v));
            return v;
        });
}

::Test::KShortS
Test::MyClassPrx::opKShortS(const KShortS& iceP_i, KShortS& iceP_o, const Ice::Context& context) const
{
    auto result = IceInternal::makePromiseOutgoing<std::tuple<KShortS, KShortS>>(true, this, &MyClassPrx::_iceI_opKShortS, iceP_i, context).get();
    iceP_o = std::move(std::get<1>(result));
    return std::move(std::get<0>(result));
}

std::future<std::tuple<::Test::KShortS, ::Test::KShortS>>
Test::MyClassPrx::opKShortSAsync(const KShortS& iceP_i, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<std::tuple<KShortS, KShortS>>(false, this, &MyClassPrx::_iceI_opKShortS, iceP_i, context);
}

std::function<void()>
Test::MyClassPrx::opKShortSAsync(const KShortS& iceP_i, std::function<void(::Test::KShortS, ::Test::KShortS)> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    auto responseCb = [response = std::move(response)](std::tuple<KShortS, KShortS>&& result) mutable
    {
        std::apply(std::move(response), std::move(result));
    };
    return IceInternal::makeLambdaOutgoing<std::tuple<KShortS, KShortS>>(std::move(responseCb), std::move(exception), std::move(sent), this, &Test::MyClassPrx::_iceI_opKShortS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opKShortS(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::tuple<KShortS, KShortS>>>& outAsync, const KShortS& iceP_i, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "opKShortS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, std::nullopt, context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](Ice::InputStream* istr)
        {
            std::tuple<KShortS, KShortS> v;
            istr->readAll(std::get<1>(v), std::get<0>(v));
            return v;
        });
}

::Test::QShortS
Test::MyClassPrx::opQShortS(const QShortS& iceP_i, QShortS& iceP_o, const Ice::Context& context) const
{
    auto result = IceInternal::makePromiseOutgoing<std::tuple<QShortS, QShortS>>(true, this, &MyClassPrx::_iceI_opQShortS, iceP_i, context).get();
    iceP_o = std::move(std::get<1>(result));
    return std::move(std::get<0>(result));
}

std::future<std::tuple<::Test::QShortS, ::Test::QShortS>>
Test::MyClassPrx::opQShortSAsync(const QShortS& iceP_i, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<std::tuple<QShortS, QShortS>>(false, this, &MyClassPrx::_iceI_opQShortS, iceP_i, context);
}

std::function<void()>
Test::MyClassPrx::opQShortSAsync(const QShortS& iceP_i, std::function<void(::Test::QShortS, ::Test::QShortS)> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    auto responseCb = [response = std::move(response)](std::tuple<QShortS, QShortS>&& result) mutable
    {
        std::apply(std::move(response), std::move(result));
    };
    return IceInternal::makeLambdaOutgoing<std::tuple<QShortS, QShortS>>(std::move(responseCb), std::move(exception), std::move(sent), this, &Test::MyClassPrx::_iceI_opQShortS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opQShortS(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::tuple<QShortS, QShortS>>>& outAsync, const QShortS& iceP_i, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "opQShortS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, std::nullopt, context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](Ice::InputStream* istr)
        {
            std::tuple<QShortS, QShortS> v;
            istr->readAll(std::get<1>(v), std::get<0>(v));
            return v;
        });
}

::Test::SShortS
Test::MyClassPrx::opSShortS(const SShortS& iceP_i, SShortS& iceP_o, const Ice::Context& context) const
{
    auto result = IceInternal::makePromiseOutgoing<std::tuple<SShortS, SShortS>>(true, this, &MyClassPrx::_iceI_opSShortS, iceP_i, context).get();
    iceP_o = std::move(std::get<1>(result));
    return std::move(std::get<0>(result));
}

std::future<std::tuple<::Test::SShortS, ::Test::SShortS>>
Test::MyClassPrx::opSShortSAsync(const SShortS& iceP_i, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<std::tuple<SShortS, SShortS>>(false, this, &MyClassPrx::_iceI_opSShortS, iceP_i, context);
}

std::function<void()>
Test::MyClassPrx::opSShortSAsync(const SShortS& iceP_i, std::function<void(::Test::SShortS, ::Test::SShortS)> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    auto responseCb = [response = std::move(response)](std::tuple<SShortS, SShortS>&& result) mutable
    {
        std::apply(std::move(response), std::move(result));
    };
    return IceInternal::makeLambdaOutgoing<std::tuple<SShortS, SShortS>>(std::move(responseCb), std::move(exception), std::move(sent), this, &Test::MyClassPrx::_iceI_opSShortS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opSShortS(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::tuple<SShortS, SShortS>>>& outAsync, const SShortS& iceP_i, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "opSShortS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, std::nullopt, context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](Ice::InputStream* istr)
        {
            std::tuple<SShortS, SShortS> v;
            istr->readAll(std::get<1>(v), std::get<0>(v));
            return v;
        });
}

::Test::AIntS
Test::MyClassPrx::opAIntS(const AIntS& iceP_i, AIntS& iceP_o, const Ice::Context& context) const
{
    auto result = IceInternal::makePromiseOutgoing<std::tuple<AIntS, AIntS>>(true, this, &MyClassPrx::_iceI_opAIntS, iceP_i, context).get();
    iceP_o = std::move(std::get<1>(result));
    return std::move(std::get<0>(result));
}

std::future<std::tuple<::Test::AIntS, ::Test::AIntS>>
Test::MyClassPrx::opAIntSAsync(const AIntS& iceP_i, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<std::tuple<AIntS, AIntS>>(false, this, &MyClassPrx::_iceI_opAIntS, iceP_i, context);
}

std::function<void()>
Test::MyClassPrx::opAIntSAsync(const AIntS& iceP_i, std::function<void(::Test::AIntS, ::Test::AIntS)> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    auto responseCb = [response = std::move(response)](std::tuple<AIntS, AIntS>&& result) mutable
    {
        std::apply(std::move(response), std::move(result));
    };
    return IceInternal::makeLambdaOutgoing<std::tuple<AIntS, AIntS>>(std::move(responseCb), std::move(exception), std::move(sent), this, &Test::MyClassPrx::_iceI_opAIntS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opAIntS(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::tuple<AIntS, AIntS>>>& outAsync, const AIntS& iceP_i, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "opAIntS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, std::nullopt, context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](Ice::InputStream* istr)
        {
            std::tuple<AIntS, AIntS> v;
            istr->readAll(std::get<1>(v), std::get<0>(v));
            return v;
        });
}

::Test::LIntS
Test::MyClassPrx::opLIntS(const LIntS& iceP_i, LIntS& iceP_o, const Ice::Context& context) const
{
    auto result = IceInternal::makePromiseOutgoing<std::tuple<LIntS, LIntS>>(true, this, &MyClassPrx::_iceI_opLIntS, iceP_i, context).get();
    iceP_o = std::move(std::get<1>(result));
    return std::move(std::get<0>(result));
}

std::future<std::tuple<::Test::LIntS, ::Test::LIntS>>
Test::MyClassPrx::opLIntSAsync(const LIntS& iceP_i, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<std::tuple<LIntS, LIntS>>(false, this, &MyClassPrx::_iceI_opLIntS, iceP_i, context);
}

std::function<void()>
Test::MyClassPrx::opLIntSAsync(const LIntS& iceP_i, std::function<void(::Test::LIntS, ::Test::LIntS)> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    auto responseCb = [response = std::move(response)](std::tuple<LIntS, LIntS>&& result) mutable
    {
        std::apply(std::move(response), std::move(result));
    };
    return IceInternal::makeLambdaOutgoing<std::tuple<LIntS, LIntS>>(std::move(responseCb), std::move(exception), std::move(sent), this, &Test::MyClassPrx::_iceI_opLIntS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opLIntS(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::tuple<LIntS, LIntS>>>& outAsync, const LIntS& iceP_i, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "opLIntS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, std::nullopt, context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](Ice::InputStream* istr)
        {
            std::tuple<LIntS, LIntS> v;
            istr->readAll(std::get<1>(v), std::get<0>(v));
            return v;
        });
}

::Test::KIntS
Test::MyClassPrx::opKIntS(const KIntS& iceP_i, KIntS& iceP_o, const Ice::Context& context) const
{
    auto result = IceInternal::makePromiseOutgoing<std::tuple<KIntS, KIntS>>(true, this, &MyClassPrx::_iceI_opKIntS, iceP_i, context).get();
    iceP_o = std::move(std::get<1>(result));
    return std::move(std::get<0>(result));
}

std::future<std::tuple<::Test::KIntS, ::Test::KIntS>>
Test::MyClassPrx::opKIntSAsync(const KIntS& iceP_i, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<std::tuple<KIntS, KIntS>>(false, this, &MyClassPrx::_iceI_opKIntS, iceP_i, context);
}

std::function<void()>
Test::MyClassPrx::opKIntSAsync(const KIntS& iceP_i, std::function<void(::Test::KIntS, ::Test::KIntS)> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    auto responseCb = [response = std::move(response)](std::tuple<KIntS, KIntS>&& result) mutable
    {
        std::apply(std::move(response), std::move(result));
    };
    return IceInternal::makeLambdaOutgoing<std::tuple<KIntS, KIntS>>(std::move(responseCb), std::move(exception), std::move(sent), this, &Test::MyClassPrx::_iceI_opKIntS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opKIntS(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::tuple<KIntS, KIntS>>>& outAsync, const KIntS& iceP_i, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "opKIntS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, std::nullopt, context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](Ice::InputStream* istr)
        {
            std::tuple<KIntS, KIntS> v;
            istr->readAll(std::get<1>(v), std::get<0>(v));
            return v;
        });
}

::Test::QIntS
Test::MyClassPrx::opQIntS(const QIntS& iceP_i, QIntS& iceP_o, const Ice::Context& context) const
{
    auto result = IceInternal::makePromiseOutgoing<std::tuple<QIntS, QIntS>>(true, this, &MyClassPrx::_iceI_opQIntS, iceP_i, context).get();
    iceP_o = std::move(std::get<1>(result));
    return std::move(std::get<0>(result));
}

std::future<std::tuple<::Test::QIntS, ::Test::QIntS>>
Test::MyClassPrx::opQIntSAsync(const QIntS& iceP_i, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<std::tuple<QIntS, QIntS>>(false, this, &MyClassPrx::_iceI_opQIntS, iceP_i, context);
}

std::function<void()>
Test::MyClassPrx::opQIntSAsync(const QIntS& iceP_i, std::function<void(::Test::QIntS, ::Test::QIntS)> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    auto responseCb = [response = std::move(response)](std::tuple<QIntS, QIntS>&& result) mutable
    {
        std::apply(std::move(response), std::move(result));
    };
    return IceInternal::makeLambdaOutgoing<std::tuple<QIntS, QIntS>>(std::move(responseCb), std::move(exception), std::move(sent), this, &Test::MyClassPrx::_iceI_opQIntS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opQIntS(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::tuple<QIntS, QIntS>>>& outAsync, const QIntS& iceP_i, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "opQIntS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, std::nullopt, context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](Ice::InputStream* istr)
        {
            std::tuple<QIntS, QIntS> v;
            istr->readAll(std::get<1>(v), std::get<0>(v));
            return v;
        });
}

::Test::SIntS
Test::MyClassPrx::opSIntS(const SIntS& iceP_i, SIntS& iceP_o, const Ice::Context& context) const
{
    auto result = IceInternal::makePromiseOutgoing<std::tuple<SIntS, SIntS>>(true, this, &MyClassPrx::_iceI_opSIntS, iceP_i, context).get();
    iceP_o = std::move(std::get<1>(result));
    return std::move(std::get<0>(result));
}

std::future<std::tuple<::Test::SIntS, ::Test::SIntS>>
Test::MyClassPrx::opSIntSAsync(const SIntS& iceP_i, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<std::tuple<SIntS, SIntS>>(false, this, &MyClassPrx::_iceI_opSIntS, iceP_i, context);
}

std::function<void()>
Test::MyClassPrx::opSIntSAsync(const SIntS& iceP_i, std::function<void(::Test::SIntS, ::Test::SIntS)> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    auto responseCb = [response = std::move(response)](std::tuple<SIntS, SIntS>&& result) mutable
    {
        std::apply(std::move(response), std::move(result));
    };
    return IceInternal::makeLambdaOutgoing<std::tuple<SIntS, SIntS>>(std::move(responseCb), std::move(exception), std::move(sent), this, &Test::MyClassPrx::_iceI_opSIntS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opSIntS(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::tuple<SIntS, SIntS>>>& outAsync, const SIntS& iceP_i, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "opSIntS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, std::nullopt, context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](Ice::InputStream* istr)
        {
            std::tuple<SIntS, SIntS> v;
            istr->readAll(std::get<1>(v), std::get<0>(v));
            return v;
        });
}

::Test::ALongS
Test::MyClassPrx::opALongS(const ALongS& iceP_i, ALongS& iceP_o, const Ice::Context& context) const
{
    auto result = IceInternal::makePromiseOutgoing<std::tuple<ALongS, ALongS>>(true, this, &MyClassPrx::_iceI_opALongS, iceP_i, context).get();
    iceP_o = std::move(std::get<1>(result));
    return std::move(std::get<0>(result));
}

std::future<std::tuple<::Test::ALongS, ::Test::ALongS>>
Test::MyClassPrx::opALongSAsync(const ALongS& iceP_i, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<std::tuple<ALongS, ALongS>>(false, this, &MyClassPrx::_iceI_opALongS, iceP_i, context);
}

std::function<void()>
Test::MyClassPrx::opALongSAsync(const ALongS& iceP_i, std::function<void(::Test::ALongS, ::Test::ALongS)> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    auto responseCb = [response = std::move(response)](std::tuple<ALongS, ALongS>&& result) mutable
    {
        std::apply(std::move(response), std::move(result));
    };
    return IceInternal::makeLambdaOutgoing<std::tuple<ALongS, ALongS>>(std::move(responseCb), std::move(exception), std::move(sent), this, &Test::MyClassPrx::_iceI_opALongS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opALongS(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::tuple<ALongS, ALongS>>>& outAsync, const ALongS& iceP_i, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "opALongS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, std::nullopt, context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](Ice::InputStream* istr)
        {
            std::tuple<ALongS, ALongS> v;
            istr->readAll(std::get<1>(v), std::get<0>(v));
            return v;
        });
}

::Test::LLongS
Test::MyClassPrx::opLLongS(const LLongS& iceP_i, LLongS& iceP_o, const Ice::Context& context) const
{
    auto result = IceInternal::makePromiseOutgoing<std::tuple<LLongS, LLongS>>(true, this, &MyClassPrx::_iceI_opLLongS, iceP_i, context).get();
    iceP_o = std::move(std::get<1>(result));
    return std::move(std::get<0>(result));
}

std::future<std::tuple<::Test::LLongS, ::Test::LLongS>>
Test::MyClassPrx::opLLongSAsync(const LLongS& iceP_i, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<std::tuple<LLongS, LLongS>>(false, this, &MyClassPrx::_iceI_opLLongS, iceP_i, context);
}

std::function<void()>
Test::MyClassPrx::opLLongSAsync(const LLongS& iceP_i, std::function<void(::Test::LLongS, ::Test::LLongS)> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    auto responseCb = [response = std::move(response)](std::tuple<LLongS, LLongS>&& result) mutable
    {
        std::apply(std::move(response), std::move(result));
    };
    return IceInternal::makeLambdaOutgoing<std::tuple<LLongS, LLongS>>(std::move(responseCb), std::move(exception), std::move(sent), this, &Test::MyClassPrx::_iceI_opLLongS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opLLongS(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::tuple<LLongS, LLongS>>>& outAsync, const LLongS& iceP_i, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "opLLongS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, std::nullopt, context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](Ice::InputStream* istr)
        {
            std::tuple<LLongS, LLongS> v;
            istr->readAll(std::get<1>(v), std::get<0>(v));
            return v;
        });
}

::Test::KLongS
Test::MyClassPrx::opKLongS(const KLongS& iceP_i, KLongS& iceP_o, const Ice::Context& context) const
{
    auto result = IceInternal::makePromiseOutgoing<std::tuple<KLongS, KLongS>>(true, this, &MyClassPrx::_iceI_opKLongS, iceP_i, context).get();
    iceP_o = std::move(std::get<1>(result));
    return std::move(std::get<0>(result));
}

std::future<std::tuple<::Test::KLongS, ::Test::KLongS>>
Test::MyClassPrx::opKLongSAsync(const KLongS& iceP_i, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<std::tuple<KLongS, KLongS>>(false, this, &MyClassPrx::_iceI_opKLongS, iceP_i, context);
}

std::function<void()>
Test::MyClassPrx::opKLongSAsync(const KLongS& iceP_i, std::function<void(::Test::KLongS, ::Test::KLongS)> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    auto responseCb = [response = std::move(response)](std::tuple<KLongS, KLongS>&& result) mutable
    {
        std::apply(std::move(response), std::move(result));
    };
    return IceInternal::makeLambdaOutgoing<std::tuple<KLongS, KLongS>>(std::move(responseCb), std::move(exception), std::move(sent), this, &Test::MyClassPrx::_iceI_opKLongS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opKLongS(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::tuple<KLongS, KLongS>>>& outAsync, const KLongS& iceP_i, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "opKLongS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, std::nullopt, context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](Ice::InputStream* istr)
        {
            std::tuple<KLongS, KLongS> v;
            istr->readAll(std::get<1>(v), std::get<0>(v));
            return v;
        });
}

::Test::QLongS
Test::MyClassPrx::opQLongS(const QLongS& iceP_i, QLongS& iceP_o, const Ice::Context& context) const
{
    auto result = IceInternal::makePromiseOutgoing<std::tuple<QLongS, QLongS>>(true, this, &MyClassPrx::_iceI_opQLongS, iceP_i, context).get();
    iceP_o = std::move(std::get<1>(result));
    return std::move(std::get<0>(result));
}

std::future<std::tuple<::Test::QLongS, ::Test::QLongS>>
Test::MyClassPrx::opQLongSAsync(const QLongS& iceP_i, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<std::tuple<QLongS, QLongS>>(false, this, &MyClassPrx::_iceI_opQLongS, iceP_i, context);
}

std::function<void()>
Test::MyClassPrx::opQLongSAsync(const QLongS& iceP_i, std::function<void(::Test::QLongS, ::Test::QLongS)> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    auto responseCb = [response = std::move(response)](std::tuple<QLongS, QLongS>&& result) mutable
    {
        std::apply(std::move(response), std::move(result));
    };
    return IceInternal::makeLambdaOutgoing<std::tuple<QLongS, QLongS>>(std::move(responseCb), std::move(exception), std::move(sent), this, &Test::MyClassPrx::_iceI_opQLongS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opQLongS(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::tuple<QLongS, QLongS>>>& outAsync, const QLongS& iceP_i, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "opQLongS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, std::nullopt, context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](Ice::InputStream* istr)
        {
            std::tuple<QLongS, QLongS> v;
            istr->readAll(std::get<1>(v), std::get<0>(v));
            return v;
        });
}

::Test::SLongS
Test::MyClassPrx::opSLongS(const SLongS& iceP_i, SLongS& iceP_o, const Ice::Context& context) const
{
    auto result = IceInternal::makePromiseOutgoing<std::tuple<SLongS, SLongS>>(true, this, &MyClassPrx::_iceI_opSLongS, iceP_i, context).get();
    iceP_o = std::move(std::get<1>(result));
    return std::move(std::get<0>(result));
}

std::future<std::tuple<::Test::SLongS, ::Test::SLongS>>
Test::MyClassPrx::opSLongSAsync(const SLongS& iceP_i, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<std::tuple<SLongS, SLongS>>(false, this, &MyClassPrx::_iceI_opSLongS, iceP_i, context);
}

std::function<void()>
Test::MyClassPrx::opSLongSAsync(const SLongS& iceP_i, std::function<void(::Test::SLongS, ::Test::SLongS)> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    auto responseCb = [response = std::move(response)](std::tuple<SLongS, SLongS>&& result) mutable
    {
        std::apply(std::move(response), std::move(result));
    };
    return IceInternal::makeLambdaOutgoing<std::tuple<SLongS, SLongS>>(std::move(responseCb), std::move(exception), std::move(sent), this, &Test::MyClassPrx::_iceI_opSLongS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opSLongS(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::tuple<SLongS, SLongS>>>& outAsync, const SLongS& iceP_i, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "opSLongS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, std::nullopt, context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](Ice::InputStream* istr)
        {
            std::tuple<SLongS, SLongS> v;
            istr->readAll(std::get<1>(v), std::get<0>(v));
            return v;
        });
}

::Test::AFloatS
Test::MyClassPrx::opAFloatS(const AFloatS& iceP_i, AFloatS& iceP_o, const Ice::Context& context) const
{
    auto result = IceInternal::makePromiseOutgoing<std::tuple<AFloatS, AFloatS>>(true, this, &MyClassPrx::_iceI_opAFloatS, iceP_i, context).get();
    iceP_o = std::move(std::get<1>(result));
    return std::move(std::get<0>(result));
}

std::future<std::tuple<::Test::AFloatS, ::Test::AFloatS>>
Test::MyClassPrx::opAFloatSAsync(const AFloatS& iceP_i, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<std::tuple<AFloatS, AFloatS>>(false, this, &MyClassPrx::_iceI_opAFloatS, iceP_i, context);
}

std::function<void()>
Test::MyClassPrx::opAFloatSAsync(const AFloatS& iceP_i, std::function<void(::Test::AFloatS, ::Test::AFloatS)> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    auto responseCb = [response = std::move(response)](std::tuple<AFloatS, AFloatS>&& result) mutable
    {
        std::apply(std::move(response), std::move(result));
    };
    return IceInternal::makeLambdaOutgoing<std::tuple<AFloatS, AFloatS>>(std::move(responseCb), std::move(exception), std::move(sent), this, &Test::MyClassPrx::_iceI_opAFloatS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opAFloatS(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::tuple<AFloatS, AFloatS>>>& outAsync, const AFloatS& iceP_i, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "opAFloatS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, std::nullopt, context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](Ice::InputStream* istr)
        {
            std::tuple<AFloatS, AFloatS> v;
            istr->readAll(std::get<1>(v), std::get<0>(v));
            return v;
        });
}

::Test::LFloatS
Test::MyClassPrx::opLFloatS(const LFloatS& iceP_i, LFloatS& iceP_o, const Ice::Context& context) const
{
    auto result = IceInternal::makePromiseOutgoing<std::tuple<LFloatS, LFloatS>>(true, this, &MyClassPrx::_iceI_opLFloatS, iceP_i, context).get();
    iceP_o = std::move(std::get<1>(result));
    return std::move(std::get<0>(result));
}

std::future<std::tuple<::Test::LFloatS, ::Test::LFloatS>>
Test::MyClassPrx::opLFloatSAsync(const LFloatS& iceP_i, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<std::tuple<LFloatS, LFloatS>>(false, this, &MyClassPrx::_iceI_opLFloatS, iceP_i, context);
}

std::function<void()>
Test::MyClassPrx::opLFloatSAsync(const LFloatS& iceP_i, std::function<void(::Test::LFloatS, ::Test::LFloatS)> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    auto responseCb = [response = std::move(response)](std::tuple<LFloatS, LFloatS>&& result) mutable
    {
        std::apply(std::move(response), std::move(result));
    };
    return IceInternal::makeLambdaOutgoing<std::tuple<LFloatS, LFloatS>>(std::move(responseCb), std::move(exception), std::move(sent), this, &Test::MyClassPrx::_iceI_opLFloatS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opLFloatS(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::tuple<LFloatS, LFloatS>>>& outAsync, const LFloatS& iceP_i, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "opLFloatS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, std::nullopt, context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](Ice::InputStream* istr)
        {
            std::tuple<LFloatS, LFloatS> v;
            istr->readAll(std::get<1>(v), std::get<0>(v));
            return v;
        });
}

::Test::KFloatS
Test::MyClassPrx::opKFloatS(const KFloatS& iceP_i, KFloatS& iceP_o, const Ice::Context& context) const
{
    auto result = IceInternal::makePromiseOutgoing<std::tuple<KFloatS, KFloatS>>(true, this, &MyClassPrx::_iceI_opKFloatS, iceP_i, context).get();
    iceP_o = std::move(std::get<1>(result));
    return std::move(std::get<0>(result));
}

std::future<std::tuple<::Test::KFloatS, ::Test::KFloatS>>
Test::MyClassPrx::opKFloatSAsync(const KFloatS& iceP_i, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<std::tuple<KFloatS, KFloatS>>(false, this, &MyClassPrx::_iceI_opKFloatS, iceP_i, context);
}

std::function<void()>
Test::MyClassPrx::opKFloatSAsync(const KFloatS& iceP_i, std::function<void(::Test::KFloatS, ::Test::KFloatS)> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    auto responseCb = [response = std::move(response)](std::tuple<KFloatS, KFloatS>&& result) mutable
    {
        std::apply(std::move(response), std::move(result));
    };
    return IceInternal::makeLambdaOutgoing<std::tuple<KFloatS, KFloatS>>(std::move(responseCb), std::move(exception), std::move(sent), this, &Test::MyClassPrx::_iceI_opKFloatS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opKFloatS(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::tuple<KFloatS, KFloatS>>>& outAsync, const KFloatS& iceP_i, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "opKFloatS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, std::nullopt, context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](Ice::InputStream* istr)
        {
            std::tuple<KFloatS, KFloatS> v;
            istr->readAll(std::get<1>(v), std::get<0>(v));
            return v;
        });
}

::Test::QFloatS
Test::MyClassPrx::opQFloatS(const QFloatS& iceP_i, QFloatS& iceP_o, const Ice::Context& context) const
{
    auto result = IceInternal::makePromiseOutgoing<std::tuple<QFloatS, QFloatS>>(true, this, &MyClassPrx::_iceI_opQFloatS, iceP_i, context).get();
    iceP_o = std::move(std::get<1>(result));
    return std::move(std::get<0>(result));
}

std::future<std::tuple<::Test::QFloatS, ::Test::QFloatS>>
Test::MyClassPrx::opQFloatSAsync(const QFloatS& iceP_i, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<std::tuple<QFloatS, QFloatS>>(false, this, &MyClassPrx::_iceI_opQFloatS, iceP_i, context);
}

std::function<void()>
Test::MyClassPrx::opQFloatSAsync(const QFloatS& iceP_i, std::function<void(::Test::QFloatS, ::Test::QFloatS)> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    auto responseCb = [response = std::move(response)](std::tuple<QFloatS, QFloatS>&& result) mutable
    {
        std::apply(std::move(response), std::move(result));
    };
    return IceInternal::makeLambdaOutgoing<std::tuple<QFloatS, QFloatS>>(std::move(responseCb), std::move(exception), std::move(sent), this, &Test::MyClassPrx::_iceI_opQFloatS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opQFloatS(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::tuple<QFloatS, QFloatS>>>& outAsync, const QFloatS& iceP_i, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "opQFloatS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, std::nullopt, context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](Ice::InputStream* istr)
        {
            std::tuple<QFloatS, QFloatS> v;
            istr->readAll(std::get<1>(v), std::get<0>(v));
            return v;
        });
}

::Test::SFloatS
Test::MyClassPrx::opSFloatS(const SFloatS& iceP_i, SFloatS& iceP_o, const Ice::Context& context) const
{
    auto result = IceInternal::makePromiseOutgoing<std::tuple<SFloatS, SFloatS>>(true, this, &MyClassPrx::_iceI_opSFloatS, iceP_i, context).get();
    iceP_o = std::move(std::get<1>(result));
    return std::move(std::get<0>(result));
}

std::future<std::tuple<::Test::SFloatS, ::Test::SFloatS>>
Test::MyClassPrx::opSFloatSAsync(const SFloatS& iceP_i, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<std::tuple<SFloatS, SFloatS>>(false, this, &MyClassPrx::_iceI_opSFloatS, iceP_i, context);
}

std::function<void()>
Test::MyClassPrx::opSFloatSAsync(const SFloatS& iceP_i, std::function<void(::Test::SFloatS, ::Test::SFloatS)> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    auto responseCb = [response = std::move(response)](std::tuple<SFloatS, SFloatS>&& result) mutable
    {
        std::apply(std::move(response), std::move(result));
    };
    return IceInternal::makeLambdaOutgoing<std::tuple<SFloatS, SFloatS>>(std::move(responseCb), std::move(exception), std::move(sent), this, &Test::MyClassPrx::_iceI_opSFloatS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opSFloatS(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::tuple<SFloatS, SFloatS>>>& outAsync, const SFloatS& iceP_i, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "opSFloatS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, std::nullopt, context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](Ice::InputStream* istr)
        {
            std::tuple<SFloatS, SFloatS> v;
            istr->readAll(std::get<1>(v), std::get<0>(v));
            return v;
        });
}

::Test::ADoubleS
Test::MyClassPrx::opADoubleS(const ADoubleS& iceP_i, ADoubleS& iceP_o, const Ice::Context& context) const
{
    auto result = IceInternal::makePromiseOutgoing<std::tuple<ADoubleS, ADoubleS>>(true, this, &MyClassPrx::_iceI_opADoubleS, iceP_i, context).get();
    iceP_o = std::move(std::get<1>(result));
    return std::move(std::get<0>(result));
}

std::future<std::tuple<::Test::ADoubleS, ::Test::ADoubleS>>
Test::MyClassPrx::opADoubleSAsync(const ADoubleS& iceP_i, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<std::tuple<ADoubleS, ADoubleS>>(false, this, &MyClassPrx::_iceI_opADoubleS, iceP_i, context);
}

std::function<void()>
Test::MyClassPrx::opADoubleSAsync(const ADoubleS& iceP_i, std::function<void(::Test::ADoubleS, ::Test::ADoubleS)> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    auto responseCb = [response = std::move(response)](std::tuple<ADoubleS, ADoubleS>&& result) mutable
    {
        std::apply(std::move(response), std::move(result));
    };
    return IceInternal::makeLambdaOutgoing<std::tuple<ADoubleS, ADoubleS>>(std::move(responseCb), std::move(exception), std::move(sent), this, &Test::MyClassPrx::_iceI_opADoubleS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opADoubleS(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::tuple<ADoubleS, ADoubleS>>>& outAsync, const ADoubleS& iceP_i, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "opADoubleS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, std::nullopt, context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](Ice::InputStream* istr)
        {
            std::tuple<ADoubleS, ADoubleS> v;
            istr->readAll(std::get<1>(v), std::get<0>(v));
            return v;
        });
}

::Test::LDoubleS
Test::MyClassPrx::opLDoubleS(const LDoubleS& iceP_i, LDoubleS& iceP_o, const Ice::Context& context) const
{
    auto result = IceInternal::makePromiseOutgoing<std::tuple<LDoubleS, LDoubleS>>(true, this, &MyClassPrx::_iceI_opLDoubleS, iceP_i, context).get();
    iceP_o = std::move(std::get<1>(result));
    return std::move(std::get<0>(result));
}

std::future<std::tuple<::Test::LDoubleS, ::Test::LDoubleS>>
Test::MyClassPrx::opLDoubleSAsync(const LDoubleS& iceP_i, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<std::tuple<LDoubleS, LDoubleS>>(false, this, &MyClassPrx::_iceI_opLDoubleS, iceP_i, context);
}

std::function<void()>
Test::MyClassPrx::opLDoubleSAsync(const LDoubleS& iceP_i, std::function<void(::Test::LDoubleS, ::Test::LDoubleS)> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    auto responseCb = [response = std::move(response)](std::tuple<LDoubleS, LDoubleS>&& result) mutable
    {
        std::apply(std::move(response), std::move(result));
    };
    return IceInternal::makeLambdaOutgoing<std::tuple<LDoubleS, LDoubleS>>(std::move(responseCb), std::move(exception), std::move(sent), this, &Test::MyClassPrx::_iceI_opLDoubleS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opLDoubleS(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::tuple<LDoubleS, LDoubleS>>>& outAsync, const LDoubleS& iceP_i, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "opLDoubleS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, std::nullopt, context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](Ice::InputStream* istr)
        {
            std::tuple<LDoubleS, LDoubleS> v;
            istr->readAll(std::get<1>(v), std::get<0>(v));
            return v;
        });
}

::Test::KDoubleS
Test::MyClassPrx::opKDoubleS(const KDoubleS& iceP_i, KDoubleS& iceP_o, const Ice::Context& context) const
{
    auto result = IceInternal::makePromiseOutgoing<std::tuple<KDoubleS, KDoubleS>>(true, this, &MyClassPrx::_iceI_opKDoubleS, iceP_i, context).get();
    iceP_o = std::move(std::get<1>(result));
    return std::move(std::get<0>(result));
}

std::future<std::tuple<::Test::KDoubleS, ::Test::KDoubleS>>
Test::MyClassPrx::opKDoubleSAsync(const KDoubleS& iceP_i, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<std::tuple<KDoubleS, KDoubleS>>(false, this, &MyClassPrx::_iceI_opKDoubleS, iceP_i, context);
}

std::function<void()>
Test::MyClassPrx::opKDoubleSAsync(const KDoubleS& iceP_i, std::function<void(::Test::KDoubleS, ::Test::KDoubleS)> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    auto responseCb = [response = std::move(response)](std::tuple<KDoubleS, KDoubleS>&& result) mutable
    {
        std::apply(std::move(response), std::move(result));
    };
    return IceInternal::makeLambdaOutgoing<std::tuple<KDoubleS, KDoubleS>>(std::move(responseCb), std::move(exception), std::move(sent), this, &Test::MyClassPrx::_iceI_opKDoubleS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opKDoubleS(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::tuple<KDoubleS, KDoubleS>>>& outAsync, const KDoubleS& iceP_i, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "opKDoubleS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, std::nullopt, context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](Ice::InputStream* istr)
        {
            std::tuple<KDoubleS, KDoubleS> v;
            istr->readAll(std::get<1>(v), std::get<0>(v));
            return v;
        });
}

::Test::QDoubleS
Test::MyClassPrx::opQDoubleS(const QDoubleS& iceP_i, QDoubleS& iceP_o, const Ice::Context& context) const
{
    auto result = IceInternal::makePromiseOutgoing<std::tuple<QDoubleS, QDoubleS>>(true, this, &MyClassPrx::_iceI_opQDoubleS, iceP_i, context).get();
    iceP_o = std::move(std::get<1>(result));
    return std::move(std::get<0>(result));
}

std::future<std::tuple<::Test::QDoubleS, ::Test::QDoubleS>>
Test::MyClassPrx::opQDoubleSAsync(const QDoubleS& iceP_i, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<std::tuple<QDoubleS, QDoubleS>>(false, this, &MyClassPrx::_iceI_opQDoubleS, iceP_i, context);
}

std::function<void()>
Test::MyClassPrx::opQDoubleSAsync(const QDoubleS& iceP_i, std::function<void(::Test::QDoubleS, ::Test::QDoubleS)> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    auto responseCb = [response = std::move(response)](std::tuple<QDoubleS, QDoubleS>&& result) mutable
    {
        std::apply(std::move(response), std::move(result));
    };
    return IceInternal::makeLambdaOutgoing<std::tuple<QDoubleS, QDoubleS>>(std::move(responseCb), std::move(exception), std::move(sent), this, &Test::MyClassPrx::_iceI_opQDoubleS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opQDoubleS(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::tuple<QDoubleS, QDoubleS>>>& outAsync, const QDoubleS& iceP_i, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "opQDoubleS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, std::nullopt, context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](Ice::InputStream* istr)
        {
            std::tuple<QDoubleS, QDoubleS> v;
            istr->readAll(std::get<1>(v), std::get<0>(v));
            return v;
        });
}

::Test::SDoubleS
Test::MyClassPrx::opSDoubleS(const SDoubleS& iceP_i, SDoubleS& iceP_o, const Ice::Context& context) const
{
    auto result = IceInternal::makePromiseOutgoing<std::tuple<SDoubleS, SDoubleS>>(true, this, &MyClassPrx::_iceI_opSDoubleS, iceP_i, context).get();
    iceP_o = std::move(std::get<1>(result));
    return std::move(std::get<0>(result));
}

std::future<std::tuple<::Test::SDoubleS, ::Test::SDoubleS>>
Test::MyClassPrx::opSDoubleSAsync(const SDoubleS& iceP_i, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<std::tuple<SDoubleS, SDoubleS>>(false, this, &MyClassPrx::_iceI_opSDoubleS, iceP_i, context);
}

std::function<void()>
Test::MyClassPrx::opSDoubleSAsync(const SDoubleS& iceP_i, std::function<void(::Test::SDoubleS, ::Test::SDoubleS)> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    auto responseCb = [response = std::move(response)](std::tuple<SDoubleS, SDoubleS>&& result) mutable
    {
        std::apply(std::move(response), std::move(result));
    };
    return IceInternal::makeLambdaOutgoing<std::tuple<SDoubleS, SDoubleS>>(std::move(responseCb), std::move(exception), std::move(sent), this, &Test::MyClassPrx::_iceI_opSDoubleS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opSDoubleS(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::tuple<SDoubleS, SDoubleS>>>& outAsync, const SDoubleS& iceP_i, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "opSDoubleS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, std::nullopt, context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](Ice::InputStream* istr)
        {
            std::tuple<SDoubleS, SDoubleS> v;
            istr->readAll(std::get<1>(v), std::get<0>(v));
            return v;
        });
}

::Test::AStringS
Test::MyClassPrx::opAStringS(const AStringS& iceP_i, AStringS& iceP_o, const Ice::Context& context) const
{
    auto result = IceInternal::makePromiseOutgoing<std::tuple<AStringS, AStringS>>(true, this, &MyClassPrx::_iceI_opAStringS, iceP_i, context).get();
    iceP_o = std::move(std::get<1>(result));
    return std::move(std::get<0>(result));
}

std::future<std::tuple<::Test::AStringS, ::Test::AStringS>>
Test::MyClassPrx::opAStringSAsync(const AStringS& iceP_i, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<std::tuple<AStringS, AStringS>>(false, this, &MyClassPrx::_iceI_opAStringS, iceP_i, context);
}

std::function<void()>
Test::MyClassPrx::opAStringSAsync(const AStringS& iceP_i, std::function<void(::Test::AStringS, ::Test::AStringS)> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    auto responseCb = [response = std::move(response)](std::tuple<AStringS, AStringS>&& result) mutable
    {
        std::apply(std::move(response), std::move(result));
    };
    return IceInternal::makeLambdaOutgoing<std::tuple<AStringS, AStringS>>(std::move(responseCb), std::move(exception), std::move(sent), this, &Test::MyClassPrx::_iceI_opAStringS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opAStringS(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::tuple<AStringS, AStringS>>>& outAsync, const AStringS& iceP_i, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "opAStringS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, std::nullopt, context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](Ice::InputStream* istr)
        {
            std::tuple<AStringS, AStringS> v;
            istr->readAll(std::get<1>(v), std::get<0>(v));
            return v;
        });
}

::Test::LStringS
Test::MyClassPrx::opLStringS(const LStringS& iceP_i, LStringS& iceP_o, const Ice::Context& context) const
{
    auto result = IceInternal::makePromiseOutgoing<std::tuple<LStringS, LStringS>>(true, this, &MyClassPrx::_iceI_opLStringS, iceP_i, context).get();
    iceP_o = std::move(std::get<1>(result));
    return std::move(std::get<0>(result));
}

std::future<std::tuple<::Test::LStringS, ::Test::LStringS>>
Test::MyClassPrx::opLStringSAsync(const LStringS& iceP_i, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<std::tuple<LStringS, LStringS>>(false, this, &MyClassPrx::_iceI_opLStringS, iceP_i, context);
}

std::function<void()>
Test::MyClassPrx::opLStringSAsync(const LStringS& iceP_i, std::function<void(::Test::LStringS, ::Test::LStringS)> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    auto responseCb = [response = std::move(response)](std::tuple<LStringS, LStringS>&& result) mutable
    {
        std::apply(std::move(response), std::move(result));
    };
    return IceInternal::makeLambdaOutgoing<std::tuple<LStringS, LStringS>>(std::move(responseCb), std::move(exception), std::move(sent), this, &Test::MyClassPrx::_iceI_opLStringS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opLStringS(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::tuple<LStringS, LStringS>>>& outAsync, const LStringS& iceP_i, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "opLStringS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, std::nullopt, context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](Ice::InputStream* istr)
        {
            std::tuple<LStringS, LStringS> v;
            istr->readAll(std::get<1>(v), std::get<0>(v));
            return v;
        });
}

::Test::KStringS
Test::MyClassPrx::opKStringS(const KStringS& iceP_i, KStringS& iceP_o, const Ice::Context& context) const
{
    auto result = IceInternal::makePromiseOutgoing<std::tuple<KStringS, KStringS>>(true, this, &MyClassPrx::_iceI_opKStringS, iceP_i, context).get();
    iceP_o = std::move(std::get<1>(result));
    return std::move(std::get<0>(result));
}

std::future<std::tuple<::Test::KStringS, ::Test::KStringS>>
Test::MyClassPrx::opKStringSAsync(const KStringS& iceP_i, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<std::tuple<KStringS, KStringS>>(false, this, &MyClassPrx::_iceI_opKStringS, iceP_i, context);
}

std::function<void()>
Test::MyClassPrx::opKStringSAsync(const KStringS& iceP_i, std::function<void(::Test::KStringS, ::Test::KStringS)> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    auto responseCb = [response = std::move(response)](std::tuple<KStringS, KStringS>&& result) mutable
    {
        std::apply(std::move(response), std::move(result));
    };
    return IceInternal::makeLambdaOutgoing<std::tuple<KStringS, KStringS>>(std::move(responseCb), std::move(exception), std::move(sent), this, &Test::MyClassPrx::_iceI_opKStringS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opKStringS(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::tuple<KStringS, KStringS>>>& outAsync, const KStringS& iceP_i, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "opKStringS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, std::nullopt, context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](Ice::InputStream* istr)
        {
            std::tuple<KStringS, KStringS> v;
            istr->readAll(std::get<1>(v), std::get<0>(v));
            return v;
        });
}

::Test::QStringS
Test::MyClassPrx::opQStringS(const QStringS& iceP_i, QStringS& iceP_o, const Ice::Context& context) const
{
    auto result = IceInternal::makePromiseOutgoing<std::tuple<QStringS, QStringS>>(true, this, &MyClassPrx::_iceI_opQStringS, iceP_i, context).get();
    iceP_o = std::move(std::get<1>(result));
    return std::move(std::get<0>(result));
}

std::future<std::tuple<::Test::QStringS, ::Test::QStringS>>
Test::MyClassPrx::opQStringSAsync(const QStringS& iceP_i, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<std::tuple<QStringS, QStringS>>(false, this, &MyClassPrx::_iceI_opQStringS, iceP_i, context);
}

std::function<void()>
Test::MyClassPrx::opQStringSAsync(const QStringS& iceP_i, std::function<void(::Test::QStringS, ::Test::QStringS)> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    auto responseCb = [response = std::move(response)](std::tuple<QStringS, QStringS>&& result) mutable
    {
        std::apply(std::move(response), std::move(result));
    };
    return IceInternal::makeLambdaOutgoing<std::tuple<QStringS, QStringS>>(std::move(responseCb), std::move(exception), std::move(sent), this, &Test::MyClassPrx::_iceI_opQStringS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opQStringS(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::tuple<QStringS, QStringS>>>& outAsync, const QStringS& iceP_i, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "opQStringS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, std::nullopt, context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](Ice::InputStream* istr)
        {
            std::tuple<QStringS, QStringS> v;
            istr->readAll(std::get<1>(v), std::get<0>(v));
            return v;
        });
}

::Test::SStringS
Test::MyClassPrx::opSStringS(const SStringS& iceP_i, SStringS& iceP_o, const Ice::Context& context) const
{
    auto result = IceInternal::makePromiseOutgoing<std::tuple<SStringS, SStringS>>(true, this, &MyClassPrx::_iceI_opSStringS, iceP_i, context).get();
    iceP_o = std::move(std::get<1>(result));
    return std::move(std::get<0>(result));
}

std::future<std::tuple<::Test::SStringS, ::Test::SStringS>>
Test::MyClassPrx::opSStringSAsync(const SStringS& iceP_i, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<std::tuple<SStringS, SStringS>>(false, this, &MyClassPrx::_iceI_opSStringS, iceP_i, context);
}

std::function<void()>
Test::MyClassPrx::opSStringSAsync(const SStringS& iceP_i, std::function<void(::Test::SStringS, ::Test::SStringS)> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    auto responseCb = [response = std::move(response)](std::tuple<SStringS, SStringS>&& result) mutable
    {
        std::apply(std::move(response), std::move(result));
    };
    return IceInternal::makeLambdaOutgoing<std::tuple<SStringS, SStringS>>(std::move(responseCb), std::move(exception), std::move(sent), this, &Test::MyClassPrx::_iceI_opSStringS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opSStringS(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::tuple<SStringS, SStringS>>>& outAsync, const SStringS& iceP_i, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "opSStringS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, std::nullopt, context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](Ice::InputStream* istr)
        {
            std::tuple<SStringS, SStringS> v;
            istr->readAll(std::get<1>(v), std::get<0>(v));
            return v;
        });
}

::Test::AObjectS
Test::MyClassPrx::opAObjectS(const AObjectS& iceP_i, AObjectS& iceP_o, const Ice::Context& context) const
{
    auto result = IceInternal::makePromiseOutgoing<std::tuple<AObjectS, AObjectS>>(true, this, &MyClassPrx::_iceI_opAObjectS, iceP_i, context).get();
    iceP_o = std::move(std::get<1>(result));
    return std::move(std::get<0>(result));
}

std::future<std::tuple<::Test::AObjectS, ::Test::AObjectS>>
Test::MyClassPrx::opAObjectSAsync(const AObjectS& iceP_i, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<std::tuple<AObjectS, AObjectS>>(false, this, &MyClassPrx::_iceI_opAObjectS, iceP_i, context);
}

std::function<void()>
Test::MyClassPrx::opAObjectSAsync(const AObjectS& iceP_i, std::function<void(::Test::AObjectS, ::Test::AObjectS)> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    auto responseCb = [response = std::move(response)](std::tuple<AObjectS, AObjectS>&& result) mutable
    {
        std::apply(std::move(response), std::move(result));
    };
    return IceInternal::makeLambdaOutgoing<std::tuple<AObjectS, AObjectS>>(std::move(responseCb), std::move(exception), std::move(sent), this, &Test::MyClassPrx::_iceI_opAObjectS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opAObjectS(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::tuple<AObjectS, AObjectS>>>& outAsync, const AObjectS& iceP_i, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "opAObjectS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, std::nullopt, context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
            ostr->writePendingValues();
        },
        nullptr,
        [](Ice::InputStream* istr)
        {
            std::tuple<AObjectS, AObjectS> v;
            istr->readAll(std::get<1>(v), std::get<0>(v));
            istr->readPendingValues();
            return v;
        });
}

::Test::LObjectS
Test::MyClassPrx::opLObjectS(const LObjectS& iceP_i, LObjectS& iceP_o, const Ice::Context& context) const
{
    auto result = IceInternal::makePromiseOutgoing<std::tuple<LObjectS, LObjectS>>(true, this, &MyClassPrx::_iceI_opLObjectS, iceP_i, context).get();
    iceP_o = std::move(std::get<1>(result));
    return std::move(std::get<0>(result));
}

std::future<std::tuple<::Test::LObjectS, ::Test::LObjectS>>
Test::MyClassPrx::opLObjectSAsync(const LObjectS& iceP_i, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<std::tuple<LObjectS, LObjectS>>(false, this, &MyClassPrx::_iceI_opLObjectS, iceP_i, context);
}

std::function<void()>
Test::MyClassPrx::opLObjectSAsync(const LObjectS& iceP_i, std::function<void(::Test::LObjectS, ::Test::LObjectS)> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    auto responseCb = [response = std::move(response)](std::tuple<LObjectS, LObjectS>&& result) mutable
    {
        std::apply(std::move(response), std::move(result));
    };
    return IceInternal::makeLambdaOutgoing<std::tuple<LObjectS, LObjectS>>(std::move(responseCb), std::move(exception), std::move(sent), this, &Test::MyClassPrx::_iceI_opLObjectS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opLObjectS(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::tuple<LObjectS, LObjectS>>>& outAsync, const LObjectS& iceP_i, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "opLObjectS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, std::nullopt, context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
            ostr->writePendingValues();
        },
        nullptr,
        [](Ice::InputStream* istr)
        {
            std::tuple<LObjectS, LObjectS> v;
            istr->readAll(std::get<1>(v), std::get<0>(v));
            istr->readPendingValues();
            return v;
        });
}

::Test::AObjectPrxS
Test::MyClassPrx::opAObjectPrxS(const AObjectPrxS& iceP_i, AObjectPrxS& iceP_o, const Ice::Context& context) const
{
    auto result = IceInternal::makePromiseOutgoing<std::tuple<AObjectPrxS, AObjectPrxS>>(true, this, &MyClassPrx::_iceI_opAObjectPrxS, iceP_i, context).get();
    iceP_o = std::move(std::get<1>(result));
    return std::move(std::get<0>(result));
}

std::future<std::tuple<::Test::AObjectPrxS, ::Test::AObjectPrxS>>
Test::MyClassPrx::opAObjectPrxSAsync(const AObjectPrxS& iceP_i, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<std::tuple<AObjectPrxS, AObjectPrxS>>(false, this, &MyClassPrx::_iceI_opAObjectPrxS, iceP_i, context);
}

std::function<void()>
Test::MyClassPrx::opAObjectPrxSAsync(const AObjectPrxS& iceP_i, std::function<void(::Test::AObjectPrxS, ::Test::AObjectPrxS)> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    auto responseCb = [response = std::move(response)](std::tuple<AObjectPrxS, AObjectPrxS>&& result) mutable
    {
        std::apply(std::move(response), std::move(result));
    };
    return IceInternal::makeLambdaOutgoing<std::tuple<AObjectPrxS, AObjectPrxS>>(std::move(responseCb), std::move(exception), std::move(sent), this, &Test::MyClassPrx::_iceI_opAObjectPrxS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opAObjectPrxS(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::tuple<AObjectPrxS, AObjectPrxS>>>& outAsync, const AObjectPrxS& iceP_i, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "opAObjectPrxS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, std::nullopt, context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](Ice::InputStream* istr)
        {
            std::tuple<AObjectPrxS, AObjectPrxS> v;
            istr->readAll(std::get<1>(v), std::get<0>(v));
            return v;
        });
}

::Test::LObjectPrxS
Test::MyClassPrx::opLObjectPrxS(const LObjectPrxS& iceP_i, LObjectPrxS& iceP_o, const Ice::Context& context) const
{
    auto result = IceInternal::makePromiseOutgoing<std::tuple<LObjectPrxS, LObjectPrxS>>(true, this, &MyClassPrx::_iceI_opLObjectPrxS, iceP_i, context).get();
    iceP_o = std::move(std::get<1>(result));
    return std::move(std::get<0>(result));
}

std::future<std::tuple<::Test::LObjectPrxS, ::Test::LObjectPrxS>>
Test::MyClassPrx::opLObjectPrxSAsync(const LObjectPrxS& iceP_i, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<std::tuple<LObjectPrxS, LObjectPrxS>>(false, this, &MyClassPrx::_iceI_opLObjectPrxS, iceP_i, context);
}

std::function<void()>
Test::MyClassPrx::opLObjectPrxSAsync(const LObjectPrxS& iceP_i, std::function<void(::Test::LObjectPrxS, ::Test::LObjectPrxS)> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    auto responseCb = [response = std::move(response)](std::tuple<LObjectPrxS, LObjectPrxS>&& result) mutable
    {
        std::apply(std::move(response), std::move(result));
    };
    return IceInternal::makeLambdaOutgoing<std::tuple<LObjectPrxS, LObjectPrxS>>(std::move(responseCb), std::move(exception), std::move(sent), this, &Test::MyClassPrx::_iceI_opLObjectPrxS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opLObjectPrxS(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::tuple<LObjectPrxS, LObjectPrxS>>>& outAsync, const LObjectPrxS& iceP_i, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "opLObjectPrxS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, std::nullopt, context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](Ice::InputStream* istr)
        {
            std::tuple<LObjectPrxS, LObjectPrxS> v;
            istr->readAll(std::get<1>(v), std::get<0>(v));
            return v;
        });
}

::Test::KObjectPrxS
Test::MyClassPrx::opKObjectPrxS(const KObjectPrxS& iceP_i, KObjectPrxS& iceP_o, const Ice::Context& context) const
{
    auto result = IceInternal::makePromiseOutgoing<std::tuple<KObjectPrxS, KObjectPrxS>>(true, this, &MyClassPrx::_iceI_opKObjectPrxS, iceP_i, context).get();
    iceP_o = std::move(std::get<1>(result));
    return std::move(std::get<0>(result));
}

std::future<std::tuple<::Test::KObjectPrxS, ::Test::KObjectPrxS>>
Test::MyClassPrx::opKObjectPrxSAsync(const KObjectPrxS& iceP_i, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<std::tuple<KObjectPrxS, KObjectPrxS>>(false, this, &MyClassPrx::_iceI_opKObjectPrxS, iceP_i, context);
}

std::function<void()>
Test::MyClassPrx::opKObjectPrxSAsync(const KObjectPrxS& iceP_i, std::function<void(::Test::KObjectPrxS, ::Test::KObjectPrxS)> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    auto responseCb = [response = std::move(response)](std::tuple<KObjectPrxS, KObjectPrxS>&& result) mutable
    {
        std::apply(std::move(response), std::move(result));
    };
    return IceInternal::makeLambdaOutgoing<std::tuple<KObjectPrxS, KObjectPrxS>>(std::move(responseCb), std::move(exception), std::move(sent), this, &Test::MyClassPrx::_iceI_opKObjectPrxS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opKObjectPrxS(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::tuple<KObjectPrxS, KObjectPrxS>>>& outAsync, const KObjectPrxS& iceP_i, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "opKObjectPrxS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, std::nullopt, context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](Ice::InputStream* istr)
        {
            std::tuple<KObjectPrxS, KObjectPrxS> v;
            istr->readAll(std::get<1>(v), std::get<0>(v));
            return v;
        });
}

::Test::QObjectPrxS
Test::MyClassPrx::opQObjectPrxS(const QObjectPrxS& iceP_i, QObjectPrxS& iceP_o, const Ice::Context& context) const
{
    auto result = IceInternal::makePromiseOutgoing<std::tuple<QObjectPrxS, QObjectPrxS>>(true, this, &MyClassPrx::_iceI_opQObjectPrxS, iceP_i, context).get();
    iceP_o = std::move(std::get<1>(result));
    return std::move(std::get<0>(result));
}

std::future<std::tuple<::Test::QObjectPrxS, ::Test::QObjectPrxS>>
Test::MyClassPrx::opQObjectPrxSAsync(const QObjectPrxS& iceP_i, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<std::tuple<QObjectPrxS, QObjectPrxS>>(false, this, &MyClassPrx::_iceI_opQObjectPrxS, iceP_i, context);
}

std::function<void()>
Test::MyClassPrx::opQObjectPrxSAsync(const QObjectPrxS& iceP_i, std::function<void(::Test::QObjectPrxS, ::Test::QObjectPrxS)> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    auto responseCb = [response = std::move(response)](std::tuple<QObjectPrxS, QObjectPrxS>&& result) mutable
    {
        std::apply(std::move(response), std::move(result));
    };
    return IceInternal::makeLambdaOutgoing<std::tuple<QObjectPrxS, QObjectPrxS>>(std::move(responseCb), std::move(exception), std::move(sent), this, &Test::MyClassPrx::_iceI_opQObjectPrxS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opQObjectPrxS(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::tuple<QObjectPrxS, QObjectPrxS>>>& outAsync, const QObjectPrxS& iceP_i, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "opQObjectPrxS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, std::nullopt, context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](Ice::InputStream* istr)
        {
            std::tuple<QObjectPrxS, QObjectPrxS> v;
            istr->readAll(std::get<1>(v), std::get<0>(v));
            return v;
        });
}

::Test::SObjectPrxS
Test::MyClassPrx::opSObjectPrxS(const SObjectPrxS& iceP_i, SObjectPrxS& iceP_o, const Ice::Context& context) const
{
    auto result = IceInternal::makePromiseOutgoing<std::tuple<SObjectPrxS, SObjectPrxS>>(true, this, &MyClassPrx::_iceI_opSObjectPrxS, iceP_i, context).get();
    iceP_o = std::move(std::get<1>(result));
    return std::move(std::get<0>(result));
}

std::future<std::tuple<::Test::SObjectPrxS, ::Test::SObjectPrxS>>
Test::MyClassPrx::opSObjectPrxSAsync(const SObjectPrxS& iceP_i, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<std::tuple<SObjectPrxS, SObjectPrxS>>(false, this, &MyClassPrx::_iceI_opSObjectPrxS, iceP_i, context);
}

std::function<void()>
Test::MyClassPrx::opSObjectPrxSAsync(const SObjectPrxS& iceP_i, std::function<void(::Test::SObjectPrxS, ::Test::SObjectPrxS)> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    auto responseCb = [response = std::move(response)](std::tuple<SObjectPrxS, SObjectPrxS>&& result) mutable
    {
        std::apply(std::move(response), std::move(result));
    };
    return IceInternal::makeLambdaOutgoing<std::tuple<SObjectPrxS, SObjectPrxS>>(std::move(responseCb), std::move(exception), std::move(sent), this, &Test::MyClassPrx::_iceI_opSObjectPrxS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opSObjectPrxS(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::tuple<SObjectPrxS, SObjectPrxS>>>& outAsync, const SObjectPrxS& iceP_i, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "opSObjectPrxS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, std::nullopt, context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](Ice::InputStream* istr)
        {
            std::tuple<SObjectPrxS, SObjectPrxS> v;
            istr->readAll(std::get<1>(v), std::get<0>(v));
            return v;
        });
}

::Test::AStructS
Test::MyClassPrx::opAStructS(const AStructS& iceP_i, AStructS& iceP_o, const Ice::Context& context) const
{
    auto result = IceInternal::makePromiseOutgoing<std::tuple<AStructS, AStructS>>(true, this, &MyClassPrx::_iceI_opAStructS, iceP_i, context).get();
    iceP_o = std::move(std::get<1>(result));
    return std::move(std::get<0>(result));
}

std::future<std::tuple<::Test::AStructS, ::Test::AStructS>>
Test::MyClassPrx::opAStructSAsync(const AStructS& iceP_i, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<std::tuple<AStructS, AStructS>>(false, this, &MyClassPrx::_iceI_opAStructS, iceP_i, context);
}

std::function<void()>
Test::MyClassPrx::opAStructSAsync(const AStructS& iceP_i, std::function<void(::Test::AStructS, ::Test::AStructS)> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    auto responseCb = [response = std::move(response)](std::tuple<AStructS, AStructS>&& result) mutable
    {
        std::apply(std::move(response), std::move(result));
    };
    return IceInternal::makeLambdaOutgoing<std::tuple<AStructS, AStructS>>(std::move(responseCb), std::move(exception), std::move(sent), this, &Test::MyClassPrx::_iceI_opAStructS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opAStructS(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::tuple<AStructS, AStructS>>>& outAsync, const AStructS& iceP_i, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "opAStructS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, std::nullopt, context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](Ice::InputStream* istr)
        {
            std::tuple<AStructS, AStructS> v;
            istr->readAll(std::get<1>(v), std::get<0>(v));
            return v;
        });
}

::Test::LStructS
Test::MyClassPrx::opLStructS(const LStructS& iceP_i, LStructS& iceP_o, const Ice::Context& context) const
{
    auto result = IceInternal::makePromiseOutgoing<std::tuple<LStructS, LStructS>>(true, this, &MyClassPrx::_iceI_opLStructS, iceP_i, context).get();
    iceP_o = std::move(std::get<1>(result));
    return std::move(std::get<0>(result));
}

std::future<std::tuple<::Test::LStructS, ::Test::LStructS>>
Test::MyClassPrx::opLStructSAsync(const LStructS& iceP_i, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<std::tuple<LStructS, LStructS>>(false, this, &MyClassPrx::_iceI_opLStructS, iceP_i, context);
}

std::function<void()>
Test::MyClassPrx::opLStructSAsync(const LStructS& iceP_i, std::function<void(::Test::LStructS, ::Test::LStructS)> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    auto responseCb = [response = std::move(response)](std::tuple<LStructS, LStructS>&& result) mutable
    {
        std::apply(std::move(response), std::move(result));
    };
    return IceInternal::makeLambdaOutgoing<std::tuple<LStructS, LStructS>>(std::move(responseCb), std::move(exception), std::move(sent), this, &Test::MyClassPrx::_iceI_opLStructS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opLStructS(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::tuple<LStructS, LStructS>>>& outAsync, const LStructS& iceP_i, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "opLStructS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, std::nullopt, context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](Ice::InputStream* istr)
        {
            std::tuple<LStructS, LStructS> v;
            istr->readAll(std::get<1>(v), std::get<0>(v));
            return v;
        });
}

::Test::KStructS
Test::MyClassPrx::opKStructS(const KStructS& iceP_i, KStructS& iceP_o, const Ice::Context& context) const
{
    auto result = IceInternal::makePromiseOutgoing<std::tuple<KStructS, KStructS>>(true, this, &MyClassPrx::_iceI_opKStructS, iceP_i, context).get();
    iceP_o = std::move(std::get<1>(result));
    return std::move(std::get<0>(result));
}

std::future<std::tuple<::Test::KStructS, ::Test::KStructS>>
Test::MyClassPrx::opKStructSAsync(const KStructS& iceP_i, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<std::tuple<KStructS, KStructS>>(false, this, &MyClassPrx::_iceI_opKStructS, iceP_i, context);
}

std::function<void()>
Test::MyClassPrx::opKStructSAsync(const KStructS& iceP_i, std::function<void(::Test::KStructS, ::Test::KStructS)> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    auto responseCb = [response = std::move(response)](std::tuple<KStructS, KStructS>&& result) mutable
    {
        std::apply(std::move(response), std::move(result));
    };
    return IceInternal::makeLambdaOutgoing<std::tuple<KStructS, KStructS>>(std::move(responseCb), std::move(exception), std::move(sent), this, &Test::MyClassPrx::_iceI_opKStructS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opKStructS(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::tuple<KStructS, KStructS>>>& outAsync, const KStructS& iceP_i, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "opKStructS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, std::nullopt, context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](Ice::InputStream* istr)
        {
            std::tuple<KStructS, KStructS> v;
            istr->readAll(std::get<1>(v), std::get<0>(v));
            return v;
        });
}

::Test::QStructS
Test::MyClassPrx::opQStructS(const QStructS& iceP_i, QStructS& iceP_o, const Ice::Context& context) const
{
    auto result = IceInternal::makePromiseOutgoing<std::tuple<QStructS, QStructS>>(true, this, &MyClassPrx::_iceI_opQStructS, iceP_i, context).get();
    iceP_o = std::move(std::get<1>(result));
    return std::move(std::get<0>(result));
}

std::future<std::tuple<::Test::QStructS, ::Test::QStructS>>
Test::MyClassPrx::opQStructSAsync(const QStructS& iceP_i, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<std::tuple<QStructS, QStructS>>(false, this, &MyClassPrx::_iceI_opQStructS, iceP_i, context);
}

std::function<void()>
Test::MyClassPrx::opQStructSAsync(const QStructS& iceP_i, std::function<void(::Test::QStructS, ::Test::QStructS)> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    auto responseCb = [response = std::move(response)](std::tuple<QStructS, QStructS>&& result) mutable
    {
        std::apply(std::move(response), std::move(result));
    };
    return IceInternal::makeLambdaOutgoing<std::tuple<QStructS, QStructS>>(std::move(responseCb), std::move(exception), std::move(sent), this, &Test::MyClassPrx::_iceI_opQStructS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opQStructS(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::tuple<QStructS, QStructS>>>& outAsync, const QStructS& iceP_i, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "opQStructS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, std::nullopt, context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](Ice::InputStream* istr)
        {
            std::tuple<QStructS, QStructS> v;
            istr->readAll(std::get<1>(v), std::get<0>(v));
            return v;
        });
}

::Test::SStructS
Test::MyClassPrx::opSStructS(const SStructS& iceP_i, SStructS& iceP_o, const Ice::Context& context) const
{
    auto result = IceInternal::makePromiseOutgoing<std::tuple<SStructS, SStructS>>(true, this, &MyClassPrx::_iceI_opSStructS, iceP_i, context).get();
    iceP_o = std::move(std::get<1>(result));
    return std::move(std::get<0>(result));
}

std::future<std::tuple<::Test::SStructS, ::Test::SStructS>>
Test::MyClassPrx::opSStructSAsync(const SStructS& iceP_i, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<std::tuple<SStructS, SStructS>>(false, this, &MyClassPrx::_iceI_opSStructS, iceP_i, context);
}

std::function<void()>
Test::MyClassPrx::opSStructSAsync(const SStructS& iceP_i, std::function<void(::Test::SStructS, ::Test::SStructS)> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    auto responseCb = [response = std::move(response)](std::tuple<SStructS, SStructS>&& result) mutable
    {
        std::apply(std::move(response), std::move(result));
    };
    return IceInternal::makeLambdaOutgoing<std::tuple<SStructS, SStructS>>(std::move(responseCb), std::move(exception), std::move(sent), this, &Test::MyClassPrx::_iceI_opSStructS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opSStructS(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::tuple<SStructS, SStructS>>>& outAsync, const SStructS& iceP_i, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "opSStructS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, std::nullopt, context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](Ice::InputStream* istr)
        {
            std::tuple<SStructS, SStructS> v;
            istr->readAll(std::get<1>(v), std::get<0>(v));
            return v;
        });
}

::Test::AStructSD
Test::MyClassPrx::opAStructSD(const AStructSD& iceP_i, AStructSD& iceP_o, const Ice::Context& context) const
{
    auto result = IceInternal::makePromiseOutgoing<std::tuple<AStructSD, AStructSD>>(true, this, &MyClassPrx::_iceI_opAStructSD, iceP_i, context).get();
    iceP_o = std::move(std::get<1>(result));
    return std::move(std::get<0>(result));
}

std::future<std::tuple<::Test::AStructSD, ::Test::AStructSD>>
Test::MyClassPrx::opAStructSDAsync(const AStructSD& iceP_i, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<std::tuple<AStructSD, AStructSD>>(false, this, &MyClassPrx::_iceI_opAStructSD, iceP_i, context);
}

std::function<void()>
Test::MyClassPrx::opAStructSDAsync(const AStructSD& iceP_i, std::function<void(::Test::AStructSD, ::Test::AStructSD)> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    auto responseCb = [response = std::move(response)](std::tuple<AStructSD, AStructSD>&& result) mutable
    {
        std::apply(std::move(response), std::move(result));
    };
    return IceInternal::makeLambdaOutgoing<std::tuple<AStructSD, AStructSD>>(std::move(responseCb), std::move(exception), std::move(sent), this, &Test::MyClassPrx::_iceI_opAStructSD, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opAStructSD(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::tuple<AStructSD, AStructSD>>>& outAsync, const AStructSD& iceP_i, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "opAStructSD";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, std::nullopt, context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](Ice::InputStream* istr)
        {
            std::tuple<AStructSD, AStructSD> v;
            istr->readAll(std::get<1>(v), std::get<0>(v));
            return v;
        });
}

::Test::LStructSD
Test::MyClassPrx::opLStructSD(const LStructSD& iceP_i, LStructSD& iceP_o, const Ice::Context& context) const
{
    auto result = IceInternal::makePromiseOutgoing<std::tuple<LStructSD, LStructSD>>(true, this, &MyClassPrx::_iceI_opLStructSD, iceP_i, context).get();
    iceP_o = std::move(std::get<1>(result));
    return std::move(std::get<0>(result));
}

std::future<std::tuple<::Test::LStructSD, ::Test::LStructSD>>
Test::MyClassPrx::opLStructSDAsync(const LStructSD& iceP_i, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<std::tuple<LStructSD, LStructSD>>(false, this, &MyClassPrx::_iceI_opLStructSD, iceP_i, context);
}

std::function<void()>
Test::MyClassPrx::opLStructSDAsync(const LStructSD& iceP_i, std::function<void(::Test::LStructSD, ::Test::LStructSD)> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    auto responseCb = [response = std::move(response)](std::tuple<LStructSD, LStructSD>&& result) mutable
    {
        std::apply(std::move(response), std::move(result));
    };
    return IceInternal::makeLambdaOutgoing<std::tuple<LStructSD, LStructSD>>(std::move(responseCb), std::move(exception), std::move(sent), this, &Test::MyClassPrx::_iceI_opLStructSD, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opLStructSD(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::tuple<LStructSD, LStructSD>>>& outAsync, const LStructSD& iceP_i, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "opLStructSD";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, std::nullopt, context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](Ice::InputStream* istr)
        {
            std::tuple<LStructSD, LStructSD> v;
            istr->readAll(std::get<1>(v), std::get<0>(v));
            return v;
        });
}

::Test::KStructSD
Test::MyClassPrx::opKStructSD(const KStructSD& iceP_i, KStructSD& iceP_o, const Ice::Context& context) const
{
    auto result = IceInternal::makePromiseOutgoing<std::tuple<KStructSD, KStructSD>>(true, this, &MyClassPrx::_iceI_opKStructSD, iceP_i, context).get();
    iceP_o = std::move(std::get<1>(result));
    return std::move(std::get<0>(result));
}

std::future<std::tuple<::Test::KStructSD, ::Test::KStructSD>>
Test::MyClassPrx::opKStructSDAsync(const KStructSD& iceP_i, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<std::tuple<KStructSD, KStructSD>>(false, this, &MyClassPrx::_iceI_opKStructSD, iceP_i, context);
}

std::function<void()>
Test::MyClassPrx::opKStructSDAsync(const KStructSD& iceP_i, std::function<void(::Test::KStructSD, ::Test::KStructSD)> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    auto responseCb = [response = std::move(response)](std::tuple<KStructSD, KStructSD>&& result) mutable
    {
        std::apply(std::move(response), std::move(result));
    };
    return IceInternal::makeLambdaOutgoing<std::tuple<KStructSD, KStructSD>>(std::move(responseCb), std::move(exception), std::move(sent), this, &Test::MyClassPrx::_iceI_opKStructSD, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opKStructSD(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::tuple<KStructSD, KStructSD>>>& outAsync, const KStructSD& iceP_i, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "opKStructSD";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, std::nullopt, context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](Ice::InputStream* istr)
        {
            std::tuple<KStructSD, KStructSD> v;
            istr->readAll(std::get<1>(v), std::get<0>(v));
            return v;
        });
}

::Test::QStructSD
Test::MyClassPrx::opQStructSD(const QStructSD& iceP_i, QStructSD& iceP_o, const Ice::Context& context) const
{
    auto result = IceInternal::makePromiseOutgoing<std::tuple<QStructSD, QStructSD>>(true, this, &MyClassPrx::_iceI_opQStructSD, iceP_i, context).get();
    iceP_o = std::move(std::get<1>(result));
    return std::move(std::get<0>(result));
}

std::future<std::tuple<::Test::QStructSD, ::Test::QStructSD>>
Test::MyClassPrx::opQStructSDAsync(const QStructSD& iceP_i, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<std::tuple<QStructSD, QStructSD>>(false, this, &MyClassPrx::_iceI_opQStructSD, iceP_i, context);
}

std::function<void()>
Test::MyClassPrx::opQStructSDAsync(const QStructSD& iceP_i, std::function<void(::Test::QStructSD, ::Test::QStructSD)> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    auto responseCb = [response = std::move(response)](std::tuple<QStructSD, QStructSD>&& result) mutable
    {
        std::apply(std::move(response), std::move(result));
    };
    return IceInternal::makeLambdaOutgoing<std::tuple<QStructSD, QStructSD>>(std::move(responseCb), std::move(exception), std::move(sent), this, &Test::MyClassPrx::_iceI_opQStructSD, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opQStructSD(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::tuple<QStructSD, QStructSD>>>& outAsync, const QStructSD& iceP_i, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "opQStructSD";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, std::nullopt, context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](Ice::InputStream* istr)
        {
            std::tuple<QStructSD, QStructSD> v;
            istr->readAll(std::get<1>(v), std::get<0>(v));
            return v;
        });
}

::Test::SStructSD
Test::MyClassPrx::opSStructSD(const SStructSD& iceP_i, SStructSD& iceP_o, const Ice::Context& context) const
{
    auto result = IceInternal::makePromiseOutgoing<std::tuple<SStructSD, SStructSD>>(true, this, &MyClassPrx::_iceI_opSStructSD, iceP_i, context).get();
    iceP_o = std::move(std::get<1>(result));
    return std::move(std::get<0>(result));
}

std::future<std::tuple<::Test::SStructSD, ::Test::SStructSD>>
Test::MyClassPrx::opSStructSDAsync(const SStructSD& iceP_i, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<std::tuple<SStructSD, SStructSD>>(false, this, &MyClassPrx::_iceI_opSStructSD, iceP_i, context);
}

std::function<void()>
Test::MyClassPrx::opSStructSDAsync(const SStructSD& iceP_i, std::function<void(::Test::SStructSD, ::Test::SStructSD)> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    auto responseCb = [response = std::move(response)](std::tuple<SStructSD, SStructSD>&& result) mutable
    {
        std::apply(std::move(response), std::move(result));
    };
    return IceInternal::makeLambdaOutgoing<std::tuple<SStructSD, SStructSD>>(std::move(responseCb), std::move(exception), std::move(sent), this, &Test::MyClassPrx::_iceI_opSStructSD, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opSStructSD(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::tuple<SStructSD, SStructSD>>>& outAsync, const SStructSD& iceP_i, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "opSStructSD";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, std::nullopt, context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](Ice::InputStream* istr)
        {
            std::tuple<SStructSD, SStructSD> v;
            istr->readAll(std::get<1>(v), std::get<0>(v));
            return v;
        });
}

::Test::ACVS
Test::MyClassPrx::opACVS(const ACVS& iceP_i, ACVS& iceP_o, const Ice::Context& context) const
{
    auto result = IceInternal::makePromiseOutgoing<std::tuple<ACVS, ACVS>>(true, this, &MyClassPrx::_iceI_opACVS, iceP_i, context).get();
    iceP_o = std::move(std::get<1>(result));
    return std::move(std::get<0>(result));
}

std::future<std::tuple<::Test::ACVS, ::Test::ACVS>>
Test::MyClassPrx::opACVSAsync(const ACVS& iceP_i, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<std::tuple<ACVS, ACVS>>(false, this, &MyClassPrx::_iceI_opACVS, iceP_i, context);
}

std::function<void()>
Test::MyClassPrx::opACVSAsync(const ACVS& iceP_i, std::function<void(::Test::ACVS, ::Test::ACVS)> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    auto responseCb = [response = std::move(response)](std::tuple<ACVS, ACVS>&& result) mutable
    {
        std::apply(std::move(response), std::move(result));
    };
    return IceInternal::makeLambdaOutgoing<std::tuple<ACVS, ACVS>>(std::move(responseCb), std::move(exception), std::move(sent), this, &Test::MyClassPrx::_iceI_opACVS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opACVS(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::tuple<ACVS, ACVS>>>& outAsync, const ACVS& iceP_i, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "opACVS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, std::nullopt, context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
            ostr->writePendingValues();
        },
        nullptr,
        [](Ice::InputStream* istr)
        {
            std::tuple<ACVS, ACVS> v;
            istr->readAll(std::get<1>(v), std::get<0>(v));
            istr->readPendingValues();
            return v;
        });
}

::Test::LCVS
Test::MyClassPrx::opLCVS(const LCVS& iceP_i, LCVS& iceP_o, const Ice::Context& context) const
{
    auto result = IceInternal::makePromiseOutgoing<std::tuple<LCVS, LCVS>>(true, this, &MyClassPrx::_iceI_opLCVS, iceP_i, context).get();
    iceP_o = std::move(std::get<1>(result));
    return std::move(std::get<0>(result));
}

std::future<std::tuple<::Test::LCVS, ::Test::LCVS>>
Test::MyClassPrx::opLCVSAsync(const LCVS& iceP_i, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<std::tuple<LCVS, LCVS>>(false, this, &MyClassPrx::_iceI_opLCVS, iceP_i, context);
}

std::function<void()>
Test::MyClassPrx::opLCVSAsync(const LCVS& iceP_i, std::function<void(::Test::LCVS, ::Test::LCVS)> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    auto responseCb = [response = std::move(response)](std::tuple<LCVS, LCVS>&& result) mutable
    {
        std::apply(std::move(response), std::move(result));
    };
    return IceInternal::makeLambdaOutgoing<std::tuple<LCVS, LCVS>>(std::move(responseCb), std::move(exception), std::move(sent), this, &Test::MyClassPrx::_iceI_opLCVS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opLCVS(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::tuple<LCVS, LCVS>>>& outAsync, const LCVS& iceP_i, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "opLCVS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, std::nullopt, context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
            ostr->writePendingValues();
        },
        nullptr,
        [](Ice::InputStream* istr)
        {
            std::tuple<LCVS, LCVS> v;
            istr->readAll(std::get<1>(v), std::get<0>(v));
            istr->readPendingValues();
            return v;
        });
}

::Test::ACRS
Test::MyClassPrx::opACRS(const ACRS& iceP_i, ACRS& iceP_o, const Ice::Context& context) const
{
    auto result = IceInternal::makePromiseOutgoing<std::tuple<ACRS, ACRS>>(true, this, &MyClassPrx::_iceI_opACRS, iceP_i, context).get();
    iceP_o = std::move(std::get<1>(result));
    return std::move(std::get<0>(result));
}

std::future<std::tuple<::Test::ACRS, ::Test::ACRS>>
Test::MyClassPrx::opACRSAsync(const ACRS& iceP_i, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<std::tuple<ACRS, ACRS>>(false, this, &MyClassPrx::_iceI_opACRS, iceP_i, context);
}

std::function<void()>
Test::MyClassPrx::opACRSAsync(const ACRS& iceP_i, std::function<void(::Test::ACRS, ::Test::ACRS)> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    auto responseCb = [response = std::move(response)](std::tuple<ACRS, ACRS>&& result) mutable
    {
        std::apply(std::move(response), std::move(result));
    };
    return IceInternal::makeLambdaOutgoing<std::tuple<ACRS, ACRS>>(std::move(responseCb), std::move(exception), std::move(sent), this, &Test::MyClassPrx::_iceI_opACRS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opACRS(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::tuple<ACRS, ACRS>>>& outAsync, const ACRS& iceP_i, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "opACRS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, std::nullopt, context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
            ostr->writePendingValues();
        },
        nullptr,
        [](Ice::InputStream* istr)
        {
            std::tuple<ACRS, ACRS> v;
            istr->readAll(std::get<1>(v), std::get<0>(v));
            istr->readPendingValues();
            return v;
        });
}

::Test::LCRS
Test::MyClassPrx::opLCRS(const LCRS& iceP_i, LCRS& iceP_o, const Ice::Context& context) const
{
    auto result = IceInternal::makePromiseOutgoing<std::tuple<LCRS, LCRS>>(true, this, &MyClassPrx::_iceI_opLCRS, iceP_i, context).get();
    iceP_o = std::move(std::get<1>(result));
    return std::move(std::get<0>(result));
}

std::future<std::tuple<::Test::LCRS, ::Test::LCRS>>
Test::MyClassPrx::opLCRSAsync(const LCRS& iceP_i, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<std::tuple<LCRS, LCRS>>(false, this, &MyClassPrx::_iceI_opLCRS, iceP_i, context);
}

std::function<void()>
Test::MyClassPrx::opLCRSAsync(const LCRS& iceP_i, std::function<void(::Test::LCRS, ::Test::LCRS)> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    auto responseCb = [response = std::move(response)](std::tuple<LCRS, LCRS>&& result) mutable
    {
        std::apply(std::move(response), std::move(result));
    };
    return IceInternal::makeLambdaOutgoing<std::tuple<LCRS, LCRS>>(std::move(responseCb), std::move(exception), std::move(sent), this, &Test::MyClassPrx::_iceI_opLCRS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opLCRS(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::tuple<LCRS, LCRS>>>& outAsync, const LCRS& iceP_i, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "opLCRS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, std::nullopt, context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
            ostr->writePendingValues();
        },
        nullptr,
        [](Ice::InputStream* istr)
        {
            std::tuple<LCRS, LCRS> v;
            istr->readAll(std::get<1>(v), std::get<0>(v));
            istr->readPendingValues();
            return v;
        });
}

::Test::AEnS
Test::MyClassPrx::opAEnS(const AEnS& iceP_i, AEnS& iceP_o, const Ice::Context& context) const
{
    auto result = IceInternal::makePromiseOutgoing<std::tuple<AEnS, AEnS>>(true, this, &MyClassPrx::_iceI_opAEnS, iceP_i, context).get();
    iceP_o = std::move(std::get<1>(result));
    return std::move(std::get<0>(result));
}

std::future<std::tuple<::Test::AEnS, ::Test::AEnS>>
Test::MyClassPrx::opAEnSAsync(const AEnS& iceP_i, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<std::tuple<AEnS, AEnS>>(false, this, &MyClassPrx::_iceI_opAEnS, iceP_i, context);
}

std::function<void()>
Test::MyClassPrx::opAEnSAsync(const AEnS& iceP_i, std::function<void(::Test::AEnS, ::Test::AEnS)> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    auto responseCb = [response = std::move(response)](std::tuple<AEnS, AEnS>&& result) mutable
    {
        std::apply(std::move(response), std::move(result));
    };
    return IceInternal::makeLambdaOutgoing<std::tuple<AEnS, AEnS>>(std::move(responseCb), std::move(exception), std::move(sent), this, &Test::MyClassPrx::_iceI_opAEnS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opAEnS(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::tuple<AEnS, AEnS>>>& outAsync, const AEnS& iceP_i, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "opAEnS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, std::nullopt, context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](Ice::InputStream* istr)
        {
            std::tuple<AEnS, AEnS> v;
            istr->readAll(std::get<1>(v), std::get<0>(v));
            return v;
        });
}

::Test::LEnS
Test::MyClassPrx::opLEnS(const LEnS& iceP_i, LEnS& iceP_o, const Ice::Context& context) const
{
    auto result = IceInternal::makePromiseOutgoing<std::tuple<LEnS, LEnS>>(true, this, &MyClassPrx::_iceI_opLEnS, iceP_i, context).get();
    iceP_o = std::move(std::get<1>(result));
    return std::move(std::get<0>(result));
}

std::future<std::tuple<::Test::LEnS, ::Test::LEnS>>
Test::MyClassPrx::opLEnSAsync(const LEnS& iceP_i, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<std::tuple<LEnS, LEnS>>(false, this, &MyClassPrx::_iceI_opLEnS, iceP_i, context);
}

std::function<void()>
Test::MyClassPrx::opLEnSAsync(const LEnS& iceP_i, std::function<void(::Test::LEnS, ::Test::LEnS)> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    auto responseCb = [response = std::move(response)](std::tuple<LEnS, LEnS>&& result) mutable
    {
        std::apply(std::move(response), std::move(result));
    };
    return IceInternal::makeLambdaOutgoing<std::tuple<LEnS, LEnS>>(std::move(responseCb), std::move(exception), std::move(sent), this, &Test::MyClassPrx::_iceI_opLEnS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opLEnS(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::tuple<LEnS, LEnS>>>& outAsync, const LEnS& iceP_i, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "opLEnS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, std::nullopt, context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](Ice::InputStream* istr)
        {
            std::tuple<LEnS, LEnS> v;
            istr->readAll(std::get<1>(v), std::get<0>(v));
            return v;
        });
}

::Test::KEnS
Test::MyClassPrx::opKEnS(const KEnS& iceP_i, KEnS& iceP_o, const Ice::Context& context) const
{
    auto result = IceInternal::makePromiseOutgoing<std::tuple<KEnS, KEnS>>(true, this, &MyClassPrx::_iceI_opKEnS, iceP_i, context).get();
    iceP_o = std::move(std::get<1>(result));
    return std::move(std::get<0>(result));
}

std::future<std::tuple<::Test::KEnS, ::Test::KEnS>>
Test::MyClassPrx::opKEnSAsync(const KEnS& iceP_i, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<std::tuple<KEnS, KEnS>>(false, this, &MyClassPrx::_iceI_opKEnS, iceP_i, context);
}

std::function<void()>
Test::MyClassPrx::opKEnSAsync(const KEnS& iceP_i, std::function<void(::Test::KEnS, ::Test::KEnS)> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    auto responseCb = [response = std::move(response)](std::tuple<KEnS, KEnS>&& result) mutable
    {
        std::apply(std::move(response), std::move(result));
    };
    return IceInternal::makeLambdaOutgoing<std::tuple<KEnS, KEnS>>(std::move(responseCb), std::move(exception), std::move(sent), this, &Test::MyClassPrx::_iceI_opKEnS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opKEnS(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::tuple<KEnS, KEnS>>>& outAsync, const KEnS& iceP_i, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "opKEnS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, std::nullopt, context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](Ice::InputStream* istr)
        {
            std::tuple<KEnS, KEnS> v;
            istr->readAll(std::get<1>(v), std::get<0>(v));
            return v;
        });
}

::Test::QEnS
Test::MyClassPrx::opQEnS(const QEnS& iceP_i, QEnS& iceP_o, const Ice::Context& context) const
{
    auto result = IceInternal::makePromiseOutgoing<std::tuple<QEnS, QEnS>>(true, this, &MyClassPrx::_iceI_opQEnS, iceP_i, context).get();
    iceP_o = std::move(std::get<1>(result));
    return std::move(std::get<0>(result));
}

std::future<std::tuple<::Test::QEnS, ::Test::QEnS>>
Test::MyClassPrx::opQEnSAsync(const QEnS& iceP_i, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<std::tuple<QEnS, QEnS>>(false, this, &MyClassPrx::_iceI_opQEnS, iceP_i, context);
}

std::function<void()>
Test::MyClassPrx::opQEnSAsync(const QEnS& iceP_i, std::function<void(::Test::QEnS, ::Test::QEnS)> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    auto responseCb = [response = std::move(response)](std::tuple<QEnS, QEnS>&& result) mutable
    {
        std::apply(std::move(response), std::move(result));
    };
    return IceInternal::makeLambdaOutgoing<std::tuple<QEnS, QEnS>>(std::move(responseCb), std::move(exception), std::move(sent), this, &Test::MyClassPrx::_iceI_opQEnS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opQEnS(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::tuple<QEnS, QEnS>>>& outAsync, const QEnS& iceP_i, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "opQEnS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, std::nullopt, context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](Ice::InputStream* istr)
        {
            std::tuple<QEnS, QEnS> v;
            istr->readAll(std::get<1>(v), std::get<0>(v));
            return v;
        });
}

::Test::SEnS
Test::MyClassPrx::opSEnS(const SEnS& iceP_i, SEnS& iceP_o, const Ice::Context& context) const
{
    auto result = IceInternal::makePromiseOutgoing<std::tuple<SEnS, SEnS>>(true, this, &MyClassPrx::_iceI_opSEnS, iceP_i, context).get();
    iceP_o = std::move(std::get<1>(result));
    return std::move(std::get<0>(result));
}

std::future<std::tuple<::Test::SEnS, ::Test::SEnS>>
Test::MyClassPrx::opSEnSAsync(const SEnS& iceP_i, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<std::tuple<SEnS, SEnS>>(false, this, &MyClassPrx::_iceI_opSEnS, iceP_i, context);
}

std::function<void()>
Test::MyClassPrx::opSEnSAsync(const SEnS& iceP_i, std::function<void(::Test::SEnS, ::Test::SEnS)> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    auto responseCb = [response = std::move(response)](std::tuple<SEnS, SEnS>&& result) mutable
    {
        std::apply(std::move(response), std::move(result));
    };
    return IceInternal::makeLambdaOutgoing<std::tuple<SEnS, SEnS>>(std::move(responseCb), std::move(exception), std::move(sent), this, &Test::MyClassPrx::_iceI_opSEnS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opSEnS(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::tuple<SEnS, SEnS>>>& outAsync, const SEnS& iceP_i, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "opSEnS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, std::nullopt, context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](Ice::InputStream* istr)
        {
            std::tuple<SEnS, SEnS> v;
            istr->readAll(std::get<1>(v), std::get<0>(v));
            return v;
        });
}

::Test::AIPrxS
Test::MyClassPrx::opAIPrxS(const AIPrxS& iceP_i, AIPrxS& iceP_o, const Ice::Context& context) const
{
    auto result = IceInternal::makePromiseOutgoing<std::tuple<AIPrxS, AIPrxS>>(true, this, &MyClassPrx::_iceI_opAIPrxS, iceP_i, context).get();
    iceP_o = std::move(std::get<1>(result));
    return std::move(std::get<0>(result));
}

std::future<std::tuple<::Test::AIPrxS, ::Test::AIPrxS>>
Test::MyClassPrx::opAIPrxSAsync(const AIPrxS& iceP_i, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<std::tuple<AIPrxS, AIPrxS>>(false, this, &MyClassPrx::_iceI_opAIPrxS, iceP_i, context);
}

std::function<void()>
Test::MyClassPrx::opAIPrxSAsync(const AIPrxS& iceP_i, std::function<void(::Test::AIPrxS, ::Test::AIPrxS)> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    auto responseCb = [response = std::move(response)](std::tuple<AIPrxS, AIPrxS>&& result) mutable
    {
        std::apply(std::move(response), std::move(result));
    };
    return IceInternal::makeLambdaOutgoing<std::tuple<AIPrxS, AIPrxS>>(std::move(responseCb), std::move(exception), std::move(sent), this, &Test::MyClassPrx::_iceI_opAIPrxS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opAIPrxS(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::tuple<AIPrxS, AIPrxS>>>& outAsync, const AIPrxS& iceP_i, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "opAIPrxS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, std::nullopt, context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](Ice::InputStream* istr)
        {
            std::tuple<AIPrxS, AIPrxS> v;
            istr->readAll(std::get<1>(v), std::get<0>(v));
            return v;
        });
}

::Test::LIPrxS
Test::MyClassPrx::opLIPrxS(const LIPrxS& iceP_i, LIPrxS& iceP_o, const Ice::Context& context) const
{
    auto result = IceInternal::makePromiseOutgoing<std::tuple<LIPrxS, LIPrxS>>(true, this, &MyClassPrx::_iceI_opLIPrxS, iceP_i, context).get();
    iceP_o = std::move(std::get<1>(result));
    return std::move(std::get<0>(result));
}

std::future<std::tuple<::Test::LIPrxS, ::Test::LIPrxS>>
Test::MyClassPrx::opLIPrxSAsync(const LIPrxS& iceP_i, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<std::tuple<LIPrxS, LIPrxS>>(false, this, &MyClassPrx::_iceI_opLIPrxS, iceP_i, context);
}

std::function<void()>
Test::MyClassPrx::opLIPrxSAsync(const LIPrxS& iceP_i, std::function<void(::Test::LIPrxS, ::Test::LIPrxS)> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    auto responseCb = [response = std::move(response)](std::tuple<LIPrxS, LIPrxS>&& result) mutable
    {
        std::apply(std::move(response), std::move(result));
    };
    return IceInternal::makeLambdaOutgoing<std::tuple<LIPrxS, LIPrxS>>(std::move(responseCb), std::move(exception), std::move(sent), this, &Test::MyClassPrx::_iceI_opLIPrxS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opLIPrxS(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::tuple<LIPrxS, LIPrxS>>>& outAsync, const LIPrxS& iceP_i, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "opLIPrxS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, std::nullopt, context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](Ice::InputStream* istr)
        {
            std::tuple<LIPrxS, LIPrxS> v;
            istr->readAll(std::get<1>(v), std::get<0>(v));
            return v;
        });
}

::Test::KIPrxS
Test::MyClassPrx::opKIPrxS(const KIPrxS& iceP_i, KIPrxS& iceP_o, const Ice::Context& context) const
{
    auto result = IceInternal::makePromiseOutgoing<std::tuple<KIPrxS, KIPrxS>>(true, this, &MyClassPrx::_iceI_opKIPrxS, iceP_i, context).get();
    iceP_o = std::move(std::get<1>(result));
    return std::move(std::get<0>(result));
}

std::future<std::tuple<::Test::KIPrxS, ::Test::KIPrxS>>
Test::MyClassPrx::opKIPrxSAsync(const KIPrxS& iceP_i, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<std::tuple<KIPrxS, KIPrxS>>(false, this, &MyClassPrx::_iceI_opKIPrxS, iceP_i, context);
}

std::function<void()>
Test::MyClassPrx::opKIPrxSAsync(const KIPrxS& iceP_i, std::function<void(::Test::KIPrxS, ::Test::KIPrxS)> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    auto responseCb = [response = std::move(response)](std::tuple<KIPrxS, KIPrxS>&& result) mutable
    {
        std::apply(std::move(response), std::move(result));
    };
    return IceInternal::makeLambdaOutgoing<std::tuple<KIPrxS, KIPrxS>>(std::move(responseCb), std::move(exception), std::move(sent), this, &Test::MyClassPrx::_iceI_opKIPrxS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opKIPrxS(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::tuple<KIPrxS, KIPrxS>>>& outAsync, const KIPrxS& iceP_i, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "opKIPrxS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, std::nullopt, context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](Ice::InputStream* istr)
        {
            std::tuple<KIPrxS, KIPrxS> v;
            istr->readAll(std::get<1>(v), std::get<0>(v));
            return v;
        });
}

::Test::QIPrxS
Test::MyClassPrx::opQIPrxS(const QIPrxS& iceP_i, QIPrxS& iceP_o, const Ice::Context& context) const
{
    auto result = IceInternal::makePromiseOutgoing<std::tuple<QIPrxS, QIPrxS>>(true, this, &MyClassPrx::_iceI_opQIPrxS, iceP_i, context).get();
    iceP_o = std::move(std::get<1>(result));
    return std::move(std::get<0>(result));
}

std::future<std::tuple<::Test::QIPrxS, ::Test::QIPrxS>>
Test::MyClassPrx::opQIPrxSAsync(const QIPrxS& iceP_i, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<std::tuple<QIPrxS, QIPrxS>>(false, this, &MyClassPrx::_iceI_opQIPrxS, iceP_i, context);
}

std::function<void()>
Test::MyClassPrx::opQIPrxSAsync(const QIPrxS& iceP_i, std::function<void(::Test::QIPrxS, ::Test::QIPrxS)> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    auto responseCb = [response = std::move(response)](std::tuple<QIPrxS, QIPrxS>&& result) mutable
    {
        std::apply(std::move(response), std::move(result));
    };
    return IceInternal::makeLambdaOutgoing<std::tuple<QIPrxS, QIPrxS>>(std::move(responseCb), std::move(exception), std::move(sent), this, &Test::MyClassPrx::_iceI_opQIPrxS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opQIPrxS(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::tuple<QIPrxS, QIPrxS>>>& outAsync, const QIPrxS& iceP_i, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "opQIPrxS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, std::nullopt, context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](Ice::InputStream* istr)
        {
            std::tuple<QIPrxS, QIPrxS> v;
            istr->readAll(std::get<1>(v), std::get<0>(v));
            return v;
        });
}

::Test::SIPrxS
Test::MyClassPrx::opSIPrxS(const SIPrxS& iceP_i, SIPrxS& iceP_o, const Ice::Context& context) const
{
    auto result = IceInternal::makePromiseOutgoing<std::tuple<SIPrxS, SIPrxS>>(true, this, &MyClassPrx::_iceI_opSIPrxS, iceP_i, context).get();
    iceP_o = std::move(std::get<1>(result));
    return std::move(std::get<0>(result));
}

std::future<std::tuple<::Test::SIPrxS, ::Test::SIPrxS>>
Test::MyClassPrx::opSIPrxSAsync(const SIPrxS& iceP_i, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<std::tuple<SIPrxS, SIPrxS>>(false, this, &MyClassPrx::_iceI_opSIPrxS, iceP_i, context);
}

std::function<void()>
Test::MyClassPrx::opSIPrxSAsync(const SIPrxS& iceP_i, std::function<void(::Test::SIPrxS, ::Test::SIPrxS)> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    auto responseCb = [response = std::move(response)](std::tuple<SIPrxS, SIPrxS>&& result) mutable
    {
        std::apply(std::move(response), std::move(result));
    };
    return IceInternal::makeLambdaOutgoing<std::tuple<SIPrxS, SIPrxS>>(std::move(responseCb), std::move(exception), std::move(sent), this, &Test::MyClassPrx::_iceI_opSIPrxS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opSIPrxS(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::tuple<SIPrxS, SIPrxS>>>& outAsync, const SIPrxS& iceP_i, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "opSIPrxS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, std::nullopt, context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](Ice::InputStream* istr)
        {
            std::tuple<SIPrxS, SIPrxS> v;
            istr->readAll(std::get<1>(v), std::get<0>(v));
            return v;
        });
}

::Test::CustomIntS
Test::MyClassPrx::opCustomIntS(const CustomIntS& iceP_i, CustomIntS& iceP_o, const Ice::Context& context) const
{
    auto result = IceInternal::makePromiseOutgoing<std::tuple<CustomIntS, CustomIntS>>(true, this, &MyClassPrx::_iceI_opCustomIntS, iceP_i, context).get();
    iceP_o = std::move(std::get<1>(result));
    return std::move(std::get<0>(result));
}

std::future<std::tuple<::Test::CustomIntS, ::Test::CustomIntS>>
Test::MyClassPrx::opCustomIntSAsync(const CustomIntS& iceP_i, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<std::tuple<CustomIntS, CustomIntS>>(false, this, &MyClassPrx::_iceI_opCustomIntS, iceP_i, context);
}

std::function<void()>
Test::MyClassPrx::opCustomIntSAsync(const CustomIntS& iceP_i, std::function<void(::Test::CustomIntS, ::Test::CustomIntS)> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    auto responseCb = [response = std::move(response)](std::tuple<CustomIntS, CustomIntS>&& result) mutable
    {
        std::apply(std::move(response), std::move(result));
    };
    return IceInternal::makeLambdaOutgoing<std::tuple<CustomIntS, CustomIntS>>(std::move(responseCb), std::move(exception), std::move(sent), this, &Test::MyClassPrx::_iceI_opCustomIntS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opCustomIntS(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::tuple<CustomIntS, CustomIntS>>>& outAsync, const CustomIntS& iceP_i, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "opCustomIntS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, std::nullopt, context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](Ice::InputStream* istr)
        {
            std::tuple<CustomIntS, CustomIntS> v;
            istr->readAll(std::get<1>(v), std::get<0>(v));
            return v;
        });
}

::Test::CustomCVS
Test::MyClassPrx::opCustomCVS(const CustomCVS& iceP_i, CustomCVS& iceP_o, const Ice::Context& context) const
{
    auto result = IceInternal::makePromiseOutgoing<std::tuple<CustomCVS, CustomCVS>>(true, this, &MyClassPrx::_iceI_opCustomCVS, iceP_i, context).get();
    iceP_o = std::move(std::get<1>(result));
    return std::move(std::get<0>(result));
}

std::future<std::tuple<::Test::CustomCVS, ::Test::CustomCVS>>
Test::MyClassPrx::opCustomCVSAsync(const CustomCVS& iceP_i, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<std::tuple<CustomCVS, CustomCVS>>(false, this, &MyClassPrx::_iceI_opCustomCVS, iceP_i, context);
}

std::function<void()>
Test::MyClassPrx::opCustomCVSAsync(const CustomCVS& iceP_i, std::function<void(::Test::CustomCVS, ::Test::CustomCVS)> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    auto responseCb = [response = std::move(response)](std::tuple<CustomCVS, CustomCVS>&& result) mutable
    {
        std::apply(std::move(response), std::move(result));
    };
    return IceInternal::makeLambdaOutgoing<std::tuple<CustomCVS, CustomCVS>>(std::move(responseCb), std::move(exception), std::move(sent), this, &Test::MyClassPrx::_iceI_opCustomCVS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opCustomCVS(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::tuple<CustomCVS, CustomCVS>>>& outAsync, const CustomCVS& iceP_i, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "opCustomCVS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, std::nullopt, context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
            ostr->writePendingValues();
        },
        nullptr,
        [](Ice::InputStream* istr)
        {
            std::tuple<CustomCVS, CustomCVS> v;
            istr->readAll(std::get<1>(v), std::get<0>(v));
            istr->readPendingValues();
            return v;
        });
}

::Test::CustomIntSS
Test::MyClassPrx::opCustomIntSS(const CustomIntSS& iceP_i, CustomIntSS& iceP_o, const Ice::Context& context) const
{
    auto result = IceInternal::makePromiseOutgoing<std::tuple<CustomIntSS, CustomIntSS>>(true, this, &MyClassPrx::_iceI_opCustomIntSS, iceP_i, context).get();
    iceP_o = std::move(std::get<1>(result));
    return std::move(std::get<0>(result));
}

std::future<std::tuple<::Test::CustomIntSS, ::Test::CustomIntSS>>
Test::MyClassPrx::opCustomIntSSAsync(const CustomIntSS& iceP_i, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<std::tuple<CustomIntSS, CustomIntSS>>(false, this, &MyClassPrx::_iceI_opCustomIntSS, iceP_i, context);
}

std::function<void()>
Test::MyClassPrx::opCustomIntSSAsync(const CustomIntSS& iceP_i, std::function<void(::Test::CustomIntSS, ::Test::CustomIntSS)> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    auto responseCb = [response = std::move(response)](std::tuple<CustomIntSS, CustomIntSS>&& result) mutable
    {
        std::apply(std::move(response), std::move(result));
    };
    return IceInternal::makeLambdaOutgoing<std::tuple<CustomIntSS, CustomIntSS>>(std::move(responseCb), std::move(exception), std::move(sent), this, &Test::MyClassPrx::_iceI_opCustomIntSS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opCustomIntSS(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::tuple<CustomIntSS, CustomIntSS>>>& outAsync, const CustomIntSS& iceP_i, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "opCustomIntSS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, std::nullopt, context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](Ice::InputStream* istr)
        {
            std::tuple<CustomIntSS, CustomIntSS> v;
            istr->readAll(std::get<1>(v), std::get<0>(v));
            return v;
        });
}

::Test::CustomCVSS
Test::MyClassPrx::opCustomCVSS(const CustomCVSS& iceP_i, CustomCVSS& iceP_o, const Ice::Context& context) const
{
    auto result = IceInternal::makePromiseOutgoing<std::tuple<CustomCVSS, CustomCVSS>>(true, this, &MyClassPrx::_iceI_opCustomCVSS, iceP_i, context).get();
    iceP_o = std::move(std::get<1>(result));
    return std::move(std::get<0>(result));
}

std::future<std::tuple<::Test::CustomCVSS, ::Test::CustomCVSS>>
Test::MyClassPrx::opCustomCVSSAsync(const CustomCVSS& iceP_i, const Ice::Context& context) const
{
    return IceInternal::makePromiseOutgoing<std::tuple<CustomCVSS, CustomCVSS>>(false, this, &MyClassPrx::_iceI_opCustomCVSS, iceP_i, context);
}

std::function<void()>
Test::MyClassPrx::opCustomCVSSAsync(const CustomCVSS& iceP_i, std::function<void(::Test::CustomCVSS, ::Test::CustomCVSS)> response, std::function<void(std::exception_ptr)> exception, std::function<void(bool)> sent, const Ice::Context& context) const
{
    auto responseCb = [response = std::move(response)](std::tuple<CustomCVSS, CustomCVSS>&& result) mutable
    {
        std::apply(std::move(response), std::move(result));
    };
    return IceInternal::makeLambdaOutgoing<std::tuple<CustomCVSS, CustomCVSS>>(std::move(responseCb), std::move(exception), std::move(sent), this, &Test::MyClassPrx::_iceI_opCustomCVSS, iceP_i, context);
}

void
Test::MyClassPrx::_iceI_opCustomCVSS(const std::shared_ptr<IceInternal::OutgoingAsyncT<std::tuple<CustomCVSS, CustomCVSS>>>& outAsync, const CustomCVSS& iceP_i, const Ice::Context& context) const
{
    static constexpr std::string_view operationName = "opCustomCVSS";

    _checkTwowayOnly(operationName);
    outAsync->invoke(operationName, Ice::OperationMode::Normal, std::nullopt, context,
        [&](Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
            ostr->writePendingValues();
        },
        nullptr,
        [](Ice::InputStream* istr)
        {
            std::tuple<CustomCVSS, CustomCVSS> v;
            istr->readAll(std::get<1>(v), std::get<0>(v));
            istr->readPendingValues();
            return v;
        });
}

Test::MyClassPrx::~MyClassPrx() = default;

const char*
Test::MyClassPrx::ice_staticId() noexcept
{
    return "::Test::MyClass";
}

void
Test::S::ice_printFields(std::ostream& os) const
{
    Ice::print(os << "i = ", this->i);
}

std::ostream&
Test::operator<<(std::ostream& os, const ::Test::S& value)
{
    os << "Test::S{";
    value.ice_printFields(os);
    os << '}';
    return os;
}

void
Test::SD::ice_printFields(std::ostream& os) const
{
    Ice::print(os << "i = ", this->i);
}

std::ostream&
Test::operator<<(std::ostream& os, const ::Test::SD& value)
{
    os << "Test::SD{";
    value.ice_printFields(os);
    os << '}';
    return os;
}

const char*
Test::CV::ice_staticId() noexcept
{
    return "::Test::CV";
}

const char*
Test::CV::ice_id() const noexcept
{
    return ice_staticId();
}

void
Test::CV::ice_printFields(std::ostream& os) const
{
    Ice::print(os << "i = ", this->i);
}

Ice::ValuePtr
Test::CV::_iceCloneImpl() const
{
    return CloneEnabler<CV>::clone(*this);
}

void
Test::CV::_iceWriteImpl(Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ostr->writeAll(this->i);
    ostr->endSlice();
}

void
Test::CV::_iceReadImpl(Ice::InputStream* istr)
{
    istr->startSlice();
    istr->readAll(this->i);
    istr->endSlice();
}

const char*
Test::CR::ice_staticId() noexcept
{
    return "::Test::CR";
}

const char*
Test::CR::ice_id() const noexcept
{
    return ice_staticId();
}

void
Test::CR::ice_printFields(std::ostream& os) const
{
    Ice::print(os << "v = ", this->v);
}

Ice::ValuePtr
Test::CR::_iceCloneImpl() const
{
    return CloneEnabler<CR>::clone(*this);
}

void
Test::CR::_iceWriteImpl(Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ostr->writeAll(this->v);
    ostr->endSlice();
}

void
Test::CR::_iceReadImpl(Ice::InputStream* istr)
{
    istr->startSlice();
    istr->readAll(this->v);
    istr->endSlice();
}

std::vector<std::string>
Test::I::ice_ids(const Ice::Current&) const
{
    static const std::vector<std::string> allTypeIds = {"::Ice::Object", "::Test::I"};
    return allTypeIds;
}

std::string
Test::I::ice_id(const Ice::Current&) const
{
    return std::string{ice_staticId()};
}

const char*
Test::I::ice_staticId() noexcept
{
    return "::Test::I";
}

std::vector<std::string>
Test::MyClass::ice_ids(const Ice::Current&) const
{
    static const std::vector<std::string> allTypeIds = {"::Ice::Object", "::Test::MyClass"};
    return allTypeIds;
}

std::string
Test::MyClass::ice_id(const Ice::Current&) const
{
    return std::string{ice_staticId()};
}

const char*
Test::MyClass::ice_staticId() noexcept
{
    return "::Test::MyClass";
}

/// \cond INTERNAL
void
Test::MyClass::_iceD_shutdown(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    request.inputStream().skipEmptyEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    try
    {
        this->shutdownAsync([responseHandler] { responseHandler->sendEmptyResponse(); }, [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClass::_iceD_opAByteS(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    AByteS iceP_i;
    istr->readAll(iceP_i);
    istr->endEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    auto responseCb = [responseHandler](const AByteS& ret, const AByteS& iceP_o)
    {
        responseHandler->sendResponse(
            [&](Ice::OutputStream* ostr)
            {
                ostr->writeAll(iceP_o, ret);
            });
    };
    try
    {
        this->opAByteSAsync(std::move(iceP_i), std::move(responseCb), [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClass::_iceD_opLByteS(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    LByteS iceP_i;
    istr->readAll(iceP_i);
    istr->endEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    auto responseCb = [responseHandler](const LByteS& ret, const LByteS& iceP_o)
    {
        responseHandler->sendResponse(
            [&](Ice::OutputStream* ostr)
            {
                ostr->writeAll(iceP_o, ret);
            });
    };
    try
    {
        this->opLByteSAsync(std::move(iceP_i), std::move(responseCb), [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClass::_iceD_opKByteS(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    KByteS iceP_i;
    istr->readAll(iceP_i);
    istr->endEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    auto responseCb = [responseHandler](const KByteS& ret, const KByteS& iceP_o)
    {
        responseHandler->sendResponse(
            [&](Ice::OutputStream* ostr)
            {
                ostr->writeAll(iceP_o, ret);
            });
    };
    try
    {
        this->opKByteSAsync(std::move(iceP_i), std::move(responseCb), [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClass::_iceD_opQByteS(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    QByteS iceP_i;
    istr->readAll(iceP_i);
    istr->endEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    auto responseCb = [responseHandler](const QByteS& ret, const QByteS& iceP_o)
    {
        responseHandler->sendResponse(
            [&](Ice::OutputStream* ostr)
            {
                ostr->writeAll(iceP_o, ret);
            });
    };
    try
    {
        this->opQByteSAsync(std::move(iceP_i), std::move(responseCb), [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClass::_iceD_opSByteS(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    SByteS iceP_i;
    istr->readAll(iceP_i);
    istr->endEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    auto responseCb = [responseHandler](const SByteS& ret, const SByteS& iceP_o)
    {
        responseHandler->sendResponse(
            [&](Ice::OutputStream* ostr)
            {
                ostr->writeAll(iceP_o, ret);
            });
    };
    try
    {
        this->opSByteSAsync(std::move(iceP_i), std::move(responseCb), [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClass::_iceD_opABoolS(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    ABoolS iceP_i;
    istr->readAll(iceP_i);
    istr->endEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    auto responseCb = [responseHandler](const ABoolS& ret, const ABoolS& iceP_o)
    {
        responseHandler->sendResponse(
            [&](Ice::OutputStream* ostr)
            {
                ostr->writeAll(iceP_o, ret);
            });
    };
    try
    {
        this->opABoolSAsync(std::move(iceP_i), std::move(responseCb), [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClass::_iceD_opLBoolS(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    LBoolS iceP_i;
    istr->readAll(iceP_i);
    istr->endEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    auto responseCb = [responseHandler](const LBoolS& ret, const LBoolS& iceP_o)
    {
        responseHandler->sendResponse(
            [&](Ice::OutputStream* ostr)
            {
                ostr->writeAll(iceP_o, ret);
            });
    };
    try
    {
        this->opLBoolSAsync(std::move(iceP_i), std::move(responseCb), [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClass::_iceD_opKBoolS(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    KBoolS iceP_i;
    istr->readAll(iceP_i);
    istr->endEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    auto responseCb = [responseHandler](const KBoolS& ret, const KBoolS& iceP_o)
    {
        responseHandler->sendResponse(
            [&](Ice::OutputStream* ostr)
            {
                ostr->writeAll(iceP_o, ret);
            });
    };
    try
    {
        this->opKBoolSAsync(std::move(iceP_i), std::move(responseCb), [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClass::_iceD_opQBoolS(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    QBoolS iceP_i;
    istr->readAll(iceP_i);
    istr->endEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    auto responseCb = [responseHandler](const QBoolS& ret, const QBoolS& iceP_o)
    {
        responseHandler->sendResponse(
            [&](Ice::OutputStream* ostr)
            {
                ostr->writeAll(iceP_o, ret);
            });
    };
    try
    {
        this->opQBoolSAsync(std::move(iceP_i), std::move(responseCb), [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClass::_iceD_opSBoolS(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    SBoolS iceP_i;
    istr->readAll(iceP_i);
    istr->endEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    auto responseCb = [responseHandler](const SBoolS& ret, const SBoolS& iceP_o)
    {
        responseHandler->sendResponse(
            [&](Ice::OutputStream* ostr)
            {
                ostr->writeAll(iceP_o, ret);
            });
    };
    try
    {
        this->opSBoolSAsync(std::move(iceP_i), std::move(responseCb), [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClass::_iceD_opAShortS(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    AShortS iceP_i;
    istr->readAll(iceP_i);
    istr->endEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    auto responseCb = [responseHandler](const AShortS& ret, const AShortS& iceP_o)
    {
        responseHandler->sendResponse(
            [&](Ice::OutputStream* ostr)
            {
                ostr->writeAll(iceP_o, ret);
            });
    };
    try
    {
        this->opAShortSAsync(std::move(iceP_i), std::move(responseCb), [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClass::_iceD_opLShortS(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    LShortS iceP_i;
    istr->readAll(iceP_i);
    istr->endEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    auto responseCb = [responseHandler](const LShortS& ret, const LShortS& iceP_o)
    {
        responseHandler->sendResponse(
            [&](Ice::OutputStream* ostr)
            {
                ostr->writeAll(iceP_o, ret);
            });
    };
    try
    {
        this->opLShortSAsync(std::move(iceP_i), std::move(responseCb), [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClass::_iceD_opKShortS(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    KShortS iceP_i;
    istr->readAll(iceP_i);
    istr->endEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    auto responseCb = [responseHandler](const KShortS& ret, const KShortS& iceP_o)
    {
        responseHandler->sendResponse(
            [&](Ice::OutputStream* ostr)
            {
                ostr->writeAll(iceP_o, ret);
            });
    };
    try
    {
        this->opKShortSAsync(std::move(iceP_i), std::move(responseCb), [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClass::_iceD_opQShortS(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    QShortS iceP_i;
    istr->readAll(iceP_i);
    istr->endEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    auto responseCb = [responseHandler](const QShortS& ret, const QShortS& iceP_o)
    {
        responseHandler->sendResponse(
            [&](Ice::OutputStream* ostr)
            {
                ostr->writeAll(iceP_o, ret);
            });
    };
    try
    {
        this->opQShortSAsync(std::move(iceP_i), std::move(responseCb), [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClass::_iceD_opSShortS(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    SShortS iceP_i;
    istr->readAll(iceP_i);
    istr->endEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    auto responseCb = [responseHandler](const SShortS& ret, const SShortS& iceP_o)
    {
        responseHandler->sendResponse(
            [&](Ice::OutputStream* ostr)
            {
                ostr->writeAll(iceP_o, ret);
            });
    };
    try
    {
        this->opSShortSAsync(std::move(iceP_i), std::move(responseCb), [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClass::_iceD_opAIntS(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    AIntS iceP_i;
    istr->readAll(iceP_i);
    istr->endEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    auto responseCb = [responseHandler](const AIntS& ret, const AIntS& iceP_o)
    {
        responseHandler->sendResponse(
            [&](Ice::OutputStream* ostr)
            {
                ostr->writeAll(iceP_o, ret);
            });
    };
    try
    {
        this->opAIntSAsync(std::move(iceP_i), std::move(responseCb), [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClass::_iceD_opLIntS(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    LIntS iceP_i;
    istr->readAll(iceP_i);
    istr->endEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    auto responseCb = [responseHandler](const LIntS& ret, const LIntS& iceP_o)
    {
        responseHandler->sendResponse(
            [&](Ice::OutputStream* ostr)
            {
                ostr->writeAll(iceP_o, ret);
            });
    };
    try
    {
        this->opLIntSAsync(std::move(iceP_i), std::move(responseCb), [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClass::_iceD_opKIntS(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    KIntS iceP_i;
    istr->readAll(iceP_i);
    istr->endEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    auto responseCb = [responseHandler](const KIntS& ret, const KIntS& iceP_o)
    {
        responseHandler->sendResponse(
            [&](Ice::OutputStream* ostr)
            {
                ostr->writeAll(iceP_o, ret);
            });
    };
    try
    {
        this->opKIntSAsync(std::move(iceP_i), std::move(responseCb), [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClass::_iceD_opQIntS(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    QIntS iceP_i;
    istr->readAll(iceP_i);
    istr->endEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    auto responseCb = [responseHandler](const QIntS& ret, const QIntS& iceP_o)
    {
        responseHandler->sendResponse(
            [&](Ice::OutputStream* ostr)
            {
                ostr->writeAll(iceP_o, ret);
            });
    };
    try
    {
        this->opQIntSAsync(std::move(iceP_i), std::move(responseCb), [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClass::_iceD_opSIntS(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    SIntS iceP_i;
    istr->readAll(iceP_i);
    istr->endEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    auto responseCb = [responseHandler](const SIntS& ret, const SIntS& iceP_o)
    {
        responseHandler->sendResponse(
            [&](Ice::OutputStream* ostr)
            {
                ostr->writeAll(iceP_o, ret);
            });
    };
    try
    {
        this->opSIntSAsync(std::move(iceP_i), std::move(responseCb), [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClass::_iceD_opALongS(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    ALongS iceP_i;
    istr->readAll(iceP_i);
    istr->endEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    auto responseCb = [responseHandler](const ALongS& ret, const ALongS& iceP_o)
    {
        responseHandler->sendResponse(
            [&](Ice::OutputStream* ostr)
            {
                ostr->writeAll(iceP_o, ret);
            });
    };
    try
    {
        this->opALongSAsync(std::move(iceP_i), std::move(responseCb), [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClass::_iceD_opLLongS(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    LLongS iceP_i;
    istr->readAll(iceP_i);
    istr->endEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    auto responseCb = [responseHandler](const LLongS& ret, const LLongS& iceP_o)
    {
        responseHandler->sendResponse(
            [&](Ice::OutputStream* ostr)
            {
                ostr->writeAll(iceP_o, ret);
            });
    };
    try
    {
        this->opLLongSAsync(std::move(iceP_i), std::move(responseCb), [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClass::_iceD_opKLongS(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    KLongS iceP_i;
    istr->readAll(iceP_i);
    istr->endEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    auto responseCb = [responseHandler](const KLongS& ret, const KLongS& iceP_o)
    {
        responseHandler->sendResponse(
            [&](Ice::OutputStream* ostr)
            {
                ostr->writeAll(iceP_o, ret);
            });
    };
    try
    {
        this->opKLongSAsync(std::move(iceP_i), std::move(responseCb), [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClass::_iceD_opQLongS(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    QLongS iceP_i;
    istr->readAll(iceP_i);
    istr->endEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    auto responseCb = [responseHandler](const QLongS& ret, const QLongS& iceP_o)
    {
        responseHandler->sendResponse(
            [&](Ice::OutputStream* ostr)
            {
                ostr->writeAll(iceP_o, ret);
            });
    };
    try
    {
        this->opQLongSAsync(std::move(iceP_i), std::move(responseCb), [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClass::_iceD_opSLongS(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    SLongS iceP_i;
    istr->readAll(iceP_i);
    istr->endEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    auto responseCb = [responseHandler](const SLongS& ret, const SLongS& iceP_o)
    {
        responseHandler->sendResponse(
            [&](Ice::OutputStream* ostr)
            {
                ostr->writeAll(iceP_o, ret);
            });
    };
    try
    {
        this->opSLongSAsync(std::move(iceP_i), std::move(responseCb), [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClass::_iceD_opAFloatS(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    AFloatS iceP_i;
    istr->readAll(iceP_i);
    istr->endEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    auto responseCb = [responseHandler](const AFloatS& ret, const AFloatS& iceP_o)
    {
        responseHandler->sendResponse(
            [&](Ice::OutputStream* ostr)
            {
                ostr->writeAll(iceP_o, ret);
            });
    };
    try
    {
        this->opAFloatSAsync(std::move(iceP_i), std::move(responseCb), [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClass::_iceD_opLFloatS(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    LFloatS iceP_i;
    istr->readAll(iceP_i);
    istr->endEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    auto responseCb = [responseHandler](const LFloatS& ret, const LFloatS& iceP_o)
    {
        responseHandler->sendResponse(
            [&](Ice::OutputStream* ostr)
            {
                ostr->writeAll(iceP_o, ret);
            });
    };
    try
    {
        this->opLFloatSAsync(std::move(iceP_i), std::move(responseCb), [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClass::_iceD_opKFloatS(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    KFloatS iceP_i;
    istr->readAll(iceP_i);
    istr->endEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    auto responseCb = [responseHandler](const KFloatS& ret, const KFloatS& iceP_o)
    {
        responseHandler->sendResponse(
            [&](Ice::OutputStream* ostr)
            {
                ostr->writeAll(iceP_o, ret);
            });
    };
    try
    {
        this->opKFloatSAsync(std::move(iceP_i), std::move(responseCb), [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClass::_iceD_opQFloatS(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    QFloatS iceP_i;
    istr->readAll(iceP_i);
    istr->endEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    auto responseCb = [responseHandler](const QFloatS& ret, const QFloatS& iceP_o)
    {
        responseHandler->sendResponse(
            [&](Ice::OutputStream* ostr)
            {
                ostr->writeAll(iceP_o, ret);
            });
    };
    try
    {
        this->opQFloatSAsync(std::move(iceP_i), std::move(responseCb), [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClass::_iceD_opSFloatS(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    SFloatS iceP_i;
    istr->readAll(iceP_i);
    istr->endEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    auto responseCb = [responseHandler](const SFloatS& ret, const SFloatS& iceP_o)
    {
        responseHandler->sendResponse(
            [&](Ice::OutputStream* ostr)
            {
                ostr->writeAll(iceP_o, ret);
            });
    };
    try
    {
        this->opSFloatSAsync(std::move(iceP_i), std::move(responseCb), [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClass::_iceD_opADoubleS(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    ADoubleS iceP_i;
    istr->readAll(iceP_i);
    istr->endEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    auto responseCb = [responseHandler](const ADoubleS& ret, const ADoubleS& iceP_o)
    {
        responseHandler->sendResponse(
            [&](Ice::OutputStream* ostr)
            {
                ostr->writeAll(iceP_o, ret);
            });
    };
    try
    {
        this->opADoubleSAsync(std::move(iceP_i), std::move(responseCb), [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClass::_iceD_opLDoubleS(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    LDoubleS iceP_i;
    istr->readAll(iceP_i);
    istr->endEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    auto responseCb = [responseHandler](const LDoubleS& ret, const LDoubleS& iceP_o)
    {
        responseHandler->sendResponse(
            [&](Ice::OutputStream* ostr)
            {
                ostr->writeAll(iceP_o, ret);
            });
    };
    try
    {
        this->opLDoubleSAsync(std::move(iceP_i), std::move(responseCb), [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClass::_iceD_opKDoubleS(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    KDoubleS iceP_i;
    istr->readAll(iceP_i);
    istr->endEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    auto responseCb = [responseHandler](const KDoubleS& ret, const KDoubleS& iceP_o)
    {
        responseHandler->sendResponse(
            [&](Ice::OutputStream* ostr)
            {
                ostr->writeAll(iceP_o, ret);
            });
    };
    try
    {
        this->opKDoubleSAsync(std::move(iceP_i), std::move(responseCb), [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClass::_iceD_opQDoubleS(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    QDoubleS iceP_i;
    istr->readAll(iceP_i);
    istr->endEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    auto responseCb = [responseHandler](const QDoubleS& ret, const QDoubleS& iceP_o)
    {
        responseHandler->sendResponse(
            [&](Ice::OutputStream* ostr)
            {
                ostr->writeAll(iceP_o, ret);
            });
    };
    try
    {
        this->opQDoubleSAsync(std::move(iceP_i), std::move(responseCb), [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClass::_iceD_opSDoubleS(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    SDoubleS iceP_i;
    istr->readAll(iceP_i);
    istr->endEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    auto responseCb = [responseHandler](const SDoubleS& ret, const SDoubleS& iceP_o)
    {
        responseHandler->sendResponse(
            [&](Ice::OutputStream* ostr)
            {
                ostr->writeAll(iceP_o, ret);
            });
    };
    try
    {
        this->opSDoubleSAsync(std::move(iceP_i), std::move(responseCb), [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClass::_iceD_opAStringS(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    AStringS iceP_i;
    istr->readAll(iceP_i);
    istr->endEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    auto responseCb = [responseHandler](const AStringS& ret, const AStringS& iceP_o)
    {
        responseHandler->sendResponse(
            [&](Ice::OutputStream* ostr)
            {
                ostr->writeAll(iceP_o, ret);
            });
    };
    try
    {
        this->opAStringSAsync(std::move(iceP_i), std::move(responseCb), [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClass::_iceD_opLStringS(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    LStringS iceP_i;
    istr->readAll(iceP_i);
    istr->endEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    auto responseCb = [responseHandler](const LStringS& ret, const LStringS& iceP_o)
    {
        responseHandler->sendResponse(
            [&](Ice::OutputStream* ostr)
            {
                ostr->writeAll(iceP_o, ret);
            });
    };
    try
    {
        this->opLStringSAsync(std::move(iceP_i), std::move(responseCb), [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClass::_iceD_opKStringS(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    KStringS iceP_i;
    istr->readAll(iceP_i);
    istr->endEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    auto responseCb = [responseHandler](const KStringS& ret, const KStringS& iceP_o)
    {
        responseHandler->sendResponse(
            [&](Ice::OutputStream* ostr)
            {
                ostr->writeAll(iceP_o, ret);
            });
    };
    try
    {
        this->opKStringSAsync(std::move(iceP_i), std::move(responseCb), [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClass::_iceD_opQStringS(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    QStringS iceP_i;
    istr->readAll(iceP_i);
    istr->endEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    auto responseCb = [responseHandler](const QStringS& ret, const QStringS& iceP_o)
    {
        responseHandler->sendResponse(
            [&](Ice::OutputStream* ostr)
            {
                ostr->writeAll(iceP_o, ret);
            });
    };
    try
    {
        this->opQStringSAsync(std::move(iceP_i), std::move(responseCb), [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClass::_iceD_opSStringS(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    SStringS iceP_i;
    istr->readAll(iceP_i);
    istr->endEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    auto responseCb = [responseHandler](const SStringS& ret, const SStringS& iceP_o)
    {
        responseHandler->sendResponse(
            [&](Ice::OutputStream* ostr)
            {
                ostr->writeAll(iceP_o, ret);
            });
    };
    try
    {
        this->opSStringSAsync(std::move(iceP_i), std::move(responseCb), [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClass::_iceD_opAObjectS(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    AObjectS iceP_i;
    istr->readAll(iceP_i);
    istr->readPendingValues();
    istr->endEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    auto responseCb = [responseHandler](const AObjectS& ret, const AObjectS& iceP_o)
    {
        responseHandler->sendResponse(
            [&](Ice::OutputStream* ostr)
            {
                ostr->writeAll(iceP_o, ret);
                ostr->writePendingValues();
            });
    };
    try
    {
        this->opAObjectSAsync(std::move(iceP_i), std::move(responseCb), [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClass::_iceD_opLObjectS(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    LObjectS iceP_i;
    istr->readAll(iceP_i);
    istr->readPendingValues();
    istr->endEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    auto responseCb = [responseHandler](const LObjectS& ret, const LObjectS& iceP_o)
    {
        responseHandler->sendResponse(
            [&](Ice::OutputStream* ostr)
            {
                ostr->writeAll(iceP_o, ret);
                ostr->writePendingValues();
            });
    };
    try
    {
        this->opLObjectSAsync(std::move(iceP_i), std::move(responseCb), [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClass::_iceD_opAObjectPrxS(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    AObjectPrxS iceP_i;
    istr->readAll(iceP_i);
    istr->endEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    auto responseCb = [responseHandler](const AObjectPrxS& ret, const AObjectPrxS& iceP_o)
    {
        responseHandler->sendResponse(
            [&](Ice::OutputStream* ostr)
            {
                ostr->writeAll(iceP_o, ret);
            });
    };
    try
    {
        this->opAObjectPrxSAsync(std::move(iceP_i), std::move(responseCb), [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClass::_iceD_opLObjectPrxS(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    LObjectPrxS iceP_i;
    istr->readAll(iceP_i);
    istr->endEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    auto responseCb = [responseHandler](const LObjectPrxS& ret, const LObjectPrxS& iceP_o)
    {
        responseHandler->sendResponse(
            [&](Ice::OutputStream* ostr)
            {
                ostr->writeAll(iceP_o, ret);
            });
    };
    try
    {
        this->opLObjectPrxSAsync(std::move(iceP_i), std::move(responseCb), [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClass::_iceD_opKObjectPrxS(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    KObjectPrxS iceP_i;
    istr->readAll(iceP_i);
    istr->endEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    auto responseCb = [responseHandler](const KObjectPrxS& ret, const KObjectPrxS& iceP_o)
    {
        responseHandler->sendResponse(
            [&](Ice::OutputStream* ostr)
            {
                ostr->writeAll(iceP_o, ret);
            });
    };
    try
    {
        this->opKObjectPrxSAsync(std::move(iceP_i), std::move(responseCb), [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClass::_iceD_opQObjectPrxS(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    QObjectPrxS iceP_i;
    istr->readAll(iceP_i);
    istr->endEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    auto responseCb = [responseHandler](const QObjectPrxS& ret, const QObjectPrxS& iceP_o)
    {
        responseHandler->sendResponse(
            [&](Ice::OutputStream* ostr)
            {
                ostr->writeAll(iceP_o, ret);
            });
    };
    try
    {
        this->opQObjectPrxSAsync(std::move(iceP_i), std::move(responseCb), [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClass::_iceD_opSObjectPrxS(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    SObjectPrxS iceP_i;
    istr->readAll(iceP_i);
    istr->endEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    auto responseCb = [responseHandler](const SObjectPrxS& ret, const SObjectPrxS& iceP_o)
    {
        responseHandler->sendResponse(
            [&](Ice::OutputStream* ostr)
            {
                ostr->writeAll(iceP_o, ret);
            });
    };
    try
    {
        this->opSObjectPrxSAsync(std::move(iceP_i), std::move(responseCb), [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClass::_iceD_opAStructS(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    AStructS iceP_i;
    istr->readAll(iceP_i);
    istr->endEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    auto responseCb = [responseHandler](const AStructS& ret, const AStructS& iceP_o)
    {
        responseHandler->sendResponse(
            [&](Ice::OutputStream* ostr)
            {
                ostr->writeAll(iceP_o, ret);
            });
    };
    try
    {
        this->opAStructSAsync(std::move(iceP_i), std::move(responseCb), [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClass::_iceD_opLStructS(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    LStructS iceP_i;
    istr->readAll(iceP_i);
    istr->endEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    auto responseCb = [responseHandler](const LStructS& ret, const LStructS& iceP_o)
    {
        responseHandler->sendResponse(
            [&](Ice::OutputStream* ostr)
            {
                ostr->writeAll(iceP_o, ret);
            });
    };
    try
    {
        this->opLStructSAsync(std::move(iceP_i), std::move(responseCb), [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClass::_iceD_opKStructS(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    KStructS iceP_i;
    istr->readAll(iceP_i);
    istr->endEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    auto responseCb = [responseHandler](const KStructS& ret, const KStructS& iceP_o)
    {
        responseHandler->sendResponse(
            [&](Ice::OutputStream* ostr)
            {
                ostr->writeAll(iceP_o, ret);
            });
    };
    try
    {
        this->opKStructSAsync(std::move(iceP_i), std::move(responseCb), [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClass::_iceD_opQStructS(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    QStructS iceP_i;
    istr->readAll(iceP_i);
    istr->endEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    auto responseCb = [responseHandler](const QStructS& ret, const QStructS& iceP_o)
    {
        responseHandler->sendResponse(
            [&](Ice::OutputStream* ostr)
            {
                ostr->writeAll(iceP_o, ret);
            });
    };
    try
    {
        this->opQStructSAsync(std::move(iceP_i), std::move(responseCb), [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClass::_iceD_opSStructS(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    SStructS iceP_i;
    istr->readAll(iceP_i);
    istr->endEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    auto responseCb = [responseHandler](const SStructS& ret, const SStructS& iceP_o)
    {
        responseHandler->sendResponse(
            [&](Ice::OutputStream* ostr)
            {
                ostr->writeAll(iceP_o, ret);
            });
    };
    try
    {
        this->opSStructSAsync(std::move(iceP_i), std::move(responseCb), [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClass::_iceD_opAStructSD(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    AStructSD iceP_i;
    istr->readAll(iceP_i);
    istr->endEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    auto responseCb = [responseHandler](const AStructSD& ret, const AStructSD& iceP_o)
    {
        responseHandler->sendResponse(
            [&](Ice::OutputStream* ostr)
            {
                ostr->writeAll(iceP_o, ret);
            });
    };
    try
    {
        this->opAStructSDAsync(std::move(iceP_i), std::move(responseCb), [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClass::_iceD_opLStructSD(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    LStructSD iceP_i;
    istr->readAll(iceP_i);
    istr->endEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    auto responseCb = [responseHandler](const LStructSD& ret, const LStructSD& iceP_o)
    {
        responseHandler->sendResponse(
            [&](Ice::OutputStream* ostr)
            {
                ostr->writeAll(iceP_o, ret);
            });
    };
    try
    {
        this->opLStructSDAsync(std::move(iceP_i), std::move(responseCb), [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClass::_iceD_opKStructSD(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    KStructSD iceP_i;
    istr->readAll(iceP_i);
    istr->endEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    auto responseCb = [responseHandler](const KStructSD& ret, const KStructSD& iceP_o)
    {
        responseHandler->sendResponse(
            [&](Ice::OutputStream* ostr)
            {
                ostr->writeAll(iceP_o, ret);
            });
    };
    try
    {
        this->opKStructSDAsync(std::move(iceP_i), std::move(responseCb), [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClass::_iceD_opQStructSD(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    QStructSD iceP_i;
    istr->readAll(iceP_i);
    istr->endEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    auto responseCb = [responseHandler](const QStructSD& ret, const QStructSD& iceP_o)
    {
        responseHandler->sendResponse(
            [&](Ice::OutputStream* ostr)
            {
                ostr->writeAll(iceP_o, ret);
            });
    };
    try
    {
        this->opQStructSDAsync(std::move(iceP_i), std::move(responseCb), [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClass::_iceD_opSStructSD(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    SStructSD iceP_i;
    istr->readAll(iceP_i);
    istr->endEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    auto responseCb = [responseHandler](const SStructSD& ret, const SStructSD& iceP_o)
    {
        responseHandler->sendResponse(
            [&](Ice::OutputStream* ostr)
            {
                ostr->writeAll(iceP_o, ret);
            });
    };
    try
    {
        this->opSStructSDAsync(std::move(iceP_i), std::move(responseCb), [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClass::_iceD_opACVS(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    ACVS iceP_i;
    istr->readAll(iceP_i);
    istr->readPendingValues();
    istr->endEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    auto responseCb = [responseHandler](const ACVS& ret, const ACVS& iceP_o)
    {
        responseHandler->sendResponse(
            [&](Ice::OutputStream* ostr)
            {
                ostr->writeAll(iceP_o, ret);
                ostr->writePendingValues();
            });
    };
    try
    {
        this->opACVSAsync(std::move(iceP_i), std::move(responseCb), [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClass::_iceD_opLCVS(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    LCVS iceP_i;
    istr->readAll(iceP_i);
    istr->readPendingValues();
    istr->endEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    auto responseCb = [responseHandler](const LCVS& ret, const LCVS& iceP_o)
    {
        responseHandler->sendResponse(
            [&](Ice::OutputStream* ostr)
            {
                ostr->writeAll(iceP_o, ret);
                ostr->writePendingValues();
            });
    };
    try
    {
        this->opLCVSAsync(std::move(iceP_i), std::move(responseCb), [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClass::_iceD_opACRS(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    ACRS iceP_i;
    istr->readAll(iceP_i);
    istr->readPendingValues();
    istr->endEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    auto responseCb = [responseHandler](const ACRS& ret, const ACRS& iceP_o)
    {
        responseHandler->sendResponse(
            [&](Ice::OutputStream* ostr)
            {
                ostr->writeAll(iceP_o, ret);
                ostr->writePendingValues();
            });
    };
    try
    {
        this->opACRSAsync(std::move(iceP_i), std::move(responseCb), [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClass::_iceD_opLCRS(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    LCRS iceP_i;
    istr->readAll(iceP_i);
    istr->readPendingValues();
    istr->endEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    auto responseCb = [responseHandler](const LCRS& ret, const LCRS& iceP_o)
    {
        responseHandler->sendResponse(
            [&](Ice::OutputStream* ostr)
            {
                ostr->writeAll(iceP_o, ret);
                ostr->writePendingValues();
            });
    };
    try
    {
        this->opLCRSAsync(std::move(iceP_i), std::move(responseCb), [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClass::_iceD_opAEnS(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    AEnS iceP_i;
    istr->readAll(iceP_i);
    istr->endEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    auto responseCb = [responseHandler](const AEnS& ret, const AEnS& iceP_o)
    {
        responseHandler->sendResponse(
            [&](Ice::OutputStream* ostr)
            {
                ostr->writeAll(iceP_o, ret);
            });
    };
    try
    {
        this->opAEnSAsync(std::move(iceP_i), std::move(responseCb), [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClass::_iceD_opLEnS(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    LEnS iceP_i;
    istr->readAll(iceP_i);
    istr->endEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    auto responseCb = [responseHandler](const LEnS& ret, const LEnS& iceP_o)
    {
        responseHandler->sendResponse(
            [&](Ice::OutputStream* ostr)
            {
                ostr->writeAll(iceP_o, ret);
            });
    };
    try
    {
        this->opLEnSAsync(std::move(iceP_i), std::move(responseCb), [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClass::_iceD_opKEnS(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    KEnS iceP_i;
    istr->readAll(iceP_i);
    istr->endEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    auto responseCb = [responseHandler](const KEnS& ret, const KEnS& iceP_o)
    {
        responseHandler->sendResponse(
            [&](Ice::OutputStream* ostr)
            {
                ostr->writeAll(iceP_o, ret);
            });
    };
    try
    {
        this->opKEnSAsync(std::move(iceP_i), std::move(responseCb), [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClass::_iceD_opQEnS(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    QEnS iceP_i;
    istr->readAll(iceP_i);
    istr->endEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    auto responseCb = [responseHandler](const QEnS& ret, const QEnS& iceP_o)
    {
        responseHandler->sendResponse(
            [&](Ice::OutputStream* ostr)
            {
                ostr->writeAll(iceP_o, ret);
            });
    };
    try
    {
        this->opQEnSAsync(std::move(iceP_i), std::move(responseCb), [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClass::_iceD_opSEnS(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    SEnS iceP_i;
    istr->readAll(iceP_i);
    istr->endEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    auto responseCb = [responseHandler](const SEnS& ret, const SEnS& iceP_o)
    {
        responseHandler->sendResponse(
            [&](Ice::OutputStream* ostr)
            {
                ostr->writeAll(iceP_o, ret);
            });
    };
    try
    {
        this->opSEnSAsync(std::move(iceP_i), std::move(responseCb), [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClass::_iceD_opAIPrxS(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    AIPrxS iceP_i;
    istr->readAll(iceP_i);
    istr->endEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    auto responseCb = [responseHandler](const AIPrxS& ret, const AIPrxS& iceP_o)
    {
        responseHandler->sendResponse(
            [&](Ice::OutputStream* ostr)
            {
                ostr->writeAll(iceP_o, ret);
            });
    };
    try
    {
        this->opAIPrxSAsync(std::move(iceP_i), std::move(responseCb), [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClass::_iceD_opLIPrxS(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    LIPrxS iceP_i;
    istr->readAll(iceP_i);
    istr->endEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    auto responseCb = [responseHandler](const LIPrxS& ret, const LIPrxS& iceP_o)
    {
        responseHandler->sendResponse(
            [&](Ice::OutputStream* ostr)
            {
                ostr->writeAll(iceP_o, ret);
            });
    };
    try
    {
        this->opLIPrxSAsync(std::move(iceP_i), std::move(responseCb), [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClass::_iceD_opKIPrxS(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    KIPrxS iceP_i;
    istr->readAll(iceP_i);
    istr->endEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    auto responseCb = [responseHandler](const KIPrxS& ret, const KIPrxS& iceP_o)
    {
        responseHandler->sendResponse(
            [&](Ice::OutputStream* ostr)
            {
                ostr->writeAll(iceP_o, ret);
            });
    };
    try
    {
        this->opKIPrxSAsync(std::move(iceP_i), std::move(responseCb), [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClass::_iceD_opQIPrxS(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    QIPrxS iceP_i;
    istr->readAll(iceP_i);
    istr->endEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    auto responseCb = [responseHandler](const QIPrxS& ret, const QIPrxS& iceP_o)
    {
        responseHandler->sendResponse(
            [&](Ice::OutputStream* ostr)
            {
                ostr->writeAll(iceP_o, ret);
            });
    };
    try
    {
        this->opQIPrxSAsync(std::move(iceP_i), std::move(responseCb), [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClass::_iceD_opSIPrxS(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    SIPrxS iceP_i;
    istr->readAll(iceP_i);
    istr->endEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    auto responseCb = [responseHandler](const SIPrxS& ret, const SIPrxS& iceP_o)
    {
        responseHandler->sendResponse(
            [&](Ice::OutputStream* ostr)
            {
                ostr->writeAll(iceP_o, ret);
            });
    };
    try
    {
        this->opSIPrxSAsync(std::move(iceP_i), std::move(responseCb), [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClass::_iceD_opCustomIntS(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    CustomIntS iceP_i;
    istr->readAll(iceP_i);
    istr->endEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    auto responseCb = [responseHandler](const CustomIntS& ret, const CustomIntS& iceP_o)
    {
        responseHandler->sendResponse(
            [&](Ice::OutputStream* ostr)
            {
                ostr->writeAll(iceP_o, ret);
            });
    };
    try
    {
        this->opCustomIntSAsync(std::move(iceP_i), std::move(responseCb), [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClass::_iceD_opCustomCVS(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    CustomCVS iceP_i;
    istr->readAll(iceP_i);
    istr->readPendingValues();
    istr->endEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    auto responseCb = [responseHandler](const CustomCVS& ret, const CustomCVS& iceP_o)
    {
        responseHandler->sendResponse(
            [&](Ice::OutputStream* ostr)
            {
                ostr->writeAll(iceP_o, ret);
                ostr->writePendingValues();
            });
    };
    try
    {
        this->opCustomCVSAsync(std::move(iceP_i), std::move(responseCb), [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClass::_iceD_opCustomIntSS(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    CustomIntSS iceP_i;
    istr->readAll(iceP_i);
    istr->endEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    auto responseCb = [responseHandler](const CustomIntSS& ret, const CustomIntSS& iceP_o)
    {
        responseHandler->sendResponse(
            [&](Ice::OutputStream* ostr)
            {
                ostr->writeAll(iceP_o, ret);
            });
    };
    try
    {
        this->opCustomIntSSAsync(std::move(iceP_i), std::move(responseCb), [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClass::_iceD_opCustomCVSS(
    Ice::IncomingRequest& request,
    std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    _iceCheckMode(Ice::OperationMode::Normal, request.current().mode);
    auto istr = &request.inputStream();
    istr->startEncapsulation();
    CustomCVSS iceP_i;
    istr->readAll(iceP_i);
    istr->readPendingValues();
    istr->endEncapsulation();
    auto responseHandler = std::make_shared<IceInternal::AsyncResponseHandler>(std::move(sendResponse), request.current());
    auto responseCb = [responseHandler](const CustomCVSS& ret, const CustomCVSS& iceP_o)
    {
        responseHandler->sendResponse(
            [&](Ice::OutputStream* ostr)
            {
                ostr->writeAll(iceP_o, ret);
                ostr->writePendingValues();
            });
    };
    try
    {
        this->opCustomCVSSAsync(std::move(iceP_i), std::move(responseCb), [responseHandler](std::exception_ptr ex) { responseHandler->sendException(ex); }, responseHandler->current());
    }
    catch (...)
    {
        responseHandler->sendException(std::current_exception());
    }
}
/// \endcond

void
Test::MyClass::dispatch(Ice::IncomingRequest& request, std::function<void(Ice::OutgoingResponse)> sendResponse)
{
    static constexpr std::array<std::string_view, 80> allOperations{"ice_id", "ice_ids", "ice_isA", "ice_ping", "opABoolS", "opAByteS", "opACRS", "opACVS", "opADoubleS", "opAEnS", "opAFloatS", "opAIPrxS", "opAIntS", "opALongS", "opAObjectPrxS", "opAObjectS", "opAShortS", "opAStringS", "opAStructS", "opAStructSD", "opCustomCVS", "opCustomCVSS", "opCustomIntS", "opCustomIntSS", "opKBoolS", "opKByteS", "opKDoubleS", "opKEnS", "opKFloatS", "opKIPrxS", "opKIntS", "opKLongS", "opKObjectPrxS", "opKShortS", "opKStringS", "opKStructS", "opKStructSD", "opLBoolS", "opLByteS", "opLCRS", "opLCVS", "opLDoubleS", "opLEnS", "opLFloatS", "opLIPrxS", "opLIntS", "opLLongS", "opLObjectPrxS", "opLObjectS", "opLShortS", "opLStringS", "opLStructS", "opLStructSD", "opQBoolS", "opQByteS", "opQDoubleS", "opQEnS", "opQFloatS", "opQIPrxS", "opQIntS", "opQLongS", "opQObjectPrxS", "opQShortS", "opQStringS", "opQStructS", "opQStructSD", "opSBoolS", "opSByteS", "opSDoubleS", "opSEnS", "opSFloatS", "opSIPrxS", "opSIntS", "opSLongS", "opSObjectPrxS", "opSShortS", "opSStringS", "opSStructS", "opSStructSD", "shutdown"};

    const Ice::Current& current = request.current();
    auto r = std::equal_range(allOperations.begin(), allOperations.end(), current.operation); // NOLINT(modernize-use-ranges)
    if (r.first == r.second)
    {
        sendResponse(Ice::makeOutgoingResponse(std::make_exception_ptr(Ice::OperationNotExistException{__FILE__, __LINE__}), current));
        return;
    }

    switch (r.first - allOperations.begin())
    {
        case 0:
        {
            _iceD_ice_id(request, std::move(sendResponse));
            break;
        }
        case 1:
        {
            _iceD_ice_ids(request, std::move(sendResponse));
            break;
        }
        case 2:
        {
            _iceD_ice_isA(request, std::move(sendResponse));
            break;
        }
        case 3:
        {
            _iceD_ice_ping(request, std::move(sendResponse));
            break;
        }
        case 4:
        {
            _iceD_opABoolS(request, std::move(sendResponse));
            break;
        }
        case 5:
        {
            _iceD_opAByteS(request, std::move(sendResponse));
            break;
        }
        case 6:
        {
            _iceD_opACRS(request, std::move(sendResponse));
            break;
        }
        case 7:
        {
            _iceD_opACVS(request, std::move(sendResponse));
            break;
        }
        case 8:
        {
            _iceD_opADoubleS(request, std::move(sendResponse));
            break;
        }
        case 9:
        {
            _iceD_opAEnS(request, std::move(sendResponse));
            break;
        }
        case 10:
        {
            _iceD_opAFloatS(request, std::move(sendResponse));
            break;
        }
        case 11:
        {
            _iceD_opAIPrxS(request, std::move(sendResponse));
            break;
        }
        case 12:
        {
            _iceD_opAIntS(request, std::move(sendResponse));
            break;
        }
        case 13:
        {
            _iceD_opALongS(request, std::move(sendResponse));
            break;
        }
        case 14:
        {
            _iceD_opAObjectPrxS(request, std::move(sendResponse));
            break;
        }
        case 15:
        {
            _iceD_opAObjectS(request, std::move(sendResponse));
            break;
        }
        case 16:
        {
            _iceD_opAShortS(request, std::move(sendResponse));
            break;
        }
        case 17:
        {
            _iceD_opAStringS(request, std::move(sendResponse));
            break;
        }
        case 18:
        {
            _iceD_opAStructS(request, std::move(sendResponse));
            break;
        }
        case 19:
        {
            _iceD_opAStructSD(request, std::move(sendResponse));
            break;
        }
        case 20:
        {
            _iceD_opCustomCVS(request, std::move(sendResponse));
            break;
        }
        case 21:
        {
            _iceD_opCustomCVSS(request, std::move(sendResponse));
            break;
        }
        case 22:
        {
            _iceD_opCustomIntS(request, std::move(sendResponse));
            break;
        }
        case 23:
        {
            _iceD_opCustomIntSS(request, std::move(sendResponse));
            break;
        }
        case 24:
        {
            _iceD_opKBoolS(request, std::move(sendResponse));
            break;
        }
        case 25:
        {
            _iceD_opKByteS(request, std::move(sendResponse));
            break;
        }
        case 26:
        {
            _iceD_opKDoubleS(request, std::move(sendResponse));
            break;
        }
        case 27:
        {
            _iceD_opKEnS(request, std::move(sendResponse));
            break;
        }
        case 28:
        {
            _iceD_opKFloatS(request, std::move(sendResponse));
            break;
        }
        case 29:
        {
            _iceD_opKIPrxS(request, std::move(sendResponse));
            break;
        }
        case 30:
        {
            _iceD_opKIntS(request, std::move(sendResponse));
            break;
        }
        case 31:
        {
            _iceD_opKLongS(request, std::move(sendResponse));
            break;
        }
        case 32:
        {
            _iceD_opKObjectPrxS(request, std::move(sendResponse));
            break;
        }
        case 33:
        {
            _iceD_opKShortS(request, std::move(sendResponse));
            break;
        }
        case 34:
        {
            _iceD_opKStringS(request, std::move(sendResponse));
            break;
        }
        case 35:
        {
            _iceD_opKStructS(request, std::move(sendResponse));
            break;
        }
        case 36:
        {
            _iceD_opKStructSD(request, std::move(sendResponse));
            break;
        }
        case 37:
        {
            _iceD_opLBoolS(request, std::move(sendResponse));
            break;
        }
        case 38:
        {
            _iceD_opLByteS(request, std::move(sendResponse));
            break;
        }
        case 39:
        {
            _iceD_opLCRS(request, std::move(sendResponse));
            break;
        }
        case 40:
        {
            _iceD_opLCVS(request, std::move(sendResponse));
            break;
        }
        case 41:
        {
            _iceD_opLDoubleS(request, std::move(sendResponse));
            break;
        }
        case 42:
        {
            _iceD_opLEnS(request, std::move(sendResponse));
            break;
        }
        case 43:
        {
            _iceD_opLFloatS(request, std::move(sendResponse));
            break;
        }
        case 44:
        {
            _iceD_opLIPrxS(request, std::move(sendResponse));
            break;
        }
        case 45:
        {
            _iceD_opLIntS(request, std::move(sendResponse));
            break;
        }
        case 46:
        {
            _iceD_opLLongS(request, std::move(sendResponse));
            break;
        }
        case 47:
        {
            _iceD_opLObjectPrxS(request, std::move(sendResponse));
            break;
        }
        case 48:
        {
            _iceD_opLObjectS(request, std::move(sendResponse));
            break;
        }
        case 49:
        {
            _iceD_opLShortS(request, std::move(sendResponse));
            break;
        }
        case 50:
        {
            _iceD_opLStringS(request, std::move(sendResponse));
            break;
        }
        case 51:
        {
            _iceD_opLStructS(request, std::move(sendResponse));
            break;
        }
        case 52:
        {
            _iceD_opLStructSD(request, std::move(sendResponse));
            break;
        }
        case 53:
        {
            _iceD_opQBoolS(request, std::move(sendResponse));
            break;
        }
        case 54:
        {
            _iceD_opQByteS(request, std::move(sendResponse));
            break;
        }
        case 55:
        {
            _iceD_opQDoubleS(request, std::move(sendResponse));
            break;
        }
        case 56:
        {
            _iceD_opQEnS(request, std::move(sendResponse));
            break;
        }
        case 57:
        {
            _iceD_opQFloatS(request, std::move(sendResponse));
            break;
        }
        case 58:
        {
            _iceD_opQIPrxS(request, std::move(sendResponse));
            break;
        }
        case 59:
        {
            _iceD_opQIntS(request, std::move(sendResponse));
            break;
        }
        case 60:
        {
            _iceD_opQLongS(request, std::move(sendResponse));
            break;
        }
        case 61:
        {
            _iceD_opQObjectPrxS(request, std::move(sendResponse));
            break;
        }
        case 62:
        {
            _iceD_opQShortS(request, std::move(sendResponse));
            break;
        }
        case 63:
        {
            _iceD_opQStringS(request, std::move(sendResponse));
            break;
        }
        case 64:
        {
            _iceD_opQStructS(request, std::move(sendResponse));
            break;
        }
        case 65:
        {
            _iceD_opQStructSD(request, std::move(sendResponse));
            break;
        }
        case 66:
        {
            _iceD_opSBoolS(request, std::move(sendResponse));
            break;
        }
        case 67:
        {
            _iceD_opSByteS(request, std::move(sendResponse));
            break;
        }
        case 68:
        {
            _iceD_opSDoubleS(request, std::move(sendResponse));
            break;
        }
        case 69:
        {
            _iceD_opSEnS(request, std::move(sendResponse));
            break;
        }
        case 70:
        {
            _iceD_opSFloatS(request, std::move(sendResponse));
            break;
        }
        case 71:
        {
            _iceD_opSIPrxS(request, std::move(sendResponse));
            break;
        }
        case 72:
        {
            _iceD_opSIntS(request, std::move(sendResponse));
            break;
        }
        case 73:
        {
            _iceD_opSLongS(request, std::move(sendResponse));
            break;
        }
        case 74:
        {
            _iceD_opSObjectPrxS(request, std::move(sendResponse));
            break;
        }
        case 75:
        {
            _iceD_opSShortS(request, std::move(sendResponse));
            break;
        }
        case 76:
        {
            _iceD_opSStringS(request, std::move(sendResponse));
            break;
        }
        case 77:
        {
            _iceD_opSStructS(request, std::move(sendResponse));
            break;
        }
        case 78:
        {
            _iceD_opSStructSD(request, std::move(sendResponse));
            break;
        }
        case 79:
        {
            _iceD_shutdown(request, std::move(sendResponse));
            break;
        }
        default:
        {
            assert(false);
            sendResponse(Ice::makeOutgoingResponse(std::make_exception_ptr(Ice::OperationNotExistException{__FILE__, __LINE__}), current));
        }
    }
}
