//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.7.9
//
// <auto-generated>
//
// Generated from file `Test.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#include <Test.h>
#include <IceUtil/PushDisableWarnings.h>
#include <Ice/LocalException.h>
#include <Ice/ValueFactory.h>
#include <Ice/OutgoingAsync.h>
#include <Ice/InputStream.h>
#include <Ice/OutputStream.h>
#include <Ice/LocalException.h>
#include <IceUtil/PopDisableWarnings.h>

#if defined(_MSC_VER)
#   pragma warning(disable:4458) // declaration of ... hides class member
#elif defined(__clang__)
#   pragma clang diagnostic ignored "-Wshadow"
#elif defined(__GNUC__)
#   pragma GCC diagnostic ignored "-Wshadow"
#endif

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 307
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 >= 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 9
#       error Ice patch level mismatch!
#   endif
#endif

#ifdef ICE_CPP11_MAPPING // C++11 mapping

namespace
{

const ::IceInternal::DefaultValueFactoryInit<::Test::CV> iceC_Test_CV_init("::Test::CV");

const ::std::string iceC_Test_I_ids[2] =
{
    "::Ice::Object",
    "::Test::I"
};
const ::std::string iceC_Test_I_ops[] =
{
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};

const ::IceInternal::DefaultValueFactoryInit<::Test::CR> iceC_Test_CR_init("::Test::CR");

const ::std::string iceC_Test_MyClass_ids[2] =
{
    "::Ice::Object",
    "::Test::MyClass"
};
const ::std::string iceC_Test_MyClass_ops[] =
{
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "opABoolS",
    "opAByteS",
    "opACRS",
    "opACVS",
    "opADoubleS",
    "opAEnS",
    "opAFloatS",
    "opAIPrxS",
    "opAIntS",
    "opALongS",
    "opAObjectPrxS",
    "opAObjectS",
    "opAShortS",
    "opAStringS",
    "opAStructS",
    "opAStructSD",
    "opCustomCVS",
    "opCustomCVSS",
    "opCustomIntS",
    "opCustomIntSS",
    "opKBoolS",
    "opKByteS",
    "opKDoubleS",
    "opKEnS",
    "opKFloatS",
    "opKIPrxS",
    "opKIntS",
    "opKLongS",
    "opKObjectPrxS",
    "opKShortS",
    "opKStringS",
    "opKStructS",
    "opKStructSD",
    "opLBoolS",
    "opLByteS",
    "opLCRS",
    "opLCVS",
    "opLDoubleS",
    "opLEnS",
    "opLFloatS",
    "opLIPrxS",
    "opLIntS",
    "opLLongS",
    "opLObjectPrxS",
    "opLObjectS",
    "opLShortS",
    "opLStringS",
    "opLStructS",
    "opLStructSD",
    "opQBoolS",
    "opQByteS",
    "opQDoubleS",
    "opQEnS",
    "opQFloatS",
    "opQIPrxS",
    "opQIntS",
    "opQLongS",
    "opQObjectPrxS",
    "opQShortS",
    "opQStringS",
    "opQStructS",
    "opQStructSD",
    "opSBoolS",
    "opSByteS",
    "opSDoubleS",
    "opSEnS",
    "opSFloatS",
    "opSIPrxS",
    "opSIntS",
    "opSLongS",
    "opSObjectPrxS",
    "opSShortS",
    "opSStringS",
    "opSStructS",
    "opSStructSD",
    "opSerialLargeCSharp",
    "opSerialSmallCSharp",
    "opSerialStructCSharp",
    "shutdown"
};
const ::std::string iceC_Test_MyClass_shutdown_name = "shutdown";
const ::std::string iceC_Test_MyClass_opAByteS_name = "opAByteS";
const ::std::string iceC_Test_MyClass_opLByteS_name = "opLByteS";
const ::std::string iceC_Test_MyClass_opKByteS_name = "opKByteS";
const ::std::string iceC_Test_MyClass_opQByteS_name = "opQByteS";
const ::std::string iceC_Test_MyClass_opSByteS_name = "opSByteS";
const ::std::string iceC_Test_MyClass_opABoolS_name = "opABoolS";
const ::std::string iceC_Test_MyClass_opLBoolS_name = "opLBoolS";
const ::std::string iceC_Test_MyClass_opKBoolS_name = "opKBoolS";
const ::std::string iceC_Test_MyClass_opQBoolS_name = "opQBoolS";
const ::std::string iceC_Test_MyClass_opSBoolS_name = "opSBoolS";
const ::std::string iceC_Test_MyClass_opAShortS_name = "opAShortS";
const ::std::string iceC_Test_MyClass_opLShortS_name = "opLShortS";
const ::std::string iceC_Test_MyClass_opKShortS_name = "opKShortS";
const ::std::string iceC_Test_MyClass_opQShortS_name = "opQShortS";
const ::std::string iceC_Test_MyClass_opSShortS_name = "opSShortS";
const ::std::string iceC_Test_MyClass_opAIntS_name = "opAIntS";
const ::std::string iceC_Test_MyClass_opLIntS_name = "opLIntS";
const ::std::string iceC_Test_MyClass_opKIntS_name = "opKIntS";
const ::std::string iceC_Test_MyClass_opQIntS_name = "opQIntS";
const ::std::string iceC_Test_MyClass_opSIntS_name = "opSIntS";
const ::std::string iceC_Test_MyClass_opALongS_name = "opALongS";
const ::std::string iceC_Test_MyClass_opLLongS_name = "opLLongS";
const ::std::string iceC_Test_MyClass_opKLongS_name = "opKLongS";
const ::std::string iceC_Test_MyClass_opQLongS_name = "opQLongS";
const ::std::string iceC_Test_MyClass_opSLongS_name = "opSLongS";
const ::std::string iceC_Test_MyClass_opAFloatS_name = "opAFloatS";
const ::std::string iceC_Test_MyClass_opLFloatS_name = "opLFloatS";
const ::std::string iceC_Test_MyClass_opKFloatS_name = "opKFloatS";
const ::std::string iceC_Test_MyClass_opQFloatS_name = "opQFloatS";
const ::std::string iceC_Test_MyClass_opSFloatS_name = "opSFloatS";
const ::std::string iceC_Test_MyClass_opADoubleS_name = "opADoubleS";
const ::std::string iceC_Test_MyClass_opLDoubleS_name = "opLDoubleS";
const ::std::string iceC_Test_MyClass_opKDoubleS_name = "opKDoubleS";
const ::std::string iceC_Test_MyClass_opQDoubleS_name = "opQDoubleS";
const ::std::string iceC_Test_MyClass_opSDoubleS_name = "opSDoubleS";
const ::std::string iceC_Test_MyClass_opAStringS_name = "opAStringS";
const ::std::string iceC_Test_MyClass_opLStringS_name = "opLStringS";
const ::std::string iceC_Test_MyClass_opKStringS_name = "opKStringS";
const ::std::string iceC_Test_MyClass_opQStringS_name = "opQStringS";
const ::std::string iceC_Test_MyClass_opSStringS_name = "opSStringS";
const ::std::string iceC_Test_MyClass_opAObjectS_name = "opAObjectS";
const ::std::string iceC_Test_MyClass_opLObjectS_name = "opLObjectS";
const ::std::string iceC_Test_MyClass_opAObjectPrxS_name = "opAObjectPrxS";
const ::std::string iceC_Test_MyClass_opLObjectPrxS_name = "opLObjectPrxS";
const ::std::string iceC_Test_MyClass_opKObjectPrxS_name = "opKObjectPrxS";
const ::std::string iceC_Test_MyClass_opQObjectPrxS_name = "opQObjectPrxS";
const ::std::string iceC_Test_MyClass_opSObjectPrxS_name = "opSObjectPrxS";
const ::std::string iceC_Test_MyClass_opAStructS_name = "opAStructS";
const ::std::string iceC_Test_MyClass_opLStructS_name = "opLStructS";
const ::std::string iceC_Test_MyClass_opKStructS_name = "opKStructS";
const ::std::string iceC_Test_MyClass_opQStructS_name = "opQStructS";
const ::std::string iceC_Test_MyClass_opSStructS_name = "opSStructS";
const ::std::string iceC_Test_MyClass_opAStructSD_name = "opAStructSD";
const ::std::string iceC_Test_MyClass_opLStructSD_name = "opLStructSD";
const ::std::string iceC_Test_MyClass_opKStructSD_name = "opKStructSD";
const ::std::string iceC_Test_MyClass_opQStructSD_name = "opQStructSD";
const ::std::string iceC_Test_MyClass_opSStructSD_name = "opSStructSD";
const ::std::string iceC_Test_MyClass_opACVS_name = "opACVS";
const ::std::string iceC_Test_MyClass_opLCVS_name = "opLCVS";
const ::std::string iceC_Test_MyClass_opACRS_name = "opACRS";
const ::std::string iceC_Test_MyClass_opLCRS_name = "opLCRS";
const ::std::string iceC_Test_MyClass_opAEnS_name = "opAEnS";
const ::std::string iceC_Test_MyClass_opLEnS_name = "opLEnS";
const ::std::string iceC_Test_MyClass_opKEnS_name = "opKEnS";
const ::std::string iceC_Test_MyClass_opQEnS_name = "opQEnS";
const ::std::string iceC_Test_MyClass_opSEnS_name = "opSEnS";
const ::std::string iceC_Test_MyClass_opAIPrxS_name = "opAIPrxS";
const ::std::string iceC_Test_MyClass_opLIPrxS_name = "opLIPrxS";
const ::std::string iceC_Test_MyClass_opKIPrxS_name = "opKIPrxS";
const ::std::string iceC_Test_MyClass_opQIPrxS_name = "opQIPrxS";
const ::std::string iceC_Test_MyClass_opSIPrxS_name = "opSIPrxS";
const ::std::string iceC_Test_MyClass_opCustomIntS_name = "opCustomIntS";
const ::std::string iceC_Test_MyClass_opCustomCVS_name = "opCustomCVS";
const ::std::string iceC_Test_MyClass_opCustomIntSS_name = "opCustomIntSS";
const ::std::string iceC_Test_MyClass_opCustomCVSS_name = "opCustomCVSS";
const ::std::string iceC_Test_MyClass_opSerialSmallCSharp_name = "opSerialSmallCSharp";
const ::std::string iceC_Test_MyClass_opSerialLargeCSharp_name = "opSerialLargeCSharp";
const ::std::string iceC_Test_MyClass_opSerialStructCSharp_name = "opSerialStructCSharp";

const ::IceInternal::DefaultUserExceptionFactoryInit<::Test::Bar> iceC_Test_Bar_init("::Test::Bar");

const ::IceInternal::DefaultValueFactoryInit<::Test::Baz> iceC_Test_Baz_init("::Test::Baz");

}

Test::Bar::~Bar()
{
}

const ::std::string&
Test::Bar::ice_staticId()
{
    static const ::std::string typeId = "::Test::Bar";
    return typeId;
}

bool
Test::I::ice_isA(::std::string s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_I_ids, iceC_Test_I_ids + 2, s);
}

::std::vector<::std::string>
Test::I::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector<::std::string>(&iceC_Test_I_ids[0], &iceC_Test_I_ids[2]);
}

::std::string
Test::I::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::I::ice_staticId()
{
    static const ::std::string typeId = "::Test::I";
    return typeId;
}

bool
Test::MyClass::ice_isA(::std::string s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_MyClass_ids, iceC_Test_MyClass_ids + 2, s);
}

::std::vector<::std::string>
Test::MyClass::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector<::std::string>(&iceC_Test_MyClass_ids[0], &iceC_Test_MyClass_ids[2]);
}

::std::string
Test::MyClass::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::MyClass::ice_staticId()
{
    static const ::std::string typeId = "::Test::MyClass";
    return typeId;
}

/// \cond INTERNAL
bool
Test::MyClass::_iceD_shutdown(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    this->shutdown(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opAByteS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    AByteS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    AByteS iceP_o;
    AByteS ret = this->opAByteS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opLByteS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    LByteS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    LByteS iceP_o;
    LByteS ret = this->opLByteS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opKByteS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    KByteS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    KByteS iceP_o;
    KByteS ret = this->opKByteS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opQByteS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    QByteS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    QByteS iceP_o;
    QByteS ret = this->opQByteS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opSByteS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    SByteS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    SByteS iceP_o;
    SByteS ret = this->opSByteS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opABoolS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ABoolS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    ABoolS iceP_o;
    ABoolS ret = this->opABoolS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opLBoolS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    LBoolS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    LBoolS iceP_o;
    LBoolS ret = this->opLBoolS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opKBoolS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    KBoolS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    KBoolS iceP_o;
    KBoolS ret = this->opKBoolS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opQBoolS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    QBoolS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    QBoolS iceP_o;
    QBoolS ret = this->opQBoolS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opSBoolS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    SBoolS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    SBoolS iceP_o;
    SBoolS ret = this->opSBoolS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opAShortS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    AShortS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    AShortS iceP_o;
    AShortS ret = this->opAShortS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opLShortS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    LShortS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    LShortS iceP_o;
    LShortS ret = this->opLShortS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opKShortS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    KShortS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    KShortS iceP_o;
    KShortS ret = this->opKShortS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opQShortS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    QShortS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    QShortS iceP_o;
    QShortS ret = this->opQShortS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opSShortS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    SShortS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    SShortS iceP_o;
    SShortS ret = this->opSShortS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opAIntS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    AIntS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    AIntS iceP_o;
    AIntS ret = this->opAIntS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opLIntS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    LIntS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    LIntS iceP_o;
    LIntS ret = this->opLIntS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opKIntS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    KIntS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    KIntS iceP_o;
    KIntS ret = this->opKIntS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opQIntS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    QIntS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    QIntS iceP_o;
    QIntS ret = this->opQIntS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opSIntS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    SIntS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    SIntS iceP_o;
    SIntS ret = this->opSIntS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opALongS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ALongS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    ALongS iceP_o;
    ALongS ret = this->opALongS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opLLongS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    LLongS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    LLongS iceP_o;
    LLongS ret = this->opLLongS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opKLongS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    KLongS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    KLongS iceP_o;
    KLongS ret = this->opKLongS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opQLongS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    QLongS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    QLongS iceP_o;
    QLongS ret = this->opQLongS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opSLongS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    SLongS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    SLongS iceP_o;
    SLongS ret = this->opSLongS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opAFloatS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    AFloatS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    AFloatS iceP_o;
    AFloatS ret = this->opAFloatS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opLFloatS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    LFloatS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    LFloatS iceP_o;
    LFloatS ret = this->opLFloatS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opKFloatS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    KFloatS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    KFloatS iceP_o;
    KFloatS ret = this->opKFloatS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opQFloatS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    QFloatS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    QFloatS iceP_o;
    QFloatS ret = this->opQFloatS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opSFloatS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    SFloatS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    SFloatS iceP_o;
    SFloatS ret = this->opSFloatS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opADoubleS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ADoubleS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    ADoubleS iceP_o;
    ADoubleS ret = this->opADoubleS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opLDoubleS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    LDoubleS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    LDoubleS iceP_o;
    LDoubleS ret = this->opLDoubleS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opKDoubleS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    KDoubleS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    KDoubleS iceP_o;
    KDoubleS ret = this->opKDoubleS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opQDoubleS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    QDoubleS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    QDoubleS iceP_o;
    QDoubleS ret = this->opQDoubleS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opSDoubleS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    SDoubleS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    SDoubleS iceP_o;
    SDoubleS ret = this->opSDoubleS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opAStringS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    AStringS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    AStringS iceP_o;
    AStringS ret = this->opAStringS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opLStringS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    LStringS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    LStringS iceP_o;
    LStringS ret = this->opLStringS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opKStringS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    KStringS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    KStringS iceP_o;
    KStringS ret = this->opKStringS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opQStringS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    QStringS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    QStringS iceP_o;
    QStringS ret = this->opQStringS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opSStringS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    SStringS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    SStringS iceP_o;
    SStringS ret = this->opSStringS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opAObjectS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    AObjectS iceP_i;
    istr->readAll(iceP_i);
    istr->readPendingValues();
    inS.endReadParams();
    AObjectS iceP_o;
    AObjectS ret = this->opAObjectS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opLObjectS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    LObjectS iceP_i;
    istr->readAll(iceP_i);
    istr->readPendingValues();
    inS.endReadParams();
    LObjectS iceP_o;
    LObjectS ret = this->opLObjectS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opAObjectPrxS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    AObjectPrxS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    AObjectPrxS iceP_o;
    AObjectPrxS ret = this->opAObjectPrxS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opLObjectPrxS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    LObjectPrxS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    LObjectPrxS iceP_o;
    LObjectPrxS ret = this->opLObjectPrxS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opKObjectPrxS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    KObjectPrxS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    KObjectPrxS iceP_o;
    KObjectPrxS ret = this->opKObjectPrxS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opQObjectPrxS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    QObjectPrxS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    QObjectPrxS iceP_o;
    QObjectPrxS ret = this->opQObjectPrxS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opSObjectPrxS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    SObjectPrxS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    SObjectPrxS iceP_o;
    SObjectPrxS ret = this->opSObjectPrxS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opAStructS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    AStructS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    AStructS iceP_o;
    AStructS ret = this->opAStructS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opLStructS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    LStructS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    LStructS iceP_o;
    LStructS ret = this->opLStructS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opKStructS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    KStructS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    KStructS iceP_o;
    KStructS ret = this->opKStructS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opQStructS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    QStructS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    QStructS iceP_o;
    QStructS ret = this->opQStructS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opSStructS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    SStructS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    SStructS iceP_o;
    SStructS ret = this->opSStructS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opAStructSD(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    AStructSD iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    AStructSD iceP_o;
    AStructSD ret = this->opAStructSD(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opLStructSD(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    LStructSD iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    LStructSD iceP_o;
    LStructSD ret = this->opLStructSD(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opKStructSD(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    KStructSD iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    KStructSD iceP_o;
    KStructSD ret = this->opKStructSD(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opQStructSD(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    QStructSD iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    QStructSD iceP_o;
    QStructSD ret = this->opQStructSD(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opSStructSD(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    SStructSD iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    SStructSD iceP_o;
    SStructSD ret = this->opSStructSD(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opACVS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ACVS iceP_i;
    istr->readAll(iceP_i);
    istr->readPendingValues();
    inS.endReadParams();
    ACVS iceP_o;
    ACVS ret = this->opACVS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opLCVS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    LCVS iceP_i;
    istr->readAll(iceP_i);
    istr->readPendingValues();
    inS.endReadParams();
    LCVS iceP_o;
    LCVS ret = this->opLCVS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opACRS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ACRS iceP_i;
    istr->readAll(iceP_i);
    istr->readPendingValues();
    inS.endReadParams();
    ACRS iceP_o;
    ACRS ret = this->opACRS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opLCRS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    LCRS iceP_i;
    istr->readAll(iceP_i);
    istr->readPendingValues();
    inS.endReadParams();
    LCRS iceP_o;
    LCRS ret = this->opLCRS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opAEnS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    AEnS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    AEnS iceP_o;
    AEnS ret = this->opAEnS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opLEnS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    LEnS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    LEnS iceP_o;
    LEnS ret = this->opLEnS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opKEnS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    KEnS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    KEnS iceP_o;
    KEnS ret = this->opKEnS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opQEnS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    QEnS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    QEnS iceP_o;
    QEnS ret = this->opQEnS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opSEnS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    SEnS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    SEnS iceP_o;
    SEnS ret = this->opSEnS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opAIPrxS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    AIPrxS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    AIPrxS iceP_o;
    AIPrxS ret = this->opAIPrxS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opLIPrxS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    LIPrxS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    LIPrxS iceP_o;
    LIPrxS ret = this->opLIPrxS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opKIPrxS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    KIPrxS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    KIPrxS iceP_o;
    KIPrxS ret = this->opKIPrxS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opQIPrxS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    QIPrxS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    QIPrxS iceP_o;
    QIPrxS ret = this->opQIPrxS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opSIPrxS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    SIPrxS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    SIPrxS iceP_o;
    SIPrxS ret = this->opSIPrxS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opCustomIntS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    CustomIntS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    CustomIntS iceP_o;
    CustomIntS ret = this->opCustomIntS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opCustomCVS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    CustomCVS iceP_i;
    istr->readAll(iceP_i);
    istr->readPendingValues();
    inS.endReadParams();
    CustomCVS iceP_o;
    CustomCVS ret = this->opCustomCVS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opCustomIntSS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    CustomIntSS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    CustomIntSS iceP_o;
    CustomIntSS ret = this->opCustomIntSS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opCustomCVSS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    CustomCVSS iceP_i;
    istr->readAll(iceP_i);
    istr->readPendingValues();
    inS.endReadParams();
    CustomCVSS iceP_o;
    CustomCVSS ret = this->opCustomCVSS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opSerialSmallCSharp(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    SerialSmall iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    SerialSmall iceP_o;
    SerialSmall ret = this->opSerialSmallCSharp(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opSerialLargeCSharp(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    SerialLarge iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    SerialLarge iceP_o;
    SerialLarge ret = this->opSerialLargeCSharp(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opSerialStructCSharp(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    SerialStruct iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    SerialStruct iceP_o;
    SerialStruct ret = this->opSerialStructCSharp(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_Test_MyClass_ops, iceC_Test_MyClass_ops + 83, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_Test_MyClass_ops)
    {
        case 0:
        {
            return _iceD_ice_id(in, current);
        }
        case 1:
        {
            return _iceD_ice_ids(in, current);
        }
        case 2:
        {
            return _iceD_ice_isA(in, current);
        }
        case 3:
        {
            return _iceD_ice_ping(in, current);
        }
        case 4:
        {
            return _iceD_opABoolS(in, current);
        }
        case 5:
        {
            return _iceD_opAByteS(in, current);
        }
        case 6:
        {
            return _iceD_opACRS(in, current);
        }
        case 7:
        {
            return _iceD_opACVS(in, current);
        }
        case 8:
        {
            return _iceD_opADoubleS(in, current);
        }
        case 9:
        {
            return _iceD_opAEnS(in, current);
        }
        case 10:
        {
            return _iceD_opAFloatS(in, current);
        }
        case 11:
        {
            return _iceD_opAIPrxS(in, current);
        }
        case 12:
        {
            return _iceD_opAIntS(in, current);
        }
        case 13:
        {
            return _iceD_opALongS(in, current);
        }
        case 14:
        {
            return _iceD_opAObjectPrxS(in, current);
        }
        case 15:
        {
            return _iceD_opAObjectS(in, current);
        }
        case 16:
        {
            return _iceD_opAShortS(in, current);
        }
        case 17:
        {
            return _iceD_opAStringS(in, current);
        }
        case 18:
        {
            return _iceD_opAStructS(in, current);
        }
        case 19:
        {
            return _iceD_opAStructSD(in, current);
        }
        case 20:
        {
            return _iceD_opCustomCVS(in, current);
        }
        case 21:
        {
            return _iceD_opCustomCVSS(in, current);
        }
        case 22:
        {
            return _iceD_opCustomIntS(in, current);
        }
        case 23:
        {
            return _iceD_opCustomIntSS(in, current);
        }
        case 24:
        {
            return _iceD_opKBoolS(in, current);
        }
        case 25:
        {
            return _iceD_opKByteS(in, current);
        }
        case 26:
        {
            return _iceD_opKDoubleS(in, current);
        }
        case 27:
        {
            return _iceD_opKEnS(in, current);
        }
        case 28:
        {
            return _iceD_opKFloatS(in, current);
        }
        case 29:
        {
            return _iceD_opKIPrxS(in, current);
        }
        case 30:
        {
            return _iceD_opKIntS(in, current);
        }
        case 31:
        {
            return _iceD_opKLongS(in, current);
        }
        case 32:
        {
            return _iceD_opKObjectPrxS(in, current);
        }
        case 33:
        {
            return _iceD_opKShortS(in, current);
        }
        case 34:
        {
            return _iceD_opKStringS(in, current);
        }
        case 35:
        {
            return _iceD_opKStructS(in, current);
        }
        case 36:
        {
            return _iceD_opKStructSD(in, current);
        }
        case 37:
        {
            return _iceD_opLBoolS(in, current);
        }
        case 38:
        {
            return _iceD_opLByteS(in, current);
        }
        case 39:
        {
            return _iceD_opLCRS(in, current);
        }
        case 40:
        {
            return _iceD_opLCVS(in, current);
        }
        case 41:
        {
            return _iceD_opLDoubleS(in, current);
        }
        case 42:
        {
            return _iceD_opLEnS(in, current);
        }
        case 43:
        {
            return _iceD_opLFloatS(in, current);
        }
        case 44:
        {
            return _iceD_opLIPrxS(in, current);
        }
        case 45:
        {
            return _iceD_opLIntS(in, current);
        }
        case 46:
        {
            return _iceD_opLLongS(in, current);
        }
        case 47:
        {
            return _iceD_opLObjectPrxS(in, current);
        }
        case 48:
        {
            return _iceD_opLObjectS(in, current);
        }
        case 49:
        {
            return _iceD_opLShortS(in, current);
        }
        case 50:
        {
            return _iceD_opLStringS(in, current);
        }
        case 51:
        {
            return _iceD_opLStructS(in, current);
        }
        case 52:
        {
            return _iceD_opLStructSD(in, current);
        }
        case 53:
        {
            return _iceD_opQBoolS(in, current);
        }
        case 54:
        {
            return _iceD_opQByteS(in, current);
        }
        case 55:
        {
            return _iceD_opQDoubleS(in, current);
        }
        case 56:
        {
            return _iceD_opQEnS(in, current);
        }
        case 57:
        {
            return _iceD_opQFloatS(in, current);
        }
        case 58:
        {
            return _iceD_opQIPrxS(in, current);
        }
        case 59:
        {
            return _iceD_opQIntS(in, current);
        }
        case 60:
        {
            return _iceD_opQLongS(in, current);
        }
        case 61:
        {
            return _iceD_opQObjectPrxS(in, current);
        }
        case 62:
        {
            return _iceD_opQShortS(in, current);
        }
        case 63:
        {
            return _iceD_opQStringS(in, current);
        }
        case 64:
        {
            return _iceD_opQStructS(in, current);
        }
        case 65:
        {
            return _iceD_opQStructSD(in, current);
        }
        case 66:
        {
            return _iceD_opSBoolS(in, current);
        }
        case 67:
        {
            return _iceD_opSByteS(in, current);
        }
        case 68:
        {
            return _iceD_opSDoubleS(in, current);
        }
        case 69:
        {
            return _iceD_opSEnS(in, current);
        }
        case 70:
        {
            return _iceD_opSFloatS(in, current);
        }
        case 71:
        {
            return _iceD_opSIPrxS(in, current);
        }
        case 72:
        {
            return _iceD_opSIntS(in, current);
        }
        case 73:
        {
            return _iceD_opSLongS(in, current);
        }
        case 74:
        {
            return _iceD_opSObjectPrxS(in, current);
        }
        case 75:
        {
            return _iceD_opSShortS(in, current);
        }
        case 76:
        {
            return _iceD_opSStringS(in, current);
        }
        case 77:
        {
            return _iceD_opSStructS(in, current);
        }
        case 78:
        {
            return _iceD_opSStructSD(in, current);
        }
        case 79:
        {
            return _iceD_opSerialLargeCSharp(in, current);
        }
        case 80:
        {
            return _iceD_opSerialSmallCSharp(in, current);
        }
        case 81:
        {
            return _iceD_opSerialStructCSharp(in, current);
        }
        case 82:
        {
            return _iceD_shutdown(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

Test::CV::~CV()
{
}

const ::std::string&
Test::CV::ice_staticId()
{
    static const ::std::string typeId = "::Test::CV";
    return typeId;
}

Test::CR::~CR()
{
}

const ::std::string&
Test::CR::ice_staticId()
{
    static const ::std::string typeId = "::Test::CR";
    return typeId;
}

Test::Baz::~Baz()
{
}

const ::std::string&
Test::Baz::ice_staticId()
{
    static const ::std::string typeId = "::Test::Baz";
    return typeId;
}

/// \cond INTERNAL
::std::shared_ptr<::Ice::ObjectPrx>
Test::IPrx::_newInstance() const
{
    return ::IceInternal::createProxy<IPrx>();
}
/// \endcond

const ::std::string&
Test::IPrx::ice_staticId()
{
    return I::ice_staticId();
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_shutdown(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_Test_MyClass_shutdown_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opAByteS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpAByteSResult>>& outAsync, const AByteS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opAByteS_name);
    outAsync->invoke(iceC_Test_MyClass_opAByteS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpAByteSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opLByteS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpLByteSResult>>& outAsync, const LByteS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opLByteS_name);
    outAsync->invoke(iceC_Test_MyClass_opLByteS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpLByteSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opKByteS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpKByteSResult>>& outAsync, const KByteS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opKByteS_name);
    outAsync->invoke(iceC_Test_MyClass_opKByteS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpKByteSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opQByteS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpQByteSResult>>& outAsync, const QByteS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opQByteS_name);
    outAsync->invoke(iceC_Test_MyClass_opQByteS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpQByteSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opSByteS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpSByteSResult>>& outAsync, const SByteS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opSByteS_name);
    outAsync->invoke(iceC_Test_MyClass_opSByteS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpSByteSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opABoolS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpABoolSResult>>& outAsync, const ABoolS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opABoolS_name);
    outAsync->invoke(iceC_Test_MyClass_opABoolS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpABoolSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opLBoolS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpLBoolSResult>>& outAsync, const LBoolS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opLBoolS_name);
    outAsync->invoke(iceC_Test_MyClass_opLBoolS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpLBoolSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opKBoolS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpKBoolSResult>>& outAsync, const KBoolS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opKBoolS_name);
    outAsync->invoke(iceC_Test_MyClass_opKBoolS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpKBoolSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opQBoolS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpQBoolSResult>>& outAsync, const QBoolS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opQBoolS_name);
    outAsync->invoke(iceC_Test_MyClass_opQBoolS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpQBoolSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opSBoolS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpSBoolSResult>>& outAsync, const SBoolS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opSBoolS_name);
    outAsync->invoke(iceC_Test_MyClass_opSBoolS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpSBoolSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opAShortS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpAShortSResult>>& outAsync, const AShortS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opAShortS_name);
    outAsync->invoke(iceC_Test_MyClass_opAShortS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpAShortSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opLShortS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpLShortSResult>>& outAsync, const LShortS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opLShortS_name);
    outAsync->invoke(iceC_Test_MyClass_opLShortS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpLShortSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opKShortS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpKShortSResult>>& outAsync, const KShortS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opKShortS_name);
    outAsync->invoke(iceC_Test_MyClass_opKShortS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpKShortSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opQShortS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpQShortSResult>>& outAsync, const QShortS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opQShortS_name);
    outAsync->invoke(iceC_Test_MyClass_opQShortS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpQShortSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opSShortS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpSShortSResult>>& outAsync, const SShortS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opSShortS_name);
    outAsync->invoke(iceC_Test_MyClass_opSShortS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpSShortSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opAIntS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpAIntSResult>>& outAsync, const AIntS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opAIntS_name);
    outAsync->invoke(iceC_Test_MyClass_opAIntS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpAIntSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opLIntS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpLIntSResult>>& outAsync, const LIntS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opLIntS_name);
    outAsync->invoke(iceC_Test_MyClass_opLIntS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpLIntSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opKIntS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpKIntSResult>>& outAsync, const KIntS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opKIntS_name);
    outAsync->invoke(iceC_Test_MyClass_opKIntS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpKIntSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opQIntS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpQIntSResult>>& outAsync, const QIntS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opQIntS_name);
    outAsync->invoke(iceC_Test_MyClass_opQIntS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpQIntSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opSIntS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpSIntSResult>>& outAsync, const SIntS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opSIntS_name);
    outAsync->invoke(iceC_Test_MyClass_opSIntS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpSIntSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opALongS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpALongSResult>>& outAsync, const ALongS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opALongS_name);
    outAsync->invoke(iceC_Test_MyClass_opALongS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpALongSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opLLongS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpLLongSResult>>& outAsync, const LLongS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opLLongS_name);
    outAsync->invoke(iceC_Test_MyClass_opLLongS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpLLongSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opKLongS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpKLongSResult>>& outAsync, const KLongS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opKLongS_name);
    outAsync->invoke(iceC_Test_MyClass_opKLongS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpKLongSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opQLongS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpQLongSResult>>& outAsync, const QLongS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opQLongS_name);
    outAsync->invoke(iceC_Test_MyClass_opQLongS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpQLongSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opSLongS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpSLongSResult>>& outAsync, const SLongS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opSLongS_name);
    outAsync->invoke(iceC_Test_MyClass_opSLongS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpSLongSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opAFloatS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpAFloatSResult>>& outAsync, const AFloatS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opAFloatS_name);
    outAsync->invoke(iceC_Test_MyClass_opAFloatS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpAFloatSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opLFloatS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpLFloatSResult>>& outAsync, const LFloatS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opLFloatS_name);
    outAsync->invoke(iceC_Test_MyClass_opLFloatS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpLFloatSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opKFloatS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpKFloatSResult>>& outAsync, const KFloatS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opKFloatS_name);
    outAsync->invoke(iceC_Test_MyClass_opKFloatS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpKFloatSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opQFloatS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpQFloatSResult>>& outAsync, const QFloatS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opQFloatS_name);
    outAsync->invoke(iceC_Test_MyClass_opQFloatS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpQFloatSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opSFloatS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpSFloatSResult>>& outAsync, const SFloatS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opSFloatS_name);
    outAsync->invoke(iceC_Test_MyClass_opSFloatS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpSFloatSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opADoubleS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpADoubleSResult>>& outAsync, const ADoubleS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opADoubleS_name);
    outAsync->invoke(iceC_Test_MyClass_opADoubleS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpADoubleSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opLDoubleS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpLDoubleSResult>>& outAsync, const LDoubleS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opLDoubleS_name);
    outAsync->invoke(iceC_Test_MyClass_opLDoubleS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpLDoubleSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opKDoubleS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpKDoubleSResult>>& outAsync, const KDoubleS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opKDoubleS_name);
    outAsync->invoke(iceC_Test_MyClass_opKDoubleS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpKDoubleSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opQDoubleS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpQDoubleSResult>>& outAsync, const QDoubleS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opQDoubleS_name);
    outAsync->invoke(iceC_Test_MyClass_opQDoubleS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpQDoubleSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opSDoubleS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpSDoubleSResult>>& outAsync, const SDoubleS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opSDoubleS_name);
    outAsync->invoke(iceC_Test_MyClass_opSDoubleS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpSDoubleSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opAStringS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpAStringSResult>>& outAsync, const AStringS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opAStringS_name);
    outAsync->invoke(iceC_Test_MyClass_opAStringS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpAStringSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opLStringS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpLStringSResult>>& outAsync, const LStringS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opLStringS_name);
    outAsync->invoke(iceC_Test_MyClass_opLStringS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpLStringSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opKStringS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpKStringSResult>>& outAsync, const KStringS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opKStringS_name);
    outAsync->invoke(iceC_Test_MyClass_opKStringS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpKStringSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opQStringS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpQStringSResult>>& outAsync, const QStringS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opQStringS_name);
    outAsync->invoke(iceC_Test_MyClass_opQStringS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpQStringSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opSStringS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpSStringSResult>>& outAsync, const SStringS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opSStringS_name);
    outAsync->invoke(iceC_Test_MyClass_opSStringS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpSStringSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opAObjectS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpAObjectSResult>>& outAsync, const AObjectS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opAObjectS_name);
    outAsync->invoke(iceC_Test_MyClass_opAObjectS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
            ostr->writePendingValues();
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpAObjectSResult v;
            istr->readAll(v.o, v.returnValue);
            istr->readPendingValues();
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opLObjectS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpLObjectSResult>>& outAsync, const LObjectS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opLObjectS_name);
    outAsync->invoke(iceC_Test_MyClass_opLObjectS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
            ostr->writePendingValues();
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpLObjectSResult v;
            istr->readAll(v.o, v.returnValue);
            istr->readPendingValues();
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opAObjectPrxS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpAObjectPrxSResult>>& outAsync, const AObjectPrxS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opAObjectPrxS_name);
    outAsync->invoke(iceC_Test_MyClass_opAObjectPrxS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpAObjectPrxSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opLObjectPrxS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpLObjectPrxSResult>>& outAsync, const LObjectPrxS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opLObjectPrxS_name);
    outAsync->invoke(iceC_Test_MyClass_opLObjectPrxS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpLObjectPrxSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opKObjectPrxS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpKObjectPrxSResult>>& outAsync, const KObjectPrxS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opKObjectPrxS_name);
    outAsync->invoke(iceC_Test_MyClass_opKObjectPrxS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpKObjectPrxSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opQObjectPrxS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpQObjectPrxSResult>>& outAsync, const QObjectPrxS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opQObjectPrxS_name);
    outAsync->invoke(iceC_Test_MyClass_opQObjectPrxS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpQObjectPrxSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opSObjectPrxS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpSObjectPrxSResult>>& outAsync, const SObjectPrxS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opSObjectPrxS_name);
    outAsync->invoke(iceC_Test_MyClass_opSObjectPrxS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpSObjectPrxSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opAStructS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpAStructSResult>>& outAsync, const AStructS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opAStructS_name);
    outAsync->invoke(iceC_Test_MyClass_opAStructS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpAStructSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opLStructS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpLStructSResult>>& outAsync, const LStructS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opLStructS_name);
    outAsync->invoke(iceC_Test_MyClass_opLStructS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpLStructSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opKStructS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpKStructSResult>>& outAsync, const KStructS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opKStructS_name);
    outAsync->invoke(iceC_Test_MyClass_opKStructS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpKStructSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opQStructS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpQStructSResult>>& outAsync, const QStructS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opQStructS_name);
    outAsync->invoke(iceC_Test_MyClass_opQStructS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpQStructSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opSStructS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpSStructSResult>>& outAsync, const SStructS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opSStructS_name);
    outAsync->invoke(iceC_Test_MyClass_opSStructS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpSStructSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opAStructSD(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpAStructSDResult>>& outAsync, const AStructSD& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opAStructSD_name);
    outAsync->invoke(iceC_Test_MyClass_opAStructSD_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpAStructSDResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opLStructSD(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpLStructSDResult>>& outAsync, const LStructSD& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opLStructSD_name);
    outAsync->invoke(iceC_Test_MyClass_opLStructSD_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpLStructSDResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opKStructSD(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpKStructSDResult>>& outAsync, const KStructSD& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opKStructSD_name);
    outAsync->invoke(iceC_Test_MyClass_opKStructSD_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpKStructSDResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opQStructSD(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpQStructSDResult>>& outAsync, const QStructSD& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opQStructSD_name);
    outAsync->invoke(iceC_Test_MyClass_opQStructSD_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpQStructSDResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opSStructSD(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpSStructSDResult>>& outAsync, const SStructSD& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opSStructSD_name);
    outAsync->invoke(iceC_Test_MyClass_opSStructSD_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpSStructSDResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opACVS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpACVSResult>>& outAsync, const ACVS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opACVS_name);
    outAsync->invoke(iceC_Test_MyClass_opACVS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
            ostr->writePendingValues();
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpACVSResult v;
            istr->readAll(v.o, v.returnValue);
            istr->readPendingValues();
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opLCVS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpLCVSResult>>& outAsync, const LCVS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opLCVS_name);
    outAsync->invoke(iceC_Test_MyClass_opLCVS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
            ostr->writePendingValues();
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpLCVSResult v;
            istr->readAll(v.o, v.returnValue);
            istr->readPendingValues();
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opACRS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpACRSResult>>& outAsync, const ACRS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opACRS_name);
    outAsync->invoke(iceC_Test_MyClass_opACRS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
            ostr->writePendingValues();
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpACRSResult v;
            istr->readAll(v.o, v.returnValue);
            istr->readPendingValues();
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opLCRS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpLCRSResult>>& outAsync, const LCRS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opLCRS_name);
    outAsync->invoke(iceC_Test_MyClass_opLCRS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
            ostr->writePendingValues();
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpLCRSResult v;
            istr->readAll(v.o, v.returnValue);
            istr->readPendingValues();
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opAEnS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpAEnSResult>>& outAsync, const AEnS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opAEnS_name);
    outAsync->invoke(iceC_Test_MyClass_opAEnS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpAEnSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opLEnS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpLEnSResult>>& outAsync, const LEnS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opLEnS_name);
    outAsync->invoke(iceC_Test_MyClass_opLEnS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpLEnSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opKEnS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpKEnSResult>>& outAsync, const KEnS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opKEnS_name);
    outAsync->invoke(iceC_Test_MyClass_opKEnS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpKEnSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opQEnS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpQEnSResult>>& outAsync, const QEnS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opQEnS_name);
    outAsync->invoke(iceC_Test_MyClass_opQEnS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpQEnSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opSEnS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpSEnSResult>>& outAsync, const SEnS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opSEnS_name);
    outAsync->invoke(iceC_Test_MyClass_opSEnS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpSEnSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opAIPrxS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpAIPrxSResult>>& outAsync, const AIPrxS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opAIPrxS_name);
    outAsync->invoke(iceC_Test_MyClass_opAIPrxS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpAIPrxSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opLIPrxS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpLIPrxSResult>>& outAsync, const LIPrxS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opLIPrxS_name);
    outAsync->invoke(iceC_Test_MyClass_opLIPrxS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpLIPrxSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opKIPrxS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpKIPrxSResult>>& outAsync, const KIPrxS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opKIPrxS_name);
    outAsync->invoke(iceC_Test_MyClass_opKIPrxS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpKIPrxSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opQIPrxS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpQIPrxSResult>>& outAsync, const QIPrxS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opQIPrxS_name);
    outAsync->invoke(iceC_Test_MyClass_opQIPrxS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpQIPrxSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opSIPrxS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpSIPrxSResult>>& outAsync, const SIPrxS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opSIPrxS_name);
    outAsync->invoke(iceC_Test_MyClass_opSIPrxS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpSIPrxSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opCustomIntS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpCustomIntSResult>>& outAsync, const CustomIntS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opCustomIntS_name);
    outAsync->invoke(iceC_Test_MyClass_opCustomIntS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpCustomIntSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opCustomCVS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpCustomCVSResult>>& outAsync, const CustomCVS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opCustomCVS_name);
    outAsync->invoke(iceC_Test_MyClass_opCustomCVS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
            ostr->writePendingValues();
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpCustomCVSResult v;
            istr->readAll(v.o, v.returnValue);
            istr->readPendingValues();
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opCustomIntSS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpCustomIntSSResult>>& outAsync, const CustomIntSS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opCustomIntSS_name);
    outAsync->invoke(iceC_Test_MyClass_opCustomIntSS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpCustomIntSSResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opCustomCVSS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpCustomCVSSResult>>& outAsync, const CustomCVSS& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opCustomCVSS_name);
    outAsync->invoke(iceC_Test_MyClass_opCustomCVSS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
            ostr->writePendingValues();
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpCustomCVSSResult v;
            istr->readAll(v.o, v.returnValue);
            istr->readPendingValues();
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opSerialSmallCSharp(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpSerialSmallCSharpResult>>& outAsync, const SerialSmall& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opSerialSmallCSharp_name);
    outAsync->invoke(iceC_Test_MyClass_opSerialSmallCSharp_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpSerialSmallCSharpResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opSerialLargeCSharp(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpSerialLargeCSharpResult>>& outAsync, const SerialLarge& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opSerialLargeCSharp_name);
    outAsync->invoke(iceC_Test_MyClass_opSerialLargeCSharp_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpSerialLargeCSharpResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opSerialStructCSharp(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<MyClass::OpSerialStructCSharpResult>>& outAsync, const SerialStruct& iceP_i, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Test_MyClass_opSerialStructCSharp_name);
    outAsync->invoke(iceC_Test_MyClass_opSerialStructCSharp_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            MyClass::OpSerialStructCSharpResult v;
            istr->readAll(v.o, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
::std::shared_ptr<::Ice::ObjectPrx>
Test::MyClassPrx::_newInstance() const
{
    return ::IceInternal::createProxy<MyClassPrx>();
}
/// \endcond

const ::std::string&
Test::MyClassPrx::ice_staticId()
{
    return MyClass::ice_staticId();
}

namespace Ice
{
}

#else // C++98 mapping

namespace
{

const ::std::string iceC_Test_MyClass_shutdown_name = "shutdown";

const ::std::string iceC_Test_MyClass_opAByteS_name = "opAByteS";

const ::std::string iceC_Test_MyClass_opLByteS_name = "opLByteS";

const ::std::string iceC_Test_MyClass_opKByteS_name = "opKByteS";

const ::std::string iceC_Test_MyClass_opQByteS_name = "opQByteS";

const ::std::string iceC_Test_MyClass_opSByteS_name = "opSByteS";

const ::std::string iceC_Test_MyClass_opABoolS_name = "opABoolS";

const ::std::string iceC_Test_MyClass_opLBoolS_name = "opLBoolS";

const ::std::string iceC_Test_MyClass_opKBoolS_name = "opKBoolS";

const ::std::string iceC_Test_MyClass_opQBoolS_name = "opQBoolS";

const ::std::string iceC_Test_MyClass_opSBoolS_name = "opSBoolS";

const ::std::string iceC_Test_MyClass_opAShortS_name = "opAShortS";

const ::std::string iceC_Test_MyClass_opLShortS_name = "opLShortS";

const ::std::string iceC_Test_MyClass_opKShortS_name = "opKShortS";

const ::std::string iceC_Test_MyClass_opQShortS_name = "opQShortS";

const ::std::string iceC_Test_MyClass_opSShortS_name = "opSShortS";

const ::std::string iceC_Test_MyClass_opAIntS_name = "opAIntS";

const ::std::string iceC_Test_MyClass_opLIntS_name = "opLIntS";

const ::std::string iceC_Test_MyClass_opKIntS_name = "opKIntS";

const ::std::string iceC_Test_MyClass_opQIntS_name = "opQIntS";

const ::std::string iceC_Test_MyClass_opSIntS_name = "opSIntS";

const ::std::string iceC_Test_MyClass_opALongS_name = "opALongS";

const ::std::string iceC_Test_MyClass_opLLongS_name = "opLLongS";

const ::std::string iceC_Test_MyClass_opKLongS_name = "opKLongS";

const ::std::string iceC_Test_MyClass_opQLongS_name = "opQLongS";

const ::std::string iceC_Test_MyClass_opSLongS_name = "opSLongS";

const ::std::string iceC_Test_MyClass_opAFloatS_name = "opAFloatS";

const ::std::string iceC_Test_MyClass_opLFloatS_name = "opLFloatS";

const ::std::string iceC_Test_MyClass_opKFloatS_name = "opKFloatS";

const ::std::string iceC_Test_MyClass_opQFloatS_name = "opQFloatS";

const ::std::string iceC_Test_MyClass_opSFloatS_name = "opSFloatS";

const ::std::string iceC_Test_MyClass_opADoubleS_name = "opADoubleS";

const ::std::string iceC_Test_MyClass_opLDoubleS_name = "opLDoubleS";

const ::std::string iceC_Test_MyClass_opKDoubleS_name = "opKDoubleS";

const ::std::string iceC_Test_MyClass_opQDoubleS_name = "opQDoubleS";

const ::std::string iceC_Test_MyClass_opSDoubleS_name = "opSDoubleS";

const ::std::string iceC_Test_MyClass_opAStringS_name = "opAStringS";

const ::std::string iceC_Test_MyClass_opLStringS_name = "opLStringS";

const ::std::string iceC_Test_MyClass_opKStringS_name = "opKStringS";

const ::std::string iceC_Test_MyClass_opQStringS_name = "opQStringS";

const ::std::string iceC_Test_MyClass_opSStringS_name = "opSStringS";

const ::std::string iceC_Test_MyClass_opAObjectS_name = "opAObjectS";

const ::std::string iceC_Test_MyClass_opLObjectS_name = "opLObjectS";

const ::std::string iceC_Test_MyClass_opAObjectPrxS_name = "opAObjectPrxS";

const ::std::string iceC_Test_MyClass_opLObjectPrxS_name = "opLObjectPrxS";

const ::std::string iceC_Test_MyClass_opKObjectPrxS_name = "opKObjectPrxS";

const ::std::string iceC_Test_MyClass_opQObjectPrxS_name = "opQObjectPrxS";

const ::std::string iceC_Test_MyClass_opSObjectPrxS_name = "opSObjectPrxS";

const ::std::string iceC_Test_MyClass_opAStructS_name = "opAStructS";

const ::std::string iceC_Test_MyClass_opLStructS_name = "opLStructS";

const ::std::string iceC_Test_MyClass_opKStructS_name = "opKStructS";

const ::std::string iceC_Test_MyClass_opQStructS_name = "opQStructS";

const ::std::string iceC_Test_MyClass_opSStructS_name = "opSStructS";

const ::std::string iceC_Test_MyClass_opAStructSD_name = "opAStructSD";

const ::std::string iceC_Test_MyClass_opLStructSD_name = "opLStructSD";

const ::std::string iceC_Test_MyClass_opKStructSD_name = "opKStructSD";

const ::std::string iceC_Test_MyClass_opQStructSD_name = "opQStructSD";

const ::std::string iceC_Test_MyClass_opSStructSD_name = "opSStructSD";

const ::std::string iceC_Test_MyClass_opACVS_name = "opACVS";

const ::std::string iceC_Test_MyClass_opLCVS_name = "opLCVS";

const ::std::string iceC_Test_MyClass_opACRS_name = "opACRS";

const ::std::string iceC_Test_MyClass_opLCRS_name = "opLCRS";

const ::std::string iceC_Test_MyClass_opAEnS_name = "opAEnS";

const ::std::string iceC_Test_MyClass_opLEnS_name = "opLEnS";

const ::std::string iceC_Test_MyClass_opKEnS_name = "opKEnS";

const ::std::string iceC_Test_MyClass_opQEnS_name = "opQEnS";

const ::std::string iceC_Test_MyClass_opSEnS_name = "opSEnS";

const ::std::string iceC_Test_MyClass_opAIPrxS_name = "opAIPrxS";

const ::std::string iceC_Test_MyClass_opLIPrxS_name = "opLIPrxS";

const ::std::string iceC_Test_MyClass_opKIPrxS_name = "opKIPrxS";

const ::std::string iceC_Test_MyClass_opQIPrxS_name = "opQIPrxS";

const ::std::string iceC_Test_MyClass_opSIPrxS_name = "opSIPrxS";

const ::std::string iceC_Test_MyClass_opCustomIntS_name = "opCustomIntS";

const ::std::string iceC_Test_MyClass_opCustomCVS_name = "opCustomCVS";

const ::std::string iceC_Test_MyClass_opCustomIntSS_name = "opCustomIntSS";

const ::std::string iceC_Test_MyClass_opCustomCVSS_name = "opCustomCVSS";

const ::std::string iceC_Test_MyClass_opSerialSmallCSharp_name = "opSerialSmallCSharp";

const ::std::string iceC_Test_MyClass_opSerialLargeCSharp_name = "opSerialLargeCSharp";

const ::std::string iceC_Test_MyClass_opSerialStructCSharp_name = "opSerialStructCSharp";

}

namespace
{

const ::IceInternal::DefaultUserExceptionFactoryInit< ::Test::Bar> iceC_Test_Bar_init("::Test::Bar");

}

Test::Bar::Bar(const SerialLarge& SLmem, const SLS& SLSmem) :
    ::Ice::UserException(),
    SLmem(SLmem),
    SLSmem(SLSmem)
{
}

#ifdef ICE_CPP11_COMPILER
Test::Bar::~Bar()
{
}
#else
Test::Bar::~Bar() throw()
{
}
#endif

::std::string
Test::Bar::ice_id() const
{
    return "::Test::Bar";
}

Test::Bar*
Test::Bar::ice_clone() const
{
    return new Bar(*this);
}

void
Test::Bar::ice_throw() const
{
    throw *this;
}

/// \cond STREAM
void
Test::Bar::_writeImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice("::Test::Bar", -1, true);
    ::Ice::StreamWriter< Bar, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Test::Bar::_readImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< Bar, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(CV* p) { return p; }

void
::IceProxy::Test::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< CV>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new CV;
        v->_copyFrom(proxy);
    }
}
/// \endcond

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::Test::CV::_newInstance() const
{
    return new CV;
}
/// \endcond

const ::std::string&
IceProxy::Test::CV::ice_staticId()
{
    return ::Test::CV::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(I* p) { return p; }

void
::IceProxy::Test::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< I>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new I;
        v->_copyFrom(proxy);
    }
}
/// \endcond

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::Test::I::_newInstance() const
{
    return new I;
}
/// \endcond

const ::std::string&
IceProxy::Test::I::ice_staticId()
{
    return ::Test::I::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(CR* p) { return p; }

void
::IceProxy::Test::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< CR>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new CR;
        v->_copyFrom(proxy);
    }
}
/// \endcond

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::Test::CR::_newInstance() const
{
    return new CR;
}
/// \endcond

const ::std::string&
IceProxy::Test::CR::ice_staticId()
{
    return ::Test::CR::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(MyClass* p) { return p; }

void
::IceProxy::Test::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< MyClass>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new MyClass;
        v->_copyFrom(proxy);
    }
}
/// \endcond

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_shutdown(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_shutdown_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_shutdown_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Test_MyClass_shutdown_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Test::MyClass::end_shutdown(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_Test_MyClass_shutdown_name);
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opAByteS(const ::Test::AByteS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opAByteS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opAByteS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opAByteS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opAByteS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::AByteS
IceProxy::Test::MyClass::end_opAByteS(::Test::AByteS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opAByteS_name);
    ::Test::AByteS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opAByteS(::Test::AByteS& iceP_o, ::Test::AByteS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opAByteS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opLByteS(const ::Test::LByteS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opLByteS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opLByteS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opLByteS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opLByteS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::LByteS
IceProxy::Test::MyClass::end_opLByteS(::Test::LByteS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opLByteS_name);
    ::Test::LByteS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opLByteS(::Test::LByteS& iceP_o, ::Test::LByteS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opLByteS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opKByteS(const ::Test::KByteS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opKByteS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opKByteS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opKByteS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opKByteS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::KByteS
IceProxy::Test::MyClass::end_opKByteS(::Test::KByteS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opKByteS_name);
    ::Test::KByteS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opKByteS(::Test::KByteS& iceP_o, ::Test::KByteS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opKByteS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opQByteS(const ::Test::QByteS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opQByteS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opQByteS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opQByteS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opQByteS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::QByteS
IceProxy::Test::MyClass::end_opQByteS(::Test::QByteS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opQByteS_name);
    ::Test::QByteS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opQByteS(::Test::QByteS& iceP_o, ::Test::QByteS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opQByteS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opSByteS(const ::Test::SByteS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opSByteS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opSByteS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opSByteS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opSByteS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::SByteS
IceProxy::Test::MyClass::end_opSByteS(::Test::SByteS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opSByteS_name);
    ::Test::SByteS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opSByteS(::Test::SByteS& iceP_o, ::Test::SByteS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opSByteS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opABoolS(const ::Test::ABoolS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opABoolS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opABoolS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opABoolS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opABoolS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::ABoolS
IceProxy::Test::MyClass::end_opABoolS(::Test::ABoolS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opABoolS_name);
    ::Test::ABoolS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opABoolS(::Test::ABoolS& iceP_o, ::Test::ABoolS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opABoolS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opLBoolS(const ::Test::LBoolS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opLBoolS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opLBoolS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opLBoolS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opLBoolS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::LBoolS
IceProxy::Test::MyClass::end_opLBoolS(::Test::LBoolS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opLBoolS_name);
    ::Test::LBoolS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opLBoolS(::Test::LBoolS& iceP_o, ::Test::LBoolS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opLBoolS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opKBoolS(const ::Test::KBoolS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opKBoolS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opKBoolS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opKBoolS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opKBoolS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::KBoolS
IceProxy::Test::MyClass::end_opKBoolS(::Test::KBoolS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opKBoolS_name);
    ::Test::KBoolS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opKBoolS(::Test::KBoolS& iceP_o, ::Test::KBoolS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opKBoolS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opQBoolS(const ::Test::QBoolS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opQBoolS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opQBoolS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opQBoolS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opQBoolS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::QBoolS
IceProxy::Test::MyClass::end_opQBoolS(::Test::QBoolS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opQBoolS_name);
    ::Test::QBoolS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opQBoolS(::Test::QBoolS& iceP_o, ::Test::QBoolS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opQBoolS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opSBoolS(const ::Test::SBoolS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opSBoolS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opSBoolS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opSBoolS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opSBoolS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::SBoolS
IceProxy::Test::MyClass::end_opSBoolS(::Test::SBoolS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opSBoolS_name);
    ::Test::SBoolS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opSBoolS(::Test::SBoolS& iceP_o, ::Test::SBoolS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opSBoolS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opAShortS(const ::Test::AShortS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opAShortS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opAShortS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opAShortS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opAShortS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::AShortS
IceProxy::Test::MyClass::end_opAShortS(::Test::AShortS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opAShortS_name);
    ::Test::AShortS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opAShortS(::Test::AShortS& iceP_o, ::Test::AShortS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opAShortS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opLShortS(const ::Test::LShortS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opLShortS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opLShortS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opLShortS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opLShortS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::LShortS
IceProxy::Test::MyClass::end_opLShortS(::Test::LShortS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opLShortS_name);
    ::Test::LShortS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opLShortS(::Test::LShortS& iceP_o, ::Test::LShortS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opLShortS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opKShortS(const ::Test::KShortS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opKShortS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opKShortS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opKShortS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opKShortS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::KShortS
IceProxy::Test::MyClass::end_opKShortS(::Test::KShortS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opKShortS_name);
    ::Test::KShortS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opKShortS(::Test::KShortS& iceP_o, ::Test::KShortS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opKShortS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opQShortS(const ::Test::QShortS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opQShortS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opQShortS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opQShortS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opQShortS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::QShortS
IceProxy::Test::MyClass::end_opQShortS(::Test::QShortS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opQShortS_name);
    ::Test::QShortS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opQShortS(::Test::QShortS& iceP_o, ::Test::QShortS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opQShortS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opSShortS(const ::Test::SShortS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opSShortS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opSShortS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opSShortS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opSShortS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::SShortS
IceProxy::Test::MyClass::end_opSShortS(::Test::SShortS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opSShortS_name);
    ::Test::SShortS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opSShortS(::Test::SShortS& iceP_o, ::Test::SShortS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opSShortS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opAIntS(const ::Test::AIntS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opAIntS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opAIntS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opAIntS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opAIntS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::AIntS
IceProxy::Test::MyClass::end_opAIntS(::Test::AIntS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opAIntS_name);
    ::Test::AIntS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opAIntS(::Test::AIntS& iceP_o, ::Test::AIntS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opAIntS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opLIntS(const ::Test::LIntS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opLIntS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opLIntS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opLIntS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opLIntS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::LIntS
IceProxy::Test::MyClass::end_opLIntS(::Test::LIntS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opLIntS_name);
    ::Test::LIntS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opLIntS(::Test::LIntS& iceP_o, ::Test::LIntS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opLIntS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opKIntS(const ::Test::KIntS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opKIntS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opKIntS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opKIntS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opKIntS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::KIntS
IceProxy::Test::MyClass::end_opKIntS(::Test::KIntS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opKIntS_name);
    ::Test::KIntS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opKIntS(::Test::KIntS& iceP_o, ::Test::KIntS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opKIntS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opQIntS(const ::Test::QIntS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opQIntS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opQIntS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opQIntS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opQIntS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::QIntS
IceProxy::Test::MyClass::end_opQIntS(::Test::QIntS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opQIntS_name);
    ::Test::QIntS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opQIntS(::Test::QIntS& iceP_o, ::Test::QIntS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opQIntS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opSIntS(const ::Test::SIntS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opSIntS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opSIntS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opSIntS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opSIntS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::SIntS
IceProxy::Test::MyClass::end_opSIntS(::Test::SIntS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opSIntS_name);
    ::Test::SIntS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opSIntS(::Test::SIntS& iceP_o, ::Test::SIntS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opSIntS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opALongS(const ::Test::ALongS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opALongS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opALongS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opALongS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opALongS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::ALongS
IceProxy::Test::MyClass::end_opALongS(::Test::ALongS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opALongS_name);
    ::Test::ALongS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opALongS(::Test::ALongS& iceP_o, ::Test::ALongS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opALongS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opLLongS(const ::Test::LLongS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opLLongS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opLLongS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opLLongS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opLLongS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::LLongS
IceProxy::Test::MyClass::end_opLLongS(::Test::LLongS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opLLongS_name);
    ::Test::LLongS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opLLongS(::Test::LLongS& iceP_o, ::Test::LLongS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opLLongS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opKLongS(const ::Test::KLongS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opKLongS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opKLongS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opKLongS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opKLongS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::KLongS
IceProxy::Test::MyClass::end_opKLongS(::Test::KLongS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opKLongS_name);
    ::Test::KLongS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opKLongS(::Test::KLongS& iceP_o, ::Test::KLongS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opKLongS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opQLongS(const ::Test::QLongS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opQLongS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opQLongS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opQLongS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opQLongS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::QLongS
IceProxy::Test::MyClass::end_opQLongS(::Test::QLongS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opQLongS_name);
    ::Test::QLongS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opQLongS(::Test::QLongS& iceP_o, ::Test::QLongS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opQLongS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opSLongS(const ::Test::SLongS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opSLongS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opSLongS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opSLongS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opSLongS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::SLongS
IceProxy::Test::MyClass::end_opSLongS(::Test::SLongS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opSLongS_name);
    ::Test::SLongS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opSLongS(::Test::SLongS& iceP_o, ::Test::SLongS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opSLongS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opAFloatS(const ::Test::AFloatS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opAFloatS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opAFloatS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opAFloatS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opAFloatS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::AFloatS
IceProxy::Test::MyClass::end_opAFloatS(::Test::AFloatS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opAFloatS_name);
    ::Test::AFloatS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opAFloatS(::Test::AFloatS& iceP_o, ::Test::AFloatS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opAFloatS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opLFloatS(const ::Test::LFloatS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opLFloatS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opLFloatS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opLFloatS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opLFloatS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::LFloatS
IceProxy::Test::MyClass::end_opLFloatS(::Test::LFloatS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opLFloatS_name);
    ::Test::LFloatS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opLFloatS(::Test::LFloatS& iceP_o, ::Test::LFloatS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opLFloatS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opKFloatS(const ::Test::KFloatS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opKFloatS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opKFloatS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opKFloatS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opKFloatS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::KFloatS
IceProxy::Test::MyClass::end_opKFloatS(::Test::KFloatS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opKFloatS_name);
    ::Test::KFloatS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opKFloatS(::Test::KFloatS& iceP_o, ::Test::KFloatS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opKFloatS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opQFloatS(const ::Test::QFloatS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opQFloatS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opQFloatS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opQFloatS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opQFloatS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::QFloatS
IceProxy::Test::MyClass::end_opQFloatS(::Test::QFloatS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opQFloatS_name);
    ::Test::QFloatS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opQFloatS(::Test::QFloatS& iceP_o, ::Test::QFloatS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opQFloatS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opSFloatS(const ::Test::SFloatS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opSFloatS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opSFloatS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opSFloatS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opSFloatS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::SFloatS
IceProxy::Test::MyClass::end_opSFloatS(::Test::SFloatS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opSFloatS_name);
    ::Test::SFloatS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opSFloatS(::Test::SFloatS& iceP_o, ::Test::SFloatS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opSFloatS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opADoubleS(const ::Test::ADoubleS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opADoubleS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opADoubleS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opADoubleS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opADoubleS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::ADoubleS
IceProxy::Test::MyClass::end_opADoubleS(::Test::ADoubleS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opADoubleS_name);
    ::Test::ADoubleS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opADoubleS(::Test::ADoubleS& iceP_o, ::Test::ADoubleS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opADoubleS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opLDoubleS(const ::Test::LDoubleS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opLDoubleS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opLDoubleS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opLDoubleS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opLDoubleS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::LDoubleS
IceProxy::Test::MyClass::end_opLDoubleS(::Test::LDoubleS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opLDoubleS_name);
    ::Test::LDoubleS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opLDoubleS(::Test::LDoubleS& iceP_o, ::Test::LDoubleS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opLDoubleS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opKDoubleS(const ::Test::KDoubleS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opKDoubleS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opKDoubleS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opKDoubleS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opKDoubleS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::KDoubleS
IceProxy::Test::MyClass::end_opKDoubleS(::Test::KDoubleS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opKDoubleS_name);
    ::Test::KDoubleS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opKDoubleS(::Test::KDoubleS& iceP_o, ::Test::KDoubleS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opKDoubleS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opQDoubleS(const ::Test::QDoubleS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opQDoubleS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opQDoubleS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opQDoubleS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opQDoubleS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::QDoubleS
IceProxy::Test::MyClass::end_opQDoubleS(::Test::QDoubleS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opQDoubleS_name);
    ::Test::QDoubleS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opQDoubleS(::Test::QDoubleS& iceP_o, ::Test::QDoubleS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opQDoubleS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opSDoubleS(const ::Test::SDoubleS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opSDoubleS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opSDoubleS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opSDoubleS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opSDoubleS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::SDoubleS
IceProxy::Test::MyClass::end_opSDoubleS(::Test::SDoubleS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opSDoubleS_name);
    ::Test::SDoubleS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opSDoubleS(::Test::SDoubleS& iceP_o, ::Test::SDoubleS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opSDoubleS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opAStringS(const ::Test::AStringS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opAStringS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opAStringS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opAStringS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opAStringS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::AStringS
IceProxy::Test::MyClass::end_opAStringS(::Test::AStringS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opAStringS_name);
    ::Test::AStringS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opAStringS(::Test::AStringS& iceP_o, ::Test::AStringS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opAStringS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opLStringS(const ::Test::LStringS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opLStringS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opLStringS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opLStringS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opLStringS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::LStringS
IceProxy::Test::MyClass::end_opLStringS(::Test::LStringS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opLStringS_name);
    ::Test::LStringS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opLStringS(::Test::LStringS& iceP_o, ::Test::LStringS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opLStringS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opKStringS(const ::Test::KStringS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opKStringS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opKStringS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opKStringS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opKStringS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::KStringS
IceProxy::Test::MyClass::end_opKStringS(::Test::KStringS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opKStringS_name);
    ::Test::KStringS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opKStringS(::Test::KStringS& iceP_o, ::Test::KStringS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opKStringS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opQStringS(const ::Test::QStringS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opQStringS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opQStringS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opQStringS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opQStringS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::QStringS
IceProxy::Test::MyClass::end_opQStringS(::Test::QStringS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opQStringS_name);
    ::Test::QStringS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opQStringS(::Test::QStringS& iceP_o, ::Test::QStringS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opQStringS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opSStringS(const ::Test::SStringS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opSStringS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opSStringS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opSStringS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opSStringS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::SStringS
IceProxy::Test::MyClass::end_opSStringS(::Test::SStringS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opSStringS_name);
    ::Test::SStringS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opSStringS(::Test::SStringS& iceP_o, ::Test::SStringS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opSStringS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opAObjectS(const ::Test::AObjectS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opAObjectS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opAObjectS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opAObjectS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        ostr->writePendingValues();
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opAObjectS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::AObjectS
IceProxy::Test::MyClass::end_opAObjectS(::Test::AObjectS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opAObjectS_name);
    ::Test::AObjectS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    istr->readPendingValues();
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opAObjectS(::Test::AObjectS& iceP_o, ::Test::AObjectS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opAObjectS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    istr->readPendingValues();
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opLObjectS(const ::Test::LObjectS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opLObjectS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opLObjectS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opLObjectS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        ostr->writePendingValues();
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opLObjectS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::LObjectS
IceProxy::Test::MyClass::end_opLObjectS(::Test::LObjectS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opLObjectS_name);
    ::Test::LObjectS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    istr->readPendingValues();
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opLObjectS(::Test::LObjectS& iceP_o, ::Test::LObjectS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opLObjectS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    istr->readPendingValues();
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opAObjectPrxS(const ::Test::AObjectPrxS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opAObjectPrxS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opAObjectPrxS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opAObjectPrxS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opAObjectPrxS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::AObjectPrxS
IceProxy::Test::MyClass::end_opAObjectPrxS(::Test::AObjectPrxS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opAObjectPrxS_name);
    ::Test::AObjectPrxS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opAObjectPrxS(::Test::AObjectPrxS& iceP_o, ::Test::AObjectPrxS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opAObjectPrxS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opLObjectPrxS(const ::Test::LObjectPrxS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opLObjectPrxS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opLObjectPrxS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opLObjectPrxS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opLObjectPrxS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::LObjectPrxS
IceProxy::Test::MyClass::end_opLObjectPrxS(::Test::LObjectPrxS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opLObjectPrxS_name);
    ::Test::LObjectPrxS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opLObjectPrxS(::Test::LObjectPrxS& iceP_o, ::Test::LObjectPrxS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opLObjectPrxS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opKObjectPrxS(const ::Test::KObjectPrxS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opKObjectPrxS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opKObjectPrxS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opKObjectPrxS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opKObjectPrxS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::KObjectPrxS
IceProxy::Test::MyClass::end_opKObjectPrxS(::Test::KObjectPrxS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opKObjectPrxS_name);
    ::Test::KObjectPrxS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opKObjectPrxS(::Test::KObjectPrxS& iceP_o, ::Test::KObjectPrxS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opKObjectPrxS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opQObjectPrxS(const ::Test::QObjectPrxS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opQObjectPrxS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opQObjectPrxS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opQObjectPrxS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opQObjectPrxS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::QObjectPrxS
IceProxy::Test::MyClass::end_opQObjectPrxS(::Test::QObjectPrxS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opQObjectPrxS_name);
    ::Test::QObjectPrxS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opQObjectPrxS(::Test::QObjectPrxS& iceP_o, ::Test::QObjectPrxS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opQObjectPrxS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opSObjectPrxS(const ::Test::SObjectPrxS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opSObjectPrxS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opSObjectPrxS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opSObjectPrxS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opSObjectPrxS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::SObjectPrxS
IceProxy::Test::MyClass::end_opSObjectPrxS(::Test::SObjectPrxS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opSObjectPrxS_name);
    ::Test::SObjectPrxS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opSObjectPrxS(::Test::SObjectPrxS& iceP_o, ::Test::SObjectPrxS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opSObjectPrxS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opAStructS(const ::Test::AStructS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opAStructS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opAStructS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opAStructS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opAStructS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::AStructS
IceProxy::Test::MyClass::end_opAStructS(::Test::AStructS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opAStructS_name);
    ::Test::AStructS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opAStructS(::Test::AStructS& iceP_o, ::Test::AStructS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opAStructS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opLStructS(const ::Test::LStructS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opLStructS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opLStructS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opLStructS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opLStructS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::LStructS
IceProxy::Test::MyClass::end_opLStructS(::Test::LStructS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opLStructS_name);
    ::Test::LStructS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opLStructS(::Test::LStructS& iceP_o, ::Test::LStructS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opLStructS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opKStructS(const ::Test::KStructS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opKStructS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opKStructS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opKStructS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opKStructS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::KStructS
IceProxy::Test::MyClass::end_opKStructS(::Test::KStructS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opKStructS_name);
    ::Test::KStructS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opKStructS(::Test::KStructS& iceP_o, ::Test::KStructS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opKStructS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opQStructS(const ::Test::QStructS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opQStructS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opQStructS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opQStructS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opQStructS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::QStructS
IceProxy::Test::MyClass::end_opQStructS(::Test::QStructS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opQStructS_name);
    ::Test::QStructS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opQStructS(::Test::QStructS& iceP_o, ::Test::QStructS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opQStructS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opSStructS(const ::Test::SStructS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opSStructS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opSStructS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opSStructS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opSStructS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::SStructS
IceProxy::Test::MyClass::end_opSStructS(::Test::SStructS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opSStructS_name);
    ::Test::SStructS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opSStructS(::Test::SStructS& iceP_o, ::Test::SStructS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opSStructS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opAStructSD(const ::Test::AStructSD& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opAStructSD_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opAStructSD_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opAStructSD_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opAStructSD_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::AStructSD
IceProxy::Test::MyClass::end_opAStructSD(::Test::AStructSD& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opAStructSD_name);
    ::Test::AStructSD ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opAStructSD(::Test::AStructSD& iceP_o, ::Test::AStructSD& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opAStructSD_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opLStructSD(const ::Test::LStructSD& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opLStructSD_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opLStructSD_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opLStructSD_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opLStructSD_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::LStructSD
IceProxy::Test::MyClass::end_opLStructSD(::Test::LStructSD& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opLStructSD_name);
    ::Test::LStructSD ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opLStructSD(::Test::LStructSD& iceP_o, ::Test::LStructSD& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opLStructSD_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opKStructSD(const ::Test::KStructSD& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opKStructSD_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opKStructSD_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opKStructSD_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opKStructSD_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::KStructSD
IceProxy::Test::MyClass::end_opKStructSD(::Test::KStructSD& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opKStructSD_name);
    ::Test::KStructSD ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opKStructSD(::Test::KStructSD& iceP_o, ::Test::KStructSD& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opKStructSD_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opQStructSD(const ::Test::QStructSD& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opQStructSD_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opQStructSD_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opQStructSD_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opQStructSD_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::QStructSD
IceProxy::Test::MyClass::end_opQStructSD(::Test::QStructSD& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opQStructSD_name);
    ::Test::QStructSD ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opQStructSD(::Test::QStructSD& iceP_o, ::Test::QStructSD& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opQStructSD_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opSStructSD(const ::Test::SStructSD& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opSStructSD_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opSStructSD_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opSStructSD_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opSStructSD_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::SStructSD
IceProxy::Test::MyClass::end_opSStructSD(::Test::SStructSD& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opSStructSD_name);
    ::Test::SStructSD ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opSStructSD(::Test::SStructSD& iceP_o, ::Test::SStructSD& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opSStructSD_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opACVS(const ::Test::ACVS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opACVS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opACVS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opACVS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        ostr->writePendingValues();
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opACVS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::ACVS
IceProxy::Test::MyClass::end_opACVS(::Test::ACVS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opACVS_name);
    ::Test::ACVS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    istr->readPendingValues();
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opACVS(::Test::ACVS& iceP_o, ::Test::ACVS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opACVS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    istr->readPendingValues();
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opLCVS(const ::Test::LCVS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opLCVS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opLCVS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opLCVS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        ostr->writePendingValues();
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opLCVS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::LCVS
IceProxy::Test::MyClass::end_opLCVS(::Test::LCVS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opLCVS_name);
    ::Test::LCVS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    istr->readPendingValues();
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opLCVS(::Test::LCVS& iceP_o, ::Test::LCVS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opLCVS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    istr->readPendingValues();
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opACRS(const ::Test::ACRS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opACRS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opACRS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opACRS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        ostr->writePendingValues();
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opACRS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::ACRS
IceProxy::Test::MyClass::end_opACRS(::Test::ACRS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opACRS_name);
    ::Test::ACRS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    istr->readPendingValues();
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opACRS(::Test::ACRS& iceP_o, ::Test::ACRS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opACRS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    istr->readPendingValues();
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opLCRS(const ::Test::LCRS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opLCRS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opLCRS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opLCRS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        ostr->writePendingValues();
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opLCRS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::LCRS
IceProxy::Test::MyClass::end_opLCRS(::Test::LCRS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opLCRS_name);
    ::Test::LCRS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    istr->readPendingValues();
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opLCRS(::Test::LCRS& iceP_o, ::Test::LCRS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opLCRS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    istr->readPendingValues();
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opAEnS(const ::Test::AEnS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opAEnS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opAEnS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opAEnS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opAEnS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::AEnS
IceProxy::Test::MyClass::end_opAEnS(::Test::AEnS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opAEnS_name);
    ::Test::AEnS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opAEnS(::Test::AEnS& iceP_o, ::Test::AEnS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opAEnS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opLEnS(const ::Test::LEnS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opLEnS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opLEnS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opLEnS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opLEnS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::LEnS
IceProxy::Test::MyClass::end_opLEnS(::Test::LEnS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opLEnS_name);
    ::Test::LEnS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opLEnS(::Test::LEnS& iceP_o, ::Test::LEnS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opLEnS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opKEnS(const ::Test::KEnS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opKEnS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opKEnS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opKEnS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opKEnS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::KEnS
IceProxy::Test::MyClass::end_opKEnS(::Test::KEnS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opKEnS_name);
    ::Test::KEnS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opKEnS(::Test::KEnS& iceP_o, ::Test::KEnS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opKEnS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opQEnS(const ::Test::QEnS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opQEnS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opQEnS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opQEnS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opQEnS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::QEnS
IceProxy::Test::MyClass::end_opQEnS(::Test::QEnS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opQEnS_name);
    ::Test::QEnS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opQEnS(::Test::QEnS& iceP_o, ::Test::QEnS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opQEnS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opSEnS(const ::Test::SEnS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opSEnS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opSEnS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opSEnS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opSEnS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::SEnS
IceProxy::Test::MyClass::end_opSEnS(::Test::SEnS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opSEnS_name);
    ::Test::SEnS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opSEnS(::Test::SEnS& iceP_o, ::Test::SEnS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opSEnS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opAIPrxS(const ::Test::AIPrxS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opAIPrxS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opAIPrxS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opAIPrxS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opAIPrxS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::AIPrxS
IceProxy::Test::MyClass::end_opAIPrxS(::Test::AIPrxS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opAIPrxS_name);
    ::Test::AIPrxS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opAIPrxS(::Test::AIPrxS& iceP_o, ::Test::AIPrxS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opAIPrxS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opLIPrxS(const ::Test::LIPrxS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opLIPrxS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opLIPrxS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opLIPrxS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opLIPrxS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::LIPrxS
IceProxy::Test::MyClass::end_opLIPrxS(::Test::LIPrxS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opLIPrxS_name);
    ::Test::LIPrxS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opLIPrxS(::Test::LIPrxS& iceP_o, ::Test::LIPrxS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opLIPrxS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opKIPrxS(const ::Test::KIPrxS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opKIPrxS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opKIPrxS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opKIPrxS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opKIPrxS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::KIPrxS
IceProxy::Test::MyClass::end_opKIPrxS(::Test::KIPrxS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opKIPrxS_name);
    ::Test::KIPrxS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opKIPrxS(::Test::KIPrxS& iceP_o, ::Test::KIPrxS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opKIPrxS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opQIPrxS(const ::Test::QIPrxS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opQIPrxS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opQIPrxS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opQIPrxS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opQIPrxS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::QIPrxS
IceProxy::Test::MyClass::end_opQIPrxS(::Test::QIPrxS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opQIPrxS_name);
    ::Test::QIPrxS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opQIPrxS(::Test::QIPrxS& iceP_o, ::Test::QIPrxS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opQIPrxS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opSIPrxS(const ::Test::SIPrxS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opSIPrxS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opSIPrxS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opSIPrxS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opSIPrxS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::SIPrxS
IceProxy::Test::MyClass::end_opSIPrxS(::Test::SIPrxS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opSIPrxS_name);
    ::Test::SIPrxS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opSIPrxS(::Test::SIPrxS& iceP_o, ::Test::SIPrxS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opSIPrxS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opCustomIntS(const ::Test::CustomIntS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opCustomIntS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opCustomIntS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opCustomIntS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opCustomIntS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::CustomIntS
IceProxy::Test::MyClass::end_opCustomIntS(::Test::CustomIntS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opCustomIntS_name);
    ::Test::CustomIntS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opCustomIntS(::Test::CustomIntS& iceP_o, ::Test::CustomIntS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opCustomIntS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opCustomCVS(const ::Test::CustomCVS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opCustomCVS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opCustomCVS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opCustomCVS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        ostr->writePendingValues();
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opCustomCVS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::CustomCVS
IceProxy::Test::MyClass::end_opCustomCVS(::Test::CustomCVS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opCustomCVS_name);
    ::Test::CustomCVS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    istr->readPendingValues();
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opCustomCVS(::Test::CustomCVS& iceP_o, ::Test::CustomCVS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opCustomCVS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    istr->readPendingValues();
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opCustomIntSS(const ::Test::CustomIntSS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opCustomIntSS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opCustomIntSS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opCustomIntSS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opCustomIntSS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::CustomIntSS
IceProxy::Test::MyClass::end_opCustomIntSS(::Test::CustomIntSS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opCustomIntSS_name);
    ::Test::CustomIntSS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opCustomIntSS(::Test::CustomIntSS& iceP_o, ::Test::CustomIntSS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opCustomIntSS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opCustomCVSS(const ::Test::CustomCVSS& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opCustomCVSS_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opCustomCVSS_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opCustomCVSS_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        ostr->writePendingValues();
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opCustomCVSS_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::CustomCVSS
IceProxy::Test::MyClass::end_opCustomCVSS(::Test::CustomCVSS& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opCustomCVSS_name);
    ::Test::CustomCVSS ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    istr->readPendingValues();
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opCustomCVSS(::Test::CustomCVSS& iceP_o, ::Test::CustomCVSS& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opCustomCVSS_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    istr->readPendingValues();
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opSerialSmallCSharp(const ::Test::SerialSmall& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opSerialSmallCSharp_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opSerialSmallCSharp_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opSerialSmallCSharp_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opSerialSmallCSharp_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::SerialSmall
IceProxy::Test::MyClass::end_opSerialSmallCSharp(::Test::SerialSmall& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opSerialSmallCSharp_name);
    ::Test::SerialSmall ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opSerialSmallCSharp(::Test::SerialSmall& iceP_o, ::Test::SerialSmall& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opSerialSmallCSharp_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opSerialLargeCSharp(const ::Test::SerialLarge& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opSerialLargeCSharp_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opSerialLargeCSharp_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opSerialLargeCSharp_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opSerialLargeCSharp_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::SerialLarge
IceProxy::Test::MyClass::end_opSerialLargeCSharp(::Test::SerialLarge& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opSerialLargeCSharp_name);
    ::Test::SerialLarge ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opSerialLargeCSharp(::Test::SerialLarge& iceP_o, ::Test::SerialLarge& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opSerialLargeCSharp_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Test::MyClass::_iceI_begin_opSerialStructCSharp(const ::Test::SerialStruct& iceP_i, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Test_MyClass_opSerialStructCSharp_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Test_MyClass_opSerialStructCSharp_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Test_MyClass_opSerialStructCSharp_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_i);
        result->endWriteParams();
        result->invoke(iceC_Test_MyClass_opSerialStructCSharp_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Test::SerialStruct
IceProxy::Test::MyClass::end_opSerialStructCSharp(::Test::SerialStruct& iceP_o, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opSerialStructCSharp_name);
    ::Test::SerialStruct ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Test::MyClass::_iceI_end_opSerialStructCSharp(::Test::SerialStruct& iceP_o, ::Test::SerialStruct& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Test_MyClass_opSerialStructCSharp_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_o);
    istr->read(ret);
    result->_endReadParams();
}

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::Test::MyClass::_newInstance() const
{
    return new MyClass;
}
/// \endcond

const ::std::string&
IceProxy::Test::MyClass::ice_staticId()
{
    return ::Test::MyClass::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::Test::upCast(Baz* p) { return p; }

void
::IceProxy::Test::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< Baz>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new Baz;
        v->_copyFrom(proxy);
    }
}
/// \endcond

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::Test::Baz::_newInstance() const
{
    return new Baz;
}
/// \endcond

const ::std::string&
IceProxy::Test::Baz::ice_staticId()
{
    return ::Test::Baz::ice_staticId();
}

Test::CV::~CV()
{
}

/// \cond INTERNAL
::Ice::Object* Test::upCast(CV* p) { return p; }

/// \endcond
::Ice::ObjectPtr
Test::CV::ice_clone() const
{
    ::Ice::Object* p = new CV(*this);
    return p;
}

namespace
{
const ::std::string iceC_Test_CV_ids[2] =
{
    "::Ice::Object",
    "::Test::CV"
};

}

bool
Test::CV::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_CV_ids, iceC_Test_CV_ids + 2, s);
}

::std::vector< ::std::string>
Test::CV::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Test_CV_ids[0], &iceC_Test_CV_ids[2]);
}

const ::std::string&
Test::CV::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::CV::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::Test::CV";
    return typeId;
#else
    return iceC_Test_CV_ids[1];
#endif
}

/// \cond STREAM
void
Test::CV::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< CV, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Test::CV::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< CV, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

namespace
{
const ::IceInternal::DefaultValueFactoryInit< ::Test::CV> iceC_Test_CV_init("::Test::CV");
}

::Ice::ValueFactoryPtr
Test::CV::ice_factory()
{
    return ::IceInternal::factoryTable->getValueFactory(::Test::CV::ice_staticId());
}

/// \cond INTERNAL
void
Test::_icePatchObjectPtr(CVPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = CVPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(CV::ice_staticId(), v);
    }
}
/// \endcond

Test::I::~I()
{
}

/// \cond INTERNAL
::Ice::Object* Test::upCast(I* p) { return p; }

/// \endcond

namespace
{
const ::std::string iceC_Test_I_ids[2] =
{
    "::Ice::Object",
    "::Test::I"
};

}

bool
Test::I::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_I_ids, iceC_Test_I_ids + 2, s);
}

::std::vector< ::std::string>
Test::I::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Test_I_ids[0], &iceC_Test_I_ids[2]);
}

const ::std::string&
Test::I::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::I::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::Test::I";
    return typeId;
#else
    return iceC_Test_I_ids[1];
#endif
}

/// \cond STREAM
void
Test::I::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< I, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Test::I::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< I, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

/// \cond INTERNAL
void
Test::_icePatchObjectPtr(IPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = IPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(I::ice_staticId(), v);
    }
}
/// \endcond

Test::CR::~CR()
{
}

/// \cond INTERNAL
::Ice::Object* Test::upCast(CR* p) { return p; }

/// \endcond

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(push)
#   pragma warning(disable:4589)
#endif
::Ice::ObjectPtr
Test::CR::ice_clone() const
{
    ::Ice::Object* p = new CR(*this);
    return p;
}
#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#   pragma warning(pop)
#endif

namespace
{
const ::std::string iceC_Test_CR_ids[2] =
{
    "::Ice::Object",
    "::Test::CR"
};

}

bool
Test::CR::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_CR_ids, iceC_Test_CR_ids + 2, s);
}

::std::vector< ::std::string>
Test::CR::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Test_CR_ids[0], &iceC_Test_CR_ids[2]);
}

const ::std::string&
Test::CR::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::CR::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::Test::CR";
    return typeId;
#else
    return iceC_Test_CR_ids[1];
#endif
}

void
Test::CR::_iceGcVisitMembers(::IceInternal::GCVisitor& v_)
{
    if(v)
    {
        if((::Test::upCast(v.get())->_iceGcVisit(v_)))
        {
            v = 0;
        }
    }
}

/// \cond STREAM
void
Test::CR::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< CR, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Test::CR::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< CR, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

namespace
{
const ::IceInternal::DefaultValueFactoryInit< ::Test::CR> iceC_Test_CR_init("::Test::CR");
}

::Ice::ValueFactoryPtr
Test::CR::ice_factory()
{
    return ::IceInternal::factoryTable->getValueFactory(::Test::CR::ice_staticId());
}

/// \cond INTERNAL
void
Test::_icePatchObjectPtr(CRPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = CRPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(CR::ice_staticId(), v);
    }
}
/// \endcond

Test::MyClass::~MyClass()
{
}

/// \cond INTERNAL
::Ice::Object* Test::upCast(MyClass* p) { return p; }

/// \endcond

namespace
{
const ::std::string iceC_Test_MyClass_ids[2] =
{
    "::Ice::Object",
    "::Test::MyClass"
};

}

bool
Test::MyClass::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_MyClass_ids, iceC_Test_MyClass_ids + 2, s);
}

::std::vector< ::std::string>
Test::MyClass::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Test_MyClass_ids[0], &iceC_Test_MyClass_ids[2]);
}

const ::std::string&
Test::MyClass::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::MyClass::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::Test::MyClass";
    return typeId;
#else
    return iceC_Test_MyClass_ids[1];
#endif
}

/// \cond INTERNAL
bool
Test::MyClass::_iceD_shutdown(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    this->shutdown(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opAByteS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    AByteS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    AByteS iceP_o;
    AByteS ret = this->opAByteS(iceP_i, iceP_o, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_o);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opLByteS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    LByteS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    LByteS iceP_o;
    LByteS ret = this->opLByteS(iceP_i, iceP_o, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_o);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opKByteS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    KByteS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    KByteS iceP_o;
    KByteS ret = this->opKByteS(iceP_i, iceP_o, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_o);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opQByteS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    QByteS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    QByteS iceP_o;
    QByteS ret = this->opQByteS(iceP_i, iceP_o, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_o);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opSByteS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    SByteS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    SByteS iceP_o;
    SByteS ret = this->opSByteS(iceP_i, iceP_o, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_o);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opABoolS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ABoolS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    ABoolS iceP_o;
    ABoolS ret = this->opABoolS(iceP_i, iceP_o, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_o);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opLBoolS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    LBoolS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    LBoolS iceP_o;
    LBoolS ret = this->opLBoolS(iceP_i, iceP_o, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_o);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opKBoolS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    KBoolS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    KBoolS iceP_o;
    KBoolS ret = this->opKBoolS(iceP_i, iceP_o, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_o);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opQBoolS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    QBoolS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    QBoolS iceP_o;
    QBoolS ret = this->opQBoolS(iceP_i, iceP_o, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_o);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opSBoolS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    SBoolS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    SBoolS iceP_o;
    SBoolS ret = this->opSBoolS(iceP_i, iceP_o, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_o);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opAShortS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    AShortS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    AShortS iceP_o;
    AShortS ret = this->opAShortS(iceP_i, iceP_o, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_o);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opLShortS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    LShortS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    LShortS iceP_o;
    LShortS ret = this->opLShortS(iceP_i, iceP_o, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_o);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opKShortS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    KShortS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    KShortS iceP_o;
    KShortS ret = this->opKShortS(iceP_i, iceP_o, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_o);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opQShortS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    QShortS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    QShortS iceP_o;
    QShortS ret = this->opQShortS(iceP_i, iceP_o, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_o);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opSShortS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    SShortS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    SShortS iceP_o;
    SShortS ret = this->opSShortS(iceP_i, iceP_o, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_o);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opAIntS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    AIntS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    AIntS iceP_o;
    AIntS ret = this->opAIntS(iceP_i, iceP_o, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_o);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opLIntS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    LIntS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    LIntS iceP_o;
    LIntS ret = this->opLIntS(iceP_i, iceP_o, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_o);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opKIntS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    KIntS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    KIntS iceP_o;
    KIntS ret = this->opKIntS(iceP_i, iceP_o, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_o);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opQIntS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    QIntS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    QIntS iceP_o;
    QIntS ret = this->opQIntS(iceP_i, iceP_o, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_o);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opSIntS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    SIntS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    SIntS iceP_o;
    SIntS ret = this->opSIntS(iceP_i, iceP_o, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_o);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opALongS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ALongS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    ALongS iceP_o;
    ALongS ret = this->opALongS(iceP_i, iceP_o, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_o);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opLLongS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    LLongS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    LLongS iceP_o;
    LLongS ret = this->opLLongS(iceP_i, iceP_o, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_o);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opKLongS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    KLongS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    KLongS iceP_o;
    KLongS ret = this->opKLongS(iceP_i, iceP_o, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_o);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opQLongS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    QLongS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    QLongS iceP_o;
    QLongS ret = this->opQLongS(iceP_i, iceP_o, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_o);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opSLongS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    SLongS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    SLongS iceP_o;
    SLongS ret = this->opSLongS(iceP_i, iceP_o, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_o);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opAFloatS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    AFloatS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    AFloatS iceP_o;
    AFloatS ret = this->opAFloatS(iceP_i, iceP_o, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_o);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opLFloatS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    LFloatS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    LFloatS iceP_o;
    LFloatS ret = this->opLFloatS(iceP_i, iceP_o, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_o);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opKFloatS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    KFloatS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    KFloatS iceP_o;
    KFloatS ret = this->opKFloatS(iceP_i, iceP_o, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_o);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opQFloatS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    QFloatS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    QFloatS iceP_o;
    QFloatS ret = this->opQFloatS(iceP_i, iceP_o, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_o);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opSFloatS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    SFloatS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    SFloatS iceP_o;
    SFloatS ret = this->opSFloatS(iceP_i, iceP_o, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_o);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opADoubleS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ADoubleS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    ADoubleS iceP_o;
    ADoubleS ret = this->opADoubleS(iceP_i, iceP_o, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_o);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opLDoubleS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    LDoubleS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    LDoubleS iceP_o;
    LDoubleS ret = this->opLDoubleS(iceP_i, iceP_o, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_o);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opKDoubleS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    KDoubleS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    KDoubleS iceP_o;
    KDoubleS ret = this->opKDoubleS(iceP_i, iceP_o, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_o);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opQDoubleS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    QDoubleS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    QDoubleS iceP_o;
    QDoubleS ret = this->opQDoubleS(iceP_i, iceP_o, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_o);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opSDoubleS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    SDoubleS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    SDoubleS iceP_o;
    SDoubleS ret = this->opSDoubleS(iceP_i, iceP_o, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_o);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opAStringS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    AStringS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    AStringS iceP_o;
    AStringS ret = this->opAStringS(iceP_i, iceP_o, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_o);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opLStringS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    LStringS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    LStringS iceP_o;
    LStringS ret = this->opLStringS(iceP_i, iceP_o, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_o);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opKStringS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    KStringS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    KStringS iceP_o;
    KStringS ret = this->opKStringS(iceP_i, iceP_o, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_o);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opQStringS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    QStringS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    QStringS iceP_o;
    QStringS ret = this->opQStringS(iceP_i, iceP_o, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_o);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opSStringS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    SStringS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    SStringS iceP_o;
    SStringS ret = this->opSStringS(iceP_i, iceP_o, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_o);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opAObjectS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    AObjectS iceP_i;
    istr->read(iceP_i);
    istr->readPendingValues();
    inS.endReadParams();
    AObjectS iceP_o;
    AObjectS ret = this->opAObjectS(iceP_i, iceP_o, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_o);
    ostr->write(ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opLObjectS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    LObjectS iceP_i;
    istr->read(iceP_i);
    istr->readPendingValues();
    inS.endReadParams();
    LObjectS iceP_o;
    LObjectS ret = this->opLObjectS(iceP_i, iceP_o, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_o);
    ostr->write(ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opAObjectPrxS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    AObjectPrxS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    AObjectPrxS iceP_o;
    AObjectPrxS ret = this->opAObjectPrxS(iceP_i, iceP_o, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_o);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opLObjectPrxS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    LObjectPrxS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    LObjectPrxS iceP_o;
    LObjectPrxS ret = this->opLObjectPrxS(iceP_i, iceP_o, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_o);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opKObjectPrxS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    KObjectPrxS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    KObjectPrxS iceP_o;
    KObjectPrxS ret = this->opKObjectPrxS(iceP_i, iceP_o, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_o);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opQObjectPrxS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    QObjectPrxS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    QObjectPrxS iceP_o;
    QObjectPrxS ret = this->opQObjectPrxS(iceP_i, iceP_o, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_o);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opSObjectPrxS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    SObjectPrxS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    SObjectPrxS iceP_o;
    SObjectPrxS ret = this->opSObjectPrxS(iceP_i, iceP_o, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_o);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opAStructS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    AStructS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    AStructS iceP_o;
    AStructS ret = this->opAStructS(iceP_i, iceP_o, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_o);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opLStructS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    LStructS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    LStructS iceP_o;
    LStructS ret = this->opLStructS(iceP_i, iceP_o, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_o);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opKStructS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    KStructS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    KStructS iceP_o;
    KStructS ret = this->opKStructS(iceP_i, iceP_o, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_o);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opQStructS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    QStructS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    QStructS iceP_o;
    QStructS ret = this->opQStructS(iceP_i, iceP_o, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_o);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opSStructS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    SStructS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    SStructS iceP_o;
    SStructS ret = this->opSStructS(iceP_i, iceP_o, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_o);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opAStructSD(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    AStructSD iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    AStructSD iceP_o;
    AStructSD ret = this->opAStructSD(iceP_i, iceP_o, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_o);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opLStructSD(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    LStructSD iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    LStructSD iceP_o;
    LStructSD ret = this->opLStructSD(iceP_i, iceP_o, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_o);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opKStructSD(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    KStructSD iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    KStructSD iceP_o;
    KStructSD ret = this->opKStructSD(iceP_i, iceP_o, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_o);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opQStructSD(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    QStructSD iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    QStructSD iceP_o;
    QStructSD ret = this->opQStructSD(iceP_i, iceP_o, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_o);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opSStructSD(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    SStructSD iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    SStructSD iceP_o;
    SStructSD ret = this->opSStructSD(iceP_i, iceP_o, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_o);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opACVS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ACVS iceP_i;
    istr->read(iceP_i);
    istr->readPendingValues();
    inS.endReadParams();
    ACVS iceP_o;
    ACVS ret = this->opACVS(iceP_i, iceP_o, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_o);
    ostr->write(ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opLCVS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    LCVS iceP_i;
    istr->read(iceP_i);
    istr->readPendingValues();
    inS.endReadParams();
    LCVS iceP_o;
    LCVS ret = this->opLCVS(iceP_i, iceP_o, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_o);
    ostr->write(ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opACRS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ACRS iceP_i;
    istr->read(iceP_i);
    istr->readPendingValues();
    inS.endReadParams();
    ACRS iceP_o;
    ACRS ret = this->opACRS(iceP_i, iceP_o, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_o);
    ostr->write(ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opLCRS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    LCRS iceP_i;
    istr->read(iceP_i);
    istr->readPendingValues();
    inS.endReadParams();
    LCRS iceP_o;
    LCRS ret = this->opLCRS(iceP_i, iceP_o, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_o);
    ostr->write(ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opAEnS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    AEnS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    AEnS iceP_o;
    AEnS ret = this->opAEnS(iceP_i, iceP_o, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_o);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opLEnS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    LEnS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    LEnS iceP_o;
    LEnS ret = this->opLEnS(iceP_i, iceP_o, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_o);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opKEnS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    KEnS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    KEnS iceP_o;
    KEnS ret = this->opKEnS(iceP_i, iceP_o, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_o);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opQEnS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    QEnS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    QEnS iceP_o;
    QEnS ret = this->opQEnS(iceP_i, iceP_o, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_o);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opSEnS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    SEnS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    SEnS iceP_o;
    SEnS ret = this->opSEnS(iceP_i, iceP_o, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_o);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opAIPrxS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    AIPrxS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    AIPrxS iceP_o;
    AIPrxS ret = this->opAIPrxS(iceP_i, iceP_o, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_o);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opLIPrxS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    LIPrxS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    LIPrxS iceP_o;
    LIPrxS ret = this->opLIPrxS(iceP_i, iceP_o, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_o);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opKIPrxS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    KIPrxS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    KIPrxS iceP_o;
    KIPrxS ret = this->opKIPrxS(iceP_i, iceP_o, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_o);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opQIPrxS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    QIPrxS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    QIPrxS iceP_o;
    QIPrxS ret = this->opQIPrxS(iceP_i, iceP_o, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_o);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opSIPrxS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    SIPrxS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    SIPrxS iceP_o;
    SIPrxS ret = this->opSIPrxS(iceP_i, iceP_o, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_o);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opCustomIntS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    CustomIntS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    CustomIntS iceP_o;
    CustomIntS ret = this->opCustomIntS(iceP_i, iceP_o, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_o);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opCustomCVS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    CustomCVS iceP_i;
    istr->read(iceP_i);
    istr->readPendingValues();
    inS.endReadParams();
    CustomCVS iceP_o;
    CustomCVS ret = this->opCustomCVS(iceP_i, iceP_o, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_o);
    ostr->write(ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opCustomIntSS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    CustomIntSS iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    CustomIntSS iceP_o;
    CustomIntSS ret = this->opCustomIntSS(iceP_i, iceP_o, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_o);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opCustomCVSS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    CustomCVSS iceP_i;
    istr->read(iceP_i);
    istr->readPendingValues();
    inS.endReadParams();
    CustomCVSS iceP_o;
    CustomCVSS ret = this->opCustomCVSS(iceP_i, iceP_o, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_o);
    ostr->write(ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opSerialSmallCSharp(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    SerialSmall iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    SerialSmall iceP_o;
    SerialSmall ret = this->opSerialSmallCSharp(iceP_i, iceP_o, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_o);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opSerialLargeCSharp(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    SerialLarge iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    SerialLarge iceP_o;
    SerialLarge ret = this->opSerialLargeCSharp(iceP_i, iceP_o, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_o);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opSerialStructCSharp(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    SerialStruct iceP_i;
    istr->read(iceP_i);
    inS.endReadParams();
    SerialStruct iceP_o;
    SerialStruct ret = this->opSerialStructCSharp(iceP_i, iceP_o, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_o);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

namespace
{
const ::std::string iceC_Test_MyClass_all[] =
{
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "opABoolS",
    "opAByteS",
    "opACRS",
    "opACVS",
    "opADoubleS",
    "opAEnS",
    "opAFloatS",
    "opAIPrxS",
    "opAIntS",
    "opALongS",
    "opAObjectPrxS",
    "opAObjectS",
    "opAShortS",
    "opAStringS",
    "opAStructS",
    "opAStructSD",
    "opCustomCVS",
    "opCustomCVSS",
    "opCustomIntS",
    "opCustomIntSS",
    "opKBoolS",
    "opKByteS",
    "opKDoubleS",
    "opKEnS",
    "opKFloatS",
    "opKIPrxS",
    "opKIntS",
    "opKLongS",
    "opKObjectPrxS",
    "opKShortS",
    "opKStringS",
    "opKStructS",
    "opKStructSD",
    "opLBoolS",
    "opLByteS",
    "opLCRS",
    "opLCVS",
    "opLDoubleS",
    "opLEnS",
    "opLFloatS",
    "opLIPrxS",
    "opLIntS",
    "opLLongS",
    "opLObjectPrxS",
    "opLObjectS",
    "opLShortS",
    "opLStringS",
    "opLStructS",
    "opLStructSD",
    "opQBoolS",
    "opQByteS",
    "opQDoubleS",
    "opQEnS",
    "opQFloatS",
    "opQIPrxS",
    "opQIntS",
    "opQLongS",
    "opQObjectPrxS",
    "opQShortS",
    "opQStringS",
    "opQStructS",
    "opQStructSD",
    "opSBoolS",
    "opSByteS",
    "opSDoubleS",
    "opSEnS",
    "opSFloatS",
    "opSIPrxS",
    "opSIntS",
    "opSLongS",
    "opSObjectPrxS",
    "opSShortS",
    "opSStringS",
    "opSStructS",
    "opSStructSD",
    "opSerialLargeCSharp",
    "opSerialSmallCSharp",
    "opSerialStructCSharp",
    "shutdown"
};

}

/// \cond INTERNAL
bool
Test::MyClass::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_Test_MyClass_all, iceC_Test_MyClass_all + 83, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_Test_MyClass_all)
    {
        case 0:
        {
            return _iceD_ice_id(in, current);
        }
        case 1:
        {
            return _iceD_ice_ids(in, current);
        }
        case 2:
        {
            return _iceD_ice_isA(in, current);
        }
        case 3:
        {
            return _iceD_ice_ping(in, current);
        }
        case 4:
        {
            return _iceD_opABoolS(in, current);
        }
        case 5:
        {
            return _iceD_opAByteS(in, current);
        }
        case 6:
        {
            return _iceD_opACRS(in, current);
        }
        case 7:
        {
            return _iceD_opACVS(in, current);
        }
        case 8:
        {
            return _iceD_opADoubleS(in, current);
        }
        case 9:
        {
            return _iceD_opAEnS(in, current);
        }
        case 10:
        {
            return _iceD_opAFloatS(in, current);
        }
        case 11:
        {
            return _iceD_opAIPrxS(in, current);
        }
        case 12:
        {
            return _iceD_opAIntS(in, current);
        }
        case 13:
        {
            return _iceD_opALongS(in, current);
        }
        case 14:
        {
            return _iceD_opAObjectPrxS(in, current);
        }
        case 15:
        {
            return _iceD_opAObjectS(in, current);
        }
        case 16:
        {
            return _iceD_opAShortS(in, current);
        }
        case 17:
        {
            return _iceD_opAStringS(in, current);
        }
        case 18:
        {
            return _iceD_opAStructS(in, current);
        }
        case 19:
        {
            return _iceD_opAStructSD(in, current);
        }
        case 20:
        {
            return _iceD_opCustomCVS(in, current);
        }
        case 21:
        {
            return _iceD_opCustomCVSS(in, current);
        }
        case 22:
        {
            return _iceD_opCustomIntS(in, current);
        }
        case 23:
        {
            return _iceD_opCustomIntSS(in, current);
        }
        case 24:
        {
            return _iceD_opKBoolS(in, current);
        }
        case 25:
        {
            return _iceD_opKByteS(in, current);
        }
        case 26:
        {
            return _iceD_opKDoubleS(in, current);
        }
        case 27:
        {
            return _iceD_opKEnS(in, current);
        }
        case 28:
        {
            return _iceD_opKFloatS(in, current);
        }
        case 29:
        {
            return _iceD_opKIPrxS(in, current);
        }
        case 30:
        {
            return _iceD_opKIntS(in, current);
        }
        case 31:
        {
            return _iceD_opKLongS(in, current);
        }
        case 32:
        {
            return _iceD_opKObjectPrxS(in, current);
        }
        case 33:
        {
            return _iceD_opKShortS(in, current);
        }
        case 34:
        {
            return _iceD_opKStringS(in, current);
        }
        case 35:
        {
            return _iceD_opKStructS(in, current);
        }
        case 36:
        {
            return _iceD_opKStructSD(in, current);
        }
        case 37:
        {
            return _iceD_opLBoolS(in, current);
        }
        case 38:
        {
            return _iceD_opLByteS(in, current);
        }
        case 39:
        {
            return _iceD_opLCRS(in, current);
        }
        case 40:
        {
            return _iceD_opLCVS(in, current);
        }
        case 41:
        {
            return _iceD_opLDoubleS(in, current);
        }
        case 42:
        {
            return _iceD_opLEnS(in, current);
        }
        case 43:
        {
            return _iceD_opLFloatS(in, current);
        }
        case 44:
        {
            return _iceD_opLIPrxS(in, current);
        }
        case 45:
        {
            return _iceD_opLIntS(in, current);
        }
        case 46:
        {
            return _iceD_opLLongS(in, current);
        }
        case 47:
        {
            return _iceD_opLObjectPrxS(in, current);
        }
        case 48:
        {
            return _iceD_opLObjectS(in, current);
        }
        case 49:
        {
            return _iceD_opLShortS(in, current);
        }
        case 50:
        {
            return _iceD_opLStringS(in, current);
        }
        case 51:
        {
            return _iceD_opLStructS(in, current);
        }
        case 52:
        {
            return _iceD_opLStructSD(in, current);
        }
        case 53:
        {
            return _iceD_opQBoolS(in, current);
        }
        case 54:
        {
            return _iceD_opQByteS(in, current);
        }
        case 55:
        {
            return _iceD_opQDoubleS(in, current);
        }
        case 56:
        {
            return _iceD_opQEnS(in, current);
        }
        case 57:
        {
            return _iceD_opQFloatS(in, current);
        }
        case 58:
        {
            return _iceD_opQIPrxS(in, current);
        }
        case 59:
        {
            return _iceD_opQIntS(in, current);
        }
        case 60:
        {
            return _iceD_opQLongS(in, current);
        }
        case 61:
        {
            return _iceD_opQObjectPrxS(in, current);
        }
        case 62:
        {
            return _iceD_opQShortS(in, current);
        }
        case 63:
        {
            return _iceD_opQStringS(in, current);
        }
        case 64:
        {
            return _iceD_opQStructS(in, current);
        }
        case 65:
        {
            return _iceD_opQStructSD(in, current);
        }
        case 66:
        {
            return _iceD_opSBoolS(in, current);
        }
        case 67:
        {
            return _iceD_opSByteS(in, current);
        }
        case 68:
        {
            return _iceD_opSDoubleS(in, current);
        }
        case 69:
        {
            return _iceD_opSEnS(in, current);
        }
        case 70:
        {
            return _iceD_opSFloatS(in, current);
        }
        case 71:
        {
            return _iceD_opSIPrxS(in, current);
        }
        case 72:
        {
            return _iceD_opSIntS(in, current);
        }
        case 73:
        {
            return _iceD_opSLongS(in, current);
        }
        case 74:
        {
            return _iceD_opSObjectPrxS(in, current);
        }
        case 75:
        {
            return _iceD_opSShortS(in, current);
        }
        case 76:
        {
            return _iceD_opSStringS(in, current);
        }
        case 77:
        {
            return _iceD_opSStructS(in, current);
        }
        case 78:
        {
            return _iceD_opSStructSD(in, current);
        }
        case 79:
        {
            return _iceD_opSerialLargeCSharp(in, current);
        }
        case 80:
        {
            return _iceD_opSerialSmallCSharp(in, current);
        }
        case 81:
        {
            return _iceD_opSerialStructCSharp(in, current);
        }
        case 82:
        {
            return _iceD_shutdown(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

/// \cond STREAM
void
Test::MyClass::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< MyClass, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Test::MyClass::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< MyClass, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

/// \cond INTERNAL
void
Test::_icePatchObjectPtr(MyClassPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = MyClassPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(MyClass::ice_staticId(), v);
    }
}
/// \endcond

Test::Baz::~Baz()
{
}

/// \cond INTERNAL
::Ice::Object* Test::upCast(Baz* p) { return p; }

/// \endcond
::Ice::ObjectPtr
Test::Baz::ice_clone() const
{
    ::Ice::Object* p = new Baz(*this);
    return p;
}

namespace
{
const ::std::string iceC_Test_Baz_ids[2] =
{
    "::Ice::Object",
    "::Test::Baz"
};

}

bool
Test::Baz::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_Baz_ids, iceC_Test_Baz_ids + 2, s);
}

::std::vector< ::std::string>
Test::Baz::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Test_Baz_ids[0], &iceC_Test_Baz_ids[2]);
}

const ::std::string&
Test::Baz::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::Baz::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::Test::Baz";
    return typeId;
#else
    return iceC_Test_Baz_ids[1];
#endif
}

/// \cond STREAM
void
Test::Baz::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< Baz, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Test::Baz::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< Baz, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

namespace
{
const ::IceInternal::DefaultValueFactoryInit< ::Test::Baz> iceC_Test_Baz_init("::Test::Baz");
}

::Ice::ValueFactoryPtr
Test::Baz::ice_factory()
{
    return ::IceInternal::factoryTable->getValueFactory(::Test::Baz::ice_staticId());
}

/// \cond INTERNAL
void
Test::_icePatchObjectPtr(BazPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = BazPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(Baz::ice_staticId(), v);
    }
}
/// \endcond

namespace Ice
{
}

#endif
