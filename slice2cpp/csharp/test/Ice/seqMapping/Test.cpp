//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.8.0-alpha.0
//
// <auto-generated>
//
// Generated from file `Test.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#define ICE_BUILDING_GENERATED_CODE
#include <Test.h>
#include <Ice/OutgoingAsync.h>

#if defined(_MSC_VER)
#   pragma warning(disable:4458) // declaration of ... hides class member
#elif defined(__clang__)
#   pragma clang diagnostic ignored "-Wshadow"
#elif defined(__GNUC__)
#   pragma GCC diagnostic ignored "-Wshadow"
#endif

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION  != 30850
#       error Ice version mismatch: an exact match is required for beta generated code
#   endif
#endif

namespace
{

const ::IceInternal::DefaultValueFactoryInit<::Test::CV> iceC_Test_CV_init("::Test::CV");

const ::std::string iceC_Test_I_ids[2] =
{
    "::Ice::Object",
    "::Test::I"
};
const ::std::string iceC_Test_I_ops[] =
{
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};

const ::IceInternal::DefaultValueFactoryInit<::Test::CR> iceC_Test_CR_init("::Test::CR");

const ::std::string iceC_Test_MyClass_ids[2] =
{
    "::Ice::Object",
    "::Test::MyClass"
};
const ::std::string iceC_Test_MyClass_ops[] =
{
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "opABoolS",
    "opAByteS",
    "opACRS",
    "opACVS",
    "opADoubleS",
    "opAEnS",
    "opAFloatS",
    "opAIPrxS",
    "opAIntS",
    "opALongS",
    "opAObjectPrxS",
    "opAObjectS",
    "opAShortS",
    "opAStringS",
    "opAStructS",
    "opAStructSD",
    "opCustomCVS",
    "opCustomCVSS",
    "opCustomIntS",
    "opCustomIntSS",
    "opKBoolS",
    "opKByteS",
    "opKDoubleS",
    "opKEnS",
    "opKFloatS",
    "opKIPrxS",
    "opKIntS",
    "opKLongS",
    "opKObjectPrxS",
    "opKShortS",
    "opKStringS",
    "opKStructS",
    "opKStructSD",
    "opLBoolS",
    "opLByteS",
    "opLCRS",
    "opLCVS",
    "opLDoubleS",
    "opLEnS",
    "opLFloatS",
    "opLIPrxS",
    "opLIntS",
    "opLLongS",
    "opLObjectPrxS",
    "opLObjectS",
    "opLShortS",
    "opLStringS",
    "opLStructS",
    "opLStructSD",
    "opQBoolS",
    "opQByteS",
    "opQDoubleS",
    "opQEnS",
    "opQFloatS",
    "opQIPrxS",
    "opQIntS",
    "opQLongS",
    "opQObjectPrxS",
    "opQShortS",
    "opQStringS",
    "opQStructS",
    "opQStructSD",
    "opSBoolS",
    "opSByteS",
    "opSDoubleS",
    "opSEnS",
    "opSFloatS",
    "opSIPrxS",
    "opSIntS",
    "opSLongS",
    "opSObjectPrxS",
    "opSShortS",
    "opSStringS",
    "opSStructS",
    "opSStructSD",
    "shutdown"
};
const ::std::string iceC_Test_MyClass_shutdown_name = "shutdown";
const ::std::string iceC_Test_MyClass_opAByteS_name = "opAByteS";
const ::std::string iceC_Test_MyClass_opLByteS_name = "opLByteS";
const ::std::string iceC_Test_MyClass_opKByteS_name = "opKByteS";
const ::std::string iceC_Test_MyClass_opQByteS_name = "opQByteS";
const ::std::string iceC_Test_MyClass_opSByteS_name = "opSByteS";
const ::std::string iceC_Test_MyClass_opABoolS_name = "opABoolS";
const ::std::string iceC_Test_MyClass_opLBoolS_name = "opLBoolS";
const ::std::string iceC_Test_MyClass_opKBoolS_name = "opKBoolS";
const ::std::string iceC_Test_MyClass_opQBoolS_name = "opQBoolS";
const ::std::string iceC_Test_MyClass_opSBoolS_name = "opSBoolS";
const ::std::string iceC_Test_MyClass_opAShortS_name = "opAShortS";
const ::std::string iceC_Test_MyClass_opLShortS_name = "opLShortS";
const ::std::string iceC_Test_MyClass_opKShortS_name = "opKShortS";
const ::std::string iceC_Test_MyClass_opQShortS_name = "opQShortS";
const ::std::string iceC_Test_MyClass_opSShortS_name = "opSShortS";
const ::std::string iceC_Test_MyClass_opAIntS_name = "opAIntS";
const ::std::string iceC_Test_MyClass_opLIntS_name = "opLIntS";
const ::std::string iceC_Test_MyClass_opKIntS_name = "opKIntS";
const ::std::string iceC_Test_MyClass_opQIntS_name = "opQIntS";
const ::std::string iceC_Test_MyClass_opSIntS_name = "opSIntS";
const ::std::string iceC_Test_MyClass_opALongS_name = "opALongS";
const ::std::string iceC_Test_MyClass_opLLongS_name = "opLLongS";
const ::std::string iceC_Test_MyClass_opKLongS_name = "opKLongS";
const ::std::string iceC_Test_MyClass_opQLongS_name = "opQLongS";
const ::std::string iceC_Test_MyClass_opSLongS_name = "opSLongS";
const ::std::string iceC_Test_MyClass_opAFloatS_name = "opAFloatS";
const ::std::string iceC_Test_MyClass_opLFloatS_name = "opLFloatS";
const ::std::string iceC_Test_MyClass_opKFloatS_name = "opKFloatS";
const ::std::string iceC_Test_MyClass_opQFloatS_name = "opQFloatS";
const ::std::string iceC_Test_MyClass_opSFloatS_name = "opSFloatS";
const ::std::string iceC_Test_MyClass_opADoubleS_name = "opADoubleS";
const ::std::string iceC_Test_MyClass_opLDoubleS_name = "opLDoubleS";
const ::std::string iceC_Test_MyClass_opKDoubleS_name = "opKDoubleS";
const ::std::string iceC_Test_MyClass_opQDoubleS_name = "opQDoubleS";
const ::std::string iceC_Test_MyClass_opSDoubleS_name = "opSDoubleS";
const ::std::string iceC_Test_MyClass_opAStringS_name = "opAStringS";
const ::std::string iceC_Test_MyClass_opLStringS_name = "opLStringS";
const ::std::string iceC_Test_MyClass_opKStringS_name = "opKStringS";
const ::std::string iceC_Test_MyClass_opQStringS_name = "opQStringS";
const ::std::string iceC_Test_MyClass_opSStringS_name = "opSStringS";
const ::std::string iceC_Test_MyClass_opAObjectS_name = "opAObjectS";
const ::std::string iceC_Test_MyClass_opLObjectS_name = "opLObjectS";
const ::std::string iceC_Test_MyClass_opAObjectPrxS_name = "opAObjectPrxS";
const ::std::string iceC_Test_MyClass_opLObjectPrxS_name = "opLObjectPrxS";
const ::std::string iceC_Test_MyClass_opKObjectPrxS_name = "opKObjectPrxS";
const ::std::string iceC_Test_MyClass_opQObjectPrxS_name = "opQObjectPrxS";
const ::std::string iceC_Test_MyClass_opSObjectPrxS_name = "opSObjectPrxS";
const ::std::string iceC_Test_MyClass_opAStructS_name = "opAStructS";
const ::std::string iceC_Test_MyClass_opLStructS_name = "opLStructS";
const ::std::string iceC_Test_MyClass_opKStructS_name = "opKStructS";
const ::std::string iceC_Test_MyClass_opQStructS_name = "opQStructS";
const ::std::string iceC_Test_MyClass_opSStructS_name = "opSStructS";
const ::std::string iceC_Test_MyClass_opAStructSD_name = "opAStructSD";
const ::std::string iceC_Test_MyClass_opLStructSD_name = "opLStructSD";
const ::std::string iceC_Test_MyClass_opKStructSD_name = "opKStructSD";
const ::std::string iceC_Test_MyClass_opQStructSD_name = "opQStructSD";
const ::std::string iceC_Test_MyClass_opSStructSD_name = "opSStructSD";
const ::std::string iceC_Test_MyClass_opACVS_name = "opACVS";
const ::std::string iceC_Test_MyClass_opLCVS_name = "opLCVS";
const ::std::string iceC_Test_MyClass_opACRS_name = "opACRS";
const ::std::string iceC_Test_MyClass_opLCRS_name = "opLCRS";
const ::std::string iceC_Test_MyClass_opAEnS_name = "opAEnS";
const ::std::string iceC_Test_MyClass_opLEnS_name = "opLEnS";
const ::std::string iceC_Test_MyClass_opKEnS_name = "opKEnS";
const ::std::string iceC_Test_MyClass_opQEnS_name = "opQEnS";
const ::std::string iceC_Test_MyClass_opSEnS_name = "opSEnS";
const ::std::string iceC_Test_MyClass_opAIPrxS_name = "opAIPrxS";
const ::std::string iceC_Test_MyClass_opLIPrxS_name = "opLIPrxS";
const ::std::string iceC_Test_MyClass_opKIPrxS_name = "opKIPrxS";
const ::std::string iceC_Test_MyClass_opQIPrxS_name = "opQIPrxS";
const ::std::string iceC_Test_MyClass_opSIPrxS_name = "opSIPrxS";
const ::std::string iceC_Test_MyClass_opCustomIntS_name = "opCustomIntS";
const ::std::string iceC_Test_MyClass_opCustomCVS_name = "opCustomCVS";
const ::std::string iceC_Test_MyClass_opCustomIntSS_name = "opCustomIntSS";
const ::std::string iceC_Test_MyClass_opCustomCVSS_name = "opCustomCVSS";

}

const ::std::string&
Test::IPrx::ice_staticId()
{
    static const ::std::string typeId = "::Test::I";
    return typeId;
}

void
Test::MyClassPrx::shutdown(const ::Ice::Context& context) const
{
    ::IceInternal::makePromiseOutgoing<void>(true, this, &MyClassPrx::_iceI_shutdown, context).get();
}

::std::future<void>
Test::MyClassPrx::shutdownAsync(const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<void>(false, this, &MyClassPrx::_iceI_shutdown, context);
}

::std::function<void()>
Test::MyClassPrx::shutdownAsync(::std::function<void ()> response,
                                ::std::function<void(::std::exception_ptr)> ex,
                                ::std::function<void(bool)> sent,
                                const ::Ice::Context& context) const
{
    return ::IceInternal::makeLambdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_shutdown, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_shutdown(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::Ice::Context& context) const
{
    outAsync->invoke(iceC_Test_MyClass_shutdown_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

::Test::AByteS
Test::MyClassPrx::opAByteS(const AByteS& iceP_i, AByteS& iceP_o, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<AByteS, AByteS>>(true, this, &MyClassPrx::_iceI_opAByteS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::AByteS, ::Test::AByteS>>
Test::MyClassPrx::opAByteSAsync(const AByteS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<AByteS, AByteS>>(false, this, &MyClassPrx::_iceI_opAByteS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opAByteSAsync(const AByteS& iceP_i,
                                ::std::function<void (::Test::AByteS, ::Test::AByteS)> response,
                                ::std::function<void(::std::exception_ptr)> ex,
                                ::std::function<void(bool)> sent,
                                const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<AByteS, AByteS>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<AByteS, AByteS>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opAByteS, iceP_i, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opAByteS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<AByteS, AByteS>>>& outAsync, const AByteS& iceP_i, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_MyClass_opAByteS_name);
    outAsync->invoke(iceC_Test_MyClass_opAByteS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<AByteS, AByteS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::LByteS
Test::MyClassPrx::opLByteS(const LByteS& iceP_i, LByteS& iceP_o, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<LByteS, LByteS>>(true, this, &MyClassPrx::_iceI_opLByteS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::LByteS, ::Test::LByteS>>
Test::MyClassPrx::opLByteSAsync(const LByteS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<LByteS, LByteS>>(false, this, &MyClassPrx::_iceI_opLByteS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opLByteSAsync(const LByteS& iceP_i,
                                ::std::function<void (::Test::LByteS, ::Test::LByteS)> response,
                                ::std::function<void(::std::exception_ptr)> ex,
                                ::std::function<void(bool)> sent,
                                const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<LByteS, LByteS>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<LByteS, LByteS>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opLByteS, iceP_i, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opLByteS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<LByteS, LByteS>>>& outAsync, const LByteS& iceP_i, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_MyClass_opLByteS_name);
    outAsync->invoke(iceC_Test_MyClass_opLByteS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<LByteS, LByteS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::KByteS
Test::MyClassPrx::opKByteS(const KByteS& iceP_i, KByteS& iceP_o, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<KByteS, KByteS>>(true, this, &MyClassPrx::_iceI_opKByteS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::KByteS, ::Test::KByteS>>
Test::MyClassPrx::opKByteSAsync(const KByteS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<KByteS, KByteS>>(false, this, &MyClassPrx::_iceI_opKByteS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opKByteSAsync(const KByteS& iceP_i,
                                ::std::function<void (::Test::KByteS, ::Test::KByteS)> response,
                                ::std::function<void(::std::exception_ptr)> ex,
                                ::std::function<void(bool)> sent,
                                const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<KByteS, KByteS>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<KByteS, KByteS>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opKByteS, iceP_i, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opKByteS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<KByteS, KByteS>>>& outAsync, const KByteS& iceP_i, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_MyClass_opKByteS_name);
    outAsync->invoke(iceC_Test_MyClass_opKByteS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<KByteS, KByteS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::QByteS
Test::MyClassPrx::opQByteS(const QByteS& iceP_i, QByteS& iceP_o, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<QByteS, QByteS>>(true, this, &MyClassPrx::_iceI_opQByteS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::QByteS, ::Test::QByteS>>
Test::MyClassPrx::opQByteSAsync(const QByteS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<QByteS, QByteS>>(false, this, &MyClassPrx::_iceI_opQByteS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opQByteSAsync(const QByteS& iceP_i,
                                ::std::function<void (::Test::QByteS, ::Test::QByteS)> response,
                                ::std::function<void(::std::exception_ptr)> ex,
                                ::std::function<void(bool)> sent,
                                const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<QByteS, QByteS>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<QByteS, QByteS>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opQByteS, iceP_i, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opQByteS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<QByteS, QByteS>>>& outAsync, const QByteS& iceP_i, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_MyClass_opQByteS_name);
    outAsync->invoke(iceC_Test_MyClass_opQByteS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<QByteS, QByteS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::SByteS
Test::MyClassPrx::opSByteS(const SByteS& iceP_i, SByteS& iceP_o, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<SByteS, SByteS>>(true, this, &MyClassPrx::_iceI_opSByteS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::SByteS, ::Test::SByteS>>
Test::MyClassPrx::opSByteSAsync(const SByteS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<SByteS, SByteS>>(false, this, &MyClassPrx::_iceI_opSByteS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opSByteSAsync(const SByteS& iceP_i,
                                ::std::function<void (::Test::SByteS, ::Test::SByteS)> response,
                                ::std::function<void(::std::exception_ptr)> ex,
                                ::std::function<void(bool)> sent,
                                const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<SByteS, SByteS>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<SByteS, SByteS>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opSByteS, iceP_i, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opSByteS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<SByteS, SByteS>>>& outAsync, const SByteS& iceP_i, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_MyClass_opSByteS_name);
    outAsync->invoke(iceC_Test_MyClass_opSByteS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<SByteS, SByteS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::ABoolS
Test::MyClassPrx::opABoolS(const ABoolS& iceP_i, ABoolS& iceP_o, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<ABoolS, ABoolS>>(true, this, &MyClassPrx::_iceI_opABoolS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::ABoolS, ::Test::ABoolS>>
Test::MyClassPrx::opABoolSAsync(const ABoolS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<ABoolS, ABoolS>>(false, this, &MyClassPrx::_iceI_opABoolS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opABoolSAsync(const ABoolS& iceP_i,
                                ::std::function<void (::Test::ABoolS, ::Test::ABoolS)> response,
                                ::std::function<void(::std::exception_ptr)> ex,
                                ::std::function<void(bool)> sent,
                                const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<ABoolS, ABoolS>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<ABoolS, ABoolS>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opABoolS, iceP_i, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opABoolS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<ABoolS, ABoolS>>>& outAsync, const ABoolS& iceP_i, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_MyClass_opABoolS_name);
    outAsync->invoke(iceC_Test_MyClass_opABoolS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<ABoolS, ABoolS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::LBoolS
Test::MyClassPrx::opLBoolS(const LBoolS& iceP_i, LBoolS& iceP_o, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<LBoolS, LBoolS>>(true, this, &MyClassPrx::_iceI_opLBoolS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::LBoolS, ::Test::LBoolS>>
Test::MyClassPrx::opLBoolSAsync(const LBoolS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<LBoolS, LBoolS>>(false, this, &MyClassPrx::_iceI_opLBoolS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opLBoolSAsync(const LBoolS& iceP_i,
                                ::std::function<void (::Test::LBoolS, ::Test::LBoolS)> response,
                                ::std::function<void(::std::exception_ptr)> ex,
                                ::std::function<void(bool)> sent,
                                const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<LBoolS, LBoolS>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<LBoolS, LBoolS>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opLBoolS, iceP_i, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opLBoolS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<LBoolS, LBoolS>>>& outAsync, const LBoolS& iceP_i, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_MyClass_opLBoolS_name);
    outAsync->invoke(iceC_Test_MyClass_opLBoolS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<LBoolS, LBoolS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::KBoolS
Test::MyClassPrx::opKBoolS(const KBoolS& iceP_i, KBoolS& iceP_o, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<KBoolS, KBoolS>>(true, this, &MyClassPrx::_iceI_opKBoolS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::KBoolS, ::Test::KBoolS>>
Test::MyClassPrx::opKBoolSAsync(const KBoolS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<KBoolS, KBoolS>>(false, this, &MyClassPrx::_iceI_opKBoolS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opKBoolSAsync(const KBoolS& iceP_i,
                                ::std::function<void (::Test::KBoolS, ::Test::KBoolS)> response,
                                ::std::function<void(::std::exception_ptr)> ex,
                                ::std::function<void(bool)> sent,
                                const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<KBoolS, KBoolS>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<KBoolS, KBoolS>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opKBoolS, iceP_i, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opKBoolS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<KBoolS, KBoolS>>>& outAsync, const KBoolS& iceP_i, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_MyClass_opKBoolS_name);
    outAsync->invoke(iceC_Test_MyClass_opKBoolS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<KBoolS, KBoolS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::QBoolS
Test::MyClassPrx::opQBoolS(const QBoolS& iceP_i, QBoolS& iceP_o, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<QBoolS, QBoolS>>(true, this, &MyClassPrx::_iceI_opQBoolS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::QBoolS, ::Test::QBoolS>>
Test::MyClassPrx::opQBoolSAsync(const QBoolS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<QBoolS, QBoolS>>(false, this, &MyClassPrx::_iceI_opQBoolS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opQBoolSAsync(const QBoolS& iceP_i,
                                ::std::function<void (::Test::QBoolS, ::Test::QBoolS)> response,
                                ::std::function<void(::std::exception_ptr)> ex,
                                ::std::function<void(bool)> sent,
                                const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<QBoolS, QBoolS>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<QBoolS, QBoolS>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opQBoolS, iceP_i, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opQBoolS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<QBoolS, QBoolS>>>& outAsync, const QBoolS& iceP_i, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_MyClass_opQBoolS_name);
    outAsync->invoke(iceC_Test_MyClass_opQBoolS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<QBoolS, QBoolS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::SBoolS
Test::MyClassPrx::opSBoolS(const SBoolS& iceP_i, SBoolS& iceP_o, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<SBoolS, SBoolS>>(true, this, &MyClassPrx::_iceI_opSBoolS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::SBoolS, ::Test::SBoolS>>
Test::MyClassPrx::opSBoolSAsync(const SBoolS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<SBoolS, SBoolS>>(false, this, &MyClassPrx::_iceI_opSBoolS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opSBoolSAsync(const SBoolS& iceP_i,
                                ::std::function<void (::Test::SBoolS, ::Test::SBoolS)> response,
                                ::std::function<void(::std::exception_ptr)> ex,
                                ::std::function<void(bool)> sent,
                                const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<SBoolS, SBoolS>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<SBoolS, SBoolS>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opSBoolS, iceP_i, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opSBoolS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<SBoolS, SBoolS>>>& outAsync, const SBoolS& iceP_i, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_MyClass_opSBoolS_name);
    outAsync->invoke(iceC_Test_MyClass_opSBoolS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<SBoolS, SBoolS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::AShortS
Test::MyClassPrx::opAShortS(const AShortS& iceP_i, AShortS& iceP_o, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<AShortS, AShortS>>(true, this, &MyClassPrx::_iceI_opAShortS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::AShortS, ::Test::AShortS>>
Test::MyClassPrx::opAShortSAsync(const AShortS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<AShortS, AShortS>>(false, this, &MyClassPrx::_iceI_opAShortS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opAShortSAsync(const AShortS& iceP_i,
                                 ::std::function<void (::Test::AShortS, ::Test::AShortS)> response,
                                 ::std::function<void(::std::exception_ptr)> ex,
                                 ::std::function<void(bool)> sent,
                                 const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<AShortS, AShortS>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<AShortS, AShortS>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opAShortS, iceP_i, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opAShortS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<AShortS, AShortS>>>& outAsync, const AShortS& iceP_i, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_MyClass_opAShortS_name);
    outAsync->invoke(iceC_Test_MyClass_opAShortS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<AShortS, AShortS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::LShortS
Test::MyClassPrx::opLShortS(const LShortS& iceP_i, LShortS& iceP_o, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<LShortS, LShortS>>(true, this, &MyClassPrx::_iceI_opLShortS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::LShortS, ::Test::LShortS>>
Test::MyClassPrx::opLShortSAsync(const LShortS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<LShortS, LShortS>>(false, this, &MyClassPrx::_iceI_opLShortS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opLShortSAsync(const LShortS& iceP_i,
                                 ::std::function<void (::Test::LShortS, ::Test::LShortS)> response,
                                 ::std::function<void(::std::exception_ptr)> ex,
                                 ::std::function<void(bool)> sent,
                                 const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<LShortS, LShortS>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<LShortS, LShortS>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opLShortS, iceP_i, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opLShortS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<LShortS, LShortS>>>& outAsync, const LShortS& iceP_i, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_MyClass_opLShortS_name);
    outAsync->invoke(iceC_Test_MyClass_opLShortS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<LShortS, LShortS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::KShortS
Test::MyClassPrx::opKShortS(const KShortS& iceP_i, KShortS& iceP_o, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<KShortS, KShortS>>(true, this, &MyClassPrx::_iceI_opKShortS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::KShortS, ::Test::KShortS>>
Test::MyClassPrx::opKShortSAsync(const KShortS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<KShortS, KShortS>>(false, this, &MyClassPrx::_iceI_opKShortS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opKShortSAsync(const KShortS& iceP_i,
                                 ::std::function<void (::Test::KShortS, ::Test::KShortS)> response,
                                 ::std::function<void(::std::exception_ptr)> ex,
                                 ::std::function<void(bool)> sent,
                                 const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<KShortS, KShortS>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<KShortS, KShortS>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opKShortS, iceP_i, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opKShortS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<KShortS, KShortS>>>& outAsync, const KShortS& iceP_i, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_MyClass_opKShortS_name);
    outAsync->invoke(iceC_Test_MyClass_opKShortS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<KShortS, KShortS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::QShortS
Test::MyClassPrx::opQShortS(const QShortS& iceP_i, QShortS& iceP_o, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<QShortS, QShortS>>(true, this, &MyClassPrx::_iceI_opQShortS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::QShortS, ::Test::QShortS>>
Test::MyClassPrx::opQShortSAsync(const QShortS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<QShortS, QShortS>>(false, this, &MyClassPrx::_iceI_opQShortS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opQShortSAsync(const QShortS& iceP_i,
                                 ::std::function<void (::Test::QShortS, ::Test::QShortS)> response,
                                 ::std::function<void(::std::exception_ptr)> ex,
                                 ::std::function<void(bool)> sent,
                                 const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<QShortS, QShortS>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<QShortS, QShortS>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opQShortS, iceP_i, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opQShortS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<QShortS, QShortS>>>& outAsync, const QShortS& iceP_i, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_MyClass_opQShortS_name);
    outAsync->invoke(iceC_Test_MyClass_opQShortS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<QShortS, QShortS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::SShortS
Test::MyClassPrx::opSShortS(const SShortS& iceP_i, SShortS& iceP_o, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<SShortS, SShortS>>(true, this, &MyClassPrx::_iceI_opSShortS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::SShortS, ::Test::SShortS>>
Test::MyClassPrx::opSShortSAsync(const SShortS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<SShortS, SShortS>>(false, this, &MyClassPrx::_iceI_opSShortS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opSShortSAsync(const SShortS& iceP_i,
                                 ::std::function<void (::Test::SShortS, ::Test::SShortS)> response,
                                 ::std::function<void(::std::exception_ptr)> ex,
                                 ::std::function<void(bool)> sent,
                                 const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<SShortS, SShortS>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<SShortS, SShortS>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opSShortS, iceP_i, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opSShortS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<SShortS, SShortS>>>& outAsync, const SShortS& iceP_i, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_MyClass_opSShortS_name);
    outAsync->invoke(iceC_Test_MyClass_opSShortS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<SShortS, SShortS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::AIntS
Test::MyClassPrx::opAIntS(const AIntS& iceP_i, AIntS& iceP_o, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<AIntS, AIntS>>(true, this, &MyClassPrx::_iceI_opAIntS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::AIntS, ::Test::AIntS>>
Test::MyClassPrx::opAIntSAsync(const AIntS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<AIntS, AIntS>>(false, this, &MyClassPrx::_iceI_opAIntS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opAIntSAsync(const AIntS& iceP_i,
                               ::std::function<void (::Test::AIntS, ::Test::AIntS)> response,
                               ::std::function<void(::std::exception_ptr)> ex,
                               ::std::function<void(bool)> sent,
                               const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<AIntS, AIntS>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<AIntS, AIntS>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opAIntS, iceP_i, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opAIntS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<AIntS, AIntS>>>& outAsync, const AIntS& iceP_i, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_MyClass_opAIntS_name);
    outAsync->invoke(iceC_Test_MyClass_opAIntS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<AIntS, AIntS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::LIntS
Test::MyClassPrx::opLIntS(const LIntS& iceP_i, LIntS& iceP_o, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<LIntS, LIntS>>(true, this, &MyClassPrx::_iceI_opLIntS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::LIntS, ::Test::LIntS>>
Test::MyClassPrx::opLIntSAsync(const LIntS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<LIntS, LIntS>>(false, this, &MyClassPrx::_iceI_opLIntS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opLIntSAsync(const LIntS& iceP_i,
                               ::std::function<void (::Test::LIntS, ::Test::LIntS)> response,
                               ::std::function<void(::std::exception_ptr)> ex,
                               ::std::function<void(bool)> sent,
                               const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<LIntS, LIntS>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<LIntS, LIntS>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opLIntS, iceP_i, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opLIntS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<LIntS, LIntS>>>& outAsync, const LIntS& iceP_i, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_MyClass_opLIntS_name);
    outAsync->invoke(iceC_Test_MyClass_opLIntS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<LIntS, LIntS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::KIntS
Test::MyClassPrx::opKIntS(const KIntS& iceP_i, KIntS& iceP_o, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<KIntS, KIntS>>(true, this, &MyClassPrx::_iceI_opKIntS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::KIntS, ::Test::KIntS>>
Test::MyClassPrx::opKIntSAsync(const KIntS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<KIntS, KIntS>>(false, this, &MyClassPrx::_iceI_opKIntS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opKIntSAsync(const KIntS& iceP_i,
                               ::std::function<void (::Test::KIntS, ::Test::KIntS)> response,
                               ::std::function<void(::std::exception_ptr)> ex,
                               ::std::function<void(bool)> sent,
                               const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<KIntS, KIntS>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<KIntS, KIntS>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opKIntS, iceP_i, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opKIntS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<KIntS, KIntS>>>& outAsync, const KIntS& iceP_i, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_MyClass_opKIntS_name);
    outAsync->invoke(iceC_Test_MyClass_opKIntS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<KIntS, KIntS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::QIntS
Test::MyClassPrx::opQIntS(const QIntS& iceP_i, QIntS& iceP_o, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<QIntS, QIntS>>(true, this, &MyClassPrx::_iceI_opQIntS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::QIntS, ::Test::QIntS>>
Test::MyClassPrx::opQIntSAsync(const QIntS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<QIntS, QIntS>>(false, this, &MyClassPrx::_iceI_opQIntS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opQIntSAsync(const QIntS& iceP_i,
                               ::std::function<void (::Test::QIntS, ::Test::QIntS)> response,
                               ::std::function<void(::std::exception_ptr)> ex,
                               ::std::function<void(bool)> sent,
                               const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<QIntS, QIntS>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<QIntS, QIntS>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opQIntS, iceP_i, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opQIntS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<QIntS, QIntS>>>& outAsync, const QIntS& iceP_i, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_MyClass_opQIntS_name);
    outAsync->invoke(iceC_Test_MyClass_opQIntS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<QIntS, QIntS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::SIntS
Test::MyClassPrx::opSIntS(const SIntS& iceP_i, SIntS& iceP_o, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<SIntS, SIntS>>(true, this, &MyClassPrx::_iceI_opSIntS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::SIntS, ::Test::SIntS>>
Test::MyClassPrx::opSIntSAsync(const SIntS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<SIntS, SIntS>>(false, this, &MyClassPrx::_iceI_opSIntS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opSIntSAsync(const SIntS& iceP_i,
                               ::std::function<void (::Test::SIntS, ::Test::SIntS)> response,
                               ::std::function<void(::std::exception_ptr)> ex,
                               ::std::function<void(bool)> sent,
                               const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<SIntS, SIntS>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<SIntS, SIntS>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opSIntS, iceP_i, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opSIntS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<SIntS, SIntS>>>& outAsync, const SIntS& iceP_i, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_MyClass_opSIntS_name);
    outAsync->invoke(iceC_Test_MyClass_opSIntS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<SIntS, SIntS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::ALongS
Test::MyClassPrx::opALongS(const ALongS& iceP_i, ALongS& iceP_o, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<ALongS, ALongS>>(true, this, &MyClassPrx::_iceI_opALongS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::ALongS, ::Test::ALongS>>
Test::MyClassPrx::opALongSAsync(const ALongS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<ALongS, ALongS>>(false, this, &MyClassPrx::_iceI_opALongS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opALongSAsync(const ALongS& iceP_i,
                                ::std::function<void (::Test::ALongS, ::Test::ALongS)> response,
                                ::std::function<void(::std::exception_ptr)> ex,
                                ::std::function<void(bool)> sent,
                                const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<ALongS, ALongS>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<ALongS, ALongS>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opALongS, iceP_i, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opALongS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<ALongS, ALongS>>>& outAsync, const ALongS& iceP_i, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_MyClass_opALongS_name);
    outAsync->invoke(iceC_Test_MyClass_opALongS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<ALongS, ALongS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::LLongS
Test::MyClassPrx::opLLongS(const LLongS& iceP_i, LLongS& iceP_o, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<LLongS, LLongS>>(true, this, &MyClassPrx::_iceI_opLLongS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::LLongS, ::Test::LLongS>>
Test::MyClassPrx::opLLongSAsync(const LLongS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<LLongS, LLongS>>(false, this, &MyClassPrx::_iceI_opLLongS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opLLongSAsync(const LLongS& iceP_i,
                                ::std::function<void (::Test::LLongS, ::Test::LLongS)> response,
                                ::std::function<void(::std::exception_ptr)> ex,
                                ::std::function<void(bool)> sent,
                                const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<LLongS, LLongS>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<LLongS, LLongS>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opLLongS, iceP_i, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opLLongS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<LLongS, LLongS>>>& outAsync, const LLongS& iceP_i, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_MyClass_opLLongS_name);
    outAsync->invoke(iceC_Test_MyClass_opLLongS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<LLongS, LLongS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::KLongS
Test::MyClassPrx::opKLongS(const KLongS& iceP_i, KLongS& iceP_o, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<KLongS, KLongS>>(true, this, &MyClassPrx::_iceI_opKLongS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::KLongS, ::Test::KLongS>>
Test::MyClassPrx::opKLongSAsync(const KLongS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<KLongS, KLongS>>(false, this, &MyClassPrx::_iceI_opKLongS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opKLongSAsync(const KLongS& iceP_i,
                                ::std::function<void (::Test::KLongS, ::Test::KLongS)> response,
                                ::std::function<void(::std::exception_ptr)> ex,
                                ::std::function<void(bool)> sent,
                                const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<KLongS, KLongS>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<KLongS, KLongS>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opKLongS, iceP_i, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opKLongS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<KLongS, KLongS>>>& outAsync, const KLongS& iceP_i, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_MyClass_opKLongS_name);
    outAsync->invoke(iceC_Test_MyClass_opKLongS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<KLongS, KLongS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::QLongS
Test::MyClassPrx::opQLongS(const QLongS& iceP_i, QLongS& iceP_o, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<QLongS, QLongS>>(true, this, &MyClassPrx::_iceI_opQLongS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::QLongS, ::Test::QLongS>>
Test::MyClassPrx::opQLongSAsync(const QLongS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<QLongS, QLongS>>(false, this, &MyClassPrx::_iceI_opQLongS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opQLongSAsync(const QLongS& iceP_i,
                                ::std::function<void (::Test::QLongS, ::Test::QLongS)> response,
                                ::std::function<void(::std::exception_ptr)> ex,
                                ::std::function<void(bool)> sent,
                                const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<QLongS, QLongS>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<QLongS, QLongS>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opQLongS, iceP_i, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opQLongS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<QLongS, QLongS>>>& outAsync, const QLongS& iceP_i, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_MyClass_opQLongS_name);
    outAsync->invoke(iceC_Test_MyClass_opQLongS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<QLongS, QLongS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::SLongS
Test::MyClassPrx::opSLongS(const SLongS& iceP_i, SLongS& iceP_o, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<SLongS, SLongS>>(true, this, &MyClassPrx::_iceI_opSLongS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::SLongS, ::Test::SLongS>>
Test::MyClassPrx::opSLongSAsync(const SLongS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<SLongS, SLongS>>(false, this, &MyClassPrx::_iceI_opSLongS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opSLongSAsync(const SLongS& iceP_i,
                                ::std::function<void (::Test::SLongS, ::Test::SLongS)> response,
                                ::std::function<void(::std::exception_ptr)> ex,
                                ::std::function<void(bool)> sent,
                                const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<SLongS, SLongS>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<SLongS, SLongS>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opSLongS, iceP_i, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opSLongS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<SLongS, SLongS>>>& outAsync, const SLongS& iceP_i, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_MyClass_opSLongS_name);
    outAsync->invoke(iceC_Test_MyClass_opSLongS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<SLongS, SLongS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::AFloatS
Test::MyClassPrx::opAFloatS(const AFloatS& iceP_i, AFloatS& iceP_o, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<AFloatS, AFloatS>>(true, this, &MyClassPrx::_iceI_opAFloatS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::AFloatS, ::Test::AFloatS>>
Test::MyClassPrx::opAFloatSAsync(const AFloatS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<AFloatS, AFloatS>>(false, this, &MyClassPrx::_iceI_opAFloatS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opAFloatSAsync(const AFloatS& iceP_i,
                                 ::std::function<void (::Test::AFloatS, ::Test::AFloatS)> response,
                                 ::std::function<void(::std::exception_ptr)> ex,
                                 ::std::function<void(bool)> sent,
                                 const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<AFloatS, AFloatS>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<AFloatS, AFloatS>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opAFloatS, iceP_i, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opAFloatS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<AFloatS, AFloatS>>>& outAsync, const AFloatS& iceP_i, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_MyClass_opAFloatS_name);
    outAsync->invoke(iceC_Test_MyClass_opAFloatS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<AFloatS, AFloatS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::LFloatS
Test::MyClassPrx::opLFloatS(const LFloatS& iceP_i, LFloatS& iceP_o, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<LFloatS, LFloatS>>(true, this, &MyClassPrx::_iceI_opLFloatS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::LFloatS, ::Test::LFloatS>>
Test::MyClassPrx::opLFloatSAsync(const LFloatS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<LFloatS, LFloatS>>(false, this, &MyClassPrx::_iceI_opLFloatS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opLFloatSAsync(const LFloatS& iceP_i,
                                 ::std::function<void (::Test::LFloatS, ::Test::LFloatS)> response,
                                 ::std::function<void(::std::exception_ptr)> ex,
                                 ::std::function<void(bool)> sent,
                                 const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<LFloatS, LFloatS>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<LFloatS, LFloatS>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opLFloatS, iceP_i, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opLFloatS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<LFloatS, LFloatS>>>& outAsync, const LFloatS& iceP_i, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_MyClass_opLFloatS_name);
    outAsync->invoke(iceC_Test_MyClass_opLFloatS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<LFloatS, LFloatS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::KFloatS
Test::MyClassPrx::opKFloatS(const KFloatS& iceP_i, KFloatS& iceP_o, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<KFloatS, KFloatS>>(true, this, &MyClassPrx::_iceI_opKFloatS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::KFloatS, ::Test::KFloatS>>
Test::MyClassPrx::opKFloatSAsync(const KFloatS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<KFloatS, KFloatS>>(false, this, &MyClassPrx::_iceI_opKFloatS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opKFloatSAsync(const KFloatS& iceP_i,
                                 ::std::function<void (::Test::KFloatS, ::Test::KFloatS)> response,
                                 ::std::function<void(::std::exception_ptr)> ex,
                                 ::std::function<void(bool)> sent,
                                 const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<KFloatS, KFloatS>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<KFloatS, KFloatS>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opKFloatS, iceP_i, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opKFloatS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<KFloatS, KFloatS>>>& outAsync, const KFloatS& iceP_i, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_MyClass_opKFloatS_name);
    outAsync->invoke(iceC_Test_MyClass_opKFloatS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<KFloatS, KFloatS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::QFloatS
Test::MyClassPrx::opQFloatS(const QFloatS& iceP_i, QFloatS& iceP_o, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<QFloatS, QFloatS>>(true, this, &MyClassPrx::_iceI_opQFloatS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::QFloatS, ::Test::QFloatS>>
Test::MyClassPrx::opQFloatSAsync(const QFloatS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<QFloatS, QFloatS>>(false, this, &MyClassPrx::_iceI_opQFloatS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opQFloatSAsync(const QFloatS& iceP_i,
                                 ::std::function<void (::Test::QFloatS, ::Test::QFloatS)> response,
                                 ::std::function<void(::std::exception_ptr)> ex,
                                 ::std::function<void(bool)> sent,
                                 const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<QFloatS, QFloatS>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<QFloatS, QFloatS>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opQFloatS, iceP_i, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opQFloatS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<QFloatS, QFloatS>>>& outAsync, const QFloatS& iceP_i, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_MyClass_opQFloatS_name);
    outAsync->invoke(iceC_Test_MyClass_opQFloatS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<QFloatS, QFloatS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::SFloatS
Test::MyClassPrx::opSFloatS(const SFloatS& iceP_i, SFloatS& iceP_o, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<SFloatS, SFloatS>>(true, this, &MyClassPrx::_iceI_opSFloatS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::SFloatS, ::Test::SFloatS>>
Test::MyClassPrx::opSFloatSAsync(const SFloatS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<SFloatS, SFloatS>>(false, this, &MyClassPrx::_iceI_opSFloatS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opSFloatSAsync(const SFloatS& iceP_i,
                                 ::std::function<void (::Test::SFloatS, ::Test::SFloatS)> response,
                                 ::std::function<void(::std::exception_ptr)> ex,
                                 ::std::function<void(bool)> sent,
                                 const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<SFloatS, SFloatS>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<SFloatS, SFloatS>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opSFloatS, iceP_i, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opSFloatS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<SFloatS, SFloatS>>>& outAsync, const SFloatS& iceP_i, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_MyClass_opSFloatS_name);
    outAsync->invoke(iceC_Test_MyClass_opSFloatS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<SFloatS, SFloatS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::ADoubleS
Test::MyClassPrx::opADoubleS(const ADoubleS& iceP_i, ADoubleS& iceP_o, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<ADoubleS, ADoubleS>>(true, this, &MyClassPrx::_iceI_opADoubleS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::ADoubleS, ::Test::ADoubleS>>
Test::MyClassPrx::opADoubleSAsync(const ADoubleS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<ADoubleS, ADoubleS>>(false, this, &MyClassPrx::_iceI_opADoubleS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opADoubleSAsync(const ADoubleS& iceP_i,
                                  ::std::function<void (::Test::ADoubleS, ::Test::ADoubleS)> response,
                                  ::std::function<void(::std::exception_ptr)> ex,
                                  ::std::function<void(bool)> sent,
                                  const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<ADoubleS, ADoubleS>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<ADoubleS, ADoubleS>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opADoubleS, iceP_i, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opADoubleS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<ADoubleS, ADoubleS>>>& outAsync, const ADoubleS& iceP_i, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_MyClass_opADoubleS_name);
    outAsync->invoke(iceC_Test_MyClass_opADoubleS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<ADoubleS, ADoubleS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::LDoubleS
Test::MyClassPrx::opLDoubleS(const LDoubleS& iceP_i, LDoubleS& iceP_o, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<LDoubleS, LDoubleS>>(true, this, &MyClassPrx::_iceI_opLDoubleS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::LDoubleS, ::Test::LDoubleS>>
Test::MyClassPrx::opLDoubleSAsync(const LDoubleS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<LDoubleS, LDoubleS>>(false, this, &MyClassPrx::_iceI_opLDoubleS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opLDoubleSAsync(const LDoubleS& iceP_i,
                                  ::std::function<void (::Test::LDoubleS, ::Test::LDoubleS)> response,
                                  ::std::function<void(::std::exception_ptr)> ex,
                                  ::std::function<void(bool)> sent,
                                  const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<LDoubleS, LDoubleS>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<LDoubleS, LDoubleS>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opLDoubleS, iceP_i, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opLDoubleS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<LDoubleS, LDoubleS>>>& outAsync, const LDoubleS& iceP_i, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_MyClass_opLDoubleS_name);
    outAsync->invoke(iceC_Test_MyClass_opLDoubleS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<LDoubleS, LDoubleS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::KDoubleS
Test::MyClassPrx::opKDoubleS(const KDoubleS& iceP_i, KDoubleS& iceP_o, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<KDoubleS, KDoubleS>>(true, this, &MyClassPrx::_iceI_opKDoubleS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::KDoubleS, ::Test::KDoubleS>>
Test::MyClassPrx::opKDoubleSAsync(const KDoubleS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<KDoubleS, KDoubleS>>(false, this, &MyClassPrx::_iceI_opKDoubleS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opKDoubleSAsync(const KDoubleS& iceP_i,
                                  ::std::function<void (::Test::KDoubleS, ::Test::KDoubleS)> response,
                                  ::std::function<void(::std::exception_ptr)> ex,
                                  ::std::function<void(bool)> sent,
                                  const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<KDoubleS, KDoubleS>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<KDoubleS, KDoubleS>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opKDoubleS, iceP_i, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opKDoubleS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<KDoubleS, KDoubleS>>>& outAsync, const KDoubleS& iceP_i, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_MyClass_opKDoubleS_name);
    outAsync->invoke(iceC_Test_MyClass_opKDoubleS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<KDoubleS, KDoubleS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::QDoubleS
Test::MyClassPrx::opQDoubleS(const QDoubleS& iceP_i, QDoubleS& iceP_o, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<QDoubleS, QDoubleS>>(true, this, &MyClassPrx::_iceI_opQDoubleS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::QDoubleS, ::Test::QDoubleS>>
Test::MyClassPrx::opQDoubleSAsync(const QDoubleS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<QDoubleS, QDoubleS>>(false, this, &MyClassPrx::_iceI_opQDoubleS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opQDoubleSAsync(const QDoubleS& iceP_i,
                                  ::std::function<void (::Test::QDoubleS, ::Test::QDoubleS)> response,
                                  ::std::function<void(::std::exception_ptr)> ex,
                                  ::std::function<void(bool)> sent,
                                  const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<QDoubleS, QDoubleS>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<QDoubleS, QDoubleS>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opQDoubleS, iceP_i, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opQDoubleS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<QDoubleS, QDoubleS>>>& outAsync, const QDoubleS& iceP_i, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_MyClass_opQDoubleS_name);
    outAsync->invoke(iceC_Test_MyClass_opQDoubleS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<QDoubleS, QDoubleS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::SDoubleS
Test::MyClassPrx::opSDoubleS(const SDoubleS& iceP_i, SDoubleS& iceP_o, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<SDoubleS, SDoubleS>>(true, this, &MyClassPrx::_iceI_opSDoubleS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::SDoubleS, ::Test::SDoubleS>>
Test::MyClassPrx::opSDoubleSAsync(const SDoubleS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<SDoubleS, SDoubleS>>(false, this, &MyClassPrx::_iceI_opSDoubleS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opSDoubleSAsync(const SDoubleS& iceP_i,
                                  ::std::function<void (::Test::SDoubleS, ::Test::SDoubleS)> response,
                                  ::std::function<void(::std::exception_ptr)> ex,
                                  ::std::function<void(bool)> sent,
                                  const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<SDoubleS, SDoubleS>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<SDoubleS, SDoubleS>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opSDoubleS, iceP_i, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opSDoubleS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<SDoubleS, SDoubleS>>>& outAsync, const SDoubleS& iceP_i, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_MyClass_opSDoubleS_name);
    outAsync->invoke(iceC_Test_MyClass_opSDoubleS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<SDoubleS, SDoubleS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::AStringS
Test::MyClassPrx::opAStringS(const AStringS& iceP_i, AStringS& iceP_o, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<AStringS, AStringS>>(true, this, &MyClassPrx::_iceI_opAStringS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::AStringS, ::Test::AStringS>>
Test::MyClassPrx::opAStringSAsync(const AStringS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<AStringS, AStringS>>(false, this, &MyClassPrx::_iceI_opAStringS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opAStringSAsync(const AStringS& iceP_i,
                                  ::std::function<void (::Test::AStringS, ::Test::AStringS)> response,
                                  ::std::function<void(::std::exception_ptr)> ex,
                                  ::std::function<void(bool)> sent,
                                  const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<AStringS, AStringS>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<AStringS, AStringS>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opAStringS, iceP_i, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opAStringS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<AStringS, AStringS>>>& outAsync, const AStringS& iceP_i, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_MyClass_opAStringS_name);
    outAsync->invoke(iceC_Test_MyClass_opAStringS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<AStringS, AStringS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::LStringS
Test::MyClassPrx::opLStringS(const LStringS& iceP_i, LStringS& iceP_o, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<LStringS, LStringS>>(true, this, &MyClassPrx::_iceI_opLStringS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::LStringS, ::Test::LStringS>>
Test::MyClassPrx::opLStringSAsync(const LStringS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<LStringS, LStringS>>(false, this, &MyClassPrx::_iceI_opLStringS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opLStringSAsync(const LStringS& iceP_i,
                                  ::std::function<void (::Test::LStringS, ::Test::LStringS)> response,
                                  ::std::function<void(::std::exception_ptr)> ex,
                                  ::std::function<void(bool)> sent,
                                  const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<LStringS, LStringS>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<LStringS, LStringS>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opLStringS, iceP_i, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opLStringS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<LStringS, LStringS>>>& outAsync, const LStringS& iceP_i, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_MyClass_opLStringS_name);
    outAsync->invoke(iceC_Test_MyClass_opLStringS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<LStringS, LStringS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::KStringS
Test::MyClassPrx::opKStringS(const KStringS& iceP_i, KStringS& iceP_o, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<KStringS, KStringS>>(true, this, &MyClassPrx::_iceI_opKStringS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::KStringS, ::Test::KStringS>>
Test::MyClassPrx::opKStringSAsync(const KStringS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<KStringS, KStringS>>(false, this, &MyClassPrx::_iceI_opKStringS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opKStringSAsync(const KStringS& iceP_i,
                                  ::std::function<void (::Test::KStringS, ::Test::KStringS)> response,
                                  ::std::function<void(::std::exception_ptr)> ex,
                                  ::std::function<void(bool)> sent,
                                  const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<KStringS, KStringS>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<KStringS, KStringS>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opKStringS, iceP_i, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opKStringS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<KStringS, KStringS>>>& outAsync, const KStringS& iceP_i, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_MyClass_opKStringS_name);
    outAsync->invoke(iceC_Test_MyClass_opKStringS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<KStringS, KStringS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::QStringS
Test::MyClassPrx::opQStringS(const QStringS& iceP_i, QStringS& iceP_o, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<QStringS, QStringS>>(true, this, &MyClassPrx::_iceI_opQStringS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::QStringS, ::Test::QStringS>>
Test::MyClassPrx::opQStringSAsync(const QStringS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<QStringS, QStringS>>(false, this, &MyClassPrx::_iceI_opQStringS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opQStringSAsync(const QStringS& iceP_i,
                                  ::std::function<void (::Test::QStringS, ::Test::QStringS)> response,
                                  ::std::function<void(::std::exception_ptr)> ex,
                                  ::std::function<void(bool)> sent,
                                  const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<QStringS, QStringS>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<QStringS, QStringS>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opQStringS, iceP_i, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opQStringS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<QStringS, QStringS>>>& outAsync, const QStringS& iceP_i, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_MyClass_opQStringS_name);
    outAsync->invoke(iceC_Test_MyClass_opQStringS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<QStringS, QStringS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::SStringS
Test::MyClassPrx::opSStringS(const SStringS& iceP_i, SStringS& iceP_o, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<SStringS, SStringS>>(true, this, &MyClassPrx::_iceI_opSStringS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::SStringS, ::Test::SStringS>>
Test::MyClassPrx::opSStringSAsync(const SStringS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<SStringS, SStringS>>(false, this, &MyClassPrx::_iceI_opSStringS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opSStringSAsync(const SStringS& iceP_i,
                                  ::std::function<void (::Test::SStringS, ::Test::SStringS)> response,
                                  ::std::function<void(::std::exception_ptr)> ex,
                                  ::std::function<void(bool)> sent,
                                  const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<SStringS, SStringS>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<SStringS, SStringS>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opSStringS, iceP_i, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opSStringS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<SStringS, SStringS>>>& outAsync, const SStringS& iceP_i, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_MyClass_opSStringS_name);
    outAsync->invoke(iceC_Test_MyClass_opSStringS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<SStringS, SStringS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::AObjectS
Test::MyClassPrx::opAObjectS(const AObjectS& iceP_i, AObjectS& iceP_o, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<AObjectS, AObjectS>>(true, this, &MyClassPrx::_iceI_opAObjectS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::AObjectS, ::Test::AObjectS>>
Test::MyClassPrx::opAObjectSAsync(const AObjectS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<AObjectS, AObjectS>>(false, this, &MyClassPrx::_iceI_opAObjectS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opAObjectSAsync(const AObjectS& iceP_i,
                                  ::std::function<void (::Test::AObjectS, ::Test::AObjectS)> response,
                                  ::std::function<void(::std::exception_ptr)> ex,
                                  ::std::function<void(bool)> sent,
                                  const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<AObjectS, AObjectS>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<AObjectS, AObjectS>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opAObjectS, iceP_i, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opAObjectS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<AObjectS, AObjectS>>>& outAsync, const AObjectS& iceP_i, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_MyClass_opAObjectS_name);
    outAsync->invoke(iceC_Test_MyClass_opAObjectS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
            ostr->writePendingValues();
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<AObjectS, AObjectS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            istr->readPendingValues();
            return v;
        });
}
/// \endcond

::Test::LObjectS
Test::MyClassPrx::opLObjectS(const LObjectS& iceP_i, LObjectS& iceP_o, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<LObjectS, LObjectS>>(true, this, &MyClassPrx::_iceI_opLObjectS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::LObjectS, ::Test::LObjectS>>
Test::MyClassPrx::opLObjectSAsync(const LObjectS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<LObjectS, LObjectS>>(false, this, &MyClassPrx::_iceI_opLObjectS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opLObjectSAsync(const LObjectS& iceP_i,
                                  ::std::function<void (::Test::LObjectS, ::Test::LObjectS)> response,
                                  ::std::function<void(::std::exception_ptr)> ex,
                                  ::std::function<void(bool)> sent,
                                  const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<LObjectS, LObjectS>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<LObjectS, LObjectS>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opLObjectS, iceP_i, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opLObjectS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<LObjectS, LObjectS>>>& outAsync, const LObjectS& iceP_i, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_MyClass_opLObjectS_name);
    outAsync->invoke(iceC_Test_MyClass_opLObjectS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
            ostr->writePendingValues();
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<LObjectS, LObjectS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            istr->readPendingValues();
            return v;
        });
}
/// \endcond

::Test::AObjectPrxS
Test::MyClassPrx::opAObjectPrxS(const AObjectPrxS& iceP_i, AObjectPrxS& iceP_o, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<AObjectPrxS, AObjectPrxS>>(true, this, &MyClassPrx::_iceI_opAObjectPrxS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::AObjectPrxS, ::Test::AObjectPrxS>>
Test::MyClassPrx::opAObjectPrxSAsync(const AObjectPrxS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<AObjectPrxS, AObjectPrxS>>(false, this, &MyClassPrx::_iceI_opAObjectPrxS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opAObjectPrxSAsync(const AObjectPrxS& iceP_i,
                                     ::std::function<void (::Test::AObjectPrxS, ::Test::AObjectPrxS)> response,
                                     ::std::function<void(::std::exception_ptr)> ex,
                                     ::std::function<void(bool)> sent,
                                     const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<AObjectPrxS, AObjectPrxS>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<AObjectPrxS, AObjectPrxS>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opAObjectPrxS, iceP_i, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opAObjectPrxS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<AObjectPrxS, AObjectPrxS>>>& outAsync, const AObjectPrxS& iceP_i, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_MyClass_opAObjectPrxS_name);
    outAsync->invoke(iceC_Test_MyClass_opAObjectPrxS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<AObjectPrxS, AObjectPrxS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::LObjectPrxS
Test::MyClassPrx::opLObjectPrxS(const LObjectPrxS& iceP_i, LObjectPrxS& iceP_o, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<LObjectPrxS, LObjectPrxS>>(true, this, &MyClassPrx::_iceI_opLObjectPrxS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::LObjectPrxS, ::Test::LObjectPrxS>>
Test::MyClassPrx::opLObjectPrxSAsync(const LObjectPrxS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<LObjectPrxS, LObjectPrxS>>(false, this, &MyClassPrx::_iceI_opLObjectPrxS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opLObjectPrxSAsync(const LObjectPrxS& iceP_i,
                                     ::std::function<void (::Test::LObjectPrxS, ::Test::LObjectPrxS)> response,
                                     ::std::function<void(::std::exception_ptr)> ex,
                                     ::std::function<void(bool)> sent,
                                     const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<LObjectPrxS, LObjectPrxS>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<LObjectPrxS, LObjectPrxS>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opLObjectPrxS, iceP_i, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opLObjectPrxS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<LObjectPrxS, LObjectPrxS>>>& outAsync, const LObjectPrxS& iceP_i, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_MyClass_opLObjectPrxS_name);
    outAsync->invoke(iceC_Test_MyClass_opLObjectPrxS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<LObjectPrxS, LObjectPrxS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::KObjectPrxS
Test::MyClassPrx::opKObjectPrxS(const KObjectPrxS& iceP_i, KObjectPrxS& iceP_o, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<KObjectPrxS, KObjectPrxS>>(true, this, &MyClassPrx::_iceI_opKObjectPrxS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::KObjectPrxS, ::Test::KObjectPrxS>>
Test::MyClassPrx::opKObjectPrxSAsync(const KObjectPrxS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<KObjectPrxS, KObjectPrxS>>(false, this, &MyClassPrx::_iceI_opKObjectPrxS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opKObjectPrxSAsync(const KObjectPrxS& iceP_i,
                                     ::std::function<void (::Test::KObjectPrxS, ::Test::KObjectPrxS)> response,
                                     ::std::function<void(::std::exception_ptr)> ex,
                                     ::std::function<void(bool)> sent,
                                     const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<KObjectPrxS, KObjectPrxS>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<KObjectPrxS, KObjectPrxS>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opKObjectPrxS, iceP_i, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opKObjectPrxS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<KObjectPrxS, KObjectPrxS>>>& outAsync, const KObjectPrxS& iceP_i, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_MyClass_opKObjectPrxS_name);
    outAsync->invoke(iceC_Test_MyClass_opKObjectPrxS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<KObjectPrxS, KObjectPrxS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::QObjectPrxS
Test::MyClassPrx::opQObjectPrxS(const QObjectPrxS& iceP_i, QObjectPrxS& iceP_o, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<QObjectPrxS, QObjectPrxS>>(true, this, &MyClassPrx::_iceI_opQObjectPrxS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::QObjectPrxS, ::Test::QObjectPrxS>>
Test::MyClassPrx::opQObjectPrxSAsync(const QObjectPrxS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<QObjectPrxS, QObjectPrxS>>(false, this, &MyClassPrx::_iceI_opQObjectPrxS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opQObjectPrxSAsync(const QObjectPrxS& iceP_i,
                                     ::std::function<void (::Test::QObjectPrxS, ::Test::QObjectPrxS)> response,
                                     ::std::function<void(::std::exception_ptr)> ex,
                                     ::std::function<void(bool)> sent,
                                     const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<QObjectPrxS, QObjectPrxS>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<QObjectPrxS, QObjectPrxS>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opQObjectPrxS, iceP_i, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opQObjectPrxS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<QObjectPrxS, QObjectPrxS>>>& outAsync, const QObjectPrxS& iceP_i, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_MyClass_opQObjectPrxS_name);
    outAsync->invoke(iceC_Test_MyClass_opQObjectPrxS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<QObjectPrxS, QObjectPrxS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::SObjectPrxS
Test::MyClassPrx::opSObjectPrxS(const SObjectPrxS& iceP_i, SObjectPrxS& iceP_o, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<SObjectPrxS, SObjectPrxS>>(true, this, &MyClassPrx::_iceI_opSObjectPrxS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::SObjectPrxS, ::Test::SObjectPrxS>>
Test::MyClassPrx::opSObjectPrxSAsync(const SObjectPrxS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<SObjectPrxS, SObjectPrxS>>(false, this, &MyClassPrx::_iceI_opSObjectPrxS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opSObjectPrxSAsync(const SObjectPrxS& iceP_i,
                                     ::std::function<void (::Test::SObjectPrxS, ::Test::SObjectPrxS)> response,
                                     ::std::function<void(::std::exception_ptr)> ex,
                                     ::std::function<void(bool)> sent,
                                     const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<SObjectPrxS, SObjectPrxS>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<SObjectPrxS, SObjectPrxS>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opSObjectPrxS, iceP_i, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opSObjectPrxS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<SObjectPrxS, SObjectPrxS>>>& outAsync, const SObjectPrxS& iceP_i, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_MyClass_opSObjectPrxS_name);
    outAsync->invoke(iceC_Test_MyClass_opSObjectPrxS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<SObjectPrxS, SObjectPrxS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::AStructS
Test::MyClassPrx::opAStructS(const AStructS& iceP_i, AStructS& iceP_o, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<AStructS, AStructS>>(true, this, &MyClassPrx::_iceI_opAStructS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::AStructS, ::Test::AStructS>>
Test::MyClassPrx::opAStructSAsync(const AStructS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<AStructS, AStructS>>(false, this, &MyClassPrx::_iceI_opAStructS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opAStructSAsync(const AStructS& iceP_i,
                                  ::std::function<void (::Test::AStructS, ::Test::AStructS)> response,
                                  ::std::function<void(::std::exception_ptr)> ex,
                                  ::std::function<void(bool)> sent,
                                  const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<AStructS, AStructS>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<AStructS, AStructS>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opAStructS, iceP_i, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opAStructS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<AStructS, AStructS>>>& outAsync, const AStructS& iceP_i, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_MyClass_opAStructS_name);
    outAsync->invoke(iceC_Test_MyClass_opAStructS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<AStructS, AStructS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::LStructS
Test::MyClassPrx::opLStructS(const LStructS& iceP_i, LStructS& iceP_o, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<LStructS, LStructS>>(true, this, &MyClassPrx::_iceI_opLStructS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::LStructS, ::Test::LStructS>>
Test::MyClassPrx::opLStructSAsync(const LStructS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<LStructS, LStructS>>(false, this, &MyClassPrx::_iceI_opLStructS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opLStructSAsync(const LStructS& iceP_i,
                                  ::std::function<void (::Test::LStructS, ::Test::LStructS)> response,
                                  ::std::function<void(::std::exception_ptr)> ex,
                                  ::std::function<void(bool)> sent,
                                  const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<LStructS, LStructS>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<LStructS, LStructS>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opLStructS, iceP_i, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opLStructS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<LStructS, LStructS>>>& outAsync, const LStructS& iceP_i, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_MyClass_opLStructS_name);
    outAsync->invoke(iceC_Test_MyClass_opLStructS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<LStructS, LStructS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::KStructS
Test::MyClassPrx::opKStructS(const KStructS& iceP_i, KStructS& iceP_o, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<KStructS, KStructS>>(true, this, &MyClassPrx::_iceI_opKStructS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::KStructS, ::Test::KStructS>>
Test::MyClassPrx::opKStructSAsync(const KStructS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<KStructS, KStructS>>(false, this, &MyClassPrx::_iceI_opKStructS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opKStructSAsync(const KStructS& iceP_i,
                                  ::std::function<void (::Test::KStructS, ::Test::KStructS)> response,
                                  ::std::function<void(::std::exception_ptr)> ex,
                                  ::std::function<void(bool)> sent,
                                  const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<KStructS, KStructS>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<KStructS, KStructS>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opKStructS, iceP_i, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opKStructS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<KStructS, KStructS>>>& outAsync, const KStructS& iceP_i, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_MyClass_opKStructS_name);
    outAsync->invoke(iceC_Test_MyClass_opKStructS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<KStructS, KStructS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::QStructS
Test::MyClassPrx::opQStructS(const QStructS& iceP_i, QStructS& iceP_o, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<QStructS, QStructS>>(true, this, &MyClassPrx::_iceI_opQStructS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::QStructS, ::Test::QStructS>>
Test::MyClassPrx::opQStructSAsync(const QStructS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<QStructS, QStructS>>(false, this, &MyClassPrx::_iceI_opQStructS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opQStructSAsync(const QStructS& iceP_i,
                                  ::std::function<void (::Test::QStructS, ::Test::QStructS)> response,
                                  ::std::function<void(::std::exception_ptr)> ex,
                                  ::std::function<void(bool)> sent,
                                  const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<QStructS, QStructS>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<QStructS, QStructS>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opQStructS, iceP_i, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opQStructS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<QStructS, QStructS>>>& outAsync, const QStructS& iceP_i, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_MyClass_opQStructS_name);
    outAsync->invoke(iceC_Test_MyClass_opQStructS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<QStructS, QStructS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::SStructS
Test::MyClassPrx::opSStructS(const SStructS& iceP_i, SStructS& iceP_o, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<SStructS, SStructS>>(true, this, &MyClassPrx::_iceI_opSStructS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::SStructS, ::Test::SStructS>>
Test::MyClassPrx::opSStructSAsync(const SStructS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<SStructS, SStructS>>(false, this, &MyClassPrx::_iceI_opSStructS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opSStructSAsync(const SStructS& iceP_i,
                                  ::std::function<void (::Test::SStructS, ::Test::SStructS)> response,
                                  ::std::function<void(::std::exception_ptr)> ex,
                                  ::std::function<void(bool)> sent,
                                  const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<SStructS, SStructS>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<SStructS, SStructS>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opSStructS, iceP_i, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opSStructS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<SStructS, SStructS>>>& outAsync, const SStructS& iceP_i, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_MyClass_opSStructS_name);
    outAsync->invoke(iceC_Test_MyClass_opSStructS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<SStructS, SStructS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::AStructSD
Test::MyClassPrx::opAStructSD(const AStructSD& iceP_i, AStructSD& iceP_o, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<AStructSD, AStructSD>>(true, this, &MyClassPrx::_iceI_opAStructSD, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::AStructSD, ::Test::AStructSD>>
Test::MyClassPrx::opAStructSDAsync(const AStructSD& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<AStructSD, AStructSD>>(false, this, &MyClassPrx::_iceI_opAStructSD, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opAStructSDAsync(const AStructSD& iceP_i,
                                   ::std::function<void (::Test::AStructSD, ::Test::AStructSD)> response,
                                   ::std::function<void(::std::exception_ptr)> ex,
                                   ::std::function<void(bool)> sent,
                                   const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<AStructSD, AStructSD>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<AStructSD, AStructSD>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opAStructSD, iceP_i, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opAStructSD(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<AStructSD, AStructSD>>>& outAsync, const AStructSD& iceP_i, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_MyClass_opAStructSD_name);
    outAsync->invoke(iceC_Test_MyClass_opAStructSD_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<AStructSD, AStructSD> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::LStructSD
Test::MyClassPrx::opLStructSD(const LStructSD& iceP_i, LStructSD& iceP_o, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<LStructSD, LStructSD>>(true, this, &MyClassPrx::_iceI_opLStructSD, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::LStructSD, ::Test::LStructSD>>
Test::MyClassPrx::opLStructSDAsync(const LStructSD& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<LStructSD, LStructSD>>(false, this, &MyClassPrx::_iceI_opLStructSD, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opLStructSDAsync(const LStructSD& iceP_i,
                                   ::std::function<void (::Test::LStructSD, ::Test::LStructSD)> response,
                                   ::std::function<void(::std::exception_ptr)> ex,
                                   ::std::function<void(bool)> sent,
                                   const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<LStructSD, LStructSD>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<LStructSD, LStructSD>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opLStructSD, iceP_i, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opLStructSD(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<LStructSD, LStructSD>>>& outAsync, const LStructSD& iceP_i, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_MyClass_opLStructSD_name);
    outAsync->invoke(iceC_Test_MyClass_opLStructSD_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<LStructSD, LStructSD> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::KStructSD
Test::MyClassPrx::opKStructSD(const KStructSD& iceP_i, KStructSD& iceP_o, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<KStructSD, KStructSD>>(true, this, &MyClassPrx::_iceI_opKStructSD, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::KStructSD, ::Test::KStructSD>>
Test::MyClassPrx::opKStructSDAsync(const KStructSD& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<KStructSD, KStructSD>>(false, this, &MyClassPrx::_iceI_opKStructSD, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opKStructSDAsync(const KStructSD& iceP_i,
                                   ::std::function<void (::Test::KStructSD, ::Test::KStructSD)> response,
                                   ::std::function<void(::std::exception_ptr)> ex,
                                   ::std::function<void(bool)> sent,
                                   const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<KStructSD, KStructSD>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<KStructSD, KStructSD>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opKStructSD, iceP_i, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opKStructSD(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<KStructSD, KStructSD>>>& outAsync, const KStructSD& iceP_i, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_MyClass_opKStructSD_name);
    outAsync->invoke(iceC_Test_MyClass_opKStructSD_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<KStructSD, KStructSD> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::QStructSD
Test::MyClassPrx::opQStructSD(const QStructSD& iceP_i, QStructSD& iceP_o, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<QStructSD, QStructSD>>(true, this, &MyClassPrx::_iceI_opQStructSD, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::QStructSD, ::Test::QStructSD>>
Test::MyClassPrx::opQStructSDAsync(const QStructSD& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<QStructSD, QStructSD>>(false, this, &MyClassPrx::_iceI_opQStructSD, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opQStructSDAsync(const QStructSD& iceP_i,
                                   ::std::function<void (::Test::QStructSD, ::Test::QStructSD)> response,
                                   ::std::function<void(::std::exception_ptr)> ex,
                                   ::std::function<void(bool)> sent,
                                   const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<QStructSD, QStructSD>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<QStructSD, QStructSD>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opQStructSD, iceP_i, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opQStructSD(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<QStructSD, QStructSD>>>& outAsync, const QStructSD& iceP_i, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_MyClass_opQStructSD_name);
    outAsync->invoke(iceC_Test_MyClass_opQStructSD_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<QStructSD, QStructSD> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::SStructSD
Test::MyClassPrx::opSStructSD(const SStructSD& iceP_i, SStructSD& iceP_o, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<SStructSD, SStructSD>>(true, this, &MyClassPrx::_iceI_opSStructSD, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::SStructSD, ::Test::SStructSD>>
Test::MyClassPrx::opSStructSDAsync(const SStructSD& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<SStructSD, SStructSD>>(false, this, &MyClassPrx::_iceI_opSStructSD, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opSStructSDAsync(const SStructSD& iceP_i,
                                   ::std::function<void (::Test::SStructSD, ::Test::SStructSD)> response,
                                   ::std::function<void(::std::exception_ptr)> ex,
                                   ::std::function<void(bool)> sent,
                                   const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<SStructSD, SStructSD>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<SStructSD, SStructSD>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opSStructSD, iceP_i, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opSStructSD(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<SStructSD, SStructSD>>>& outAsync, const SStructSD& iceP_i, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_MyClass_opSStructSD_name);
    outAsync->invoke(iceC_Test_MyClass_opSStructSD_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<SStructSD, SStructSD> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::ACVS
Test::MyClassPrx::opACVS(const ACVS& iceP_i, ACVS& iceP_o, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<ACVS, ACVS>>(true, this, &MyClassPrx::_iceI_opACVS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::ACVS, ::Test::ACVS>>
Test::MyClassPrx::opACVSAsync(const ACVS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<ACVS, ACVS>>(false, this, &MyClassPrx::_iceI_opACVS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opACVSAsync(const ACVS& iceP_i,
                              ::std::function<void (::Test::ACVS, ::Test::ACVS)> response,
                              ::std::function<void(::std::exception_ptr)> ex,
                              ::std::function<void(bool)> sent,
                              const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<ACVS, ACVS>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<ACVS, ACVS>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opACVS, iceP_i, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opACVS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<ACVS, ACVS>>>& outAsync, const ACVS& iceP_i, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_MyClass_opACVS_name);
    outAsync->invoke(iceC_Test_MyClass_opACVS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
            ostr->writePendingValues();
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<ACVS, ACVS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            istr->readPendingValues();
            return v;
        });
}
/// \endcond

::Test::LCVS
Test::MyClassPrx::opLCVS(const LCVS& iceP_i, LCVS& iceP_o, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<LCVS, LCVS>>(true, this, &MyClassPrx::_iceI_opLCVS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::LCVS, ::Test::LCVS>>
Test::MyClassPrx::opLCVSAsync(const LCVS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<LCVS, LCVS>>(false, this, &MyClassPrx::_iceI_opLCVS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opLCVSAsync(const LCVS& iceP_i,
                              ::std::function<void (::Test::LCVS, ::Test::LCVS)> response,
                              ::std::function<void(::std::exception_ptr)> ex,
                              ::std::function<void(bool)> sent,
                              const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<LCVS, LCVS>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<LCVS, LCVS>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opLCVS, iceP_i, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opLCVS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<LCVS, LCVS>>>& outAsync, const LCVS& iceP_i, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_MyClass_opLCVS_name);
    outAsync->invoke(iceC_Test_MyClass_opLCVS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
            ostr->writePendingValues();
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<LCVS, LCVS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            istr->readPendingValues();
            return v;
        });
}
/// \endcond

::Test::ACRS
Test::MyClassPrx::opACRS(const ACRS& iceP_i, ACRS& iceP_o, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<ACRS, ACRS>>(true, this, &MyClassPrx::_iceI_opACRS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::ACRS, ::Test::ACRS>>
Test::MyClassPrx::opACRSAsync(const ACRS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<ACRS, ACRS>>(false, this, &MyClassPrx::_iceI_opACRS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opACRSAsync(const ACRS& iceP_i,
                              ::std::function<void (::Test::ACRS, ::Test::ACRS)> response,
                              ::std::function<void(::std::exception_ptr)> ex,
                              ::std::function<void(bool)> sent,
                              const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<ACRS, ACRS>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<ACRS, ACRS>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opACRS, iceP_i, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opACRS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<ACRS, ACRS>>>& outAsync, const ACRS& iceP_i, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_MyClass_opACRS_name);
    outAsync->invoke(iceC_Test_MyClass_opACRS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
            ostr->writePendingValues();
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<ACRS, ACRS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            istr->readPendingValues();
            return v;
        });
}
/// \endcond

::Test::LCRS
Test::MyClassPrx::opLCRS(const LCRS& iceP_i, LCRS& iceP_o, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<LCRS, LCRS>>(true, this, &MyClassPrx::_iceI_opLCRS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::LCRS, ::Test::LCRS>>
Test::MyClassPrx::opLCRSAsync(const LCRS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<LCRS, LCRS>>(false, this, &MyClassPrx::_iceI_opLCRS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opLCRSAsync(const LCRS& iceP_i,
                              ::std::function<void (::Test::LCRS, ::Test::LCRS)> response,
                              ::std::function<void(::std::exception_ptr)> ex,
                              ::std::function<void(bool)> sent,
                              const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<LCRS, LCRS>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<LCRS, LCRS>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opLCRS, iceP_i, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opLCRS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<LCRS, LCRS>>>& outAsync, const LCRS& iceP_i, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_MyClass_opLCRS_name);
    outAsync->invoke(iceC_Test_MyClass_opLCRS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
            ostr->writePendingValues();
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<LCRS, LCRS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            istr->readPendingValues();
            return v;
        });
}
/// \endcond

::Test::AEnS
Test::MyClassPrx::opAEnS(const AEnS& iceP_i, AEnS& iceP_o, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<AEnS, AEnS>>(true, this, &MyClassPrx::_iceI_opAEnS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::AEnS, ::Test::AEnS>>
Test::MyClassPrx::opAEnSAsync(const AEnS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<AEnS, AEnS>>(false, this, &MyClassPrx::_iceI_opAEnS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opAEnSAsync(const AEnS& iceP_i,
                              ::std::function<void (::Test::AEnS, ::Test::AEnS)> response,
                              ::std::function<void(::std::exception_ptr)> ex,
                              ::std::function<void(bool)> sent,
                              const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<AEnS, AEnS>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<AEnS, AEnS>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opAEnS, iceP_i, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opAEnS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<AEnS, AEnS>>>& outAsync, const AEnS& iceP_i, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_MyClass_opAEnS_name);
    outAsync->invoke(iceC_Test_MyClass_opAEnS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<AEnS, AEnS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::LEnS
Test::MyClassPrx::opLEnS(const LEnS& iceP_i, LEnS& iceP_o, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<LEnS, LEnS>>(true, this, &MyClassPrx::_iceI_opLEnS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::LEnS, ::Test::LEnS>>
Test::MyClassPrx::opLEnSAsync(const LEnS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<LEnS, LEnS>>(false, this, &MyClassPrx::_iceI_opLEnS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opLEnSAsync(const LEnS& iceP_i,
                              ::std::function<void (::Test::LEnS, ::Test::LEnS)> response,
                              ::std::function<void(::std::exception_ptr)> ex,
                              ::std::function<void(bool)> sent,
                              const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<LEnS, LEnS>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<LEnS, LEnS>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opLEnS, iceP_i, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opLEnS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<LEnS, LEnS>>>& outAsync, const LEnS& iceP_i, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_MyClass_opLEnS_name);
    outAsync->invoke(iceC_Test_MyClass_opLEnS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<LEnS, LEnS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::KEnS
Test::MyClassPrx::opKEnS(const KEnS& iceP_i, KEnS& iceP_o, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<KEnS, KEnS>>(true, this, &MyClassPrx::_iceI_opKEnS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::KEnS, ::Test::KEnS>>
Test::MyClassPrx::opKEnSAsync(const KEnS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<KEnS, KEnS>>(false, this, &MyClassPrx::_iceI_opKEnS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opKEnSAsync(const KEnS& iceP_i,
                              ::std::function<void (::Test::KEnS, ::Test::KEnS)> response,
                              ::std::function<void(::std::exception_ptr)> ex,
                              ::std::function<void(bool)> sent,
                              const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<KEnS, KEnS>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<KEnS, KEnS>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opKEnS, iceP_i, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opKEnS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<KEnS, KEnS>>>& outAsync, const KEnS& iceP_i, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_MyClass_opKEnS_name);
    outAsync->invoke(iceC_Test_MyClass_opKEnS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<KEnS, KEnS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::QEnS
Test::MyClassPrx::opQEnS(const QEnS& iceP_i, QEnS& iceP_o, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<QEnS, QEnS>>(true, this, &MyClassPrx::_iceI_opQEnS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::QEnS, ::Test::QEnS>>
Test::MyClassPrx::opQEnSAsync(const QEnS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<QEnS, QEnS>>(false, this, &MyClassPrx::_iceI_opQEnS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opQEnSAsync(const QEnS& iceP_i,
                              ::std::function<void (::Test::QEnS, ::Test::QEnS)> response,
                              ::std::function<void(::std::exception_ptr)> ex,
                              ::std::function<void(bool)> sent,
                              const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<QEnS, QEnS>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<QEnS, QEnS>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opQEnS, iceP_i, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opQEnS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<QEnS, QEnS>>>& outAsync, const QEnS& iceP_i, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_MyClass_opQEnS_name);
    outAsync->invoke(iceC_Test_MyClass_opQEnS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<QEnS, QEnS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::SEnS
Test::MyClassPrx::opSEnS(const SEnS& iceP_i, SEnS& iceP_o, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<SEnS, SEnS>>(true, this, &MyClassPrx::_iceI_opSEnS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::SEnS, ::Test::SEnS>>
Test::MyClassPrx::opSEnSAsync(const SEnS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<SEnS, SEnS>>(false, this, &MyClassPrx::_iceI_opSEnS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opSEnSAsync(const SEnS& iceP_i,
                              ::std::function<void (::Test::SEnS, ::Test::SEnS)> response,
                              ::std::function<void(::std::exception_ptr)> ex,
                              ::std::function<void(bool)> sent,
                              const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<SEnS, SEnS>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<SEnS, SEnS>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opSEnS, iceP_i, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opSEnS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<SEnS, SEnS>>>& outAsync, const SEnS& iceP_i, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_MyClass_opSEnS_name);
    outAsync->invoke(iceC_Test_MyClass_opSEnS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<SEnS, SEnS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::AIPrxS
Test::MyClassPrx::opAIPrxS(const AIPrxS& iceP_i, AIPrxS& iceP_o, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<AIPrxS, AIPrxS>>(true, this, &MyClassPrx::_iceI_opAIPrxS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::AIPrxS, ::Test::AIPrxS>>
Test::MyClassPrx::opAIPrxSAsync(const AIPrxS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<AIPrxS, AIPrxS>>(false, this, &MyClassPrx::_iceI_opAIPrxS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opAIPrxSAsync(const AIPrxS& iceP_i,
                                ::std::function<void (::Test::AIPrxS, ::Test::AIPrxS)> response,
                                ::std::function<void(::std::exception_ptr)> ex,
                                ::std::function<void(bool)> sent,
                                const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<AIPrxS, AIPrxS>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<AIPrxS, AIPrxS>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opAIPrxS, iceP_i, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opAIPrxS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<AIPrxS, AIPrxS>>>& outAsync, const AIPrxS& iceP_i, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_MyClass_opAIPrxS_name);
    outAsync->invoke(iceC_Test_MyClass_opAIPrxS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<AIPrxS, AIPrxS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::LIPrxS
Test::MyClassPrx::opLIPrxS(const LIPrxS& iceP_i, LIPrxS& iceP_o, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<LIPrxS, LIPrxS>>(true, this, &MyClassPrx::_iceI_opLIPrxS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::LIPrxS, ::Test::LIPrxS>>
Test::MyClassPrx::opLIPrxSAsync(const LIPrxS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<LIPrxS, LIPrxS>>(false, this, &MyClassPrx::_iceI_opLIPrxS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opLIPrxSAsync(const LIPrxS& iceP_i,
                                ::std::function<void (::Test::LIPrxS, ::Test::LIPrxS)> response,
                                ::std::function<void(::std::exception_ptr)> ex,
                                ::std::function<void(bool)> sent,
                                const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<LIPrxS, LIPrxS>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<LIPrxS, LIPrxS>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opLIPrxS, iceP_i, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opLIPrxS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<LIPrxS, LIPrxS>>>& outAsync, const LIPrxS& iceP_i, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_MyClass_opLIPrxS_name);
    outAsync->invoke(iceC_Test_MyClass_opLIPrxS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<LIPrxS, LIPrxS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::KIPrxS
Test::MyClassPrx::opKIPrxS(const KIPrxS& iceP_i, KIPrxS& iceP_o, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<KIPrxS, KIPrxS>>(true, this, &MyClassPrx::_iceI_opKIPrxS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::KIPrxS, ::Test::KIPrxS>>
Test::MyClassPrx::opKIPrxSAsync(const KIPrxS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<KIPrxS, KIPrxS>>(false, this, &MyClassPrx::_iceI_opKIPrxS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opKIPrxSAsync(const KIPrxS& iceP_i,
                                ::std::function<void (::Test::KIPrxS, ::Test::KIPrxS)> response,
                                ::std::function<void(::std::exception_ptr)> ex,
                                ::std::function<void(bool)> sent,
                                const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<KIPrxS, KIPrxS>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<KIPrxS, KIPrxS>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opKIPrxS, iceP_i, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opKIPrxS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<KIPrxS, KIPrxS>>>& outAsync, const KIPrxS& iceP_i, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_MyClass_opKIPrxS_name);
    outAsync->invoke(iceC_Test_MyClass_opKIPrxS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<KIPrxS, KIPrxS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::QIPrxS
Test::MyClassPrx::opQIPrxS(const QIPrxS& iceP_i, QIPrxS& iceP_o, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<QIPrxS, QIPrxS>>(true, this, &MyClassPrx::_iceI_opQIPrxS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::QIPrxS, ::Test::QIPrxS>>
Test::MyClassPrx::opQIPrxSAsync(const QIPrxS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<QIPrxS, QIPrxS>>(false, this, &MyClassPrx::_iceI_opQIPrxS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opQIPrxSAsync(const QIPrxS& iceP_i,
                                ::std::function<void (::Test::QIPrxS, ::Test::QIPrxS)> response,
                                ::std::function<void(::std::exception_ptr)> ex,
                                ::std::function<void(bool)> sent,
                                const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<QIPrxS, QIPrxS>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<QIPrxS, QIPrxS>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opQIPrxS, iceP_i, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opQIPrxS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<QIPrxS, QIPrxS>>>& outAsync, const QIPrxS& iceP_i, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_MyClass_opQIPrxS_name);
    outAsync->invoke(iceC_Test_MyClass_opQIPrxS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<QIPrxS, QIPrxS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::SIPrxS
Test::MyClassPrx::opSIPrxS(const SIPrxS& iceP_i, SIPrxS& iceP_o, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<SIPrxS, SIPrxS>>(true, this, &MyClassPrx::_iceI_opSIPrxS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::SIPrxS, ::Test::SIPrxS>>
Test::MyClassPrx::opSIPrxSAsync(const SIPrxS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<SIPrxS, SIPrxS>>(false, this, &MyClassPrx::_iceI_opSIPrxS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opSIPrxSAsync(const SIPrxS& iceP_i,
                                ::std::function<void (::Test::SIPrxS, ::Test::SIPrxS)> response,
                                ::std::function<void(::std::exception_ptr)> ex,
                                ::std::function<void(bool)> sent,
                                const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<SIPrxS, SIPrxS>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<SIPrxS, SIPrxS>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opSIPrxS, iceP_i, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opSIPrxS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<SIPrxS, SIPrxS>>>& outAsync, const SIPrxS& iceP_i, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_MyClass_opSIPrxS_name);
    outAsync->invoke(iceC_Test_MyClass_opSIPrxS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<SIPrxS, SIPrxS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::CustomIntS
Test::MyClassPrx::opCustomIntS(const CustomIntS& iceP_i, CustomIntS& iceP_o, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<CustomIntS, CustomIntS>>(true, this, &MyClassPrx::_iceI_opCustomIntS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::CustomIntS, ::Test::CustomIntS>>
Test::MyClassPrx::opCustomIntSAsync(const CustomIntS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<CustomIntS, CustomIntS>>(false, this, &MyClassPrx::_iceI_opCustomIntS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opCustomIntSAsync(const CustomIntS& iceP_i,
                                    ::std::function<void (::Test::CustomIntS, ::Test::CustomIntS)> response,
                                    ::std::function<void(::std::exception_ptr)> ex,
                                    ::std::function<void(bool)> sent,
                                    const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<CustomIntS, CustomIntS>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<CustomIntS, CustomIntS>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opCustomIntS, iceP_i, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opCustomIntS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<CustomIntS, CustomIntS>>>& outAsync, const CustomIntS& iceP_i, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_MyClass_opCustomIntS_name);
    outAsync->invoke(iceC_Test_MyClass_opCustomIntS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<CustomIntS, CustomIntS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::CustomCVS
Test::MyClassPrx::opCustomCVS(const CustomCVS& iceP_i, CustomCVS& iceP_o, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<CustomCVS, CustomCVS>>(true, this, &MyClassPrx::_iceI_opCustomCVS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::CustomCVS, ::Test::CustomCVS>>
Test::MyClassPrx::opCustomCVSAsync(const CustomCVS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<CustomCVS, CustomCVS>>(false, this, &MyClassPrx::_iceI_opCustomCVS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opCustomCVSAsync(const CustomCVS& iceP_i,
                                   ::std::function<void (::Test::CustomCVS, ::Test::CustomCVS)> response,
                                   ::std::function<void(::std::exception_ptr)> ex,
                                   ::std::function<void(bool)> sent,
                                   const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<CustomCVS, CustomCVS>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<CustomCVS, CustomCVS>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opCustomCVS, iceP_i, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opCustomCVS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<CustomCVS, CustomCVS>>>& outAsync, const CustomCVS& iceP_i, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_MyClass_opCustomCVS_name);
    outAsync->invoke(iceC_Test_MyClass_opCustomCVS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
            ostr->writePendingValues();
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<CustomCVS, CustomCVS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            istr->readPendingValues();
            return v;
        });
}
/// \endcond

::Test::CustomIntSS
Test::MyClassPrx::opCustomIntSS(const CustomIntSS& iceP_i, CustomIntSS& iceP_o, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<CustomIntSS, CustomIntSS>>(true, this, &MyClassPrx::_iceI_opCustomIntSS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::CustomIntSS, ::Test::CustomIntSS>>
Test::MyClassPrx::opCustomIntSSAsync(const CustomIntSS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<CustomIntSS, CustomIntSS>>(false, this, &MyClassPrx::_iceI_opCustomIntSS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opCustomIntSSAsync(const CustomIntSS& iceP_i,
                                     ::std::function<void (::Test::CustomIntSS, ::Test::CustomIntSS)> response,
                                     ::std::function<void(::std::exception_ptr)> ex,
                                     ::std::function<void(bool)> sent,
                                     const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<CustomIntSS, CustomIntSS>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<CustomIntSS, CustomIntSS>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opCustomIntSS, iceP_i, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opCustomIntSS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<CustomIntSS, CustomIntSS>>>& outAsync, const CustomIntSS& iceP_i, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_MyClass_opCustomIntSS_name);
    outAsync->invoke(iceC_Test_MyClass_opCustomIntSS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<CustomIntSS, CustomIntSS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            return v;
        });
}
/// \endcond

::Test::CustomCVSS
Test::MyClassPrx::opCustomCVSS(const CustomCVSS& iceP_i, CustomCVSS& iceP_o, const ::Ice::Context& context) const
{
    auto _result = ::IceInternal::makePromiseOutgoing<::std::tuple<CustomCVSS, CustomCVSS>>(true, this, &MyClassPrx::_iceI_opCustomCVSS, iceP_i, context).get();
    iceP_o = ::std::move(::std::get<1>(_result));
    return ::std::move(::std::get<0>(_result));
}

::std::future<::std::tuple<::Test::CustomCVSS, ::Test::CustomCVSS>>
Test::MyClassPrx::opCustomCVSSAsync(const CustomCVSS& iceP_i, const ::Ice::Context& context) const
{
    return ::IceInternal::makePromiseOutgoing<::std::tuple<CustomCVSS, CustomCVSS>>(false, this, &MyClassPrx::_iceI_opCustomCVSS, iceP_i, context);
}

::std::function<void()>
Test::MyClassPrx::opCustomCVSSAsync(const CustomCVSS& iceP_i,
                                    ::std::function<void (::Test::CustomCVSS, ::Test::CustomCVSS)> response,
                                    ::std::function<void(::std::exception_ptr)> ex,
                                    ::std::function<void(bool)> sent,
                                    const ::Ice::Context& context) const
{
    auto _responseCb = [response](::std::tuple<CustomCVSS, CustomCVSS>&& _result)
    {
        response(::std::move(::std::get<0>(_result)), ::std::move(::std::get<1>(_result)));
    };
    return ::IceInternal::makeLambdaOutgoing<::std::tuple<CustomCVSS, CustomCVSS>>(std::move(_responseCb), std::move(ex), std::move(sent), this, &Test::MyClassPrx::_iceI_opCustomCVSS, iceP_i, context);
}

/// \cond INTERNAL
void
Test::MyClassPrx::_iceI_opCustomCVSS(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::tuple<CustomCVSS, CustomCVSS>>>& outAsync, const CustomCVSS& iceP_i, const ::Ice::Context& context) const
{
    _checkTwowayOnly(iceC_Test_MyClass_opCustomCVSS_name);
    outAsync->invoke(iceC_Test_MyClass_opCustomCVSS_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_i);
            ostr->writePendingValues();
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ::std::tuple<CustomCVSS, CustomCVSS> v;
            istr->readAll(::std::get<1>(v), ::std::get<0>(v));
            istr->readPendingValues();
            return v;
        });
}
/// \endcond

const ::std::string&
Test::MyClassPrx::ice_staticId()
{
    static const ::std::string typeId = "::Test::MyClass";
    return typeId;
}

Test::CV::~CV()
{
}

const ::std::string&
Test::CV::ice_staticId()
{
    static const ::std::string typeId = "::Test::CV";
    return typeId;
}

Test::CR::~CR()
{
}

const ::std::string&
Test::CR::ice_staticId()
{
    static const ::std::string typeId = "::Test::CR";
    return typeId;
}

bool
Test::I::ice_isA(::std::string s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_I_ids, iceC_Test_I_ids + 2, s);
}

::std::vector<::std::string>
Test::I::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector<::std::string>(&iceC_Test_I_ids[0], &iceC_Test_I_ids[2]);
}

::std::string
Test::I::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::I::ice_staticId()
{
    static const ::std::string typeId = "::Test::I";
    return typeId;
}

bool
Test::MyClass::ice_isA(::std::string s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Test_MyClass_ids, iceC_Test_MyClass_ids + 2, s);
}

::std::vector<::std::string>
Test::MyClass::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector<::std::string>(&iceC_Test_MyClass_ids[0], &iceC_Test_MyClass_ids[2]);
}

::std::string
Test::MyClass::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Test::MyClass::ice_staticId()
{
    static const ::std::string typeId = "::Test::MyClass";
    return typeId;
}

/// \cond INTERNAL
bool
Test::MyClass::_iceD_shutdown(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    this->shutdown(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opAByteS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    AByteS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    AByteS iceP_o;
    AByteS ret = this->opAByteS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opLByteS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    LByteS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    LByteS iceP_o;
    LByteS ret = this->opLByteS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opKByteS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    KByteS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    KByteS iceP_o;
    KByteS ret = this->opKByteS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opQByteS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    QByteS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    QByteS iceP_o;
    QByteS ret = this->opQByteS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opSByteS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    SByteS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    SByteS iceP_o;
    SByteS ret = this->opSByteS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opABoolS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ABoolS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    ABoolS iceP_o;
    ABoolS ret = this->opABoolS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opLBoolS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    LBoolS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    LBoolS iceP_o;
    LBoolS ret = this->opLBoolS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opKBoolS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    KBoolS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    KBoolS iceP_o;
    KBoolS ret = this->opKBoolS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opQBoolS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    QBoolS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    QBoolS iceP_o;
    QBoolS ret = this->opQBoolS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opSBoolS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    SBoolS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    SBoolS iceP_o;
    SBoolS ret = this->opSBoolS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opAShortS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    AShortS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    AShortS iceP_o;
    AShortS ret = this->opAShortS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opLShortS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    LShortS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    LShortS iceP_o;
    LShortS ret = this->opLShortS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opKShortS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    KShortS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    KShortS iceP_o;
    KShortS ret = this->opKShortS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opQShortS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    QShortS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    QShortS iceP_o;
    QShortS ret = this->opQShortS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opSShortS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    SShortS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    SShortS iceP_o;
    SShortS ret = this->opSShortS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opAIntS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    AIntS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    AIntS iceP_o;
    AIntS ret = this->opAIntS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opLIntS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    LIntS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    LIntS iceP_o;
    LIntS ret = this->opLIntS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opKIntS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    KIntS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    KIntS iceP_o;
    KIntS ret = this->opKIntS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opQIntS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    QIntS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    QIntS iceP_o;
    QIntS ret = this->opQIntS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opSIntS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    SIntS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    SIntS iceP_o;
    SIntS ret = this->opSIntS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opALongS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ALongS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    ALongS iceP_o;
    ALongS ret = this->opALongS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opLLongS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    LLongS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    LLongS iceP_o;
    LLongS ret = this->opLLongS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opKLongS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    KLongS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    KLongS iceP_o;
    KLongS ret = this->opKLongS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opQLongS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    QLongS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    QLongS iceP_o;
    QLongS ret = this->opQLongS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opSLongS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    SLongS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    SLongS iceP_o;
    SLongS ret = this->opSLongS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opAFloatS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    AFloatS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    AFloatS iceP_o;
    AFloatS ret = this->opAFloatS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opLFloatS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    LFloatS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    LFloatS iceP_o;
    LFloatS ret = this->opLFloatS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opKFloatS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    KFloatS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    KFloatS iceP_o;
    KFloatS ret = this->opKFloatS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opQFloatS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    QFloatS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    QFloatS iceP_o;
    QFloatS ret = this->opQFloatS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opSFloatS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    SFloatS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    SFloatS iceP_o;
    SFloatS ret = this->opSFloatS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opADoubleS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ADoubleS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    ADoubleS iceP_o;
    ADoubleS ret = this->opADoubleS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opLDoubleS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    LDoubleS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    LDoubleS iceP_o;
    LDoubleS ret = this->opLDoubleS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opKDoubleS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    KDoubleS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    KDoubleS iceP_o;
    KDoubleS ret = this->opKDoubleS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opQDoubleS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    QDoubleS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    QDoubleS iceP_o;
    QDoubleS ret = this->opQDoubleS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opSDoubleS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    SDoubleS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    SDoubleS iceP_o;
    SDoubleS ret = this->opSDoubleS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opAStringS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    AStringS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    AStringS iceP_o;
    AStringS ret = this->opAStringS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opLStringS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    LStringS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    LStringS iceP_o;
    LStringS ret = this->opLStringS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opKStringS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    KStringS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    KStringS iceP_o;
    KStringS ret = this->opKStringS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opQStringS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    QStringS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    QStringS iceP_o;
    QStringS ret = this->opQStringS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opSStringS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    SStringS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    SStringS iceP_o;
    SStringS ret = this->opSStringS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opAObjectS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    AObjectS iceP_i;
    istr->readAll(iceP_i);
    istr->readPendingValues();
    inS.endReadParams();
    AObjectS iceP_o;
    AObjectS ret = this->opAObjectS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opLObjectS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    LObjectS iceP_i;
    istr->readAll(iceP_i);
    istr->readPendingValues();
    inS.endReadParams();
    LObjectS iceP_o;
    LObjectS ret = this->opLObjectS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opAObjectPrxS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    AObjectPrxS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    AObjectPrxS iceP_o;
    AObjectPrxS ret = this->opAObjectPrxS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opLObjectPrxS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    LObjectPrxS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    LObjectPrxS iceP_o;
    LObjectPrxS ret = this->opLObjectPrxS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opKObjectPrxS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    KObjectPrxS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    KObjectPrxS iceP_o;
    KObjectPrxS ret = this->opKObjectPrxS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opQObjectPrxS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    QObjectPrxS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    QObjectPrxS iceP_o;
    QObjectPrxS ret = this->opQObjectPrxS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opSObjectPrxS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    SObjectPrxS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    SObjectPrxS iceP_o;
    SObjectPrxS ret = this->opSObjectPrxS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opAStructS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    AStructS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    AStructS iceP_o;
    AStructS ret = this->opAStructS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opLStructS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    LStructS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    LStructS iceP_o;
    LStructS ret = this->opLStructS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opKStructS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    KStructS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    KStructS iceP_o;
    KStructS ret = this->opKStructS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opQStructS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    QStructS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    QStructS iceP_o;
    QStructS ret = this->opQStructS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opSStructS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    SStructS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    SStructS iceP_o;
    SStructS ret = this->opSStructS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opAStructSD(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    AStructSD iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    AStructSD iceP_o;
    AStructSD ret = this->opAStructSD(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opLStructSD(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    LStructSD iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    LStructSD iceP_o;
    LStructSD ret = this->opLStructSD(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opKStructSD(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    KStructSD iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    KStructSD iceP_o;
    KStructSD ret = this->opKStructSD(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opQStructSD(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    QStructSD iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    QStructSD iceP_o;
    QStructSD ret = this->opQStructSD(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opSStructSD(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    SStructSD iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    SStructSD iceP_o;
    SStructSD ret = this->opSStructSD(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opACVS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ACVS iceP_i;
    istr->readAll(iceP_i);
    istr->readPendingValues();
    inS.endReadParams();
    ACVS iceP_o;
    ACVS ret = this->opACVS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opLCVS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    LCVS iceP_i;
    istr->readAll(iceP_i);
    istr->readPendingValues();
    inS.endReadParams();
    LCVS iceP_o;
    LCVS ret = this->opLCVS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opACRS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ACRS iceP_i;
    istr->readAll(iceP_i);
    istr->readPendingValues();
    inS.endReadParams();
    ACRS iceP_o;
    ACRS ret = this->opACRS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opLCRS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    LCRS iceP_i;
    istr->readAll(iceP_i);
    istr->readPendingValues();
    inS.endReadParams();
    LCRS iceP_o;
    LCRS ret = this->opLCRS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opAEnS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    AEnS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    AEnS iceP_o;
    AEnS ret = this->opAEnS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opLEnS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    LEnS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    LEnS iceP_o;
    LEnS ret = this->opLEnS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opKEnS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    KEnS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    KEnS iceP_o;
    KEnS ret = this->opKEnS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opQEnS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    QEnS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    QEnS iceP_o;
    QEnS ret = this->opQEnS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opSEnS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    SEnS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    SEnS iceP_o;
    SEnS ret = this->opSEnS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opAIPrxS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    AIPrxS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    AIPrxS iceP_o;
    AIPrxS ret = this->opAIPrxS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opLIPrxS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    LIPrxS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    LIPrxS iceP_o;
    LIPrxS ret = this->opLIPrxS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opKIPrxS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    KIPrxS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    KIPrxS iceP_o;
    KIPrxS ret = this->opKIPrxS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opQIPrxS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    QIPrxS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    QIPrxS iceP_o;
    QIPrxS ret = this->opQIPrxS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opSIPrxS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    SIPrxS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    SIPrxS iceP_o;
    SIPrxS ret = this->opSIPrxS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opCustomIntS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    CustomIntS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    CustomIntS iceP_o;
    CustomIntS ret = this->opCustomIntS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opCustomCVS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    CustomCVS iceP_i;
    istr->readAll(iceP_i);
    istr->readPendingValues();
    inS.endReadParams();
    CustomCVS iceP_o;
    CustomCVS ret = this->opCustomCVS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opCustomIntSS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    CustomIntSS iceP_i;
    istr->readAll(iceP_i);
    inS.endReadParams();
    CustomIntSS iceP_o;
    CustomIntSS ret = this->opCustomIntSS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceD_opCustomCVSS(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    CustomCVSS iceP_i;
    istr->readAll(iceP_i);
    istr->readPendingValues();
    inS.endReadParams();
    CustomCVSS iceP_o;
    CustomCVSS ret = this->opCustomCVSS(::std::move(iceP_i), iceP_o, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_o, ret);
    ostr->writePendingValues();
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Test::MyClass::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_Test_MyClass_ops, iceC_Test_MyClass_ops + 80, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_Test_MyClass_ops)
    {
        case 0:
        {
            return _iceD_ice_id(in, current);
        }
        case 1:
        {
            return _iceD_ice_ids(in, current);
        }
        case 2:
        {
            return _iceD_ice_isA(in, current);
        }
        case 3:
        {
            return _iceD_ice_ping(in, current);
        }
        case 4:
        {
            return _iceD_opABoolS(in, current);
        }
        case 5:
        {
            return _iceD_opAByteS(in, current);
        }
        case 6:
        {
            return _iceD_opACRS(in, current);
        }
        case 7:
        {
            return _iceD_opACVS(in, current);
        }
        case 8:
        {
            return _iceD_opADoubleS(in, current);
        }
        case 9:
        {
            return _iceD_opAEnS(in, current);
        }
        case 10:
        {
            return _iceD_opAFloatS(in, current);
        }
        case 11:
        {
            return _iceD_opAIPrxS(in, current);
        }
        case 12:
        {
            return _iceD_opAIntS(in, current);
        }
        case 13:
        {
            return _iceD_opALongS(in, current);
        }
        case 14:
        {
            return _iceD_opAObjectPrxS(in, current);
        }
        case 15:
        {
            return _iceD_opAObjectS(in, current);
        }
        case 16:
        {
            return _iceD_opAShortS(in, current);
        }
        case 17:
        {
            return _iceD_opAStringS(in, current);
        }
        case 18:
        {
            return _iceD_opAStructS(in, current);
        }
        case 19:
        {
            return _iceD_opAStructSD(in, current);
        }
        case 20:
        {
            return _iceD_opCustomCVS(in, current);
        }
        case 21:
        {
            return _iceD_opCustomCVSS(in, current);
        }
        case 22:
        {
            return _iceD_opCustomIntS(in, current);
        }
        case 23:
        {
            return _iceD_opCustomIntSS(in, current);
        }
        case 24:
        {
            return _iceD_opKBoolS(in, current);
        }
        case 25:
        {
            return _iceD_opKByteS(in, current);
        }
        case 26:
        {
            return _iceD_opKDoubleS(in, current);
        }
        case 27:
        {
            return _iceD_opKEnS(in, current);
        }
        case 28:
        {
            return _iceD_opKFloatS(in, current);
        }
        case 29:
        {
            return _iceD_opKIPrxS(in, current);
        }
        case 30:
        {
            return _iceD_opKIntS(in, current);
        }
        case 31:
        {
            return _iceD_opKLongS(in, current);
        }
        case 32:
        {
            return _iceD_opKObjectPrxS(in, current);
        }
        case 33:
        {
            return _iceD_opKShortS(in, current);
        }
        case 34:
        {
            return _iceD_opKStringS(in, current);
        }
        case 35:
        {
            return _iceD_opKStructS(in, current);
        }
        case 36:
        {
            return _iceD_opKStructSD(in, current);
        }
        case 37:
        {
            return _iceD_opLBoolS(in, current);
        }
        case 38:
        {
            return _iceD_opLByteS(in, current);
        }
        case 39:
        {
            return _iceD_opLCRS(in, current);
        }
        case 40:
        {
            return _iceD_opLCVS(in, current);
        }
        case 41:
        {
            return _iceD_opLDoubleS(in, current);
        }
        case 42:
        {
            return _iceD_opLEnS(in, current);
        }
        case 43:
        {
            return _iceD_opLFloatS(in, current);
        }
        case 44:
        {
            return _iceD_opLIPrxS(in, current);
        }
        case 45:
        {
            return _iceD_opLIntS(in, current);
        }
        case 46:
        {
            return _iceD_opLLongS(in, current);
        }
        case 47:
        {
            return _iceD_opLObjectPrxS(in, current);
        }
        case 48:
        {
            return _iceD_opLObjectS(in, current);
        }
        case 49:
        {
            return _iceD_opLShortS(in, current);
        }
        case 50:
        {
            return _iceD_opLStringS(in, current);
        }
        case 51:
        {
            return _iceD_opLStructS(in, current);
        }
        case 52:
        {
            return _iceD_opLStructSD(in, current);
        }
        case 53:
        {
            return _iceD_opQBoolS(in, current);
        }
        case 54:
        {
            return _iceD_opQByteS(in, current);
        }
        case 55:
        {
            return _iceD_opQDoubleS(in, current);
        }
        case 56:
        {
            return _iceD_opQEnS(in, current);
        }
        case 57:
        {
            return _iceD_opQFloatS(in, current);
        }
        case 58:
        {
            return _iceD_opQIPrxS(in, current);
        }
        case 59:
        {
            return _iceD_opQIntS(in, current);
        }
        case 60:
        {
            return _iceD_opQLongS(in, current);
        }
        case 61:
        {
            return _iceD_opQObjectPrxS(in, current);
        }
        case 62:
        {
            return _iceD_opQShortS(in, current);
        }
        case 63:
        {
            return _iceD_opQStringS(in, current);
        }
        case 64:
        {
            return _iceD_opQStructS(in, current);
        }
        case 65:
        {
            return _iceD_opQStructSD(in, current);
        }
        case 66:
        {
            return _iceD_opSBoolS(in, current);
        }
        case 67:
        {
            return _iceD_opSByteS(in, current);
        }
        case 68:
        {
            return _iceD_opSDoubleS(in, current);
        }
        case 69:
        {
            return _iceD_opSEnS(in, current);
        }
        case 70:
        {
            return _iceD_opSFloatS(in, current);
        }
        case 71:
        {
            return _iceD_opSIPrxS(in, current);
        }
        case 72:
        {
            return _iceD_opSIntS(in, current);
        }
        case 73:
        {
            return _iceD_opSLongS(in, current);
        }
        case 74:
        {
            return _iceD_opSObjectPrxS(in, current);
        }
        case 75:
        {
            return _iceD_opSShortS(in, current);
        }
        case 76:
        {
            return _iceD_opSStringS(in, current);
        }
        case 77:
        {
            return _iceD_opSStructS(in, current);
        }
        case 78:
        {
            return _iceD_opSStructSD(in, current);
        }
        case 79:
        {
            return _iceD_shutdown(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond
